
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass.exe --m65c02 --nostart -Wall -q --case-sensitive --line-numbers --verbose-list -Lbuild/mos350.lst --output-section mos -o build/350/mos.rom --output-section utils -o build/350/utils.rom --output-section ext -o build/350/ext.rom mos350.s65
; Tue Jan 02 20:24:18 2024

;Line	;Offset	;PC	;Hex		;Monitor	;Source

:1	;******  Processing input file: mos350.s65

1							                .include "src/hardware.s65"

:2	;******  Processing file: src/hardware.s65

1							;-------------------------------------------------------------------------

3							                .virtual $fe00

5	.fe00						CRTC: .block

7							                .virtual 8
8	.0008						R8: .block
9	=$00						normalSync=%00000000
10	=$01						interlaceSync=%00000001
11	=$02						normalSyncAlt=%00000010
12	=$03						interlaceSyncAndVideo=%00000011

14	=0						displayDelay0=0<<4
15	=16						displayDelay1=1<<4
16	=32						displayDelay2=2<<4
17	=48						displayDisable=3<<4

19	=0						cursorDelay0=0<<6
20	=64						cursorDelay1=1<<6
21	=128						cursorDelay2=2<<6
22	=192						cursorDisable=3<<6
23							                .endblock
24							                .endvirtual

26							                .virtual 10
27	.000a						R10: .block
28	=$40						blink=$40
29	=$20						slowBlink=$20
30							                .endblock
31							                .endvirtual

33							                .endblock

35							                .endvirtual

37							;-------------------------------------------------------------------------
38							; ACIA=$fe08
39	=$fe10						SERPROC=$fe10
40							;HADC=$fe18
41							                .if includeTubeSupport
42	=$fee0						TUBE=$fee0
43							                .endif
44	=$fe30						ROMSEL=$fe30
45							;ACCCON=$fe34
46							                .virtual $fe20
47	.fe20						VCONTROL: .block
48	=$01						flash=$01
49	=$02						isTeletext=$02
50	=$00						shift2MHz=$00
51	=$04						shift4MHz=$04
52	=$08						shift8MHz=$08
53	=$0c						shift16MHz=$0c
54	=$00						crtc1MHz=$00
55	=$10						crtc2MHz=$10
56	=$00						cursor____=$00
57	=$20						cursor__XX=$20
58	=$40						cursor_X__=$40
59	=$60						cursor_XXX=$60
60	=$80						cursorX___=$80
61	=$a0						cursorX_XX=$a0
62	=$c0						cursorXX__=$c0
63	=$e0						cursorXXXX=$e0
64							                .endblock
65							                .endvirtual
66	=$fe21						VPALETTE=$fe21

68							;-------------------------------------------------------------------------

70							                .virtual $fe08
71	.fe08						ACIA: .block

73	.fe08						control: .block
74	=0						counterDivide1=0<<0
75	=1						counterDivide16=1<<0
76	=2						counterDivide64=2<<0
77	=3						reset=3<<0

79	=0						word7DataEventParity2Stop=0<<2
80	=4						word7DataOddParity2Stop=1<<2
81	=8						word7DataEvenParity1Stop=2<<2
82	=12						word7DataOddParity1Stop=3<<2
83	=16						word8DataNoParity2Stop=4<<2
84	=20						word8DataNoParity1Stop=5<<2
85	=24						word8DataEvenParity1Stop=6<<2
86	=28						word8DataOddParity1Stop=7<<2

88	=0						rtsLowTXInterruptDisabled=0<<5
89	=32						rtsLowTXInterruptEnabled=1<<5
90	=64						rtsHighTXInterruptDisabled=2<<5
91	=96						rtsLowBreakTXInterruptDisabled=3<<5

93	=0						rtsRXInterruptDisabled=0<<7
94	=128						rtsRTSInterruptEnabled=1<<7

96							                .endblock
97	.fe08						status: .block
98							                .endblock

100	>fe08						                .fill 1
101	.fe09						tdr:
102	.fe09						rdr:
103	>fe09						                .fill 1
104							                .endblock
105							                .endvirtual

107							;-------------------------------------------------------------------------

109							                .virtual $fe18
110	.fe18						HADC: .block
111	.fe18						status: .block
112							                .endblock
113	.fe18						latch: .block
114							                .endblock
115	>fe18						                .fill 1

117							                .endblock
118							                .endvirtual

120							;-------------------------------------------------------------------------

122							                .virtual $fe34
123	.fe34						ACCCON: .block
124							;D=1 = display shadow RAM; D=0 = display main RAM
125	=$01						D=$01

127							;E=1 = VDU code ($c000-$dfff in MOS ROM) accesses shadow RAM; E=0 =
128							;VDU code accesses main RAM
129	=$02						E=$02

131							;X=1 = shadow RAM at $3000; X=0 = main RAM at $3000
132	=$04						X=$04

134							;Y=1 = HAZEL at $c000; Y=0 = MOS ROM at $c000
135	=$08						Y=$08

137							;ITU=1 = access internal Tube; ITU=0 = access external Tube
138	=$10						ITU=$10

140							;IFJ=1 = $fc00...$fdff accesses cartridge; IFJ=0 = $fc00...$fdff
141							;accesses 1MHz bus
142	=$20						IFJ=$20

144							; TST=1 = read MOS ROM at $fc00...$feff; TST=0 = read I/O at
145							; $fc00...$feff
146	=$40						TST=$40

148							;IRR=1 = IRQ to CPU
149	=$80						IRR=$80
150							                .bend
151							                .endv

153							                VIA: .struct                    ;
154	.0000						orb:
155	.0000						irb:
156	>0000						                .fill 1         ;0
157	.0001						ora:
158	.0001						ira:
159	>0001						                .fill 1         ;1
160	.0002						ddrb:
161	>0002						                .fill 1         ;2
162	.0003						ddra:
163	>0003						                .fill 1         ;3
164	.0004						t1cL:
165	>0004						                .fill 1         ;4
166	.0005						t1cH:
167	>0005						                .fill 1         ;5
168	.0006						t1lL:
169	>0006						                .fill 1         ;6
170	.0007						t1lH:
171	>0007						                .fill 1         ;7
172	.0008						t2cL:
173	>0008						                .fill 1         ;8
174	.0009						t2cH:
175	>0009						                .fill 1         ;9
176	.000a						sr:
177	>000a						                .fill 1         ;10
178	.000b						acr: .block
179	=0						t1OneShot=0<<6
180	=64						t1Continuous=1<<6
181	=128						t1OneShotPB7=2<<6
182	=192						t1ContinuousPB7=3<<6

184	=0						t2Timer=0<<5
185	=32						t2CountPB6=1<<5

187	=0						srDisabled=0<<2
188	=4						srShiftInT2=1<<2
189	=8						srShiftInVIAClock=2<<2
190	=12						srShiftInExtClock=3<<2
191	=16						srShiftOutT2FreeRun=4<<2
192	=20						srShiftOutT2=5<<2
193	=24						srShiftOutVIAClock=6<<2
194	=28						srShiftOutExtClock=7<<2

196	=0						pbLatchDisabled=0<<1
197	=2						pbLatchEnabled=1<<1

199	=0						paLatchDisabled=0<<0
200	=1						paLatchEnabled=1<<0

202	>000b						                .fill 1         ;11
203							                .endblock
204	.000c						pcr: .block

206	=0						cb2InputNegativeActiveEdge=0<<5
207	=32						cb2IndependentInterruptInputNegativeEdge=1<<5
208	=64						cb2InputPositiveEdge=2<<5
209	=96						cb2IndependentInterruptInputPositiveEdge=3<<5
210	=128						cb2HandshakeOutput=4<<5
211	=160						cb2PulseOutput=5<<5
212	=192						cb2LowOutput=6<<5
213	=224						cb2HighOutput=7<<5

215	=0						cb1NegativeActiveEdge=0<<4
216	=16						cb1PositiveActiveEdge=1<<4

218	=0						ca2InputNegativeActiveEdge=0<<1
219	=2						ca2IndependentInterruptInputNegativeEdge=1<<1
220	=4						ca2InputPositiveEdge=2<<1
221	=6						ca2IndependentInterruptInputPositiveEdge=3<<1
222	=8						ca2HandshakeOutput=4<<1
223	=10						ca2PulseOutput=5<<1
224	=12						ca2LowOutput=6<<1
225	=14						ca2HighOutput=7<<1

227	=0						ca1NegativeActiveEdge=0<<0
228	=1						ca1PositiveActiveEdge=1<<0

230	>000c						                .fill 1         ;12
231							                .endblock
232	.000d						ifr:
233	>000d						                .fill 1         ;13
234	.000e						ier:
235	>000e						                .fill 1         ;14
236	.000f						oraNoHandshake:
237	.000f						iraNoHandshake:
238	>000f						                .fill 1         ;15

240	.0010						irq: .block
241	=1						ca2=1
242	=2						ca1=2
243	=4						sr=4
244	=8						cb2=8
245	=16						cb1=16
246	=32						t2=32
247	=64						t1=64
248							                .endblock
249							                .ends

251							; System VIA port B bits for Master Compact
252	=$20						i2cClock=$20
253	=$10						i2cData=$10

255							; PCD8572 command codes

257							;   7   6   5   4   3   2   1   0
258							; +---+---+---+---+---+---+---+---+
259							; | 1 | 0 | 1 | 0 |A2 |A1 |A0 |RnW|
260							; +---+---+---+---+---+---+---+---+

262	=$a1						eepromRead=$a1
263	=$a0						eepromWrite=$a0
264							                                .virtual $fe40
265	.fe40						systemVIA: .dstruct VIA
154	.fe40						orb:
155	.fe40						irb:
156	>fe40						                .fill 1         ;0
157	.fe41						ora:
158	.fe41						ira:
159	>fe41						                .fill 1         ;1
160	.fe42						ddrb:
161	>fe42						                .fill 1         ;2
162	.fe43						ddra:
163	>fe43						                .fill 1         ;3
164	.fe44						t1cL:
165	>fe44						                .fill 1         ;4
166	.fe45						t1cH:
167	>fe45						                .fill 1         ;5
168	.fe46						t1lL:
169	>fe46						                .fill 1         ;6
170	.fe47						t1lH:
171	>fe47						                .fill 1         ;7
172	.fe48						t2cL:
173	>fe48						                .fill 1         ;8
174	.fe49						t2cH:
175	>fe49						                .fill 1         ;9
176	.fe4a						sr:
177	>fe4a						                .fill 1         ;10
178	.fe4b						acr: .block
179	=0						t1OneShot=0<<6
180	=64						t1Continuous=1<<6
181	=128						t1OneShotPB7=2<<6
182	=192						t1ContinuousPB7=3<<6

184	=0						t2Timer=0<<5
185	=32						t2CountPB6=1<<5

187	=0						srDisabled=0<<2
188	=4						srShiftInT2=1<<2
189	=8						srShiftInVIAClock=2<<2
190	=12						srShiftInExtClock=3<<2
191	=16						srShiftOutT2FreeRun=4<<2
192	=20						srShiftOutT2=5<<2
193	=24						srShiftOutVIAClock=6<<2
194	=28						srShiftOutExtClock=7<<2

196	=0						pbLatchDisabled=0<<1
197	=2						pbLatchEnabled=1<<1

199	=0						paLatchDisabled=0<<0
200	=1						paLatchEnabled=1<<0

202	>fe4b						                .fill 1         ;11
203							                .endblock
204	.fe4c						pcr: .block

206	=0						cb2InputNegativeActiveEdge=0<<5
207	=32						cb2IndependentInterruptInputNegativeEdge=1<<5
208	=64						cb2InputPositiveEdge=2<<5
209	=96						cb2IndependentInterruptInputPositiveEdge=3<<5
210	=128						cb2HandshakeOutput=4<<5
211	=160						cb2PulseOutput=5<<5
212	=192						cb2LowOutput=6<<5
213	=224						cb2HighOutput=7<<5

215	=0						cb1NegativeActiveEdge=0<<4
216	=16						cb1PositiveActiveEdge=1<<4

218	=0						ca2InputNegativeActiveEdge=0<<1
219	=2						ca2IndependentInterruptInputNegativeEdge=1<<1
220	=4						ca2InputPositiveEdge=2<<1
221	=6						ca2IndependentInterruptInputPositiveEdge=3<<1
222	=8						ca2HandshakeOutput=4<<1
223	=10						ca2PulseOutput=5<<1
224	=12						ca2LowOutput=6<<1
225	=14						ca2HighOutput=7<<1

227	=0						ca1NegativeActiveEdge=0<<0
228	=1						ca1PositiveActiveEdge=1<<0

230	>fe4c						                .fill 1         ;12
231							                .endblock
232	.fe4d						ifr:
233	>fe4d						                .fill 1         ;13
234	.fe4e						ier:
235	>fe4e						                .fill 1         ;14
236	.fe4f						oraNoHandshake:
237	.fe4f						iraNoHandshake:
238	>fe4f						                .fill 1         ;15

240	.fe50						irq: .block
241	=1						ca2=1
242	=2						ca1=2
243	=4						sr=4
244	=8						cb2=8
245	=16						cb1=16
246	=32						t2=32
247	=64						t1=64
248							                .endblock
249							                .ends
266							                .endv

268							                .virtual $fe60
269	.fe60						userVIA: .dstruct VIA
154	.fe60						orb:
155	.fe60						irb:
156	>fe60						                .fill 1         ;0
157	.fe61						ora:
158	.fe61						ira:
159	>fe61						                .fill 1         ;1
160	.fe62						ddrb:
161	>fe62						                .fill 1         ;2
162	.fe63						ddra:
163	>fe63						                .fill 1         ;3
164	.fe64						t1cL:
165	>fe64						                .fill 1         ;4
166	.fe65						t1cH:
167	>fe65						                .fill 1         ;5
168	.fe66						t1lL:
169	>fe66						                .fill 1         ;6
170	.fe67						t1lH:
171	>fe67						                .fill 1         ;7
172	.fe68						t2cL:
173	>fe68						                .fill 1         ;8
174	.fe69						t2cH:
175	>fe69						                .fill 1         ;9
176	.fe6a						sr:
177	>fe6a						                .fill 1         ;10
178	.fe6b						acr: .block
179	=0						t1OneShot=0<<6
180	=64						t1Continuous=1<<6
181	=128						t1OneShotPB7=2<<6
182	=192						t1ContinuousPB7=3<<6

184	=0						t2Timer=0<<5
185	=32						t2CountPB6=1<<5

187	=0						srDisabled=0<<2
188	=4						srShiftInT2=1<<2
189	=8						srShiftInVIAClock=2<<2
190	=12						srShiftInExtClock=3<<2
191	=16						srShiftOutT2FreeRun=4<<2
192	=20						srShiftOutT2=5<<2
193	=24						srShiftOutVIAClock=6<<2
194	=28						srShiftOutExtClock=7<<2

196	=0						pbLatchDisabled=0<<1
197	=2						pbLatchEnabled=1<<1

199	=0						paLatchDisabled=0<<0
200	=1						paLatchEnabled=1<<0

202	>fe6b						                .fill 1         ;11
203							                .endblock
204	.fe6c						pcr: .block

206	=0						cb2InputNegativeActiveEdge=0<<5
207	=32						cb2IndependentInterruptInputNegativeEdge=1<<5
208	=64						cb2InputPositiveEdge=2<<5
209	=96						cb2IndependentInterruptInputPositiveEdge=3<<5
210	=128						cb2HandshakeOutput=4<<5
211	=160						cb2PulseOutput=5<<5
212	=192						cb2LowOutput=6<<5
213	=224						cb2HighOutput=7<<5

215	=0						cb1NegativeActiveEdge=0<<4
216	=16						cb1PositiveActiveEdge=1<<4

218	=0						ca2InputNegativeActiveEdge=0<<1
219	=2						ca2IndependentInterruptInputNegativeEdge=1<<1
220	=4						ca2InputPositiveEdge=2<<1
221	=6						ca2IndependentInterruptInputPositiveEdge=3<<1
222	=8						ca2HandshakeOutput=4<<1
223	=10						ca2PulseOutput=5<<1
224	=12						ca2LowOutput=6<<1
225	=14						ca2HighOutput=7<<1

227	=0						ca1NegativeActiveEdge=0<<0
228	=1						ca1PositiveActiveEdge=1<<0

230	>fe6c						                .fill 1         ;12
231							                .endblock
232	.fe6d						ifr:
233	>fe6d						                .fill 1         ;13
234	.fe6e						ier:
235	>fe6e						                .fill 1         ;14
236	.fe6f						oraNoHandshake:
237	.fe6f						iraNoHandshake:
238	>fe6f						                .fill 1         ;15

240	.fe70						irq: .block
241	=1						ca2=1
242	=2						ca1=2
243	=4						sr=4
244	=8						cb2=8
245	=16						cb1=16
246	=32						t2=32
247	=64						t1=64
248							                .endblock
249							                .ends
270							                .endv

272							                .if includeTubeSupport
273							                .virtual $fee0
274	.fee0						tube: .block
275							; Parasite to Host: Carries the OSWRCH call. Data register is a FIFO
276							; that can handle a VDU command length (10 bytes).
277							;
278							; Host to Parasite: There is a 1 byte buffer. It is used to generate
279							; IRQ's in the parasite from events in the host.

281							; write/read (clears IRQ)
282	.fee0						status1: .block
283							; [Tube p13]
284	=$01						Q=$01                           ;enable HIRQ from R4
285	=$02						I=$02                           ;enable PIRQ from R1
286	=$04						J=$04                           ;enable PIRQ from R3
287	=$08						M=$08                           ;enable PNMI from R3
288	=$10						V=$10                           ;2-byte R3
289	=$20						P=$20                           ;activate PRST
290	=$40						T=$40                           ;clear all Tube registers
291	=$80						S=$80                           ;set/clear bits
292							                .bend
293	>fee0						                .fill 1

295							; bit 7 - data available/IRQ
296							; bit 6 - not full
297	.fee1						data1:
298	>fee1						                .fill 1

300							; Used to implement OS calls that take a long time or that cannot
301							; interrupt Host tasks. The parasite passes a byte describing the
302							; required task. The two processors then exchange data until the task
303							; is complete. OS calls handled through this register include: OSRDCH,
304							; OSCLI, OSBYTE, OSWORD, OSBPUT, OSBGET, OSFIND, OSARGS, OSFILE,
305							; OSGBPB.

307							; write/read
308	.fee2						status2:
309	>fee2						                .fill 1

311							; bit 7 - data available
312							; bit 6 - not full
313	.fee3						data2:
314	>fee3						                .fill 1

316							; Used for the background task of fast data transfer between the two
317							; processors.

319							; write/read
320	.fee4						status3:
321	>fee4						                .fill 1

323							; bit 7 - data available/NMI
324							; bit 6 - not full
325	.fee5						data3:
326	>fee5						                .fill 1

328							; Used as the control channel for block transfers going through
329							; Register 3, and also the transfer register for error strings from
330							; host to parasite. In both cases, the host interrupts the parasite by
331							; placing a byte into the Register. In the former case it is a byte
332							; describing the required action, in the latter it is an error code.

334							; write (sets IRQ)/read (clears IRQ)
335	.fee6						status4:
336	>fee6						                .fill 1

338							; bit 7 - data available/IRQ
339							; bit 6 - not full/IRQ
340	.fee7						data4:
341	>fee7						                .fill 1
342							                .bend
343							                .endvirtual
344							                .endif

346							RTC: .struct
347	>0000						seconds: .fill 1
348	>0001						secondsAlarm: .fill 1
349	>0002						minutes: .fill 1
350	>0003						minutesAlarm: .fill 1
351	>0004						hours: .fill 1
352	>0005						hoursAlarm: .fill 1
353	>0006						dayOfWeek: .fill 1
354	>0007						dayOfMonth: .fill 1
355	>0008						month: .fill 1
356	>0009						year: .fill 1
357	.000a						a: .block
358	=7						dvMask=7
359	=4						dvShift=4
360	=0						dv4194304Hz=0<<dvShift
361	=16						dv1048576Hz=1<<dvShift
362	=32						dv32768Hz=2<<dvShift
363	>000a						                .fill 1
364							                .endblock
365	.000b						b: .block
366	=$80						set=$80
367	=$02						_24h=$02
368	=$01						dse=$01
369	>000b						                .fill 1
370							                .endblock
371	.000c						c: .block
372	=$10						uf=$10
373	>000c						                .fill 1
374							                .endblock
375	.000d						d: .block
376	>000d						                .fill 1
377							                .endblock
378	=50						ram_size=50
379	>000e						ram: .fill ram_size
380							                .endstruct


:1	;******  Return to file: mos350.s65

2							                .include "src/mos_workspace.s65"

:3	;******  Processing file: src/mos_workspace.s65

1							;-------------------------------------------------------------------------
2							;
3							; Disorganized jumble of constants. They'll get tidied up at some
4							; point... promise...
5							;
6							;-------------------------------------------------------------------------

8							; The version constant is not very well named: it should really be
9							; something like "acornVersion". It refers to one of the official MOS
10							; versions released for Acorn-branded hardware, and can have one of
11							; the following 6 specific values:
12							;
13							; version=320 - MOS 3.20
14							; version=350 - MOS 3.50
15							; version=400 - MOS 4.00
16							; version=500 - MOS 5.00
17							; version=510 - MOS 5.10
18							; version=511 - MOS 5.11
19							;
20							; (Strictly speaking, these are not numeric, but there's a few
21							; instances of version>=n where this coincidentally makes sense. The
22							; 5.xx series follow on from one another, some of the 4.00 changes are
23							; in 5.xx too, and some of the 4.00 changes that are in 5.xx also made
24							; it into 3.50 as well.)

26							                .cerror !(version==320||version==350||version==400||version==500||version==510||version==511)

28							; All other versions are considered to be variants of one of the six
29							; official versions, as per the variant flags below. These variant
30							; flags are applicable to the stated versions only, and may or may not
31							; be separable from the various version-dependent .if/.endif
32							; constructs for that version. If they're changed from these defaults
33							; for any other version, the output may not make sense.
34							;
35							; Over time I intend to (try to) turn these into feature flags,
36							; according to the actual features they control.

38							                .weak
39							                ; Set if building Olivetti MOS, a variant of 5.10.
40	=false						olivetti=false

42							                ; Set if building CFA3000 MOS, a variant of 3.50.
43	=false						CFA3000=false

45							                ; Set if building Autocue 1500 MOS, a variant of 5.11.
46	=false						autocue=false

48							                ; Set if building MOS 3.29 (Acorn FinMOS), a variant
49							                ; of 3.50.
50	=false						finmos329=false

52							                ; Clear if stripping out the terminal ROM. Applicable
53							                ; to 3.20 or 3.50.
54	=true						includeTerminalROM=true

56							                ; Set if building any of the refresh versions.
57	=false						refreshVersion=false
58							                .endweak

60							;-------------------------------------------------------------------------

62							; These feature flags can be set freely by the main driver file.

64							                .weak

66							                ; If true, include *X. Not clear what this command
67							                ; actually, does, but it's in the original ROMs, so
68							                ; there has to be the option...
69	=true						includeStarX=version<500

71							                ; For some reason, *TAPE and *MOTOR have lower-case
72							                ; command name entries in MOS 4.00.
73	="TAPE"						tapeCommandString=version==400?"tape":"TAPE"
74	="MOTOR"					motorCommandString=version==400?"motor":"MOTOR"

76							                ; If false, reproduce the OSBYTE $6B/$6C bug present
77							                ; in MOS versions prior to 3.50.
78	=true						correctOSBYTE6B6C=version==350

80							                ; Assumed century for RTC reading purposes.
81	=$19						assumedRTCCenturyBCD=$19

83							                .endweak

85							;-------------------------------------------------------------------------

87							; These feature flags are offered on a best-effort basis. They're more
88							; intended for readability than for use as toggles.

90							                .weak

92							                ; If true, include Tube support.
93							                .if version==320||version==350||version==400
94	=true						includeTubeSupport=true
97							                .endif

99							                .if version==350||version>=500
100	=true						useTableDrivenConfigure=true
103							                .endif

105							                .endweak

107							;-------------------------------------------------------------------------

109							; Some combinations are impossible. Sorry!
110							;
111							; (The code deliberately doesn't try to work around this. The driver
112							; files must avoid these cases.)

114							                .cerror includeStarX&&!includeTubeSupport
115							                .cerror version==400&&!includeTubeSupport

117							                ; Table-driven configuration takes up fewer bytes, so
118							                ; no point trying to switch it off for builds where it
119							                ; would be on.
120							                .cerror (version==350||version>=500)&&!useTableDrivenConfigure

122							;-------------------------------------------------------------------------

124							beword .macro value
127							                .endm


130							;-------------------------------------------------------------------------

132	=$400						tubeHostAddr=$400

134							                .if version==350
135							                ; MOS 3.50 parasite language relocation workspace?
136	=2						tubeRelocationBitmapPtr=2
137	=$4f5						tubeRelocationBitmapSizeBytes=$4f5
138	=$4f7						tubeRelocationBitmapByte=$4f7
139	=$04f8						tubeRelocationBitmapROMBank=$04f8
140	=$04f9						tubeRelocationPageOffset=$04f9

142							                ; 256-byte region where 1 relocated page of language
143							                ; ROM is held ready for host->parasite pagewise
144							                ; transfer.
145	=$700						tubeRelocationBuffer=$700
146							                .endif

148							;-------------------------------------------------------------------------

150							                .virtual $b0
151	.00b0						sramTransferPointers: .block
152	>00b0						src: .fill 2
153	>00b2						dest: .fill 2
154							                .endblock
155							                .endvirtual

157	=$a8						osargsBuffer=$a8                ;4-byte ZP buffer for use with OSARGS
158	=$b8						printMessageAddress=$b8

160							                .virtual $bb
161	.00bb						tapeCurrentOptionsByte: .block
162							                .endblock
163							                .endvirtual

165							                .virtual $f2
166	.00f2						fsStatusByte: .block
167	=$01						inputFileOpen=$01
168	=$02						outputFileOpen=$02
169	=$08						catStatus=$08
170	=$40						eofReached=$40
171	=$80						eofWarningGiven=$80
172							                .endblock
173							                .endvirtual

175							                .virtual $e4
176	.00e4						stringInputOptions: .block
177	=$80						doubleQuotes=$80
178	=$40						spaceNotATerminator=$40
179	=$01						goodString=$01
180							                .endblock
181							                .endvirtual
182	=$e5						stringInputPlingFlag=$e5        ;bit 7 set if last char was '!'
183	=$e6						readCharacterTimedFlag=$e6
184	=$e7						autoRepeatCountdownTimer=$e7
185	=$eb						tapeCritical=$eb
186	=$ec						lastKeyPressedInternal=$ec
187	=$ed						firstKeyPressedInternal=$ed
188	=$f2						stringInputBufferAddress=$f2    ;word

190							;-------------------------------------------------------------------------

192	=$80						romTypeHasServiceEntry=$80
193	=$40						romTypeHasLanguageEntry=$40
194	=$20						romTypeHasTubeRelocationAddress=$20
195	=$02						romType6502=$02

197							;-------------------------------------------------------------------------

199	=$01						romServiceCallAbsoluteWorkspaceClaim=$01 ; memory used only when ROM is paged in
200	=$02						romServiceCallPrivateWorkspaceClaim=$02 ; memory used even when ROM is not paged in
201	=$03						romServiceCallAutoBoot=$03              ;
202	=$04						romServiceCallUnrecognisedCommand=$04   ; star command not recognised
203	=$05						romServiceCallUnrecognisedInterrupt=$05 ;
204	=$06						romServiceCallBreakInstruction=$06      ;
205	=$07						romServiceCallUnrecognisedOSBYTE=$07    ;
206	=$08						romServiceCallUnrecognisedOSWORD=$08    ;
207	=$09						romServiceCallHelp=$09                  ;
208	=$0a						romServiceCallClaimStaticWorkspace=$0A ; (Issued by paged ROMs, not the OS)
209	=$0b						romServiceCallNMIRelease=$0B    ; (Issued by paged ROMs, not the OS)
210	=$0c						romServiceCallNMIClaim=$0C      ; (Issued by paged ROMs, not the OS)
211	=$0d						romServiceCallROMFilingSystemInitialize=$0D    ;
212	=$0e						romServiceCallROMFilingSystemByteGet=$0E    ;
213	=$0f						romServiceCallVectorsClaimed=$0F    ; Used when a filing system starts
214	=$10						romServiceCallSpoolExecClosureWarning=$10    ;
215							;romServiceCallFontImplosionExplosionWarning=$11    ;
216	=$12						romServiceCallInitialiseFilingSystem=$12    ; (Issued from paged ROMs, not the OS)
217	=$15						romServiceCallPollingInterrupt=$15
218	=$18						romServiceCallReserved=$18
219	=$21						romServiceCallAbsoluteHAZELWorkspaceClaim=$21
220	=$22						romServiceCallPrivateHAZELWorkspaceClam=$22
221	=$23						romServiceCallTopOfHAZELWorkspace=$23
222	=$24						romServiceCallCountDynamicHAZELWorkspace=$24
223	=$25						romServiceCallRequestFSInfo=$25
224	=$26						romServiceCallCloseAllOpenFiles=$26
225	=$27						romServiceCallInformReset=$27
226	=$28						romServiceCallUnknownCONFIG=$28
227	=$29						romServiceCallUnknownSTATUS=$29
228	=$2a						romServiceCallLanguageChange=$2a
229	=$2c						romServiceCallCompactJoystick=$2c
230	=$30						romServiceCall30=$30
231	=$fe						romServiceCallTubeSystemPostInitialisation=$FE    ;
232	=$ff						romServiceCallTubeMainInitialisation=$FF    ;

234							;-------------------------------------------------------------------------

236	=0						fsNone=0
237	=1						fs1200BaudTape=1
238	=2						fs300BaudTape=2
239	=3						fsROM=3

241							; max FS number for all tape/ROM FS types
242	=3						fsTapeOrROMMax=3

244							;-------------------------------------------------------------------------

246							; [MasRef D.2-24]

248	=0						eventOutputBufferEmpty=0
249	=1						eventInputBufferFull=1
250	=2						eventCharacterEnteringBuffer=2
251	=3						eventADCConversionComplete=3
252	=4						eventStartOfVerticalSync=4
253	=5						eventIntervalTimerCrossingZero=5
254	=6						eventESCAPEPressed=6
255	=7						eventRS423Error=7
256	=8						eventNetworkError=8
257	=9						eventUser=9
258	=9						eventMax=9

260							;-------------------------------------------------------------------------

262							; [MasRef D.2-27]

264							; Input buffers
265	=0						bufferKeyboard=0
266	=1						bufferRS423Input=1

268							; Output buffers
269	=2						bufferFirstOutput=2
270	=2						bufferRS423Output=2
271	=3						bufferPrinter=3
272	=4						bufferSoundChannel0=4
273	=5						bufferSoundChannel1=5
274	=6						bufferSoundChannel2=6
275	=7						bufferSoundChannel3=7
276							; What's buffer 8? Previously speech on OS 1.20. There's indices
277							; allocated for it...
278	=8						bufferMax=8


281	=$03e0						bufferKeyboardAddress=$03e0
282	=32						bufferKeyboardSize=32
283	=$0a00						bufferRS423InputAddress=$0a00
284	=256						bufferRS423InputSize=256
285	=$0900						bufferRS423OutputAddress=$0900
286	=192						bufferRS423OutputSize=192
287	=$0880						bufferPrinterAddress=$0880
288	=64						bufferPrinterSize=64
289	=$0840						bufferSoundChannel0Address=$0840
290	=16						bufferSoundChannel0Size=16
291	=$0850						bufferSoundChannel1Address=$0850
292	=16						bufferSoundChannel1Size=16
293	=$0860						bufferSoundChannel2Address=$0860
294	=16						bufferSoundChannel2Size=16
295	=$0870						bufferSoundChannel3Address=$0870
296	=16						bufferSoundChannel3Size=16
297	=$09c0						buffer8Address=$09c0
298	=64						buffer8Size=64



302							; BufferInfo: .function bufferAddress,bufferSizeByte
303							;                 .endfunction (bufferAddress,256-bufferSizeByte)

305							; ; buffer info is (base address,size)
306							;  _:=[]
307							; _..=[BufferInfo($0300,32)];bufferKeyboard=0
308							; _..=[BufferInfo($0a00,256)];bufferRS423Input=1
309							; _..=[BufferInfo($08c0,192)];bufferRS423Output=2
310							; _..=[BufferInfo($07c0,64)];bufferPrinter=3
311							; _..=[BufferInfo($0750,16)];bufferSoundChannel0=4
312							; _..=[BufferInfo($0760,16)];bufferSoundChannel1=5
313							; _..=[BufferInfo($0770,16)];bufferSoundChannel2=6
314							; _..=[BufferInfo($0780,16)];bufferSoundChannel3=7
315							; _..=[BufferInfo($0900,64)];What's buffer 8?

317							;-------------------------------------------------------------------------

319							; [MasRef C.5-5]

321	=0						printerDriverTypeSink=0
322	=1						printerDriverTypeParallel=1
323	=2						printerDriverTypeSerial=2
324	=3						printerDriverTypeUser=3
325	=4						printerDriverTypeNetwork=4

327							; AUG p259

329	=0						printerDriverPoll=0
330	=1						printerDriverActivate=1
331	=2						printerDriverVDU2=2
332	=3						printerDriverVDU3=3
333	=5						printerDriverFX5=5

335	=10						printerDriverFX3=10             ;undocumented???

337							;-------------------------------------------------------------------------

339							; AUG p261

341	=0						netPrinterRequest0=0
342	=1						netPrinterRequest1=1
343	=2						netPrinterRequest2=2
344	=3						netPrinterRequest3=3
345	=4						netWriteCharacterAttempted=4
346	=5						netPrinterRequest5=5
347	=6						netReadCharacterAttempted=6
348	=7						netOSBYTEAttempted=7
349	=8						netOSWORDAttempted=8
350	=13						netOSWORD0Complete=13

352							;-------------------------------------------------------------------------

354							; OSFIND open constants
355	=$40						findOpenForRead=$40
356	=$80						findOpenForWrite=$80

358	=0						fscOPT=0
359	=1						fscCheckEOF=1
360	=2						fscStarSlash=2
361	=3						fscUnknownCommand=3
362	=4						fscStarRUN=4
363	=5						fscStarCAT=5
364	=6						fscNewFS=6
365	=7						fscFileHandleRange=7
366	=8						fscStarCommand=8
367	=9						fscStarEX=9
368	=10						fscStarINFO=10
369	=11						fscRUNLibrary=11

371							; NAUG mentions this. But it doesn't appear to
372							; actually exist in the code.
373							;
374							; Maybe it's present in MOS 3.50 or later?
375	=12						fscRENAME=12

377	=1						gbpbPutBytesNewPTR=1            ;[AUG p340]
378	=2						gbpbPutBytesCurrentPTR=2        ;[AUG p340]
379	=3						gbpbGetBytesNewPTR=3            ;[AUG p341]
380	=4						gbpbGetBytesCurrentPTR=4        ;[AUG p341]
381	=5						gbpbGetMediaMetadata=5          ;[AUG p341]
382	=6						gbpbGetCurrentDevice=6          ;[AUG p341]
383	=7						gbpbGetLibraryDevice=7          ;[AUG p341]
384	=8						gbpbReadFileNames=8             ;[AUG p341]

386							OSGBPBParameterBlock: .struct
387	.0000						handle:
388	>0000						                .fill 1
389	.0001						address:
390	>0001						                .fill 4
391	.0005						count:
392	>0005						                .fill 4
393	.0009						ptr:
394	>0009						                .fill 4
395							                .endstruct

397	=0						argsGetFS=0                     ;[AUG p337]
398	=1						argsGetCommandLine=1            ;[AUG p338]
399	=2						argsCheckANFS=2                 ;https://beebwiki.mdfs.net/OSARGS
400	=3						argsGetLibFS=3                  ;
401	=$ff						argsFlushBuffers=$ff            ;[AUG p338]

403	=0						argsFileGetPTR=0
404	=1						argsFileSetPTR=1
405	=2						argsFileGetEXT=2
406	=$ff						argsFileFlush=$ff

408	=0						fileSave=0                      ;[AUG p336]
409	=1						fileWriteMetadata=1             ;[AUG p336]
410	=2						fileWriteLoadAddress=2          ;[AUG p336]
411	=3						fileWriteExecAddress=3          ;[AUG p336]
412	=4						fileWritettributes=4            ;[AUG p336]
413	=5						fileReadMetadata=5              ;[AUG p336]
414	=6						fileDelete=6                    ;[AUG p336]
415	=$ff						fileLoad=$ff                    ;[AUG p336]

417							OSFILEParameterBlock: .struct
418	.0000						fileName:
419	>0000						                .fill 2
420	.0002						addresses:
421	.0002						load:
422	>0002						                .fill 4
423	.0006						exec:
424	>0006						                .fill 4
425	.000a						length:
426	.000a						saveStart:
427	>000a						                .fill 4
428	.000e						attributes:
429	.000e						saveEnd:
430	>000e						                .fill 4
431							                .endstruct

433							;-------------------------------------------------------------------------

435	=0						bufferNumberKeyboard=0          ;
436	=1						bufferNumberRS423Input=1        ;
437	=2						bufferNumberRS423Output=2       ;
438	=3						bufferNumberPrinter=3           ;
439	=4						bufferNumberSound0=4            ; Noise channel
440	=5						bufferNumberSound1=5            ;
441	=6						bufferNumberSound2=6            ;
442	=7						bufferNumberSound3=7            ;
443							; bufferNumberSpeech=8            ;
444	=8						bufferNumberHighest=8           ;

446							;-------------------------------------------------------------------------

448							                .if includeTubeSupport
449	=0						tubeReasonMultiByteParasiteToHost=0
450	=1						tubeReasonMultiByteHostToParasite=1
451	=4						tubeReasonExecute=4
452	=$c0						tubeReasonClaimMask=$c0
453	=$80						tubeReasonReleaseMask=$80
454							                .endif

456							;-------------------------------------------------------------------------

458							; uservIndex=0
459							; brkvIndex=1
460							; irq1vIndex=2
461							; irq2vIndex=3
462							; clivIndex=4
463							; bytevIndex=5
464							; wordvIndex=6
465							; wrchvIndex=7
466							; rdchvIndex=8
467							; filevIndex=9
468							; argsvIndex=10
469							; bgetvIndex=11
470							; bputvIndex=12
471							; gbpbvIndex=13
472							; findvIndex=14
473							; fscvIndex=15
474							; eventvIndex=16
475							; uptvIndex=17
476							; netvIndex=18
477							; vduvIndex=19
478							; keyvIndex=20
479							; insvIndex=21
480							; remvIndex=22
481							; cnpvIndex=23
482							; ind1vIndex=24
483							; ind2vIndex=25
484							; ind3vIndex=26


487							                .virtual $200
488	.0200						vectors:
489	.0200						USERV:
490	>0200						                .fill 2
491	.0202						BRKV:
492	>0202						                .fill 2
493	.0204						IRQ1V:
494	>0204						                .fill 2
495	.0206						IRQ2V:
496	>0206						                .fill 2
497	.0208						CLIV:
498	>0208						                .fill 2
499	.020a						BYTEV:
500	>020a						                .fill 2
501	.020c						WORDV:
502	>020c						                .fill 2
503	.020e						WRCHV:
504	>020e						                .fill 2
505	.0210						RDCHV:
506	>0210						                .fill 2
507	.0212						FILEV:
508	>0212						                .fill 2
509	.0214						ARGSV:
510	>0214						                .fill 2
511	.0216						BGETV:
512	>0216						                .fill 2
513	.0218						BPUTV:
514	>0218						                .fill 2
515	.021a						GBPBV:
516	>021a						                .fill 2
517	.021c						FINDV:
518	>021c						                .fill 2
519	.021e						FSCV:
520	>021e						                .fill 2
521	.0220						EVENTV:
522	>0220						                .fill 2
523	.0222						UPTV:
524	>0222						                .fill 2
525	.0224						NETV:
526	>0224						                .fill 2
527	.0226						VDUV:
528	>0226						                .fill 2
529	.0228						KEYV:
530	>0228						                .fill 2
531	.022a						INSV:
532	>022a						                .fill 2
533	.022c						REMV:
534	>022c						                .fill 2
535	.022e						CNPV:
536	>022e						                .fill 2
537	.0230						IND1V:
538	>0230						                .fill 2
539	.0232						IND2V:
540	>0232						                .fill 2
541	.0234						IND3V:
542	>0234						                .fill 2
543	.0236						mosVariables:

545							; OSBYTE 166 (&A6) Read start address of MOS variables [MasRef D.2-50]
546							; OSBYTE 167 (&A7) Read start address of MOS variablespointer table  [MasRef D.2-50]
547	>0236						mosVariablesAddress: .fill 2

549							; OSBYTE 168 (&A8) Read address of ROM pointer table [MasRef D.2-51]
550							; OSBYTE 169 (&A9) Read address of ROM pointer table [MasRef D.2-51]
551	>0238						extendedVectorSpaceAddress: .fill 2

553							; OSBYTE 170 (&AA) Read address of ROM information table [MasRef D.2-51]
554							; OSBYTE 171 (&AB) Read address of ROM information table [MasRef D.2-51]
555	>023a						romInformationTableAddress: .fill 2

557							; OSBYTE 172 (&AC) Read address of keyboard translation table [MasRef D.2-52]
558							; OSBYTE 173 (&AD) Read address of keyboard translation table [MasRef D.2-52]
559	>023c						keyboardTranslationTableAddress: .fill 2

561							; OSBYTE 174 (&AE) Read address of VDU variables origin [MasRef D.2-52]
562							; OSBYTE 175 (&AF) Read address of VDU variables origin [MasRef D.2-52]
563	>023e						vduVariablesAddress: .fill 2

565							; OSBYTE 176 (&B0) Read/Write CFS timeout counter [MasRef D.2-52]
566	>0240						cfsTimeoutCounter: .fill 1

568							; OSBYTE 177 (&B1) Read/write input source [MasRef D.2-53]
569	>0241						inputSource: .fill 1

571							; OSBYTE 178 (&B2) Read/write keyboard semaphore [MasRef D.2-53]
572	>0242						keyboardSemaphore: .fill 1

574							; OSBYTE 179 (&B3) Read/write ROM polling semaphore [MasRef D.2-54]
575	>0243						romPollingSemaphore: .fill 1

577							; OSBYTE 180 (&B4) Read/write Operating System High [MasRef D.2-54]
578	>0244						oshwm: .fill 1

580							; OSBYTE 181 (&B5) Read/write RS243 input interpretation [MasRef D.2-54]
581	>0245						rs423InputInterpretationStatus: .fill 1


584							; OSBYTE 182 (&B6) Read NOIGNORE state [MasRef D.2-55]
585							;
586							; TODO - not a great name, no matter how official - should probably be usePrinterIgnoreChar or something
587	>0246						noignoreState: .fill 1

589							; OSBYTE 183 (&B7) Read/write cassette/ROM filing system [MasRef D.2-55]
590	>0247						cfsRFSFSSwitch: .fill 1

592							; OSBYTE 184 (&B8) Read OS copy of video ULA control [MasRef D.2-56]
593	>0248						vcontrolRegister: .fill 1

595							; OSBYTE 185 (&B9) Read OS copy of video ULA palette [MasRef D.2-56]
596	>0249						vpaletteRegister: .fill 1

598							; OSBYTE 186 (&BA) Read ROM number active at last BRK [MasRef D.2-56]
599	>024a						romActiveAtLastBRK: .fill 1

601							; OSBYTE 187 (&BB) Read ROM number of socket [MasRef D.2-57]
602	>024b						basicROMNumber: .fill 1

604							; OSBYTE 188 (&BC) Read current ADC channel number [MasRef D.2-57]
605	>024c						currentADCChannel: .fill 1

607							; OSBYTE 189 (&BD) Read maximum ADC channel number [MasRef D.2-57]
608	>024d						maximumADCChannel: .fill 1

610							; OSBYTE 190 (&BE) Read/write ADC conversion type [MasRef D.2-58]
611	>024e						adcConversionType: .fill 1

613							; OSBYTE 191 (&BF) Read/write RS423 busy flag [MasRef D.2-58]
614	>024f						rs423Busy: .fill 1

616							; OSBYTE 192 (&C0) Read serial ACIA control register [MasRef D.2-58]
617	>0250						aciaControlRegister: .fill 1

619							; OSBYTE 193 (&C1) Read/write flash counter [MasRef D.2-59]
620	>0251						flashCounter: .fill 1

622							; OSBYTE 194 (&C2) Read/write duration of first colour [MasRef D.2-59]
623	>0252						firstFlashColourDuration: .fill 1

625							; OSBYTE 195 (&C3) Read/write duration of second colour [MasRef D.2-60]
626	>0253						secondFlashColourDuration: .fill 1

628							; OSBYTE 196 (&C4) Read/write keyboard auto-repeat delay [MasRef D.2-60]
629	>0254						keyboardAutoRepeatDelay: .fill 1

631							; OSBYTE 197 (&C5) Read/write keyboard auto-repeat rate [MasRef D.2-60]
632	>0255						keyboardAutoRepeatRate: .fill 1

634							; OSBYTE 198 (&C6) Read/write *EXEC file handle [MasRef D.2-61]
635	>0256						execFileHandle: .fill 1

637							; OSBYTE 199 (&C7) Read/write *SPOOL file handle [MasRef D.2-62]
638	>0257						spoolFileHandle: .fill 1

640							; OSBYTE 200 (&C8) Read/write BREAK and ESCAPE effect [MasRef D.2-62]
641	>0258						breakAndESCAPEEffect: .fill 1

643							; OSBYTE 201 (&C9) Read/write keyboard status [MasRef D.2-63]
644	>0259						keyboardStatus: .fill 1

646							; OSBYTE 202 (&CA) Read/write keyboard status byte [MasRef D.2-63]
647	.025a						keyboardStatusByte: .block
648	=$8						shiftPressed=%1<<3
649	=%10000						capsLockDisengaged=%1<<4
650	=%100000					shiftLockDisengaged=%1<<5
651	=%1000000					ctrlPressed=%1<<6
652	=$80						shiftEnabled=%1<<7
653	>025a						                .fill 1
654							                .endblock

656							; OSBYTE 203 (&CB) Read/write RS423 input buffer [MasRef D.2-64]
657	>025b						rs423InputBufferMinimumSpace: .fill 1

659							; OSBYTE 204 (&CC) Read/write RS423 ignore flag [MasRef D.2-65]
660	>025c						rs423Ignore: .fill 1

662							; OSBYTE 205 (&CD) Read/write RS423 destination [MasRef D.2-65]
663	>025d						rs423Destination: .fill 1

665							; OSBYTE 206 (&CE) Read/write Econet OS call interception [MasRef D.2-66]
666	>025e						econetInterceptionStatus: .fill 1

668							; OSBYTE 207 (&CF) Read/write Econet input interpretation [MasRef D.2-66]
669	>025f						econetInputInterpretationStatus: .fill 1

671							; OSBYTE 208 (&D0) Read write Econet output [MasRef D.2-67]
672	>0260						econetOutputInterpretationStatus: .fill 1

674							; OSBYTE 209 (&D1) is reserved for the speech system [MasRef D.2-67]
675	>0261						speechSystemByte1:  .fill 1

677							; OSBYTE 210 (&D2) Read/write sound suppression status [MasRef D.2-67]
678	>0262						soundSuppressionStatus: .fill 1

680							; OSBYTE 211 (&D3) Read/write BELL channel [MasRef D.2-67]
681	>0263						bellChannel: .fill 1

683							; OSBYTE 212 (&D4) Read/write BELL sound information [MasRef D.2-68]
684	>0264						bellSound: .fill 1

686							; OSBYTE 213 (&D5) Read/write BELL frequency [MasRef D.2-69]
687	>0265						bellFrequency: .fill 1

689							; OSBYTE 214 (&D6) Read/write BELL duration [MasRef D.2-69]
690	>0266						bellDuration: .fill 1

692							; OSBYTE 215 (&D7) Read/write startup message [MasRef D.2-69]
693	>0267						startupMessageSuppressionStatus: .fill 1

695							; OSBYTE 216 (&D8) Read/write length of soft key string [MasRef D.2-70]
696	>0268						softKeyStringLength: .fill 1

698							; OSBYTE 217 (&D9) Read/write paged mode line count [MasRef D.2-71]
699	>0269						pagedModeCounter: .fill 1

701							; OSBYTE 218 (&DA) Read/write bytes in VDU queue [MasRef D.2-71]
702	>026a						vduQueueNegativeLength: .fill 1

704							; OSBYTE 219 (&DB) Read/write TAB key code [MasRef D.2-72]
705	>026b						tabKeyCode: .fill 1

707							; OSBYTE 220 (&DC) Read/write ESCAPE character [MasRef D.2-72]
708	>026c						escapeCharacter: .fill 1

710							; OSBYTE 221 (&DD) Read/write interpretation of input values 192-207 [MasRef D.2-73]
711	>026d						input192To207Interpretation: .fill 1

713							; OSBYTE 222 (&DE) Read/write interpretation of input values 208-223 [MasRef D.2-73]
714	>026e						input208To223Interpretation: .fill 1

716							; OSBYTE 223 (&DF) Read/write interpretation of input values 224-239 [MasRef D.2-73]
717	>026f						input224To239Interpretation: .fill 1

719							; OSBYTE 224 (&E0) Read/write interpretation of input values 240-255 [MasRef D.2-73]
720	>0270						input240To255Interpretation: .fill 1

722							; OSBYTE 225 (&E1) Read/write soft key interpretation [MasRef D.2-74]
723	>0271						softKeyInterpretation: .fill 1

725							; OSBYTE 226 (&E2) Read/write SHIFT+soft key interpretation [MasRef D.2-74]
726	>0272						shiftSoftKeyInterpretation: .fill 1

728							; OSBYTE 227 (&E3) Read/write CTRL+soft key interpretation [MasRef D.2-74]
729	>0273						ctrlSoftKeyInterpretation: .fill 1

731							; OSBYTE 228 (&E4) Read/write SHIFT+CTRL+soft key interpretation [MasRef D.2-74]
732	>0274						shiftCtrlSoftKeyInterpretation: .fill 1

734							; OSBYTE 229 (&E5) Read/write ESCAPE key status [MasRef D.2-75]
735	>0275						escapeKeyStatus: .fill 1

737							; OSBYTE 230 (&E6) Read/write ESCAPE effects [MasRef D.2-75]
738	>0276						escapeEffects: .fill 1

740							; OSBYTE 231 (&E7) Read/write IRQ bit mask for user 6522 [MasRef D.2-76]
741	>0277						userVIAInterruptMask: .fill 1

743							; OSBYTE 232 (&E8) Read/write IRQ bit mask for 6850 [MasRef D.2-76]
744	>0278						rs423InterruptMask: .fill 1

746							; OSBYTE 233 (&E9) Read write IRQ bit mask for system [MasRef D.2-76]
747	>0279						systemVIAInterruptMask: .fill 1

749							; OSBYTE 234 (&EA) Read flag indicating Tube presence [MasRef D.2-76]
750							                .if includeTubeSupport
751	>027a						tubePresence: .fill 1
754							                .endif

756							; OSBYTE 235 (&EB) is reserved for the speech system. [MasRef D.2-77]
757	>027b						speechSystemByte2: .fill 1

759							; OSBYTE 236 (&EC) Read/write character destination status [MasRef D.2-77]
760	.027c						characterDestinationStatus: .block
761	>027c						                .fill 1
762	=1						rs423_enable=1
763	=2						vdu_disable=2
764	=4						printer_disable=4               ;printer always off
765	=8						printer_enable=8                ;printer always on
766	=16						spool_disable=16
767	=64						printer_maybe=64                ;printer on when VDU 1 only
768							                .endblock

770							; OSBYTE 237 (&ED) Read/write cursor editing status [MasRef D.2-77]
771	.027d						editKeysMode: .block
772	=0						editKeys=0                      ;edit keys do editing
773	=1						asciiKeys=1                     ;edit keys are ASCII 135-139
774	=2						functionKeys=2                  ;edit keys are F keys 11-15
775	>027d						                .fill 1
776							                .endblock

778							; OSBYTE 238 (&EE) Read/write numeric keypad [MasRef D.2-78]
779	>027e						numericKeypadInterpretation: .fill 1

781							; OSBYTE 239 (&EF) Read/write *SHADOW state [MasRef D.2-78]
782	>027f						shadowRAMState: .fill 1

784							; OSBYTE 240 (&F0) Read country flag [MasRef D.2-79]
785	>0280						countryFlag: .fill 1

787							; OSBYTE 241 (&F1) Read/write user flag [MasRef D.2-79]
788	>0281						userFlag: .fill 1

790							; OSBYTE 242 (&F2) Read copy of serial processor ULA [MasRef D.2-80]
791	>0282						serialULARegister: .fill 1

793							; OSBYTE 243 (&F3) Read timer switch state [MasRef D.2-80]
794							;
795							; The location holds either 5 (initialTimerSwitchState) or 10
796							; (initialTimerSwitchState^15) - i.e., the offset of the byte after
797							; the last of the timer.
798							;
799							; Various offsets are applied to the timer addresses to make this
800							; work.
801	>0283						timerSwitchState: .fill 1

803							; OSBYTE 244 (&F4) Read/write soft key consistency flag [MasRef D.2-81]
804	>0284						softKeyConsistencyFlag: .fill 1

806							; OSBYTE 245 (&F5) Read printer driver type [MasRef D.2-81[
807	>0285						printerDriverType: .fill 1

809							; OSBYTE 246 (&F6) Read/write printer ignore character [MasRef D.2-81]
810	>0286						printerIgnoreChar: .fill 1

812							; OSBYTE 247 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
813	>0287						breakVectorByte0: .fill 1

815							; OSBYTE 248 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
816	>0288						breakVectorByte1: .fill 1

818							; OSBYTE 249 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
819	>0289						breakVectorByte2: .fill 1

821							; OSBYTE 250 (&FA) Read memory written by VDU driver [MasRef D.2-82]
822	>028a						vduDriverMemory: .fill 1

824							; OSBYTE 251 (&FB) Read memory displayed [MasRef D.2-83]
825	>028b						displayMemory: .fill 1

827							; OSBYTE 252 (&FC) Read/write current language ROM number [MasRef D.2-83]
828	>028c						currentLanguageROM: .fill 1

830							; OSBYTE 253 (&FD) Read last BREAK type [MasRef D.2-83]
831	.028d						lastBREAKType: .block
832	>028d						                .fill 1
833	=0						softBREAK=0
834	=1						powerOn=1
835	=2						hardBREAK=2
836							                .endblock
837							; OSBYTE 254 (&FE) Set effect of SHIFT on numeric keypad [MasRef D.2-84]
838	>028e						numericKeypadShiftEffect: .fill 1
839							; OSBYTE 255 (&FF) Read/write startup options [MasRef D.2-84]
840	>028f						startupOptions: .fill 1
841	=7						modeMask=7

843							                .endvirtual

845	=166						firstMOSVariableOSBYTE=166

847	=5						initialTimerSwitchState=5
848	=$290						tvOffset=$290
849	=$291						tvInterlace=$291
850	=$292						timer0=$292
851	=$297						timer1=$297
852	=$29c						intervalTimer=$29c
853	=$2a1						romInformationTable=$2a1
854	=$2b1						inkeyTimeoutCounter=$2b1
855	=$2b3						osword0MaxLineLength=$2b3
856	=$2b4						osword0MinASCIICharacter=$2b4
857	=$2b5						osword0MaxASCIICharacter=$2b5
858	=$2b6						adcResultLSBs=$2b6
859	=$2ba						adcResultMSBs=$2ba
860	=$2be						adcLastChannelRead=$2be         ;Two names for the same thing!
861	=$2be						adcLastConvertedChannel=$2be    ;Two names for the same thing!
862	=$2bf						eventEnabledFlags=$2bf
863	=$02c9						currentSoftKey=$02c9
864	=$02ca						keyboardFirstAutoRepeatCount=$02ca
865	=$2cb						previousKeyPressedWhenReadingLastKey=$2cb
866	=$2cc						previousKeyPressedWhenReadingFirstKey=$2cc
867	=$2cd						previousKeyPressedWhenReadingOSBYTE=$2cd
868							; soundIsUpdatingFlag=$2ce
869	=$2ce						bufferEmptyFlags=$2ce
870	=$2d7						bufferStartIndices=$2d7
871	=$2e0						bufferEndIndices=$2e0

873	=$2e9						tapeInputCurrentBlockSize=$2e9
874	=$2eb						blockFlagOfCurrentlyResidentBlock=$2eb
875	=$2ec						lastCharacterOfCurrentlyResidentBlock=$2ec

877							; Needs a better name, possibly more than one :(
878							;
879							; Used by various file routines to store OSGBPB and OSFILE parameter
880							; blocks.
881							;
882							; Used by the clock routines to hold a (possibly partial) mirror of
883							; the RTC time/date registers.
884							;
885							; Used when parsing hex addresses from the command line - obviously
886							; designed primarily for convenient use when building up the OSFILE
887							; parameter block for use with *LOAD and *SAVE.
888							;
889							; Used by the SRAM utilities to store working data.
890	=$2ed						osfileParameterBlock=$2ed

892							                .virtual osfileParameterBlock
893	.02ed						sramWorkspace: .block
894	>02ed						temp: .fill 1
895	>02ee						type: .fill 1
896	>02ef						length: .fill 2
897	>02f1						bank: .fill 1
898	>02f2						sramAddress: .fill 4
899	>02f6						dataAddress: .fill 4
900							                .endblock
901							                .endvirtual

903							; rtcTempData=$2ee

905							ExtendedVectorAddress: .function vectorAddress
907							                .endfunction extendedVectorSpace+(vectorAddress-vectors)/2*3

909							;-------------------------------------------------------------------------

911	=$d9f						extendedVectorSpace=$d9f

913	=$62						key_space=$62
914	=$66						key_comma=$66
915	=$17						key_minus=$17
916	=$67						key_stop=$67
917	=$68						key_slash=$68
918	=$27						key_0=$27
919	=$30						key_1=$30
920	=$31						key_2=$31
921	=$11						key_3=$11
922	=$12						key_4=$12
923	=$13						key_5=$13
924	=$34						key_6=$34
925	=$24						key_7=$24
926	=$15						key_8=$15
927	=$26						key_9=$26
928	=$48						key_colon=$48
929	=$57						key_semicolon=$57
930	=$47						key_at=$47
931	=$41						key_a=$41
932	=$64						key_b=$64
933	=$52						key_c=$52
934	=$32						key_d=$32
935	=$22						key_e=$22
936	=$43						key_f=$43
937	=$53						key_g=$53
938	=$54						key_h=$54
939	=$25						key_i=$25
940	=$45						key_j=$45
941	=$46						key_k=$46
942	=$56						key_l=$56
943	=$65						key_m=$65
944	=$55						key_n=$55
945	=$36						key_o=$36
946	=$37						key_p=$37
947	=$10						key_q=$10
948	=$33						key_r=$33
949	=$51						key_s=$51
950	=$23						key_t=$23
951	=$35						key_u=$35
952	=$63						key_v=$63
953	=$21						key_w=$21
954	=$42						key_x=$42
955	=$44						key_y=$44
956	=$61						key_z=$61
957	=$38						key_left_square_bracket=$38
958	=$78						key_backslash=$78
959	=$58						key_right_square_bracket=$58
960	=$18						key_caret=$18
961	=$28						key_underline=$28
962	=$70						key_escape=$70
963	=$60						key_tab=$60
964	=$40						key_caps_lock=$40
965	=$1						key_ctrl=$1
966	=$50						key_shift_lock=$50
967	=$0						key_shift=$0
968	=$59						key_delete=$59
969	=$69						key_copy=$69
970	=$49						key_return=$49
971	=$39						key_up=$39
972	=$29						key_down=$29
973	=$19						key_left=$19
974	=$79						key_right=$79
975	=$20						key_f0=$20
976	=$71						key_f1=$71
977	=$72						key_f2=$72
978	=$73						key_f3=$73
979	=$14						key_f4=$14
980	=$74						key_f5=$74
981	=$75						key_f6=$75
982	=$16						key_f7=$16
983	=$76						key_f8=$76
984	=$77						key_f9=$77
985	=$6a						key_numpad_0=$6a
986	=$6b						key_numpad_1=$6b
987	=$7c						key_numpad_2=$7c
988	=$6c						key_numpad_3=$6c
989	=$7a						key_numpad_4=$7a
990	=$7b						key_numpad_5=$7b
991	=$1a						key_numpad_6=$1a
992	=$1b						key_numpad_7=$1b
993	=$2a						key_numpad_8=$2a
994	=$2b						key_numpad_9=$2b
995	=$3a						key_numpad_plus=$3a
996	=$3b						key_numpad_minus=$3b
997	=$4a						key_numpad_divide=$4a
998	=$5a						key_numpad_hash=$5a
999	=$5b						key_numpad_multiply=$5b
1000	=$5c						key_numpad_comma=$5c
1001	=$3c						key_numpad_return=$3c
1002	=$4b						key_numpad_delete=$4b
1003	=$4c						key_numpad_stop=$4c

1005							fsInfoBlock: .struct
1006	>0000						name: .fill 8
1007	>0008						minHandle: .fill 1
1008	>0009						maxHandle: .fill 1
1009	>000a						fsNumber: .fill 1
1010							                .ends

1012							osgbpbBlock: .struct
1013	>0000						handle: .fill 1
1014	>0001						addr: .fill 4
1015	>0005						numBytes: .fill 4
1016	>0009						ptr: .fill 4
1017							                .ends

1019							                ; NAUG p260
1020							                .virtual $dc00
1021	.dc00						hazel: .block
1022	.dc00						commandLine:                    ;dc00
1023	>dc00						                .fill 256
1024	.dd00						ddxx:                           ;dd00
1025	>dd00						                .fill 256
1026	.de00						dexx:
1027	>de00						                .fill 256
1028	.df00						currentFS:                      ;df00
1029	>df00						                .fill 1
1030	.df01						activeFS:                       ;df01
1031	>df01						                .fill 1
1032	.df02						libFS:                          ;df02
1033	>df02						                .fill 1
1034	.df03						currentFSROM:                   ;df03
1035	>df03						                .fill 1
1036	.df04						commandLinePointer:             ;df04
1037	>df04						                .fill 2

1039							                ; 17 info blocks in total, but everything is relative
1040							                ; to the 0th, so there's only a need to instantiate a
1041							                ; struct for that one. Don't think 64tass handles
1042							                ; arrays of structs anyway.
1043	.df06						fsInfoBlocks:   .dstruct fsInfoBlock ;df06
1006	>df06						name: .fill 8
1007	>df0e						minHandle: .fill 1
1008	>df0f						maxHandle: .fill 1
1009	>df10						fsNumber: .fill 1
1010							                .ends
1044	>df11						                .fill 16*size(fsInfoBlock)
1045	.dfc1						fsInfoBlocksTerminator:         ;dfc1
1046							                ; space reserved for the 0 terminator when the full
1047							                ; set of info blocks are filled.
1048	>dfc1						                .fill 1
1049	.dfc2						fsFlags: .block                 ;dfc2
1050	>dfc2						                .fill 1
1051	=$80						useASCII=$80
1052	=$80						isAPPEND=$80
1053	=$40						noLineNumbers=$40
1054							                .bend
1055	.dfc3						lineNumberBCD:                  ;dfc3
1056	>dfc3						                .fill 2
1057	.dfc5						lastCharPrinted:                ;dfc5
1058	>dfc5						                .fill 1
1059	.dfc6						tempFSFlag:                     ;dfc6
1060	>dfc6						                .fill 1
1061	.dfc7						moveOSGBPB: .dstruct osgbpbBlock ;dfc7
1013	>dfc7						handle: .fill 1
1014	>dfc8						addr: .fill 4
1015	>dfcc						numBytes: .fill 4
1016	>dfd0						ptr: .fill 4
1017							                .ends
1062	.dfd4						moveSrcHandle:                  ;dfd4
1063	>dfd4						                .fill 1
1064	.dfd5						moveDestHandle:                 ;dfd5
1065	>dfd5						                .fill 1
1066	.dfd6						moveBufferMSB:                  ;dfd6
1067	>dfd6						                .fill 1
1068	.dfd7						moveNumPages:                   ;dfd7
1069	>dfd7						                .fill 1
1070	.dfd8						moveDestName:                   ;dfd8
1071	>dfd8						                .fill 2
1072	.dfda						activeFSCV:                     ;dfda
1073	>dfda						                .fill 2
1074	.dfdc						oldACCCON:                      ;dfdc
1075	>dfdc						                .fill 1
1076	.dfdd						hasACCCONChanged:                ;dfdd
1077	>dfdd						                .fill 1

1079							                .if version>=350
1080	.dfde						sramBankModes:
1081							                ; pseudo/absolute bank flags, as queried by OSBYTE $45
1084							                .endif
1085	>dfde						                .fill 1
1086							                .bend
1087							                .endv

1089							;-------------------------------------------------------------------------
1090							;
1091							; VDU variables
1092							;
1093							; MasRef E.4-1
1094							;
1095							VDUVariables: .struct
1096	.0000						graphicsWindow:
1097							;graphicsWindowLeftBottom:
1098							; &00 2 Graphics window left column. (p)
1099	>0000						graphicsWindowPixelsLeft: .fill 2
1100							; &02 2 Graphics window bottom row. (p)
1101	>0002						graphicsWindowPixelsBottom: .fill 2
1102							;graphicsWindowRightTop:
1103							; &04 2 Graphics window right column. (p)
1104	>0004						graphicsWindowPixelsRight: .fill 2
1105							; &06 2 Graphics window top row. (p)
1106	>0006						graphicsWindowPixelsTop: .fill 2
1107	.0008						textWindow:
1108							; &08 1 Text window left column.
1109	>0008						textWindowLeft: .fill 1
1110							; &09 1 Text window bottom row.
1111	>0009						textWindowBottom: .fill 1
1112							; &0A 1 Text window right column.
1113	>000a						textWindowRight: .fill 1
1114							; &0B 1 Text window top row.
1115	>000b						textWindowTop: .fill 1
1116							; &0C 2 Graphics origin X coordinate. (e)
1117	>000c						graphicsWindowOriginX: .fill 2
1118							; &0E 2 Graphics origin Y coordinate. (e)
1119	>000e						graphicsWindowOriginY: .fill 2
1120							; &10 2 Graphics cursor X coordinate. (e)
1121	>0010						graphicsCursorPositionX: .fill 2
1122							; &12 2 Graphics cursor Y coordinate. (e)
1123	>0012						graphicsCursorPositionY: .fill 2
1124							; &14 2 Previous graphics cursor X coordinate. (p)
1125	.0014						oldGraphicsCursorPixels:
1126	>0014						oldGraphicsCursorPixelsX: .fill 2
1127							; &16 2 Previous graphics cursor Y coordinate. (p)
1128	>0016						oldGraphicsCursorPixelsY: .fill 2
1129							; &18 1 Text cursor X coordinate (from left of screen) when not cursor editing. When cursor editing, normally the input cursor X coordinate, but the output cursor X coordinate within an "unknown PLOT codes" routine.
1130	>0018						textCursorXPosition: .fill 1
1131							; &19 1 Text cursor Y coordinate (from top of screen) when not cursor editing. When cursor editing, normally t.lsthe input cursor Y coordinate, but the output cursor Y coordinate within an "unknown PLOT codes" routine.
1132	>0019						textCursorYPosition: .fill 1
1133							; &1A 1 Y produced by GADDR (see next section) so that (ZMEMG),Y addresses the correct byte.
1134	>001a						graphicsAddressOffset: .fill 1
1135							; &1B-&23 VDU queue: &23 contains last byte of queue, other bytes immediately precede it.
1136	=9						queueSize=9
1137	>001b						queueBegin: .fill queueSize
1138	.0024						queueEnd:
1139	.0024						graphicsCursorPixels:
1140							; &24 2 Graphics cursor X coordinate. (p)
1141	>0024						graphicsCursorPixelsX: .fill 2
1142							; &26 2 Graphics cursor Y coordinate. (p)
1143	>0026						graphicsCursorPixelsY: .fill 2
1144							; &28-&49 Workspace. But variable &38 must not be used in a Teletext mode (mode 7 or 135).
1145							                .union
1146	.0028						ew: .dstruct EllipseWorkspaceVDUVariables
1344							                ; https://tobylobster.github.io/GXR-pages/gxr/S-s3.html#SP4
1345	.0028						aspectRatio:
1346	>0028						                .fill 3
1347	.002b						shear:
1348	>002b						                .fill 3
1349	.002e						halfHeightCounter:
1350	>002e						                .fill 2
1351	.0030						halfHeightSquared:
1352	>0030						                .fill 4
1353	.0034						pointC:
1354	>0034						                .fill 2
1355	.0036						pointD:
1356	>0036						                .fill 2
1357	.0038						leftPoint:
1358	>0038						                .fill 2
1359	.003a						rightPoint:
1360	>003a						                .fill 2
1361	.003c						pointA:
1362	>003c						                .fill 2
1363	.003e						pointB:
1364	>003e						                .fill 2
1365	.0040						pointE:
1366	>0040						                .fill 2
1367	.0042						currentOffsetX:
1368	>0042						                .fill 2
1369	.0044						plotPointX:
1370	.0044						pointF:
1371	>0044						                .fill 2
1372	.0046						plotPointY:
1373	>0046						                .fill 2
1374							                .endstruct
1147	.0028						hlfw: .dstruct HorizontalLineFillWorkspaceVDUVariables
1409	>0028						                .fill 6
1410	.002e						pixelsX:                        ;2e
1411	>002e						                .fill 2
1412	.0030						pixelsY:                        ;30
1413	>0030						                .fill 2
1414	.0032						pixelsRightEndX:
1415	>0032						                .fill 2         ;32
1416	.0034						pixelsLimitX:                   ;34
1417	>0034						                .fill 2
1418							                .endstruct
1148	.0028						mocr: .dstruct MoveOrCopyRectangleWorkspaceVDUVariables
1387	.0028						src: .dstruct VDUAABB
1268	.0028						min: .dstruct VDUCoordinate
1263	>0028						x: .fill 2
1264	>002a						y: .fill 2
1265							                .endstruct
1269	.002c						max: .dstruct VDUCoordinate
1263	>002c						x: .fill 2
1264	>002e						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1388	.0030						L30:
1389	>0030						                .fill 4
1390	.0034						dest: .dstruct VDUAABB
1268	.0034						min: .dstruct VDUCoordinate
1263	>0034						x: .fill 2
1264	>0036						y: .fill 2
1265							                .endstruct
1269	.0038						max: .dstruct VDUCoordinate
1263	>0038						x: .fill 2
1264	>003a						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1391	.003c						L3C:
1392	>003c						                .fill 4
1393	.0040						L40:
1394	>0040						                .fill 2
1395	.0042						shiftToNextByte:
1396	>0042						                .fill 2
1397	.0044						L44:
1398	>0044						                .fill 1
1399	.0045						copy:
1400	>0045						                .fill 1         ;0=move, 2=copy
1401	.0046						L46:
1402	>0046						                .fill 1
1403	.0047						L47:
1404	>0047						                .fill 1

1406							                .endstruct
1149	.0028						workspace: .dstruct GenericWorkspaceVDUVariables
1273	.0028						_28:
1274	>0028						                .fill 1
1275	.0029						_29:
1276	>0029						                .fill 1
1277	.002a						_2A:
1278	>002a						                .fill 1
1279	.002b						_2B:
1280	>002b						                .fill 1
1281	.002c						_2C:
1282	>002c						                .fill 1
1283	.002d						_2D:
1284	>002d						                .fill 1
1285	.002e						_2E:
1286	>002e						                .fill 1
1287	.002f						_2F:
1288	>002f						                .fill 1
1289	.0030						_30:
1290	>0030						                .fill 1
1291	.0031						_31:
1292	>0031						                .fill 1
1293	.0032						_32:
1294	>0032						                .fill 1
1295	.0033						_33:
1296	>0033						                .fill 1
1297	.0034						_34:
1298	>0034						                .fill 1
1299	.0035						_35:
1300	>0035						                .fill 1
1301	.0036						_36:
1302	>0036						                .fill 1
1303	.0037						_37:
1304	>0037						                .fill 1
1305	.0038						_38:
1306	>0038						                .fill 1
1307	.0039						_39:
1308	>0039						                .fill 1
1309	.003a						_3A:
1310	>003a						                .fill 1
1311	.003b						_3B:
1312	>003b						                .fill 1
1313	.003c						_3C:
1314	>003c						                .fill 1
1315	.003d						_3D:
1316	>003d						                .fill 1
1317	.003e						_3E:
1318	>003e						                .fill 1
1319	.003f						_3F:
1320	>003f						                .fill 1
1321	.0040						_40:
1322	>0040						                .fill 1
1323	.0041						_41:
1324	>0041						                .fill 1
1325	.0042						_42:
1326	>0042						                .fill 1
1327	.0043						_43:
1328	>0043						                .fill 1
1329	.0044						_44:
1330	>0044						                .fill 1
1331	.0045						_45:
1332	>0045						                .fill 1
1333	.0046						_46:
1334	>0046						                .fill 1
1335	.0047						_47:
1336	>0047						                .fill 1
1337	.0048						_48:
1338	>0048						                .fill 1
1339	.0049						_49:
1340	>0049						                .fill 1
1341							                .endstruct
1150							                .endunion
1151							; &4A 2 Address at which the 6845 is to display the text cursor.
1152	>004a						textCursorCRTCAddress: .fill 2
1153							; &4C 2 Number of bytes in a character row of the text window.
1154	>004c						textWindowWidthInBytes: .fill 2
1155							; &4E 1 Most significant byte of address of first byte of screen memory.
1156	>004e						startScreenAddressHighByte: .fill 1
1157							; &4F 1 Number of bytes in a character.
1158	>004f						bytesPerCharacter: .fill 1
1159							; &50 2 Address of byte in top left corner of screen display.
1160	>0050						screenTopLeftAddress: .fill 2
1161							; &52 2 Number of bytes in a character row of the whole screen.
1162	>0052						bytesPerCharacterRow: .fill 2
1163							; &54 1 Most significant byte of number of bytes of screen memory.
1164	>0054						screenSizeHighByte: .fill 1
1165							; &55 1 Current screen mode (in range 0-7, i.e. without regard to 'shadowing').
1166	>0055						currentScreenMODE: .fill 1
1167							; &56 1 Memory mode: 0 for 20K modes, 1 for 16K modes, 2 for 10K modes, 3 for 8K modes, 4 for 1K modes.
1168	>0056						currentScreenMODEGroup: .fill 1
1169							; &57 1 Foreground text colour mask.
1170	>0057						foregroundTextColour: .fill 1
1171							; &58 1 Background text colour mask.
1172	>0058						backgroundTextColour: .fill 1
1173							; &59 1 0 if plotting graphics foreground, 8 if plotting graphics background.
1174	>0059						graphicsPlotState: .fill 1
1175							; &5A 1 Current graphics plot mode (usually set to one of following two reduced mod 16).
1176	>005a						graphicsPlotMode: .fill 1
1177							; &5B 1 Current graphics foreground plot mode (as set by VDU 18).
1178	>005b						foregroundGCOLMode: .fill 1
1179							; &5C 1 Current graphics background plot mode (as set by VDU 18).
1180	>005c						backgroundGCOLMode: .fill 1
1181							; &5D 2 Address of routine to process current VDU sequence.
1182	>005d						jumpVector: .fill 2
1183							; &5F 1 Value for 6845 register 10 to revert to on leaving cursor editing.
1184	>005f						lastCursorStartRegisterValue: .fill 1
1185							; &60 1 (Number of logical colours)-1 (0 if Teletext).
1186	>0060						numberOfLogicalColoursMinusOne: .fill 1
1187							; &61 1 (Number of pixels/byte)-1 (0 if not graphics).
1188	>0061						pixelsPerByteMinusOne: .fill 1
1189							; &62 1 Mask for leftmost pixel in a byte.
1190	>0062						colourMaskLeft: .fill 1
1191							; &63 1 Mask for rightmost pixel in a byte.
1192	>0063						colourMaskRight: .fill 1
1193							; &64 1 Output cursor X coordinate when cursor editing, but input cursor X coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1194	>0064						editCursorXPosition: .fill 1
1195							; &65 1 Output cursor Y coordinate when cursor editing, but input cursor Y coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1196	>0065						editCursorYPosition: .fill 1
1197							; &66 1 Cursor control flags (as set by VDU 23 16).
1198	.0066						cursorFlags: .block
1199	>0066						                .fill 1
1200							; MasRef E.3-18
1201	=$40						noSpecialVDU5Actions=$40
1202	=$20						noMoveCursorAfterPrint=$20
1203	=$10						noVerticalScroll=$10
1204	=$08						swapAxes=$08                    ;if set, X=vert; if clear, X=horiz
1205	=$04						invertVertical=$04              ;if set, vert=up; if clear, vert=down
1206	=$02						invertHorizontal=$02            ;if set, horiz=left; if clear, horiz=right
1207	=$01						scrollProtect=$01
1208							                .endblock
1209							; &67 1 Dot pattern (as set by VDU 23 6).
1210	>0067						dotPattern: .fill 1
1211							; &68 1 Current state of dot pattern.
1212	>0068						dotPatternState: .fill 1
1213							; &69 1 0 if colour being plotted is solid, non-zero if colour is an ECF
1214	>0069						isColourECF: .fill 1
1215							; &6A 1 0 if graphics foreground colour is solid, non-zero if foreground colour is an ECF
1216	>006a						isForegroundECF: .fill 1
1217							; &6B 1 0 if graphics background colour is solid, non-zero if background colour is an ECF
1218	>006b						isBackgroundECF: .fill 1
1219							; &6C 1 Top bit set when cursor is in "column 81".
1220	>006c						column81: .fill 1
1221							; &6D 1 Current graphics foreground colour (as set by VDU 18).
1222	>006d						foregroundGraphicsColour: .fill 1
1223							; &6E 1 Current graphics background colour (as set by VDU 18)
1224	>006e						backgroundGraphicsColour: .fill 1
1225							; &6F-&7E Software copy of the current palette.
1226	>006f						currentPalette: .fill 16
1227							; &7F 1 Reserved.
1228	>007f						reserved: .fill 1
1229							                .endstruct

1231							                .virtual $300
1232	.0300						vduv: .dstruct VDUVariables
1096	.0300						graphicsWindow:
1097							;graphicsWindowLeftBottom:
1098							; &00 2 Graphics window left column. (p)
1099	>0300						graphicsWindowPixelsLeft: .fill 2
1100							; &02 2 Graphics window bottom row. (p)
1101	>0302						graphicsWindowPixelsBottom: .fill 2
1102							;graphicsWindowRightTop:
1103							; &04 2 Graphics window right column. (p)
1104	>0304						graphicsWindowPixelsRight: .fill 2
1105							; &06 2 Graphics window top row. (p)
1106	>0306						graphicsWindowPixelsTop: .fill 2
1107	.0308						textWindow:
1108							; &08 1 Text window left column.
1109	>0308						textWindowLeft: .fill 1
1110							; &09 1 Text window bottom row.
1111	>0309						textWindowBottom: .fill 1
1112							; &0A 1 Text window right column.
1113	>030a						textWindowRight: .fill 1
1114							; &0B 1 Text window top row.
1115	>030b						textWindowTop: .fill 1
1116							; &0C 2 Graphics origin X coordinate. (e)
1117	>030c						graphicsWindowOriginX: .fill 2
1118							; &0E 2 Graphics origin Y coordinate. (e)
1119	>030e						graphicsWindowOriginY: .fill 2
1120							; &10 2 Graphics cursor X coordinate. (e)
1121	>0310						graphicsCursorPositionX: .fill 2
1122							; &12 2 Graphics cursor Y coordinate. (e)
1123	>0312						graphicsCursorPositionY: .fill 2
1124							; &14 2 Previous graphics cursor X coordinate. (p)
1125	.0314						oldGraphicsCursorPixels:
1126	>0314						oldGraphicsCursorPixelsX: .fill 2
1127							; &16 2 Previous graphics cursor Y coordinate. (p)
1128	>0316						oldGraphicsCursorPixelsY: .fill 2
1129							; &18 1 Text cursor X coordinate (from left of screen) when not cursor editing. When cursor editing, normally the input cursor X coordinate, but the output cursor X coordinate within an "unknown PLOT codes" routine.
1130	>0318						textCursorXPosition: .fill 1
1131							; &19 1 Text cursor Y coordinate (from top of screen) when not cursor editing. When cursor editing, normally t.lsthe input cursor Y coordinate, but the output cursor Y coordinate within an "unknown PLOT codes" routine.
1132	>0319						textCursorYPosition: .fill 1
1133							; &1A 1 Y produced by GADDR (see next section) so that (ZMEMG),Y addresses the correct byte.
1134	>031a						graphicsAddressOffset: .fill 1
1135							; &1B-&23 VDU queue: &23 contains last byte of queue, other bytes immediately precede it.
1136	=9						queueSize=9
1137	>031b						queueBegin: .fill queueSize
1138	.0324						queueEnd:
1139	.0324						graphicsCursorPixels:
1140							; &24 2 Graphics cursor X coordinate. (p)
1141	>0324						graphicsCursorPixelsX: .fill 2
1142							; &26 2 Graphics cursor Y coordinate. (p)
1143	>0326						graphicsCursorPixelsY: .fill 2
1144							; &28-&49 Workspace. But variable &38 must not be used in a Teletext mode (mode 7 or 135).
1145							                .union
1146	.0328						ew: .dstruct EllipseWorkspaceVDUVariables
1344							                ; https://tobylobster.github.io/GXR-pages/gxr/S-s3.html#SP4
1345	.0328						aspectRatio:
1346	>0328						                .fill 3
1347	.032b						shear:
1348	>032b						                .fill 3
1349	.032e						halfHeightCounter:
1350	>032e						                .fill 2
1351	.0330						halfHeightSquared:
1352	>0330						                .fill 4
1353	.0334						pointC:
1354	>0334						                .fill 2
1355	.0336						pointD:
1356	>0336						                .fill 2
1357	.0338						leftPoint:
1358	>0338						                .fill 2
1359	.033a						rightPoint:
1360	>033a						                .fill 2
1361	.033c						pointA:
1362	>033c						                .fill 2
1363	.033e						pointB:
1364	>033e						                .fill 2
1365	.0340						pointE:
1366	>0340						                .fill 2
1367	.0342						currentOffsetX:
1368	>0342						                .fill 2
1369	.0344						plotPointX:
1370	.0344						pointF:
1371	>0344						                .fill 2
1372	.0346						plotPointY:
1373	>0346						                .fill 2
1374							                .endstruct
1147	.0328						hlfw: .dstruct HorizontalLineFillWorkspaceVDUVariables
1409	>0328						                .fill 6
1410	.032e						pixelsX:                        ;2e
1411	>032e						                .fill 2
1412	.0330						pixelsY:                        ;30
1413	>0330						                .fill 2
1414	.0332						pixelsRightEndX:
1415	>0332						                .fill 2         ;32
1416	.0334						pixelsLimitX:                   ;34
1417	>0334						                .fill 2
1418							                .endstruct
1148	.0328						mocr: .dstruct MoveOrCopyRectangleWorkspaceVDUVariables
1387	.0328						src: .dstruct VDUAABB
1268	.0328						min: .dstruct VDUCoordinate
1263	>0328						x: .fill 2
1264	>032a						y: .fill 2
1265							                .endstruct
1269	.032c						max: .dstruct VDUCoordinate
1263	>032c						x: .fill 2
1264	>032e						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1388	.0330						L30:
1389	>0330						                .fill 4
1390	.0334						dest: .dstruct VDUAABB
1268	.0334						min: .dstruct VDUCoordinate
1263	>0334						x: .fill 2
1264	>0336						y: .fill 2
1265							                .endstruct
1269	.0338						max: .dstruct VDUCoordinate
1263	>0338						x: .fill 2
1264	>033a						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1391	.033c						L3C:
1392	>033c						                .fill 4
1393	.0340						L40:
1394	>0340						                .fill 2
1395	.0342						shiftToNextByte:
1396	>0342						                .fill 2
1397	.0344						L44:
1398	>0344						                .fill 1
1399	.0345						copy:
1400	>0345						                .fill 1         ;0=move, 2=copy
1401	.0346						L46:
1402	>0346						                .fill 1
1403	.0347						L47:
1404	>0347						                .fill 1

1406							                .endstruct
1149	.0328						workspace: .dstruct GenericWorkspaceVDUVariables
1273	.0328						_28:
1274	>0328						                .fill 1
1275	.0329						_29:
1276	>0329						                .fill 1
1277	.032a						_2A:
1278	>032a						                .fill 1
1279	.032b						_2B:
1280	>032b						                .fill 1
1281	.032c						_2C:
1282	>032c						                .fill 1
1283	.032d						_2D:
1284	>032d						                .fill 1
1285	.032e						_2E:
1286	>032e						                .fill 1
1287	.032f						_2F:
1288	>032f						                .fill 1
1289	.0330						_30:
1290	>0330						                .fill 1
1291	.0331						_31:
1292	>0331						                .fill 1
1293	.0332						_32:
1294	>0332						                .fill 1
1295	.0333						_33:
1296	>0333						                .fill 1
1297	.0334						_34:
1298	>0334						                .fill 1
1299	.0335						_35:
1300	>0335						                .fill 1
1301	.0336						_36:
1302	>0336						                .fill 1
1303	.0337						_37:
1304	>0337						                .fill 1
1305	.0338						_38:
1306	>0338						                .fill 1
1307	.0339						_39:
1308	>0339						                .fill 1
1309	.033a						_3A:
1310	>033a						                .fill 1
1311	.033b						_3B:
1312	>033b						                .fill 1
1313	.033c						_3C:
1314	>033c						                .fill 1
1315	.033d						_3D:
1316	>033d						                .fill 1
1317	.033e						_3E:
1318	>033e						                .fill 1
1319	.033f						_3F:
1320	>033f						                .fill 1
1321	.0340						_40:
1322	>0340						                .fill 1
1323	.0341						_41:
1324	>0341						                .fill 1
1325	.0342						_42:
1326	>0342						                .fill 1
1327	.0343						_43:
1328	>0343						                .fill 1
1329	.0344						_44:
1330	>0344						                .fill 1
1331	.0345						_45:
1332	>0345						                .fill 1
1333	.0346						_46:
1334	>0346						                .fill 1
1335	.0347						_47:
1336	>0347						                .fill 1
1337	.0348						_48:
1338	>0348						                .fill 1
1339	.0349						_49:
1340	>0349						                .fill 1
1341							                .endstruct
1150							                .endunion
1151							; &4A 2 Address at which the 6845 is to display the text cursor.
1152	>034a						textCursorCRTCAddress: .fill 2
1153							; &4C 2 Number of bytes in a character row of the text window.
1154	>034c						textWindowWidthInBytes: .fill 2
1155							; &4E 1 Most significant byte of address of first byte of screen memory.
1156	>034e						startScreenAddressHighByte: .fill 1
1157							; &4F 1 Number of bytes in a character.
1158	>034f						bytesPerCharacter: .fill 1
1159							; &50 2 Address of byte in top left corner of screen display.
1160	>0350						screenTopLeftAddress: .fill 2
1161							; &52 2 Number of bytes in a character row of the whole screen.
1162	>0352						bytesPerCharacterRow: .fill 2
1163							; &54 1 Most significant byte of number of bytes of screen memory.
1164	>0354						screenSizeHighByte: .fill 1
1165							; &55 1 Current screen mode (in range 0-7, i.e. without regard to 'shadowing').
1166	>0355						currentScreenMODE: .fill 1
1167							; &56 1 Memory mode: 0 for 20K modes, 1 for 16K modes, 2 for 10K modes, 3 for 8K modes, 4 for 1K modes.
1168	>0356						currentScreenMODEGroup: .fill 1
1169							; &57 1 Foreground text colour mask.
1170	>0357						foregroundTextColour: .fill 1
1171							; &58 1 Background text colour mask.
1172	>0358						backgroundTextColour: .fill 1
1173							; &59 1 0 if plotting graphics foreground, 8 if plotting graphics background.
1174	>0359						graphicsPlotState: .fill 1
1175							; &5A 1 Current graphics plot mode (usually set to one of following two reduced mod 16).
1176	>035a						graphicsPlotMode: .fill 1
1177							; &5B 1 Current graphics foreground plot mode (as set by VDU 18).
1178	>035b						foregroundGCOLMode: .fill 1
1179							; &5C 1 Current graphics background plot mode (as set by VDU 18).
1180	>035c						backgroundGCOLMode: .fill 1
1181							; &5D 2 Address of routine to process current VDU sequence.
1182	>035d						jumpVector: .fill 2
1183							; &5F 1 Value for 6845 register 10 to revert to on leaving cursor editing.
1184	>035f						lastCursorStartRegisterValue: .fill 1
1185							; &60 1 (Number of logical colours)-1 (0 if Teletext).
1186	>0360						numberOfLogicalColoursMinusOne: .fill 1
1187							; &61 1 (Number of pixels/byte)-1 (0 if not graphics).
1188	>0361						pixelsPerByteMinusOne: .fill 1
1189							; &62 1 Mask for leftmost pixel in a byte.
1190	>0362						colourMaskLeft: .fill 1
1191							; &63 1 Mask for rightmost pixel in a byte.
1192	>0363						colourMaskRight: .fill 1
1193							; &64 1 Output cursor X coordinate when cursor editing, but input cursor X coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1194	>0364						editCursorXPosition: .fill 1
1195							; &65 1 Output cursor Y coordinate when cursor editing, but input cursor Y coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1196	>0365						editCursorYPosition: .fill 1
1197							; &66 1 Cursor control flags (as set by VDU 23 16).
1198	.0366						cursorFlags: .block
1199	>0366						                .fill 1
1200							; MasRef E.3-18
1201	=$40						noSpecialVDU5Actions=$40
1202	=$20						noMoveCursorAfterPrint=$20
1203	=$10						noVerticalScroll=$10
1204	=$08						swapAxes=$08                    ;if set, X=vert; if clear, X=horiz
1205	=$04						invertVertical=$04              ;if set, vert=up; if clear, vert=down
1206	=$02						invertHorizontal=$02            ;if set, horiz=left; if clear, horiz=right
1207	=$01						scrollProtect=$01
1208							                .endblock
1209							; &67 1 Dot pattern (as set by VDU 23 6).
1210	>0367						dotPattern: .fill 1
1211							; &68 1 Current state of dot pattern.
1212	>0368						dotPatternState: .fill 1
1213							; &69 1 0 if colour being plotted is solid, non-zero if colour is an ECF
1214	>0369						isColourECF: .fill 1
1215							; &6A 1 0 if graphics foreground colour is solid, non-zero if foreground colour is an ECF
1216	>036a						isForegroundECF: .fill 1
1217							; &6B 1 0 if graphics background colour is solid, non-zero if background colour is an ECF
1218	>036b						isBackgroundECF: .fill 1
1219							; &6C 1 Top bit set when cursor is in "column 81".
1220	>036c						column81: .fill 1
1221							; &6D 1 Current graphics foreground colour (as set by VDU 18).
1222	>036d						foregroundGraphicsColour: .fill 1
1223							; &6E 1 Current graphics background colour (as set by VDU 18)
1224	>036e						backgroundGraphicsColour: .fill 1
1225							; &6F-&7E Software copy of the current palette.
1226	>036f						currentPalette: .fill 16
1227							; &7F 1 Reserved.
1228	>037f						reserved: .fill 1
1229							                .endstruct
1233							                .endvirtual

1235							; vduQueueItemAddr: .function index
1236							;                 .cerror index<0||index>=vdu.queueSize,"bad VDU queue index"
1237							;                 .endfunction vdu.queue+vdu.queueSize-1-index

1239							; Presumed addresses in ANDY that don't happen to coincide with other
1240							; labels.
1241							;
1242							; MasRef E.4-5, MasRef F.6-10
1243							;
1244							; &8000-83FF  RAM  Soft key expansions buffer
1245							; &8400-87FF  RAM  VDU workspace.
1246							; &8800-07    RAM  ECF pattern 1 definition.
1247							; &8808-0F    RAM  ECF pattern 2 definition.
1248							; &8810-17    RAM  ECF pattern 3 definition.
1249							; &8818-1F    RAM  ECF pattern 4 definition.
1250							; &8820-27    RAM  Current foreground ECF pattern or solid colour.
1251							; &8828-2F    RAM  Current background ECF pattern or solid colour.
1252							; &8830-BF    RAM  VDU workspace.
1253							; &88C0-FF    RAM  Reserved for future expansion.
1254							; &8900-FF    RAM  Current definitions of characters &20-3F.
1255							; &8A00-FF    RAM  Current definitions of characters &40-5F.
1256							; &8B00-FF    RAM  Current definitions of characters &60-7F.
1257							; &8C00-FF    RAM  Current definitions of characters &80-9F.
1258							; &8D00-FF    RAM  Current definitions of characters &A0-BF.
1259							; &8E00-FF    RAM  Current definitions of characters &C0-DF.
1260							; &8F00-FF    RAM  Current definitions of characters &E0-FF.

1262							VDUCoordinate: .struct
1263	>0000						x: .fill 2
1264	>0002						y: .fill 2
1265							                .endstruct

1267							VDUAABB: .struct
1268	.0000						min: .dstruct VDUCoordinate
1263	>0000						x: .fill 2
1264	>0002						y: .fill 2
1265							                .endstruct
1269	.0004						max: .dstruct VDUCoordinate
1263	>0004						x: .fill 2
1264	>0006						y: .fill 2
1265							                .endstruct
1270							                .endstruct

1272							GenericWorkspaceVDUVariables: .struct
1273	.0000						_28:
1274	>0000						                .fill 1
1275	.0001						_29:
1276	>0001						                .fill 1
1277	.0002						_2A:
1278	>0002						                .fill 1
1279	.0003						_2B:
1280	>0003						                .fill 1
1281	.0004						_2C:
1282	>0004						                .fill 1
1283	.0005						_2D:
1284	>0005						                .fill 1
1285	.0006						_2E:
1286	>0006						                .fill 1
1287	.0007						_2F:
1288	>0007						                .fill 1
1289	.0008						_30:
1290	>0008						                .fill 1
1291	.0009						_31:
1292	>0009						                .fill 1
1293	.000a						_32:
1294	>000a						                .fill 1
1295	.000b						_33:
1296	>000b						                .fill 1
1297	.000c						_34:
1298	>000c						                .fill 1
1299	.000d						_35:
1300	>000d						                .fill 1
1301	.000e						_36:
1302	>000e						                .fill 1
1303	.000f						_37:
1304	>000f						                .fill 1
1305	.0010						_38:
1306	>0010						                .fill 1
1307	.0011						_39:
1308	>0011						                .fill 1
1309	.0012						_3A:
1310	>0012						                .fill 1
1311	.0013						_3B:
1312	>0013						                .fill 1
1313	.0014						_3C:
1314	>0014						                .fill 1
1315	.0015						_3D:
1316	>0015						                .fill 1
1317	.0016						_3E:
1318	>0016						                .fill 1
1319	.0017						_3F:
1320	>0017						                .fill 1
1321	.0018						_40:
1322	>0018						                .fill 1
1323	.0019						_41:
1324	>0019						                .fill 1
1325	.001a						_42:
1326	>001a						                .fill 1
1327	.001b						_43:
1328	>001b						                .fill 1
1329	.001c						_44:
1330	>001c						                .fill 1
1331	.001d						_45:
1332	>001d						                .fill 1
1333	.001e						_46:
1334	>001e						                .fill 1
1335	.001f						_47:
1336	>001f						                .fill 1
1337	.0020						_48:
1338	>0020						                .fill 1
1339	.0021						_49:
1340	>0021						                .fill 1
1341							                .endstruct

1343							EllipseWorkspaceVDUVariables: .struct
1344							                ; https://tobylobster.github.io/GXR-pages/gxr/S-s3.html#SP4
1345	.0000						aspectRatio:
1346	>0000						                .fill 3
1347	.0003						shear:
1348	>0003						                .fill 3
1349	.0006						halfHeightCounter:
1350	>0006						                .fill 2
1351	.0008						halfHeightSquared:
1352	>0008						                .fill 4
1353	.000c						pointC:
1354	>000c						                .fill 2
1355	.000e						pointD:
1356	>000e						                .fill 2
1357	.0010						leftPoint:
1358	>0010						                .fill 2
1359	.0012						rightPoint:
1360	>0012						                .fill 2
1361	.0014						pointA:
1362	>0014						                .fill 2
1363	.0016						pointB:
1364	>0016						                .fill 2
1365	.0018						pointE:
1366	>0018						                .fill 2
1367	.001a						currentOffsetX:
1368	>001a						                .fill 2
1369	.001c						plotPointX:
1370	.001c						pointF:
1371	>001c						                .fill 2
1372	.001e						plotPointY:
1373	>001e						                .fill 2
1374							                .endstruct

1376							HorizontalLineFillWorkspaceZP: .struct
1377	>0000						notByteMatch: .fill 1
1378	>0001						a: .fill 1
1379	>0002						b: .fill 2
1380							;c: .fill 2
1381	>0004						pixelsX: .fill 2
1382	>0006						d: .fill 1
1383	>0007						resultEOR: .fill 1
1384							                .endstruct

1386							MoveOrCopyRectangleWorkspaceVDUVariables: .struct
1387	.0000						src: .dstruct VDUAABB
1268	.0000						min: .dstruct VDUCoordinate
1263	>0000						x: .fill 2
1264	>0002						y: .fill 2
1265							                .endstruct
1269	.0004						max: .dstruct VDUCoordinate
1263	>0004						x: .fill 2
1264	>0006						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1388	.0008						L30:
1389	>0008						                .fill 4
1390	.000c						dest: .dstruct VDUAABB
1268	.000c						min: .dstruct VDUCoordinate
1263	>000c						x: .fill 2
1264	>000e						y: .fill 2
1265							                .endstruct
1269	.0010						max: .dstruct VDUCoordinate
1263	>0010						x: .fill 2
1264	>0012						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1391	.0014						L3C:
1392	>0014						                .fill 4
1393	.0018						L40:
1394	>0018						                .fill 2
1395	.001a						shiftToNextByte:
1396	>001a						                .fill 2
1397	.001c						L44:
1398	>001c						                .fill 1
1399	.001d						copy:
1400	>001d						                .fill 1         ;0=move, 2=copy
1401	.001e						L46:
1402	>001e						                .fill 1
1403	.001f						L47:
1404	>001f						                .fill 1

1406							                .endstruct

1408							HorizontalLineFillWorkspaceVDUVariables: .struct
1409	>0000						                .fill 6
1410	.0006						pixelsX:                        ;2e
1411	>0006						                .fill 2
1412	.0008						pixelsY:                        ;30
1413	>0008						                .fill 2
1414	.000a						pixelsRightEndX:
1415	>000a						                .fill 2         ;32
1416	.000c						pixelsLimitX:                   ;34
1417	>000c						                .fill 2
1418							                .endstruct

1420							HorizontalLineFillWorkspaceANDY: .struct
1421	>0000						ecfPattern: .fill 8
1422							                .endstruct

1424	=16						softKeyCount=16
1425	=$400						softKeyDataTotalSize=$400

1427							                .virtual $8000
1428	.8000						andy: .block
1429	.8000						softKeys: .block
1430	>8000						stringLSBs: .fill softKeyCount
1431	>8010						endLSB: .fill 1
1432	>8011						stringMSBs: .fill softKeyCount
1433	>8021						endMSB: .fill 1
1434	.8022						strings:
1435	>8022						                .fill softKeys+$400-*
1436	.8400						end:
1437							                .endblock
1438	>8400						                .fill $8800-*;(softKeyCount*2+1)
1439	.8800						ecfPatterns:
1440	>8800						ecfPattern1: .fill 8
1441	>8808						ecfPattern2: .fill 8
1442	>8810						ecfPattern3: .fill 8
1443	>8818						ecfPattern4: .fill 8
1444	.8820						currentECFPatterns:
1445	>8820						fgECFPattern: .fill 8
1446	>8828						bgECFPattern: .fill 8
1447	.8830						workspace:
1448							                .union
1449	.8830						hlfw: .dstruct HorizontalLineFillWorkspaceANDY
1421	>8830						ecfPattern: .fill 8
1422							                .endstruct
1450	>8830						                .fill 208
1451							                .endunion
1452	.8900						softCharacterDefinitions:
1453	>8900						                .fill (256-32)*8
1454							                .cerror (<andy.softCharacterDefinitions)!=0,"Soft character definitions must be page aligned"
1455							                .cerror *!=$9000,"ANDY is the wrong size"
1456							                .endblock
1457							                .endvirtual


1460	=$8000						L8000=$8000
1461	=$8001						L8001=$8001
1462	=$8002						L8002=$8002
1463	=$8004						L8004=$8004
1464	=$8010						L8010=$8010
1465	=$8011						L8011=$8011
1466	=$8012						L8012=$8012
1467							                ;l8011=$8011
1468							                ;l8012=$8012
1469	=$8021						L8021=$8021

1471							; see $d40d, $d4ae
1472							;
1473							; (suspect these are actually references to $8840-$104 and $8848-$104)
1474	=$873c						L873C=$873c
1475	=$8744						L8744=$8744

1477	=$8400						L8400=$8400
1478	=$8500						L8500=$8500
1479	=$8600						L8600=$8600
1480	=$8700						L8700=$8700
1481	=$87f8						L87F8=$87f8
1482	=$87ff						L87FF=$87FF
1483	=$8800						L8800=$8800
1484	=$8803						L8803=$8803
1485	=$8804						L8804=$8804
1486	=$881e						L881E=$881E
1487	=$8820						L8820=$8820
1488	=$8830						multiplicand=$8830              ; 3 bytes
1489	=$8830						L8830=$8830
1490	=$8831						L8831=$8831
1491	=$8832						L8832=$8832
1492	=$8833						L8833=$8833
1493	=$8834						multiplier=$8834                ; 3 bytes
1494	=$8834						product=$8834                   ; 6 bytes
1495	=$8834						sqrtNumber=$8834                ; 6 bytes
1496	=$8834						L8834=$8834
1497	=$8835						L8835=$8835
1498	=$8836						L8836=$8836
1499	=$8837						L8837=$8837
1500	=$8838						L8838=$8838
1501	=$8839						L8839=$8839
1502							;dividend=$883a                  ; 3 bytes
1503	=$883a						L883A=$883a
1504	=$883b						L883B=$883b
1505	=$883c						L883C=$883C
1506	=$883d						L883D=$883D
1507							;divisor=$883e                   ; 3 bytes
1508	=$883e						L883E=$883e
1509	=$883f						L883F=$883f
1510	=$8840						L8840=$8840
1511	=$8841						ellipseSignFlag=$8841           ; 1 byte
1512	=$8841						L8841=$8841
1513	=$8842						ellipseAccumulatedShear=$8842   ; 3 bytes
1514	=$8842						L8842=$8842
1515	=$8843						L8843=$8843
1516	=$8844						L8844=$8844
1517	=$8845						ellipseCountOddNumbers=$8845    ; 4 bytes
1518	=$8845						L8845=$8845
1519	=$8846						L8846=$8846
1520	=$8847						L8847=$8847
1521	=$8848						L8848=$8848
1522	=$8849						ellipseCountSquares=$8849       ; 4 bytes
1523	=$8849						L8849=$8849
1524	=$884a						L884A=$884a
1525	=$884b						L884B=$884b
1526	=$884c						L884C=$884c
1527	=$884d						ellipseCountHeight=$884d

1529							                ; written to during startup
1530	=$fe8e						LFE8E=$fe8e

1532							;-------------------------------------------------------------------------

1534							                .if includeTubeSupport
1535							                .virtual $00
1536							                .union
1537	.0000						tubeOSFILEParameterBlock: .dstruct OSFILEParameterBlock
418	.0000						fileName:
419	>0000						                .fill 2
420	.0002						addresses:
421	.0002						load:
422	>0002						                .fill 4
423	.0006						exec:
424	>0006						                .fill 4
425	.000a						length:
426	.000a						saveStart:
427	>000a						                .fill 4
428	.000e						attributes:
429	.000e						saveEnd:
430	>000e						                .fill 4
431							                .endstruct
1538	.0000						tubeOSGBPBParameterBlock: .dstruct OSGBPBParameterBlock
387	.0000						handle:
388	>0000						                .fill 1
389	.0001						address:
390	>0001						                .fill 4
391	.0005						count:
392	>0005						                .fill 4
393	.0009						ptr:
394	>0009						                .fill 4
395							                .endstruct
1539	>0000						tubeLanguageHostAddr: .fill 2
1540							                .endunion
1541	>0012						tubeTransferAddr: .fill 2
1542	>0014						tubeNotClaimed: .fill 1            ;bit 7 clear if tube claimed
1543	>0015						tubeClaimantID: .fill 1
1544	.0016						tubeBrkHandlerAddr:
1545							                ; Tube BRK handler sits here.
1546							                .endv

1548	=$700						tubeStringBuffer=$700
1549	=$0128						tubeOSWORDBuffer=$0128

1551							                .virtual $53
1552	>0053						tubeLanguageParasiteAddr: .fill 4
1553							                .endv

1555							                .endif

1557							;-------------------------------------------------------------------------
1558							; MasRef E.4-4
1559							                .virtual $d0
1560	.00d0						STATE: .block
1561	>00d0						                .fill 1
1562							                ; D.2-32
1563	=$01						isPrinterEnabled=$01
1564	=$02						isScrollingDisabled=$02
1565	=$04						isPagedScrolling=$04
1566	=$08						isTextWindow=$08
1567	=$10						isShadowMode=$10
1568	=$20						isVDU5=$20
1569	=$40						isCursorEditing=$40
1570	=$80						isVDU21=$80
1571							                .bend

1573	>00d1						ZMASK: .fill 1                       ;Pixel mask
1574	>00d2						ZORA: .fill 1                        ;Text OR mask
1575	>00d3						ZEOR: .fill 1                        ;Text EOR mask
1576	>00d4						ZGORA: .fill 1                       ;Graphics OR mask
1577	>00d5						ZGEOR: .fill 1                       ;Graphics EOR mask
1578	>00d6						ZMEMG: .fill 2                       ;Graphics pointer
1579	>00d8						ZMEMT: .fill 2                       ;Text pointer
1580	>00da						ZTEMP: .fill 2                       ;Temporary space
1581	>00dc						ZTEMPB: .fill 2                      ;Temporary space
1582	>00de						ZTEMPC: .fill 2                      ;Temporary space
1583	>00e0						ZTEMPD: .fill 2                      ;Temporary space
1584							                .endv

1586							                .virtual ZTEMP
1587	.00da						zhlfw: .dstruct HorizontalLineFillWorkspaceZP
1377	>00da						notByteMatch: .fill 1
1378	>00db						a: .fill 1
1379	>00dc						b: .fill 2
1380							;c: .fill 2
1381	>00de						pixelsX: .fill 2
1382	>00e0						d: .fill 1
1383	>00e1						resultEOR: .fill 1
1384							                .endstruct
1588							                .endv


1591	=$f8						softKeyExpansionPtr=$f8       ;pointer to current char when expanding soft key.
1592	=$fa						SEIWKA=$fa
1593	=$fb						SEIWKB=$fb

1595	=$d8						vduWriteCursor=$d8

1597	=$d00						nmiEntryPoint=$d00

1599	=0						gcolModeOverwrite=0
1600	=1						gcolModeOR=1
1601	=2						gcolModeAND=2
1602	=3						gcolModeEOR=3
1603	=4						gcolModeInvert=4
1604	=5						gcolModeLeave=5

1606							;-------------------------------------------------------------------------

1608							StarKEYWorkspace: .struct
1609	>0000						newStringLength: .fill 1
1610	>0001						destPtr: .fill 2
1611	>0003						srcPtr: .fill 2
1612	>0005						counter: .fill 2
1613							                .endstruct

1615							OSGBPBWorkspace: .struct
1616	>0000						ptr: .fill 2
1617							                .endstruct

1619							ParseFileNameFSWorkspace: .struct
1620	>0000						fsInfoOffset: .fill 1
1621							                .endstruct

1623							OSCLIWorkspace: .struct
1624	>0000						tablePtr: .fill 2
1625							                .endstruct

1627							                ; TODO - could do being renamed, as it's used (in the
1628							                ; same way) by *UNPLUG and *INSERT.
1629							StarROMSWorkspace: .struct
1630	>0000						insertedFlagMask: .fill 1
1631							                .endstruct

1633							TerminalHELPWorkspace: .struct
1634	>0000						tablePtr: .fill 2
1635							                .endstruct

1637							                ; TODO - tediously verbose names. Acronyms work well
1638							                ; enough for the VDU variables. Do the same thing
1639							                ; here.
1640							                .virtual $b0
1641							                .union
1642	.00b0						starKEYWorkspace: .dstruct StarKEYWorkspace
1609	>00b0						newStringLength: .fill 1
1610	>00b1						destPtr: .fill 2
1611	>00b3						srcPtr: .fill 2
1612	>00b5						counter: .fill 2
1613							                .endstruct
1643	.00b0						osgbpbWorkspace: .dstruct OSGBPBWorkspace
1616	>00b0						ptr: .fill 2
1617							                .endstruct
1644	.00b0						parseFileNameFSWorkspace: .dstruct ParseFileNameFSWorkspace
1620	>00b0						fsInfoOffset: .fill 1
1621							                .endstruct
1645	.00b0						oscliWorkspace: .dstruct OSCLIWorkspace
1624	>00b0						tablePtr: .fill 2
1625							                .endstruct
1646	.00b0						starROMSWorkspace: .dstruct StarROMSWorkspace
1630	>00b0						insertedFlagMask: .fill 1
1631							                .endstruct
1647	.00b0						terminalHELPWorkspace: .dstruct TerminalHELPWorkspace
1634	>00b0						tablePtr: .fill 2
1635							                .endstruct
1648							                .endunion
1649							                .endvirtual

1651							;-------------------------------------------------------------------------

1653							; ROM number containing Terminal
1654	=15						terminalROM=15

1656							; ROM number containing the extXXXX entry points
1657							                .if !includeTerminalROM
1664							                .elsif version==350
1665	=9						extROM=9
1668							                .endif

1670							; Base page for VDU routines
1671	=$c0						vduRoutinesPage=$c0

1673							                .if version<500
1674	=14						cmosBytesOffset=RTC.ram
1677							                .endif

1679							CMOSBytes: .struct
1680	>0000						econetStationNumber: .fill 1
1681	>0001						fileServerStationNumber: .fill 1
1682	>0002						fileServerNetworkNumber: .fill 1
1683	>0003						printerServerStationNumber: .fill 1
1684	>0004						printerServerNetworkNumber: .fill 1
1685	.0005						defaultROMs: .block
1686	>0005						                .fill 1
1687	=0						fsShift=0
1688	=4						languageShift=4
1689							                .endblock

1691	>0006						insertedROMs: .fill 2

1693	>0008						editROMByte: .fill 1
1694	>0009						telecommsByte: .fill 1

1696	.000a						defaults0: .block
1697	>000a						                .fill 1
1698	=0						modeShift=0
1699	=7						modeMask=7
1700	=8						shadowMask=8
1701	=16						interlaceMask=16
1702	=7						tvMask=7
1703	=5						tvShift=5
1704							                .endblock

1706	.000b						defaults1: .block
1707	>000b						                .fill 1
1708	=0						fdriveShift=0
1709	=7						fdriveMask=7
1710	=8						shiftLockMask=8
1711	=16						noLockMask=16
1712	=32						capsLockMask=32
1713	=64						adfsLoadDirMask=64
1714	=128						floppyDrive=128
1715							                .endblock

1717	>000c						keyboardAutoRepeatDelay: .fill 1
1718	>000d						keyboardAutoRepeatRate: .fill 1
1719	>000e						printerIgnoreChar: .fill 1

1721	.000f						defaults2: .block
1722	>000f						                .fill 1
1723							                .if includeTubeSupport
1724	=1						tubeOnMask=1
1725							                .endif
1726	=2						usePrinterIgnoreCharMask=2
1727	=7						serialBaudRateIndexMask=7
1728	=2						serialBaudRateIndexShift=2
1729	=7						fx5SettingMask=7
1730	=5						fx5SettingShift=5
1731							                .endblock

1733	.0010						defaults3: .block
1734	>0010						                .fill 1
1735	=2						loudMask=2
1736							                .if includeTubeSupport
1737	=4						extTubeMask=4
1738							                .endif
1739	=8						protectedScrollingMask=8
1740	=16						autoBootMask=16
1741	=7						serialDataFormatMask=7
1742	=5						serialDataFormatShift=5
1743							                .endblock

1745							                .if version>=500
1764							                .endif

1766							                .endstruct

1768	=$ef						originalA=$ef
1769	=$f0						originalX=$f0
1770	=$f1						originalY=$f1
1771	=$fc						TEMPA=$fc
1772	=$fd						errPtr=$fd                      ;REPTR in OS 1.20
1773	=$ff						escapeFlag=$ff

1775	=$8c0						envelope1Data=$8c0

1777	=$8000						sidewaysROMLanguageEntry=$8000
1778	=$8003						sidewaysROMServiceEntry=$8003
1779							                .virtual $8006
1780	.8006						sidewaysROMType: .block
1781	=32						hasRelocationAddress=32
1782	=64						hasLanguageEntry=64
1783	=128						hasServiceEntry=128
1784							                .endblock
1785							                .endvirtual
1786	=$8007						sidewaysROMCopyrightOffset=$8007
1787	=$8008						sidewaysROMVersion=$8008
1788	=$8009						sidewaysROMName=$8009

1790							;-------------------------------------------------------------------------

1792							                ; [MasRef D.3-22]
1793							ClockStringFormat: .struct
1794	.0000						ddd:
1795	>0000						                .fill 3
1796	>0003						                .fill 1                      ;','
1797	.0004						nn:
1798	>0004						                .fill 2
1799	>0006						                .fill 1                      ;' '
1800	.0007						mmm:
1801	>0007						                .fill 3
1802	>000a						                .fill 1                      ;' '
1803	.000b						yyyy:
1804	>000b						                .fill 4
1805	>000f						                .fill 1                      ;'.'
1806	.0010						hh:
1807	>0010						                .fill 2
1808	>0012						                .fill 1                      ;':'
1809	.0013						mm:
1810	>0013						                .fill 2
1811	>0015						                .fill 1                      ;':'
1812	.0016						ss:
1813	>0016						                .fill 2
1814	.0018						cr:
1815	>0018						                .fill 1                      ;'\n'
1816							                .endstruct

1818							;-------------------------------------------------------------------------


:1	;******  Return to file: mos350.s65

3							                .include "src/terminal_workspace.s65"

:4	;******  Processing file: src/terminal_workspace.s65

1							;-------------------------------------------------------------------------

3							; Not really MOS stuff. This is the Terminal ROM zero page workspace.

5	=$70						oldINSV=$70
6	=$72						oldREMV=$72
7							                .cerror oldREMV!=oldINSV+2,"oldREMV and oldINSV must be adjacent"

9							;-------------------------------------------------------------------------

11							zterm: .struct
12	=$39						numRowsMinusOne=$39
13	=$38						numColumns=$38
14	=$37						numColumnsMinusOne=$37
15							; TODO old INSV and oldREMV should probably go in here too!
16							                .endstruct



:1	;******  Return to file: mos350.s65


5	=350						version=350
6	="MOS 3.50"					versionString="MOS 3.50"
7	=7						defaultMODE=7

9							*=$af00
10							                .dsection ext
11							                .cwarn *>$b800,'Ext ROM is too large'

13							*=$8000
14							                .dsection utils
15							                .cwarn *>$c000,'Terminal ROM is too large'

17							*=$c000
18							                .dsection mos
19							                ; there's no need for a size check here - 64tass gives
20							                ; you an error if the code would go past the 64 K
21							                ; barrier.

23							;-------------------------------------------------------------------------

25							                .section ext
26							                .include "src/sound_stuff.s65"

:5	;******  Processing file: src/sound_stuff.s65

1							; Table to convert channel number to the bits required by the chip
2	.af00						soundParameterTable:
3	>af00		e0 c0 a0 80			                .byte $e0,$c0,$a0,$80

5							;-------------------------------------------------------------------------

7	.af04						LF413:
8	.af04		4c 11 b0	jmp $b011	                jmp LF520

10							;-------------------------------------------------------------------------

12							                .if version>=500
14							                .else
15	.af07						LF416:
16							                .endif
17	.af07		a2 00		ldx #$00	                ldx #$00
18	.af09		ad 38 08	lda $0838	                lda $0838
19	.af0c		d0 04		bne $af12	                bne LF421
20	.af0e		e8		inx		                inx
21	.af0f		ce 38 08	dec $0838	                dec $0838
22	.af12						LF421:
23	.af12		8e 3b 08	stx $083b	                stx $083B
24	.af15		a2 08		ldx #$08	                ldx #$08
25	.af17						LF426:
26	.af17		ca		dex		                dex
27	.af18		bd 00 08	lda $0800,x	                lda $0800,x
28	.af1b		f0 e7		beq $af04	                beq LF413
29	.af1d		bd ce 02	lda $02ce,x	                lda bufferEmptyFlags,x
30	.af20		30 05		bmi $af27	                bmi LF436
31	.af22		bd 18 08	lda $0818,x	                lda $0818,x
32	.af25		d0 08		bne $af2f	                bne LF43E
33	.af27						LF436:
34	.af27		20 19 b0	jsr $b019	                jsr LF528
35	.af2a		bd 18 08	lda $0818,x	                lda $0818,x
36	.af2d		f0 12		beq $af41	                beq LF450
37	.af2f						LF43E:
38	.af2f		1a		inc a		                inc a
39	.af30		f0 12		beq $af44	                beq LF453
40	.af32		de 1c 08	dec $081c,x	                dec $081C,x
41	.af35		d0 0d		bne $af44	                bne LF453
42	.af37		a9 05		lda #$05	                lda #$05
43	.af39		9d 1c 08	sta $081c,x	                sta $081C,x
44	.af3c		de 18 08	dec $0818,x	                dec $0818,x
45	.af3f		d0 03		bne $af44	                bne LF453
46	.af41						LF450:
47	.af41		20 19 b0	jsr $b019	                jsr LF528
48	.af44						LF453:
49	.af44		bd 24 08	lda $0824,x	                lda $0824,x
50	.af47		f0 05		beq $af4e	                beq LF45D
51	.af49		de 24 08	dec $0824,x	                dec $0824,x
52	.af4c		d0 b6		bne $af04	                bne LF413
53	.af4e						LF45D:
54	.af4e		bc 20 08	ldy $0820,x	                ldy $0820,x
55	.af51		c0 ff		cpy #$ff	                cpy #$FF
56	.af53		f0 af		beq $af04	                beq LF413
57	.af55		b9 c0 08	lda $08c0,y	                lda $08C0,y
58	.af58		29 7f		and #$7f	                and #$7F
59	.af5a		9d 24 08	sta $0824,x	                sta $0824,x
60	.af5d		bd 08 08	lda $0808,x	                lda $0808,x
61	.af60		c9 04		cmp #$04	                cmp #$04
62	.af62		f0 5d		beq $afc1	                beq LF4D0
63	.af64		18		clc		                clc
64	.af65		7d 20 08	adc $0820,x	                adc $0820,x
65	.af68		a8		tay		                tay
66	.af69		b9 cb 08	lda $08cb,y	                lda $08CB,y
67	.af6c		38		sec		                sec
68	.af6d		e9 3f		sbc #$3f	                sbc #$3F
69	.af6f		8d 3a 08	sta $083a	                sta $083A
70	.af72		b9 c7 08	lda $08c7,y	                lda $08C7,y
71	.af75		8d 39 08	sta $0839	                sta $0839
72	.af78		bd 04 08	lda $0804,x	                lda $0804,x
73	.af7b						LF48A:
74	.af7b		48		pha		                pha
75	.af7c		18		clc		                clc
76	.af7d		6d 39 08	adc $0839	                adc $0839
77	.af80		50 07		bvc $af89	                bvc LF498
78	.af82		2a		rol a		                rol a
79	.af83		a9 3f		lda #$3f	                lda #$3F
80	.af85		b0 02		bcs $af89	                bcs LF498
81	.af87		49 ff		eor #$ff	                eor #$FF
82	.af89						LF498:
83	.af89		9d 04 08	sta $0804,x	                sta $0804,x
84	.af8c		2a		rol a		                rol a
85	.af8d		5d 04 08	eor $0804,x	                eor $0804,x
86	.af90		10 09		bpl $af9b	                bpl LF4AA
87	.af92		a9 3f		lda #$3f	                lda #$3F
88	.af94		90 02		bcc $af98	                bcc LF4A7
89	.af96		49 ff		eor #$ff	                eor #$FF
90	.af98						LF4A7:
91	.af98		9d 04 08	sta $0804,x	                sta $0804,x
92	.af9b						LF4AA:
93	.af9b		ce 39 08	dec $0839	                dec $0839
94	.af9e		bd 04 08	lda $0804,x	                lda $0804,x
95	.afa1		38		sec		                sec
96	.afa2		ed 3a 08	sbc $083a	                sbc $083A
97	.afa5		4d 39 08	eor $0839	                eor $0839
98	.afa8		30 09		bmi $afb3	                bmi LF4C2
99	.afaa		ad 3a 08	lda $083a	                lda $083A
100	.afad		9d 04 08	sta $0804,x	                sta $0804,x
101	.afb0		fe 08 08	inc $0808,x	                inc $0808,x
102	.afb3						LF4C2:
103	.afb3		68		pla		                pla
104	.afb4		5d 04 08	eor $0804,x	                eor $0804,x
105	.afb7		29 f8		and #$f8	                and #$F8
106	.afb9		f0 06		beq $afc1	                beq LF4D0
107	.afbb		bd 04 08	lda $0804,x	                lda $0804,x
108	.afbe		20 8a b0	jsr $b08a	                jsr LF599
109	.afc1						LF4D0:
110	.afc1		bd 10 08	lda $0810,x	                lda $0810,x
111	.afc4		c9 03		cmp #$03	                cmp #$03
112	.afc6		f0 49		beq $b011	                beq LF520
113	.afc8		bd 14 08	lda $0814,x	                lda $0814,x
114	.afcb		d0 28		bne $aff5	                bne LF504
115	.afcd		fe 10 08	inc $0810,x	                inc $0810,x
116	.afd0		bd 10 08	lda $0810,x	                lda $0810,x
117	.afd3		c9 03		cmp #$03	                cmp #$03
118	.afd5		d0 0e		bne $afe5	                bne LF4F4
119	.afd7		bc 20 08	ldy $0820,x	                ldy $0820,x
120	.afda		b9 c0 08	lda $08c0,y	                lda $08C0,y
121	.afdd		30 32		bmi $b011	                bmi LF520
122	.afdf		9e 30 08	stz $0830,x	                stz $0830,x
123	.afe2		9e 10 08	stz $0810,x	                stz $0810,x
124	.afe5						LF4F4:
125	.afe5		bd 10 08	lda $0810,x	                lda $0810,x
126	.afe8		18		clc		                clc
127	.afe9		7d 20 08	adc $0820,x	                adc $0820,x
128	.afec		a8		tay		                tay
129	.afed		b9 c4 08	lda $08c4,y	                lda $08C4,y
130	.aff0		9d 14 08	sta $0814,x	                sta $0814,x
131	.aff3		f0 1c		beq $b011	                beq LF520
132	.aff5						LF504:
133	.aff5		de 14 08	dec $0814,x	                dec $0814,x
134	.aff8		bd 20 08	lda $0820,x	                lda $0820,x
135	.affb		18		clc		                clc
136	.affc		7d 10 08	adc $0810,x	                adc $0810,x
137	.afff		a8		tay		                tay
138	.b000		b9 c1 08	lda $08c1,y	                lda $08C1,y
139	.b003		18		clc		                clc
140	.b004		7d 30 08	adc $0830,x	                adc $0830,x
141	.b007		9d 30 08	sta $0830,x	                sta $0830,x
142	.b00a		18		clc		                clc
143	.b00b		7d 0c 08	adc $080c,x	                adc $080C,x
144	.b00e		20 c6 b0	jsr $b0c6	                jsr LF5D5
145	.b011						LF520:
146	.b011		e0 04		cpx #$04	                cpx #$04
147	.b013		f0 03		beq $b018	                beq LF527
148	.b015		4c 17 af	jmp $af17	                jmp LF426

150	.b018						LF527:
151	.b018		60		rts		                rts

153	.b019						LF528:
154	.b019		bd 08 08	lda $0808,x	                lda $0808,x
155	.b01c		c9 04		cmp #$04	                cmp #$04
156	.b01e		f0 05		beq $b025	                beq LF534
157	.b020		a9 03		lda #$03	                lda #$03
158	.b022		9d 08 08	sta $0808,x	                sta $0808,x
159	.b025						LF534:
160	.b025		bd ce 02	lda $02ce,x	                lda bufferEmptyFlags,x
161	.b028		f0 14		beq $b03e	                beq LF54D
162	.b02a		a9 00		lda #$00	                lda #$00
163	.b02c		9e ce 02	stz $02ce,x	                stz bufferEmptyFlags,x
164	.b02f		a0 04		ldy #$04	                ldy #$04
165	.b031						LF540:
166	.b031		99 2b 08	sta $082b,y	                sta $082B,y
167	.b034		88		dey		                dey
168	.b035		d0 fa		bne $b031	                bne LF540
169	.b037		9e 18 08	stz $0818,x	                stz $0818,x
170	.b03a		88		dey		                dey
171	.b03b		8c 38 08	sty $0838	                sty $0838
172	.b03e						LF54D:
173	.b03e		bd 28 08	lda $0828,x	                lda $0828,x
174	.b041		f0 60		beq $b0a3	                beq LF5B2
175	.b043		ad 3b 08	lda $083b	                lda $083B
176	.b046		f0 34		beq $b07c	                beq LF58B
177	.b048		9e 28 08	stz $0828,x	                stz $0828,x
178	.b04b						LF55A:
179	.b04b		4c 75 b1	jmp $b175	                jmp LF685

181							;-------------------------------------------------------------------------
182							;
183							; Clear a buffer that's a sound channel.
184							;
185							; https://tobylobster.github.io/mos/mos/S-s16.html#SP7
186							;
187							; Entry:
188							;
189							; X = buffer number (must be a sound channel buffer)
190							;
191							                .if version>=500||version==350
192							                ; All this stuff is in the top-level namespace in
193							                ; 3.50. Needs a rethink!
194	.b04e						clearSoundChannelBufferInternal:
197							                .endif
198							                .block
199	.b04e		20 83 b0	jsr $b083	                jsr LF592
200	.b051		98		tya		                tya
201	.b052		9e 18 08	stz $0818,x	                stz $0818,x
202	.b055		9e ce 02	stz $02ce,x	                stz bufferEmptyFlags,x
203	.b058		9e 00 08	stz $0800,x	                stz $0800,x
204	.b05b		a0 03		ldy #$03	                ldy #$03
205	.b05d						loop:
206	.b05d		99 2c 08	sta $082c,y	                sta $082C,y
207	.b060		88		dey		                dey
208	.b061		10 fa		bpl $b05d	                bpl loop
209	.b063		8c 38 08	sty $0838	                sty $0838
210	.b066		80 63		bra $b0cb	                bra LF5DA
211							                .endblock

213							;-------------------------------------------------------------------------

215	.b068						LF577:
216	.b068		08		php		                php
217	.b069		78		sei		                sei
218	.b06a		bd 08 08	lda $0808,x	                lda $0808,x
219	.b06d		c9 04		cmp #$04	                cmp #$04
220	.b06f		d0 0a		bne $b07b	                bne LF58A
221	.b071		20 b3 e9	jsr $e9b3	                jsr osbyte98
222	.b074		90 05		bcc $b07b	                bcc LF58A
223	.b076		a9 00		lda #$00	                lda #$00
224	.b078		9e 00 08	stz $0800,x	                stz $0800,x
225	.b07b						LF58A:
226	.b07b		28		plp		                plp
227	.b07c						LF58B:
228	.b07c		bc 20 08	ldy $0820,x	                ldy $0820,x
229	.b07f		c0 ff		cpy #$ff	                cpy #$FF
230	.b081		d0 72		bne $b0f5	                bne LF604

232							                ; https://tobylobster.github.io/mos/mos/S-s16.html#SP2
233	.b083						LF592:
234	.b083		a9 04		lda #$04	                lda #$04
235	.b085		9d 08 08	sta $0808,x	                sta $0808,x
236	.b088		a9 c0		lda #$c0	                lda #$C0
237	.b08a						LF599:
238	.b08a		9d 04 08	sta $0804,x	                sta $0804,x
239	.b08d		ac 62 02	ldy $0262	                ldy soundSuppressionStatus
240	.b090		f0 02		beq $b094	                beq LF5A3
241	.b092		a9 c0		lda #$c0	                lda #$C0
242	.b094						LF5A3:
243	.b094		38		sec		                sec
244	.b095		e9 40		sbc #$40	                sbc #$40
245	.b097		4a		lsr a		                lsr a
246	.b098		4a		lsr a		                lsr a
247	.b099		4a		lsr a		                lsr a
248	.b09a		49 0f		eor #$0f	                eor #$0F
249	.b09c		1d fc ae	ora $aefc,x	                ora soundParameterTable-bufferNumberSound0,x
250	.b09f		09 10		ora #$10	                ora #$10
251	.b0a1		80 34		bra $b0d7	                bra LF5E6

253	.b0a3						LF5B2:
254	.b0a3		20 b3 e9	jsr $e9b3	                jsr osbyte98
255	.b0a6		b0 c0		bcs $b068	                bcs LF577
256	.b0a8		29 03		and #$03	                and #$03
257	.b0aa		f0 9f		beq $b04b	                beq LF55A
258	.b0ac		ad 38 08	lda $0838	                lda $0838
259	.b0af		f0 cb		beq $b07c	                beq LF58B
260	.b0b1		fe 28 08	inc $0828,x	                inc $0828,x
261	.b0b4		a8		tay		                tay
262	.b0b5		10 0a		bpl $b0c1	                bpl LF5D0
263	.b0b7		20 b3 e9	jsr $e9b3	                jsr osbyte98
264	.b0ba		29 03		and #$03	                and #$03
265	.b0bc		8d 38 08	sta $0838	                sta $0838
266	.b0bf		80 bb		bra $b07c	                bra LF58B

268	.b0c1						LF5D0:
269	.b0c1		ce 38 08	dec $0838	                dec $0838
270	.b0c4		80 b6		bra $b07c	                bra LF58B

272	.b0c6						LF5D5:
273	.b0c6		dd 2c 08	cmp $082c,x	                cmp $082C,x
274	.b0c9		f0 2a		beq $b0f5	                beq LF604
275	.b0cb						LF5DA:
276	.b0cb		9d 2c 08	sta $082c,x	                sta $082C,x
277	.b0ce		e0 04		cpx #$04	                cpx #$04
278	.b0d0		d0 24		bne $b0f6	                bne LF605
279	.b0d2		29 0f		and #$0f	                and #$0F
280	.b0d4		1d fc ae	ora $aefc,x	                ora soundParameterTable-bufferNumberSound0,x
281	.b0d7						LF5E6:
282	.b0d7		08		php		                php
283	.b0d8						LF5E7:
284	.b0d8		78		sei		                sei
285	.b0d9		a0 ff		ldy #$ff	                ldy #$FF
286	.b0db		8c 43 fe	sty $fe43	                sty systemVIA.ddra
287	.b0de		8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake
288	.b0e1		c8		iny		                iny
289	.b0e2		8c 40 fe	sty $fe40	                sty systemVIA.orb
290	.b0e5		a0 02		ldy #$02	                ldy #$02
291	.b0e7						LF5F6:
292	.b0e7		88		dey		                dey
293	.b0e8		d0 fd		bne $b0e7	                bne LF5F6
294	.b0ea		a0 08		ldy #$08	                ldy #$08
295	.b0ec		8c 40 fe	sty $fe40	                sty systemVIA.orb
296	.b0ef		a0 04		ldy #$04	                ldy #$04
297	.b0f1						LF600:
298	.b0f1		88		dey		                dey
299	.b0f2		d0 fd		bne $b0f1	                bne LF600
300	.b0f4		28		plp		                plp
301	.b0f5						LF604:
302	.b0f5		60		rts		                rts

304	.b0f6						LF605:
305	.b0f6		48		pha		                pha
306	.b0f7		29 03		and #$03	                and #$03
307	.b0f9		8d 3c 08	sta $083c	                sta $083C
308	.b0fc		9c 3d 08	stz $083d	                stz $083D
309	.b0ff		68		pla		                pla
310	.b100		4a		lsr a		                lsr a
311	.b101		4a		lsr a		                lsr a
312	.b102						LF611:
313	.b102		c9 0c		cmp #$0c	                cmp #$0C
314	.b104		90 07		bcc $b10d	                bcc LF61C
315	.b106		ee 3d 08	inc $083d	                inc $083D
316	.b109		e9 0c		sbc #$0c	                sbc #$0C
317	.b10b		d0 f5		bne $b102	                bne LF611
318	.b10d						LF61C:
319	.b10d		a8		tay		                tay
320	.b10e		ad 3d 08	lda $083d	                lda $083D
321	.b111		48		pha		                pha
322	.b112		b9 d4 b1	lda $b1d4,y	                lda LF6E4,y
323	.b115		8d 3d 08	sta $083d	                sta $083D
324	.b118		b9 e0 b1	lda $b1e0,y	                lda LF6F0,y
325	.b11b		48		pha		                pha
326	.b11c		29 03		and #$03	                and #$03
327	.b11e		8d 3e 08	sta $083e	                sta $083E
328	.b121		68		pla		                pla
329							                .if version==350
330	.b122		20 20 e5	jsr $e520	                jsr LE520
336							                .endif
337	.b125		8d 3f 08	sta $083f	                sta $083F
338	.b128		ad 3d 08	lda $083d	                lda $083D
339	.b12b		ac 3c 08	ldy $083c	                ldy $083C
340	.b12e		f0 0c		beq $b13c	                beq LF64C
341	.b130						LF640:
342	.b130		38		sec		                sec
343	.b131		ed 3f 08	sbc $083f	                sbc $083F
344	.b134		b0 03		bcs $b139	                bcs LF649
345	.b136		ce 3e 08	dec $083e	                dec $083E
346	.b139						LF649:
347	.b139		88		dey		                dey
348	.b13a		d0 f4		bne $b130	                bne LF640
349	.b13c						LF64C:
350	.b13c		8d 3d 08	sta $083d	                sta $083D
351	.b13f		68		pla		                pla
352	.b140		a8		tay		                tay
353	.b141		f0 09		beq $b14c	                beq LF65C
354	.b143						LF653:
355	.b143		4e 3e 08	lsr $083e	                lsr $083E
356	.b146		6e 3d 08	ror $083d	                ror $083D
357	.b149		88		dey		                dey
358	.b14a		d0 f7		bne $b143	                bne LF653
359	.b14c						LF65C:
360	.b14c		ad 3d 08	lda $083d	                lda $083D
361	.b14f		18		clc		                clc
362	.b150		7d 63 e1	adc $e163,x	                adc LE165,x
363	.b153		8d 3d 08	sta $083d	                sta $083D
364	.b156		90 03		bcc $b15b	                bcc LF66B
365	.b158		ee 3e 08	inc $083e	                inc $083E
366	.b15b						LF66B:
367	.b15b		29 0f		and #$0f	                and #$0F
368	.b15d		1d fc ae	ora $aefc,x	                ora soundParameterTable-bufferNumberSound0,x
369	.b160		08		php		                php
370	.b161		78		sei		                sei
371	.b162		20 d7 b0	jsr $b0d7	                jsr LF5E6
372	.b165		ad 3d 08	lda $083d	                lda $083D
373	.b168		4e 3e 08	lsr $083e	                lsr $083E
374	.b16b		6a		ror a		                ror a
375	.b16c		4e 3e 08	lsr $083e	                lsr $083E
376	.b16f		6a		ror a		                ror a
377	.b170		4a		lsr a		                lsr a
378	.b171		4a		lsr a		                lsr a
379	.b172		4c d8 b0	jmp $b0d8	                jmp LF5E7

381	.b175						LF685:
382	.b175		08		php		                php
383	.b176		78		sei		                sei
384	.b177		20 b8 e9	jsr $e9b8	                jsr osbyte91
385	.b17a		48		pha		                pha
386	.b17b		29 04		and #$04	                and #$04
387	.b17d		f0 13		beq $b192	                beq LF6A2
388	.b17f		68		pla		                pla
389	.b180		bc 20 08	ldy $0820,x	                ldy $0820,x
390	.b183		c8		iny		                iny
391	.b184		d0 03		bne $b189	                bne LF699Sound
392	.b186		20 83 b0	jsr $b083	                jsr LF592
393	.b189						LF699Sound:
394	.b189		20 b8 e9	jsr $e9b8	                jsr osbyte91
395	.b18c		20 b8 e9	jsr $e9b8	                jsr osbyte91
396	.b18f		28		plp		                plp
397	.b190		80 3e		bra $b1d0	                bra LF6E0

399	.b192						LF6A2:
400	.b192		68		pla		                pla
401	.b193		29 f8		and #$f8	                and #$F8
402	.b195		0a		asl a		                asl a
403	.b196		90 0b		bcc $b1a3	                bcc LF6B3Sound
404	.b198		49 ff		eor #$ff	                eor #$FF
405	.b19a		4a		lsr a		                lsr a
406	.b19b		38		sec		                sec
407	.b19c		e9 40		sbc #$40	                sbc #$40
408	.b19e		20 8a b0	jsr $b08a	                jsr LF599
409	.b1a1		a9 ff		lda #$ff	                lda #$FF
410	.b1a3						LF6B3Sound:
411	.b1a3		9d 20 08	sta $0820,x	                sta $0820,x
412	.b1a6		a9 05		lda #$05	                lda #$05
413	.b1a8		9d 1c 08	sta $081c,x	                sta $081C,x
414	.b1ab		a9 01		lda #$01	                lda #$01
415	.b1ad		9d 24 08	sta $0824,x	                sta $0824,x
416	.b1b0		9e 14 08	stz $0814,x	                stz $0814,x
417	.b1b3		9e 08 08	stz $0808,x	                stz $0808,x
418	.b1b6		9e 30 08	stz $0830,x	                stz $0830,x
419	.b1b9		a9 ff		lda #$ff	                lda #$FF
420	.b1bb		9d 10 08	sta $0810,x	                sta $0810,x
421	.b1be		20 b8 e9	jsr $e9b8	                jsr osbyte91
422	.b1c1		9d 0c 08	sta $080c,x	                sta $080C,x
423	.b1c4		20 b8 e9	jsr $e9b8	                jsr osbyte91
424	.b1c7		28		plp		                plp
425	.b1c8		48		pha		                pha
426	.b1c9		bd 0c 08	lda $080c,x	                lda $080C,x
427	.b1cc		20 c6 b0	jsr $b0c6	                jsr LF5D5
428	.b1cf		68		pla		                pla
429	.b1d0						LF6E0:
430	.b1d0		9d 18 08	sta $0818,x	                sta $0818,x
431	.b1d3		60		rts		                rts

433	.b1d4						LF6E4:
434	>b1d4		f0				                .byte $F0
435	>b1d5		b7				                .byte $B7
436	>b1d6		82				                .byte $82
437	>b1d7		4f				                .byte $4F
438	>b1d8		20				                .byte $20
439	>b1d9		f3				                .byte $F3
440	>b1da		c8				                .byte $C8
441	>b1db		a0				                .byte $A0
442	>b1dc		7b				                .byte $7B
443	>b1dd		57				                .byte $57
444	>b1de		35				                .byte $35
445	>b1df		16				                .byte $16
446	.b1e0						LF6F0:
447	>b1e0		e7				                .byte $E7
448	>b1e1		d7				                .byte $D7
449	>b1e2		cb				                .byte $CB
450	>b1e3		c3				                .byte $C3
451	>b1e4		b7				                .byte $B7
452	>b1e5		aa				                .byte $AA
453	>b1e6		a2				                .byte $A2
454	>b1e7		9a				                .byte $9a
455	>b1e8		92				                .byte $92
456	>b1e9		8a				                .byte $8a
457	>b1ea		82				                .byte $82
458	>b1eb		7a				                .byte $7a


:1	;******  Return to file: mos350.s65

27	>b1ec		ff ff ff ff ff ff ff		                .fill 7,255
28							                .include "src/ext.s65"

:6	;******  Processing file: src/ext.s65

1							; -*- comment-column:45; -*-

3	.b1f3						plotEllipseOutline:
4							                ; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP1
5	.b1f3		20 3a b3	jsr $b33a	                jsr     ellipseInitialisation
6							                .if version<500
7	.b1f6		80 03		bra $b1fb	                bra     startEllipseOutline
10							                .endif

12	.b1f8						ellipseOutlineLoop:
13	.b1f8		20 f4 b3	jsr $b3f4	                jsr     updateEllipseIncrementally

15	.b1fb						startEllipseOutline:
16	.b1fb		a2 34		ldx #$34	                ldx     #VDUVariables.ew.pointC
17	.b1fd		a0 3c		ldy #$3c	                ldy     #VDUVariables.ew.pointA
18	.b1ff		20 cb d5	jsr $d5cb	                jsr     sortVDUVariableWords
19							                .if version!=350
21							                .endif
22							                .if version<500&&version!=350
24							                .else
25	.b202		ad 39 03	lda $0339	                lda vduv.ew.leftPoint+1
26							                .endif
27	.b205		8d 43 03	sta $0343	                sta     vduv.ew.currentOffsetX+1
28							                .if version<500&&version!=350
31							                .else
32	.b208		ae 38 03	ldx $0338	                ldx vduv.ew.leftPoint+0
33							                .endif

35	.b20b						ellipseOutlineContinueRowLoop:
36	.b20b		8e 42 03	stx $0342	                stx     vduv.ew.currentOffsetX+0
37	.b20e		20 2b b5	jsr $b52b	                jsr     outlineEllipsePlotOnePointAndReflection
38	.b211		e8		inx		                inx
39	.b212		d0 03		bne $b217	                bne     +
40	.b214		ee 43 03	inc $0343	                inc     vduv.ew.currentOffsetX+1
41	.b217						+
42	.b217		8a		txa		                txa
43	.b218		d9 00 03	cmp $0300,y	                cmp     vduv+0,y
44	.b21b		ad 43 03	lda $0343	                lda     vduv.ew.currentOffsetX+1
45	.b21e		f9 01 03	sbc $0301,y	                sbc     vduv+1,y
46	.b221		30 e8		bmi $b20b	                bmi     ellipseOutlineContinueRowLoop

48							                .if version<500&&version!=350
76							                .else

78	.b223		ac 43 03	ldy $0343	                ldy vduv.ew.currentOffsetX+1
79	.b226		8a		txa		                txa
80	.b227		d0 01		bne $b22a	                bne +
81	.b229		88		dey		                dey
82	.b22a						+
83	.b22a		ca		dex		                dex
84	.b22b		8e 34 03	stx $0334	                stx vduv.ew.pointC+0
85	.b22e		8c 35 03	sty $0335	                sty vduv.ew.pointC+1
86	.b231		8a		txa		                txa
87	.b232		cd 3a 03	cmp $033a	                cmp vduv.ew.rightPoint+0
88	.b235		98		tya		                tya
89	.b236		ed 3b 03	sbc $033b	                sbc vduv.ew.rightPoint+1
90	.b239		10 30		bpl $b26b	                bpl LAF47
91	.b23b		a2 36		ldx #$36	                ldx #VDUVariables.ew.pointD
92	.b23d		a0 3e		ldy #$3e	                ldy #VDUVariables.ew.pointB
93	.b23f		20 cb d5	jsr $d5cb	                jsr sortVDUVariableWords
94	.b242		a0 34		ldy #$34	                ldy #VDUVariables.ew.pointC
95	.b244		20 cb d5	jsr $d5cb	                jsr sortVDUVariableWords
96	.b247		ad 3b 03	lda $033b	                lda vduv.ew.rightPoint+1
97	.b24a		8d 43 03	sta $0343	                sta vduv.ew.currentOffsetX+1
98	.b24d		ad 3a 03	lda $033a	                lda vduv.ew.rightPoint+0
99	.b250		aa		tax		                tax
100	.b251						LAF2D:
101	.b251		8e 42 03	stx $0342	                stx vduv.ew.currentOffsetX+0
102	.b254						LAF30:
103	.b254		20 2b b5	jsr $b52b	                jsr outlineEllipsePlotOnePointAndReflection
104	.b257		8a		txa		                txa
105	.b258		d0 03		bne $b25d	                bne +
106	.b25a		ce 43 03	dec $0343	                dec vduv.ew.currentOffsetX+1
107	.b25d						+
108	.b25d		ca		dex		                dex
109	.b25e		18		clc		                clc
110	.b25f		8a		txa		                txa
111	.b260		f9 00 03	sbc $0300,y	                sbc vduv+0,y
112	.b263		ad 43 03	lda $0343	                lda vduv.ew.currentOffsetX+1
113	.b266		f9 01 03	sbc $0301,y	                sbc vduv+1,y
114	.b269		10 e6		bpl $b251	                bpl LAF2D

116	.b26b						LAF47:
117	.b26b		ad 2f 03	lda $032f	                lda vduv.workspace._2F
118	.b26e		10 88		bpl $b1f8	                bpl ellipseOutlineLoop
119							                .if version==350
120	.b270		80 14		bra $b286	                bra LBA7B
123							                .endif

125							                .endif

127							;-------------------------------------------------------------------------

129	.b272						plotEllipseFilled:
130	.b272		20 3a b3	jsr $b33a	                jsr     ellipseInitialisation
131	.b275		80 03		bra $b27a	                bra     startFilledEllipse


134	.b277						filledEllipseLoop:
135	.b277		20 f4 b3	jsr $b3f4	                jsr     updateEllipseIncrementally

137	.b27a						startFilledEllipse:
138	.b27a		a2 3a		ldx #$3a	                ldx     #VDUVariables.ew.rightPoint
139	.b27c		a0 38		ldy #$38	                ldy     #VDUVariables.ew.leftPoint
140	.b27e		20 92 b2	jsr $b292	                jsr     fillEllipseOneRowAndReflection
141	.b281		ad 2f 03	lda $032f	                lda     vduv.workspace._2F
142	.b284		10 f1		bpl $b277	                bpl     filledEllipseLoop

144	.b286						LBA7B:
145	.b286		ee 4d 88	inc $884d	                inc     ellipseCountHeight+0
146	.b289		d0 03		bne $b28e	                bne     LBA83
147	.b28b		ee 4e 88	inc $884e	                inc     ellipseCountHeight+1

149	.b28e						LBA83:
150	.b28e		a2 3e		ldx #$3e	                ldx     #VDUVariables.ew.pointB
151	.b290		a0 3c		ldy #$3c	                ldy     #VDUVariables.ew.pointA

153	.b292						fillEllipseOneRowAndReflection:
154	.b292		da		phx		                phx
155	.b293		5a		phy		                phy
156	.b294		18		clc		                clc
157	.b295		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
158	.b298		79 00 03	adc $0300,y	                adc     vduv+0,y
159	.b29b		8d 40 03	sta $0340	                sta     vduv.workspace._40
160	.b29e		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
161	.b2a1		79 01 03	adc $0301,y	                adc     vduv+1,y
162	.b2a4		8d 41 03	sta $0341	                sta     vduv.workspace._41
163	.b2a7		18		clc		                clc
164	.b2a8		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
165	.b2ab		7d 00 03	adc $0300,x	                adc     vduv+0,x
166	.b2ae		8d 44 03	sta $0344	                sta     vduv.workspace._44
167	.b2b1		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
168	.b2b4		7d 01 03	adc $0301,x	                adc     vduv+1,x
169	.b2b7		8d 45 03	sta $0345	                sta     vduv.workspace._45
170	.b2ba		18		clc		                clc
171	.b2bb		ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
172	.b2be		6d 4d 88	adc $884d	                adc     ellipseCountHeight+0
173	.b2c1		a8		tay		                tay
174	.b2c2		ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
175	.b2c5		6d 4e 88	adc $884e	                adc     ellipseCountHeight+1
176	.b2c8		20 09 b3	jsr $b309	                jsr     LBAFE
177	.b2cb		7a		ply		                ply
178	.b2cc		fa		plx		                plx
179	.b2cd		ad 4d 88	lda $884d	                lda     ellipseCountHeight+0
180	.b2d0		0d 4e 88	ora $884e	                ora     ellipseCountHeight+1
181	.b2d3		f0 47		beq $b31c	                beq     rtsBB11
182	.b2d5		38		sec		                sec
183	.b2d6		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
184	.b2d9		fd 00 03	sbc $0300,x	                sbc     vduv+0,x
185	.b2dc		8d 40 03	sta $0340	                sta     vduv.workspace._40
186	.b2df		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
187	.b2e2		fd 01 03	sbc $0301,x	                sbc     vduv+1,x
188	.b2e5		8d 41 03	sta $0341	                sta     vduv.workspace._41
189	.b2e8		38		sec		                sec
190	.b2e9		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
191	.b2ec		f9 00 03	sbc $0300,y	                sbc     vduv+0,y
192	.b2ef		8d 44 03	sta $0344	                sta     vduv.workspace._44
193	.b2f2		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
194	.b2f5		f9 01 03	sbc $0301,y	                sbc     vduv+1,y
195	.b2f8		8d 45 03	sta $0345	                sta     vduv.workspace._45
196	.b2fb		38		sec		                sec
197	.b2fc		ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
198	.b2ff		ed 4d 88	sbc $884d	                sbc     ellipseCountHeight+0
199	.b302		a8		tay		                tay
200	.b303		ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
201	.b306		ed 4e 88	sbc $884e	                sbc     ellipseCountHeight+1

203	.b309						LBAFE:
204	.b309		8c 46 03	sty $0346	                sty     vduv.workspace._46
205	.b30c		8c 42 03	sty $0342	                sty     vduv.ew.currentOffsetX+0
206	.b30f		8d 47 03	sta $0347	                sta     vduv.workspace._47
207	.b312		8d 43 03	sta $0343	                sta     vduv.ew.currentOffsetX+1
208	.b315		a2 44		ldx #$44	                ldx     #VDUVariables.ew.pointF
209	.b317		a0 40		ldy #$40	                ldy     #VDUVariables.ew.pointE
210	.b319		4c e7 da	jmp $dae7	                jmp     LDAE8





216	.b31c						rtsBB11:
217	.b31c		60		rts		                rts




222	.b31d						LBB12:
223	.b31d		68		pla		                pla
224	.b31e		68		pla		                pla
225	.b31f		9c 4d 88	stz $884d	                stz     ellipseCountHeight+0
226	.b322		9c 4e 88	stz $884e	                stz     ellipseCountHeight+1
227	.b325		a2 29		ldx #$29	                ldx     #VDUVariables.workspace._29
228	.b327		a0 40		ldy #$40	                ldy     #VDUVariables.ew.pointE
229	.b329		20 05 b6	jsr $b605	                jsr     negateVDUVariableXIntoY
230	.b32c		a2 29		ldx #$29	                ldx     #VDUVariables.workspace._29
231	.b32e		a0 44		ldy #$44	                ldy     #VDUVariables.ew.pointF
232	.b330		20 0c c9	jsr $c90c	                jsr     copyTwoBytesWithinVDUVariables
233	.b333		a2 44		ldx #$44	                ldx     #VDUVariables.ew.pointF
234	.b335		a0 40		ldy #$40	                ldy     #VDUVariables.ew.pointE
235	.b337		4c 92 b2	jmp $b292	                jmp     fillEllipseOneRowAndReflection

237	.b33a						ellipseInitialisation:
238							                ; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP5
239	.b33a		a0 24		ldy #$24	                ldy     #VDUVariables.graphicsCursorPixelsX
240	.b33c		a2 14		ldx #$14	                ldx     #VDUVariables.oldGraphicsCursorPixelsX
241	.b33e		a9 29		lda #$29	                lda     #VDUVariables.workspace._29
242	.b340		20 77 d6	jsr $d677	                jsr     LD678
243	.b343		9c 28 03	stz $0328	                stz     vduv.ew.aspectRatio+0
244	.b346		a0 22		ldy #$22	                ldy     #VDUVariables.queueEnd-2
245	.b348		a2 16		ldx #$16	                ldx     #VDUVariables.oldGraphicsCursorPixelsY
246	.b34a		a9 2e		lda #$2e	                lda     #VDUVariables.ew.halfHeightCounter
247	.b34c		20 77 d6	jsr $d677	                jsr     LD678
248	.b34f		ad 2e 03	lda $032e	                lda     vduv.ew.halfHeightCounter+0
249	.b352		0d 2f 03	ora $032f	                ora     vduv.ew.halfHeightCounter+1
250	.b355		f0 c6		beq $b31d	                beq     LBB12
251	.b357		2a		rol a		                rol     a
252	.b358		8d 41 88	sta $8841	                sta     L8841
253	.b35b		a0 20		ldy #$20	                ldy     #VDUVariables.queueEnd-4
254	.b35d		a2 14		ldx #$14	                ldx     #VDUVariables.oldGraphicsCursorPixelsX
255	.b35f		a9 2c		lda #$2c	                lda     #VDUVariables.ew.shear+1
256	.b361		20 77 d6	jsr $d677	                jsr     LD678
257	.b364		9c 2b 03	stz $032b	                stz     vduv.ew.shear+0
258	.b367		2a		rol a		                rol     a
259	.b368		4d 41 88	eor $8841	                eor     ellipseSignFlag
260	.b36b		29 01		and #$01	                and     #1
261	.b36d		8d 41 88	sta $8841	                sta     ellipseSignFlag
262	.b370		a2 28		ldx #$28	                ldx     #VDUVariables.ew.aspectRatio
263	.b372		a0 2e		ldy #$2e	                ldy     #VDUVariables.ew.halfHeightCounter
264	.b374		20 8e b5	jsr $b58e	                jsr     LBD83
265	.b377		a2 2b		ldx #$2b	                ldx     #VDUVariables.ew.shear
266	.b379		a0 2e		ldy #$2e	                ldy     #VDUVariables.ew.halfHeightCounter
267	.b37b		20 8e b5	jsr $b58e	                jsr     LBD83
268	.b37e		ad 41 88	lda $8841	                lda     L8841
269	.b381		f0 0e		beq $b391	                beq     LBB86
270	.b383		38		sec		                sec
271	.b384		a0 fd		ldy #$fd	                ldy     #$fd

273	.b386						LBB7B:
274	.b386		a9 00		lda #$00	                lda     #0
275	.b388		f9 2e 02	sbc $022e,y	                sbc     vduv.workspace._2B-$fd,y
276	.b38b		99 2e 02	sta $022e,y	                sta     vduv.workspace._2B-$fd,y
277	.b38e		c8		iny		                iny
278	.b38f		d0 f5		bne $b386	                bne     LBB7B

280	.b391						LBB86:
281	.b391		ad 2e 03	lda $032e	                lda     vduv.workspace._2E
282	.b394		8d 3c 88	sta $883c	                sta     L883C
283	.b397		ad 2f 03	lda $032f	                lda     vduv.workspace._2F
284	.b39a		20 cd d4	jsr $d4cd	                jsr     LD4CE
285	.b39d		a0 03		ldy #$03	                ldy     #3

287	.b39f						LBB94:
288	.b39f		b9 40 88	lda $8840,y	                lda     $8840,y
289	.b3a2		99 30 03	sta $0330,y	                sta     vduv.workspace._30,y
290	.b3a5		88		dey		                dey
291	.b3a6		10 f7		bpl $b39f	                bpl     LBB94
292	.b3a8		a2 0a		ldx #$0a	                ldx     #$a

294	.b3aa						LBB9F:
295	.b3aa		9e 42 88	stz $8842,x	                stz     $8842,x
296	.b3ad		ca		dex		                dex
297	.b3ae		10 fa		bpl $b3aa	                bpl     LBB9F
298	.b3b0		ee 45 88	inc $8845	                inc     L8845
299	.b3b3		20 23 b4	jsr $b423	                jsr     updateEllipse
300	.b3b6		20 23 b4	jsr $b423	                jsr     updateEllipse
301	.b3b9		9c 4d 88	stz $884d	                stz     ellipseCountHeight+0
302	.b3bc		9c 4e 88	stz $884e	                stz     ellipseCountHeight+1
303	.b3bf		a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
304	.b3c1		a0 36		ldy #$36	                ldy     #VDUVariables.ew.pointD
305	.b3c3		20 05 b6	jsr $b605	                jsr     negateVDUVariableXIntoY
306	.b3c6		a2 3e		ldx #$3e	                ldx     #VDUVariables.ew.pointB
307	.b3c8		a0 34		ldy #$34	                ldy     #VDUVariables.ew.pointC
308	.b3ca		20 05 b6	jsr $b605	                jsr     negateVDUVariableXIntoY
309	.b3cd		a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
310	.b3cf		a0 3a		ldy #$3a	                ldy     #VDUVariables.ew.rightPoint
311	.b3d1		20 d5 d5	jsr $d5d5	                jsr     compareVDUVariableWords
312	.b3d4		10 07		bpl $b3dd	                bpl     LBBD2
313	.b3d6		20 0c c9	jsr $c90c	                jsr     copyTwoBytesWithinVDUVariables
314	.b3d9		a2 36		ldx #$36	                ldx     #VDUVariables.ew.pointD
315	.b3db		80 12		bra $b3ef	                bra     LBBE4


318	.b3dd						LBBD2:
319	.b3dd		a2 38		ldx #$38	                ldx     #VDUVariables.ew.leftPoint
320	.b3df		a0 3e		ldy #$3e	                ldy     #VDUVariables.ew.pointB
321	.b3e1		20 d5 d5	jsr $d5d5	                jsr     compareVDUVariableWords
322	.b3e4		10 3c		bpl $b422	                bpl     rtsBC17
323	.b3e6		a2 34		ldx #$34	                ldx     #VDUVariables.ew.pointC
324	.b3e8		a0 3a		ldy #$3a	                ldy     #VDUVariables.ew.rightPoint
325	.b3ea		20 0c c9	jsr $c90c	                jsr     copyTwoBytesWithinVDUVariables
326	.b3ed		a2 3e		ldx #$3e	                ldx     #VDUVariables.ew.pointB

328	.b3ef						LBBE4:
329	.b3ef		a0 38		ldy #$38	                ldy     #VDUVariables.ew.leftPoint
330	.b3f1		4c 0c c9	jmp $c90c	                jmp     copyTwoBytesWithinVDUVariables

332							;-------------------------------------------------------------------------
333							;
334							; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP6
335							;

337	.b3f4						updateEllipseIncrementally:
338	.b3f4		20 23 b4	jsr $b423	                jsr     updateEllipse
339	.b3f7		a0 3a		ldy #$3a	                ldy     #VDUVariables.ew.rightPoint
340	.b3f9		a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
341	.b3fb		20 d5 d5	jsr $d5d5	                jsr     compareVDUVariableWords
342	.b3fe		10 0d		bpl $b40d	                bpl     LBC02
343	.b400		ad 3c 03	lda $033c	                lda     vduv.ew.pointA+0
344	.b403		8d 3a 03	sta $033a	                sta     vduv.ew.rightPoint+0
345	.b406		ad 3d 03	lda $033d	                lda     vduv.ew.pointA+1
346	.b409		8d 3b 03	sta $033b	                sta     vduv.ew.rightPoint+1
347	.b40c		60		rts		                rts

349	.b40d						LBC02:
350	.b40d		a2 38		ldx #$38	                ldx     #VDUVariables.ew.leftPoint
351	.b40f		a0 3e		ldy #$3e	                ldy     #VDUVariables.ew.pointB
352	.b411		20 d5 d5	jsr $d5d5	                jsr     compareVDUVariableWords
353	.b414		10 0c		bpl $b422	                bpl     rtsBC17
354	.b416		ad 3e 03	lda $033e	                lda     vduv.ew.pointB+0
355	.b419		8d 38 03	sta $0338	                sta     vduv.ew.leftPoint+0
356	.b41c		ad 3f 03	lda $033f	                lda     vduv.ew.pointB+1
357	.b41f		8d 39 03	sta $0339	                sta     vduv.ew.leftPoint+1

359	.b422						rtsBC17:
360	.b422		60		rts		                rts

362							;-------------------------------------------------------------------------
363							;
364							; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP7
365							;

367	.b423						updateEllipse:
368	.b423		a2 38		ldx #$38	                ldx     #VDUVariables.ew.leftPoint
369	.b425		a0 34		ldy #$34	                ldy     #VDUVariables.ew.pointC
370	.b427		20 1e c9	jsr $c91e	                jsr     copyFourBytesWithinVDUVariables
371	.b42a		a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
372	.b42c		a0 38		ldy #$38	                ldy     #VDUVariables.ew.leftPoint
373	.b42e		20 1e c9	jsr $c91e	                jsr     copyFourBytesWithinVDUVariables

375	.b431		38		sec		                sec
376	.b432		ad 30 03	lda $0330	                lda     vduv.ew.halfHeightSquared+0
377	.b435		ed 49 88	sbc $8849	                sbc     ellipseCountSquares+0
378	.b438		8d 36 88	sta $8836	                sta     sqrtNumber+2
379	.b43b		ad 31 03	lda $0331	                lda     vduv.ew.halfHeightSquared+1
380	.b43e		ed 4a 88	sbc $884a	                sbc     ellipseCountSquares+1
381	.b441		8d 37 88	sta $8837	                sta     sqrtNumber+3
382	.b444		ad 32 03	lda $0332	                lda     vduv.ew.halfHeightSquared+2
383	.b447		ed 4b 88	sbc $884b	                sbc     ellipseCountSquares+2
384	.b44a		8d 38 88	sta $8838	                sta     sqrtNumber+4
385	.b44d		ad 33 03	lda $0333	                lda     vduv.ew.halfHeightSquared+3
386	.b450		ed 4c 88	sbc $884c	                sbc     ellipseCountSquares+3
387	.b453		8d 39 88	sta $8839	                sta     sqrtNumber+5
388	.b456		9c 35 88	stz $8835	                stz     sqrtNumber+1
389	.b459		9c 34 88	stz $8834	                stz     sqrtNumber+0
390	.b45c		20 56 b6	jsr $b656	                jsr     LBE4B

392	.b45f		ad 28 03	lda $0328	                lda     vduv.ew.aspectRatio+0
393	.b462		8d 34 88	sta $8834	                sta     multiplier+0
394	.b465		ad 29 03	lda $0329	                lda     vduv.ew.aspectRatio+1
395	.b468		8d 35 88	sta $8835	                sta     multiplier+1
396	.b46b		ad 2a 03	lda $032a	                lda     vduv.ew.aspectRatio+2
397	.b46e		8d 36 88	sta $8836	                sta     multiplier+2
398	.b471		20 17 b6	jsr $b617	                jsr     multiply24x24

400	.b474		18		clc		                clc
401	.b475		ad 42 88	lda $8842	                lda     ellipseAccumulatedShear+0
402	.b478		6d 35 88	adc $8835	                adc     product+1
403	.b47b		08		php		                php
404	.b47c		ad 43 88	lda $8843	                lda     ellipseAccumulatedShear+1
405	.b47f		6d 36 88	adc $8836	                adc     product+2
406	.b482		8d 3e 03	sta $033e	                sta     vduv.ew.pointB+0
407	.b485		ad 44 88	lda $8844	                lda     ellipseAccumulatedShear+2
408	.b488		6d 37 88	adc $8837	                adc     product+3
409	.b48b		8d 3f 03	sta $033f	                sta     vduv.ew.pointB+1
410	.b48e		28		plp		                plp
411	.b48f		10 08		bpl $b499	                bpl     +
412	.b491		ee 3e 03	inc $033e	                inc     vduv.ew.pointB+0
413	.b494		d0 03		bne $b499	                bne     +
414	.b496		ee 3f 03	inc $033f	                inc     vduv.ew.pointB+1
415	.b499						+
416	.b499		38		sec		                sec
417	.b49a		ad 42 88	lda $8842	                lda     ellipseAccumulatedShear+0
418	.b49d		ed 35 88	sbc $8835	                sbc     product+1
419	.b4a0		08		php		                php
420	.b4a1		ad 43 88	lda $8843	                lda     ellipseAccumulatedShear+1
421	.b4a4		ed 36 88	sbc $8836	                sbc     product+2
422	.b4a7		8d 3c 03	sta $033c	                sta     vduv.ew.pointA+0
423	.b4aa		ad 44 88	lda $8844	                lda     ellipseAccumulatedShear+2
424	.b4ad		ed 37 88	sbc $8837	                sbc     product+3
425	.b4b0		8d 3d 03	sta $033d	                sta     vduv.ew.pointA+1
426	.b4b3		28		plp		                plp
427	.b4b4		10 08		bpl $b4be	                bpl     +
428	.b4b6		ee 3c 03	inc $033c	                inc     vduv.ew.pointA+0
429	.b4b9		d0 03		bne $b4be	                bne     +
430	.b4bb		ee 3d 03	inc $033d	                inc     vduv.ew.pointA+1
431	.b4be						+

433	.b4be		18		clc		                clc
434	.b4bf		ad 45 88	lda $8845	                lda     ellipseCountOddNumbers+0
435	.b4c2		6d 49 88	adc $8849	                adc     ellipseCountSquares+0
436	.b4c5		8d 49 88	sta $8849	                sta     ellipseCountSquares+0
437	.b4c8		ad 46 88	lda $8846	                lda     ellipseCountOddNumbers+1
438	.b4cb		6d 4a 88	adc $884a	                adc     ellipseCountSquares+1
439	.b4ce		8d 4a 88	sta $884a	                sta     ellipseCountSquares+1
440	.b4d1		ad 47 88	lda $8847	                lda     ellipseCountOddNumbers+2
441	.b4d4		6d 4b 88	adc $884b	                adc     ellipseCountSquares+2
442	.b4d7		8d 4b 88	sta $884b	                sta     ellipseCountSquares+2
443	.b4da		ad 48 88	lda $8848	                lda     ellipseCountOddNumbers+3
444	.b4dd		6d 4c 88	adc $884c	                adc     ellipseCountSquares+3
445	.b4e0		8d 4c 88	sta $884c	                sta     ellipseCountSquares+3
446	.b4e3		18		clc		                clc
447	.b4e4		a9 02		lda #$02	                lda     #2
448	.b4e6		6d 45 88	adc $8845	                adc     ellipseCountOddNumbers+0
449	.b4e9		8d 45 88	sta $8845	                sta     ellipseCountOddNumbers+0
450	.b4ec		90 0d		bcc $b4fb	                bcc     +
451	.b4ee		ee 46 88	inc $8846	                inc     ellipseCountOddNumbers+1
452	.b4f1		d0 08		bne $b4fb	                bne     +
453	.b4f3		ee 47 88	inc $8847	                inc     ellipseCountOddNumbers+2
454	.b4f6		d0 03		bne $b4fb	                bne     +
455	.b4f8		ee 48 88	inc $8848	                inc     ellipseCountOddNumbers+3
456	.b4fb						+
457	.b4fb		18		clc		                clc
458	.b4fc		ad 42 88	lda $8842	                lda     ellipseAccumulatedShear+0
459	.b4ff		6d 2b 03	adc $032b	                adc     vduv.ew.shear+0
460	.b502		8d 42 88	sta $8842	                sta     ellipseAccumulatedShear+0
461	.b505		ad 43 88	lda $8843	                lda     ellipseAccumulatedShear+1
462	.b508		6d 2c 03	adc $032c	                adc     vduv.ew.shear+1
463	.b50b		8d 43 88	sta $8843	                sta     ellipseAccumulatedShear+1
464	.b50e		ad 44 88	lda $8844	                lda     ellipseAccumulatedShear+2
465	.b511		6d 2d 03	adc $032d	                adc     vduv.ew.shear+2
466	.b514		8d 44 88	sta $8844	                sta     ellipseAccumulatedShear+2
467	.b517		ee 4d 88	inc $884d	                inc     ellipseCountHeight+0
468	.b51a		d0 03		bne $b51f	                bne     +
469	.b51c		ee 4e 88	inc $884e	                inc     ellipseCountHeight+1
470	.b51f						+
471	.b51f		ad 2e 03	lda $032e	                lda     vduv.workspace._2E
472	.b522		d0 03		bne $b527	                bne     +
473	.b524		ce 2f 03	dec $032f	                dec     vduv.workspace._2F
474	.b527						+
475	.b527		ce 2e 03	dec $032e	                dec     vduv.workspace._2E
476	.b52a		60		rts		                rts

478							;-------------------------------------------------------------------------
479							;
480							; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP8
481							;
482	.b52b						outlineEllipsePlotOnePointAndReflection: .block
483	.b52b		da		phx		                phx
484	.b52c		5a		phy		                phy

486	.b52d		18		clc		                clc
487	.b52e		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
488	.b531		6d 42 03	adc $0342	                adc     vduv.ew.currentOffsetX+0
489	.b534		8d 44 03	sta $0344	                sta     vduv.ew.plotPointX+0
490	.b537		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
491	.b53a		6d 43 03	adc $0343	                adc     vduv.ew.currentOffsetX+1
492	.b53d		8d 45 03	sta $0345	                sta     vduv.ew.plotPointX+1

494	.b540		18		clc		                clc
495	.b541		ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
496	.b544		6d 4d 88	adc $884d	                adc     ellipseCountHeight+0
497	.b547		8d 46 03	sta $0346	                sta     vduv.ew.plotPointY+0
498	.b54a		ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
499	.b54d		6d 4e 88	adc $884e	                adc     ellipseCountHeight+1
500	.b550		8d 47 03	sta $0347	                sta     vduv.ew.plotPointY+1

502	.b553		a2 44		ldx #$44	                ldx     #VDUVariables.ew.plotPointX
503	.b555		20 4b db	jsr $db4b	                jsr     plotPointInternal

505	.b558		ad 4d 88	lda $884d	                lda     ellipseCountHeight+0
506	.b55b		0d 4e 88	ora $884e	                ora     ellipseCountHeight+1
507	.b55e		f0 2b		beq $b58b	                beq     done

509	.b560		38		sec		                sec
510	.b561		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
511	.b564		ed 42 03	sbc $0342	                sbc     vduv.ew.currentOffsetX+0
512	.b567		8d 44 03	sta $0344	                sta     vduv.ew.plotPointX+0
513	.b56a		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
514	.b56d		ed 43 03	sbc $0343	                sbc     vduv.ew.currentOffsetX+1
515	.b570		8d 45 03	sta $0345	                sta     vduv.ew.plotPointX+1

517	.b573		38		sec		                sec
518	.b574		ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
519	.b577		ed 4d 88	sbc $884d	                sbc     ellipseCountHeight+0
520	.b57a		8d 46 03	sta $0346	                sta     vduv.ew.plotPointY+0
521	.b57d		ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
522	.b580		ed 4e 88	sbc $884e	                sbc     ellipseCountHeight+1
523	.b583		8d 47 03	sta $0347	                sta     vduv.ew.plotPointY+1

525	.b586		a2 44		ldx #$44	                ldx     #VDUVariables.ew.plotPointX
526	.b588		20 4b db	jsr $db4b	                jsr     plotPointInternal
527	.b58b						done:
528	.b58b		7a		ply		                ply
529	.b58c		fa		plx		                plx
530	.b58d		60		rts		                rts
531							                .endblock

533							;-------------------------------------------------------------------------

535	.b58e						LBD83:
536	.b58e		da		phx		                phx
537	.b58f		b9 00 03	lda $0300,y	                lda     vduv+0,y
538	.b592		8d 3f 88	sta $883f	                sta     L883F
539	.b595		b9 01 03	lda $0301,y	                lda     vduv+1,y
540	.b598		8d 40 88	sta $8840	                sta     L8840
541	.b59b		a0 18		ldy #$18	                ldy     #$18 ;not VDUVariables.textCursorXPosition?
542	.b59d		bd 00 03	lda $0300,x	                lda     vduv+0,x
543	.b5a0		8d 3a 88	sta $883a	                sta     L883A
544	.b5a3		bd 01 03	lda $0301,x	                lda     vduv+1,x
545	.b5a6		8d 3b 88	sta $883b	                sta     L883B
546	.b5a9		bd 02 03	lda $0302,x	                lda     vduv+2,x
547	.b5ac		30 0c		bmi $b5ba	                bmi     LBDAF

549	.b5ae						LBDA3:
550	.b5ae		88		dey		                dey
551	.b5af		f0 52		beq $b603	                beq     LBDF8
552	.b5b1		0e 3a 88	asl $883a	                asl     L883A
553	.b5b4		2e 3b 88	rol $883b	                rol     L883B
554	.b5b7		2a		rol a		                rol     a
555	.b5b8		10 f4		bpl $b5ae	                bpl     LBDA3

557	.b5ba						LBDAF:
558	.b5ba		8d 3c 88	sta $883c	                sta     L883C
559	.b5bd		9c 3d 88	stz $883d	                stz     L883D
560	.b5c0		9c 3e 88	stz $883e	                stz     L883E
561	.b5c3		18		clc		                clc

563	.b5c4						LBDB9:
564	.b5c4		2e 3a 88	rol $883a	                rol     L883A
565	.b5c7		2e 3b 88	rol $883b	                rol     L883B
566	.b5ca		2e 3c 88	rol $883c	                rol     L883C
567	.b5cd		2e 3d 88	rol $883d	                rol     L883D
568	.b5d0		2e 3e 88	rol $883e	                rol     L883E
569	.b5d3		38		sec		                sec
570	.b5d4		ad 3d 88	lda $883d	                lda     L883D
571	.b5d7		ed 3f 88	sbc $883f	                sbc     L883F
572	.b5da		aa		tax		                tax
573	.b5db		ad 3e 88	lda $883e	                lda     L883E
574	.b5de		ed 40 88	sbc $8840	                sbc     L8840
575	.b5e1		90 06		bcc $b5e9	                bcc     LBDDE
576	.b5e3		8e 3d 88	stx $883d	                stx     L883D
577	.b5e6		8d 3e 88	sta $883e	                sta     L883E

579	.b5e9						LBDDE:
580	.b5e9		88		dey		                dey
581	.b5ea		d0 d8		bne $b5c4	                bne     LBDB9
582	.b5ec		fa		plx		                plx
583	.b5ed		ad 3a 88	lda $883a	                lda     L883A
584	.b5f0		2a		rol a		                rol     a
585	.b5f1		9d 00 03	sta $0300,x	                sta     vduv+0,x
586	.b5f4		ad 3b 88	lda $883b	                lda     L883B
587	.b5f7		2a		rol a		                rol     a
588	.b5f8		9d 01 03	sta $0301,x	                sta     vduv+1,x
589	.b5fb		ad 3c 88	lda $883c	                lda     L883C
590	.b5fe		2a		rol a		                rol     a
591	.b5ff		9d 02 03	sta $0302,x	                sta     vduv+2,x
592	.b602		60		rts		                rts


595	.b603						LBDF8:
596	.b603		fa		plx		                plx
597	.b604		60		rts		                rts




602							;-------------------------------------------------------------------------
603							;
604							; https://tobylobster.github.io/GXR-pages/gxr/S-s24.html#SP3
605							;

607	.b605						negateVDUVariableXIntoY:
608	.b605		38		sec		                sec
609	.b606		a9 00		lda #$00	                lda     #0
610	.b608		fd 00 03	sbc $0300,x	                sbc     vduv+0,x
611	.b60b		99 00 03	sta $0300,y	                sta     vduv+0,y
612	.b60e		a9 00		lda #$00	                lda     #0
613	.b610		fd 01 03	sbc $0301,x	                sbc     vduv+1,x
614	.b613		99 01 03	sta $0301,y	                sta     vduv+1,y
615	.b616		60		rts		                rts

617							;-------------------------------------------------------------------------

619	.b617						multiply24x24:
620	.b617		a0 17		ldy #$17	                ldy     #23
621	.b619		9c 39 88	stz $8839	                stz     product+5
622	.b61c		9c 38 88	stz $8838	                stz     product+4
623	.b61f		9c 37 88	stz $8837	                stz     product+3
624	.b622		4e 36 88	lsr $8836	                lsr     multiplier+2
625	.b625		6e 35 88	ror $8835	                ror     multiplier+1
626	.b628		6e 34 88	ror $8834	                ror     multiplier+0

628	.b62b						LBE20:
629	.b62b		90 1c		bcc $b649	                bcc     LBE3E
630	.b62d		18		clc		                clc
631	.b62e		ad 30 88	lda $8830	                lda     multiplicand+0
632	.b631		6d 37 88	adc $8837	                adc     product+3
633	.b634		8d 37 88	sta $8837	                sta     product+3
634	.b637		ad 31 88	lda $8831	                lda     multiplicand+1
635	.b63a		6d 38 88	adc $8838	                adc     product+4
636	.b63d		8d 38 88	sta $8838	                sta     product+4
637	.b640		ad 32 88	lda $8832	                lda     multiplicand+2
638	.b643		6d 39 88	adc $8839	                adc     product+5
639	.b646		8d 39 88	sta $8839	                sta     product+5

641	.b649						LBE3E:
642	.b649		18		clc		                clc
643	.b64a		a2 05		ldx #$05	                ldx     #5

645	.b64c						LBE41:
646	.b64c		7e 34 88	ror $8834,x	                ror     product,x
647	.b64f		ca		dex		                dex
648	.b650		10 fa		bpl $b64c	                bpl     LBE41
649	.b652		88		dey		                dey
650	.b653		10 d6		bpl $b62b	                bpl     LBE20
651	.b655		60		rts		                rts

653							;-------------------------------------------------------------------------

655	.b656						LBE4B:
656	.b656		a2 03		ldx #$03	                ldx     #3

658	.b658						LBE4D:
659	.b658		9e 30 88	stz $8830,x	                stz     $8830,x
660	.b65b		74 dc		stz $dc,x	                stz     ZTEMPB,x
661	.b65d		ca		dex		                dex
662	.b65e		10 f8		bpl $b658	                bpl     LBE4D
663	.b660		a0 05		ldy #$05	                ldy     #5

665	.b662						LBE57:
666	.b662		b9 34 88	lda $8834,y	                lda     $8834,y
667	.b665		85 da		sta $da		                sta     ZTEMP+0
668	.b667		5a		phy		                phy
669	.b668		a0 03		ldy #$03	                ldy     #3

671	.b66a						LBE5F:
672	.b66a		5a		phy		                phy
673	.b66b		38		sec		                sec
674	.b66c		2e 30 88	rol $8830	                rol     L8830
675	.b66f		2e 31 88	rol $8831	                rol     L8831
676	.b672		2e 32 88	rol $8832	                rol     L8832
677	.b675		2e 33 88	rol $8833	                rol     L8833
678	.b678		a2 01		ldx #$01	                ldx     #1
679	.b67a		a5 dc		lda $dc		                lda     ZTEMPB+0

681	.b67c						LBE71:
682	.b67c		06 da		asl $da		                asl     ZTEMP+0
683	.b67e		2a		rol a		                rol     a
684	.b67f		26 dd		rol $dd		                rol     ZTEMPB+1
685	.b681		26 de		rol $de		                rol     ZTEMPC+0
686	.b683		26 df		rol $df		                rol     ZTEMPC+1
687	.b685		ca		dex		                dex
688	.b686		10 f4		bpl $b67c	                bpl     LBE71
689	.b688		85 dc		sta $dc		                sta     ZTEMPB+0
690	.b68a		38		sec		                sec
691	.b68b		ed 30 88	sbc $8830	                sbc     L8830
692	.b68e		48		pha		                pha
693	.b68f		a5 dd		lda $dd		                lda     ZTEMPB+1
694	.b691		ed 31 88	sbc $8831	                sbc     L8831
695	.b694		aa		tax		                tax
696	.b695		a5 de		lda $de		                lda     ZTEMPC+0
697	.b697		ed 32 88	sbc $8832	                sbc     L8832
698	.b69a		a8		tay		                tay
699	.b69b		a5 df		lda $df		                lda     ZTEMPC+1
700	.b69d		ed 33 88	sbc $8833	                sbc     L8833
701	.b6a0		90 0e		bcc $b6b0	                bcc     LBEA5
702	.b6a2		85 df		sta $df		                sta     ZTEMPC+1
703	.b6a4		84 de		sty $de		                sty     ZTEMPC+0
704	.b6a6		86 dd		stx $dd		                stx     ZTEMPB+1
705	.b6a8		68		pla		                pla
706	.b6a9		85 dc		sta $dc		                sta     ZTEMPB+0
707	.b6ab		ee 30 88	inc $8830	                inc     L8830
708	.b6ae		80 04		bra $b6b4	                bra     LBEA9


711	.b6b0						LBEA5:
712	.b6b0		68		pla		                pla
713	.b6b1		ce 30 88	dec $8830	                dec     L8830

715	.b6b4						LBEA9:
716	.b6b4		7a		ply		                ply
717	.b6b5		88		dey		                dey
718	.b6b6		10 b2		bpl $b66a	                bpl     LBE5F
719	.b6b8		7a		ply		                ply
720	.b6b9		88		dey		                dey
721	.b6ba		10 a6		bpl $b662	                bpl     LBE57
722	.b6bc		4e 33 88	lsr $8833	                lsr     L8833
723	.b6bf		6e 32 88	ror $8832	                ror     L8832
724	.b6c2		6e 31 88	ror $8831	                ror     L8831
725	.b6c5		6e 30 88	ror $8830	                ror     L8830
726	.b6c8		60		rts		                rts

728							;-------------------------------------------------------------------------
729							;
730							; 184-191 = Move/copy rectangle [MasRef E.3-31]
731							;
732							; The normal interpretation of <p> does not apply in this group of
733							; plot codes and the meanings are as follows:
734							;
735							; 184, 185 - %1011100x - Move rectangle, relative
736							; 186, 187 - %1011101x - Copy rectangle, relative
737							; 188, 189 - %1011110x - Move rectangle, absolute
738							; 190, 191 - %1011111x - Copy rectangle, absolute
739							;
740	.b6c9						plotMoveOrCopyRectangle:
741	.b6c9		29 02		and #$02	                and     #2
742	.b6cb		8d 45 03	sta $0345	                sta     vduv.mocr.copy

744	.b6ce		20 51 c9	jsr $c951	                jsr     prepareForPlotBackground

746	.b6d1		a2 14		ldx #$14	                ldx     #VDUVariables.oldGraphicsCursorPixels
747	.b6d3		20 e6 c8	jsr $c8e6	                jsr     prepareAABB

749							                ; mocr.dest.min = PLOT coordinate
750	.b6d6		a0 34		ldy #$34	                ldy     #VDUVariables.mocr.dest.min
751	.b6d8		20 16 c9	jsr $c916	                jsr     copyLastFourVDUQueueBytes
752	.b6db		84 da		sty $da		                sty     ZTEMP+0              ;Y=VDUVariables.mocr.dest.max

754							                ; dest.max = dest.min + (src.max - src.min)
755	.b6dd		a2 34		ldx #$34	                ldx     #VDUVariables.mocr.dest.min
756	.b6df		a0 2c		ldy #$2c	                ldy     #VDUVariables.mocr.src.max
757	.b6e1		a9 28		lda #$28	                lda     #VDUVariables.mocr.src.min
758	.b6e3		20 7f d5	jsr $d57f	                jsr     addRegionDimensionsToVDUVariableCoordinates

760							                ;
761	.b6e6		a2 28		ldx #$28	                ldx     #VDUVariables.mocr.src.min
762	.b6e8		a0 34		ldy #$34	                ldy     #VDUVariables.mocr.dest
763	.b6ea		20 cb d5	jsr $d5cb	                jsr     sortVDUVariableWords

765	.b6ed		5a		phy		                phy
766	.b6ee		da		phx		                phx
767	.b6ef		a0 00		ldy #$00	                ldy     #0                   ;get outcode for X axis
768	.b6f1		20 b6 d1	jsr $d1b6	                jsr     getOutcodeForAxis
769	.b6f4		f0 08		beq $b6fe	                beq     LBEF3                ;taken if
770	.b6f6		4a		lsr a		                lsr     a
771	.b6f7		f0 03		beq $b6fc	                beq     LBEF1
772	.b6f9		68		pla		                pla

774	.b6fa						LBEEF:
775	.b6fa		68		pla		                pla
776	.b6fb		60		rts		                rts


779	.b6fc						LBEF1:
780	.b6fc		a2 00		ldx #$00	                ldx     #0

782	.b6fe						LBEF3:
783	.b6fe		68		pla		                pla

785	.b6ff		a0 30		ldy #$30	                ldy     #VDUVariables.mocr.L30
786	.b701		84 da		sty $da		                sty     ZTEMP+0
787	.b703		a0 28		ldy #$28	                ldy     #VDUVariables.mocr.src.min
788	.b705		20 8c d5	jsr $d58c	                jsr     addRegionDimensionToVDUVariableCoordinate

790	.b708		a0 3c		ldy #$3c	                ldy     #VDUVariables.ew.pointA
791	.b70a		84 da		sty $da		                sty     ZTEMP+0

793	.b70c		a0 34		ldy #$34	                ldy     #VDUVariables.mocr.dest.min
794	.b70e		20 8c d5	jsr $d58c	                jsr     addRegionDimensionToVDUVariableCoordinate

796	.b711		68		pla		                pla
797	.b712		18		clc		                clc
798	.b713		69 04		adc #$04	                adc     #4
799	.b715		aa		tax		                tax
800	.b716		da		phx		                phx
801	.b717		a0 00		ldy #$00	                ldy     #0
802	.b719		20 b6 d1	jsr $d1b6	                jsr     getOutcodeForAxis
803	.b71c		f0 05		beq $b723	                beq     LBF18
804	.b71e		4a		lsr a		                lsr     a
805	.b71f		f0 d9		beq $b6fa	                beq     LBEEF
806	.b721		a2 04		ldx #$04	                ldx     #4

808	.b723						LBF18:
809	.b723		68		pla		                pla
810	.b724		a0 40		ldy #$40	                ldy     #VDUVariables.mocr.L40
811	.b726		84 da		sty $da		                sty     ZTEMP+0
812	.b728		a0 38		ldy #$38	                ldy     #VDUVariables.mocr.dest.max.x
813	.b72a		20 8c d5	jsr $d58c	                jsr     addRegionDimensionToVDUVariableCoordinate
814	.b72d		ad 40 03	lda $0340	                lda     vduv.mocr.L40
815	.b730		cd 3c 03	cmp $033c	                cmp     vduv.mocr.L3C
816	.b733		ad 41 03	lda $0341	                lda     vduv.mocr.L40+1
817	.b736		ed 3d 03	sbc $033d	                sbc     vduv.mocr.L3C+1
818	.b739		10 10		bpl $b74b	                bpl     LBF40
819	.b73b		ad 45 03	lda $0345	                lda     vduv.mocr.copy
820	.b73e		d0 03		bne $b743	                bne     LBF38
821	.b740		20 1f c4	jsr $c41f	                jsr     LC420

823	.b743						LBF38:
824	.b743		a2 34		ldx #$34	                ldx     #VDUVariables.mocr.dest
825	.b745		20 02 c9	jsr $c902	                jsr     copyEightBytesToWorkspace28
826	.b748		4c 1f c4	jmp $c41f	                jmp     LC420


829	.b74b						LBF40:
830	.b74b		9c 47 03	stz $0347	                stz     vduv.mocr.L47
831	.b74e		ad 30 03	lda $0330	                lda     vduv.mocr.L30
832	.b751		2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne
833	.b754		85 da		sta $da		                sta     ZTEMP+0
834	.b756		ad 3c 03	lda $033c	                lda     vduv.mocr.L3C
835	.b759		2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne
836	.b75c		38		sec		                sec
837	.b75d		e5 da		sbc $da		                sbc     ZTEMP+0
838	.b75f		10 06		bpl $b767	                bpl     LBF5C
839	.b761		ce 47 03	dec $0347	                dec     vduv.mocr.L47
840	.b764		2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne

842	.b767						LBF5C:
843	.b767		8d 43 03	sta $0343	                sta     vduv.ew.currentOffsetX+1
844	.b76a		48		pha		                pha
845	.b76b		49 ff		eor #$ff	                eor     #$ff
846	.b76d		1a		inc a		                inc     a
847	.b76e		2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne
848	.b771		8d 42 03	sta $0342	                sta     vduv.mocr.shiftToNextByte
849	.b774		68		pla		                pla
850	.b775		18		clc		                clc
851	.b776		6d 61 03	adc $0361	                adc     vduv.pixelsPerByteMinusOne
852	.b779		aa		tax		                tax
853	.b77a		bd 1e e1	lda $e11e,x	                lda     LE120,x
854	.b77d		85 e1		sta $e1		                sta     ZTEMPD+1
855	.b77f		a2 3c		ldx #$3c	                ldx     #VDUVariables.mocr.L3C
856	.b781		a0 40		ldy #$40	                ldy     #VDUVariables.mocr.L40
857	.b783		20 9b da	jsr $da9b	                jsr     LDA9C
858	.b786		8d 44 03	sta $0344	                sta     vduv.mocr.L44
859	.b789		a5 d1		lda $d1		                lda     ZMASK
860	.b78b		8d 46 03	sta $0346	                sta     vduv.mocr.L46
861	.b78e		a5 dc		lda $dc		                lda     ZTEMPB+0
862	.b790		85 e0		sta $e0		                sta     ZTEMPD+0
863	.b792		a2 00		ldx #$00	                ldx     #0
864	.b794		20 f1 b7	jsr $b7f1	                jsr     LBFE6
865	.b797		f0 40		beq $b7d9	                beq     LBFCE
866	.b799		ad 2a 03	lda $032a	                lda     vduv.mocr.src.min.y+0
867	.b79c		cd 36 03	cmp $0336	                cmp     vduv.mocr.dest.min.y+0
868	.b79f		ad 2b 03	lda $032b	                lda     vduv.mocr.src.min.y+1
869	.b7a2		ed 37 03	sbc $0337	                sbc     vduv.mocr.dest.min.y+1
870	.b7a5		50 02		bvc $b7a9	                bvc     LBF9E
871	.b7a7		49 80		eor #$80	                eor     #$80

873	.b7a9						LBF9E:
874	.b7a9		30 11		bmi $b7bc	                bmi     LBFB1

876	.b7ab						LBFA0:
877	.b7ab		20 61 db	jsr $db61	                jsr     LDB62
878	.b7ae		a2 00		ldx #$00	                ldx     #0
879	.b7b0		20 dc b7	jsr $b7dc	                jsr     LBFD1
880	.b7b3		a2 0c		ldx #$0c	                ldx     #$c
881	.b7b5		20 dc b7	jsr $b7dc	                jsr     LBFD1
882	.b7b8		d0 f1		bne $b7ab	                bne     LBFA0
883	.b7ba		80 1d		bra $b7d9	                bra     LBFCE


886	.b7bc						LBFB1:
887	.b7bc		a2 2a		ldx #$2a	                ldx     #VDUVariables.mocr.src.min.y
888	.b7be		a0 2e		ldy #$2e	                ldy     #VDUVariables.mocr.src.max.y
889	.b7c0		20 b0 e2	jsr $e2b0	                jsr     exchangeTwoVDUBytes
890	.b7c3		a2 36		ldx #$36	                ldx     #VDUVariables.mocr.dest.min.y
891	.b7c5		a0 3a		ldy #$3a	                ldy     #VDUVariables.mocr.dest.max.y
892	.b7c7		20 b0 e2	jsr $e2b0	                jsr     exchangeTwoVDUBytes

894	.b7ca						LBFBF:
895	.b7ca		20 61 db	jsr $db61	                jsr     LDB62
896	.b7cd		a2 00		ldx #$00	                ldx     #0
897	.b7cf		20 e6 b7	jsr $b7e6	                jsr     LBFDB
898	.b7d2		a2 0c		ldx #$0c	                ldx     #$c
899	.b7d4		20 e6 b7	jsr $b7e6	                jsr     LBFDB
900	.b7d7		d0 f1		bne $b7ca	                bne     LBFBF

902	.b7d9						LBFCE:
903	.b7d9		4c 61 db	jmp $db61	                jmp     LDB62

905	.b7dc						LBFD1:
906	.b7dc		fe 2a 03	inc $032a,x	                inc     vduv.mocr.src.min.y+0,x
907	.b7df		d0 10		bne $b7f1	                bne     LBFE6
908	.b7e1		fe 2b 03	inc $032b,x	                inc     vduv.mocr.src.min.y+1,x
909	.b7e4		80 0b		bra $b7f1	                bra     LBFE6

911	.b7e6						LBFDB:
912	.b7e6		bd 2a 03	lda $032a,x	                lda     vduv.mocr.src.min.y+0,x
913	.b7e9		d0 03		bne $b7ee	                bne     LBFE3
914	.b7eb		de 2b 03	dec $032b,x	                dec     vduv.mocr.src.min.y+1,x

916	.b7ee						LBFE3:
917	.b7ee		de 2a 03	dec $032a,x	                dec     vduv.mocr.src.min.y+0,x
918	.b7f1						LBFE6:
919	.b7f1		bd 2a 03	lda $032a,x	                lda     vduv.mocr.src.min.y+0,x
920	.b7f4		dd 2e 03	cmp $032e,x	                cmp     vduv.mocr.src.max.y+0,x
921	.b7f7		d0 06		bne $b7ff	                bne     rtsBFF4
922	.b7f9		bd 2b 03	lda $032b,x	                lda     vduv.mocr.src.min.y+1,x
923	.b7fc		dd 2f 03	cmp $032f,x	                cmp     vduv.mocr.src.max.y+1,x

925	.b7ff						rtsBFF4:
926	.b7ff		60		rts		                rts

928							                .if version!=400&&version!=350
941							                .endif


:1	;******  Return to file: mos350.s65

29							                .endsection

31							                .section utils
32							                .include "src/terminal.s65"

:7	;******  Processing file: src/terminal.s65

1							; -*- comment-column:45; -*-

3	.8000						utilsROMHeader: .block
4							                .if (version==320||version==350)&&includeTerminalROM
5	.8000		4c 95 af	jmp $af95	                jmp terminalLanguageEntryPoint ; Language entry point
6	.8003		4c 8d 9d	jmp $9d8d	                jmp utilsServiceEntryPoint  ; Service entry point
7	>8006		c2				                .byte $C2                    ; ROM type=SERV+LANG+6502
8	>8007		11				                .byte copyrightText-1-utilsROMHeader ; (C) offset
9	>8008		01				                .byte $01
10	>8009		54 45 52 4d 49 4e 41 4c		                .text "TERMINAL"
11	>8011		00				                .byte 0
12	.8012						copyrightText:
13							                .if version==350
14	>8012		28 43 29 31 39 38 36 20		                .text "(C)1986 Acorn"
	>801a		41 63 6f 72 6e
17							                .endif
18	>801f		00				                .byte 0

65							                .endif
66							                .endblock

68							;-------------------------------------------------------------------------

70							                .if version==350
71	.8020						trbACCCON:
72	.8020		20 5c f3	jsr $f35c	                jsr withTSTClear
73	.8023		1c 34 fe	trb $fe34	                trb ACCCON
74	.8026		60		rts		                rts
75							                .endif

77							;-------------------------------------------------------------------------

79							                .if version==350
80	.8027						tsbACCCON:
81	.8027		20 5c f3	jsr $f35c	                jsr withTSTClear
82	.802a		0c 34 fe	tsb $fe34	                tsb ACCCON
83	.802d		60		rts		                rts
84							                .endif

86							;-------------------------------------------------------------------------

88							                .if version==350
89	.802e						ldaSystemVIAIER:
90	.802e		20 5c f3	jsr $f35c	                jsr withTSTClear
91	.8031		ad 4e fe	lda $fe4e	                lda systemVIA.ier
92	.8034		60		rts		                rts
93							                .endif

95							;-------------------------------------------------------------------------

97							                .if version==350
98	.8035						printCMOSRamResetMessage:
99	.8035		20 5c f3	jsr $f35c	                jsr withTSTClear
100	.8038		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
101	>803b		0d 0a				                .text 13,10
102	>803d		43 4d 4f 53 20 52 41 4d		                .text "CMOS RAM reset",13,10
	>8045		20 72 65 73 65 74 0d 0a
103	>804d		50 72 65 73 73 20 62 72		                .text "Press break to continue",13,10
	>8055		65 61 6b 20 74 6f 20 63 6f 6e 74 69 6e 75 65 0d
	>8065		0a
104	>8066		00				                .text 0
105	.8067		60		rts		                rts
106							                .endif

108							;-------------------------------------------------------------------------

110							                .if version==350
111							                .if includeTubeSupport
112							                .include "isSecondProcessorPresent.s65"

:22	;******  Processing file: src/isSecondProcessorPresent.s65

1							;-------------------------------------------------------------------------
2							;
3							; Check if a coprocessor is attached to the Tube
4							;
5							; exit:
6							;
7							; C=0 = no Tube
8							;
9							; C=1 = Tube
10							;

12							; (Note that this code is always included in MOS 5.xx, even though
13							; there's no second processor support.)

15	.8068						isSecondProcessorPresent:
16							                .if version==350
17	.8068		20 5c f3	jsr $f35c	                jsr withTSTClear
18							                .endif
19	.806b		a2 01		ldx #$01	                ldx #$01
20	.806d		8e e0 fe	stx $fee0	                stx $fee0;tube.status1
21	.8070		ad e0 fe	lda $fee0	                lda $fee0;tube.status1
22	.8073		49 01		eor #$01	                eor #$01
23	.8075		a2 81		ldx #$81	                ldx #$81
24	.8077		8e e0 fe	stx $fee0	                stx $fee0;tube.status1
25	.807a		2d e0 fe	and $fee0	                and $fee0;tube.status1       ; Cy=0 if no Tube, Cy=1 if Tube
26	.807d		6a		ror a		                ror a
27	.807e		60		rts		                rts


:7	;******  Return to file: src/terminal.s65

113							                .endif
114							                .endif

116							;-------------------------------------------------------------------------

118							                .if version==350
119	.807f						resetCRTC:
120	.807f		a2 1e		ldx #$1e	                ldx #$1e
121	.8081						L8081:
122	.8081		8e 00 fe	stx $fe00	                stx $fe00
123	.8084		9c 01 fe	stz $fe01	                stz $fe01
124	.8087		e8		inx		                inx
125	.8088		e0 21		cpx #$21	                cpx #$21
126	.808a		90 f5		bcc $8081	                bcc L8081
127	.808c		60		rts		                rts
128							                .endif

130							;-------------------------------------------------------------------------

132							; STARTUP
133							; =======

135							; This code is officially more than a bit gnarly, as it gets stitched
136							; together in several different ways.

138							                .if version==350             ;stripped_out_reset
139	.808d						softResetPart2:
140	.808d		20 5c f3	jsr $f35c	                jsr withTSTClear
141	.8090		68		pla		                pla
142	.8091		68		pla		                pla
143	.8092		68		pla		                pla
147							                .endif

149							                .if includeTubeSupport
150	.8093		90 0a		bcc $809f	                bcc handleROMWorkspace        ;taken if Tube not found
151							                .if version!=350
153							                .endif
154	.8095		a2 ff		ldx #$ff	                ldx #romServiceCallTubeMainInitialisation
155	.8097		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall   ;
156	.809a		d0 03		bne $809f	                bne handleROMWorkspace        ; Not claimed, step past
157	.809c		ce 7a 02	dec $027a	                dec tubePresence ; Tube PreInit claimed, set TubeFlag to &FF, Tube present
158							                .endif
159							                .if version!=350
161							                .endif
162	.809f						handleROMWorkspace:
163	.809f		ad 8d 02	lda $028d	                lda lastBREAKType ; Soft Break, don't ask about workspace
164	.80a2		f0 27		beq $80cb	                beq L82FC
165	.80a4		a0 dc		ldy #$dc	                ldy #$DC                     ; Start high workspace at &DC00 and work downwards
166	.80a6		a2 24		ldx #$24	                ldx #romServiceCallCountDynamicHAZELWorkspace ; Ask ROMs how much private high workspace required
167	.80a8		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall   ;
168	.80ab		a2 21		ldx #$21	                ldx #romServiceCallAbsoluteHAZELWorkspaceClaim ; Ask ROMs for maximum shared high workspace required
169	.80ad		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall   ;
170	.80b0		5a		phy		                phy                          ; Save top of shared workspace
171	.80b1		a2 22		ldx #$22	                ldx #romServiceCallPrivateHAZELWorkspaceClam ; Ask ROMs for private high workspace required
172	.80b3		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall   ;
173	.80b6		a0 0e		ldy #$0e	                ldy #$0E                     ; Start low workspace at &0E00
174	.80b8		a2 01		ldx #$01	                ldx #romServiceCallAbsoluteWorkspaceClaim ; Ask ROMs for maximum shared workspace
175	.80ba		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall   ;
176	.80bd		a2 02		ldx #$02	                ldx #romServiceCallPrivateWorkspaceClaim ; Ask ROMs for private workspace
177	.80bf		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall   ;
178	.80c2		8c 44 02	sty $0244	                sty oshwm                    ; Set OSHWM - default PAGE
179	.80c5		7a		ply		                ply                          ; Get top of shared high workspace
180	.80c6		a2 23		ldx #$23	                ldx #romServiceCallTopOfHAZELWorkspace ; Tell ROMs top of shared high workspace
181	.80c8		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall   ;
182	.80cb						L82FC:
183	.80cb		a2 21		ldx #$21	                ldx #size(defaultFsInfoBlocks)
184	.80cd						L82FE:
185	.80cd		bd 15 81	lda $8115,x	                lda defaultFsInfoBlocks-1,x                ; Copy initial FS info blocks for CFS, TAPE, ROM
186	.80d0		9d 05 df	sta $df05,x	                sta hazel.fsInfoBlocks-1,x
187	.80d3		ca		dex		                dex
188	.80d4		d0 f7		bne $80cd	                bne L82FE
189	.80d6		64 f2		stz $f2		                stz $F2                      ; &F2/3=>FS Info Blocks
190	.80d8		a9 df		lda #$df	                lda #>hazel.fsInfoBlocks
191	.80da		85 f3		sta $f3		                sta $F3
192							                ; Y=>end of FS Info Blocks
193	.80dc		a0 27		ldy #$27	                ldy #<hazel.fsInfoBlocks+size(defaultFsInfoBlocks)
194	.80de		a2 25		ldx #$25	                ldx #romServiceCallRequestFSInfo
195	.80e0		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall   ;
196	.80e3		a9 00		lda #$00	                lda #$00                     ; Terminate FS Info blocks
197	.80e5		91 f2		sta ($f2),y	                sta ($F2),y

199	.80e7		ad 57 02	lda $0257	                lda spoolFileHandle ; Save Spool handle and disable Spooling
200	.80ea		48		pha		                pha
201	.80eb		9c 57 02	stz $0257	                stz spoolFileHandle
202	.80ee		a2 fe		ldx #$fe	                ldx #romServiceCallTubeSystemPostInitialisation
203							                .if includeTubeSupport
204	.80f0		ac 7a 02	ldy $027a	                ldy tubePresence
207							                .endif
208	.80f3		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall   ; Tube PostInit
209	.80f6		2d 67 02	and $0267	                and startupMessageSuppressionStatus
210	.80f9		10 14		bpl $810f	                bpl L8340

212							                ; use +$ff rather than -1 to avoid 64tass warning.
213							                ; Only the LSB is used.
214	.80fb		a0 ff		ldy #$ff	                ldy #((startupMessages.acornMOS-(startupMessages&$ff00))+$ff)&$ff
215	.80fd		20 6d e7	jsr $e76d	                jsr printStartupMessage
216	.8100		ad 8d 02	lda $028d	                lda lastBREAKType            ; Skip past if Soft Break
217	.8103		f0 05		beq $810a	                beq L833B
218	.8105		a0 0b		ldy #$0b	                ldy #((startupMessages.beep-(startupMessages&$ff00))-1)&$ff
219	.8107		20 6d e7	jsr $e76d	                jsr printStartupMessage
220	.810a						L833B:
221	.810a		a0 0d		ldy #$0d	                ldy #((startupMessages.twoNewlines-(startupMessages&$ff00))-1)&$ff
222	.810c		20 6d e7	jsr $e76d	                jsr printStartupMessage
223	.810f						L8340:
224	.810f		68		pla		                pla                          ; Restore Spool handle
225	.8110		8d 57 02	sta $0257	                sta spoolFileHandle
226	.8113		4c c1 e3	jmp $e3c1	                jmp LE40E                ;

228							;-------------------------------------------------------------------------

230							                .if version>=500
238							                .endif
239							                .if version>=400
248							                .endif

250							;-------------------------------------------------------------------------

252							; Default FS Info Blocks
253							; ======================
254	.8116						defaultFsInfoBlocks: .block
255							                .if version<500
256	>8116		43 46 53 20 20 20 20 20		                .text "CFS     "
257	>811e		01				                .byte $01
258	>811f		02				                .byte $02
259	>8120		01				                .byte $01
260	>8121		54 41 50 45 20 20 20 20		                .text "TAPE    "
261	>8129		01				                .byte $01
262	>812a		02				                .byte $02
263	>812b		01				                .byte $01
264							                .endif
265	>812c		52 4f 4d 20 20 20 20 20		                .text "ROM     "
266	>8134		03				                .byte $03
267	>8135		03				                .byte $03
268	>8136		03				                .byte $03
269							                .endblock

271							;-------------------------------------------------------------------------
272							;
273							; MOS command table

275							mos_command .macro name,routine,byte1,byte2
292							                .endm

294	.8137						mosCommandTable:
276							                ; Name of command, compared case-insensitively.
277	>8137		43 41 54			                .text "CAT"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>813a		f1				                .byte >callFSCV
126	>813b		50				                .byte <callFSCV

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>813c		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>813d		05				                .byte $05
296							                .if version!=400
276							                ; Name of command, compared case-insensitively.
277	>813e		41 44 46 53			                .text "ADFS"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8142		83				                .byte >passStarCommandThrough
126	>8143		79				                .byte <passStarCommandThrough

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8144		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8145		00				                .byte $00
298							                .endif
276							                ; Name of command, compared case-insensitively.
277	>8146		41 50 50 45 4e 44		                .text "APPEND"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>814c		8f				                .byte >starAPPEND
126	>814d		ea				                .byte <starAPPEND

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>814e		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>814f		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8150		42 41 53 49 43			                .text "BASIC"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8155		83				                .byte >starBASIC
126	>8156		71				                .byte <starBASIC

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8157		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8158		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8159		42 55 49 4c 44			                .text "BUILD"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>815e		8f				                .byte >starBUILD
126	>815f		e5				                .byte <starBUILD

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8160		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8161		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8162		43 4c 4f 53 45			                .text "CLOSE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8167		94				                .byte >starCLOSE
126	>8168		04				                .byte <starCLOSE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8169		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>816a		ff				                .byte $FF
303							                .if useTableDrivenConfigure
276							                ; Name of command, compared case-insensitively.
277	>816b		43 4f 4e 46 49 47 55 52		                .text "CONFIGURE"
	>8173		45

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8174		86				                .byte >starCONFIGUREOrStarSTATUS
126	>8175		23				                .byte <starCONFIGUREOrStarSTATUS

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8176		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8177		80				                .byte $80
307							                .endif
276							                ; Name of command, compared case-insensitively.
277	>8178		43 4f 44 45			                .text "CODE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>817c		93				                .byte >starCommandThroughOSBYTE
126	>817d		85				                .byte <starCommandThroughOSBYTE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>817e		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>817f		88				                .byte $88
276							                ; Name of command, compared case-insensitively.
277	>8180		43 52 45 41 54 45		                .text "CREATE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8186		92				                .byte >starCommandThroughOSFILE
126	>8187		b6				                .byte <starCommandThroughOSFILE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8188		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8189		07				                .byte $07
276							                ; Name of command, compared case-insensitively.
277	>818a		44 55 4d 50			                .text "DUMP"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>818e		8f				                .byte >starDUMP
126	>818f		18				                .byte <starDUMP

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8190		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8191		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8192		44 45 4c 45 54 45		                .text "DELETE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8198		94				                .byte >starDELETE
126	>8199		1a				                .byte <starDELETE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>819a		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>819b		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>819c		45 58 45 43			                .text "EXEC"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81a0		a5				                .byte >starEXEC
126	>81a1		ab				                .byte <starEXEC

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81a2		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81a3		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>81a4		45 58				                .text "EX"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81a6		f1				                .byte >callFSCV
126	>81a7		50				                .byte <callFSCV

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81a8		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81a9		09				                .byte $09
276							                ; Name of command, compared case-insensitively.
277	>81aa		46 58				                .text "FX"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81ac		93				                .byte >starFX
126	>81ad		7f				                .byte <starFX

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81ae		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81af		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>81b0		47 4f 49 4f			                .text "GOIO"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81b4		92				                .byte >starGOIO
126	>81b5		9b				                .byte <starGOIO

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81b6		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81b7		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>81b8		47 4f				                .text "GO"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81ba		92				                .byte >starGO
126	>81bb		93				                .byte <starGO

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81bc		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81bd		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>81be		48 45 4c 50			                .text "HELP"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81c2		83				                .byte >starHELP
126	>81c3		94				                .byte <starHELP

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81c4		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81c5		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>81c6		49 4e 46 4f			                .text "INFO"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81ca		f1				                .byte >callFSCV
126	>81cb		50				                .byte <callFSCV

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81cc		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81cd		0a				                .byte $0A
276							                ; Name of command, compared case-insensitively.
277	>81ce		49 47 4e 4f 52 45		                .text "IGNORE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81d4		94				                .byte >starIGNORE
126	>81d5		0f				                .byte <starIGNORE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81d6		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81d7		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>81d8		49 4e 53 45 52 54		                .text "INSERT"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81de		84				                .byte >starINSERT
126	>81df		ff				                .byte <starINSERT

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81e0		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81e1		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>81e2		4b 45 59			                .text "KEY"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81e5		97				                .byte >starKEY
126	>81e6		c5				                .byte <starKEY

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81e7		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81e8		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>81e9		4c 4f 41 44			                .text "LOAD"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81ed		92				                .byte >starLOAD
126	>81ee		b4				                .byte <starLOAD

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81ef		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81f0		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>81f1		4c 49 53 54			                .text "LIST"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81f5		8e				                .byte >starLIST
126	>81f6		96				                .byte <starLIST

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81f7		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>81f8		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>81f9		4c 49 4e 45			                .text "LINE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>81fd		eb				                .byte >callUSERV
126	>81fe		81				                .byte <callUSERV

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>81ff		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8200		01				                .byte $01
276							                ; Name of command, compared case-insensitively.
277	>8201		4c 49 42 46 53			                .text "LIBFS"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8206		e7				                .byte >starLIBFS
126	>8207		c2				                .byte <starLIBFS

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8208		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8209		00				                .byte $00
326							                .if version<500
276							                ; Name of command, compared case-insensitively.
277	>820a		4d 4f 54 4f 52			                .text motorCommandString

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>820f		93				                .byte >starCommandThroughOSBYTE
126	>8210		85				                .byte <starCommandThroughOSBYTE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8211		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8212		89				                .byte $89
330							                .endif
276							                ; Name of command, compared case-insensitively.
277	>8213		4d 4f 56 45			                .text "MOVE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8217		90				                .byte >starMOVE
126	>8218		97				                .byte <starMOVE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8219		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>821a		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>821b		4f 50 54			                .text "OPT"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>821e		93				                .byte >starCommandThroughOSBYTE
126	>821f		85				                .byte <starCommandThroughOSBYTE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8220		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8221		8b				                .byte $8B
276							                ; Name of command, compared case-insensitively.
277	>8222		50 52 49 4e 54			                .text "PRINT"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8227		8e				                .byte >starPRINT
126	>8228		8f				                .byte <starPRINT

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8229		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>822a		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>822b		52 55 4e			                .text "RUN"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>822e		f1				                .byte >callFSCV
126	>822f		50				                .byte <callFSCV

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8230		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8231		04				                .byte $04
276							                ; Name of command, compared case-insensitively.
277	>8232		52 45 4d 4f 56 45		                .text "REMOVE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8238		93				                .byte >starREMOVE
126	>8239		0f				                .byte <starREMOVE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>823a		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>823b		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>823c		52 4f 4d			                .text "ROM"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>823f		93				                .byte >starCommandThroughOSBYTE
126	>8240		85				                .byte <starCommandThroughOSBYTE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8241		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8242		8d				                .byte $8D
276							                ; Name of command, compared case-insensitively.
277	>8243		52 4f 4d 53			                .text "ROMS"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8247		84				                .byte >starROMS
126	>8248		6e				                .byte <starROMS

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8249		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>824a		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>824b		53 41 56 45			                .text "SAVE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>824f		92				                .byte >starCommandThroughOSFILE
126	>8250		b6				                .byte <starCommandThroughOSFILE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8251		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8252		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8253		53 48 41 44 4f 57		                .text "SHADOW"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8259		93				                .byte >starSHADOW
126	>825a		bd				                .byte <starSHADOW

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>825b		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>825c		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>825d		53 48 4f 57			                .text "SHOW"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8261		97				                .byte >starSHOW
126	>8262		65				                .byte <starSHOW

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8263		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8264		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>8265		53 48 55 54			                .text "SHUT"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8269		f3				                .byte >starSHUT
126	>826a		05				                .byte <starSHUT

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>826b		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>826c		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>826d		53 50 4f 4f 4c			                .text "SPOOL"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8272		93				                .byte >starSPOOL
126	>8273		d1				                .byte <starSPOOL

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8274		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8275		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8276		53 50 4f 4f 4c 4f 4e		                .text "SPOOLON"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>827d		93				                .byte >starSPOOLON
126	>827e		ba				                .byte <starSPOOLON

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>827f		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8280		00				                .byte $00
344							                .if version>=350
276							                ; Name of command, compared case-insensitively.
277	>8281		53 52 44 41 54 41		                .text "SRDATA"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8287		8a				                .byte >starSRDATAOrStarSRROM
126	>8288		83				                .byte <starSRDATAOrStarSRROM

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8289		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>828a		a0				                .byte $a0
276							                ; Name of command, compared case-insensitively.
277	>828b		53 52 4c 4f 41 44		                .text "SRLOAD"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8291		8b				                .byte >starSRLOADOrStarSRSAVE
126	>8292		d1				                .byte <starSRLOADOrStarSRSAVE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8293		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8294		60				                .byte $60
276							                ; Name of command, compared case-insensitively.
277	>8295		53 52 52 45 41 44		                .text "SRREAD"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>829b		8b				                .byte >starSRREADOrStarSRWRITE
126	>829c		55				                .byte <starSRREADOrStarSRWRITE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>829d		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>829e		a0				                .byte $a0
276							                ; Name of command, compared case-insensitively.
277	>829f		53 52 52 4f 4d			                .text "SRROM"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>82a4		8a				                .byte >starSRDATAOrStarSRROM
126	>82a5		83				                .byte <starSRDATAOrStarSRROM

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>82a6		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>82a7		80				                .byte $80
276							                ; Name of command, compared case-insensitively.
277	>82a8		53 52 53 41 56 45		                .text "SRSAVE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>82ae		8b				                .byte >starSRLOADOrStarSRSAVE
126	>82af		d1				                .byte <starSRLOADOrStarSRSAVE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>82b0		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>82b1		20				                .byte $20
276							                ; Name of command, compared case-insensitively.
277	>82b2		53 52 57 52 49 54 45		                .text "SRWRITE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>82b9		8b				                .byte >starSRREADOrStarSRWRITE
126	>82ba		55				                .byte <starSRREADOrStarSRWRITE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>82bb		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>82bc		e0				                .byte $e0
351							                .endif
352							                .if useTableDrivenConfigure
276							                ; Name of command, compared case-insensitively.
277	>82bd		53 54 41 54 55 53		                .text "STATUS"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>82c3		86				                .byte >starCONFIGUREOrStarSTATUS
126	>82c4		23				                .byte <starCONFIGUREOrStarSTATUS

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>82c5		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>82c6		c0				                .byte $c0
356							                .endif
357							                .if version<500
276							                ; Name of command, compared case-insensitively.
277	>82c7		54 41 50 45			                .text tapeCommandString

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>82cb		93				                .byte >starCommandThroughOSBYTE
126	>82cc		85				                .byte <starCommandThroughOSBYTE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>82cd		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>82ce		8c				                .byte $8C
361							                .endif
276							                ; Name of command, compared case-insensitively.
277	>82cf		54 56				                .text "TV"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>82d1		93				                .byte >starCommandThroughOSBYTE
126	>82d2		85				                .byte <starCommandThroughOSBYTE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>82d3		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>82d4		90				                .byte $90
276							                ; Name of command, compared case-insensitively.
277	>82d5		54 49 4d 45			                .text "TIME"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>82d9		85				                .byte >starTIME
126	>82da		24				                .byte <starTIME

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>82db		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>82dc		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>82dd		54 59 50 45			                .text "TYPE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>82e1		8e				                .byte >starTYPE
126	>82e2		a1				                .byte <starTYPE

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>82e3		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>82e4		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>82e5		55 4e 50 4c 55 47		                .text "UNPLUG"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>82eb		85				                .byte >starUNPLUG
126	>82ec		02				                .byte <starUNPLUG

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>82ed		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>82ee		ff				                .byte $FF
366							                .if includeStarX
276							                ; Name of command, compared case-insensitively.
277	>82ef		58				                .text "X"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>82f0		e7				                .byte >starX
126	>82f1		c9				                .byte <starX

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>82f2		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>82f3		00				                .byte $00
368							                .endif
276							                ; Name of command, compared case-insensitively.
277	>82f4						                .text ""

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>82f4		f1				                .byte >callFSCV
126	>82f5		50				                .byte <callFSCV

283:7							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>82f6		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>82f7		03				                .byte $03
370	>82f8		00				                .byte $00

372							;-------------------------------------------------------------------------
373							;
374							; Get string input buffer address tail according to table byte.
375							;
376							; Entry:
377							;
378							; oscliWorkspace.tablePtr; = pointer to table byte
379							; (stringInputBufferAddress),y = pointer to input
380							;
381							; Exit:
382							;
383							; A = table byte
384							;
385							; if table byte bit 7 set: Y/X points to command line tail
386	.82f9						maybeGetStringInputBufferAddress:
387	.82f9		b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr)
388	.82fb		30 0c		bmi $8309	                bmi rts84FE
389	.82fd						getStringInputBufferAddressWithYOffset:
390	.82fd		98		tya		                tya
391	.82fe						getStringInputBufferAddressWithAOffset:
392	.82fe		18		clc		                clc
393	.82ff		65 f2		adc $f2		                adc stringInputBufferAddress+0
394	.8301		aa		tax		                tax
395	.8302		a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
396	.8304		90 01		bcc $8307	                bcc +
397	.8306		c8		iny		                iny
398	.8307						+
399	.8307		b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr)
400	.8309						rts84FE:
401	.8309		60		rts		                rts

403							; Prepare OSCLI command line
404							; ==========================
405	.830a						oscli:
406	.830a		86 f2		stx $f2		                stx stringInputBufferAddress+0
407	.830c		84 f3		sty $f3		                sty stringInputBufferAddress+1
408	.830e		ad 00 df	lda $df00	                lda hazel.currentFS
409	.8311		20 89 f8	jsr $f889	                jsr selectFS
410	.8314		a9 08		lda #$08	                lda #fscStarCommand
411	.8316		20 50 f1	jsr $f150	                jsr callFSCV
412	.8319		a0 ff		ldy #$ff	                ldy #$FF
413	.831b						L8510:
414	.831b		20 71 f2	jsr $f271	                jsr incAndSkipSpaces
415	.831e		f0 e9		beq $8309	                beq rts84FE
416	.8320		c9 2a		cmp #$2a	                cmp #'*'
417	.8322		f0 f7		beq $831b	                beq L8510
418	.8324		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
419	.8327		f0 e0		beq $8309	                beq rts84FE
420	.8329		c9 7c		cmp #$7c	                cmp #'|'
421	.832b		f0 dc		beq $8309	                beq rts84FE
422	.832d		9c c6 df	stz $dfc6	                stz hazel.tempFSFlag
423	.8330		c9 2d		cmp #$2d	                cmp #'-'
424	.8332		d0 0c		bne $8340	                bne L8535
425	.8334		20 e2 f7	jsr $f7e2	                jsr parseFileNameFS
426	.8337		20 89 f8	jsr $f889	                jsr selectFS
427	.833a		38		sec		                sec
428	.833b		6e c6 df	ror $dfc6	                ror hazel.tempFSFlag
429	.833e		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
430	.8340						L8535:
431	.8340		c9 2f		cmp #$2f	                cmp #'/'
432	.8342		d0 09		bne $834d	                bne L8542
433	.8344		c8		iny		                iny
434	.8345		20 fd 82	jsr $82fd	                jsr getStringInputBufferAddressWithYOffset
435	.8348		a9 02		lda #$02	                lda #fscStarSlash
436	.834a		4c 50 f1	jmp $f150	                jmp callFSCV

438	.834d						L8542:
439							                .if version<500&&version!=350
441							                .endif
442	.834d		a9 37		lda #$37	                lda #<mosCommandTable
443	.834f		85 b0		sta $b0		                sta oscliWorkspace.tablePtr+0
444	.8351		a9 81		lda #$81	                lda #>mosCommandTable
445	.8353		85 b1		sta $b1		                sta oscliWorkspace.tablePtr+1
446							                .if version<500&&version!=350
448							                .else
449	.8355		b8		clv		                clv
450	.8356		20 5f 88	jsr $885f	                jsr findCommand
451	.8359		90 1e		bcc $8379	                bcc passStarCommandThrough
452							                .endif

454							                .if version<500&&version!=350
488							                .endif
489	.835b						L8585:
490	.835b		48		pha		                pha
491	.835c		20 9e 88	jsr $889e	                jsr fetchCommandTableByte
492	.835f		48		pha		                pha
493	.8360		20 9e 88	jsr $889e	                jsr fetchCommandTableByte
494	.8363		30 03		bmi $8368	                bmi L8592
495	.8365		9c c6 df	stz $dfc6	                stz hazel.tempFSFlag
496	.8368						L8592:
497	.8368		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
498	.836b		18		clc		                clc
499	.836c		08		php		                php
500	.836d		20 f9 82	jsr $82f9	                jsr maybeGetStringInputBufferAddress
501	.8370		40		rti		                rti

503							                .if !useTableDrivenConfigure
519							                .endif

521							;-------------------------------------------------------------------------

523							; *BASIC
524							; ======
525	.8371						starBASIC:
526	.8371		ae 4b 02	ldx $024b	                ldx basicROMNumber           ; Get BASIC ROM number
527	.8374		30 03		bmi $8379	                bmi passStarCommandThrough ; If no BASIC ROM, jump to pass to ROMs and filing system
528							                .if version==350&&includeTubeSupport
529	.8376		4c f9 fa	jmp $faf9	                jmp osbyte8EWithoutRelocation
536							                .endif

538							;-------------------------------------------------------------------------

540							; *ADFS - pass straight to ROMs/Filing System
541							; ===========================================
542	.8379						passStarCommandThrough:
543	.8379		2c c6 df	bit $dfc6	                bit hazel.tempFSFlag      ; Check filing system flag
544	.837c		30 0c		bmi $838a	                bmi L85C0                    ; If ... skip ROM service call
545	.837e		9c c6 df	stz $dfc6	                stz hazel.tempFSFlag      ; Clear filing system flag
546	.8381		a4 e6		ldy $e6		                ldy $E6
547	.8383		a2 04		ldx #$04	                ldx #romServiceCallUnrecognisedCommand
548	.8385		20 46 ed	jsr $ed46	                jsr osbyte8F    ; Service call 4 - Unknown command
549							                .if useTableDrivenConfigure
550	.8388		f0 4d		beq $83d7	                beq parseDone
553							                .endif
554	.838a						L85C0:
555	.838a		a5 e6		lda $e6		                lda $E6
556	.838c		20 fe 82	jsr $82fe	                jsr getStringInputBufferAddressWithAOffset
557	.838f		a9 03		lda #$03	                lda #$03
558	.8391		4c 50 f1	jmp $f150	                jmp callFSCV ; Pass to FSCV,3 - Unknown command

560	.8394						starHELP:
561	.8394		a2 09		ldx #$09	                ldx #romServiceCallHelp      ;
562	.8396		a5 d0		lda $d0		                lda STATE                    ;
563	.8398		48		pha		                pha                          ;save STATE
564	.8399		a9 0e		lda #$0e	                lda #14
565	.839b		20 ee ff	jsr $ffee	                jsr OSWRCH                   ; paged mode ON
566	.839e		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall   ;
567	.83a1		a2 18		ldx #$18	                ldx #romServiceCallReserved  ;???
568	.83a3		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
569	.83a6		68		pla		                pla                          ;restore STATE
570	.83a7		89 04		bit #$04	                bit #STATE.isPagedScrolling  ;was paged mode on originally?
571	.83a9		d0 2c		bne $83d7	                bne parseDone   ;taken if paged mode was originally on
572							                                ;(branch target is an arbitrary nearby
573							                                ;RTS)
574	.83ab		a9 0f		lda #$0f	                lda #15         ;restore non-paged mode
575	.83ad		4c ee ff	jmp $ffee	                jmp OSWRCH

577							;-------------------------------------------------------------------------
578							;
579							; Read a byte value (0-255) from a string. If the number has a '&'
580							; prefix, interpret it as hex.
581							;
582							; entry:
583							;
584							; (stringInputBufferAddress),y - string
585							;
586							; exit:
587							;
588							; X = result
589							; ?$e6 = result
590							; C=0 if error
591							; Z=1 if CR encountered
592							;
593	.83b0						parseNumberFromString:
594	.83b0		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
595	.83b3		c9 26		cmp #$26	                cmp #'&'                     ; hex value incoming?
596	.83b5		d0 21		bne $83d8	                bne parseDecimal             ; taken if not hex value
597	.83b7						parseHex:
598	.83b7		c8		iny		                iny                          ; skip '&'
599	.83b8		20 10 84	jsr $8410	                jsr readHexDigit             ; read first hex digit
600	.83bb		90 51		bcc $840e	                bcc errorReadingString
601	.83bd		85 e6		sta $e6		                sta $E6                      ; save first hex digit
602	.83bf		20 10 84	jsr $8410	                jsr readHexDigit             ; read second hex digih
603	.83c2		90 0e		bcc $83d2	                bcc parsedValue         ; taken if not hex digit
604							                ; The first digit read was actually the high nybble,
605							                ; and the current digit read is therefore the low
606							                ; nybble.
607							                ;
608							                ; Shift saved digit 4 bits left.
609	.83c4		a2 04		ldx #$04	                ldx #$04
610	.83c6						-
611	.83c6		06 e6		asl $e6		                asl $E6
612	.83c8		ca		dex		                dex
613	.83c9		d0 fb		bne $83c6	                bne -
614	.83cb		04 e6		tsb $e6		                tsb $E6                      ; insert low nybble
615	.83cd		20 10 84	jsr $8410	                jsr readHexDigit             ; read third hex digit
616	.83d0		b0 29		bcs $83fb	                bcs errorReadingString2 ; 3+-digit hex values are not valid
617	.83d2						parsedValue:
618	.83d2		a6 e6		ldx $e6		                ldx $E6
619	.83d4		c9 0d		cmp #$0d	                cmp #$0D
620	.83d6		38		sec		                sec
621	.83d7						parseDone:
622	.83d7		60		rts		                rts

624	.83d8						parseDecimal:
625	.83d8		20 fe 83	jsr $83fe	                jsr readDigitFromString
626	.83db		90 31		bcc $840e	                bcc errorReadingString      ;branch taken if not digit
627	.83dd						parseDecimalDigit:
628	.83dd		85 e6		sta $e6		                sta $E6                     ;save current value
629	.83df		20 fd 83	jsr $83fd	                jsr readNextDigitFromString
630	.83e2		90 ee		bcc $83d2	                bcc parsedValue ;branch taken if not digit, meaning number
631							                                     ;parsed successfully
632	.83e4		aa		tax		                tax                         ;X=digit

634							                ; calculate (value*4+value)*2 - i.e., value*10. Carry
635							                ; at any point indicates the value was greater than
636							                ; 255, and therefore an error.
637	.83e5		a5 e6		lda $e6		                lda $E6                     ;value
638	.83e7		0a		asl a		                asl a                       ;value*2
639	.83e8		b0 24		bcs $840e	                bcs errorReadingString
640	.83ea		0a		asl a		                asl a                       ;value*4
641	.83eb		b0 21		bcs $840e	                bcs errorReadingString
642	.83ed		65 e6		adc $e6		                adc $E6                     ;value*5
643	.83ef		b0 1d		bcs $840e	                bcs errorReadingString
644	.83f1		0a		asl a		                asl a                       ;value*10
645	.83f2		b0 1a		bcs $840e	                bcs errorReadingString
646	.83f4		85 e6		sta $e6		                sta $E6                      ;save value*10
647	.83f6		8a		txa		                txa                          ;A=digit
648	.83f7		65 e6		adc $e6		                adc $E6                      ;value*10+digit
649	.83f9		90 e2		bcc $83dd	                bcc parseDecimalDigit
650	.83fb						errorReadingString2:
651	.83fb		18		clc		                clc
652	.83fc		60		rts		                rts

654	.83fd						readNextDigitFromString:
655	.83fd		c8		iny		                iny

657							; check if current string input byte is a digit.
658							;
659							; exit: C=1 if digit; C=0 if not digit
660	.83fe						readDigitFromString:
661	.83fe		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
662	.8400		c9 3a		cmp #$3a	                cmp #'9'+1
663	.8402		b0 0a		bcs $840e	                bcs errorReadingString       ;taken if not ASCII decimal digit
664	.8404		c9 30		cmp #$30	                cmp #'0'
665	.8406		90 06		bcc $840e	                bcc errorReadingString       ;taken if not ASCII decimal digit
666	.8408		29 0f		and #$0f	                and #$0F         ;convert ASCII decimaldigit to number
667	.840a		60		rts		                rts

669	.840b						L8641:
670	.840b		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
671							                .if version!=350
673							                .endif
674	.840e						errorReadingString:
675	.840e		18		clc		                clc
676	.840f		60		rts		                rts

678							;-------------------------------------------------------------------------
679							;
680							; Read a hex digit from a string
681							;
682							; entry:
683							;
684							; (stringInputBufferAddress),y = next byte to read
685							;
686							; exit:
687							;
688							; C=1 if ok: A = digit read
689							;
690							; C=0 if error: A = value read, Z=1 if CR encountered
691							;
692	.8410						readHexDigit:
693	.8410		20 fe 83	jsr $83fe	                jsr readDigitFromString
694	.8413		b0 0d		bcs $8422	                bcs +                        ; branch taken if digit
695	.8415		29 df		and #$df	                and #$DF                     ; convert to upper case
696	.8417		c9 47		cmp #$47	                cmp #'F'+1
697	.8419		b0 f0		bcs $840b	                bcs L8641    ; branch taken if not ASCII A-F hex digit
698	.841b		c9 41		cmp #$41	                cmp #'A'
699	.841d		90 ec		bcc $840b	                bcc L8641     ;branch taken if not ASCII A-F hex digit
700							                ; convert ASCII A-F hex digit to number.
701	.841f		49 48		eor #$48	                eor #$48
702	.8421		1a		inc a		                inc a
703	.8422						+
704	.8422		c8		iny		                iny
705	.8423		60		rts		                rts

707							;-------------------------------------------------------------------------
708							;
709							; OSWORD 0 control block for *commands
710							; ====================================
711	.8424						commandLineUIOSWORD0Parameters:
712	>8424		00 dc				                .word hazel.commandLine      ; address
713	>8426		f0				                .byte $F0			; max # chars
714	>8427		20				                .byte $20			; min ASCII char
715	>8428		7e				                .byte $7E			; max ASCII char

717							;-------------------------------------------------------------------------

719	.8429						commandLineUI:
720	.8429		a9 55		lda #$55	                lda #<commandLineUIBRKHandler
721	.842b		8d 02 02	sta $0202	                sta BRKV+0
722	.842e		a9 84		lda #$84	                lda #>commandLineUIBRKHandler
723	.8430		8d 03 02	sta $0203	                sta BRKV+1
724	.8433		a9 1f		lda #$1f	                lda #$10|terminalROM         ;????
725	.8435		8d 8c 02	sta $028c	                sta currentLanguageROM
726	.8438						commandLineUILoop:
727	.8438		a2 ff		ldx #$ff	                ldx #$FF
728	.843a		9a		txs		                txs
729	.843b		58		cli		                cli
730	.843c		20 fa ec	jsr $ecfa	                jsr selectHAZEL
731	.843f		a9 2a		lda #$2a	                lda #'*'
732	.8441		20 ee ff	jsr $ffee	                jsr OSWRCH
733	.8444		20 65 84	jsr $8465	                jsr readCommandLine
734	.8447		90 03		bcc $844c	                bcc +                     ;taken if ESCAPE not pressed
735	.8449		4c d3 a8	jmp $a8d3	                jmp escapeError
736	.844c						+
737	.844c		a2 00		ldx #$00	                ldx #<hazel.commandLine
738	.844e		a0 dc		ldy #$dc	                ldy #>hazel.commandLine
739	.8450		20 f7 ff	jsr $fff7	                jsr OSCLI
740	.8453		80 e3		bra $8438	                bra commandLineUILoop

742	.8455						commandLineUIBRKHandler:
743	.8455		20 e7 ff	jsr $ffe7	                jsr OSNEWL
744	.8458		a0 00		ldy #$00	                ldy #$00
745	.845a		20 73 e7	jsr $e773	                jsr printBRKMessage
746	.845d		20 e7 ff	jsr $ffe7	                jsr OSNEWL
747	.8460		80 c7		bra $8429	                bra commandLineUI

749	.8462						badCommandError869A:
750	.8462		4c 29 f9	jmp $f929	                jmp badCommandError

752	.8465						readCommandLine:
753	.8465		a9 00		lda #$00	                lda #$00
754	.8467		a2 24		ldx #$24	                ldx #<commandLineUIOSWORD0Parameters
755	.8469		a0 84		ldy #$84	                ldy #>commandLineUIOSWORD0Parameters
756	.846b		4c f1 ff	jmp $fff1	                jmp OSWORD

758							;-------------------------------------------------------------------------
759							;
760							; *ROMS [MasRef C.5-10]
761							;
762	.846e						starROMS:
763	.846e		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
764	.8471		d0 ef		bne $8462	                bne badCommandError869A
765	.8473		a0 0f		ldy #$0f	                ldy #$0F
766	.8475						printROMsLoop:
767							                .if version<400&&version!=350
774							                .else
775	.8475		98		tya		                tya
776	.8476		aa		tax		                tax
777	.8477		5a		phy		                phy
778	.8478		20 c7 f9	jsr $f9c7	                jsr isBankROM
779	.847b		b0 0a		bcs $8487	                bcs L86D2
780	.847d		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
781	>8480		52 4f 4d 20 00			                .text "ROM ",0
782	.8485		80 08		bra $848f	                bra L86DA
783	.8487						L86D2:
784	.8487		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
785	>848a		52 41 4d 20 00			                .text "RAM ",0
786	.848f						L86DA:
787	.848f		7a		ply		                ply
788	.8490		98		tya		                tya
789							                .endif
790	.8491		20 b5 a8	jsr $a8b5	                jsr printHexDigit            ;print ROM slot
791	.8494		20 28 9f	jsr $9f28	                jsr printSpace
792	.8497		a9 09		lda #$09	                lda #<sidewaysROMName
793	.8499		85 f6		sta $f6		                sta $F6
794	.849b		a9 80		lda #$80	                lda #>sidewaysROMName
795	.849d		85 f7		sta $f7		                sta $F7
796							                .if version<400&&version!=350
798							                .endif
799	.849f		20 51 e5	jsr $e551	                jsr isROMValidThenSelectTerminalROM
800							                .if version<400&&version!=350
802							                .endif
803	.84a2		90 49		bcc $84ed	                bcc invalidROM
804							                .if version>=500||version==350
805	.84a4		b9 a1 02	lda $02a1,y	                lda romInformationTable,y
806	.84a7		3a		dec a		                dec a
807	.84a8		f0 43		beq $84ed	                beq invalidROM
808							                .endif
809	.84aa						printROMNameLoop:
810	.84aa		20 a9 f3	jsr $f3a9	                jsr osrdscEntryPoint     ;read name byte
811	.84ad		c9 20		cmp #$20	                cmp #' '
812	.84af		90 0f		bcc $84c0	                bcc printROMVersion ;taken if non-printable char, including the terminating 0
813	.84b1		c9 7f		cmp #$7f	                cmp #127
814	.84b3		b0 38		bcs $84ed	                bcs invalidROM  ;taken if bad (bit 7 set) char in name
815	.84b5		20 ee ff	jsr $ffee	                jsr OSWRCH
816	.84b8		e6 f6		inc $f6		                inc $F6
817	.84ba		24 f6		bit $f6		                bit $F6
818	.84bc		50 ec		bvc $84aa	                bvc printROMNameLoop         ;taken if address<$8040
819	.84be		80 2d		bra $84ed	                bra invalidROM               ;taken if name too long

821	.84c0						printROMVersion:
822	.84c0		aa		tax		                tax               ;Z=1 if final char was the expected 0
823	.84c1		d0 2a		bne $84ed	                bne invalidROM    ;taken if bad (control) char in name
824	.84c3		a9 08		lda #$08	                lda #<sidewaysROMVersion
825	.84c5		85 f6		sta $f6		                sta $F6
826	.84c7		a9 80		lda #$80	                lda #>sidewaysROMVersion
827	.84c9		85 f7		sta $f7		                sta $F7
828	.84cb		20 a9 f3	jsr $f3a9	                jsr osrdscEntryPoint
829	.84ce		20 a8 a8	jsr $a8a8	                jsr printSpaceThenPrintHexByte
830	.84d1						printInsertionStatus:
831	.84d1		5a		phy		                phy
832							                .if version<500&&version!=350
837							                .else
838	.84d2		20 f4 84	jsr $84f4	                jsr L873F
839							                .endif
840	.84d5		d0 0e		bne $84e5	                bne +
841	.84d7		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
842	>84da		20 75 6e 70 6c 75 67 67		                .text " unplugged",0
	>84e2		65 64 00
843	.84e5						+
844	.84e5		7a		ply		                ply
845	.84e6		20 e7 ff	jsr $ffe7	                jsr OSNEWL
846	.84e9		88		dey		                dey
847	.84ea		10 89		bpl $8475	                bpl printROMsLoop
848	.84ec		60		rts		                rts

850	.84ed						invalidROM:
851	.84ed		a9 3f		lda #$3f	                lda #'?'
852	.84ef		20 ee ff	jsr $ffee	                jsr OSWRCH
853	.84f2		80 dd		bra $84d1	                bra printInsertionStatus

855							;-------------------------------------------------------------------------

857							                .if useTableDrivenConfigure
858	.84f4						L873F:
859	.84f4		20 7f e9	jsr $e97f	                jsr getROMInsertedFlagRTCAddressAndMask
860	.84f7		85 b0		sta $b0		                sta $b0
861	.84f9		20 a3 96	jsr $96a3	                jsr readRTCByte
862	.84fc		25 b0		and $b0		                and $b0
863	.84fe		60		rts		                rts
864							                .endif

866							;-------------------------------------------------------------------------
867							;
868							; *INSERT [MasRef C.5-8]
869							;
870	.84ff						starINSERT:
871	.84ff		38		sec		                sec
872	.8500		80 01		bra $8503	                bra starINSERTOrStarUNPLUG

874							;-------------------------------------------------------------------------
875							;
876							; *UNPLUG [MasRef C.5-13]
877							;
878	.8502						starUNPLUG:
879	.8502		18		clc		                clc
880	.8503						starINSERTOrStarUNPLUG:
881	.8503		08		php		                php
882	.8504		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
883							                .if useTableDrivenConfigure
884	.8507		20 20 87	jsr $8720	                jsr L8953
887							                .endif
888	.850a		a8		tay		                tay                          ;Y=ROM number
889	.850b		20 7f e9	jsr $e97f	                jsr getROMInsertedFlagRTCAddressAndMask
890	.850e		48		pha		                pha
891	.850f		20 a3 96	jsr $96a3	                jsr readRTCByte
892	.8512		84 b0		sty $b0		                sty starROMSWorkspace.insertedFlagMask
893	.8514		68		pla		                pla
894	.8515		28		plp		                plp
895	.8516		90 04		bcc $851c	                bcc unplug                   ;taken if it's *UNPLUG

897							                ; it's *INSERT
898	.8518		05 b0		ora $b0		                ora starROMSWorkspace.insertedFlagMask
899	.851a		80 04		bra $8520	                bra +
900	.851c						unplug:
901	.851c		49 ff		eor #$ff	                eor #$FF
902	.851e		25 b0		and $b0		                and starROMSWorkspace.insertedFlagMask
903	.8520						+
904	.8520		a8		tay		                tay
905	.8521		4c d0 96	jmp $96d0	                jmp writeRTCByte

907							;-------------------------------------------------------------------------
908							;
909							; *TIME [MasRef C.5-12]
910							;
911	.8524						starTIME:
912	.8524		9c 00 dc	stz $dc00	                stz hazel.commandLine
913	.8527		a2 00		ldx #$00	                ldx #<hazel.commandLine
914	.8529		a0 dc		ldy #$dc	                ldy #>hazel.commandLine
915	.852b		a9 0e		lda #$0e	                lda #$0E
916	.852d		20 f1 ff	jsr $fff1	                jsr OSWORD
917	.8530		a2 e7		ldx #$e7	                ldx #256-size(ClockStringFormat)
918	.8532						L8752:
919	.8532		bd 19 db	lda $db19,x	                lda hazel.commandLine-(256-size(ClockStringFormat)),x
920	.8535		20 e3 ff	jsr $ffe3	                jsr OSASCI
921	.8538		e8		inx		                inx
922	.8539		d0 f7		bne $8532	                bne L8752
923	.853b		60		rts		                rts

925							;-------------------------------------------------------------------------

927							                .if version==350
928							                .include "configure_table_driven.s65"

:8	;******  Processing file: src/configure_table_driven.s65

1							byte2: .macro value,value350
7							                .endmacro

9							                ; Metadata layout

11							                ; +0

13							                ;   7   6   5   4   3   2   1   0
14							                ; +---+---+---+---+---+---+---+---+
15							                ; |X  |V0 |MaskCount  |Value      |
16							                ; +---+---+---+---+---+---+---+---+

18							                ; X is unused - it's generally set in the configure
19							                ; table, so that the names can be terminated by a byte
20							                ; with bit 7 set.
21							                ;
22							                ; If V0 is clear, this field is actually the address
23							                ; of a routine.
24							                ;
25							                ; Value is the value for the bitfield when this option
26							                ; is in effect.
27							                ;
28							                ; MaskCount
29							                ;

31							                ; +1

33							                ;   7   6   5   4   3   2   1   0
34							                ; +---+---+---+---+---+---+---+---+
35							                ; |N1 |RTCByteIndex   |ShiftCount |
36							                ; +---+---+---+---+---+---+---+---+
37							                ;
38							                ; N1 = tested by L8ADF

40							                ; The RTC byte indexes in the table are actually
41							                ; offset.
42							                .if version==350
43	=15						rtcByteIndexOffset=cmosBytesOffset+CMOSBytes.fileServerStationNumber
46							                .endif

48							itemWithAddress: .macro name,addr
53							                .endmacro

55							countLS0s: .function value
75							                .endfunction n

77							itemMaskInfo: .macro value
83							                .endmacro

85							itemMetadata: .macro topMask,rtcByteIndex,mask,matchValue,n1
96							                .endmacro

98							itemWithMetadata: .macro name,rtcByteIndex,mask,matchValue,n1
102							                .endmacro

104	.853c						configureTable: .block
49	>853c		2e				                .text "."
50	.853d						metadata:
51							                .cerror (printConfigureOrStatusHeader&$c000)!=$8000
125:3	>853d		87				                .byte >printConfigureOrStatusHeader-1
126	>853e		89				                .byte <printConfigureOrStatusHeader-1
106:8	.853f						baud:
99	>853f		42 61 75 64			                .text ("Baud")
100	.8543						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults2))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults2))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults2.serialBaudRateIndexMask<<CMOSBytes.defaults2.serialBaudRateIndexShift))<0||((CMOSBytes.defaults2.serialBaudRateIndexMask<<CMOSBytes.defaults2.serialBaudRateIndexShift))>256,format("Bad mask: $%02x",(CMOSBytes.defaults2.serialBaudRateIndexMask<<CMOSBytes.defaults2.serialBaudRateIndexShift))

92	.8543						info:
78	=2						shift=countLS0s(((CMOSBytes.defaults2.serialBaudRateIndexMask<<CMOSBytes.defaults2.serialBaudRateIndexShift)))
79	=7						unshiftedMask=(((CMOSBytes.defaults2.serialBaudRateIndexMask<<CMOSBytes.defaults2.serialBaudRateIndexShift)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults2.serialBaudRateIndexMask<<CMOSBytes.defaults2.serialBaudRateIndexShift)),shift,unshiftedMask)
81	=3						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults2.serialBaudRateIndexMask<<CMOSBytes.defaults2.serialBaudRateIndexShift)))

94	>8543		d0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>8544		f2				                .byte (((true))?$80:$00)|(((CMOSBytes.defaults2)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
107	.8545						boot:
99	>8545		42 6f 6f 74			                .text ("Boot")
100	.8549						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults3))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults3))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((1))>=0&&((1))<8)
90							                .cerror ((CMOSBytes.defaults3.autoBootMask))<0||((CMOSBytes.defaults3.autoBootMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults3.autoBootMask))

92	.8549						info:
78	=4						shift=countLS0s(((CMOSBytes.defaults3.autoBootMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults3.autoBootMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults3.autoBootMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults3.autoBootMask)))

94	>8549		c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
95	>854a		7c				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
99	>854b		43 61 70 73			                .text ("Caps")
100	.854f						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults1))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults1))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((4))>=0&&((4))<8)
90							                .cerror (((CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask)))<0||(((CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask)))>256,format("Bad mask: $%02x",((CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask)))

92	.854f						info:
78	=3						shift=countLS0s((((CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask))))
79	=7						unshiftedMask=((((CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask))))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",(((CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask))),shift,unshiftedMask)
81	=3						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",(((CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask))))

94	>854f		d4				                .byte ($c0)|((info.maskWidth-1)<<3)|((4))
95	>8550		53				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
109							                .if olivetti
111							                .endif
112	.8551						data:
99	>8551		44 61 74 61			                .text ("Data")
100	.8555						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults3))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults3))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults3.serialDataFormatMask<<CMOSBytes.defaults3.serialDataFormatShift))<0||((CMOSBytes.defaults3.serialDataFormatMask<<CMOSBytes.defaults3.serialDataFormatShift))>256,format("Bad mask: $%02x",(CMOSBytes.defaults3.serialDataFormatMask<<CMOSBytes.defaults3.serialDataFormatShift))

92	.8555						info:
78	=5						shift=countLS0s(((CMOSBytes.defaults3.serialDataFormatMask<<CMOSBytes.defaults3.serialDataFormatShift)))
79	=7						unshiftedMask=(((CMOSBytes.defaults3.serialDataFormatMask<<CMOSBytes.defaults3.serialDataFormatShift)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults3.serialDataFormatMask<<CMOSBytes.defaults3.serialDataFormatShift)),shift,unshiftedMask)
81	=3						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults3.serialDataFormatMask<<CMOSBytes.defaults3.serialDataFormatShift)))

94	>8555		d0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>8556		fd				                .byte (((true))?$80:$00)|(((CMOSBytes.defaults3)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
99	>8557		44 65 6c 61 79			                .text ("Delay")
100	.855c						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.keyboardAutoRepeatDelay))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.keyboardAutoRepeatDelay))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror (($ff))<0||(($ff))>256,format("Bad mask: $%02x",($ff))

92	.855c						info:
78	=0						shift=countLS0s((($ff)))
79	=$ff						unshiftedMask=((($ff)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",(($ff)),shift,unshiftedMask)
81	=8						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",(($ff)))

94	>855c		f8				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>855d		d8				                .byte (((true))?$80:$00)|(((CMOSBytes.keyboardAutoRepeatDelay)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
114	.855e						dir:
99	>855e		44 69 72			                .text ("Dir")
100	.8561						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults1))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults1))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults1.adfsLoadDirMask))<0||((CMOSBytes.defaults1.adfsLoadDirMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults1.adfsLoadDirMask))

92	.8561						info:
78	=6						shift=countLS0s(((CMOSBytes.defaults1.adfsLoadDirMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults1.adfsLoadDirMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults1.adfsLoadDirMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults1.adfsLoadDirMask)))

94	>8561		c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>8562		56				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
115	=$8560						lastDirChar=dir.metadata-1
116							                .if includeTubeSupport
117	.8563						extube:
99	>8563		45 78 54 75 62 65		                .text ("ExTube")
100	.8569						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults3))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults3))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((1))>=0&&((1))<8)
90							                .cerror ((CMOSBytes.defaults3.extTubeMask))<0||((CMOSBytes.defaults3.extTubeMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults3.extTubeMask))

92	.8569						info:
78	=2						shift=countLS0s(((CMOSBytes.defaults3.extTubeMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults3.extTubeMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults3.extTubeMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults3.extTubeMask)))

94	>8569		c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
95	>856a		7a				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
118	=$8564						lastExChar=extube+1
119							                .endif
99	>856b		46 64 72 69 76 65		                .text ("Fdrive")
100	.8571						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults1))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults1))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults1.fdriveMask))<0||((CMOSBytes.defaults1.fdriveMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults1.fdriveMask))

92	.8571						info:
78	=0						shift=countLS0s(((CMOSBytes.defaults1.fdriveMask)))
79	=7						unshiftedMask=(((CMOSBytes.defaults1.fdriveMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults1.fdriveMask)),shift,unshiftedMask)
81	=3						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults1.fdriveMask)))

94	>8571		d0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>8572		d0				                .byte (((true))?$80:$00)|(((CMOSBytes.defaults1)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
121	.8573						file:
99	>8573		46 69 6c 65			                .text ("File")
100	.8577						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaultROMs))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaultROMs))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror (($f<<CMOSBytes.defaultROMs.fsShift))<0||(($f<<CMOSBytes.defaultROMs.fsShift))>256,format("Bad mask: $%02x",($f<<CMOSBytes.defaultROMs.fsShift))

92	.8577						info:
78	=0						shift=countLS0s((($f<<CMOSBytes.defaultROMs.fsShift)))
79	=$f						unshiftedMask=((($f<<CMOSBytes.defaultROMs.fsShift)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",(($f<<CMOSBytes.defaultROMs.fsShift)),shift,unshiftedMask)
81	=4						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",(($f<<CMOSBytes.defaultROMs.fsShift)))

94	>8577		d8				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>8578		a0				                .byte (((true))?$80:$00)|(((CMOSBytes.defaultROMs)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
122							                .if version==350
99	>8579		46 6c 6f 70 70 79		                .text ("Floppy")
100	.857f						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults1))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults1))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((1))>=0&&((1))<8)
90							                .cerror ((CMOSBytes.defaults1.floppyDrive))<0||((CMOSBytes.defaults1.floppyDrive))>256,format("Bad mask: $%02x",(CMOSBytes.defaults1.floppyDrive))

92	.857f						info:
78	=7						shift=countLS0s(((CMOSBytes.defaults1.floppyDrive)))
79	=1						unshiftedMask=(((CMOSBytes.defaults1.floppyDrive)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults1.floppyDrive)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults1.floppyDrive)))

94	>857f		c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
95	>8580		57				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
124							                .endif
125							                .if version==350
99	>8581		48 61 72 64			                .text ("Hard")
100	.8585						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults1))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults1))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults1.floppyDrive))<0||((CMOSBytes.defaults1.floppyDrive))>256,format("Bad mask: $%02x",(CMOSBytes.defaults1.floppyDrive))

92	.8585						info:
78	=7						shift=countLS0s(((CMOSBytes.defaults1.floppyDrive)))
79	=1						unshiftedMask=(((CMOSBytes.defaults1.floppyDrive)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults1.floppyDrive)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults1.floppyDrive)))

94	>8585		c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>8586		57				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
127							                .endif
128	.8587						ignore:
49	>8587		49 67 6e 6f 72 65		                .text "Ignore"
50	.858d						metadata:
51							                .cerror (handlePrinterIgnoreChar&$c000)!=$8000
125:3	>858d		86				                .byte >handlePrinterIgnoreChar-1
126	>858e		df				                .byte <handlePrinterIgnoreChar-1
129:8							                .if includeTubeSupport
130	.858f						intube:
99	>858f		49 6e 54 75 62 65		                .text ("InTube")
100	.8595						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults3))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults3))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults3.extTubeMask))<0||((CMOSBytes.defaults3.extTubeMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults3.extTubeMask))

92	.8595						info:
78	=2						shift=countLS0s(((CMOSBytes.defaults3.extTubeMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults3.extTubeMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults3.extTubeMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults3.extTubeMask)))

94	>8595		c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>8596		7a				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
131	=$8590						lastInChar=intube+1
132							                .endif
133	.8597						lang:
99	>8597		4c 61 6e 67			                .text ("Lang")
100	.859b						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaultROMs))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaultROMs))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror (($f<<CMOSBytes.defaultROMs.languageShift))<0||(($f<<CMOSBytes.defaultROMs.languageShift))>256,format("Bad mask: $%02x",($f<<CMOSBytes.defaultROMs.languageShift))

92	.859b						info:
78	=4						shift=countLS0s((($f<<CMOSBytes.defaultROMs.languageShift)))
79	=$f						unshiftedMask=((($f<<CMOSBytes.defaultROMs.languageShift)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",(($f<<CMOSBytes.defaultROMs.languageShift)),shift,unshiftedMask)
81	=4						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",(($f<<CMOSBytes.defaultROMs.languageShift)))

94	>859b		d8				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>859c		a4				                .byte (((true))?$80:$00)|(((CMOSBytes.defaultROMs)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
99	>859d		4c 6f 75 64			                .text ("Loud")
100	.85a1						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults3))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults3))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((1))>=0&&((1))<8)
90							                .cerror ((CMOSBytes.defaults3.loudMask))<0||((CMOSBytes.defaults3.loudMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults3.loudMask))

92	.85a1						info:
78	=1						shift=countLS0s(((CMOSBytes.defaults3.loudMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults3.loudMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults3.loudMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults3.loudMask)))

94	>85a1		c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
95	>85a2		79				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
135	.85a3						mode:
99	>85a3		4d 6f 64 65			                .text ("Mode")
100	.85a7						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults0))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults0))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults0.modeMask|CMOSBytes.defaults0.shadowMask))<0||((CMOSBytes.defaults0.modeMask|CMOSBytes.defaults0.shadowMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults0.modeMask|CMOSBytes.defaults0.shadowMask))

92	.85a7						info:
78	=0						shift=countLS0s(((CMOSBytes.defaults0.modeMask|CMOSBytes.defaults0.shadowMask)))
79	=15						unshiftedMask=(((CMOSBytes.defaults0.modeMask|CMOSBytes.defaults0.shadowMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults0.modeMask|CMOSBytes.defaults0.shadowMask)),shift,unshiftedMask)
81	=4						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults0.modeMask|CMOSBytes.defaults0.shadowMask)))

94	>85a7		d8				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>85a8		c8				                .byte (((true))?$80:$00)|(((CMOSBytes.defaults0)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
99	>85a9		4e 6f 42 6f 6f 74		                .text ("NoBoot")
100	.85af						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults3))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults3))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults3.autoBootMask))<0||((CMOSBytes.defaults3.autoBootMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults3.autoBootMask))

92	.85af						info:
78	=4						shift=countLS0s(((CMOSBytes.defaults3.autoBootMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults3.autoBootMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults3.autoBootMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults3.autoBootMask)))

94	>85af		c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>85b0		7c				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
99	>85b1		4e 6f 43 61 70 73		                .text ("NoCaps")
100	.85b7						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults1))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults1))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((2))>=0&&((2))<8)
90							                .cerror ((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask))<0||((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask))

92	.85b7						info:
78	=3						shift=countLS0s(((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)))
79	=7						unshiftedMask=(((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)),shift,unshiftedMask)
81	=3						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)))

94	>85b7		d2				                .byte ($c0)|((info.maskWidth-1)<<3)|((2))
95	>85b8		53				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
138	.85b9						noDir:
99	>85b9		4e 6f 44 69 72			                .text ("NoDir")
100	.85be						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults1))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults1))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((1))>=0&&((1))<8)
90							                .cerror ((CMOSBytes.defaults1.adfsLoadDirMask))<0||((CMOSBytes.defaults1.adfsLoadDirMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults1.adfsLoadDirMask))

92	.85be						info:
78	=6						shift=countLS0s(((CMOSBytes.defaults1.adfsLoadDirMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults1.adfsLoadDirMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults1.adfsLoadDirMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults1.adfsLoadDirMask)))

94	>85be		c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
95	>85bf		56				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
139	=$85bd						lastNoDirChar:=noDir.metadata-1
99	>85c0		4e 6f 53 63 72 6f 6c 6c		                .text ("NoScroll")
100	.85c8						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults3))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults3))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((1))>=0&&((1))<8)
90							                .cerror ((CMOSBytes.defaults3.protectedScrollingMask))<0||((CMOSBytes.defaults3.protectedScrollingMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults3.protectedScrollingMask))

92	.85c8						info:
78	=3						shift=countLS0s(((CMOSBytes.defaults3.protectedScrollingMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults3.protectedScrollingMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults3.protectedScrollingMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults3.protectedScrollingMask)))

94	>85c8		c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
95	>85c9		7b				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
141							                .if includeTubeSupport
99	>85ca		4e 6f 54 75 62 65		                .text ("NoTube")
100	.85d0						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults2))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults2))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults2.tubeOnMask))<0||((CMOSBytes.defaults2.tubeOnMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults2.tubeOnMask))

92	.85d0						info:
78	=0						shift=countLS0s(((CMOSBytes.defaults2.tubeOnMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults2.tubeOnMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults2.tubeOnMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults2.tubeOnMask)))

94	>85d0		c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>85d1		70				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults2)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
143							                .endif
144	.85d2						print:
99	>85d2		50 72 69 6e 74			                .text ("Print")
100	.85d7						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults2))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults2))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults2.fx5SettingMask<<CMOSBytes.defaults2.fx5SettingShift))<0||((CMOSBytes.defaults2.fx5SettingMask<<CMOSBytes.defaults2.fx5SettingShift))>256,format("Bad mask: $%02x",(CMOSBytes.defaults2.fx5SettingMask<<CMOSBytes.defaults2.fx5SettingShift))

92	.85d7						info:
78	=5						shift=countLS0s(((CMOSBytes.defaults2.fx5SettingMask<<CMOSBytes.defaults2.fx5SettingShift)))
79	=7						unshiftedMask=(((CMOSBytes.defaults2.fx5SettingMask<<CMOSBytes.defaults2.fx5SettingShift)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults2.fx5SettingMask<<CMOSBytes.defaults2.fx5SettingShift)),shift,unshiftedMask)
81	=3						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults2.fx5SettingMask<<CMOSBytes.defaults2.fx5SettingShift)))

94	>85d7		d0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>85d8		f5				                .byte (((true))?$80:$00)|(((CMOSBytes.defaults2)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
99	>85d9		51 75 69 65 74			                .text ("Quiet")
100	.85de						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults3))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults3))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults3.loudMask))<0||((CMOSBytes.defaults3.loudMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults3.loudMask))

92	.85de						info:
78	=1						shift=countLS0s(((CMOSBytes.defaults3.loudMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults3.loudMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults3.loudMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults3.loudMask)))

94	>85de		c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>85df		79				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
99	>85e0		52 65 70 65 61 74		                .text ("Repeat")
100	.85e6						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.keyboardAutoRepeatRate))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.keyboardAutoRepeatRate))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror (($ff))<0||(($ff))>256,format("Bad mask: $%02x",($ff))

92	.85e6						info:
78	=0						shift=countLS0s((($ff)))
79	=$ff						unshiftedMask=((($ff)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",(($ff)),shift,unshiftedMask)
81	=8						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",(($ff)))

94	>85e6		f8				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>85e7		e0				                .byte (((true))?$80:$00)|(((CMOSBytes.keyboardAutoRepeatRate)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
99	>85e8		53 63 72 6f 6c 6c		                .text ("Scroll")
100	.85ee						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults3))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults3))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((0))>=0&&((0))<8)
90							                .cerror ((CMOSBytes.defaults3.protectedScrollingMask))<0||((CMOSBytes.defaults3.protectedScrollingMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults3.protectedScrollingMask))

92	.85ee						info:
78	=3						shift=countLS0s(((CMOSBytes.defaults3.protectedScrollingMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults3.protectedScrollingMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults3.protectedScrollingMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults3.protectedScrollingMask)))

94	>85ee		c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
95	>85ef		7b				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
148	.85f0						shCaps:
99	>85f0		53 68 43 61 70 73		                .text ("ShCaps")
100	.85f6						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults1))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults1))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((1))>=0&&((1))<8)
90							                .cerror ((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask))<0||((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask))

92	.85f6						info:
78	=3						shift=countLS0s(((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)))
79	=7						unshiftedMask=(((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)),shift,unshiftedMask)
81	=3						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)))

94	>85f6		d1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
95	>85f7		53				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
149	=$85f1						lastShChar=shCaps+1
150							                .if includeTubeSupport
99	>85f8		54 75 62 65			                .text ("Tube")
100	.85fc						metadata:
86							                ; constants need some rationalisation here...
87							                .cerror ((CMOSBytes.defaults2))<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror ((CMOSBytes.defaults2))>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !(((1))>=0&&((1))<8)
90							                .cerror ((CMOSBytes.defaults2.tubeOnMask))<0||((CMOSBytes.defaults2.tubeOnMask))>256,format("Bad mask: $%02x",(CMOSBytes.defaults2.tubeOnMask))

92	.85fc						info:
78	=0						shift=countLS0s(((CMOSBytes.defaults2.tubeOnMask)))
79	=1						unshiftedMask=(((CMOSBytes.defaults2.tubeOnMask)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",((CMOSBytes.defaults2.tubeOnMask)),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",((CMOSBytes.defaults2.tubeOnMask)))

94	>85fc		c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
95	>85fd		70				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults2)-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
152							                .endif
153							                .if version>=500
155							                .endif
156							                .if version>=500
158							                .endif
159							                .if version>=500
161							                .endif
49	>85fe		54 56				                .text "TV"
50	.8600						metadata:
51							                .cerror (handleTV&$c000)!=$8000
125:3	>8600		87				                .byte >handleTV-1
126	>8601		31				                .byte <handleTV-1
163:8	>8602		00				                .byte 0
164	.8603						L8603:
165							                .if version==350
86							                ; constants need some rationalisation here...
87							                .cerror (CMOSBytes.defaults2)<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror (CMOSBytes.defaults2)>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !((0)>=0&&(0)<8)
90							                .cerror (CMOSBytes.defaults2.usePrinterIgnoreCharMask)<0||(CMOSBytes.defaults2.usePrinterIgnoreCharMask)>256,format("Bad mask: $%02x",CMOSBytes.defaults2.usePrinterIgnoreCharMask)

92	.8603						info:
78	=1						shift=countLS0s((CMOSBytes.defaults2.usePrinterIgnoreCharMask))
79	=1						unshiftedMask=((CMOSBytes.defaults2.usePrinterIgnoreCharMask))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",(CMOSBytes.defaults2.usePrinterIgnoreCharMask),shift,unshiftedMask)
81	=1						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",(CMOSBytes.defaults2.usePrinterIgnoreCharMask))

94	>8603		00				                .byte ($00)|((info.maskWidth-1)<<3)|(0)
95	>8604		71				                .byte ((false)?$80:$00)|((CMOSBytes.defaults2-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
170							                .endif
171	.8605						L8605:
86							                ; constants need some rationalisation here...
87							                .cerror (CMOSBytes.defaults0)<(rtcByteIndexOffset)-cmosBytesOffset
88							                .cerror (CMOSBytes.defaults0)>=(rtcByteIndexOffset)+16-cmosBytesOffset
89							                .cerror !((0)>=0&&(0)<8)
90							                .cerror (CMOSBytes.defaults0.interlaceMask|(CMOSBytes.defaults0.tvMask<<CMOSBytes.defaults0.tvShift))<0||(CMOSBytes.defaults0.interlaceMask|(CMOSBytes.defaults0.tvMask<<CMOSBytes.defaults0.tvShift))>256,format("Bad mask: $%02x",CMOSBytes.defaults0.interlaceMask|(CMOSBytes.defaults0.tvMask<<CMOSBytes.defaults0.tvShift))

92	.8605						info:
78	=4						shift=countLS0s((CMOSBytes.defaults0.interlaceMask|(CMOSBytes.defaults0.tvMask<<CMOSBytes.defaults0.tvShift)))
79	=15						unshiftedMask=((CMOSBytes.defaults0.interlaceMask|(CMOSBytes.defaults0.tvMask<<CMOSBytes.defaults0.tvShift)))>>shift
80							                .cerror (unshiftedMask&(unshiftedMask+1))!=0,format("bad mask: $%02x (shift: %d; unshifted: $%02x)",(CMOSBytes.defaults0.interlaceMask|(CMOSBytes.defaults0.tvMask<<CMOSBytes.defaults0.tvShift)),shift,unshiftedMask)
81	=4						maskWidth=countLS0s(~unshiftedMask)
82							                .cerror !(maskWidth>=1&&maskWidth<=8),format("bad mask: $%02x",(CMOSBytes.defaults0.interlaceMask|(CMOSBytes.defaults0.tvMask<<CMOSBytes.defaults0.tvShift)))

94	>8605		18				                .byte ($00)|((info.maskWidth-1)<<3)|(0)
95	>8606		4c				                .byte ((false)?$80:$00)|((CMOSBytes.defaults0-(rtcByteIndexOffset-cmosBytesOffset))<<3)|info.shift
173	.8607						ectory:
174	>8607		65 63 74 6f 72 79 ff		                .text "ectory",$ff
175							                .if includeTubeSupport
176	.860e						ternal:
177	>860e		74 65 72 6e 61 6c ff		                .text "ternal",$ff
178							                .endif
179	.8615						ift:
180	>8615		69 66 74 ff			                .text "ift",$ff

182	.8619						textSnippetInsertPointOffsets:
183	>8619		24				                .text lastDirChar-configureTable   ;"Directory"
184	>861a		81				                .byte lastNoDirChar-configureTable ;"NoDirectory"
185							                .if includeTubeSupport
186	>861b		28				                .byte lastExChar-configureTable    ;"External"
187	>861c		54				                .byte lastInChar-configureTable    ;"Internal"
188							                .endif
189	>861d		b5				                .byte lastShChar-configureTable    ;"Shift"
190	=5						textSnippetsCount=*-textSnippetInsertPointOffsets

192	.861e						textSnippetOffsets:
193	>861e		cb				                .byte configureTable.ectory-configureTable
194	>861f		cb				                .byte configureTable.ectory-configureTable
195							                .if includeTubeSupport
196	>8620		d2				                .byte configureTable.ternal-configureTable
197	>8621		d2				                .byte configureTable.ternal-configureTable
198							                .endif
199	>8622		d9				                .byte configureTable.ift-configureTable
200							                .cerror *-textSnippetOffsets!=textSnippetsCount

202							                .endblock

204							;-------------------------------------------------------------------------

206	.8623						starCONFIGUREOrStarSTATUS:
207	.8623		0a		asl a		                asl a
208	.8624		69 80		adc #$80	                adc #$80

210							                ; *STATUS: A=1 V=1 C=1
211							                ; *CONFIGURE: A=0 V=0 C=1
212	.8626		08		php		                php
213	.8627		a9 3c		lda #$3c	                lda #<configureTable
214	.8629		85 b0		sta $b0		                sta oscliWorkspace.tablePtr+0
215	.862b		a9 85		lda #$85	                lda #>configureTable
216	.862d		85 b1		sta $b1		                sta oscliWorkspace.tablePtr+1
217	.862f		a2 ff		ldx #$ff	                ldx #$FF
218	.8631		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
219	.8634		d0 03		bne $8639	                bne L886C
220	.8636		20 9e 88	jsr $889e	                jsr fetchCommandTableByte

222	.8639						L886C:
223	.8639		2c 5e e3	bit $e35e	                bit valueFF ; V=1 to indicate 2-byte metadata
224	.863c		20 5f 88	jsr $885f	                jsr findCommand
225	.863f		b0 07		bcs $8648	                bcs foundCONFIGOrSTATUSTopic
226	.8641		28		plp		                plp
227	.8642		20 41 89	jsr $8941	                jsr unknownCONFIGOrStatus
228	.8645		d0 71		bne $86b8	                bne jmpBadCommandError8B68
229	.8647		60		rts		                rts

231							;-------------------------------------------------------------------------

233	.8648						foundCONFIGOrSTATUSTopic:
234	.8648		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
235	.864b		28		plp		                plp
236	.864c		50 03		bvc $8651	                bvc L8884
237	.864e		20 2a 87	jsr $872a	                jsr L895D

239							;-------------------------------------------------------------------------

241	.8651						L8884:
242	.8651		bd 3c 85	lda $853c,x	                lda configureTable,x
243	.8654		89 40		bit #$40	                bit #$40
244	.8656		d0 0a		bne $8662	                bne L8895       ;taken if V0 clear
245	.8658		48		pha		                pha
246	.8659		bd 3d 85	lda $853d,x	                lda configureTable+1,x
247	.865c		48		pha		                pha
248	.865d		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
249	.865f		49 0d		eor #$0d	                eor #$D         ;A=0 Z=1 if command line tail is empty
250	.8661		60		rts		                rts             ;call routine, in effect

252							;-------------------------------------------------------------------------

254	.8662						L8895:
255	.8662		29 07		and #$07	                and #7
256							                .if version==350
257	.8664		de 3d 85	dec $853d,x	                dec configureTable+1,x
260							                .endif
261	.8667		70 3d		bvs $86a6	                bvs L88D9
262	.8669		b0 30		bcs $869b	                bcs print1NumberHelp
263	.866b		30 05		bmi $8672	                bmi L88A5
264	.866d		20 2a 87	jsr $872a	                jsr L895D
265	.8670		80 26		bra $8698	                bra jmpL88EE

267							;-------------------------------------------------------------------------

269	.8672						L88A5:
270	.8672		da		phx		                phx
271	.8673		20 82 87	jsr $8782	                jsr L89B5
272	.8676		fa		plx		                plx
273	.8677		e0 07		cpx #$07	                cpx #7
274	.8679		d0 06		bne $8681	                bne L88B4
275	.867b		a8		tay		                tay
276	.867c		d0 02		bne $8680	                bne L88B3
277	.867e		a9 07		lda #$07	                lda #7

279	.8680						L88B3:
280	.8680		3a		dec a		                dec a

282	.8681						L88B4:
283	.8681		e0 6b		cpx #$6b	                cpx #configureTable.mode.metadata-configureTable
284	.8683		d0 09		bne $868e	                bne L88C1
285	.8685		89 78		bit #$78	                bit #$78
286	.8687		d0 2f		bne $86b8	                bne jmpBadCommandError8B68
287	.8689		a8		tay		                tay
288	.868a		10 02		bpl $868e	                bpl L88C1
289	.868c		49 88		eor #$88	                eor #$88

291	.868e						L88C1:
292	.868e		20 5d 89	jsr $895d	                jsr getMaskCount
293	.8691		d9 69 89	cmp $8969,y	                cmp maskByBitCount,y
294	.8694		f0 02		beq $8698	                beq jmpL88EE
295	.8696		b0 20		bcs $86b8	                bcs jmpBadCommandError8B68


298	.8698						jmpL88EE:
299	.8698		4c bb 86	jmp $86bb	                jmp L88EE

301							;-------------------------------------------------------------------------

303	.869b						print1NumberHelp:
304	.869b		10 08		bpl $86a5	                bpl L88D8
305	.869d		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
306	>86a0		3c 44 3e 0d 00			                .text "<D>",13,0
307	.86a5						L88D8:
308	.86a5		60		rts		                rts

310							;-------------------------------------------------------------------------

312	.86a6						L88D9:
313	.86a6		30 07		bmi $86af	                bmi printDecimalConfigurationByte
314	.86a8		bd 3d 85	lda $853d,x	                lda configureTable+1,x
315	.86ab		18		clc		                clc
316	.86ac		4c aa 88	jmp $88aa	                jmp L8ADA

318							;-------------------------------------------------------------------------

320	.86af						printDecimalConfigurationByte:
321	.86af		20 34 88	jsr $8834	                jsr readConfigurationByte

323	.86b2						printDecimalByteAThenNewLine:
324	.86b2		20 7d 89	jsr $897d	                jsr printDecimalByteA
325	.86b5		4c e7 ff	jmp $ffe7	                jmp OSNEWL

327							;-------------------------------------------------------------------------

329	.86b8						jmpBadCommandError8B68:
330	.86b8		4c 29 f9	jmp $f929	                jmp badCommandError

332							;-------------------------------------------------------------------------

334	.86bb						L88EE: .block
335	.86bb		85 b0		sta $b0		                sta $B0         ;save value
336	.86bd		20 5d 89	jsr $895d	                jsr getMaskCount
337	.86c0		b9 69 89	lda $8969,y	                lda maskByBitCount,y
338	.86c3		20 54 89	jsr $8954	                jsr getShiftCount
339	.86c6		80 03		bra $86cb	                bra shift
340	.86c8						shiftLoop:
341	.86c8		0a		asl a		                asl a           ;shift mask
342	.86c9		06 b0		asl $b0		                asl $B0         ;shift value

344	.86cb						shift:
345	.86cb		88		dey		                dey
346	.86cc		10 fa		bpl $86c8	                bpl shiftLoop
347	.86ce		85 b1		sta $b1		                sta $B1         ;store shifted value
348	.86d0		20 48 89	jsr $8948	                jsr getRTCByteIndex
349	.86d3		20 a3 96	jsr $96a3	                jsr readRTCByte ;get previous value
350	.86d6		05 b1		ora $b1		                ora $B1         ;set all masked bits to 1
351	.86d8		45 b1		eor $b1		                eor $B1         ;set all masked bits to 0
352	.86da		05 b0		ora $b0		                ora $B0         ;insert value
353	.86dc		a8		tay		                tay             ;Y=byte to write
354							                .endblock

356	.86dd						jmpWriteRTCByte:
357	.86dd		4c d0 96	jmp $96d0	                jmp writeRTCByte

359							;-------------------------------------------------------------------------

361	.86e0						handlePrinterIgnoreChar:
362	.86e0		70 18		bvs $86fa	                bvs printDefaultPrinterIgnoreChar ;taken if *STATUS
363	.86e2		b0 31		bcs $8715	                bcs print1OptionalNumberHelp
364	.86e4		f0 0e		beq $86f4	                beq L8927
365	.86e6		20 82 87	jsr $8782	                jsr L89B5
366	.86e9		da		phx		                phx
367	.86ea		a9 00		lda #$00	                lda #0
368	.86ec		20 f6 86	jsr $86f6	                jsr L8929
369	.86ef		7a		ply		                ply
370	.86f0		a2 1c		ldx #$1c	                ldx #$E+cmosBytesOffset
371	.86f2		80 e9		bra $86dd	                bra jmpWriteRTCByte

373							;-------------------------------------------------------------------------

375	.86f4						L8927:
376	.86f4		a9 01		lda #$01	                lda #1

378							;-------------------------------------------------------------------------

380	.86f6						L8929:
381	.86f6		a2 c7		ldx #$c7	                ldx #configureTable.L8603-configureTable
382	.86f8						L892B:
383	.86f8		80 9e		bra $8698	                bra jmpL88EE

385							;-------------------------------------------------------------------------

387	.86fa						printDefaultPrinterIgnoreChar:
388	.86fa		20 74 89	jsr $8974	                jsr readUsePrinterIgnoreChar
389	.86fd		90 0f		bcc $870e	                bcc gotPrinterIgnoreChar
390	.86ff		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
391	>8702		4e 6f 20 49 67 6e 6f 72		                .text "No Ignore",13,0
	>870a		65 0d 00
392	.870d		60		rts		                rts

394							;-------------------------------------------------------------------------

396	.870e						gotPrinterIgnoreChar:
397	.870e		a2 1c		ldx #$1c	                ldx #CMOSBytes.printerIgnoreChar+cmosBytesOffset
398	.8710		20 a3 96	jsr $96a3	                jsr readRTCByte
399	.8713						L8946:
400	.8713		80 9d		bra $86b2	                bra printDecimalByteAThenNewLine

402							;-------------------------------------------------------------------------

404	.8715						print1OptionalNumberHelp:
405	.8715		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
406	>8718		5b 3c 44 3e 5d 0d 00		                .text "[<D>]",13,0
407	.871f		60		rts		                rts

409							;-------------------------------------------------------------------------

411	.8720						L8953:

413	.8720		20 b0 83	jsr $83b0	                jsr parseNumberFromString

415	.8723						L8956:
416	.8723		90 93		bcc $86b8	                bcc jmpBadCommandError8B68
417	.8725		8a		txa		                txa
418	.8726		c9 10		cmp #$10	                cmp #$10

420	.8728						L895B:
421	.8728		b0 8e		bcs $86b8	                bcs jmpBadCommandError8B68

423	.872a						L895D:
424	.872a		48		pha		                pha
425	.872b		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput

427	.872e						L8961:
428	.872e		d0 88		bne $86b8	                bne jmpBadCommandError8B68
429	.8730		68		pla		                pla
430	.8731		60		rts		                rts

432							;-------------------------------------------------------------------------

434	.8732						handleTV:
435	.8732		70 2f		bvs $8763	                bvs L8996
436	.8734		b0 3b		bcs $8771	                bcs printTVHelp
437	.8736		f0 27		beq $875f	                beq L8992
438	.8738		20 b0 83	jsr $83b0	                jsr parseNumberFromString
439	.873b		90 e6		bcc $8723	                bcc L8956
440	.873d		e0 fc		cpx #$fc	                cpx #$FC
441	.873f		b0 04		bcs $8745	                bcs L8978
442	.8741		e0 04		cpx #$04	                cpx #4
443	.8743		b0 e3		bcs $8728	                bcs L895B

445	.8745						L8978:
446	.8745		8a		txa		                txa
447	.8746		0a		asl a		                asl a
448	.8747		85 b1		sta $b1		                sta $B1
449	.8749		a2 00		ldx #$00	                ldx #0
450	.874b		20 7d f2	jsr $f27d	                jsr LF30A
451	.874e		f0 08		beq $8758	                beq L898B
452	.8750		20 82 87	jsr $8782	                jsr L89B5
453	.8753		c9 02		cmp #$02	                cmp #2
454	.8755		b0 d1		bcs $8728	                bcs L895B
455	.8757		aa		tax		                tax

457	.8758						L898B:
458	.8758		8a		txa		                txa
459	.8759		05 b1		ora $b1		                ora $B1

461	.875b						L898E:
462	.875b		a2 c9		ldx #$c9	                ldx #configureTable.L8605-configureTable
463	.875d		80 99		bra $86f8	                bra L892B

465							;-------------------------------------------------------------------------

467	.875f						L8992:
468	.875f		a9 00		lda #$00	                lda #0
469	.8761		80 f8		bra $875b	                bra L898E

471							;-------------------------------------------------------------------------

473	.8763						L8996:
474	.8763		20 ac 89	jsr $89ac	                jsr readDefaultTVSettings
475	.8766		20 7c 89	jsr $897c	                jsr printDecimalByteY
476	.8769		a9 2c		lda #$2c	                lda #','
477	.876b		20 ee ff	jsr $ffee	                jsr OSWRCH
478	.876e		8a		txa		                txa
479	.876f		80 a2		bra $8713	                bra L8946

481							;-------------------------------------------------------------------------

483	.8771						printTVHelp:
484	.8771		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
485	>8774		5b 3c 44 3e 5b 2c 3c 44		                .text "[<D>[,<D>]]",13,0
	>877c		3e 5d 5d 0d 00
486	.8781		60		rts		                rts

488							;-------------------------------------------------------------------------

490	.8782						L89B5:
491	.8782		20 b0 83	jsr $83b0	                jsr parseNumberFromString
492	.8785		90 9c		bcc $8723	                bcc L8956
493	.8787		8a		txa		                txa
494	.8788		80 a0		bra $872a	                bra L895D


497							;-------------------------------------------------------------------------

499	.878a						printConfigureOrStatusHeader: .block
500	.878a		d0 a2		bne $872e	                bne L8961
501	.878c		08		php		                php
502	.878d		5a		phy		                phy
503	.878e		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
504	>8791		43 6f 6e 66 69 67 75 72		                .text "Configuration ",0
	>8799		61 74 69 6f 6e 20 00
505	.87a0		70 0f		bvs $87b1	                bvs printStatusHeader ;taken if *STATUS
506	.87a2		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
507	>87a5		6f 70 74 69 6f 6e 73 3a		                .text "options:",13,0
	>87ad		0d 00
508	.87af		80 0c		bra $87bd	                bra printItems
509	.87b1						printStatusHeader:
510	.87b1		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
511	>87b4		73 74 61 74 75 73 3a 0d		                .text "status:",13,0
	>87bc		00
512	.87bd						printItems:
513	.87bd		38		sec		                sec
514	.87be		20 aa 88	jsr $88aa	                jsr L8ADA
515	.87c1		7a		ply		                ply
516	.87c2		28		plp		                plp
517	.87c3		08		php		                php
518	.87c4		20 41 89	jsr $8941	                jsr unknownCONFIGOrStatus
519	.87c7		28		plp		                plp
520	.87c8		70 66		bvs $8830	                bvs done        ;taken if *STATUS
521	.87ca		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
522	>87cd		57 68 65 72 65 3a 0d		                .text "Where:",13
523	>87d4		44 20 69 73 20 61 20 64		                .text "D is a decimal number, or",13
	>87dc		65 63 69 6d 61 6c 20 6e 75 6d 62 65 72 2c 20 6f
	>87ec		72 0d
524	>87ee		61 20 68 65 78 61 64 65		                .text "a hexadecimal number preceded by &",13
	>87f6		63 69 6d 61 6c 20 6e 75 6d 62 65 72 20 70 72 65
	>8806		63 65 64 65 64 20 62 79 20 26 0d
525	>8811		49 74 65 6d 73 20 77 69		                .text "Items within [ ] are optional",13
	>8819		74 68 69 6e 20 5b 20 5d 20 61 72 65 20 6f 70 74
	>8829		69 6f 6e 61 6c 0d
526	>882f		00				                .byte 0
527	.8830						done:
528	.8830		60		rts		                rts
529							                .endblock

531							;-------------------------------------------------------------------------
532							;
533							; Read configuration byte, given offset of metadata in the configure
534							; table.
535							;
536							; Entry:
537							;
538							; X = offset of metadata in the configure table
539							;
540							; Exit:
541							;
542							; A = value read
543							;
544							; Preserves: X/Y/P

546							                .if version==350
547	.8831						clearTSTAndReadConfigurationByte:
548	.8831		20 5c f3	jsr $f35c	                jsr withTSTClear
549							                .endif
550	.8834						readConfigurationByte: .block
551	.8834		08		php		                php
552	.8835		5a		phy		                phy
553	.8836		da		phx		                phx
554	.8837		20 48 89	jsr $8948	                jsr getRTCByteIndex ;
555	.883a		20 a3 96	jsr $96a3	                jsr readRTCByte
556	.883d		fa		plx		                plx
557	.883e		20 54 89	jsr $8954	                jsr getShiftCount
558	.8841		80 01		bra $8844	                bra shift

560							;-------------------------------------------------------------------------

562	.8843						shiftLoop:
563	.8843		4a		lsr a		                lsr a

565	.8844						shift:
566	.8844		88		dey		                dey
567	.8845		10 fc		bpl $8843	                bpl shiftLoop

569	.8847		20 5d 89	jsr $895d	                jsr getMaskCount
570	.884a		39 69 89	and $8969,y	                and maskByBitCount,y
571	.884d		e0 07		cpx #$07	                cpx #configureTable.baud.metadata-configureTable
572	.884f		d0 01		bne $8852	                bne gotMaskedByte
573	.8851		1a		inc a		                inc a

575	.8852						gotMaskedByte:
576							                ; If retrieving the MODE value, rearrange things so
577							                ; the shadow modes are 128-135.
578	.8852		e0 6b		cpx #$6b	                cpx #configureTable.mode.metadata-configureTable
579	.8854		d0 06		bne $885c	                bne done        ;taken if not MODE
580	.8856		89 08		bit #$08	                bit #CMOSBytes.defaults0.shadowMask ;test shadow bit
581	.8858		f0 02		beq $885c	                beq done                                   ;taken if not shadow mode
582	.885a		49 88		eor #$88	                eor #$80|CMOSBytes.defaults0.shadowMask ;turn mode|flag into mode|$80

584	.885c						done:
585	.885c		7a		ply		                ply
586	.885d		28		plp		                plp
587	.885e		60		rts		                rts
588							                .endblock

590							;-------------------------------------------------------------------------
591							;
592							; Find command in command table.
593							;
594							; Entry:
595							;
596							; (stringInputBufferAddress),y = input
597							; oscliWorkspace.tablePtr; = address of command table
598							; V = 0 if commands have 4 bytes of metadata
599							;     1 if commands have 2 bytes of metadata
600							;
601							; Exit:
602							;
603							; C=0 = no match
604							;
605							; C=1 = match;
606							;       A holds 1st byte of metadata
607							;       oscliWorkspace.tablePtr; = address of 2nd and following metadata bytes
608							;       (stringInputBufferAddress),y = input following command
609							;
610							; Preserves: X/V

612	.885f						findCommand: .block
613	.885f		84 e6		sty $e6		                sty $E6         ;save Y
614	.8861		80 0a		bra $886d	                bra checkInput       ;get going...

616	.8863						checkLetter:
617	.8863		52 b0		eor ($b0)	                eor (oscliWorkspace.tablePtr)
618	.8865		29 df		and #$df	                and #$DF
619	.8867		d0 15		bne $887e	                bne noMatch    ; taken if char didn't match
620	.8869		20 9e 88	jsr $889e	                jsr fetchCommandTableByte
621	.886c		c8		iny		                iny

623	.886d						checkInput:
624	.886d		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
625	.886f		20 35 ea	jsr $ea35	                jsr isLetter
626	.8872		90 ef		bcc $8863	                bcc checkLetter ; taken if letter

628							                ; Non-letter input means potentially end of command
629							                ; name.
630	.8874		b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr) ; next table byte
631	.8876		30 21		bmi $8899	                bmi commandMatch ; taken if end of string - a match
632	.8878		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
633	.887a		c9 2e		cmp #$2e	                cmp #'.'        ; '.' is the abbreviation char
634	.887c		f0 04		beq $8882	                beq abbreviationMatch ;taken with C=1 if match

636	.887e						noMatch:
637	.887e		18		clc		                clc             ;indicate no match
638	.887f		a4 e6		ldy $e6		                ldy $E6         ;restore Y
639	.8881		88		dey		                dey             ;compensate for upcoming iny

641	.8882						abbreviationMatch:
642	.8882		c8		iny		                iny             ; skip the '.'

644	.8883						findCommandMetadataLoop:
645	.8883		20 9e 88	jsr $889e	                jsr fetchCommandTableByte
646	.8886		f0 15		beq $889d	                beq rts8ACD
647	.8888		10 f9		bpl $8883	                bpl findCommandMetadataLoop ; keep looping through chars if necessary
648	.888a		b0 11		bcs $889d	                bcs rts8ACD                 ;taken if it was a match
649	.888c		20 9e 88	jsr $889e	                jsr fetchCommandTableByte   ;discard 2nd metadata byte
650	.888f		70 dc		bvs $886d	                bvs checkInput ; if V=1, 2-byte metadata; if V=0, 4-byte metadata
651	.8891		20 9e 88	jsr $889e	                jsr fetchCommandTableByte ;discard 3rd metadata byte
652	.8894		20 9e 88	jsr $889e	                jsr fetchCommandTableByte ;discard 4th metadata byte
653	.8897		80 d4		bra $886d	                bra checkInput

655							;-------------------------------------------------------------------------

657	.8899						commandMatch:
658	.8899		20 9e 88	jsr $889e	                jsr fetchCommandTableByte
659	.889c		38		sec		                sec

661	.889d						rts8ACD:
662	.889d		60		rts		                rts
663							                .endblock

665							;-------------------------------------------------------------------------
666							;
667							; Fetch byte from command table with postincrement.
668							;
669							; Entry:
670							;
671							; oscliWorkspace.tablePtr; = address of byte to fetch
672							;
673							; Exit:
674							;
675							; A = byte fetched
676							; oscliWorkspace.tablePtr; incremented
677							;
678							; Preserves: X/Y/C/V

680	.889e						fetchCommandTableByte:
681	.889e		e8		inx		                inx
682	.889f		b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr)
683	.88a1		48		pha		                pha
684	.88a2		e6 b0		inc $b0		                inc oscliWorkspace.tablePtr+0
685	.88a4		d0 02		bne $88a8	                bne L8AD8
686	.88a6		e6 b1		inc $b1		                inc oscliWorkspace.tablePtr+1

688	.88a8						L8AD8:
689	.88a8		68		pla		                pla
690	.88a9		60		rts		                rts

692							;-------------------------------------------------------------------------
693							;
694							; Print configure table items.
695							;
696							; Entry:
697							;
698							; C = ???
699							;
700							; V=0 if *CONFIGURE; V=1 if *STATUS
701							;
702	.88aa						L8ADA: .block
703	.88aa		48		pha		                pha
704	.88ab		a0 03		ldy #$03	                ldy #configureTable.baud-configureTable
705	.88ad		a2 02		ldx #$02	                ldx #(configureTable.baud-configureTable)-1

707	.88af						loop:
708	.88af		e8		inx		                inx
709	.88b0		bd 3c 85	lda $853c,x	                lda configureTable,x ;get name byte
710	.88b3		f0 5a		beq $890f	                beq done            ;all done if 0
711	.88b5		10 f8		bpl $88af	                bpl loop            ;keep going until end of name
712							                                     ;reached
713	.88b7		50 1f		bvc $88d8	                bvc L8B08            ;taken if *CONFIGURE

715							                ; A = metadata byte 0
716	.88b9		29 40		and #$40	                and #$40
717	.88bb		f0 10		beq $88cd	                beq L8AFD       ;taken if V0 clear

719	.88bd		bd 3d 85	lda $853d,x	                lda configureTable+1,x ;A = metadata byte 1
720	.88c0		30 0b		bmi $88cd	                bmi L8AFD              ;taken if N1 set

722	.88c2		20 34 88	jsr $8834	                jsr readConfigurationByte ;Read the actual value
723	.88c5		5d 3c 85	eor $853c,x	                eor configureTable,x      ;eor with MatchValue
724	.88c8		29 07		and #$07	                and #7                    ;A=0 if value matches MatchValue
725	.88ca		d0 3d		bne $8909	                bne next                  ;taken if value isn't MatchValue
726	.88cc		3a		dec a		                dec a                     ;A=$ff

728	.88cd						L8AFD:
729	.88cd		b0 09		bcs $88d8	                bcs L8B08       ;
730	.88cf		10 38		bpl $8909	                bpl next        ;
731	.88d1		68		pla		                pla
732	.88d2		48		pha		                pha
733	.88d3		5d 3d 85	eor $853d,x	                eor configureTable+1,x
734	.88d6		d0 31		bne $8909	                bne next

736	.88d8						L8B08:
737	.88d8		08		php		                php
738	.88d9		da		phx		                phx
739	.88da		50 09		bvc $88e5	                bvc printOrdinaryItem
740	.88dc		c0 4b		cpy #$4b	                cpy #configureTable.ignore-configureTable
741	.88de		d0 05		bne $88e5	                bne printOrdinaryItem
742	.88e0		20 74 89	jsr $8974	                jsr readUsePrinterIgnoreChar
743	.88e3		b0 1b		bcs $8900	                bcs L8B30

745	.88e5						printOrdinaryItem:
746	.88e5		a2 09		ldx #$09	                ldx #9
747	.88e7		20 3b 89	jsr $893b	                jsr printConfigureTableString
748	.88ea		29 40		and #$40	                and #$40
749	.88ec		f0 0f		beq $88fd	                beq printSpaces       ;taken if V0 clear
750	.88ee		b9 3d 85	lda $853d,y	                lda configureTable+1,y
751	.88f1		30 0a		bmi $88fd	                bmi printSpaces ;taken if N1 set

753							                ; V0 set, N1 clear = newline and next item
754	.88f3		20 e7 ff	jsr $ffe7	                jsr OSNEWL
755	.88f6		80 0f		bra $8907	                bra next2

757	.88f8						printSpacesLoop:
758	.88f8		a9 20		lda #$20	                lda #' '
759	.88fa		20 ee ff	jsr $ffee	                jsr OSWRCH

761	.88fd						printSpaces:
762	.88fd		ca		dex		                dex
763	.88fe		10 f8		bpl $88f8	                bpl printSpacesLoop

765	.8900						L8B30:
766	.8900		fa		plx		                plx
767	.8901		28		plp		                plp
768	.8902		08		php		                php
769	.8903		da		phx		                phx
770	.8904		20 51 86	jsr $8651	                jsr L8884

772	.8907						next2:
773	.8907		fa		plx		                plx
774	.8908		28		plp		                plp

776	.8909						next:
777	.8909		e8		inx		                inx             ;point X just before next item
778	.890a		8a		txa		                txa
779	.890b		a8		tay		                tay
780	.890c		c8		iny		                iny             ;point Y at next item
781	.890d		80 a0		bra $88af	                bra loop

783	.890f						done:
784	.890f		68		pla		                pla
785	.8910		60		rts		                rts
786							                .endblock

788							;-------------------------------------------------------------------------

790	.8911						printConfigureTableStringLoop:
791	.8911		20 ee ff	jsr $ffee	                jsr OSWRCH      ;print char
792	.8914		48		pha		                pha             ;save A (char to print)
793	.8915		5a		phy		                phy             ;save Y (table offset)
794	.8916		98		tya		                tya             ;get table offset in A

796							                ; If we're at a snippet insert point, insert the
797							                ; snippet, recursively.
798	.8917		a0 04		ldy #$04	                ldy #configureTable.textSnippetsCount-1
799	.8919						findSnippetInsertPointLoop:
800	.8919		d9 19 86	cmp $8619,y	                cmp configureTable.textSnippetInsertPointOffsets,y
801	.891c		d0 07		bne $8925	                bne nextSnippetInsertPoint

803							                ; Insert a snippet here. Load the new snippet's offset
804							                ; in Y and repeat.
805	.891e		b9 1e 86	lda $861e,y	                lda configureTable.textSnippetOffsets,y
806	.8921		a8		tay		                tay
807	.8922		20 3b 89	jsr $893b	                jsr printConfigureTableString
808	.8925						nextSnippetInsertPoint
809	.8925		88		dey		                dey
810	.8926		10 f1		bpl $8919	                bpl findSnippetInsertPointLoop
811	.8928		7a		ply		                ply             ;restore Y (table offset)
812	.8929		68		pla		                pla             ;restore A (char to print)
813	.892a		c8		iny		                iny             ;next byte in table
814	.892b		ca		dex		                dex             ;
815	.892c		49 20		eor #$20	                eor #$20
816	.892e		19 3c 85	ora $853c,y	                ora configureTable,y
817	.8931		29 a0		and #$a0	                and #%10100000
818	.8933		d0 06		bne $893b	                bne printConfigureTableString

820							                ; if char case changed, but it wasn't the end of the
821							                ; string, pop a space in.
822	.8935		a9 20		lda #$20	                lda #' '
823	.8937		20 ee ff	jsr $ffee	                jsr OSWRCH
824	.893a		ca		dex		                dex
825							                .cerror *!=printConfigureTableString

827							;-------------------------------------------------------------------------
828							;
829							; Print string from configure table, with snippets inserted as
830							; required.
831							;
832							; Entry:
833							;
834							; X = column counter start value
835							; Y = configure table offset
836							;
837							; Exit:
838							;
839							; A = item's metadata byte 0
840							; X decremented for each char printed
841							;
842	.893b						printConfigureTableString:
843	.893b		b9 3c 85	lda $853c,y	                lda configureTable,y
844	.893e		10 d1		bpl $8911	                bpl printConfigureTableStringLoop
845	.8940		60		rts		                rts


848							;-------------------------------------------------------------------------
849							;
850							; Issue ROM service call romServiceCallUnknownCONFIG ($28) or
851							; romServiceCallUnknownSTATUS ($29).
852							;
853							; Entry:
854							;
855							; C=0 for unknown CONFIG, or C=1 for unknown STATUS
856							;
857							; Exit:
858							;
859							; as per appropriate ROM service call
860							;
861	.8941						unknownCONFIGOrStatus:
862							                .cerror (romServiceCallUnknownCONFIG&1)!=0
863							                .cerror (romServiceCallUnknownSTATUS&1)==0
864	.8941		a9 14		lda #$14	                lda #romServiceCallUnknownCONFIG>>1
865	.8943		2a		rol a		                rol a           ;form $28 or $29 according to C
866	.8944		aa		tax		                tax
867	.8945		4c b5 ed	jmp $edb5	                jmp makeROMServiceCall

869							;-------------------------------------------------------------------------
870							;
871							; Get actual RTC byte index for configure item, given offset in
872							; configure table to its metadata.
873							;
874							; Entry:
875							;
876							; X = offset into configure table for item's metadata
877							;
878							; Exit:
879							;
880							; X = index of byte read
881							;
882							; Preserves: Y/C

884	.8948						getRTCByteIndex:
885	.8948		bd 3d 85	lda $853d,x	                lda configureTable+1,x
886	.894b		29 78		and #$78	                and #%01111000
887	.894d		4a		lsr a		                lsr a
888	.894e		4a		lsr a		                lsr a
889	.894f		4a		lsr a		                lsr a
890	.8950		69 0f		adc #$0f	                adc #rtcByteIndexOffset
891	.8952		aa		tax		                tax
892	.8953		60		rts		                rts

894							;-------------------------------------------------------------------------
895							;
896							; Get shift count for configure item's data, given offset in configure
897							; table for its metadata.
898							;
899							; Entry:
900							;
901							; X = offset into configure table for item's metadata
902							;
903							; Exit:
904							;
905							; Y = shift count
906							;
907							; Preserves: A/X/C
908							;
909	.8954						getShiftCount:
910	.8954		48		pha		                pha
911	.8955		bd 3d 85	lda $853d,x	                lda configureTable+1,x
912	.8958		29 07		and #$07	                and #%00000111
913	.895a		a8		tay		                tay
914	.895b		68		pla		                pla
915	.895c		60		rts		                rts


918							;-------------------------------------------------------------------------
919							;
920							; Get mask bit count for configure item's data, given offset in
921							; configure table for its metadata.
922							;
923							; Entry:
924							;
925							; X = offset into configure table for item's metadata
926							;
927							; Exit:
928							;
929							; Y = mask bit count, -1 (0 = 1 bits ... 7 = 8 bits)
930							;
931							; Preserves: A/X
932							;
933	.895d						getMaskCount:
934	.895d		48		pha		                pha
935	.895e		bd 3c 85	lda $853c,x	                lda configureTable,x; "."
936	.8961		4a		lsr a		                lsr a
937	.8962		4a		lsr a		                lsr a
938	.8963		4a		lsr a		                lsr a
939	.8964		29 07		and #$07	                and #7
940	.8966		a8		tay		                tay
941	.8967		68		pla		                pla
942	.8968		60		rts		                rts

944	.8969						maskByBitCount:
945	>8969		01				                .byte %00000001
946	>896a		03				                .byte %00000011
947	>896b		07				                .byte %00000111
948	>896c		0f				                .byte %00001111
949	>896d		1f				                .byte %00011111
950	>896e		3f				                .byte %00111111
951	>896f		7f				                .byte %01111111
952	>8970		ff				                .byte %11111111

954							;-------------------------------------------------------------------------
955							;
956							; Read the use printer ignore char flag.
957							;
958							; Exit:
959							;
960							; C=0 if using printer ignore char; C=1 if not.
961							;
962							; Preserves: Y

964							                .if version==350
965	.8971						clearTSTAndReadUsePrinterIgnoreChar:
966	.8971		20 5c f3	jsr $f35c	                jsr withTSTClear
967							                .endif
968	.8974						readUsePrinterIgnoreChar:
969	.8974		5a		phy		                phy
970	.8975		20 8f 96	jsr $968f	                jsr readDefaults2
971	.8978		4a		lsr a		                lsr a
972	.8979		4a		lsr a		                lsr a
973	.897a		7a		ply		                ply
974	.897b		60		rts		                rts

976							;-------------------------------------------------------------------------
977							;
978							; Print decimal byte.
979							;
980							; Entry:
981							;
982							; (printDecimalByteA) A = value to print
983							;
984							; (printDecimalByteY) Y = value to print
985							;
986	.897c						printDecimalByteY:
987	.897c		98		tya		                tya
988	.897d						printDecimalByteA:
989	.897d		38		sec		                sec             ;set leading zeros flag
990	.897e		a0 ff		ldy #$ff	                ldy #$FF        ;reset digit counter
991	.8980		08		php		                php             ;save leading zeros flag

993	.8981						countHundredsLoop:
994	.8981		c8		iny		                iny
995	.8982		e9 64		sbc #$64	                sbc #100
996	.8984		b0 fb		bcs $8981	                bcs countHundredsLoop

998	.8986		69 64		adc #$64	                adc #100        ;put 0 back in the hundreds column
999	.8988		28		plp		                plp             ;restore leading zeros flag
1000	.8989		20 9d 89	jsr $899d	                jsr maybePrintHexDigit

1002	.898c		a0 ff		ldy #$ff	                ldy #$FF        ;reset digit counter
1003	.898e		08		php		                php             ;save leading zeros flag
1004	.898f		38		sec		                sec

1006	.8990						countTensLoop:
1007	.8990		c8		iny		                iny
1008	.8991		e9 0a		sbc #$0a	                sbc #10
1009	.8993		b0 fb		bcs $8990	                bcs countTensLoop

1011	.8995		69 0a		adc #$0a	                adc #10         ;put 0 back in the tens column
1012	.8997		28		plp		                plp             ;restore leading zeros flag
1013	.8998		20 9d 89	jsr $899d	                jsr maybePrintHexDigit
1014	.899b		18		clc		                clc             ;always clear leading zeros flag for
1015							                                ;units
1016	.899c		a8		tay		                tay             ;Y=3rd digit

1018	.899d						maybePrintHexDigit:
1019	.899d		48		pha		                pha
1020	.899e		98		tya		                tya
1021	.899f		d0 02		bne $89a3	                bne L8BD0       ;always print if non-zero
1022	.89a1		b0 04		bcs $89a7	                bcs L8BD4       ;print non-leading zeros
1023	.89a3						L8BD0:
1024	.89a3		20 b5 a8	jsr $a8b5	                jsr printHexDigit
1025	.89a6		18		clc		                clc             ;indicate non-zero digit printed
1026	.89a7						L8BD4:
1027	.89a7		68		pla		                pla
1028	.89a8		60		rts		                rts

1030							;-------------------------------------------------------------------------

1032							                .if version==350
1033	.89a9						clearTSTAndReadDefaultTVSettings
1034	.89a9		20 5c f3	jsr $f35c	                jsr withTSTClear
1035							                .endif
1036	.89ac						readDefaultTVSettings:
1037	.89ac		a2 c9		ldx #$c9	                ldx #configureTable.L8605-configureTable
1038	.89ae		20 34 88	jsr $8834	                jsr readConfigurationByte
1039	.89b1		4a		lsr a		                lsr a
1040	.89b2		89 04		bit #$04	                bit #%00000100
1041	.89b4		f0 02		beq $89b8	                beq L8BE2
1042	.89b6		09 fc		ora #$fc	                ora #%11111100
1043	.89b8						L8BE2:
1044	.89b8		a8		tay		                tay
1045	.89b9		a9 00		lda #$00	                lda #0
1046	.89bb		2a		rol a		                rol a
1047	.89bc		aa		tax		                tax
1048	.89bd		60		rts		                rts

1050							;-------------------------------------------------------------------------


:7	;******  Return to file: src/terminal.s65

929							                .include "sram_utils.s65"

:9	;******  Processing file: src/sram_utils.s65

1							;-------------------------------------------------------------------------

3							; osword42SetupTable[i] is offset into sramWorkspace for OSWORD
4							; parameter block byte i

6	.89be						osword42SetupTable:
7							                .if version>=500||version==350
8	>89be		01				                .byte sramWorkspace.type-sramWorkspace
9							                .endif
10	>89bf		09				                .byte sramWorkspace.dataAddress+0-sramWorkspace
11	>89c0		0a				                .byte sramWorkspace.dataAddress+1-sramWorkspace
12	>89c1		0b				                .byte sramWorkspace.dataAddress+2-sramWorkspace
13	>89c2		0c				                .byte sramWorkspace.dataAddress+3-sramWorkspace
14	>89c3		02				                .byte sramWorkspace.length+0-sramWorkspace
15	>89c4		03				                .byte sramWorkspace.length+1-sramWorkspace
16	>89c5		04				                .byte sramWorkspace.bank-sramWorkspace
17	>89c6		05				                .byte sramWorkspace.sramAddress+0-sramWorkspace
18	>89c7		06				                .byte sramWorkspace.sramAddress+1-sramWorkspace

20							;-------------------------------------------------------------------------
21							;
22							; OSWORD $42 - Sideways RAM Block Transfor (G.7-7)
23							;
24							; Entry: parameter block like this:
25							;
26							;    block?0 - bit 7 clear=sram->memory, set=memory->sram
27							;              bit 6 clear=absolute, set=pseudo
28							;    block!1 - data address
29							;    (block+5); - block length
30							;    block?7 - ROM ID 0-$0f, or $10-$13 for W/X/Y/Z
31							;    (block+8); - sideways RAM address
32							;
33	.89c8						osword42: .proc
34							                .if version==400
38							                .endif
39	.89c8		a0 09		ldy #$09	                ldy #9

41	.89ca						copyFromParameterBlockLoop:
42	.89ca		b1 f0		lda ($f0),y	                lda (originalX),y
43							                .if version==400
45							                .else
46	.89cc		be be 89	ldx $89be,y	                ldx osword42SetupTable,y
47							                .endif
48	.89cf		9d ed 02	sta $02ed,x	                sta sramWorkspace,x
49	.89d2		88		dey		                dey
50							                .if version==400
52							                .else
53	.89d3		10 f5		bpl $89ca	                bpl copyFromParameterBlockLoop
54	.89d5		c8		iny		                iny             ; Y=0
55							                .endif

57	.89d6						saveTransferPointersLoop:
58	.89d6		b9 b0 00	lda $00b0,y	                lda sramTransferPointers,y
59	.89d9		48		pha		                pha
60	.89da		c8		iny		                iny
61	.89db		c0 04		cpy #$04	                cpy #size(sramTransferPointers)
62	.89dd		90 f7		bcc $89d6	                bcc saveTransferPointersLoop

64	.89df		20 8d 8b	jsr $8b8d	                jsr doSidewaysRAMBlockTransfer

66	.89e2		a0 03		ldy #$03	                ldy #size(sramTransferPointers)-1
67	.89e4						restoreTransferPointersLoop:
68	.89e4		68		pla		                pla
69	.89e5		99 b0 00	sta $00b0,y	                sta sramTransferPointers,y
70	.89e8		88		dey		                dey
71	.89e9		10 f9		bpl $89e4	                bpl restoreTransferPointersLoop
72	.89eb		60		rts		                rts
73							                .endproc

75							;-------------------------------------------------------------------------

77	.89ec						convertSidewaysRAMPseudoAddress:
78	.89ec		2c ee 02	bit $02ee	                bit sramWorkspace.type
79	.89ef		50 30		bvc $8a21	                bvc checkROMID ;taken if absolute addressing - nothing to do

81							                ; Sort out pseudo address - see MasRef G.7-5
82	.89f1		a0 04		ldy #$04	                ldy #4          ; 4=first SRAM bank
83	.89f3		ad f2 02	lda $02f2	                lda sramWorkspace.sramAddress+0 ; pseudo address
84	.89f6		ae f3 02	ldx $02f3	                ldx sramWorkspace.sramAddress+1 ; pseudo address
85	.89f9						findStartBankLoop:
86	.89f9		e0 3f		cpx #$3f	                cpx #>dataBankSize
87	.89fb		90 16		bcc $8a13	                bcc foundStartBank ; taken if MSB $00-$3e
88	.89fd		d0 04		bne $8a03	                bne nextBank       ; taken if MSB >=$40

90							                ; Address is 16 KB-the dummy header size
91	.89ff		c9 f0		cmp #$f0	                cmp #<dataBankSize
92	.8a01		90 10		bcc $8a13	                bcc foundStartBank ; taken if address<$3ff0

94	.8a03						nextBank:
95	.8a03		e9 f0		sbc #$f0	                sbc #<dataBankSize
96	.8a05		48		pha		                pha
97	.8a06		8a		txa		                txa
98	.8a07		e9 3f		sbc #$3f	                sbc #>dataBankSize
99	.8a09		aa		tax		                tax
100	.8a0a		68		pla		                pla
101	.8a0b		c8		iny		                iny
102	.8a0c		c0 08		cpy #$08	                cpy #8          ; 8=last SRAM bank
103	.8a0e		90 e9		bcc $89f9	                bcc findStartBankLoop ; taken if more banks to go
104	.8a10		4c e9 92	jmp $92e9	                jmp badAddressError ; taken if pseudo address out of range

106	.8a13						foundStartBank:
107							                ; form actual address in sramAddress!5
108	.8a13		69 10		adc #$10	                adc #<dataBankStart
109	.8a15		8d f2 02	sta $02f2	                sta sramWorkspace.sramAddress+0
110	.8a18		8a		txa		                txa
111	.8a19		69 80		adc #$80	                adc #>dataBankStart
112	.8a1b		8d f3 02	sta $02f3	                sta sramWorkspace.sramAddress+1
113	.8a1e		8c f1 02	sty $02f1	                sty sramWorkspace.bank ; save ROM number
114							                .cerror *!=checkROMID ; fall through to checkROMID

116							;-------------------------------------------------------------------------
117							;
118							; Check ROM ID (as read by readROMID) is valid.
119							;
120							; Entry:
121							;
122							; sramWorkspace.bank = ROM ID
123							;
124							; Exit:
125							;
126							; A=$40 Z=0 if operation addressing mode/bank addressing mode mismatch
127							;
128							; May also generate a "Bad id" error.

130	.8a21						checkROMID: .proc
131	.8a21		ad f1 02	lda $02f1	                lda sramWorkspace.bank
132	.8a24		c9 10		cmp #$10	                cmp #$10
133	.8a26		90 09		bcc $8a31	                bcc gotValidROMID       ; if <16, use as-is

135							                ; convert W/X/Y/Z to 4-7
136	.8a28		c9 14		cmp #$14	                cmp #$14
137	.8a2a		b0 1e		bcs $8a4a	                bcs badIdError  ; bad id if >=$14
138	.8a2c		49 14		eor #$14	                eor #$14        ; $10->$04, $11->$05, $12->$06, $13->$07
139	.8a2e		8d f1 02	sta $02f1	                sta sramWorkspace.bank

141	.8a31						gotValidROMID:
142	.8a31		aa		tax		                tax
143	.8a32		20 c7 f9	jsr $f9c7	                jsr isBankROM
144	.8a35		b0 07		bcs $8a3e	                bcs gotValidBank ; taken if RAM
145	.8a37		2c ee 02	bit $02ee	                bit sramWorkspace.type

147							                ; Don't understand the logic here?
148	.8a3a		10 0e		bpl $8a4a	                bpl badIdError  ; taken if read operation
149	.8a3c		70 0c		bvs $8a4a	                bvs badIdError  ; taken if pseudo addressing

151	.8a3e						gotValidBank:
152	.8a3e		20 95 8d	jsr $8d95	                jsr sramGetBankMode        ; A=$40 if pseudo
153	.8a41		ae f1 02	ldx $02f1	                ldx sramWorkspace.bank
154	.8a44		4d ee 02	eor $02ee	                eor sramWorkspace.type
155	.8a47		29 40		and #$40	                and #$40
156	.8a49		60		rts		                rts
157							                .endproc

159							;-------------------------------------------------------------------------

161	.8a4a						badIdError:
162	.8a4a		20 2f ab	jsr $ab2f	                jsr doFollowingError
163	>8a4d		80				                .byte $80
164	>8a4e		42 61 64 20 69 64		                .text "Bad id"
165	>8a54		00				                .byte 0

167							;-------------------------------------------------------------------------
168							;
169							; Read ROM ID from command line.
170							;
171							; Entry:
172							;
173							; ($f2),y = command line input pointer
174							;
175							; Exit:
176							;
177							; V=1 if invalid
178							;
179							; V=0 if valid
180							;    osfileParameterBlock?1 bit 6 cleared
181							;    osfileParameterBlock?4 is ROM ID
182							;
183							; May also generate a "Bad id" error.
184							;
185	.8a55						readROMID: .proc
186	.8a55		20 10 84	jsr $8410	                jsr readHexDigit ; get char, possibly hex
187	.8a58		2c 5e e3	bit $e35e	                bit valueFF      ; V=1
188	.8a5b		b0 0d		bcs $8a6a	                bcs got1CharROMID  ; taken if hex digit encountered
189	.8a5d		29 df		and #$df	                and #$DF         ; redundantly convert to upper case
190	.8a5f		c9 5b		cmp #$5b	                cmp #'Z'+1
191	.8a61		b0 1d		bcs $8a80	                bcs done        ; taken if >'Z' - not valid
192	.8a63		c9 57		cmp #$57	                cmp #'W'
193	.8a65		90 19		bcc $8a80	                bcc done        ; taken if <'W' - not valid
194	.8a67		e9 53		sbc #$53	                sbc #'W'-4      ; adjust: W=4, X=5, Y=6, Z=7
195	.8a69		c8		iny		                iny             ; consume command line char

197	.8a6a						got1CharROMID:
198							                ; Handle decimal numbers: if the bank was 1, it might
199							                ; be "1" or the first char of "10", "11", etc. Handle
200							                ; accordingly.
201							                ;
202							                ; (If using the W/X/Y/Z syntax, the banks are 4-7.)
203	.8a6a		c9 01		cmp #$01	                cmp #1
204	.8a6c		d0 09		bne $8a77	                bne gotROMID
205	.8a6e		88		dey		                dey             ; go back to the got char
206	.8a6f		20 b0 83	jsr $83b0	                jsr parseNumberFromString ; read as number
207	.8a72		8a		txa		                txa                       ; A = result
208	.8a73		c9 10		cmp #$10	                cmp #$10
209	.8a75		b0 d3		bcs $8a4a	                bcs badIdError  ; bad id if >15

211	.8a77						gotROMID:
212							                ; +4 = romid
213	.8a77		8d f1 02	sta $02f1	                sta sramWorkspace.bank

215							                ; clear +1 bit 6 - indicate valid rom id?
216	.8a7a		a9 40		lda #$40	                lda #$40
217	.8a7c		1c ee 02	trb $02ee	                trb sramWorkspace.type
218	.8a7f		b8		clv		                clv             ; V=0

220	.8a80						done:
221	.8a80		4c 72 f2	jmp $f272	                jmp skipSpacesAndCheckForCRInStringInput
222							                .endproc

224							;-------------------------------------------------------------------------

226	.8a83						starSRDATAOrStarSRROM:
227	.8a83		48		pha		                pha
228	.8a84		20 55 8a	jsr $8a55	                jsr readROMID
229	.8a87		70 23		bvs $8aac	                bvs jmpBadCommandError8CD6 ; taken if invalid ROM ID
230	.8a89		d0 21		bne $8aac	                bne jmpBadCommandError8CD6 ; taken if bad command line
231							                                           ; contents
232	.8a8b		68		pla		                pla

234							                ; $80 if *SRDATA; $00 if *SRROM
235							                .if version==400
237							                .else
238	.8a8c		0a		asl a		                asl a
239	.8a8d		8d ee 02	sta $02ee	                sta sramWorkspace.type
240							                .endif
241	.8a90		20 21 8a	jsr $8a21	                jsr checkROMID
242	.8a93		b0 b5		bcs $8a4a	                bcs badIdError  ; taken if bank could never be used
243							                                ; with pseudo addressing
244	.8a95		d0 06		bne $8a9d	                bne toggleModeAndInitBank ; taken if switching to other bank mode

246							                ; If bank mode didn't change, but there's nothing in
247							                ; the bank already, set up the dummy ROM header for
248							                ; it.
249	.8a97		1d a1 02	ora $02a1,x	                ora romInformationTable,x
250	.8a9a		f0 0a		beq $8aa6	                beq initBank
251	.8a9c		60		rts		                rts

253	.8a9d						toggleModeAndInitBank:
254	.8a9d		ad de df	lda $dfde	                lda hazel.sramBankModes
255	.8aa0		5d 5d 8d	eor $8d5d,x	                eor sramBank4567ModeMasks-4,x
256	.8aa3		8d de df	sta $dfde	                sta hazel.sramBankModes

258	.8aa6						initBank:
259	.8aa6		20 5b 8d	jsr $8d5b	                jsr setROMXType6502
260	.8aa9		4c a9 f9	jmp $f9a9	                jmp initDummyROMHeader

262							;-------------------------------------------------------------------------

264	.8aac						jmpBadCommandError8CD6:
265	.8aac		4c 29 f9	jmp $f929	                jmp badCommandError

267							;-------------------------------------------------------------------------

269	.8aaf						L8CD9:
270	.8aaf		20 c0 8a	jsr $8ac0	                jsr L8CEA
271	.8ab2		b0 0b		bcs $8abf	                bcs locret_8CE9
272	.8ab4		20 37 f9	jsr $f937	                jsr transferBetweenSidewaysRAMAndRAM
273	.8ab7		8c f2 02	sty $02f2	                sty sramWorkspace.sramAddress+0
274	.8aba		b5 01		lda $01,x	                lda 1,x
275	.8abc		8d f3 02	sta $02f3	                sta sramWorkspace.sramAddress+1

277	.8abf						locret_8CE9:
278	.8abf		60		rts		                rts


281							;-------------------------------------------------------------------------

283	.8ac0						L8CEA:
284							                ; get sram transfer sram pointer address in X - src if
285							                ; reading from sideways RAM, dest if writing to
286							                ; sideways RAM
287	.8ac0		a2 b0		ldx #$b0	                ldx #sramTransferPointers.src
288	.8ac2		2c ee 02	bit $02ee	                bit sramWorkspace.type
289	.8ac5		10 02		bpl $8ac9	                bpl +           ; taken if reading from sideways RAM
290	.8ac7		a2 b2		ldx #$b2	                ldx #sramTransferPointers.dest
291	.8ac9						+
292	.8ac9		74 00		stz $00,x	                stz 0,x
293	.8acb		ac f2 02	ldy $02f2	                ldy sramWorkspace.sramAddress+0 ; sram address LSB
294	.8ace		98		tya		                tya                        ; Y=sram address LSB
295	.8acf		18		clc		                clc
296	.8ad0		6d ef 02	adc $02ef	                adc sramWorkspace.length+0 ; form end address LSB
297	.8ad3		8d ef 02	sta $02ef	                sta sramWorkspace.length+0
298	.8ad6		ad f3 02	lda $02f3	                lda sramWorkspace.sramAddress+1 ; sram address MSB
299	.8ad9		95 01		sta $01,x	                sta 1,x                    ;
300	.8adb		6d f0 02	adc $02f0	                adc sramWorkspace.length+1 ; form end address MSB
301	.8ade		8d f0 02	sta $02f0	                sta sramWorkspace.length+1
302	.8ae1		38		sec		                sec
303	.8ae2		20 73 8d	jsr $8d73	                jsr initSRAMTransferDataPointer
304	.8ae5						L8D0F:
305	.8ae5		cc ef 02	cpy $02ef	                cpy sramWorkspace.length+0
306	.8ae8		d0 08		bne $8af2	                bne L8D1C
307	.8aea		b5 01		lda $01,x	                lda 1,x
308	.8aec		cd f0 02	cmp $02f0	                cmp sramWorkspace.length+1
309	.8aef		d0 01		bne $8af2	                bne L8D1C
310	.8af1		60		rts		                rts

312	.8af2						L8D1C:
313	.8af2		2c ee 02	bit $02ee	                bit sramWorkspace.type
314	.8af5		50 32		bvc $8b29	                bvc L8D53       ; taken if absolute addressing
315	.8af7		b5 01		lda $01,x	                lda 1,x         ; get sideways RAM pointer
316	.8af9		c9 c0		cmp #$c0	                cmp #>(dataBankStart+dataBankSize) ; gone past end of bank?
317	.8afb		90 2c		bcc $8b29	                bcc L8D53       ; taken if not past end of bank
318	.8afd		a9 80		lda #$80	                lda #>dataBankStart
319	.8aff		95 01		sta $01,x	                sta 1,x                    ; reset pointer MSB
320	.8b01		ee f1 02	inc $02f1	                inc sramWorkspace.bank ; move to next bank
321	.8b04		ad f1 02	lda $02f1	                lda sramWorkspace.bank
322	.8b07		c9 08		cmp #$08	                cmp #8
323	.8b09		b0 2e		bcs $8b39	                bcs jmpBadAddressError ; bad address error if definitely past end of pseudo-addressable area
324	.8b0b		da		phx		                phx
325	.8b0c		20 21 8a	jsr $8a21	                jsr checkROMID  ; perform other ROM ID checks
326	.8b0f		d0 28		bne $8b39	                bne jmpBadAddressError ; bad address error if bad
327	.8b11		fa		plx		                plx
328	.8b12		a0 10		ldy #$10	                ldy #<dataBankStart

330							                ; Subtract dataBankSize from count of bytes remaining
331	.8b14		ad ef 02	lda $02ef	                lda sramWorkspace.length+0
332	.8b17		38		sec		                sec
333	.8b18		e9 f0		sbc #$f0	                sbc #<dataBankSize
334	.8b1a		8d ef 02	sta $02ef	                sta sramWorkspace.length+0
335	.8b1d		ad f0 02	lda $02f0	                lda sramWorkspace.length+1
336	.8b20		e9 3f		sbc #$3f	                sbc #>dataBankSize
337	.8b22		8d f0 02	sta $02f0	                sta sramWorkspace.length+1
338	.8b25		18		clc		                clc
339	.8b26		20 73 8d	jsr $8d73	                jsr initSRAMTransferDataPointer

341	.8b29						L8D53:
342	.8b29		ad f1 02	lda $02f1	                lda sramWorkspace.bank
343	.8b2c		18		clc		                clc

345	.8b2d						locret_8D57:
346	.8b2d		60		rts		                rts

348							;-------------------------------------------------------------------------

350	.8b2e						parse16BitHexAddressFromCommandLine:
351	.8b2e		20 f9 92	jsr $92f9	                jsr parseHexAddressFromCommandLine
352	.8b31						checkParameterBlockAddressIs16Bit:
353	.8b31		bd ef 02	lda $02ef,x	                lda sramWorkspace.length+0,x
354	.8b34		1d f0 02	ora $02f0,x	                ora sramWorkspace.length+1,x
355	.8b37		f0 f4		beq $8b2d	                beq locret_8D57

357	.8b39						jmpBadAddressError:
358	.8b39		4c e9 92	jmp $92e9	                jmp badAddressError

360							;-------------------------------------------------------------------------
361							;
362							; Read I from command line. From Master Compact app note: ``A facility
363							; to load an SRAM image and update the MOS ROM type table has been
364							; added. An "I" should be added to the *SRLOAD command.''
365							;
366							                .if version==350||version>=500
367	.8b3c						readImmediateFlag:
368	.8b3c		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
369	.8b3f		29 df		and #$df	                and #$DF
370	.8b41		c9 49		cmp #$49	                cmp #'I'
371	.8b43		d0 0d		bne $8b52	                bne L8D7C
372	.8b45		c8		iny		                iny
373	.8b46		ad ee 02	lda $02ee	                lda sramWorkspace.type
374	.8b49		c9 80		cmp #$80	                cmp #$80
375	.8b4b		d0 3d		bne $8b8a	                bne jmpBadCommandError8DB4 ; "Bad command" if not *SRLOAD
376	.8b4d		09 20		ora #$20	                ora #$20                   ; set bit 5 to indicate I
377	.8b4f		8d ee 02	sta $02ee	                sta sramWorkspace.type

379	.8b52						L8D7C:
380	.8b52		4c 72 f2	jmp $f272	                jmp skipSpacesAndCheckForCRInStringInput
381							                .endif

383							;-------------------------------------------------------------------------
384							;
385							; C=0 for *SRREAD
386							;
387	.8b55						starSRREADOrStarSRWRITE:
388							                .if version==400
390							                .else
391	.8b55		0a		asl a		                asl a
392	.8b56		8d ee 02	sta $02ee	                sta sramWorkspace.type
393							                .endif

395	.8b59		a2 09		ldx #$09	                ldx #sramWorkspace.dataAddress-osfileParameterBlock
396	.8b5b		20 f9 92	jsr $92f9	                jsr parseHexAddressFromCommandLine
397	.8b5e		20 65 8d	jsr $8d65	                jsr checkForPlusInCommandLine
398	.8b61		a2 02		ldx #$02	                ldx #sramWorkspace.length-osfileParameterBlock
399	.8b63		20 f9 92	jsr $92f9	                jsr parseHexAddressFromCommandLine
400	.8b66		70 10		bvs $8b78	                bvs L8DA2 ; taken if + encountered, so +2 is already the length

402							                ; sramWorkspace.length is actually the end address -
403							                ; substract start address to turn it into the length.
404	.8b68		a2 fc		ldx #$fc	                ldx #$FC

406	.8b6a						L8D94:
407	.8b6a		bd f3 01	lda $01f3,x	                lda sramWorkspace.length-$FC,x
408	.8b6d		fd fa 01	sbc $01fa,x	                sbc sramWorkspace.dataAddress-$FC,x
409	.8b70		9d f3 01	sta $01f3,x	                sta sramWorkspace.length-$FC,x
410	.8b73		e8		inx		                inx
411	.8b74		d0 f4		bne $8b6a	                bne L8D94
412	.8b76		90 c1		bcc $8b39	                bcc jmpBadAddressError ; taken if end<start

414	.8b78						L8DA2:
415							                ; Check length is a 16 bit quantity
416	.8b78		a2 02		ldx #$02	                ldx #sramWorkspace.length-osfileParameterBlock
417	.8b7a		20 31 8b	jsr $8b31	                jsr checkParameterBlockAddressIs16Bit

419							                ; Parse SRAM address
420	.8b7d		a2 05		ldx #$05	                ldx #sramWorkspace.sramAddress-osfileParameterBlock
421	.8b7f		20 2e 8b	jsr $8b2e	                jsr parse16BitHexAddressFromCommandLine

423							                ; Read ROM ID
424	.8b82		20 55 8a	jsr $8a55	                jsr readROMID

426							                .if version>=500||version==350
427	.8b85		20 3c 8b	jsr $8b3c	                jsr readImmediateFlag
428							                .endif
429	.8b88		f0 03		beq $8b8d	                beq doSidewaysRAMBlockTransfer

431	.8b8a						jmpBadCommandError8DB4:
432	.8b8a		4c 29 f9	jmp $f929	                jmp badCommandError

434	.8b8d						doSidewaysRAMBlockTransfer:
435	.8b8d		08		php		                php
436	.8b8e		20 ec 89	jsr $89ec	                jsr convertSidewaysRAMPseudoAddress
437	.8b91		f0 03		beq $8b96	                beq L8DC0
438	.8b93		20 4a 8a	jsr $8a4a	                jsr badIdError  ; should be a jmp; will never return
439	.8b96						L8DC0:
440	.8b96		20 51 8d	jsr $8d51	                jsr L8F40
441							                .if includeTubeSupport
442	.8b99		ad f8 02	lda $02f8	                lda sramWorkspace.dataAddress+2
443	.8b9c		2d f9 02	and $02f9	                and sramWorkspace.dataAddress+3
444	.8b9f		1a		inc a		                inc a
445	.8ba0		2d 7a 02	and $027a	                and tubePresence
446	.8ba3		d0 07		bne $8bac	                bne L8952
447							                .endif
448	.8ba5		20 af 8a	jsr $8aaf	                jsr L8CD9
449	.8ba8		28		plp		                plp
450							                .if version==400
452							                .else
453	.8ba9		4c e1 f9	jmp $f9e1	                jmp LF8D1
454							                .endif

456							;-------------------------------------------------------------------------

458							                .if includeTubeSupport
459	.8bac						L8952:
460	.8bac		a9 c8		lda #$c8	                lda #$c8    ; 8 = claimant code for sideways RAM utils
461	.8bae		20 06 04	jsr $0406	                jsr $0406   ; claim Tube
462	.8bb1		90 f9		bcc $8bac	                bcc L8952       ; if it failed, try again
463	.8bb3		a9 00		lda #$00	                lda #0          ; multi byte parasite->host
464	.8bb5		2c ee 02	bit $02ee	                bit sramWorkspace.type
465	.8bb8		30 01		bmi $8bbb	                bmi +           ; taken if writing to sideways RAM
466	.8bba		1a		inc a		                inc a           ; multi byte host->parasite
467	.8bbb						+
468	.8bbb		a2 f6		ldx #$f6	                ldx #<sramWorkspace.dataAddress
469	.8bbd		a0 02		ldy #$02	                ldy #>sramWorkspace.dataAddress
470	.8bbf		20 06 04	jsr $0406	                jsr $0406       ; begin transfer to/from data address
471	.8bc2		20 c0 8a	jsr $8ac0	                jsr L8CEA
472	.8bc5		b0 03		bcs $8bca	                bcs L8970
473	.8bc7		20 67 f9	jsr $f967	                jsr transferSidewaysRAMOverTube
474	.8bca						L8970:
475	.8bca		a9 88		lda #$88	                lda #$88
476	.8bcc		20 06 04	jsr $0406	                jsr $0406
477	.8bcf		28		plp		                plp
478	.8bd0		60		rts		                rts
479							                .endif

481							;-------------------------------------------------------------------------

483	.8bd1						starSRLOADOrStarSRSAVE:
484							                .if version==400
486							                .else
487	.8bd1		0a		asl a		                asl a
488	.8bd2		8d ee 02	sta $02ee	                sta sramWorkspace.type
489							                .endif
490	.8bd5		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
491	.8bd8		86 f2		stx $f2		                stx stringInputBufferAddress
492	.8bda		84 f3		sty $f3		                sty stringInputBufferAddress+1
493	.8bdc		8e ef 02	stx $02ef	                stx sramWorkspace.length+0
494	.8bdf		8c f0 02	sty $02f0	                sty sramWorkspace.length+1
495	.8be2		a0 00		ldy #$00	                ldy #0
496	.8be4		20 e0 f1	jsr $f1e0	                jsr gsinitForFilenameParsing

498	.8be7						L8DE0:
499	.8be7		20 f2 f1	jsr $f1f2	                jsr gsreadEntryPoint
500	.8bea		90 fb		bcc $8be7	                bcc L8DE0
501	.8bec		a2 05		ldx #$05	                ldx #5
502	.8bee		20 2e 8b	jsr $8b2e	                jsr parse16BitHexAddressFromCommandLine
503	.8bf1		2c ee 02	bit $02ee	                bit sramWorkspace.type
504	.8bf4		30 1e		bmi $8c14	                bmi L8E0D
505	.8bf6		20 65 8d	jsr $8d65	                jsr checkForPlusInCommandLine
506	.8bf9		a2 07		ldx #$07	                ldx #7
507	.8bfb		20 2e 8b	jsr $8b2e	                jsr parse16BitHexAddressFromCommandLine
508	.8bfe		70 14		bvs $8c14	                bvs L8E0D
509	.8c00		38		sec		                sec
510	.8c01		a2 fe		ldx #$fe	                ldx #$FE

512	.8c03						L8DFC:
513	.8c03		bd f6 01	lda $01f6,x	                lda sramWorkspace.sramAddress+2-$FE,x
514	.8c06		fd f4 01	sbc $01f4,x	                sbc sramWorkspace.sramAddress+0-$FE,x
515	.8c09		9d f6 01	sta $01f6,x	                sta sramWorkspace.sramAddress+2-$FE,x
516	.8c0c		e8		inx		                inx
517	.8c0d		d0 f4		bne $8c03	                bne L8DFC
518	.8c0f		b0 03		bcs $8c14	                bcs L8E0D
519	.8c11		4c 39 8b	jmp $8b39	                jmp jmpBadAddressError

521							;-------------------------------------------------------------------------

523	.8c14						L8E0D:
524	.8c14		20 55 8a	jsr $8a55	                jsr readROMID
525	.8c17		9c f8 02	stz $02f8	                stz sramWorkspace.dataAddress+2
526							                .if version==350
527	.8c1a		a2 ff		ldx #$ff	                ldx #$ff
530							                .endif
531							                .if version>=500||version==350
532	.8c1c		20 3c 8b	jsr $8b3c	                jsr readImmediateFlag
533							                .endif
534	.8c1f		29 df		and #$df	                and #$DF
535							                .if version==350
536	.8c21		c8		iny		                iny
537							                .endif
538	.8c22		c9 51		cmp #$51	                cmp #'Q'
539							                .if version==350
540	.8c24		f0 0b		beq $8c31	                beq L8E20
543							                .endif
544							                .if version==350
545	.8c26		88		dey		                dey
546							                .endif
547							                .if version==350
548	.8c27		9c f6 02	stz $02f6	                stz sramWorkspace.dataAddress+0
549	.8c2a		a2 dc		ldx #$dc	                ldx #>hazel.commandLine
550	.8c2c		8e f7 02	stx $02f7	                stx sramWorkspace.dataAddress+1
551	.8c2f		a2 03		ldx #$03	                ldx #$03
555							                .endif

557	.8c31						L8E20:
558	.8c31		8e f9 02	stx $02f9	                stx sramWorkspace.dataAddress+3
559	.8c34		ae 34 fe	ldx $fe34	                ldx ACCCON
560							                .if version==400
562							                .else
563	.8c37		20 3c 8b	jsr $8b3c	                jsr readImmediateFlag
564							                .endif
565	.8c3a		f0 16		beq $8c52	                beq L8E41
566	.8c3c		4c 8a 8b	jmp $8b8a	                jmp jmpBadCommandError8DB4

568							;-------------------------------------------------------------------------

570	.8c3f						osword43:
571	.8c3f		ae 34 fe	ldx $fe34	                ldx ACCCON
572	.8c42		20 fa ec	jsr $ecfa	                jsr selectHAZEL
573	.8c45		9c c6 df	stz $dfc6	                stz hazel.tempFSFlag
574	.8c48		a0 0b		ldy #$0b	                ldy #$B

576	.8c4a						L8E39:
577	.8c4a		b1 f0		lda ($f0),y	                lda (originalX),y
578	.8c4c		99 ee 02	sta $02ee,y	                sta sramWorkspace.type,y
579	.8c4f		88		dey		                dey
580	.8c50		10 f8		bpl $8c4a	                bpl L8E39
581							                .if version==400
584							                .endif

586	.8c52						L8E41:
587	.8c52		08		php		                php
588	.8c53		da		phx		                phx
589	.8c54		20 ec 89	jsr $89ec	                jsr convertSidewaysRAMPseudoAddress
590	.8c57		f0 03		beq $8c5c	                beq L8E4B
591	.8c59		4c 4a 8a	jmp $8a4a	                jmp badIdError
592	.8c5c						L8E4B:
593	.8c5c		ad f9 02	lda $02f9	                lda sramWorkspace.dataAddress+3
594	.8c5f		30 0b		bmi $8c6c	                bmi L8E5B
595	.8c61		0d f8 02	ora $02f8	                ora sramWorkspace.dataAddress+2
596	.8c64		d0 1d		bne $8c83	                bne L8E72
597	.8c66		a9 02		lda #$02	                lda #2
598	.8c68		a0 dd		ldy #$dd	                ldy #>hazel.ddxx
599	.8c6a		80 0b		bra $8c77	                bra L8E66

601							;-------------------------------------------------------------------------

603	.8c6c						L8E5B:
604	.8c6c		20 25 f1	jsr $f125	                jsr osbyte84
605	.8c6f		98		tya		                tya
606	.8c70		38		sec		                sec
607	.8c71		ed 44 02	sbc $0244	                sbc oshwm
608	.8c74		ac 44 02	ldy $0244	                ldy oshwm

610	.8c77						L8E66:
611	.8c77		9c f6 02	stz $02f6	                stz sramWorkspace.dataAddress+0
612	.8c7a		8c f7 02	sty $02f7	                sty sramWorkspace.dataAddress+1
613	.8c7d		9c f8 02	stz $02f8	                stz sramWorkspace.dataAddress+2
614	.8c80		8d f9 02	sta $02f9	                sta sramWorkspace.dataAddress+3

616	.8c83						L8E72:
617	.8c83		2c ee 02	bit $02ee	                bit sramWorkspace.type
618	.8c86		10 38		bpl $8cc0	                bpl L8EAF
619	.8c88		a9 40		lda #$40	                lda #findOpenForRead
620	.8c8a		20 2c 8d	jsr $8d2c	                jsr sramOpenFile

622	.8c8d						L8E7C:
623	.8c8d		38		sec		                sec
624	.8c8e		20 fe 8c	jsr $8cfe	                jsr L8EED
625	.8c91		a9 04		lda #$04	                lda #gbpbGetBytesCurrentPTR
626	.8c93		20 25 8d	jsr $8d25	                jsr sramOSGBPB
627	.8c96		08		php		                php
628	.8c97		90 0e		bcc $8ca7	                bcc L8E96
629	.8c99		a2 fe		ldx #$fe	                ldx #$FE

631	.8c9b						L8E8A:
632	.8c9b		bd f1 01	lda $01f1,x	                lda sramWorkspace.length+0-$FE,x

634	.8c9e						L8E8D:
635	.8c9e		fd ce de	sbc $dece,x	                sbc hazel.moveOSGBPB+OSGBPBParameterBlock.count+0-$fe,x
636	.8ca1		9d f1 01	sta $01f1,x	                sta sramWorkspace.length+0-$FE,x
637	.8ca4		e8		inx		                inx
638	.8ca5		d0 f4		bne $8c9b	                bne L8E8A

640	.8ca7						L8E96:
641	.8ca7		20 af 8a	jsr $8aaf	                jsr L8CD9
642	.8caa		28		plp		                plp
643	.8cab		90 e0		bcc $8c8d	                bcc L8E7C

645	.8cad						L8E9C:
646	.8cad		ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle
647	.8cb0		9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
648	.8cb3		a9 00		lda #$00	                lda #0
649	.8cb5		20 ce ff	jsr $ffce	                jsr OSFIND
650	.8cb8		68		pla		                pla
651	.8cb9		8d 34 fe	sta $fe34	                sta ACCCON
652	.8cbc		28		plp		                plp
653							                .if version==400
655							                .else
656	.8cbd		4c e1 f9	jmp $f9e1	                jmp LF8D1
657							                .endif

659							;-------------------------------------------------------------------------

661	.8cc0						L8EAF:
662	.8cc0		a9 80		lda #$80	                lda #findOpenForWrite
663	.8cc2		20 2c 8d	jsr $8d2c	                jsr sramOpenFile

665	.8cc5						L8EB4:
666	.8cc5		38		sec		                sec
667	.8cc6		a2 fe		ldx #$fe	                ldx #$FE

669	.8cc8						L8EB7:
670	.8cc8		bd f6 01	lda $01f6,x	                lda sramWorkspace.sramAddress+2-$FE,x
671	.8ccb		9d b2 ff	sta $ffb2,x	                sta @w sramTransferPointers-$fe,x
672	.8cce		fd fa 01	sbc $01fa,x	                sbc sramWorkspace.dataAddress+2-$FE,x
673	.8cd1		9d f6 01	sta $01f6,x	                sta sramWorkspace.sramAddress+2-$FE,x
674	.8cd4		e8		inx		                inx
675	.8cd5		d0 f1		bne $8cc8	                bne L8EB7
676	.8cd7		0d f4 02	ora $02f4	                ora sramWorkspace.sramAddress+2
677	.8cda		08		php		                php
678	.8cdb		20 fe 8c	jsr $8cfe	                jsr L8EED
679	.8cde		20 af 8a	jsr $8aaf	                jsr L8CD9
680	.8ce1		a9 02		lda #$02	                lda #gbpbPutBytesCurrentPTR
681	.8ce3		20 25 8d	jsr $8d25	                jsr sramOSGBPB
682	.8ce6		28		plp		                plp
683	.8ce7		90 c4		bcc $8cad	                bcc L8E9C
684	.8ce9		f0 c2		beq $8cad	                beq L8E9C
685	.8ceb		80 d8		bra $8cc5	                bra L8EB4

687							;-------------------------------------------------------------------------

689							                .if version==400
694							                .endif

696							;-------------------------------------------------------------------------
697							;
698							; OSBYTE 68 (&44) - Test RAM presence [MasRef D.2-28]
699							;
700	.8ced						osbyte44:
701	.8ced		a9 00		lda #$00	                lda #0
702	.8cef		a2 07		ldx #$07	                ldx #7
703	.8cf1						osbyte44Loop:
704	.8cf1		48		pha		                pha
705	.8cf2		20 c7 f9	jsr $f9c7	                jsr isBankROM
706	.8cf5		68		pla		                pla
707	.8cf6		2a		rol a		                rol a
708	.8cf7		ca		dex		                dex
709	.8cf8		e0 04		cpx #$04	                cpx #4
710	.8cfa		b0 f5		bcs $8cf1	                bcs osbyte44Loop
711	.8cfc		aa		tax		                tax
712	.8cfd		60		rts		                rts

714							;-------------------------------------------------------------------------

716	.8cfe						L8EED:
717	.8cfe		ad d4 df	lda $dfd4	                lda hazel.moveSrcHandle
718	.8d01		8d c7 df	sta $dfc7	                sta hazel.moveOSGBPB.handle
719	.8d04		a2 01		ldx #$01	                ldx #1

721	.8d06						L8EF5:
722	.8d06		bd f6 02	lda $02f6,x	                lda sramWorkspace.dataAddress+0,x
723	.8d09		9d c8 df	sta $dfc8,x	                sta hazel.moveOSGBPB.addr,x
724	.8d0c		bd f8 02	lda $02f8,x	                lda sramWorkspace.dataAddress+2,x
725	.8d0f		b0 02		bcs $8d13	                bcs L8F02
726	.8d11		b5 b0		lda $b0,x	                lda sramTransferPointers.src,x

728	.8d13						L8F02:
729	.8d13		9d cc df	sta $dfcc,x	                sta hazel.moveOSGBPB.numBytes,x
730	.8d16		9d ef 02	sta $02ef,x	                sta sramWorkspace.length+0,x
731	.8d19		a9 ff		lda #$ff	                lda #$FF
732	.8d1b		9d ca df	sta $dfca,x	                sta hazel.moveOSGBPB.addr+2,x ; address is in I/O processor
733	.8d1e		9e ce df	stz $dfce,x	                stz hazel.moveOSGBPB.numBytes+2,x ; size is 16-bit quantity
734	.8d21		ca		dex		                dex
735	.8d22		10 e2		bpl $8d06	                bpl L8EF5
736	.8d24		60		rts		                rts


739							;-------------------------------------------------------------------------

741	.8d25						sramOSGBPB:
742	.8d25		a2 c7		ldx #$c7	                ldx #<hazel.moveOSGBPB
743	.8d27		a0 df		ldy #$df	                ldy #>hazel.moveOSGBPB
744	.8d29		4c d1 ff	jmp $ffd1	                jmp OSGBPB


747							;-------------------------------------------------------------------------

749	.8d2c						sramOpenFile:
750	.8d2c		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
751	.8d2f		ae ef 02	ldx $02ef	                ldx sramWorkspace.length+0
752	.8d32		ac f0 02	ldy $02f0	                ldy sramWorkspace.length+1
753	.8d35		20 ce ff	jsr $ffce	                jsr OSFIND
754	.8d38		aa		tax		                tax
755	.8d39		d0 13		bne $8d4e	                bne sramFileFound
756	.8d3b		20 2f ab	jsr $ab2f	                jsr doFollowingError
757	>8d3e		d6				                .byte $D6
758	>8d3f		46 69 6c 65 20 6e 6f 74		                .text "File not found"
	>8d47		20 66 6f 75 6e 64
759	>8d4d		00				                .byte 0

761	.8d4e						sramFileFound:
762	.8d4e		8d d4 df	sta $dfd4	                sta hazel.moveSrcHandle
763	.8d51						L8F40:
764	.8d51		ae f1 02	ldx $02f1	                ldx sramWorkspace.bank ; ROM number of interest
765	.8d54		2c ee 02	bit $02ee	                bit sramWorkspace.type
766	.8d57		10 07		bpl $8d60	                bpl rts8F4F ; taken if reading
767	.8d59		70 05		bvs $8d60	                bvs rts8F4F ; taken if pseudo addressing

769							                ; writing, absolute addressing
770	.8d5b						setROMXType6502:
771	.8d5b		a9 02		lda #$02	                lda #romType6502
772	.8d5d		9d a1 02	sta $02a1,x	                sta romInformationTable,x

774	.8d60						rts8F4F:
775	.8d60		60		rts		                rts


778							;-------------------------------------------------------------------------

780	.8d61						sramBank4567ModeMasks:
781	>8d61		01				                .byte 1         ; bank 4
782	>8d62		02				                .byte 2         ; bank 5
783	>8d63		04				                .byte 4         ; bank 6
784	>8d64		08				                .byte 8         ; bank 7

786							;-------------------------------------------------------------------------
787							;
788							; Check to see if next char on command line is +.
789							;
790							; Entry:
791							;
792							; (stringInputBufferAddress),y = next char on command line
793							;
794							; Exit:
795							;
796							; V=0 if not +
797							;
798							; V=1 if +. (stringInputBufferAddress),y = next non-space after the +

800	.8d65						checkForPlusInCommandLine:
801	.8d65		b8		clv		                clv
802	.8d66		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
803	.8d68		c9 2b		cmp #$2b	                cmp #'+'
804	.8d6a		d0 06		bne $8d72	                bne locret_8F61
805	.8d6c		2c 5e e3	bit $e35e	                bit valueFF
806	.8d6f		20 71 f2	jsr $f271	                jsr incAndSkipSpaces

808	.8d72						locret_8F61:
809	.8d72		60		rts		                rts


812							;-------------------------------------------------------------------------
813							;
814							; Adjust sram transfer data pointer so that the same Y register can be
815							; used for both sram pointer and data pointer.
816							;
817							; Entry:
818							;
819							; X = offset of sram transfer sram pointer (0=src, 2=dest)
820							; Y = value to subtract from sram transfer data pointer
821							;
822							; C=1 = initialise sram transfer data pointer from data address
823							;
824							; Exit:
825							;
826							; sram transfer data pointer has had Y subtracted
827							;
828	.8d73						initSRAMTransferDataPointer: .proc
829	.8d73		da		phx		                phx
830							                ; select the non-sram data pointer
831	.8d74		8a		txa		                txa
832	.8d75		49 02		eor #$02	                eor #sramTransferPointers.src^sramTransferPointers.dest
833	.8d77		aa		tax		                tax
834	.8d78		90 0a		bcc $8d84	                bcc subtractY

836							                ; store data address in the non-sram pointer
837	.8d7a		ad f6 02	lda $02f6	                lda sramWorkspace.dataAddress+0
838	.8d7d		95 00		sta $00,x	                sta 0,x
839	.8d7f		ad f7 02	lda $02f7	                lda sramWorkspace.dataAddress+1
840	.8d82		95 01		sta $01,x	                sta 1,x

842	.8d84						subtractY:
843	.8d84		8c ed 02	sty $02ed	                sty sramWorkspace.temp ; sram address LSB
844	.8d87		b5 00		lda $00,x	                lda 0,x
845	.8d89		38		sec		                sec
846	.8d8a		ed ed 02	sbc $02ed	                sbc sramWorkspace.temp
847	.8d8d		95 00		sta $00,x	                sta 0,x
848	.8d8f		b0 02		bcs $8d93	                bcs +
849	.8d91		d6 01		dec $01,x	                dec 1,x
850	.8d93						+
851	.8d93		fa		plx		                plx
852	.8d94		60		rts		                rts
853							                .endproc

855							;-------------------------------------------------------------------------
856							;
857							; Get bank mode: pseudo, or absolute.
858							;
859							; (Only banks 4-7 can be used with pseudo addressing, but you can test
860							; any.)
861							;
862							; Entry:
863							;
864							; X = bank of interest
865							;
866							; Exit:
867							;
868							; A=$00 if absolute (C=1 as well, if bank could only ever be absolute)
869							;
870							; A=$40 if pseudo

872	.8d95						sramGetBankMode:
873	.8d95		e0 04		cpx #$04	                cpx #4
874	.8d97		90 1c		bcc $8db5	                bcc bankModeIsInherentlyAbsolute ; taken if <4
875	.8d99		e0 08		cpx #$08	                cpx #8
876	.8d9b		b0 18		bcs $8db5	                bcs bankModeIsInherentlyAbsolute ; taken if >=8

878	.8d9d						osbyte45:
879							                ; When entered as OSBYTE $45, the X register is bogus,
880							                ; so the table lookup could read junk and the AND
881							                ; could end up meaningless. But that doesn't matter:
882							                ; it's only the value in X on exit that's important.
883	.8d9d		ac 34 fe	ldy $fe34	                ldy ACCCON
884	.8da0		20 fa ec	jsr $ecfa	                jsr selectHAZEL ; engage HAZEL
885	.8da3		bd 5d 8d	lda $8d5d,x	                lda sramBank4567ModeMasks-4,x ; acquire mask: 1/2/4/8 for banks
886							                                 ; 4/5/6/7 respectively
887	.8da6		ae de df	ldx $dfde	                ldx hazel.sramBankModes ; load current settings into X, in case this is OSBYTE $45
888	.8da9		2d de df	and $dfde	                and hazel.sramBankModes
889	.8dac		f0 02		beq $8db0	                beq +           ; taken with A=$00 if bank of interest
890							                                ; is absolute
891	.8dae		a9 40		lda #$40	                lda #$40        ; indicate pseudo
892	.8db0						+
893	.8db0		8c 34 fe	sty $fe34	                sty ACCCON
894	.8db3		18		clc		                clc
895	.8db4		60		rts		                rts

897	.8db5						bankModeIsInherentlyAbsolute:
898	.8db5		38		sec		                sec
899	.8db6		a9 00		lda #$00	                lda #0
900	.8db8		60		rts		                rts


:7	;******  Return to file: src/terminal.s65

930							                .include "osbyte_osword_table.s65"

:10	;******  Processing file: src/osbyte_osword_table.s65

1							; OSBYTE Dispatch Table
2							; =====================

4							; TODO structure probably the same as
5							; https://tobylobster.github.io/mos/mos/S-s15.html#SP1...

7							; entry:
8							;
9							; A = OSBYTE A
10							;
11							; X = OSBYTE X
12							;
13							; Y = OSBYTE Y
14							;
15							; ?originalA, ?originalX, ?originalY = OSBYTE arguments
16							;
17							; C=1
18							;
19							; N/Z set as per X
20							;

22	.8db9						osbyteAndOSWORDRoutineTable:
23							                ;Display MOS version D.2-18
24	>8db9		d1 ee				                .word osbyte00

26							                ;Write user flag D.2-18
27	>8dbb		31 f0				                .word osbyte01

29							                ;Specify input stream D.2-18
30							                .if version==400
32							                .else
33	>8dbd		00 ec				                .word osbyte02
34							                .endif

36							                ;Specify output stream D.2-19
37	>8dbf		06 f0				                .word osbyte03

39							                ;Enable/disable cursor editing
40	>8dc1		39 f0				                .word osbyte04

42							                ;Write printer driver type D.2-20
43	>8dc3		1f f0				                .word osbyte05

45							                ;Write printer ignore character D.2-21
46	>8dc5		16 f0				                .word osbyte06

48							                ;Write RS423 receive rate D.2-21
49							                .if version==400
51							                .else
52	>8dc7		b9 eb				                .word osbyte07
53							                .endif

55							                ;Write RS423 transmit rate D.2-22
56							                .if version==400
58							                .else
59	>8dc9		b7 eb				                .word osbyte08
60							                .endif

62							                ;Write duration of first colour D.2-22
63	>8dcb		de eb				                .word osbyte09

65							                ;Write duration of second colour D.2-22
66	>8dcd		e0 eb				                .word osbyte0A

68							                ;Write keyboard auto-repeat delay D.2-22
69	>8dcf		37 f0				                .word osbyte0B

71							                ;Write keyboard auto-repeat rate D.2-23
72	>8dd1		35 f0				                .word osbyte0C

74							                ;Disable event D.2-23
75	>8dd3		26 ec				                .word osbyte0D

77							                ;Enable event D.2-24
78	>8dd5		27 ec				                .word osbyte0E

80							                ;Flush buffer D.2-24
81	>8dd7		0f e9				                .word osbyte0F

83							                ;Write number of ADC channels D.2-25
84							                .if version==400
86							                .else
87	>8dd9		33 ec				                .word osbyte10
88							                .endif

90							                ;Write next ADC channel to be sampled D.2-25
91							                .if version==400
93							                .else
94	>8ddb		68 e7				                .word osbyte11
95							                .endif

97							                ;Reset soft keys D.2-26
98	>8ddd		85 f0				                .word osbyte12

100							                ;Wait for vertical sync D.2-26
101	>8ddf		58 f0				                .word osbyte13

103							                ;Restore default font definitions D.2-26
104	>8de1		38 97				                .word osbyte14

106							                ;Flush selected buffer D.2-27
107	>8de3		1b e9				                .word osbyte15

109							                ;Increment ROM polling semaphore D.2-27
110	>8de5		90 f1				                .word osbyte16

112							                ;Decrement ROM polling semaphore D.2-27
113	>8de7		94 f1				                .word osbyte17

115							                ; Reserved
116	>8de9		d0 ec				                .word osbyteUnused

118							                ;Restore a group of font definitions D.2-28
119	>8deb		81 f1				                .word selectTerminalROMAndOSBYTE19

121							                ; Test RAM presence D.2-28
122							                .if version==350
123	>8ded		ed 8c				                .word osbyte44
126							                .endif

128							                ; Test pseudo/absolute use of bank D.2-29
129							                .if version==350
130	>8def		9d 8d				                .word osbyte45
133							                .endif

135							                ;Write 1MHz bus selection status D.2-29
136	>8df1		e1 ed				                .word osbyte6B

138							                ;Write usage of main/shadow memory D.2-30
139	>8df3		e5 ed				                .word osbyte6C

141							                ;Make temporary Filing System permanent D.2-30
142	>8df5		74 f1				                .word osbyte6D

144							                ;Unused
145	>8df7		d0 ec				                .word osbyteUnused

147							                ;Unused
148	>8df9		d0 ec				                .word osbyteUnused

150							                ;Select main/shadow memory for VDU access D.2-31
151	>8dfb		a4 ec				                .word osbyte70

153							                ;Select main/shadow memory for display D.2-31
154	>8dfd		b4 ec				                .word osbyte71

156							                ;Write usage of shadow memory D.2-31
157	>8dff		1b f0				                .word osbyte72

159							                ;Unused
160	>8e01		aa ff				                .word rtsFFAA

162							                ;Unused
163	>8e03		aa ff				                .word rtsFFAA

165							                ;Read VDU status D.2-32
166	>8e05		16 ef				                .word osbyte75

168							                ;Reflect keyboard status in keyboard LEDs D.2-33
169	>8e07		a3 f1				                .word osbyte76

171							                ;Close all *SPOOL/*SPOOLON or *EXEC files D.2-33
172							                .if version==350
173	>8e09		c1 93				                .word osbyte77
176							                .endif

178							                ;Write keys pressed information D.2-33
179	>8e0b		29 f6				                .word osbyte78

181							                ;Keyboard scan D.2-33
182	>8e0d		20 f6				                .word callKEYV

184							                ;Keyboard scan from 16 decimal
185	>8e0f		31 f6				                .word osbyte7A

187							                ;Inform MOS of printer driver going dormant
188	>8e11		f9 e8				                .word osbyte7B

190							                ;Clear escape condition
191	>8e13		9e eb				                .word osbyte7C

193							                ;Set escape condition
194	>8e15		9f eb				                .word osbyte7D

196							                ;Acknowledge escape condition
197	>8e17		84 eb				                .word osbyte7E

199							                ;Check for end of file on an opened file
200	>8e19		4e f1				                .word osbyte7F

202							                ;Read ADC channel or get buffer status
203							                .if version==400
205							                .else
206	>8e1b		81 ec				                .word osbyte80
207							                .endif

209							                ;Read key with time limit
210	>8e1d		40 ec				                .word osbyte81

212							                ;Read machine high order address
213	>8e1f		57 ec				                .word osbyte82

215							                ;Read Operating System High Water Mark (OSHWM)
216	>8e21		23 f6				                .word osbyte83

218							                ;Read top of user RAM
219	>8e23		25 f1				                .word osbyte84

221							                ;Read top of user RAM for given mode
222	>8e25		3b f1				                .word osbyte85

224							                ;Read text cursor position
225	>8e27		67 e2				                .word osbyte86

227							                ;Read screen mode and character at text cursor position
228	>8e29		47 f1				                .word osbyte87

230							                ;Execute user code
231	>8e2b		7f eb				                .word osbyte88

233							                .if version<400
234	>8e2d		ad eb				                .word osbyte89 ;Switch cassette motor relay
239							                .endif

241							                ;Insert character code into buffer
242	>8e2f		03 ea				                .word osbyte8A

244							                ;Write Filing System options
245	>8e31		4d f1				                .word osbyte8B

247							                .if version<400
248	>8e33		da ec				                .word osbyte8C8D ;Select Cassette Filing System
251							                .endif


254							                ;Select ROM Filing System
255	>8e35		da ec				                .word osbyte8C8D

257							                ;Enter language ROM
258	>8e37		78 e4				                .word osbyte8E

260							                ;Issue paged ROM service request
261	>8e39		46 ed				                .word osbyte8F

263							                ;Set vertical screen shift and interlace option
264	>8e3b		e5 f2				                .word osbyte90

266							                ;Get character from buffer
267	>8e3d		b8 e9				                .word osbyte91

269							                ;Read from FRED (&FC00 - &FCFF)
270	>8e3f		bc f5				                .word osbyte92

272							                ;Write to FRED (&FC00 - &FCFF)
273	>8e41		00 f3				                .word osbyte93

275							                ;Read from JIM (&FD00 - &FDFF)
276	>8e43		cc f5				                .word osbyte94

278							                ;Write to JIM (&FD00 - &FDFF)
279	>8e45		f6 f2				                .word osbyte95

281							                ;Read from SHEILA (&FE00 - &FEFF)
282	>8e47		ab ff				                .word osbyte96

284							                ;Write to SHEILA (&FE00 - &FEFF)
285	>8e49		fb f2				                .word osbyte97

287							                ;Examine buffer status
288	>8e4b		b3 e9				                .word osbyte98

290							                ;Insert character code into buffer checking for escape
291							                .if version==400
293							                .else
294	>8e4d		47 ea				                .word osbyte99
295							                .endif

297							                ;Write video ULA control register
298	>8e4f		c2 f1				                .word osbyte9A

300							                ;Write to video ULA palette register and copy
301	>8e51		d3 f1				                .word osbyte9B

303							                ;Read/write serial ACIA control register and copy
304							                .if version==400
306							                .else
307	>8e53		de e8				                .word osbyte9C
308							                .endif

310							                ;Write byte across Tube
311	>8e55		af ff				                .word osbyte9D

313							                ;reserved for the speech system
314	>8e57		d0 ec				                .word osbyteUnused

316							                ;reserved for the speech system
317	>8e59		d0 ec				                .word osbyteUnused

319							                ;Read VDU variable value
320	>8e5b		62 f0				                .word osbyteA0

322							                ;Read CMOS RAM
323							                .if version==350
324	>8e5d		9a 96				                .word readCMOSByte
327							                .endif

329							                ;Write CMOS RAM
330							                .if version==350
331	>8e5f		c8 96				                .word writeCMOSByte
334							                .endif

336							                ;reserved for applications software
337	>8e61		d0 ec				                .word osbyteUnused

339							                ;Check processor type
340	>8e63		02 e5				                .word osbyteA4

342							                ;Read output cursor position
343	>8e65		3b e2				                .word osbyteA5

345							                ;handle osbyte A6-FF
346	>8e67		3e f0				                .word osbyteA6

348							                ;*LINE - not part of the above table???
349	>8e69		81 eb				                .word callUSERV

351							;-------------------------------------------------------------------------
352							;
353							; OSWORD dispatch table. Must follow on from the OSBYTE table.
354							;
355							; entry:
356							;
357							; A = 0th byte of parameter block
358							;
359							; X = OSWORD X
360							;
361							; Y = 0
362							;
363							; ?originalA, ?originalX, ?originalY = OSWORD arguments
364							;
365							; C=1
366							;
367							; N/Z set as per X
368							;
369	.8e6b						oswordRoutineTable:

371							;Read line from input stream to memory
372	>8e6b		92 ef				                .word osword00

374							                ;Read system clock
375	>8e6d		65 ef				                .word osword01

377							                ;Write system clock
378	>8e6f		78 ef				                .word osword02

380							                ;Read interval timer
381	>8e71		61 ef				                .word osword03

383							                ;Write interval timer
384	>8e73		74 ef				                .word osword04

386							                ;Read byte from I/O processor memory
387	>8e75		bd ee				                .word osword05

389							                ;Write byte to I/O processor memory
390	>8e77		f3 ed				                .word osword06

392							                ;Generate a sound
393	>8e79		de ee				                .word osword07

395							                ;Define a sound envelope
396	>8e7b		3f ef				                .word osword08

398							                ;Read pixel logical colour
399	>8e7d		bb f0				                .word osword09

401							                ;Read a character definition
402	>8e7f		e0 f0				                .word osword0A

404							                ;Read the palette
405	>8e81		aa f0				                .word osword0B

407							                ;Write the palette
408	>8e83		f8 f0				                .word osword0C

410							                ;Read current and previous graphics cursor positions
411	>8e85		06 f1				                .word osword0D

413							                ;Read CMOS clock
414	>8e87		11 ee				                .word selectTerminalROMAndOSWORD0E

416							                ;Write CMOS clock
417							                .if version==350
418	>8e89		39 94				                .word osword0F
421							                .endif

423							                .if version>=350
424	.8e8b						osword42AndAboveRoutineTable:
425							                ; Sideways RAM Block Transfer
426							                .if version==350
427	>8e8b		c8 89				                .word osword42
430							                .endif

432							                ; Sideways RAM Load/Save
433							                .if version==350
434	>8e8d		3f 8c				                .word osword43
437							                .endif
438							                .endif


:7	;******  Return to file: src/terminal.s65

944							                .endif

946							;-------------------------------------------------------------------------

948							                .if version>=500
956							                .endif

958							;-------------------------------------------------------------------------

960							                .if !useTableDrivenConfigure
1078							                .endif

1080							;-------------------------------------------------------------------------
1081							;
1082							; [MasRef G.5-8]
1083							;
1084	.8e8f						starPRINT:
1085	.8e8f		a9 c0		lda #$c0	                lda #$C0
1086	.8e91		8d c2 df	sta $dfc2	                sta hazel.fsFlags
1087	.8e94		80 12		bra $8ea8	                bra L8ED2

1089							;-------------------------------------------------------------------------

1091	.8e96						starLIST:
1092	.8e96		4e c2 df	lsr $dfc2	                lsr hazel.fsFlags
1093	.8e99		9c c3 df	stz $dfc3	                stz hazel.lineNumberBCD+0
1094	.8e9c		9c c4 df	stz $dfc4	                stz hazel.lineNumberBCD+1
1095	.8e9f		80 04		bra $8ea5	                bra L8ECF

1097							;-------------------------------------------------------------------------

1099	.8ea1						starTYPE:
1100	.8ea1		38		sec		                sec
1101	.8ea2		6e c2 df	ror $dfc2	                ror hazel.fsFlags
1102	.8ea5						L8ECF:
1103	.8ea5		4e c2 df	lsr $dfc2	                lsr hazel.fsFlags
1104	.8ea8						L8ED2:
1105	.8ea8		9c c5 df	stz $dfc5	                stz hazel.lastCharPrinted
1106	.8eab		20 5f a5	jsr $a55f	                jsr openFileForReading
1107	.8eae						L8ED8:
1108	.8eae		24 ff		bit $ff		                bit $FF
1109	.8eb0		30 52		bmi $8f04	                bmi handleESCAPEWithFileOpen
1110	.8eb2		20 d7 ff	jsr $ffd7	                jsr OSBGET
1111	.8eb5		b0 2e		bcs $8ee5	                bcs closeFile
1112	.8eb7		2c c2 df	bit $dfc2	                bit hazel.fsFlags
1113	.8eba		70 05		bvs $8ec1	                bvs L8EEB
1114	.8ebc		48		pha		                pha
1115	.8ebd		20 cc 91	jsr $91cc	                jsr printLineNumber
1116	.8ec0		68		pla		                pla
1117	.8ec1						L8EEB:
1118	.8ec1		2c c2 df	bit $dfc2	                bit hazel.fsFlags
1119	.8ec4		30 14		bmi $8eda	                bmi L8F04
1120	.8ec6		c9 0d		cmp #$0d	                cmp #$0D
1121	.8ec8		f0 20		beq $8eea	                beq L8F14
1122	.8eca		c9 0a		cmp #$0a	                cmp #$0A
1123	.8ecc		f0 1c		beq $8eea	                beq L8F14
1124	.8ece		8d c5 df	sta $dfc5	                sta hazel.lastCharPrinted
1125	.8ed1		c9 22		cmp #$22	                cmp #'"'
1126	.8ed3		f0 05		beq $8eda	                beq L8F04
1127	.8ed5		20 04 99	jsr $9904	                jsr printGSREADChar
1128	.8ed8		80 03		bra $8edd	                bra L8F07

1130	.8eda						L8F04:
1131	.8eda		20 ee ff	jsr $ffee	                jsr OSWRCH
1132	.8edd						L8F07:
1133	.8edd		20 10 8f	jsr $8f10	                jsr bgetAndCheckForESCAPE
1134	.8ee0		90 df		bcc $8ec1	                bcc L8EEB
1135	.8ee2						printNewLineThenCloseFile:
1136	.8ee2		20 e7 ff	jsr $ffe7	                jsr OSNEWL
1137	.8ee5						closeFile:
1138	.8ee5		a9 00		lda #$00	                lda #$00
1139	.8ee7		4c ce ff	jmp $ffce	                jmp OSFIND

1141	.8eea						L8F14:
1142	.8eea		cd c5 df	cmp $dfc5	                cmp hazel.lastCharPrinted
1143	.8eed		f0 10		beq $8eff	                beq L8F29
1144	.8eef		48		pha		                pha
1145	.8ef0		ad c5 df	lda $dfc5	                lda hazel.lastCharPrinted
1146	.8ef3		c9 0d		cmp #$0d	                cmp #$0D
1147	.8ef5		f0 13		beq $8f0a	                beq L8F34
1148	.8ef7		c9 0a		cmp #$0a	                cmp #$0A
1149	.8ef9		f0 0f		beq $8f0a	                beq L8F34
1150	.8efb		68		pla		                pla
1151	.8efc		8d c5 df	sta $dfc5	                sta hazel.lastCharPrinted
1152	.8eff						L8F29:
1153	.8eff		20 e7 ff	jsr $ffe7	                jsr OSNEWL
1154	.8f02		80 aa		bra $8eae	                bra L8ED8

1156							;-------------------------------------------------------------------------
1157							;
1158							; Tidily handle ESCAPE when a file is open during *DUMP or whatever.
1159							; Prints a new line, closes the file, then does an Escape error.
1160							;
1161							; entry:
1162							;
1163							; Y = file handle
1164							;
1165	.8f04						handleESCAPEWithFileOpen:
1166	.8f04		20 e2 8e	jsr $8ee2	                jsr printNewLineThenCloseFile
1167	.8f07		4c d3 a8	jmp $a8d3	                jmp escapeError

1169							;-------------------------------------------------------------------------

1171	.8f0a						L8F34:
1172	.8f0a		68		pla		                pla
1173	.8f0b		9c c5 df	stz $dfc5	                stz hazel.lastCharPrinted
1174	.8f0e		80 cd		bra $8edd	                bra L8F07

1176							;-------------------------------------------------------------------------
1177							;
1178							; Does an OSBGET and handles ESCAPE.
1179							;
1180							; entry:
1181							;
1182							; Y = file handle
1183							;
1184							; exit:
1185							;
1186							; A = byte read
1187							; C=1 if EOF
1188							; (as per OSBGET)
1189							;
1190	.8f10						bgetAndCheckForESCAPE:
1191	.8f10		20 d7 ff	jsr $ffd7	                jsr OSBGET
1192	.8f13		24 ff		bit $ff		                bit $FF
1193	.8f15		30 ed		bmi $8f04	                bmi handleESCAPEWithFileOpen
1194	.8f17		60		rts		                rts

1196							;-------------------------------------------------------------------------
1197							;
1198							; *DUMP [MasRef G.5-4]
1199							;
1200	.8f18						starDUMP:
1201	.8f18		86 f2		stx $f2		                stx stringInputBufferAddress+0
1202	.8f1a		84 f3		sty $f3		                sty stringInputBufferAddress+1
1203	.8f1c		a2 00		ldx #$00	                ldx #$00
1204	.8f1e		20 5a 92	jsr $925a	                jsr clearOSFILEParameterBlockDWORD
1205	.8f21		a2 04		ldx #$04	                ldx #$04
1206	.8f23		20 5a 92	jsr $925a	                jsr clearOSFILEParameterBlockDWORD
1207	.8f26		a0 00		ldy #$00	                ldy #$00
1208	.8f28		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
1209	.8f2b		20 e0 f1	jsr $f1e0	                jsr gsinitForFilenameParsing
1210	.8f2e						L8F58:
1211	.8f2e		20 f2 f1	jsr $f1f2	                jsr gsreadEntryPoint
1212	.8f31		90 fb		bcc $8f2e	                bcc L8F58
1213	.8f33		f0 1a		beq $8f4f	                beq L8F79
1214	.8f35		a2 00		ldx #$00	                ldx #$00
1215	.8f37		20 f9 92	jsr $92f9	                jsr parseHexAddressFromCommandLine

1217	.8f3a		a2 03		ldx #$03	                ldx #$03
1218	.8f3c						-
1219	.8f3c		bd ed 02	lda $02ed,x	                lda osfileParameterBlock+0,x
1220	.8f3f		9d f1 02	sta $02f1,x	                sta osfileParameterBlock+4,x
1221	.8f42		ca		dex		                dex
1222	.8f43		10 f7		bpl $8f3c	                bpl -

1224	.8f45		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
1225	.8f48		f0 05		beq $8f4f	                beq L8F79
1226	.8f4a		a2 04		ldx #$04	                ldx #$04
1227	.8f4c		20 f9 92	jsr $92f9	                jsr parseHexAddressFromCommandLine
1228	.8f4f						L8F79:
1229	.8f4f		a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
1230	.8f51		a6 f2		ldx $f2		                ldx stringInputBufferAddress+0
1231	.8f53		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
1232	.8f56		20 5f a5	jsr $a55f	                jsr openFileForReading

1234	.8f59		a9 02		lda #$02	                lda #argsFileGetEXT
1235	.8f5b		20 ff 93	jsr $93ff	                jsr callOSARGSWithBuffer

1237	.8f5e		a2 03		ldx #$03	                ldx #$03
1238	.8f60						L8F8A:
1239	.8f60		b5 a8		lda $a8,x	                lda osargsBuffer,x
1240	.8f62		dd ed 02	cmp $02ed,x	                cmp osfileParameterBlock+0,x
1241	.8f65		90 6a		bcc $8fd1	                bcc L8FFB
1242	.8f67		d0 03		bne $8f6c	                bne L8F96
1243	.8f69		ca		dex		                dex
1244	.8f6a		10 f4		bpl $8f60	                bpl L8F8A
1245	.8f6c						L8F96:
1246	.8f6c		a2 03		ldx #$03	                ldx #$03
1247	.8f6e						-
1248	.8f6e		bd ed 02	lda $02ed,x	                lda osfileParameterBlock+0,x
1249	.8f71		95 a8		sta $a8,x	                sta osargsBuffer,x
1250	.8f73		ca		dex		                dex
1251	.8f74		10 f8		bpl $8f6e	                bpl -
1252	.8f76		20 fd 93	jsr $93fd	                jsr setFilePointerFromOSARGSBuffer
1253	.8f79						L8FA3:
1254	.8f79		a2 00		ldx #$00	                ldx #$00
1255	.8f7b		20 d7 ff	jsr $ffd7	                jsr OSBGET
1256	.8f7e		b0 46		bcs $8fc6	                bcs L8FF0
1257	.8f80		20 18 92	jsr $9218	                jsr L9239
1258	.8f83		48		pha		                pha
1259	.8f84		ad f1 02	lda $02f1	                lda osfileParameterBlock+4
1260	.8f87		29 07		and #$07	                and #$07
1261	.8f89		f0 15		beq $8fa0	                beq L8FCA
1262	.8f8b		5a		phy		                phy
1263	.8f8c		a8		tay		                tay
1264	.8f8d						L8FB7:
1265	.8f8d		5a		phy		                phy
1266	.8f8e		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
1267	>8f91		20 20 20 00			                .text "   ",0
1268	.8f95		7a		ply		                ply
1269	.8f96		a9 20		lda #$20	                lda #$20
1270	.8f98		9d f5 02	sta $02f5,x	                sta osfileParameterBlock+8,x
1271	.8f9b		e8		inx		                inx
1272	.8f9c		88		dey		                dey
1273	.8f9d		d0 ee		bne $8f8d	                bne L8FB7
1274	.8f9f		7a		ply		                ply
1275	.8fa0						L8FCA:
1276	.8fa0		68		pla		                pla
1277	.8fa1						L8FCB:
1278	.8fa1		48		pha		                pha
1279	.8fa2		c9 20		cmp #$20	                cmp #32
1280	.8fa4		90 04		bcc $8faa	                bcc nonPrintable
1281	.8fa6		c9 7f		cmp #$7f	                cmp #127
1282	.8fa8		90 02		bcc $8fac	                bcc L8FD6                    ;taken if printable
1283	.8faa						nonPrintable:
1284	.8faa		a9 2e		lda #$2e	                lda #'.'          ;placeholder for non-printable chars
1285	.8fac						L8FD6:
1286	.8fac		9d f5 02	sta $02f5,x	                sta osfileParameterBlock+8,x
1287	.8faf		68		pla		                pla
1288	.8fb0		20 a8 a8	jsr $a8a8	                jsr printSpaceThenPrintHexByte
1289	.8fb3		e8		inx		                inx
1290	.8fb4		20 27 92	jsr $9227	                jsr L9248
1291	.8fb7		ad f1 02	lda $02f1	                lda osfileParameterBlock+4
1292	.8fba		29 07		and #$07	                and #$07
1293	.8fbc		f0 0b		beq $8fc9	                beq L8FF3
1294	.8fbe		20 10 8f	jsr $8f10	                jsr bgetAndCheckForESCAPE
1295	.8fc1		90 de		bcc $8fa1	                bcc L8FCB
1296	.8fc3		20 36 92	jsr $9236	                jsr L9257
1297	.8fc6						L8FF0:
1298	.8fc6		4c e5 8e	jmp $8ee5	                jmp closeFile

1300	.8fc9						L8FF3:
1301	.8fc9		20 36 92	jsr $9236	                jsr L9257
1302	.8fcc		80 ab		bra $8f79	                bra L8FA3

1304	.8fce						L8FF8:
1305	.8fce		4c 67 a5	jmp $a567	                jmp notFoundError

1307	.8fd1						L8FFB:
1308	.8fd1		20 e5 8e	jsr $8ee5	                jsr closeFile
1309	.8fd4		20 2f ab	jsr $ab2f	                jsr doFollowingError
1310	>8fd7		b7 4f 75 74 73 69 64 65		                .text $b7,"Outside file",0
	>8fdf		20 66 69 6c 65 00

1312							;-------------------------------------------------------------------------
1313							;
1314							; *BUILD
1315							;
1316	.8fe5						starBUILD:
1317	.8fe5		4e c2 df	lsr $dfc2	                lsr hazel.fsFlags            ;clear bit 7 of fsFlags
1318	.8fe8		80 04		bra $8fee	                bra starBUILDOrAPPEND

1320							;-------------------------------------------------------------------------
1321							;
1322							; *APPEND
1323							;
1324	.8fea						starAPPEND:
1325	.8fea		38		sec		                sec
1326	.8feb		6e c2 df	ror $dfc2	                ror hazel.fsFlags            ;set bit 7 of fsFlags
1327	.8fee						starBUILDOrAPPEND:
1328							                ; bit 7 of fsFlags indicates *BUILD (clear) or *APPEND
1329							                ; (set).
1330	.8fee		9c c3 df	stz $dfc3	                stz hazel.lineNumberBCD+0    ;reset line number
1331	.8ff1		9c c4 df	stz $dfc4	                stz hazel.lineNumberBCD+1    ;reset line number
1332	.8ff4		a9 80		lda #$80	                lda #$80                     ;open for output. Assume *BUILD
1333	.8ff6		2c c2 df	bit $dfc2	                bit hazel.fsFlags            ;test *BUILD/*APPEND
1334	.8ff9		10 02		bpl $8ffd	                bpl +                        ;branch taken if *BUILD
1335	.8ffb		a9 c0		lda #$c0	                lda #$C0                     ;*APPEND, so open for update
1336	.8ffd						+
1337	.8ffd		20 ce ff	jsr $ffce	                jsr OSFIND                   ;open the file
1338	.9000		a8		tay		                tay                          ;Y=file handle
1339	.9001		f0 cb		beq $8fce	                beq L8FF8                    ;branch taken if open failed
1340	.9003		8c ed 02	sty $02ed	                sty osfileParameterBlock+0   ;save file handle
1341	.9006		20 f8 93	jsr $93f8	                jsr setPTRToEOF ;move to EOF (effective no-op when *BUILD)
1342	.9009						L9033:
1343	.9009		20 cc 91	jsr $91cc	                jsr printLineNumber
1344	.900c						L9036:
1345							                .if version<500&&version!=350
1347							                .else
1348	.900c		a9 00		lda #$00	                lda #0
1349	.900e		a2 92		ldx #$92	                ldx #<starBuildOrAPPENDOSWORD0Parameters
1350	.9010		a0 90		ldy #$90	                ldy #>starBuildOrAPPENDOSWORD0Parameters
1351	.9012		20 f1 ff	jsr $fff1	                jsr OSWORD
1352							                .endif
1353	.9015		08		php		                php
1354	.9016		90 0f		bcc $9027	                bcc L904B
1355							                ; Handle ESCAPE
1356	.9018		20 e7 ff	jsr $ffe7	                jsr OSNEWL
1357	.901b		a9 0d		lda #$0d	                lda #$0D
1358	.901d		99 00 dc	sta $dc00,y	                sta hazel.commandLine,y      ;terminate current line
1359	.9020						L9044:
1360	.9020		5a		phy		                phy                          ;save line length
1361	.9021		a9 7e		lda #$7e	                lda #$7E
1362	.9023		20 f4 ff	jsr $fff4	                jsr OSBYTE                   ;acknowledge ESCAPE
1363	.9026		7a		ply		                ply                          ;restore line length
1364	.9027						L904B:
1365	.9027		98		tya		                tya                          ;A=line length
1366	.9028		f0 50		beq $907a	                beq L909E                    ;taken if line empty
1367	.902a		20 87 90	jsr $9087	                jsr setStringInputBufferToCommandLine
1368	.902d		a0 00		ldy #$00	                ldy #$00
1369	.902f		a2 00		ldx #$00	                ldx #$00
1370	.9031						L9055:
1371	.9031		20 0f f2	jsr $f20f	                jsr LF29C
1372	.9034		9d 00 dc	sta $dc00,x	                sta hazel.commandLine,x
1373	.9037		a9 01		lda #$01	                lda #stringInputOptions.goodString
1374	.9039		24 e4		bit $e4		                bit stringInputOptions
1375	.903b		d0 0b		bne $9048	                bne L906C
1376	.903d		a9 07		lda #$07	                lda #7
1377	.903f		20 ee ff	jsr $ffee	                jsr OSWRCH                   ;beep
1378	.9042		20 d6 91	jsr $91d6	                jsr L91F5
1379	.9045		28		plp		                plp
1380	.9046		80 c4		bra $900c	                bra L9036

1382	.9048						L906C:
1383	.9048		e8		inx		                inx
1384	.9049		90 e6		bcc $9031	                bcc L9055
1385	.904b		28		plp		                plp
1386	.904c		90 01		bcc $904f	                bcc L9073
1387	.904e		ca		dex		                dex
1388	.904f						L9073:
1389	.904f		08		php		                php
1390	.9050		da		phx		                phx
1391	.9051		a2 0b		ldx #$0b	                ldx #size(OSGBPBParameterBlock)-2
1392	.9053						L9077:
1393	.9053		9e ee 02	stz $02ee,x	                stz osfileParameterBlock+1,x
1394	.9056		ca		dex		                dex
1395	.9057		10 fa		bpl $9053	                bpl L9077
1396	.9059		fa		plx		                plx
1397	.905a		8e f2 02	stx $02f2	                stx osfileParameterBlock+OSGBPBParameterBlock.count+0
1398							                .cerror (<hazel.commandLine)!=0,"hazel.commandLine must be page aligned"
1399	.905d		a9 dc		lda #$dc	                lda #>hazel.commandLine
1400	.905f		8d ef 02	sta $02ef	                sta osfileParameterBlock+OSGBPBParameterBlock.address+1
1401	.9062		ce f0 02	dec $02f0	                dec osfileParameterBlock+OSGBPBParameterBlock.address+2
1402	.9065		ce f1 02	dec $02f1	                dec osfileParameterBlock+OSGBPBParameterBlock.address+3
1403	.9068		a9 02		lda #$02	                lda #gbpbPutBytesCurrentPTR
1404	.906a		a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
1405	.906c		a0 02		ldy #$02	                ldy #>osfileParameterBlock
1406	.906e		20 d1 ff	jsr $ffd1	                jsr OSGBPB
1407	.9071		28		plp		                plp
1408	.9072		90 95		bcc $9009	                bcc L9033
1409	.9074						L9098:
1410	.9074		ac ed 02	ldy $02ed	                ldy osfileParameterBlock+0
1411	.9077		4c e5 8e	jmp $8ee5	                jmp closeFile

1413	.907a						L909E:
1414	.907a		28		plp		                plp
1415	.907b		b0 f7		bcs $9074	                bcs L9098
1416	.907d		a9 0d		lda #$0d	                lda #13
1417	.907f		ac ed 02	ldy $02ed	                ldy osfileParameterBlock
1418	.9082		20 d4 ff	jsr $ffd4	                jsr OSBPUT
1419	.9085		80 82		bra $9009	                bra L9033

1421	.9087						setStringInputBufferToCommandLine:
1422	.9087		a9 41		lda #$41	                lda #$41
1423	.9089		85 e4		sta $e4		                sta $E4
1424							                .cerror (<hazel.commandLine)!=0,"hazel.commandLine must be page aligned"
1425	.908b		64 f2		stz $f2		                stz stringInputBufferAddress+0
1426	.908d		a9 dc		lda #$dc	                lda #>hazel.commandLine
1427	.908f		85 f3		sta $f3		                sta stringInputBufferAddress+1
1428	.9091		60		rts		                rts

1430							;-------------------------------------------------------------------------

1432							                .if version>=500||version==350
1433	.9092						starBuildOrAPPENDOSWORD0Parameters:
1434	>9092		00 dc				                .word hazel.commandLine      ;address
1435	>9094		f0				                .byte $f0                    ;max # chars
1436	>9095		00				                .byte 0                      ;min char
1437	>9096		ff				                .byte 255                    ;max char
1438							                .endif

1440							;-------------------------------------------------------------------------
1441							;
1442							; *MOVE
1443							;
1444	.9097						starMOVE:
1445	.9097		ad 34 fe	lda $fe34	                lda ACCCON                    ; Save ACCCON
1446	.909a		8d dc df	sta $dfdc	                sta hazel.oldACCCON
1447	.909d		48		pha		                pha                          ; Save ACCCON and command line pointer
1448	.909e		da		phx		                phx
1449	.909f		5a		phy		                phy
1450	.90a0		a0 80		ldy #$80	                ldy #$80                     ; Top of available shadow memory at &8000
1451	.90a2		a5 d0		lda $d0		                lda STATE                      ; Get VDU status
1452	.90a4		89 10		bit #$10	                bit #$10                     ; Jump if not shadow screen, spare up to &8000
1453	.90a6		f0 07		beq $90af	                beq L90CE
1454							; Shadow screen selected
1455	.90a8		20 2b f1	jsr $f12b	                jsr LF1C0                ; Get screen bottom to XY
1456	.90ab		c0 30		cpy #$30	                cpy #$30                     ; Screen at &3000, no spare memory, jump to use Hazel
1457	.90ad		f0 14		beq $90c3	                beq L90E2

1459							; Non-shadow or small shadow screen selected
1460							; Y=top of available memory in shadow memory
1461	.90af						L90CE:
1462	.90af		a9 30		lda #$30	                lda #$30                     ; &3000=start of shadow memory
1463	.90b1		8d d6 df	sta $dfd6	                sta hazel.moveBufferMSB
1464	.90b4		a9 04		lda #$04	                lda #ACCCON.X
1465	.90b6		0c 34 fe	tsb $fe34	                tsb ACCCON
1466	.90b9		8d dd df	sta $dfdd	                sta hazel.hasACCCONChanged      ; set 'ACCCON changed'
1467	.90bc		98		tya		                tya                          ; A=length of space in shadow memory
1468	.90bd		38		sec		                sec
1469	.90be		ed d6 df	sbc $dfd6	                sbc hazel.moveBufferMSB
1470	.90c1		80 07		bra $90ca	                bra L90E9

1472							; No shadow memory available, use Hazel
1473	.90c3						L90E2:
1474	.90c3		a9 dd		lda #$dd	                lda #$DD                     ; Buffer at &DD00
1475	.90c5		8d d6 df	sta $dfd6	                sta hazel.moveBufferMSB
1476	.90c8		a9 02		lda #$02	                lda #$02                     ; Buffer length=&200

1478							; &DFD6=high byte of buffer address
1479							; A=high byte of buffer length
1480	.90ca						L90E9:
1481	.90ca		8d d7 df	sta $dfd7	                sta hazel.moveNumPages      ; Store buffer length
1482	.90cd		7a		ply		                ply                          ; Get command line pointer
1483	.90ce		fa		plx		                plx
1484	.90cf		da		phx		                phx
1485	.90d0		5a		phy		                phy
1486	.90d1		a9 40		lda #$40	                lda #$40                     ; Open source file
1487	.90d3		20 ce ff	jsr $ffce	                jsr OSFIND
1488	.90d6		a8		tay		                tay                          ; Store source handle, jump if not found
1489	.90d7		8c d4 df	sty $dfd4	                sty hazel.moveSrcHandle
1490	.90da		f0 39		beq $9115	                beq L9134
1491	.90dc		7a		ply		                ply                          ; Get command line back again
1492	.90dd		fa		plx		                plx
1493	.90de		86 f2		stx $f2		                stx $F2
1494	.90e0		84 f3		sty $f3		                sty $F3
1495	.90e2		da		phx		                phx                          ; And save it again
1496	.90e3		5a		phy		                phy
1497	.90e4		a0 00		ldy #$00	                ldy #$00                     ; Step past first parameter
1498	.90e6		20 e0 f1	jsr $f1e0	                jsr gsinitForFilenameParsing
1499	.90e9						L9108:
1500	.90e9		20 f2 f1	jsr $f1f2	                jsr gsreadEntryPoint     ;
1501	.90ec		90 fb		bcc $90e9	                bcc L9108
1502	.90ee		98		tya		                tya                          ; Save address of dest filename
1503	.90ef		18		clc		                clc
1504	.90f0		65 f2		adc $f2		                adc $F2
1505	.90f2		8d d8 df	sta $dfd8	                sta hazel.moveDestName+0
1506	.90f5		aa		tax		                tax
1507	.90f6		a5 f3		lda $f3		                lda $F3
1508	.90f8		69 00		adc #$00	                adc #$00
1509	.90fa		8d d9 df	sta $dfd9	                sta hazel.moveDestName+1
1510	.90fd		a8		tay		                tay                          ; Temporary filing system flag
1511	.90fe		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
1512	.9101		a9 80		lda #$80	                lda #$80                     ; Open destination file
1513	.9103		20 ce ff	jsr $ffce	                jsr OSFIND
1514	.9106		a8		tay		                tay                          ; Store dest handle, jump if opened
1515	.9107		8c d5 df	sty $dfd5	                sty hazel.moveDestHandle
1516	.910a		d0 0c		bne $9118	                bne L9137

1518							; Couldn't open destination
1519	.910c		ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle      ; Get source handle and clear it
1520	.910f		9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
1521	.9112		20 ce ff	jsr $ffce	                jsr OSFIND                   ; Close source file
1522	.9115						L9134:
1523	.9115		4c 67 a5	jmp $a567	                jmp notFoundError                    ; Jump to 'Not found' error

1525							; Source and dest opened
1526							; ----------------------
1527							; Build OSGBPB source file control block at &02ED
1528							; and destination control block at &DFC7
1529	.9118						L9137:
1530	.9118		a2 07		ldx #$07	                ldx #$07
1531	.911a						L9139:
1532	.911a		9e ee 02	stz $02ee,x	                stz @w osfileParameterBlock+OSGBPBParameterBlock.address,x ; Addr=0, Num=0
1533	.911d		9e c8 df	stz $dfc8,x	                stz hazel.moveOSGBPB+1,x
1534	.9120		ca		dex		                dex
1535	.9121		10 f7		bpl $911a	                bpl L9139
1536	.9123		ad d4 df	lda $dfd4	                lda hazel.moveSrcHandle      ; Source handle
1537	.9126		8d ed 02	sta $02ed	                sta osfileParameterBlock+OSGBPBParameterBlock.handle
1538	.9129		ad d6 df	lda $dfd6	                lda hazel.moveBufferMSB      ; Buffer address
1539	.912c		8d ef 02	sta $02ef	                sta osfileParameterBlock+OSGBPBParameterBlock.address+1
1540	.912f		8d c9 df	sta $dfc9	                sta hazel.moveOSGBPB.addr+1
1541	.9132		ad d7 df	lda $dfd7	                lda hazel.moveNumPages
1542	.9135		8d f3 02	sta $02f3	                sta osfileParameterBlock+OSGBPBParameterBlock.count+1
1543	.9138		8d cd df	sta $dfcd	                sta hazel.moveOSGBPB.numBytes+1
1544	.913b		ce f0 02	dec $02f0	                dec osfileParameterBlock+OSGBPBParameterBlock.address+2 ; Source addr=&FFFFxxxx
1545	.913e		ce f1 02	dec $02f1	                dec osfileParameterBlock+OSGBPBParameterBlock.address+3
1546	.9141		ce ca df	dec $dfca	                dec hazel.moveOSGBPB.addr+2
1547	.9144		ce cb df	dec $dfcb	                dec hazel.moveOSGBPB.addr+3

1549							; Should use &FFFExxxx and let filing system select correct memory
1550							; Unfortunately, CFS/RFS and DFS do not recognise &FFFExxxx, so
1551							; *MOVE has to do it itself, causing problems for filing systems
1552							; that /do/ recognise &FFFExxxx where they have to remember to
1553							; *do* *nothing* for &FFFFxxxx instead of select main memory as
1554							; &FFFFxxxx implies.

1556	.9147		a2 ed		ldx #$ed	                ldx #<osfileParameterBlock                     ; XY=>source OSGBPB block
1557	.9149		a0 02		ldy #$02	                ldy #>osfileParameterBlock
1558	.914b		a9 04		lda #$04	                lda #$04                     ; Read data from source
1559	.914d		20 d1 ff	jsr $ffd1	                jsr OSGBPB
1560	.9150		08		php		                php                          ; Jump if not at end of file
1561	.9151		90 11		bcc $9164	                bcc L9183
1562							; End of file, adjust destination buffer length for final part
1563	.9153		a9 00		lda #$00	                lda #$00
1564	.9155		ed f2 02	sbc $02f2	                sbc osfileParameterBlock+OSGBPBParameterBlock.count+0
1565	.9158		8d cc df	sta $dfcc	                sta hazel.moveOSGBPB.numBytes+0
1566	.915b		ad cd df	lda $dfcd	                lda hazel.moveOSGBPB.numBytes+1
1567	.915e		ed f3 02	sbc $02f3	                sbc osfileParameterBlock+OSGBPBParameterBlock.count+1
1568	.9161		8d cd df	sta $dfcd	                sta hazel.moveOSGBPB.numBytes+1
1569	.9164						L9183:
1570	.9164		ad d5 df	lda $dfd5	                lda hazel.moveDestHandle      ; Destination handle
1571	.9167		8d c7 df	sta $dfc7	                sta hazel.moveOSGBPB.handle
1572	.916a		a9 02		lda #$02	                lda #$02                     ; XY=>control block, A=write
1573	.916c		a2 c7		ldx #$c7	                ldx #<hazel.moveOSGBPB
1574	.916e		a0 df		ldy #$df	                ldy #>hazel.moveOSGBPB
1575	.9170		20 d1 ff	jsr $ffd1	                jsr OSGBPB
1576	.9173		28		plp		                plp                          ; Loop until end of file
1577	.9174		90 a2		bcc $9118	                bcc L9137
1578	.9176		a9 00		lda #$00	                lda #$00
1579	.9178		ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle      ; Get and clear source handle
1580	.917b		9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
1581	.917e		5a		phy		                phy                          ; Close source file
1582	.917f		20 ce ff	jsr $ffce	                jsr OSFIND
1583	.9182		a9 00		lda #$00	                lda #$00                     ; Get dest handle
1584	.9184		ac d5 df	ldy $dfd5	                ldy hazel.moveDestHandle
1585	.9187		5a		phy		                phy                          ; Clear dest handle and close file
1586	.9188		9c d5 df	stz $dfd5	                stz hazel.moveDestHandle
1587	.918b		20 ce ff	jsr $ffce	                jsr OSFIND
1588	.918e		7a		ply		                ply                          ; Dest not CFS/RFS, jump to...
1589	.918f		c0 04		cpy #$04	                cpy #$04
1590	.9191		b0 0b		bcs $919e	                bcs L91BD
1591	.9193		7a		ply		                ply                          ; Pop source handle
1592	.9194						L91B3:
1593	.9194		7a		ply		                ply                          ; Restore XY
1594	.9195		fa		plx		                plx
1595	.9196						L91B5:
1596	.9196		68		pla		                pla                          ; Clear 'ACCCON changed', restore ACCCON
1597	.9197		9c dd df	stz $dfdd	                stz hazel.hasACCCONChanged
1598	.919a		8d 34 fe	sta $fe34	                sta ACCCON
1599	.919d		60		rts		                rts

1601	.919e						L91BD:
1602	.919e		7a		ply		                ply                          ; Source was CFS/RFS, jump to exit
1603	.919f		c0 04		cpy #$04	                cpy #$04
1604	.91a1		90 f1		bcc $9194	                bcc L91B3
1605	.91a3		7a		ply		                ply                          ; Point to first parameter
1606	.91a4		8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
1607	.91a7		fa		plx		                plx
1608	.91a8		8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
1609	.91ab		a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
1610	.91ad		a0 02		ldy #$02	                ldy #>osfileParameterBlock
1611	.91af		a9 05		lda #$05	                lda #$05                     ; Read info on source file
1612	.91b1		20 dd ff	jsr $ffdd	                jsr OSFILE
1613	.91b4		ad d8 df	lda $dfd8	                lda hazel.moveDestName+0      ; Get address of dest filename
1614	.91b7		8d ed 02	sta $02ed	                sta osfileParameterBlock+OSFILEParameterBlock.fileName+0
1615	.91ba		ad d9 df	lda $dfd9	                lda hazel.moveDestName+1      ;  and put in control block
1616	.91bd		8d ee 02	sta $02ee	                sta osfileParameterBlock+OSFILEParameterBlock.fileName+1
1617	.91c0		a9 f0		lda #$f0	                lda #$F0                     ; Mask out 'public' access bits
1618	.91c2		1c fb 02	trb $02fb	                trb osfileParameterBlock+OSFILEParameterBlock.attributes+0
1619	.91c5		a9 01		lda #$01	                lda #$01                     ; Write info on dest file
1620	.91c7		20 dd ff	jsr $ffdd	                jsr OSFILE
1621	.91ca		80 ca		bra $9196	                bra L91B5                    ; Jump to restore ACCCON and exit

1623	.91cc						printLineNumber:
1624	.91cc		a2 00		ldx #$00	                ldx #$00
1625	.91ce		38		sec		                sec
1626	.91cf		20 0d 92	jsr $920d	                jsr adcLineNumberBCDX        ;increment line number LSB
1627	.91d2		e8		inx		                inx
1628	.91d3		20 0d 92	jsr $920d	                jsr adcLineNumberBCDX        ;carry into line number MSB
1629	.91d6						L91F5:
1630	.91d6		38		sec		                sec                          ;printing leading 0s
1631	.91d7		ad c4 df	lda $dfc4	                lda hazel.lineNumberBCD+1    ;get line number MSB
1632	.91da		20 f1 91	jsr $91f1	                jsr printPossiblyLeading0s
1633	.91dd		ad c3 df	lda $dfc3	                lda hazel.lineNumberBCD+0    ;get line number LSB
1634	.91e0		48		pha		                pha                          ;save line number LSB
1635	.91e1		08		php		                php                          ;save C
1636							                .if version==350
1637	.91e2		20 20 e5	jsr $e520	                jsr LE520
1643							                .endif
1644	.91e5		28		plp		                plp                          ;restore  C
1645	.91e6		20 fb 91	jsr $91fb	                jsr printPossiblyLeading0    ;print line number 3rd digit
1646	.91e9		68		pla		                pla                          ;restore line number LSB
1647	.91ea		18		clc		                clc                ;always print line number 4th digit
1648	.91eb		20 fb 91	jsr $91fb	                jsr printPossiblyLeading0    ;
1649	.91ee		4c 28 9f	jmp $9f28	                jmp printSpace                    ;

1651	.91f1						printPossiblyLeading0s:
1652	.91f1		48		pha		                pha                          ;save value
1653	.91f2		08		php		                php                          ;save C
1654							                .if version==350
1655	.91f3		20 20 e5	jsr $e520	                jsr LE520
1661							                .endif
1662	.91f6		28		plp		                plp                          ;restore C
1663	.91f7		20 fb 91	jsr $91fb	                jsr printPossiblyLeading0    ;print 1st digit
1664	.91fa		68		pla		                pla                          ;restore value
1665	.91fb						printPossiblyLeading0:
1666	.91fb		29 0f		and #$0f	                and #$0F                     ;get digit to print
1667	.91fd		d0 09		bne $9208	                bne printNonLeading0         ;always print if non-0
1668	.91ff		90 07		bcc $9208	                bcc printNonLeading0 ;branch taken if not leading 0
1669	.9201		a9 20		lda #$20	                lda #$20             ;print space instead of leading 0
1670	.9203		20 ee ff	jsr $ffee	                jsr OSWRCH
1671	.9206		38		sec		                sec                ;indicate still in leading 0s state
1672	.9207		60		rts		                rts

1674	.9208						printNonLeading0:
1675	.9208		20 b5 a8	jsr $a8b5	                jsr printHexDigit            ;print digit
1676	.920b		18		clc		                clc                          ;no longer in leading 0s state
1677	.920c		60		rts		                rts                          ;

1679	.920d						adcLineNumberBCDX:
1680	.920d		a9 00		lda #$00	                lda #$00
1681	.920f		f8		sed		                sed
1682	.9210		7d c3 df	adc $dfc3,x	                adc hazel.lineNumberBCD,x
1683	.9213		9d c3 df	sta $dfc3,x	                sta hazel.lineNumberBCD,x
1684	.9216		d8		cld		                cld
1685	.9217						rts9238:
1686	.9217		60		rts		                rts

1688							;-------------------------------------------------------------------------

1690	.9218						L9239:
1691	.9218		da		phx		                phx
1692	.9219		48		pha		                pha
1693	.921a		a2 02		ldx #$02	                ldx #$02
1694	.921c						L923D:
1695	.921c		bd f1 02	lda $02f1,x	                lda osfileParameterBlock+4,x
1696	.921f		20 ad a8	jsr $a8ad	                jsr printHexByte
1697	.9222		ca		dex		                dex
1698	.9223		10 f7		bpl $921c	                bpl L923D
1699	.9225		80 0c		bra $9233	                bra L9254

1701							;-------------------------------------------------------------------------

1703	.9227						L9248:
1704	.9227		da		phx		                phx
1705	.9228		48		pha		                pha
1706	.9229		a2 fc		ldx #$fc	                ldx #256-4
1707	.922b						L924C:
1708	.922b		fe f5 01	inc $01f5,x	                inc osfileParameterBlock+4-(256-4),x
1709	.922e		d0 03		bne $9233	                bne L9254
1710	.9230		e8		inx		                inx
1711	.9231		d0 f8		bne $922b	                bne L924C
1712	.9233						L9254:
1713	.9233		68		pla		                pla
1714	.9234		fa		plx		                plx
1715	.9235		60		rts		                rts

1717	.9236						L9257:
1718	.9236		5a		phy		                phy
1719	.9237		da		phx		                phx
1720	.9238						L9259:
1721	.9238		e0 08		cpx #$08	                cpx #$08
1722	.923a		f0 0a		beq $9246	                beq L9267
1723	.923c		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
1724	>923f		20 20 20 00			                .text "   ",0
1725	.9243		e8		inx		                inx
1726	.9244		80 f2		bra $9238	                bra L9259

1728	.9246						L9267:
1729	.9246		fa		plx		                plx
1730	.9247		20 28 9f	jsr $9f28	                jsr printSpace
1731	.924a		a0 00		ldy #$00	                ldy #$00
1732	.924c						L926D:
1733	.924c		b9 f5 02	lda $02f5,y	                lda osfileParameterBlock+8,y
1734	.924f		20 ee ff	jsr $ffee	                jsr OSWRCH
1735	.9252		c8		iny		                iny
1736	.9253		ca		dex		                dex
1737	.9254		d0 f6		bne $924c	                bne L926D
1738	.9256		7a		ply		                ply
1739	.9257		4c e7 ff	jmp $ffe7	                jmp OSNEWL

1741							;-------------------------------------------------------------------------

1743							                .if version==320||version==400
1749							                .endif

1751							;-------------------------------------------------------------------------
1752							;
1753							; Clear 4 bytes in the OSFILE parameter block.
1754							;
1755							; entry:
1756							;
1757							; X = offset of the 4 bytes to clear
1758							;
1759	.925a						clearOSFILEParameterBlockDWORD:
1760	.925a		9e ed 02	stz $02ed,x	                stz osfileParameterBlock+0,x
1761	.925d		9e ee 02	stz $02ee,x	                stz osfileParameterBlock+1,x
1762	.9260		9e ef 02	stz $02ef,x	                stz osfileParameterBlock+2,x
1763	.9263		9e f0 02	stz $02f0,x	                stz osfileParameterBlock+3,x
1764	.9266						rts94A4:
1765	.9266		60		rts		                rts

1767							;-------------------------------------------------------------------------
1768							;
1769							; Read a 32-bit hex value from a string.
1770							;
1771							; entry:
1772							;
1773							; X = offset into osfileParameterBlock to store the value
1774							;
1775							; exit:
1776							;
1777							; C=0 if error
1778							;
1779							; preserves: V
1780							;
1781	.9267						parseHexAddressFromString:
1782	.9267		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
1783	.926a		20 10 84	jsr $8410	                jsr readHexDigit
1784	.926d		90 23		bcc $9292	                bcc rts92F4
1785	.926f		20 5a 92	jsr $925a	                jsr clearOSFILEParameterBlockDWORD
1786	.9272						readDigitsLoop:
1787	.9272		5a		phy		                phy
1788	.9273		2a		rol a		                rol a
1789	.9274		2a		rol a		                rol a
1790	.9275		2a		rol a		                rol a
1791	.9276		2a		rol a		                rol a                        ;put digit in top 4 bits
1792	.9277		a0 04		ldy #$04	                ldy #$04
1793	.9279						shiftIn1DigitLoop:
1794	.9279		2a		rol a		                rol a
1795	.927a		3e ed 02	rol $02ed,x	                rol osfileParameterBlock+0,x
1796	.927d		3e ee 02	rol $02ee,x	                rol osfileParameterBlock+1,x
1797	.9280		3e ef 02	rol $02ef,x	                rol osfileParameterBlock+2,x
1798	.9283		3e f0 02	rol $02f0,x	                rol osfileParameterBlock+3,x
1799	.9286		b0 61		bcs $92e9	                bcs badAddressError ;carry out of bit 31 implies too many digits
1800	.9288		88		dey		                dey
1801	.9289		d0 ee		bne $9279	                bne shiftIn1DigitLoop
1802	.928b		7a		ply		                ply
1803	.928c		20 10 84	jsr $8410	                jsr readHexDigit
1804	.928f		b0 e1		bcs $9272	                bcs readDigitsLoop   ;keep going until hex digits stop
1805	.9291		38		sec		                sec       ;got at least 1 hex digit, so result is good
1806	.9292						rts92F4:
1807	.9292		60		rts		                rts

1809							;-------------------------------------------------------------------------
1810							;
1811							; *GO (<addr>) [MasRef C.5-6]
1812							;
1813	.9293						starGO:
1814	.9293		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
1815	.9296		d0 03		bne $929b	                bne starGOIO             ; Jump to read parameters
1816	.9298		4c 29 84	jmp $8429	                jmp commandLineUI        ; No parameters, enter CLICOM

1818							;-------------------------------------------------------------------------
1819							;
1820							; *GOIO <addr> [MasRef C.5-7]
1821							;
1822	.929b						starGOIO:
1823	.929b		a2 00		ldx #$00	                ldx #$00
1824	.929d		20 f9 92	jsr $92f9	                jsr parseHexAddressFromCommandLine ; Read hex address
1825	.92a0		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
1826	.92a3		08		php		                php  ; Update &F2/3 to point to any further parameters
1827	.92a4		98		tya		                tya
1828	.92a5		18		clc		                clc
1829	.92a6		65 f2		adc $f2		                adc stringInputBufferAddress+0
1830	.92a8		85 f2		sta $f2		                sta stringInputBufferAddress+0
1831	.92aa		90 02		bcc $92ae	                bcc +
1832	.92ac		e6 f3		inc $f3		                inc stringInputBufferAddress+1
1833	.92ae						+
1834	.92ae		a0 00		ldy #$00	                ldy #$00    ; (&F2),y=>parameters, EQ if no parameters
1835	.92b0		28		plp		                plp
1836	.92b1		6c ed 02	jmp ($02ed)	                jmp (osfileParameterBlock+0) ; Jump to address

1838							;-------------------------------------------------------------------------

1840	.92b4						starLOAD:
1841	.92b4		a9 ff		lda #$ff	                lda #fileLoad
1842	.92b6						starCommandThroughOSFILE:
1843	.92b6		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
1844	.92b9						L931B:
1845	.92b9		86 f2		stx $f2		                stx stringInputBufferAddress+0
1846	.92bb		84 f3		sty $f3		                sty stringInputBufferAddress+1
1847	.92bd		8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
1848	.92c0		8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
1849	.92c3		48		pha		                pha                          ;save OSFILE reason
1850	.92c4		a2 02		ldx #$02	                ldx #OSFILEParameterBlock.load
1851	.92c6		20 5a 92	jsr $925a	                jsr clearOSFILEParameterBlockDWORD
1852	.92c9		a2 0a		ldx #$0a	                ldx #OSFILEParameterBlock.length
1853	.92cb		20 5a 92	jsr $925a	                jsr clearOSFILEParameterBlockDWORD
1854	.92ce		a0 ff		ldy #$ff	                ldy #$FF
1855	.92d0		8c f3 02	sty $02f3	                sty osfileParameterBlock+OSFILEParameterBlock.exec+0 ;by default, load to file's load address
1856	.92d3		c8		iny		                iny                                                  ;Y=0
1857	.92d4		20 e0 f1	jsr $f1e0	                jsr gsinitForFilenameParsing
1858	.92d7						L9339:
1859	.92d7		20 f2 f1	jsr $f1f2	                jsr gsreadEntryPoint
1860	.92da		90 fb		bcc $92d7	                bcc L9339
1861	.92dc		68		pla		                pla                          ;restore OSFILE reason
1862	.92dd		48		pha		                pha                          ;save OSFILE reason
1863	.92de		10 4c		bpl $932c	                bpl finishStarSAVE                    ;taken if *SAVE
1864	.92e0		a2 02		ldx #$02	                ldx #OSFILEParameterBlock.load
1865	.92e2		20 67 92	jsr $9267	                jsr parseHexAddressFromString ;parse *LOAD address
1866	.92e5		b0 18		bcs $92ff	                bcs doStarLOADWithExplicitAddress ;taken if good address
1867	.92e7		f0 1b		beq $9304	                beq L9366        ;taken if CR encountered (this is ok)
1868	.92e9						badAddressError:
1869	.92e9		20 2f ab	jsr $ab2f	                jsr doFollowingError
1870	>92ec		fc 42 61 64 20 61 64 64		                .text $fc,"Bad address",0
	>92f4		72 65 73 73 00

1872							;-------------------------------------------------------------------------
1873							;
1874							; Parse hex address from command line.
1875							;
1876	.92f9						parseHexAddressFromCommandLine:
1877	.92f9		20 67 92	jsr $9267	                jsr parseHexAddressFromString ; Read hex address
1878	.92fc		90 eb		bcc $92e9	                bcc badAddressError           ; Jump with bad address
1879	.92fe		60		rts		                rts

1881							;-------------------------------------------------------------------------

1883	.92ff						doStarLOADWithExplicitAddress:
1884	.92ff		d0 7b		bne $937c	                bne badCommandError93E2
1885	.9301		ee f3 02	inc $02f3	                inc osfileParameterBlock+OSFILEParameterBlock.exec+0 ;load to parameter block load address
1886	.9304						L9366:
1887	.9304		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
1888	.9307						callOSFILEWithOSFILEParameterBlock:
1889	.9307		a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
1890	.9309		a0 02		ldy #$02	                ldy #>osfileParameterBlock
1891	.930b		68		pla		                pla
1892	.930c		4c dd ff	jmp $ffdd	                jmp OSFILE

1894							;-------------------------------------------------------------------------
1895							;
1896							; *REMOVE [MasRef G.5-9]
1897							;
1898	.930f						starREMOVE:
1899	.930f		8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
1900	.9312		8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
1901							                .if version>=510||version==350
1902	.9315		86 f2		stx $f2		                stx stringInputBufferAddress+0
1903	.9317		84 f3		sty $f3		                sty stringInputBufferAddress+1
1904	.9319		a0 ff		ldy #$ff	                ldy #$ff
1905	.931b						L9596:
1906	.931b		c8		iny		                iny
1907	.931c		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
1908	.931e		c9 21		cmp #$21	                cmp #'!'
1909	.9320		b0 f9		bcs $931b	                bcs L9596
1910	.9322		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
1911	.9325		d0 55		bne $937c	                bne badCommandError93E2
1912							                .endif
1913	.9327		a9 06		lda #$06	                lda #fileDelete
1914	.9329		48		pha		                pha
1915	.932a		80 db		bra $9307	                bra callOSFILEWithOSFILEParameterBlock

1917							;-------------------------------------------------------------------------
1918							                .if version<510&&version!=350
1928							                .endif
1929							;-------------------------------------------------------------------------
1930							                .if version<510&&version!=350
1943							                .endif
1944							;-------------------------------------------------------------------------

1946	.932c						finishStarSAVE:
1947	.932c		d0 07		bne $9335	                bne L939B
1948	.932e		a2 0a		ldx #$0a	                ldx #OSFILEParameterBlock.saveStart
1949	.9330		20 67 92	jsr $9267	                jsr parseHexAddressFromString
1950	.9333		90 47		bcc $937c	                bcc badCommandError93E2
1951	.9335						L939B:
1952	.9335		b8		clv		                clv
1953	.9336		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
1954	.9338		c9 2b		cmp #$2b	                cmp #'+'
1955	.933a		d0 04		bne $9340	                bne L93A6                    ;taken if "*SAVE START END..."
1956	.933c		2c 5e e3	bit $e35e	                bit valueFF              ;V=1
1957	.933f		c8		iny		                iny
1958	.9340						L93A6:
1959	.9340		a2 0e		ldx #$0e	                ldx #OSFILEParameterBlock.saveEnd
1960	.9342		20 67 92	jsr $9267	                jsr parseHexAddressFromString
1961	.9345		90 35		bcc $937c	                bcc badCommandError93E2
1962	.9347		08		php		                php
1963	.9348		50 0f		bvc $9359	                bvc L93BF                    ;taken if "*SAVE START END"

1965							                ; Get the save end address.
1966	.934a		a2 fc		ldx #$fc	                ldx #256-4
1967	.934c		18		clc		                clc
1968	.934d						-
1969							                ; TODO - not sure why the @w notation is required here?
1970	.934d		bd fb 01	lda $01fb,x	                lda@w osfileParameterBlock+OSFILEParameterBlock.saveStart-(256-4),x
1971	.9350		7d ff 01	adc $01ff,x	                adc@w osfileParameterBlock+OSFILEParameterBlock.saveEnd-(256-4),x
1972	.9353		9d ff 01	sta $01ff,x	                sta@w osfileParameterBlock+OSFILEParameterBlock.saveEnd-(256-4),x
1973	.9356		e8		inx		                inx
1974	.9357		d0 f4		bne $934d	                bne -
1975	.9359						L93BF:

1977							                ; Initialize load and exec addresses to save start
1978							                ; address.
1979	.9359		a2 03		ldx #$03	                ldx #$03
1980	.935b						-
1981	.935b		bd f7 02	lda $02f7,x	                lda@w osfileParameterBlock+OSFILEParameterBlock.saveStart,x
1982	.935e		9d f3 02	sta $02f3,x	                sta@w osfileParameterBlock+OSFILEParameterBlock.exec,x
1983	.9361		9d ef 02	sta $02ef,x	                sta@w osfileParameterBlock+OSFILEParameterBlock.load,x
1984	.9364		ca		dex		                dex
1985	.9365		10 f4		bpl $935b	                bpl -

1987	.9367		28		plp		                plp
1988	.9368		f0 9a		beq $9304	                beq L9366

1990	.936a		a2 06		ldx #$06	                ldx #OSFILEParameterBlock.exec
1991	.936c		20 67 92	jsr $9267	                jsr parseHexAddressFromString
1992	.936f		90 0b		bcc $937c	                bcc badCommandError93E2
1993	.9371		f0 91		beq $9304	                beq L9366

1995	.9373		a2 02		ldx #$02	                ldx #OSFILEParameterBlock.load
1996	.9375		20 67 92	jsr $9267	                jsr parseHexAddressFromString
1997	.9378		90 02		bcc $937c	                bcc badCommandError93E2
1998	.937a		f0 88		beq $9304	                beq L9366

2000	.937c						badCommandError93E2:
2001	.937c		4c 29 f9	jmp $f929	                jmp badCommandError

2003							;-------------------------------------------------------------------------

2005	.937f						starFX:
2006	.937f		20 b0 83	jsr $83b0	                jsr parseNumberFromString
2007	.9382		90 f8		bcc $937c	                bcc badCommandError93E2
2008	.9384		8a		txa		                txa
2009	.9385						starCommandThroughOSBYTE:
2010	.9385		08		php		                php
2011	.9386		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
2012	.9389		28		plp		                plp
2013	.938a		48		pha		                pha
2014	.938b		64 e5		stz $e5		                stz $E5
2015	.938d		64 e4		stz $e4		                stz $E4
2016	.938f		20 7b f2	jsr $f27b	                jsr LF308
2017	.9392		f0 18		beq $93ac	                beq L9412
2018	.9394		20 b0 83	jsr $83b0	                jsr parseNumberFromString
2019	.9397		90 e3		bcc $937c	                bcc badCommandError93E2
2020	.9399		86 e5		stx $e5		                stx $E5
2021	.939b		20 7d f2	jsr $f27d	                jsr LF30A
2022	.939e		f0 0c		beq $93ac	                beq L9412
2023	.93a0		20 b0 83	jsr $83b0	                jsr parseNumberFromString
2024	.93a3		90 d7		bcc $937c	                bcc badCommandError93E2
2025	.93a5		86 e4		stx $e4		                stx $E4
2026	.93a7		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
2027	.93aa						L9625:
2028	.93aa		d0 d0		bne $937c	                bne badCommandError93E2
2029	.93ac						L9412:
2030	.93ac		a4 e4		ldy $e4		                ldy $E4
2031	.93ae		a6 e5		ldx $e5		                ldx $E5
2032	.93b0		68		pla		                pla
2033	.93b1		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
2034	.93b4		20 f4 ff	jsr $fff4	                jsr OSBYTE
2035	.93b7		70 c3		bvs $937c	                bvs badCommandError93E2
2036	.93b9						rts941F:
2037	.93b9		60		rts		                rts

2039							;-------------------------------------------------------------------------

2041	.93ba						starSPOOLON:
2042	.93ba		38		sec		                sec
2043	.93bb		80 14		bra $93d1	                bra starSPOOL

2045							;-------------------------------------------------------------------------

2047							                .if version>=510||version==350
2048	.93bd						starSHADOW:
2049	.93bd		a9 72		lda #$72	                lda #$72
2050	.93bf						L963A:
2051	.93bf		80 c4		bra $9385	                bra starCommandThroughOSBYTE
2052							                .endif

2054							;-------------------------------------------------------------------------

2056	.93c1						osbyte77:
2057	.93c1		a2 10		ldx #$10	                ldx #romServiceCallSpoolExecClosureWarning
2058	.93c3		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
2059	.93c6		f0 f1		beq $93b9	                beq rts941F
2060	.93c8		20 a5 a5	jsr $a5a5	                jsr LA58B
2061	.93cb		ad 57 02	lda $0257	                lda spoolFileHandle
2062	.93ce		20 85 a5	jsr $a585	                jsr LA56B
2063	.93d1						starSPOOL:
2064	.93d1		08		php		                php
2065	.93d2		5a		phy		                phy
2066	.93d3		ac 57 02	ldy $0257	                ldy spoolFileHandle
2067	.93d6		8d 57 02	sta $0257	                sta spoolFileHandle
2068	.93d9		f0 03		beq $93de	                beq L9440
2069	.93db		20 ce ff	jsr $ffce	                jsr OSFIND
2070	.93de						L9440:
2071	.93de		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
2072	.93e1		7a		ply		                ply
2073	.93e2		28		plp		                plp
2074	.93e3		f0 d4		beq $93b9	                beq rts941F
2075	.93e5		a9 80		lda #$80	                lda #$80
2076	.93e7		90 02		bcc $93eb	                bcc L944D
2077	.93e9		a9 c0		lda #$c0	                lda #$C0
2078	.93eb						L944D:
2079	.93eb		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
2080	.93ee		20 ce ff	jsr $ffce	                jsr OSFIND
2081	.93f1		a8		tay		                tay
2082	.93f2		f0 88		beq $937c	                beq badCommandError93E2
2083	.93f4		8d 57 02	sta $0257	                sta spoolFileHandle
2084	.93f7		a8		tay		                tay
2085	.93f8						setPTRToEOF:
2086	.93f8		a9 02		lda #$02	                lda #argsFileGetEXT
2087	.93fa		20 ff 93	jsr $93ff	                jsr callOSARGSWithBuffer
2088	.93fd						setFilePointerFromOSARGSBuffer:
2089	.93fd		a9 01		lda #$01	                lda #argsFileSetPTR
2090	.93ff						callOSARGSWithBuffer:
2091	.93ff		a2 a8		ldx #$a8	                ldx #osargsBuffer
2092	.9401		4c da ff	jmp $ffda	                jmp OSARGS

2094							;-------------------------------------------------------------------------

2096							                .if version<510&&version!=350
2100							                .endif

2102							;-------------------------------------------------------------------------

2104							                .if version>=510||version==350
2105	.9404						starCLOSE:
2106	.9404		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
2107	.9407		d0 a1		bne $93aa	                bne L9625
2108	.9409		a9 00		lda #$00	                lda #$00
2109	.940b		a8		tay		                tay
2110	.940c		6c 1c 02	jmp ($021c)	                jmp (FINDV)                  ;OSFIND A=0 Y=0
2111							                .endif

2113							;-------------------------------------------------------------------------

2115							                .if version>=510||version==350
2116	.940f						starIGNORE:
2117	.940f		d0 05		bne $9416	                bne L938E
2118	.9411		38		sec		                sec
2119	.9412		6e 46 02	ror $0246	                ror noignoreState
2120	.9415		60		rts		                rts

2122	.9416						L938E:
2123	.9416		a9 06		lda #$06	                lda #$06
2124	.9418		80 a5		bra $93bf	                bra L963A
2125							                .endif

2127							;-------------------------------------------------------------------------
2128							;
2129	.941a						starDELETE:
2130	.941a		20 0f 93	jsr $930f	                jsr starREMOVE
2131	.941d		a8		tay		                tay
2132	.941e		d0 99		bne $93b9	                bne rts941F
2133	.9420		4c 67 a5	jmp $a567	                jmp notFoundError

2135							;-------------------------------------------------------------------------

2137							                .if version==350
2138							                .include "rtc.s65"

:11	;******  Processing file: src/rtc.s65

1							                .if version<500
2							; Day string not matched
3							; ----------------------
4	.9423						nextDayString:
5	.9423		68		pla		                pla                          ; Drop number of characters matched
6	.9424		68		pla		                pla                          ; Get offset to string table
7	.9425		7a		ply		                ply                          ; Get start of supplied string
8	.9426		18		clc		                clc                          ; Step to next string table entry
9	.9427		69 04		adc #$04	                adc #$04
10	.9429		c9 1c		cmp #$1c	                cmp #size(dayOfWeekStrings) ; If not checked 28/4=7 entries, keep looking
11	.942b		90 1c		bcc $9449	                bcc checkDayString
12	.942d		60		rts		                rts                          ; Otherwise exit silently

14							; Month string not matched
15							; ------------------------
16	.942e						nextMonthString:
17	.942e		68		pla		                pla                          ; Drop number of characters matched
18	.942f		68		pla		                pla                          ; Get offset to string table
19	.9430		7a		ply		                ply                          ; Get start of supplied string
20	.9431		18		clc		                clc                          ; Step to next string table entry
21	.9432		69 04		adc #$04	                adc #$04
22	.9434		c9 30		cmp #$30	                cmp #size(monthStrings) ; If not checked 48/4=12 entries, keep looking
23	.9436		90 43		bcc $947b	                bcc checkMonthString
24	.9438						rts9655:
25	.9438		60		rts		                rts                          ; Otherwise exit silently

27							;-------------------------------------------------------------------------
28							;
29							; OSWORD 15 (&0F) Write CMOS clock [MasRef D.3-24]
30							;
31	.9439						osword0F:
32	.9439		9c ed 02	stz $02ed	                stz osfileParameterBlock     ;got no time, got no date
33	.943c		49 0f		eor #$0f	                eor #15                     ; len=15, set date
34	.943e		f0 08		beq $9448	                beq setDate
35	.9440		49 07		eor #$07	                eor #15^8
36	.9442		f0 76		beq $94ba	                beq setTime
37	.9444		49 10		eor #$10	                eor #(15^8)^23
38	.9446		d0 f0		bne $9438	                bne rts9655

40							; Set date and set date+time
41							; --------------------------
42							; (&F0),1=>"Day,00 Mon 0000"
43							; (&F0),1=>"Day,00 Mon 0000.00:00:00"
44							; A=0, Y=0
45	.9448						setDate:
46	.9448		c8		iny		                iny                          ; Point to supplied data
47							; Translate day string into day number
48	.9449						checkDayString:
49	.9449		5a		phy		                phy                          ; Push pointer to data string
50	.944a		48		pha		                pha                          ; Push offset to match strings
51	.944b		aa		tax		                tax                          ; X=>match strings
52	.944c		a9 03		lda #$03	                lda #$03                     ; A=3 characters to match
53	.944e						checkDayStringLoop:
54	.944e		48		pha		                pha                          ; Save number of characters to match
55	.944f		b1 f0		lda ($f0),y	                lda (originalX),y      ; Get character from string
56	.9451		5d 4b 95	eor $954b,x	                eor dayOfWeekStrings,x ; Compare with day string table
57	.9454		29 df		and #$df	                and #$DF                     ; Force to upper case
58	.9456		d0 cb		bne $9423	                bne nextDayString  ; No match step to check next entry
59	.9458		e8		inx		                inx                          ; Step to next character to match
60	.9459		c8		iny		                iny                          ; Step to next data character
61	.945a		68		pla		                pla                          ; Get character count back
62	.945b		3a		dec a		                dec a                        ; Decrement and loop until 3 characters matched
63	.945c		d0 f0		bne $944e	                bne checkDayStringLoop
64	.945e		bd 4b 95	lda $954b,x	                lda dayOfWeekStrings,x ; Get translation byte from string table
65	.9461		8d f4 02	sta $02f4	                sta osfileParameterBlock+1+RTC.dayOfWeek ; Store it in workspace
66							; Translates Sun,Mon,Tue,etc to &01,&02,&03,etc
67	.9464		fa		plx		                plx                          ; Drop char count and table offset
68	.9465		fa		plx		                plx
69	.9466		b1 f0		lda ($f0),y	                lda ($F0),y                  ; Get next character
70	.9468		c9 2c		cmp #$2c	                cmp #','                     ; Not followed by a comma, so exit silently
71	.946a		d0 cc		bne $9438	                bne rts9655
72	.946c		a2 07		ldx #$07	                ldx #$07                     ; Get day of month
73	.946e		20 13 95	jsr $9513	                jsr readDecimalBCDByte
74	.9471		90 c5		bcc $9438	                bcc rts9655                    ; Bad number, exit silently
75	.9473		c8		iny		                iny                          ; Get next character
76	.9474		b1 f0		lda ($f0),y	                lda ($F0),y
77	.9476		49 20		eor #$20	                eor #' '                     ; Not space, exit silently
78	.9478		d0 be		bne $9438	                bne rts9655
79	.947a		c8		iny		                iny                          ; Step to first character of month
80							; Translate month string into month number
81							; This could use the same code as the Day translation
82	.947b						checkMonthString:
83	.947b		5a		phy		                phy                          ; Push pointer to data string
84	.947c		48		pha		                pha                          ; Push offset to match strings
85	.947d		aa		tax		                tax                          ; X=>match strings
86	.947e		a9 03		lda #$03	                lda #$03                     ; A=3 characters to match
87	.9480						checkMonthStringLoop:
88	.9480		48		pha		                pha
89	.9481		b1 f0		lda ($f0),y	                lda (originalX),y
90	.9483		5d 67 95	eor $9567,x	                eor monthStrings,x
91	.9486		29 df		and #$df	                and #$DF
92	.9488		d0 a4		bne $942e	                bne nextMonthString
93	.948a		e8		inx		                inx
94	.948b		c8		iny		                iny
95	.948c		68		pla		                pla
96	.948d		3a		dec a		                dec a
97	.948e		d0 f0		bne $9480	                bne checkMonthStringLoop
98	.9490		bd 67 95	lda $9567,x	                lda monthStrings,x
99	.9493		8d f6 02	sta $02f6	                sta osfileParameterBlock+1+RTC.month
100							; Translates Jan,Feb,Mar,etc to &01,&02,&03,etc..&09,&10,&11,&12
101	.9496		fa		plx		                plx                          ; Drop char count and table offset
102	.9497		fa		plx		                plx
103	.9498		b1 f0		lda ($f0),y	                lda ($F0),y                  ; Get next character
104	.949a		c9 20		cmp #$20	                cmp #' '                     ; Not followed by space, exit silently
105	.949c		d0 9a		bne $9438	                bne rts9655
106	.949e		a2 09		ldx #$09	                ldx #RTC.year
107	.94a0		20 13 95	jsr $9513	                jsr readDecimalBCDByte
108	.94a3		90 93		bcc $9438	                bcc rts9655                    ; Bad number, exit silently
109	.94a5		20 13 95	jsr $9513	                jsr readDecimalBCDByte                    ; Get year number
110	.94a8		90 8e		bcc $9438	                bcc rts9655                    ; Bad number, exit silently
111	.94aa		6e ed 02	ror $02ed	                ror osfileParameterBlock+0     ;got date
112	.94ad		b2 f0		lda ($f0)	                lda (originalX)        ; Get data length
113	.94af		c9 0f		cmp #$0f	                cmp #$0F                     ; len=15, jump to just set date
114	.94b1		f0 2f		beq $94e2	                beq setRTCDate
115							; Must be len=24 to set date+time
116	.94b3		c8		iny		                iny                          ; Get next character
117	.94b4		b1 f0		lda ($f0),y	                lda (originalX),y
118	.94b6		c9 2e		cmp #$2e	                cmp #'.'                     ; If not full stop, exit silently
119	.94b8		d0 7c		bne $9536	                bne rts9753

121	.94ba						setTime:
122	.94ba		a2 04		ldx #$04	                ldx #RTC.hours
123	.94bc		20 13 95	jsr $9513	                jsr readDecimalBCDByte
124	.94bf		90 75		bcc $9536	                bcc rts9753
125	.94c1		c8		iny		                iny
126	.94c2		b1 f0		lda ($f0),y	                lda (originalX),y
127	.94c4		c9 3a		cmp #$3a	                cmp #':'
128	.94c6		d0 6e		bne $9536	                bne rts9753
129	.94c8		a2 02		ldx #$02	                ldx #RTC.minutes
130	.94ca		20 13 95	jsr $9513	                jsr readDecimalBCDByte
131	.94cd		90 67		bcc $9536	                bcc rts9753
132	.94cf		c8		iny		                iny
133	.94d0		b1 f0		lda ($f0),y	                lda (originalX),y
134	.94d2		c9 3a		cmp #$3a	                cmp #':'
135	.94d4		d0 60		bne $9536	                bne rts9753
136	.94d6		a2 00		ldx #$00	                ldx #RTC.seconds
137	.94d8		20 13 95	jsr $9513	                jsr readDecimalBCDByte
138	.94db		90 59		bcc $9536	                bcc rts9753
139	.94dd		a9 40		lda #$40	                lda #$40
140	.94df		0c ed 02	tsb $02ed	                tsb osfileParameterBlock+0   ;got time
141	.94e2						setRTCDate:
142	.94e2		58		cli		                cli
143	.94e3		78		sei		                sei
144	.94e4		a0 83		ldy #$83	                ldy #RTC.b.set|RTC.b._24h|RTC.b.dse
145	.94e6		a2 0b		ldx #$0b	                ldx #RTC.b
146	.94e8		20 d0 96	jsr $96d0	                jsr writeRTCByte
147	.94eb		2c ed 02	bit $02ed	                bit osfileParameterBlock+0 ;N=1 if got date; V=1 if got time
148	.94ee		10 0f		bpl $94ff	                bpl setRTCTime ;taken if not got date - must then have time
149	.94f0		a2 06		ldx #$06	                ldx #$06
150	.94f2						-
151	.94f2		bc ee 02	ldy $02ee,x	                ldy osfileParameterBlock+1,x
152	.94f5		20 d0 96	jsr $96d0	                jsr writeRTCByte
153	.94f8		e8		inx		                inx
154	.94f9		e0 0a		cpx #$0a	                cpx #RTC.a
155	.94fb		90 f5		bcc $94f2	                bcc -
156	.94fd		50 0d		bvc $950c	                bvc finishRTCUpdate                    ;taken if not got date
157	.94ff						setRTCTime:
158	.94ff		a2 00		ldx #$00	                ldx #RTC.seconds
159	.9501						-
160	.9501		bc ee 02	ldy $02ee,x	                ldy osfileParameterBlock+1,x
161	.9504		20 d0 96	jsr $96d0	                jsr writeRTCByte
162	.9507		e8		inx		                inx
163	.9508		e0 06		cpx #$06	                cpx #RTC.dayOfWeek
164	.950a		90 f5		bcc $9501	                bcc -
165	.950c						finishRTCUpdate:
166	.950c		a2 0b		ldx #$0b	                ldx #RTC.b
167	.950e		a0 02		ldy #$02	                ldy #RTC.b._24h
168	.9510		4c d0 96	jmp $96d0	                jmp writeRTCByte

170	.9513						readDecimalBCDByte:
171	.9513		20 37 95	jsr $9537	                jsr readDecimalDigit
172	.9516		49 20		eor #$20	                eor #$20         ;check for ' '
173	.9518		f0 04		beq $951e	                beq +        ;taken if leading space - that's fine
174	.951a		49 20		eor #$20	                eor #$20         ;reinstate old value
175	.951c		90 18		bcc $9536	                bcc rts9753      ;taken if non-space non-digits
176	.951e						+
177	.951e		9d ee 02	sta $02ee,x	                sta osfileParameterBlock+1,x
178	.9521		20 37 95	jsr $9537	                jsr readDecimalDigit
179	.9524		90 10		bcc $9536	                bcc rts9753                  ;taken if invalid digit

181							                ; rotate new digit into place
182	.9526		5a		phy		                phy
183	.9527		a0 04		ldy #$04	                ldy #$04
184	.9529		0a		asl a		                asl a
185	.952a		0a		asl a		                asl a
186	.952b		0a		asl a		                asl a
187	.952c		0a		asl a		                asl a
188	.952d						-
189	.952d		0a		asl a		                asl a
190	.952e		3e ee 02	rol $02ee,x	                rol osfileParameterBlock+1,x
191	.9531		88		dey		                dey
192	.9532		d0 f9		bne $952d	                bne -
193	.9534		7a		ply		                ply
194	.9535		38		sec		                sec
195	.9536						rts9753:
196	.9536		60		rts		                rts

198	.9537						readDecimalDigit:
199	.9537		c8		iny		                iny
200	.9538		b1 f0		lda ($f0),y	                lda (originalX),y
201	.953a		c9 3a		cmp #$3a	                cmp #'9'+1
202	.953c		b0 07		bcs $9545	                bcs notDecimalDigit
203	.953e		c9 30		cmp #$30	                cmp #'0'
204	.9540		90 03		bcc $9545	                bcc notDecimalDigit
205	.9542		29 0f		and #$0f	                and #$0F
206	.9544		60		rts		                rts

208	.9545						notDecimalDigit:
209	.9545		18		clc		                clc
210	.9546		60		rts		                rts
211							                .endif

213							;-------------------------------------------------------------------------

215							; TODO - is this necessary?
216							;
217							; There's a reference to dayOfWeekStrings-4, but that seems to be
218							; because days are 1-based. The data here is presumably never
219							; accesssed.
220	>9547		20 20 20 00			                .text "   ",0

222							;-------------------------------------------------------------------------

224	.954b						dayOfWeekStrings: .block
225	>954b		53 75 6e 01			                .text "Sun",$01
226	>954f		4d 6f 6e 02			                .text "Mon",$02
227	>9553		54 75 65 03			                .text "Tue",$03
228	>9557		57 65 64 04			                .text "Wed",$04
229	>955b		54 68 75 05			                .text "Thu",$05
230	>955f		46 72 69 06			                .text "Fri",$06
231	>9563		53 61 74 07			                .text "Sat",$07
232							                .endblock

234							;-------------------------------------------------------------------------

236	.9567						monthStrings: .block
237	>9567		4a 61 6e 01			                .text "Jan",$01
238	>956b		46 65 62 02			                .text "Feb",$02
239	>956f		4d 61 72 03			                .text "Mar",$03
240	>9573		41 70 72 04			                .text "Apr",$04
241	>9577		4d 61 79 05			                .text "May",$05
242	>957b		4a 75 6e 06			                .text "Jun",$06
243	>957f		4a 75 6c 07			                .text "Jul",$07
244	>9583		41 75 67 08			                .text "Aug",$08
245	>9587		53 65 70 09			                .text "Sep",$09
246	>958b		4f 63 74 10			                .text "Oct",$10
247	>958f		4e 6f 76 11			                .text "Nov",$11
248	>9593		44 65 63 12			                .text "Dec",$12
249							                .endblock

251							;-------------------------------------------------------------------------

253							                .if version>=500
262							                .endif

264							;-------------------------------------------------------------------------

266							                .if version>=500
270							                .endif

272							;-------------------------------------------------------------------------
273							;
274							; OSWORD 14 (&0E) Read CMOS clock [MasRef D.3-22]
275							;

277	.9597						osword0E:
278							                .if version<500
279	.9597		48		pha		                pha                          ;save reason code
280	.9598		49 02		eor #$02	                eor #$02                     ;
281	.959a		d0 1b		bne $95b7	                bne readClock
325							                .endif

327							                ; Convert given time to string. Fill out the RTC temp
328							                ; data with the info from the parameter block, then
329							                ; pass on to the common code.
330	.959c		a0 07		ldy #$07	                ldy #$07

332							                ; Copy hours, mins, secs.
333	.959e		a2 00		ldx #$00	                ldx #$00
334	.95a0						-
335	.95a0		b1 f0		lda ($f0),y	                lda ($F0),y
336	.95a2		9d ee 02	sta $02ee,x	                sta osfileParameterBlock+1,x
337	.95a5		88		dey		                dey
338	.95a6		e8		inx		                inx
339	.95a7		e8		inx		                inx
340	.95a8		e0 06		cpx #$06	                cpx #$06
341	.95aa		90 f4		bcc $95a0	                bcc -

343							                ; Copy day of week, day of month, month, year.
344	.95ac						-
345	.95ac		b1 f0		lda ($f0),y	                lda (originalX),y
346	.95ae		9d ee 02	sta $02ee,x	                sta osfileParameterBlock+1,x
347	.95b1		e8		inx		                inx
348	.95b2		88		dey		                dey
349	.95b3		d0 f7		bne $95ac	                bne -

351							                .if version<500
352	.95b5		80 30		bra $95e7	                bra maybeConvertToString ; (called from here, there's no maybe about it)

354	.95b7						readClock:
355	.95b7		a5 f0		lda $f0		                lda originalX
356	.95b9		48		pha		                pha
357	.95ba		a5 f1		lda $f1		                lda originalY
358	.95bc		48		pha		                pha
359	.95bd						readRTCClock:
360	.95bd		a2 0c		ldx #$0c	                ldx #RTC.c
361	.95bf		20 a3 96	jsr $96a3	                jsr readRTCByte ;clear the various IRQ flags with a read of register C
362	.95c2		a2 09		ldx #$09	                ldx #RTC.year
363	.95c4						-
364	.95c4		20 a3 96	jsr $96a3	                jsr readRTCByte
365	.95c7		9d ee 02	sta $02ee,x	                sta osfileParameterBlock+1,x
366	.95ca		ca		dex		                dex
367	.95cb		10 f7		bpl $95c4	                bpl -
368	.95cd		a2 0a		ldx #$0a	                ldx #RTC.a
369	.95cf		20 a3 96	jsr $96a3	                jsr readRTCByte
370	.95d2		10 04		bpl $95d8	                bpl L97F5 ;taken if update not in progress - result is good
371	.95d4						retryReadRTCClock:
372	.95d4		58		cli		                cli
373	.95d5		78		sei		                sei
374	.95d6		80 e5		bra $95bd	                bra readRTCClock

376	.95d8						L97F5:
377	.95d8		a2 0c		ldx #$0c	                ldx #RTC.c
378	.95da		20 a3 96	jsr $96a3	                jsr readRTCByte
379	.95dd		29 10		and #$10	                and #RTC.c.uf
380	.95df		d0 f3		bne $95d4	                bne retryReadRTCClock
381	.95e1		68		pla		                pla
382	.95e2		85 f1		sta $f1		                sta originalY
383	.95e4		68		pla		                pla
384	.95e5		85 f0		sta $f0		                sta originalX
385	.95e7						maybeConvertToString:
386	.95e7		68		pla		                pla                          ;get reason code
387	.95e8		3a		dec a		                dec a
388	.95e9		d0 1a		bne $9605	                bne convertTimeToString                    ;taken if 0 or 2

390							                ; Copy year, month, day of month, day of week.
391	.95eb		a0 00		ldy #$00	                ldy #$00
392	.95ed		a2 09		ldx #$09	                ldx #RTC.year
393	.95ef						-
394	.95ef		bd ee 02	lda $02ee,x	                lda osfileParameterBlock+1,x
395	.95f2		91 f0		sta ($f0),y	                sta (originalX),y
396	.95f4		c8		iny		                iny
397	.95f5		ca		dex		                dex
398	.95f6		e0 06		cpx #$06	                cpx #RTC.dayOfWeek
399	.95f8		b0 f5		bcs $95ef	                bcs -

401							                ; Copy hours, minutes, seconds.
402	.95fa						-
403	.95fa		bd ed 02	lda $02ed,x	                lda osfileParameterBlock,x
404	.95fd		91 f0		sta ($f0),y	                sta (originalX),y
405	.95ff		c8		iny		                iny
406	.9600		ca		dex		                dex
407	.9601		ca		dex		                dex
408	.9602		10 f6		bpl $95fa	                bpl -
409	.9604		60		rts		                rts

411							                .endif

413	.9605						convertTimeToString:
414							                ; Store terminating CR.
415	.9605		a0 18		ldy #$18	                ldy #ClockStringFormat.cr
416	.9607		a9 0d		lda #$0d	                lda #13
417	.9609		91 f0		sta ($f0),y	                sta (originalX),y
418	.960b		a2 00		ldx #$00	                ldx #$00
419	.960d		88		dey		                dey
420	.960e		20 73 96	jsr $9673	                jsr storeRTCDataByteString
421	.9611		a9 3a		lda #$3a	                lda #':'
422	.9613		91 f0		sta ($f0),y	                sta (originalX),y
423	.9615		a0 12		ldy #$12	                ldy #ClockStringFormat.hh+2
424	.9617		91 f0		sta ($f0),y	                sta (originalX),y
425	.9619		a2 02		ldx #$02	                ldx #RTC.minutes
426	.961b		a0 14		ldy #$14	                ldy #ClockStringFormat.mm+1
427	.961d		20 73 96	jsr $9673	                jsr storeRTCDataByteString
428	.9620		a2 04		ldx #$04	                ldx #RTC.hours
429	.9622		a0 11		ldy #$11	                ldy #ClockStringFormat.hh+1
430	.9624		20 73 96	jsr $9673	                jsr storeRTCDataByteString
431	.9627		a9 2e		lda #$2e	                lda #'.'
432	.9629		91 f0		sta ($f0),y	                sta (originalX),y
433	.962b		ad f4 02	lda $02f4	                lda osfileParameterBlock+1+RTC.dayOfWeek;
434	.962e		0a		asl a		                asl a
435	.962f		0a		asl a		                asl a
436	.9630		a0 00		ldy #$00	                ldy #$00
437	.9632		aa		tax		                tax
438	.9633						-
439	.9633		bd 47 95	lda $9547,x	                lda dayOfWeekStrings-4,x     ;-4 as 1=Sunday
440	.9636		91 f0		sta ($f0),y	                sta (originalX),y
441	.9638		e8		inx		                inx
442	.9639		c8		iny		                iny
443	.963a		c0 03		cpy #$03	                cpy #$03
444	.963c		90 f5		bcc $9633	                bcc -
445	.963e		a9 2c		lda #$2c	                lda #','
446	.9640		91 f0		sta ($f0),y	                sta (originalX),y
447	.9642		ad f6 02	lda $02f6	                lda osfileParameterBlock+1+RTC.month
448	.9645		c9 10		cmp #$10	                cmp #$10
449	.9647		90 02		bcc $964b	                bcc +
450	.9649		e9 06		sbc #$06	                sbc #$06            ;convert $10, $11 and $12 from BCD
451	.964b						+
452	.964b		3a		dec a		                dec a                        ;make month 0-based
453	.964c		0a		asl a		                asl a
454	.964d		0a		asl a		                asl a
455	.964e		aa		tax		                tax
456	.964f		a0 07		ldy #$07	                ldy #ClockStringFormat.mmm
457	.9651						-
458	.9651		bd 67 95	lda $9567,x	                lda monthStrings,x
459	.9654		91 f0		sta ($f0),y	                sta ($F0),y
460	.9656		e8		inx		                inx
461	.9657		c8		iny		                iny
462	.9658		c0 0a		cpy #$0a	                cpy #ClockStringFormat.mmm+3
463	.965a		90 f5		bcc $9651	                bcc -
464	.965c		a2 09		ldx #$09	                ldx #RTC.year
465	.965e		a0 0e		ldy #$0e	                ldy #ClockStringFormat.yyyy+3
466	.9660		20 73 96	jsr $9673	                jsr storeRTCDataByteString
467	.9663		a9 19		lda #$19	                lda #assumedRTCCenturyBCD
468	.9665		20 76 96	jsr $9676	                jsr storeBCDByteString
469	.9668		a9 20		lda #$20	                lda #$20
470	.966a		91 f0		sta ($f0),y	                sta ($F0),y
471	.966c		a0 06		ldy #$06	                ldy #ClockStringFormat.nn+2
472	.966e		91 f0		sta ($f0),y	                sta ($F0),y
473	.9670		88		dey		                dey
474	.9671		a2 07		ldx #$07	                ldx #RTC.dayOfMonth
475	.9673						storeRTCDataByteString:
476	.9673		bd ee 02	lda $02ee,x	                lda osfileParameterBlock+1,x
477	.9676						storeBCDByteString:
478	.9676		48		pha		                pha
479	.9677		20 7e 96	jsr $967e	                jsr storeNybbleString
480	.967a		68		pla		                pla
481							                .if version==350
482	.967b		20 20 e5	jsr $e520	                jsr LE520
488							                .endif
489	.967e						storeNybbleString:
490	.967e		29 0f		and #$0f	                and #$0F
491	.9680		09 30		ora #$30	                ora #'0'
492	.9682		c9 3a		cmp #$3a	                cmp #'9'+1
493	.9684		90 02		bcc $9688	                bcc +
494	.9686		69 06		adc #$06	                adc #('A'-'9'-1)-1           ;(-1 because C set)
495	.9688						+
496	.9688		91 f0		sta ($f0),y	                sta (originalX),y
497	.968a		88		dey		                dey
498	.968b		60		rts		                rts

500							;-------------------------------------------------------------------------

502							                .if version<500
503							                .if version==350
504	.968c						clearTSTAndReadDefaults2:
505	.968c		20 5c f3	jsr $f35c	                jsr withTSTClear
506							                .endif
507	.968f						readDefaults2:
508	.968f		a2 1d		ldx #$1d	                ldx #CMOSBytes.defaults2+cmosBytesOffset
509	.9691		80 10		bra $96a3	                bra readRTCByte
510							                .endif

512							;-------------------------------------------------------------------------

514							                .if version<500
515							                .if version==350
516	.9693						clearTSTAndReadDefaults3:
517	.9693		20 5c f3	jsr $f35c	                jsr withTSTClear
518							                .endif
519	.9696						readDefaults3:
520	.9696		a2 1e		ldx #$1e	                ldx #CMOSBytes.defaults3+cmosBytesOffset
521	.9698		80 09		bra $96a3	                bra readRTCByte
522							                .endif

524							;-------------------------------------------------------------------------
525							;
526							; Read byte from RTC, either by 0-based CMOS RAM offset (readCMOSByte)
527							; or by RTC register index (readRTCByte).
528							;
529							; entry:
530							;
531							; X = address to read from
532							;
533							; exit:
534							;
535							; A = byte read
536							;
537							; N,Z = set as per byte read
538							;
539							                .if version<500
540	.969a						readCMOSByte:
541	.969a		20 e9 96	jsr $96e9	                jsr getRTCAddressForCMOSByte
542							                .if version==350
543	.969d		90 04		bcc $96a3	                bcc readRTCByte
544	.969f		60		rts		                rts
547							                .endif
548							                .if version==350
549	.96a0						clearTSTAndReadRTCByte:
550	.96a0		20 5c f3	jsr $f35c	                jsr withTSTClear
551							                .endif
552	.96a3						readRTCByte:
553	.96a3		08		php		                php
554	.96a4		78		sei		                sei
555	.96a5		20 f2 96	jsr $96f2	                jsr setRTCAddress
556	.96a8		a9 49		lda #$49	                lda #$49
557	.96aa		8d 40 fe	sta $fe40	                sta systemVIA.orb
558	.96ad		9c 43 fe	stz $fe43	                stz systemVIA.ddra
559	.96b0		a9 4a		lda #$4a	                lda #$4A
560	.96b2		8d 40 fe	sta $fe40	                sta systemVIA.orb
561	.96b5		ac 4f fe	ldy $fe4f	                ldy systemVIA.iraNoHandshake ;read value
562	.96b8						deselectRTC:
563	.96b8		a9 42		lda #$42	                lda #$42
564	.96ba		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=0
565	.96bd		a9 02		lda #$02	                lda #$02
566	.96bf		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=0 DS=0 R=0
567	.96c2		9c 43 fe	stz $fe43	                stz systemVIA.ddra           ;all bits inputs
568	.96c5		28		plp		                plp
569	.96c6		98		tya		                tya
570	.96c7						rts98DB:
571	.96c7		60		rts		                rts
572							                .endif

574							;-------------------------------------------------------------------------
575							;
576							; Write byte to RTC, either by 0-based CMOS RAM offset (writeCMOSByte)
577							; or by RTC register index (writeRTCByte).
578							;
579							; (For some reason, writeCMOSByte can't be used to write to CMOS RAM
580							; offset 0.)
581							;
582							; entry:
583							;
584							; X = address to write to
585							;
586							; Y = value to write
587							;
588							                .if version<500
589	.96c8						writeCMOSByte:
590	.96c8		8a		txa		                txa
591	.96c9		f0 fc		beq $96c7	                beq rts98DB
592	.96cb		20 e9 96	jsr $96e9	                jsr getRTCAddressForCMOSByte
593	.96ce		b0 f7		bcs $96c7	                bcs rts98DB
594	.96d0						writeRTCByte:
595	.96d0		08		php		                php
596	.96d1		78		sei		                sei
597	.96d2		20 f2 96	jsr $96f2	                jsr setRTCAddress            ;X=address
598	.96d5		a9 41		lda #$41	                lda #$41
599	.96d7		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=0
600	.96da		a9 ff		lda #$ff	                lda #$FF
601	.96dc		8d 43 fe	sta $fe43	                sta systemVIA.ddra           ;all bits outputs
602	.96df		a9 4a		lda #$4a	                lda #$4A
603	.96e1		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=1
604	.96e4		8c 4f fe	sty $fe4f	                sty systemVIA.oraNoHandshake ;store value
605	.96e7		80 cf		bra $96b8	                bra deselectRTC
606							                .endif

608							;-------------------------------------------------------------------------
609							;
610							; Convert CMOS byte offset to actual RTC address.
611							;
612							; entry:
613							;
614							; X = CMOS byte offset - 0-49
615							;
616							; exit:
617							;
618							; C=1 = invalid address
619							;
620							; C=0 = valid address: X = register index
621							;
622							                .if version<500
623	.96e9						getRTCAddressForCMOSByte:
624	.96e9		e0 32		cpx #$32	                cpx #size(RTC.ram)
625	.96eb		b0 04		bcs $96f1	                bcs rts9905
626	.96ed		8a		txa		                txa
627	.96ee		69 0e		adc #$0e	                adc #RTC.ram
628	.96f0		aa		tax		                tax
629	.96f1						rts9905:
630	.96f1		60		rts		                rts
631							                .endif

633							;-------------------------------------------------------------------------
634							;
635							; set RTC address for future read/write operation.
636							;
637							; entry:
638							;
639							; X = address to set
640							;
641							; preserves: Y
642							;
643							                .if version<500
644	.96f2						setRTCAddress:
645	.96f2		a9 02		lda #$02	                lda #$02
646	.96f4		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=0 DS=0 R=0
647	.96f7		a9 82		lda #$82	                lda #$82
648	.96f9		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=1 CS=0 DS=0 R=0
649	.96fc		a9 ff		lda #$ff	                lda #$FF
650	.96fe		8d 43 fe	sta $fe43	                sta systemVIA.ddra           ;all bits outputs
651	.9701		8e 4f fe	stx $fe4f	                stx systemVIA.oraNoHandshake ;write RTC address
652	.9704		a9 c2		lda #$c2	                lda #$c2
653	.9706		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=1 CS=1 DS=0 R=0
654	.9709		a9 42		lda #$42	                lda #$42
655	.970b		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=0
656	.970e						rts9922:
657	.970e		60		rts		                rts
658							                .endif


:7	;******  Return to file: src/terminal.s65

2139	=$970e						osbyte19Done=rts9922
2140							                .include "restore_font.s65"

:12	;******  Processing file: src/restore_font.s65

1							;-------------------------------------------------------------------------
2							;
3							; restore entire font.
4							;
5	.970f						restoreFont32To255:
6	.970f		a2 07		ldx #$07	                ldx #$07                     ;224 chars - 32-255
7							                .cerror *!=restoreFont32ToN
8							                ; fall through to restoreFont32ToN

10							;-------------------------------------------------------------------------
11							;
12							; Restore part of the font, starting from char 32.
13							;
14							; entry:
15							;
16							; X = number of pages of font data to restore - X*32 chars will be
17							; restored
18							;
19	.9711						restoreFont32ToN:
20	.9711		08		php		                php
21	.9712		78		sei		                sei
22	.9713		a9 b9		lda #$b9	                lda #>LB900                ;start at beginning of font
23	.9715		85 f1		sta $f1		                sta $F1
24	.9717		a9 89		lda #$89	                lda #>andy.softCharacterDefinitions ;write to beginning of soft character definitions
25							                .cerror *!=restoreFontPart
26							                ; fall through to restoreFontPart

28							;-------------------------------------------------------------------------
29							;
30							; Restore part of the font.
31							;
32							; entry:
33							;
34							; ?$f1 = MSB of font data
35							;
36							; A = MSB of dest page in ANDY - should be part of the soft character
37							; definitions!
38							;
39							; X = number of pages of font data to restore - X*32 chars will be
40							; restored
41							;
42							; preserves: Y

44	.9719						restoreFontPart:
45	.9719		85 fb		sta $fb		                sta $FB                      ;save MSB of dest
46	.971b		20 62 e5	jsr $e562	                jsr selectTerminalROMAndANDY2
47							                .cwarn *<$9000,format("Code inside ANDY at: $%04x",*) ; following code can't be inside the ANDY region!
48	.971e		5a		phy		                phy                          ;
49	.971f		a0 00		ldy #$00	                ldy #$00                     ;
50	.9721		64 fa		stz $fa		                stz $FA                      ;initialize LSB of src
51	.9723		64 f0		stz $f0		                stz $F0                      ;initialize LSB of dest
52	.9725						-
53	.9725		b1 f0		lda ($f0),y	                lda ($F0),y
54	.9727		91 fa		sta ($fa),y	                sta ($FA),y
55	.9729		c8		iny		                iny
56	.972a		d0 f9		bne $9725	                bne -
57	.972c		e6 f1		inc $f1		                inc $F1
58	.972e		e6 fb		inc $fb		                inc $FB
59	.9730		ca		dex		                dex
60	.9731		d0 f2		bne $9725	                bne -
61	.9733		7a		ply		                ply
62	.9734		28		plp		                plp
63	.9735		4c 5a e5	jmp $e55a	                jmp selectTerminalROM

65							;-------------------------------------------------------------------------

67							                .if version==350
68	.9738						osbyte14:
69							                .endif
70	.9738						restoreFont32To126:
71	.9738		a2 03		ldx #$03	                ldx #$03                     ;96 chars - 32-126
72	.973a		80 d5		bra $9711	                bra restoreFont32ToN

74							;-------------------------------------------------------------------------
75							;
76							; OSBYTE 25 (&19) Restore a group of font definitions
77							;
78							; MasRef D.2-28
79							;
80	.973c						osbyte19:
81	.973c		8a		txa		                txa                          ;A=group identifier
82	.973d		f0 d0		beq $970f	                beq restoreFont32To255   ;taken if group 0 - all chars
83							                .if version>=500
85							                .else
86	.973f		c9 08		cmp #$08	                cmp #$08
87							                .endif
88	.9741		b0 cb		bcs $970e	                bcs osbyte19Done
89							                .if version>=500
92							                .endif
93	.9743		08		php		                php
94	.9744		78		sei		                sei
95	.9745		69 b8		adc #$b8	                adc #(>LB900)-1 ;form address of ROM font data for group
96	.9747		85 f1		sta $f1		                sta $F1
97	.9749		8a		txa		                txa
98	.974a		a2 01		ldx #$01	                ldx #$01                   ;copy 1 page, 32 chars
99	.974c		69 88		adc #$88	                adc #(>andy.softCharacterDefinitions)-1 ;get page in ANDY for group
100	.974e		80 c9		bra $9719	                bra restoreFontPart



:7	;******  Return to file: src/terminal.s65

2141							                .endif

2143							;-------------------------------------------------------------------------

2145							                .if version==350
2146	.9750						parseSoftKeyNumberFromCommandLine:
2147	.9750		20 b0 83	jsr $83b0	                jsr parseNumberFromString
2148	.9753		90 04		bcc $9759	                bcc badKeyError
2149	.9755		e0 10		cpx #$10	                cpx #softKeyCount
2150							                .if version==350
2151	.9757		90 b5		bcc $970e	                bcc rts9922
2154							                .endif
2155	.9759						badKeyError:
2156	.9759		20 2f ab	jsr $ab2f	                jsr doFollowingError
2157	>975c		fb				                .byte $FB
2158	>975d		42 61 64 20 6b 65 79		                .text "Bad key"
2159	>9764		00				                .byte 0
2160							                .endif

2162							;-------------------------------------------------------------------------

2164							                .if version>=510||version==350
2165	.9765						starSHOW:
2166	.9765		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
2167	.9767		49 0d		eor #$0d	                eor #13
2168	.9769		d0 1b		bne $9786	                bne L96BF
2169	.976b		aa		tax		                tax
2170	.976c						L96A5:
2171	.976c		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
2172	>976f		4b 65 79 20 00			                .text "Key ",0

2174	.9774		da		phx		                phx
2175	.9775		8a		txa		                txa
2176	.9776		20 b5 a8	jsr $a8b5	                jsr printHexDigit
2177	.9779		20 28 9f	jsr $9f28	                jsr printSpace
2178	.977c		20 8e 97	jsr $978e	                jsr printKeyDefinition
2179	.977f		fa		plx		                plx
2180	.9780		e8		inx		                inx
2181	.9781		e0 10		cpx #$10	                cpx #$10
2182	.9783		90 e7		bcc $976c	                bcc L96A5
2183	.9785						L96BE:
2184	.9785		60		rts		                rts

2186	.9786						L96BF:
2187	.9786		20 50 97	jsr $9750	                jsr parseSoftKeyNumberFromCommandLine
2188	.9789		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
2189	.978c						L96C5:
2190	.978c		d0 cb		bne $9759	                bne badKeyError
2191							                .endif

2193							;-------------------------------------------------------------------------

2195							                .if version<510&&version!=350
2206							                .endif

2208							;-------------------------------------------------------------------------
2209							;
2210							; [MasRef C.5-11]
2211							;

2213							                .if version<510&&version!=350
2218							                .else
2219	.978e						printKeyDefinition:
2220							                .endif
2221	.978e		a9 22		lda #$22	                lda #'"'
2222	.9790		20 ee ff	jsr $ffee	                jsr OSWRCH
2223	.9793		a5 f4		lda $f4		                lda $F4
2224	.9795		48		pha		                pha
2225	.9796		20 62 e5	jsr $e562	                jsr selectTerminalROMAndANDY2
2226							                .cwarn *<$9000,format("Code inside ANDY at: $%04x",*)
2227	.9799		bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2228	.979c		85 f2		sta $f2		                sta stringInputBufferAddress+0
2229	.979e		bd 11 80	lda $8011,x	                lda andy.softKeys.stringMSBs,x
2230	.97a1		85 f3		sta $f3		                sta stringInputBufferAddress+1
2231							                .if version<510&&version!=350
2233							                .else
2234	.97a3		8a		txa		                txa
2235	.97a4		a8		tay		                tay
2236							                .endif
2237	.97a5		20 61 eb	jsr $eb61	                jsr getSoftKeyStringLength
2238	.97a8		a8		tay		                tay                          ;Y = string length
2239	.97a9		f0 0e		beq $97b9	                beq starSHOWDone                    ;done if length=0
2240	.97ab						-
2241	.97ab		b2 f2		lda ($f2)	                lda (stringInputBufferAddress)
2242	.97ad		20 04 99	jsr $9904	                jsr printGSREADChar
2243	.97b0		e6 f2		inc $f2		                inc stringInputBufferAddress+0
2244	.97b2		d0 02		bne $97b6	                bne +
2245	.97b4		e6 f3		inc $f3		                inc stringInputBufferAddress+1
2246	.97b6						+
2247	.97b6		88		dey		                dey
2248	.97b7		d0 f2		bne $97ab	                bne -
2249	.97b9						starSHOWDone:
2250	.97b9		68		pla		                pla
2251	.97ba		20 5c e5	jsr $e55c	                jsr selectROMA
2252	.97bd		a9 22		lda #$22	                lda #'"'
2253	.97bf		20 ee ff	jsr $ffee	                jsr OSWRCH
2254	.97c2		4c e7 ff	jmp $ffe7	                jmp OSNEWL

2256							;-------------------------------------------------------------------------

2258							                .if version>=510
2269							                .endif

2271							;-------------------------------------------------------------------------
2272							;
2273							; [MasRef C.5-8]
2274							;
2275	.97c5						starKEY: .proc
2276	.97c5		20 50 97	jsr $9750	                jsr parseSoftKeyNumberFromCommandLine
2277	.97c8		a5 f4		lda $f4		                lda $F4
2278	.97ca		48		pha		                pha
2279	.97cb		20 49 e5	jsr $e549	                jsr selectTerminalROMAndANDY
2280	.97ce		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
2281	.97d1		64 b0		stz $b0		                stz starKEYWorkspace.newStringLength
2282	.97d3		f0 15		beq $97ea	                beq commandLineTailEmpty
2283	.97d5		a2 00		ldx #$00	                ldx #$00
2284	.97d7		38		sec		                sec
2285	.97d8		20 e1 f1	jsr $f1e1	                jsr gsinitEntryPoint
2286	.97db						-
2287	.97db		20 f2 f1	jsr $f1f2	                jsr gsreadEntryPoint
2288	.97de		b0 06		bcs $97e6	                bcs bneBadKeyError
2289	.97e0		9d 00 dc	sta $dc00,x	                sta hazel.commandLine,x
2290	.97e3		e8		inx		                inx
2291	.97e4		80 f5		bra $97db	                bra -

2293	.97e6						bneBadKeyError:
2294							                .if version==350
2295	.97e6		d0 a4		bne $978c	                bne L96C5
2298							                .endif
2299	.97e8		86 b0		stx $b0		                stx starKEYWorkspace.newStringLength
2300	.97ea						commandLineTailEmpty:
2301	.97ea		a4 e6		ldy $e6		                ldy $E6                        ;Y = soft key number
2302	.97ec		20 61 eb	jsr $eb61	                jsr getSoftKeyStringLength
2303	.97ef		85 b5		sta $b5		                sta starKEYWorkspace.counter+0
2304	.97f1		38		sec		                sec
2305	.97f2		e5 b0		sbc $b0		                sbc starKEYWorkspace.newStringLength ;A=existing len-new len
2306	.97f4		b0 16		bcs $980c	                bcs newStringWillFit            ;taken if new string shorter, meaning it'll definitely fit

2308	.97f6		49 ff		eor #$ff	                eor #$FF
2309	.97f8		69 01		adc #$01	                adc #$01                     ;A=new len-existing len
2310	.97fa		6d 10 80	adc $8010	                adc andy.softKeys.endLSB
2311	.97fd		aa		tax		                tax
2312	.97fe		ad 21 80	lda $8021	                lda andy.softKeys.endMSB
2313	.9801		69 00		adc #$00	                adc #$00
2314	.9803		c9 84		cmp #$84	                cmp #>(andy.softKeys.end)
2315	.9805		90 05		bcc $980c	                bcc newStringWillFit

2317							                ; Produce slightly cryptic "Bad key" if string won't
2318							                ; fit.
2319	.9807		d0 dd		bne $97e6	                bne bneBadKeyError
2320	.9809		8a		txa		                txa
2321	.980a		d0 da		bne $97e6	                bne bneBadKeyError
2322	.980c						newStringWillFit:
2323	.980c		ad 68 02	lda $0268	                lda softKeyStringLength
2324	.980f		f0 32		beq $9843	                beq storeNewString          ;taken if new string empty
2325	.9811		ad c9 02	lda $02c9	                lda currentSoftKey
2326	.9814		c5 e6		cmp $e6		                cmp $E6
2327	.9816		90 2b		bcc $9843	                bcc storeNewString ;taken if current soft key<key - expansion will not need to relocate
2328	.9818		d0 0f		bne $9829	                bne relocateCurrentSoftKeyExpansion ;taken if current soft key>key - expansion must relocate
2329	.981a		20 2f ab	jsr $ab2f	                jsr doFollowingError
2330	>981d		fa 4b 65 79 20 69 6e 20		                .text $fa,"Key in use",0
	>9825		75 73 65 00
2331	.9829						relocateCurrentSoftKeyExpansion:
2332	.9829		64 b2		stz $b2		                stz starKEYWorkspace.destPtr+1
2333	.982b		38		sec		                sec
2334	.982c		a5 b0		lda $b0		                lda starKEYWorkspace.newStringLength
2335	.982e		e5 b5		sbc $b5		                sbc starKEYWorkspace.counter+0
2336	.9830		85 b1		sta $b1		                sta starKEYWorkspace.destPtr+0
2337	.9832		b0 02		bcs $9836	                bcs +
2338	.9834		c6 b2		dec $b2		                dec starKEYWorkspace.destPtr+1
2339	.9836						+
2340	.9836		18		clc		                clc
2341	.9837		a5 f8		lda $f8		                lda softKeyExpansionPtr+0
2342	.9839		65 b1		adc $b1		                adc starKEYWorkspace.destPtr+0
2343	.983b		85 f8		sta $f8		                sta softKeyExpansionPtr+0
2344	.983d		a5 f9		lda $f9		                lda softKeyExpansionPtr+1
2345	.983f		65 b2		adc $b2		                adc starKEYWorkspace.destPtr+1
2346	.9841		85 f9		sta $f9		                sta softKeyExpansionPtr+1
2347	.9843						storeNewString:
2348	.9843		ce 84 02	dec $0284	                dec softKeyConsistencyFlag   ;mark soft keys inconsistent
2349	.9846		a6 e6		ldx $e6		                ldx $E6                      ;X=key number
2350	.9848		a5 b5		lda $b5		                lda starKEYWorkspace.counter+0
2351	.984a		f0 45		beq $9891	                beq makeSpaceForNewString ;taken if no existing string for this soft key

2353							                ; delete existing string
2354	.984c		bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2355	.984f		85 b1		sta $b1		                sta starKEYWorkspace.destPtr+0
2356	.9851		bd 11 80	lda $8011,x	                lda andy.softKeys.stringMSBs,x
2357	.9854		85 b2		sta $b2		                sta starKEYWorkspace.destPtr+1
2358	.9856		bd 01 80	lda $8001,x	                lda andy.softKeys.stringLSBs+1,x
2359	.9859		85 b3		sta $b3		                sta starKEYWorkspace.srcPtr+0
2360	.985b		bd 12 80	lda $8012,x	                lda andy.softKeys.stringMSBs+1,x
2361	.985e		85 b4		sta $b4		                sta starKEYWorkspace.srcPtr+1
2362	.9860						deleteExistingStringLoop:
2363							                ; copy byte (with postincrement)
2364	.9860		b2 b3		lda ($b3)	                lda (starKEYWorkspace.srcPtr)
2365	.9862		92 b1		sta ($b1)	                sta (starKEYWorkspace.destPtr)

2367							                ; increment destPtr
2368	.9864		e6 b1		inc $b1		                inc starKEYWorkspace.destPtr+0
2369	.9866		d0 02		bne $986a	                bne +
2370	.9868		e6 b2		inc $b2		                inc starKEYWorkspace.destPtr+1
2371	.986a						+

2373							                ; increment srcPtr
2374	.986a		e6 b3		inc $b3		                inc starKEYWorkspace.srcPtr+0
2375	.986c		d0 02		bne $9870	                bne +
2376	.986e		e6 b4		inc $b4		                inc starKEYWorkspace.srcPtr+1
2377	.9870						+

2379							                ; keep copying until end of buffer reached.
2380	.9870		a5 b3		lda $b3		                lda starKEYWorkspace.srcPtr+0
2381	.9872		cd 10 80	cmp $8010	                cmp andy.softKeys.endLSB
2382	.9875		a5 b4		lda $b4		                lda starKEYWorkspace.srcPtr+1
2383	.9877		ed 21 80	sbc $8021	                sbc andy.softKeys.endMSB
2384	.987a		90 e4		bcc $9860	                bcc deleteExistingStringLoop

2386							                ; update following strings' start addresses, which all
2387							                ; move down by the old string's length.
2388	.987c						updateAddressesLoop:
2389	.987c		e8		inx		                inx
2390	.987d		e0 11		cpx #$11	                cpx #softKeyCount+1
2391	.987f		b0 10		bcs $9891	                bcs makeSpaceForNewString
2392	.9881		38		sec		                sec
2393	.9882		bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2394	.9885		e5 b5		sbc $b5		                sbc starKEYWorkspace.counter+0
2395	.9887		9d 00 80	sta $8000,x	                sta andy.softKeys.stringLSBs,x
2396	.988a		b0 f0		bcs $987c	                bcs updateAddressesLoop
2397	.988c		de 11 80	dec $8011,x	                dec andy.softKeys.stringMSBs,x
2398	.988f		80 eb		bra $987c	                bra updateAddressesLoop

2400	.9891						makeSpaceForNewString:
2401	.9891		a6 e6		ldx $e6		                ldx $E6
2402	.9893		a5 b0		lda $b0		                lda starKEYWorkspace.newStringLength
2403	.9895		f0 66		beq $98fd	                beq done
2404	.9897		ad 10 80	lda $8010	                lda andy.softKeys.endLSB
2405	.989a		85 b3		sta $b3		                sta starKEYWorkspace.srcPtr+0
2406	.989c		18		clc		                clc
2407	.989d		65 b0		adc $b0		                adc starKEYWorkspace.newStringLength
2408	.989f		85 b1		sta $b1		                sta starKEYWorkspace.destPtr+0 ;new end ptr LSB
2409	.98a1		ad 21 80	lda $8021	                lda andy.softKeys.endMSB
2410	.98a4		85 b4		sta $b4		                sta starKEYWorkspace.srcPtr+1
2411	.98a6		69 00		adc #$00	                adc #$00
2412	.98a8		85 b2		sta $b2		                sta starKEYWorkspace.destPtr+1 ;new end ptr MSB
2413	.98aa		a5 b3		lda $b3		                lda starKEYWorkspace.srcPtr+0
2414	.98ac		38		sec		                sec
2415	.98ad		fd 00 80	sbc $8000,x	                sbc andy.softKeys.stringLSBs,x
2416	.98b0		85 b5		sta $b5		                sta starKEYWorkspace.counter+0
2417	.98b2		a5 b4		lda $b4		                lda starKEYWorkspace.srcPtr+1
2418	.98b4		fd 11 80	sbc $8011,x	                sbc andy.softKeys.stringMSBs,x
2419	.98b7		85 b6		sta $b6		                sta starKEYWorkspace.counter+1
2420	.98b9						makeSpaceForNewStringLoop:
2421							                ; loop while counter>0
2422	.98b9		a5 b5		lda $b5		                lda starKEYWorkspace.counter+0
2423	.98bb		05 b6		ora $b6		                ora starKEYWorkspace.counter+1
2424	.98bd		f0 1e		beq $98dd	                beq updateAddressesLoop2

2426							                ; decrement destPtr
2427	.98bf		a5 b1		lda $b1		                lda starKEYWorkspace.destPtr+0
2428	.98c1		d0 02		bne $98c5	                bne +
2429	.98c3		c6 b2		dec $b2		                dec starKEYWorkspace.destPtr+1
2430	.98c5						+
2431	.98c5		c6 b1		dec $b1		                dec starKEYWorkspace.destPtr+0

2433							                ; decrement srcPtr
2434	.98c7		a5 b3		lda $b3		                lda starKEYWorkspace.srcPtr+0
2435	.98c9		d0 02		bne $98cd	                bne +
2436	.98cb		c6 b4		dec $b4		                dec starKEYWorkspace.srcPtr+1
2437	.98cd						+
2438	.98cd		c6 b3		dec $b3		                dec starKEYWorkspace.srcPtr+0

2440							                ; copy byte (with predecrement)
2441	.98cf		b2 b3		lda ($b3)	                lda (starKEYWorkspace.srcPtr)
2442	.98d1		92 b1		sta ($b1)	                sta (starKEYWorkspace.destPtr)

2444							                ; decrement counter
2445	.98d3		a5 b5		lda $b5		                lda starKEYWorkspace.counter+0
2446	.98d5		d0 02		bne $98d9	                bne +
2447	.98d7		c6 b6		dec $b6		                dec starKEYWorkspace.counter+1
2448	.98d9						+
2449	.98d9		c6 b5		dec $b5		                dec starKEYWorkspace.counter+0

2451	.98db		80 dc		bra $98b9	                bra makeSpaceForNewStringLoop

2453							                ; update following strings' start addresses, which all
2454							                ; move up by the new string's length.
2455	.98dd						updateAddressesLoop2:
2456	.98dd		e8		inx		                inx
2457	.98de		e0 11		cpx #$11	                cpx #softKeyCount+1
2458	.98e0		b0 0f		bcs $98f1	                bcs copyNewString
2459	.98e2		bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2460	.98e5		65 b0		adc $b0		                adc starKEYWorkspace.newStringLength
2461	.98e7		9d 00 80	sta $8000,x	                sta andy.softKeys.stringLSBs,x
2462	.98ea		90 f1		bcc $98dd	                bcc updateAddressesLoop2
2463	.98ec		fe 11 80	inc $8011,x	                inc andy.softKeys.stringMSBs,x
2464	.98ef		80 ec		bra $98dd	                bra updateAddressesLoop2

2466	.98f1						copyNewString:
2467	.98f1		a0 00		ldy #$00	                ldy #$00
2468	.98f3						copyNewStringLoop:
2469	.98f3		b9 00 dc	lda $dc00,y	                lda hazel.commandLine,y
2470	.98f6		91 b3		sta ($b3),y	                sta (starKEYWorkspace.srcPtr),y
2471	.98f8		c8		iny		                iny
2472	.98f9		c6 b0		dec $b0		                dec starKEYWorkspace.newStringLength
2473	.98fb		d0 f6		bne $98f3	                bne copyNewStringLoop
2474	.98fd						done:
2475	.98fd		ee 84 02	inc $0284	                inc softKeyConsistencyFlag   ;mark soft keys consistent
2476	.9900		68		pla		                pla
2477	.9901		4c 5c e5	jmp $e55c	                jmp selectROMA
2478							                .endproc

2480							;-------------------------------------------------------------------------
2481							;
2482							; Print char, printing control codes using the string reader escape
2483							; syntax. [MasRef C.5-8]
2484							;
2485	.9904						printGSREADChar: .proc
2486	.9904		aa		tax		                tax                          ;X=char
2487	.9905		30 28		bmi $992f	                bmi printHighBitChar
2488	.9907		c9 20		cmp #$20	                cmp #$20
2489	.9909		90 1f		bcc $992a	                bcc printControlChar
2490	.990b		e8		inx		                inx
2491	.990c		30 0f		bmi $991d	                bmi vdu127
2492	.990e		ca		dex		                dex                          ;restore old char
2493	.990f		c9 22		cmp #$22	                cmp #'"'
2494	.9911		f0 11		beq $9924	                beq printEscapedX
2495	.9913		c9 7c		cmp #$7c	                cmp #'|'
2496	.9915		d0 03		bne $991a	                bne printA
2497							                ; print "||"
2498	.9917		20 ee ff	jsr $ffee	                jsr OSWRCH
2499	.991a						printA:
2500	.991a		4c ee ff	jmp $ffee	                jmp OSWRCH

2502	.991d						vdu127:
2503							                ; print "|?"
2504	.991d		20 3a 99	jsr $993a	                jsr printEscapeChar
2505	.9920		a9 3f		lda #$3f	                lda #'?'
2506	.9922		80 f6		bra $991a	                bra printA

2508	.9924						printEscapedX:
2509	.9924		20 3a 99	jsr $993a	                jsr printEscapeChar
2510	.9927		8a		txa		                txa
2511	.9928		80 f0		bra $991a	                bra printA

2513	.992a						printControlChar:
2514	.992a		09 40		ora #$40	                ora #$40
2515	.992c		aa		tax		                tax
2516	.992d		80 f5		bra $9924	                bra printEscapedX

2518	.992f						printHighBitChar:
2519	.992f		48		pha		                pha
2520	.9930		a2 21		ldx #$21	                ldx #'!'
2521	.9932		20 24 99	jsr $9924	                jsr printEscapedX
2522	.9935		68		pla		                pla
2523	.9936		29 7f		and #$7f	                and #$7F
2524	.9938		80 ca		bra $9904	                bra printGSREADChar

2526	.993a						printEscapeChar:
2527	.993a		a9 7c		lda #$7c	                lda #'|'
2528	.993c		80 dc		bra $991a	                bra printA
2529							                .endproc

2531							;-------------------------------------------------------------------------

2533							                .if version!=350
2535							                .endif

2537							;-------------------------------------------------------------------------

2539	.993e						L9923:
2540	.993e		a9 03		lda #$03	                lda #$03
2541	.9940		20 97 d2	jsr $d297	                jsr LD298
2542	.9943		90 12		bcc $9957	                bcc L993C
2543	.9945		20 4b 99	jsr $994b	                jsr L9930
2544	.9948		20 a8 d8	jsr $d8a8	                jsr LD8A9
2545	.994b						L9930:
2546	.994b		a2 20		ldx #$20	                ldx #$20
2547	.994d		4c b6 e2	jmp $e2b6	                jmp LE2B8

2549	.9950						L9935:
2550	.9950		a9 02		lda #$02	                lda #$02
2551	.9952		20 97 d2	jsr $d297	                jsr LD298
2552	.9955		b0 64		bcs $99bb	                bcs L99A0
2553	.9957						L993C:
2554	.9957		20 d1 d3	jsr $d3d1	                jsr LD3D2
2555	.995a		20 da 9a	jsr $9ada	                jsr L9ABF
2556	.995d		80 08		bra $9967	                bra L994C

2558	.995f						L9944:
2559	.995f		20 19 d4	jsr $d419	                jsr LD41A
2560	.9962		f0 57		beq $99bb	                beq L99A0
2561	.9964		20 d1 d3	jsr $d3d1	                jsr LD3D2
2562	.9967						L994C:
2563	.9967		a5 e1		lda $e1		                lda $E1
2564	.9969		89 20		bit #$20	                bit #$20
2565	.996b		f0 05		beq $9972	                beq L9957
2566	.996d		48		pha		                pha
2567	.996e		20 a2 d6	jsr $d6a2	                jsr LD6A3
2568	.9971		68		pla		                pla
2569	.9972						L9957:
2570	.9972		89 10		bit #$10	                bit #$10
2571	.9974		f0 03		beq $9979	                beq L995E
2572	.9976		20 97 d6	jsr $d697	                jsr LD698
2573	.9979						L995E:
2574	.9979		20 17 9a	jsr $9a17	                jsr L99FC
2575	.997c		08		php		                php
2576	.997d		20 75 9a	jsr $9a75	                jsr L9A5A
2577	.9980		a2 42		ldx #$42	                ldx #$42
2578	.9982		a0 46		ldy #$46	                ldy #$46
2579	.9984		a9 20		lda #$20	                lda #$20
2580	.9986		2c 49 88	bit $8849	                bit L8849
2581	.9989		f0 1c		beq $99a7	                beq L998C
2582	.998b		30 18		bmi $99a5	                bmi L998A
2583	.998d		ad 2c 03	lda $032c	                lda $032C
2584	.9990		cd 37 03	cmp $0337	                cmp $0337
2585	.9993		d0 08		bne $999d	                bne L9982
2586	.9995		ad 2d 03	lda $032d	                lda $032D
2587	.9998		cd 38 03	cmp $0338	                cmp $0338
2588	.999b		f0 10		beq $99ad	                beq L9992
2589	.999d						L9982:
2590	.999d		a2 37		ldx #$37	                ldx #$37
2591	.999f		20 4c d2	jsr $d24c	                jsr LD24D
2592	.99a2		a2 42		ldx #$42	                ldx #$42
2593	.99a4		b8		clv		                clv
2594	.99a5						L998A:
2595	.99a5		a0 2c		ldy #$2c	                ldy #$2C
2596	.99a7						L998C:
2597	.99a7		30 07		bmi $99b0	                bmi L9995
2598	.99a9		50 02		bvc $99ad	                bvc L9992
2599	.99ab		a2 37		ldx #$37	                ldx #$37
2600	.99ad						L9992:
2601	.99ad		20 4c d2	jsr $d24c	                jsr LD24D
2602	.99b0						L9995:
2603	.99b0		28		plp		                plp
2604	.99b1		90 b4		bcc $9967	                bcc L994C
2605	.99b3		60		rts		                rts

2607	.99b4						L9999:
2608	.99b4		a9 01		lda #$01	                lda #$01
2609	.99b6		20 97 d2	jsr $d297	                jsr LD298
2610	.99b9		90 09		bcc $99c4	                bcc L99A9
2611	.99bb						L99A0:
2612	.99bb		a2 24		ldx #$24	                ldx #$24
2613	.99bd		80 37		bra $99f6	                bra L99DB

2615	.99bf						L99A4:
2616	.99bf		20 19 d4	jsr $d419	                jsr LD41A
2617	.99c2		f0 f7		beq $99bb	                beq L99A0
2618	.99c4						L99A9:
2619	.99c4		20 d1 d3	jsr $d3d1	                jsr LD3D2
2620	.99c7		20 e4 99	jsr $99e4	                jsr L99C9
2621	.99ca						L99AF:
2622	.99ca		20 e5 d5	jsr $d5e5	                jsr LD5E6
2623	.99cd		20 e4 99	jsr $99e4	                jsr L99C9
2624	.99d0		ad 30 88	lda $8830	                lda L8830
2625	.99d3		0d 31 88	ora $8831	                ora L8831
2626	.99d6		f0 3e		beq $9a16	                beq L99FB
2627	.99d8		2c 48 88	bit $8848	                bit L8848
2628	.99db		70 ed		bvs $99ca	                bvs L99AF
2629	.99dd		a2 42		ldx #$42	                ldx #$42
2630	.99df		20 f1 99	jsr $99f1	                jsr L99D6
2631	.99e2		80 e6		bra $99ca	                bra L99AF

2633	.99e4						L99C9:
2634	.99e4		20 33 d3	jsr $d333	                jsr LD334
2635	.99e7		20 f9 99	jsr $99f9	                jsr L99DE
2636	.99ea		2c 48 88	bit $8848	                bit L8848
2637	.99ed		30 27		bmi $9a16	                bmi L99FB
2638	.99ef		a2 46		ldx #$46	                ldx #$46
2639	.99f1						L99D6:
2640	.99f1		da		phx		                phx
2641	.99f2		20 7f d2	jsr $d27f	                jsr LD280
2642	.99f5		fa		plx		                plx
2643	.99f6						L99DB:
2644	.99f6		4c 4b db	jmp $db4b	                jmp plotPointInternal

2646	.99f9						L99DE:
2647	.99f9		a2 03		ldx #$03	                ldx #$03
2648	.99fb						L99E0:
2649	.99fb		bd 30 88	lda $8830,x	                lda L8830,x
2650	.99fe		9d 42 03	sta $0342,x	                sta $0342,x
2651	.9a01		9d 46 03	sta $0346,x	                sta $0346,x
2652	.9a04		ca		dex		                dex
2653	.9a05		10 f4		bpl $99fb	                bpl L99E0
2654	.9a07						L99EC:
2655	.9a07		ac 42 03	ldy $0342	                ldy $0342
2656	.9a0a		ad 43 03	lda $0343	                lda $0343
2657	.9a0d		20 2e c9	jsr $c92e	                jsr negateAY
2658	.9a10		8c 42 03	sty $0342	                sty $0342
2659	.9a13		8d 43 03	sta $0343	                sta $0343
2660	.9a16						L99FB:
2661	.9a16		60		rts		                rts

2663	.9a17						L99FC:
2664	.9a17		a5 e1		lda $e1		                lda $E1
2665	.9a19		8d 49 88	sta $8849	                sta L8849
2666	.9a1c		20 f9 99	jsr $99f9	                jsr L99DE
2667	.9a1f		a2 01		ldx #$01	                ldx #$01
2668	.9a21						L9A06:
2669	.9a21		9e 42 03	stz $0342,x	                stz $0342,x
2670	.9a24		9e 46 03	stz $0346,x	                stz $0346,x
2671	.9a27		ca		dex		                dex
2672	.9a28		10 f7		bpl $9a21	                bpl L9A06
2673	.9a2a						L9A0F:
2674	.9a2a		20 49 9a	jsr $9a49	                jsr L9A2E
2675	.9a2d		ad 30 88	lda $8830	                lda L8830
2676	.9a30		0d 31 88	ora $8831	                ora L8831
2677	.9a33		d0 06		bne $9a3b	                bne L9A20
2678	.9a35		38		sec		                sec
2679	.9a36		ad 47 88	lda $8847	                lda L8847
2680	.9a39		d0 cc		bne $9a07	                bne L99EC
2681	.9a3b						L9A20:
2682	.9a3b		20 e5 d5	jsr $d5e5	                jsr LD5E6
2683	.9a3e		ad 32 88	lda $8832	                lda L8832
2684	.9a41		cd 44 03	cmp $0344	                cmp $0344
2685	.9a44		f0 e4		beq $9a2a	                beq L9A0F
2686	.9a46		18		clc		                clc
2687	.9a47		80 be		bra $9a07	                bra L99EC

2689	.9a49						L9A2E:
2690	.9a49		20 33 d3	jsr $d333	                jsr LD334
2691	.9a4c		2c 48 88	bit $8848	                bit L8848
2692	.9a4f		30 07		bmi $9a58	                bmi L9A3D
2693	.9a51		08		php		                php
2694	.9a52		a2 46		ldx #$46	                ldx #$46
2695	.9a54		20 5c 9a	jsr $9a5c	                jsr L9A41
2696	.9a57		28		plp		                plp
2697	.9a58						L9A3D:
2698	.9a58		70 1a		bvs $9a74	                bvs L9A59
2699	.9a5a		a2 42		ldx #$42	                ldx #$42
2700	.9a5c						L9A41:
2701	.9a5c		ad 30 88	lda $8830	                lda L8830
2702	.9a5f		a8		tay		                tay
2703	.9a60		dd 00 03	cmp $0300,x	                cmp $0300,x
2704	.9a63		ad 31 88	lda $8831	                lda L8831
2705	.9a66		48		pha		                pha
2706	.9a67		fd 01 03	sbc $0301,x	                sbc $0301,x
2707	.9a6a		68		pla		                pla
2708	.9a6b		90 07		bcc $9a74	                bcc L9A59
2709	.9a6d		9d 01 03	sta $0301,x	                sta $0301,x
2710	.9a70		98		tya		                tya
2711	.9a71		9d 00 03	sta $0300,x	                sta $0300,x
2712	.9a74						L9A59:
2713	.9a74		60		rts		                rts

2715	.9a75						L9A5A:
2716	.9a75		ad 44 03	lda $0344	                lda $0344
2717	.9a78		0d 45 03	ora $0345	                ora $0345
2718	.9a7b		d0 5c		bne $9ad9	                bne L9ABE
2719	.9a7d		a5 e1		lda $e1		                lda $E1
2720	.9a7f		1a		inc a		                inc a
2721	.9a80		29 03		and #$03	                and #$03
2722	.9a82		d0 55		bne $9ad9	                bne L9ABE
2723	.9a84		a9 20		lda #$20	                lda #$20
2724	.9a86		2c 49 88	bit $8849	                bit L8849
2725	.9a89		10 09		bpl $9a94	                bpl L9A79
2726	.9a8b		f0 07		beq $9a94	                beq L9A79
2727	.9a8d		a2 2c		ldx #$2c	                ldx #$2C
2728	.9a8f		a0 46		ldy #$46	                ldy #$46
2729	.9a91		20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
2730	.9a94						L9A79:
2731	.9a94		a9 10		lda #$10	                lda #$10
2732	.9a96		2c 49 88	bit $8849	                bit L8849
2733	.9a99		50 09		bvc $9aa4	                bvc L9A89
2734	.9a9b		f0 07		beq $9aa4	                beq L9A89
2735	.9a9d		a2 37		ldx #$37	                ldx #$37
2736	.9a9f		a0 42		ldy #$42	                ldy #$42
2737	.9aa1		20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
2738	.9aa4						L9A89:
2739	.9aa4		20 da 9a	jsr $9ada	                jsr L9ABF
2740	.9aa7		a5 e1		lda $e1		                lda $E1
2741	.9aa9		49 3c		eor #$3c	                eor #$3C
2742	.9aab		2a		rol a		                rol a
2743	.9aac		20 6e c6	jsr $c66e	                jsr fixUpVPALETTEFor4Colours
2744	.9aaf		6a		ror a		                ror a
2745	.9ab0		85 e1		sta $e1		                sta $E1
2746	.9ab2		89 20		bit #$20	                bit #$20
2747	.9ab4		f0 10		beq $9ac6	                beq L9AAB
2748	.9ab6		48		pha		                pha
2749	.9ab7		a2 2c		ldx #$2c	                ldx #$2C
2750	.9ab9		a0 46		ldy #$46	                ldy #$46
2751	.9abb		20 cb d5	jsr $d5cb	                jsr sortVDUVariableWords
2752	.9abe		98		tya		                tya
2753	.9abf		aa		tax		                tax
2754	.9ac0		a0 46		ldy #$46	                ldy #$46
2755	.9ac2		20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
2756	.9ac5		68		pla		                pla
2757	.9ac6						L9AAB:
2758	.9ac6		89 10		bit #$10	                bit #$10
2759	.9ac8		f0 0c		beq $9ad6	                beq L9ABB
2760	.9aca		a2 37		ldx #$37	                ldx #$37
2761	.9acc		a0 42		ldy #$42	                ldy #$42
2762	.9ace		20 cb d5	jsr $d5cb	                jsr sortVDUVariableWords
2763	.9ad1		a0 42		ldy #$42	                ldy #$42
2764	.9ad3		20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
2765	.9ad6						L9ABB:
2766	.9ad6		9c 49 88	stz $8849	                stz L8849
2767	.9ad9						L9ABE:
2768	.9ad9		60		rts		                rts

2770	.9ada						L9ABF:
2771	.9ada		a2 03		ldx #$03	                ldx #$03
2772	.9adc						L9AC1:
2773	.9adc		9e 3b 03	stz $033b,x	                stz $033B,x
2774	.9adf		ca		dex		                dex
2775	.9ae0		10 fa		bpl $9adc	                bpl L9AC1
2776	.9ae2		a0 28		ldy #$28	                ldy #$28
2777	.9ae4		a2 1b		ldx #$1b	                ldx #$1B
2778	.9ae6		a9 2c		lda #$2c	                lda #$2C
2779	.9ae8		20 fa 9a	jsr $9afa	                jsr L9ADF
2780	.9aeb		20 a7 d6	jsr $d6a7	                jsr LD6A8
2781	.9aee		a0 1b		ldy #$1b	                ldy #$1B
2782	.9af0		a2 28		ldx #$28	                ldx #$28
2783	.9af2		a9 37		lda #$37	                lda #$37
2784	.9af4		20 fa 9a	jsr $9afa	                jsr L9ADF
2785	.9af7		4c 9c d6	jmp $d69c	                jmp LD69D

2787	.9afa						L9ADF:
2788	.9afa		48		pha		                pha
2789	.9afb		a5 e1		lda $e1		                lda $E1
2790	.9afd		4a		lsr a		                lsr a
2791	.9afe		90 0b		bcc $9b0b	                bcc L9AF0
2792	.9b00		ad 47 88	lda $8847	                lda L8847
2793	.9b03		d0 04		bne $9b09	                bne L9AEE
2794	.9b05		a2 3b		ldx #$3b	                ldx #$3B
2795	.9b07		80 02		bra $9b0b	                bra L9AF0

2797	.9b09						L9AEE:
2798	.9b09		a0 3b		ldy #$3b	                ldy #$3B
2799	.9b0b						L9AF0:
2800	.9b0b		8a		txa		                txa
2801	.9b0c		fa		plx		                plx
2802	.9b0d		da		phx		                phx
2803	.9b0e		48		pha		                pha
2804	.9b0f		5a		phy		                phy
2805	.9b10		a8		tay		                tay
2806	.9b11		a9 03		lda #$03	                lda #$03
2807	.9b13		85 da		sta $da		                sta $DA
2808	.9b15						L9AFA:
2809	.9b15		b9 00 03	lda $0300,y	                lda $0300,y
2810	.9b18		9d 1e 88	sta $881e,x	                sta L881E,x
2811	.9b1b		c8		iny		                iny
2812	.9b1c		e8		inx		                inx
2813	.9b1d		c6 da		dec $da		                dec $DA
2814	.9b1f		10 f4		bpl $9b15	                bpl L9AFA
2815	.9b21		7a		ply		                ply
2816	.9b22		68		pla		                pla
2817	.9b23		fa		plx		                plx
2818	.9b24						L9B09:
2819	.9b24		48		pha		                pha
2820	.9b25		5a		phy		                phy
2821	.9b26		20 7c 9b	jsr $9b7c	                jsr L9B61
2822	.9b29		ca		dex		                dex
2823	.9b2a		7a		ply		                ply
2824	.9b2b		68		pla		                pla
2825	.9b2c		da		phx		                phx
2826	.9b2d		c8		iny		                iny
2827	.9b2e		c8		iny		                iny
2828	.9b2f		1a		inc a		                inc a
2829	.9b30		1a		inc a		                inc a
2830	.9b31		e8		inx		                inx
2831	.9b32		e8		inx		                inx
2832	.9b33		20 7c 9b	jsr $9b7c	                jsr L9B61
2833	.9b36		fa		plx		                plx
2834	.9b37		20 ab 9b	jsr $9bab	                jsr L9B90
2835	.9b3a		08		php		                php
2836	.9b3b		48		pha		                pha
2837	.9b3c		bd 05 03	lda $0305,x	                lda $0305,x
2838	.9b3f		0a		asl a		                asl a
2839	.9b40		7e 0a 03	ror $030a,x	                ror $030A,x
2840	.9b43		10 03		bpl $9b48	                bpl L9B2D
2841	.9b45		20 9a 9b	jsr $9b9a	                jsr L9B7F
2842	.9b48						L9B2D:
2843	.9b48		68		pla		                pla
2844	.9b49		0a		asl a		                asl a
2845	.9b4a		7e 0a 03	ror $030a,x	                ror $030A,x
2846	.9b4d		10 07		bpl $9b56	                bpl L9B3B
2847	.9b4f		e8		inx		                inx
2848	.9b50		e8		inx		                inx
2849	.9b51		20 9a 9b	jsr $9b9a	                jsr L9B7F
2850	.9b54		ca		dex		                dex
2851	.9b55		ca		dex		                dex
2852	.9b56						L9B3B:
2853	.9b56		20 ab 9b	jsr $9bab	                jsr L9B90
2854	.9b59		10 06		bpl $9b61	                bpl L9B46
2855	.9b5b		bd 05 03	lda $0305,x	                lda $0305,x
2856	.9b5e		bc 04 03	ldy $0304,x	                ldy $0304,x
2857	.9b61						L9B46:
2858	.9b61		28		plp		                plp
2859	.9b62		30 06		bmi $9b6a	                bmi L9B4F
2860	.9b64		c0 00		cpy #$00	                cpy #$00
2861	.9b66		d0 01		bne $9b69	                bne L9B4E
2862	.9b68		3a		dec a		                dec a
2863	.9b69						L9B4E:
2864	.9b69		88		dey		                dey
2865	.9b6a						L9B4F:
2866	.9b6a		4a		lsr a		                lsr a
2867	.9b6b		48		pha		                pha
2868	.9b6c		98		tya		                tya
2869	.9b6d		6a		ror a		                ror a
2870	.9b6e		38		sec		                sec
2871	.9b6f		ca		dex		                dex
2872	.9b70		20 75 9b	jsr $9b75	                jsr L9B5A
2873	.9b73		e8		inx		                inx
2874	.9b74		68		pla		                pla
2875	.9b75						L9B5A:
2876	.9b75		fd 07 03	sbc $0307,x	                sbc $0307,x
2877	.9b78		9d 09 03	sta $0309,x	                sta $0309,x
2878	.9b7b		60		rts		                rts

2880	.9b7c						L9B61:
2881	.9b7c		48		pha		                pha
2882	.9b7d		b9 00 03	lda $0300,y	                lda $0300,y
2883	.9b80		9d 00 03	sta $0300,x	                sta $0300,x
2884	.9b83		b9 01 03	lda $0301,y	                lda $0301,y
2885	.9b86		9d 01 03	sta $0301,x	                sta $0301,x
2886	.9b89		7a		ply		                ply
2887	.9b8a		38		sec		                sec
2888	.9b8b		20 90 9b	jsr $9b90	                jsr L9B75
2889	.9b8e		e8		inx		                inx
2890	.9b8f		c8		iny		                iny
2891	.9b90						L9B75:
2892	.9b90		b9 00 03	lda $0300,y	                lda $0300,y
2893	.9b93		fd 00 03	sbc $0300,x	                sbc $0300,x
2894	.9b96		9d 04 03	sta $0304,x	                sta $0304,x
2895	.9b99		60		rts		                rts

2897	.9b9a						L9B7F:
2898	.9b9a		bd 05 03	lda $0305,x	                lda $0305,x
2899	.9b9d		bc 04 03	ldy $0304,x	                ldy $0304,x
2900	.9ba0		20 2e c9	jsr $c92e	                jsr negateAY
2901	.9ba3		9d 05 03	sta $0305,x	                sta $0305,x
2902	.9ba6		98		tya		                tya
2903	.9ba7		9d 04 03	sta $0304,x	                sta $0304,x
2904	.9baa		60		rts		                rts

2906	.9bab						L9B90:
2907	.9bab		bd 06 03	lda $0306,x	                lda $0306,x
2908	.9bae		a8		tay		                tay
2909	.9baf		dd 04 03	cmp $0304,x	                cmp $0304,x
2910	.9bb2		bd 07 03	lda $0307,x	                lda $0307,x
2911	.9bb5		fd 05 03	sbc $0305,x	                sbc $0305,x
2912	.9bb8		08		php		                php
2913	.9bb9		bd 07 03	lda $0307,x	                lda $0307,x
2914	.9bbc		28		plp		                plp
2915	.9bbd		60		rts		                rts

2917							;-------------------------------------------------------------------------
2918							;
2919							; 112-119 = Plot parallelogram [MasRef E.3-27]
2920							;
2921	.9bbe						plotParallelogram:
2922	.9bbe		a2 28		ldx #$28	                ldx #$28
2923	.9bc0		86 da		stx $da		                stx $DA
2924	.9bc2		a2 14		ldx #$14	                ldx #$14
2925	.9bc4		a0 20		ldy #$20	                ldy #$20
2926	.9bc6		a9 24		lda #$24	                lda #$24
2927	.9bc8		20 7f d5	jsr $d57f	                jsr addRegionDimensionsToVDUVariableCoordinates
2928	.9bcb		a0 14		ldy #$14	                ldy #$14
2929	.9bcd		a2 24		ldx #$24	                ldx #$24
2930	.9bcf		20 b6 d5	jsr $d5b6	                jsr sortVDUVariableCoordinates
2931	.9bd2		8e 30 88	stx $8830	                stx L8830
2932	.9bd5		a2 20		ldx #$20	                ldx #$20
2933	.9bd7		20 b6 d5	jsr $d5b6	                jsr sortVDUVariableCoordinates
2934	.9bda		8e 31 88	stx $8831	                stx L8831
2935	.9bdd		a2 28		ldx #$28	                ldx #$28
2936	.9bdf		20 b6 d5	jsr $d5b6	                jsr sortVDUVariableCoordinates
2937	.9be2		8c 33 88	sty $8833	                sty L8833
2938	.9be5		ac 31 88	ldy $8831	                ldy L8831
2939	.9be8		20 b6 d5	jsr $d5b6	                jsr sortVDUVariableCoordinates
2940	.9beb		8c 32 88	sty $8832	                sty L8832
2941	.9bee		ac 30 88	ldy $8830	                ldy L8830
2942	.9bf1		20 2a 9c	jsr $9c2a	                jsr L9C0F
2943	.9bf4		ad 33 88	lda $8833	                lda L8833
2944	.9bf7		85 e0		sta $e0		                sta $E0
2945	.9bf9		a2 2c		ldx #$2c	                ldx #$2C
2946	.9bfb		20 24 9b	jsr $9b24	                jsr L9B09
2947	.9bfe		a4 e1		ldy $e1		                ldy $E1
2948	.9c00		20 71 9c	jsr $9c71	                jsr L9C56
2949	.9c03		ac 32 88	ldy $8832	                ldy L8832
2950	.9c06		ad 33 88	lda $8833	                lda L8833
2951	.9c09		85 e1		sta $e1		                sta $E1
2952	.9c0b		a2 37		ldx #$37	                ldx #$37
2953	.9c0d		20 6c 9c	jsr $9c6c	                jsr L9C51
2954	.9c10		80 15		bra $9c27	                bra L9C0C

2956	.9c12						L9BF7;
2957	.9c12		a0 14		ldy #$14	                ldy #$14
2958	.9c14		a2 24		ldx #$24	                ldx #$24
2959	.9c16		20 b6 d5	jsr $d5b6	                jsr sortVDUVariableCoordinates
2960	.9c19		8c 32 88	sty $8832	                sty L8832
2961	.9c1c		a0 20		ldy #$20	                ldy #$20
2962	.9c1e		20 2a 9c	jsr $9c2a	                jsr L9C0F
2963	.9c21		ad 32 88	lda $8832	                lda L8832
2964	.9c24		20 68 9c	jsr $9c68	                jsr L9C4D
2965	.9c27						L9C0C:
2966	.9c27		4c e3 da	jmp $dae3	                jmp LDAE4

2968	.9c2a						L9C0F:
2969	.9c2a		20 b6 d5	jsr $d5b6	                jsr sortVDUVariableCoordinates
2970	.9c2d		8e 30 88	stx $8830	                stx L8830
2971	.9c30		ae 32 88	ldx $8832	                ldx L8832
2972	.9c33		20 b6 d5	jsr $d5b6	                jsr sortVDUVariableCoordinates
2973	.9c36		8c 32 88	sty $8832	                sty L8832
2974	.9c39		8e 31 88	stx $8831	                stx L8831
2975	.9c3c		ac 30 88	ldy $8830	                ldy L8830
2976	.9c3f		a2 fc		ldx #$fc	                ldx #$FC
2977	.9c41						L9C26:
2978	.9c41		b9 00 03	lda $0300,y	                lda $0300,y
2979	.9c44		9d 46 02	sta $0246,x	                sta vduv.workspace._42-$fc,x
2980	.9c47		9d 4a 02	sta $024a,x	                sta vduv.workspace._46-$fc,x
2981	.9c4a		c8		iny		                iny
2982	.9c4b		e8		inx		                inx
2983	.9c4c		d0 f3		bne $9c41	                bne L9C26
2984	.9c4e		ac 30 88	ldy $8830	                ldy L8830
2985	.9c51		ad 32 88	lda $8832	                lda L8832
2986	.9c54		85 e1		sta $e1		                sta $E1
2987	.9c56		a2 37		ldx #$37	                ldx #$37
2988	.9c58		20 24 9b	jsr $9b24	                jsr L9B09
2989	.9c5b		ac 30 88	ldy $8830	                ldy L8830
2990	.9c5e		ad 31 88	lda $8831	                lda L8831
2991	.9c61		20 68 9c	jsr $9c68	                jsr L9C4D
2992	.9c64		ac 31 88	ldy $8831	                ldy L8831
2993	.9c67		60		rts		                rts

2995	.9c68						L9C4D:
2996	.9c68		85 e0		sta $e0		                sta $E0
2997	.9c6a		a2 2c		ldx #$2c	                ldx #$2C
2998	.9c6c						L9C51:
2999	.9c6c		20 24 9b	jsr $9b24	                jsr L9B09
3000	.9c6f		a4 e0		ldy $e0		                ldy $E0
3001	.9c71						L9C56:
3002	.9c71		5a		phy		                phy
3003	.9c72		b9 02 03	lda $0302,y	                lda $0302,y
3004	.9c75		cd 44 03	cmp $0344	                cmp $0344
3005	.9c78		d0 08		bne $9c82	                bne L9C67
3006	.9c7a		b9 03 03	lda $0303,y	                lda $0303,y
3007	.9c7d		cd 45 03	cmp $0345	                cmp $0345
3008	.9c80		f0 39		beq $9cbb	                beq L9CA0
3009	.9c82						L9C67:
3010	.9c82		a2 2c		ldx #$2c	                ldx #$2C
3011	.9c84		20 db 9c	jsr $9cdb	                jsr L9CC0
3012	.9c87		a2 37		ldx #$37	                ldx #$37
3013	.9c89		20 db 9c	jsr $9cdb	                jsr L9CC0
3014	.9c8c		20 e3 da	jsr $dae3	                jsr LDAE4
3015	.9c8f		a2 37		ldx #$37	                ldx #$37
3016	.9c91		20 25 d7	jsr $d725	                jsr LD726
3017	.9c94		a2 2c		ldx #$2c	                ldx #$2C
3018	.9c96		20 25 d7	jsr $d725	                jsr LD726
3019	.9c99		a0 37		ldy #$37	                ldy #$37
3020	.9c9b		20 cb d5	jsr $d5cb	                jsr sortVDUVariableWords
3021	.9c9e		da		phx		                phx
3022	.9c9f		a2 fc		ldx #$fc	                ldx #$FC
3023	.9ca1						L9C86:
3024	.9ca1		b9 00 03	lda $0300,y	                lda $0300,y
3025	.9ca4		9d 4a 02	sta $024a,x	                sta vduv.workspace._46-$fc,x
3026	.9ca7		c8		iny		                iny
3027	.9ca8		e8		inx		                inx
3028	.9ca9		d0 f6		bne $9ca1	                bne L9C86
3029	.9cab		fa		plx		                plx
3030	.9cac		a0 fc		ldy #$fc	                ldy #$FC
3031	.9cae						L9C93:
3032	.9cae		bd 00 03	lda $0300,x	                lda $0300,x
3033	.9cb1		99 46 02	sta $0246,y	                sta vduv.workspace._42-$fc,y
3034	.9cb4		e8		inx		                inx
3035	.9cb5		c8		iny		                iny
3036	.9cb6		d0 f6		bne $9cae	                bne L9C93
3037	.9cb8		7a		ply		                ply
3038	.9cb9		80 b6		bra $9c71	                bra L9C56

3040	.9cbb						L9CA0:
3041	.9cbb		a9 2c		lda #$2c	                lda #$2C
3042	.9cbd		a6 e0		ldx $e0		                ldx $E0
3043	.9cbf		20 c7 9c	jsr $9cc7	                jsr L9CAC
3044	.9cc2		7a		ply		                ply
3045	.9cc3		a9 37		lda #$37	                lda #$37
3046	.9cc5		a6 e1		ldx $e1		                ldx $E1
3047	.9cc7						L9CAC:
3048	.9cc7		85 de		sta $de		                sta $DE
3049	.9cc9		bd 02 03	lda $0302,x	                lda vduv.graphicsWindowPixelsBottom+0,x
3050	.9ccc		d9 02 03	cmp $0302,y	                cmp vduv.graphicsWindowPixelsBottom+0,y
3051	.9ccf		d0 08		bne $9cd9	                bne L9CBE
3052	.9cd1		bd 03 03	lda $0303,x	                lda vduv.graphicsWindowPixelsBottom+1,x
3053	.9cd4		d9 03 03	cmp $0303,y	                cmp vduv.graphicsWindowPixelsBottom+1,y
3054	.9cd7		f0 05		beq $9cde	                beq L9CC3
3055	.9cd9						L9CBE:
3056	.9cd9		a6 de		ldx $de		                ldx $DE
3057	.9cdb						L9CC0:
3058	.9cdb		20 1c d7	jsr $d71c	                jsr LD71D
3059	.9cde						L9CC3:
3060	.9cde		bd 00 03	lda $0300,x	                lda $0300,x
3061	.9ce1		cd 42 03	cmp $0342	                cmp $0342
3062	.9ce4		bd 01 03	lda $0301,x	                lda $0301,x
3063	.9ce7		ed 43 03	sbc $0343	                sbc $0343
3064	.9cea		10 0d		bpl $9cf9	                bpl L9CDE
3065	.9cec		bd 00 03	lda $0300,x	                lda $0300,x
3066	.9cef		8d 42 03	sta $0342	                sta $0342
3067	.9cf2		bd 01 03	lda $0301,x	                lda $0301,x
3068	.9cf5		8d 43 03	sta $0343	                sta $0343
3069	.9cf8		60		rts		                rts

3071	.9cf9						L9CDE:
3072	.9cf9		ad 46 03	lda $0346	                lda $0346
3073	.9cfc		dd 00 03	cmp $0300,x	                cmp $0300,x
3074	.9cff		ad 47 03	lda $0347	                lda $0347
3075	.9d02		fd 01 03	sbc $0301,x	                sbc $0301,x
3076	.9d05		10 0c		bpl $9d13	                bpl L9CF8
3077	.9d07		bd 00 03	lda $0300,x	                lda $0300,x
3078	.9d0a		8d 46 03	sta $0346	                sta $0346
3079	.9d0d		bd 01 03	lda $0301,x	                lda $0301,x
3080	.9d10		8d 47 03	sta $0347	                sta $0347
3081	.9d13						L9CF8:
3082	.9d13		60		rts		                rts

3084	.9d14						L9CF9:
3085	.9d14		20 a0 dd	jsr $dda0	                jsr LDDA1
3086	.9d17		9c 36 03	stz $0336	                stz $0336
3087	.9d1a		9c 37 03	stz $0337	                stz $0337
3088	.9d1d		20 af dc	jsr $dcaf	                jsr LDCB0
3089	.9d20		d0 4f		bne $9d71	                bne L9D56
3090	.9d22		20 1b dc	jsr $dc1b	                jsr LDC1C
3091	.9d25						L9D0A:
3092	.9d25		24 ff		bit $ff		                bit $FF
3093	.9d27		30 48		bmi $9d71	                bmi L9D56
3094	.9d29		ad 36 03	lda $0336	                lda $0336
3095	.9d2c		cd 37 03	cmp $0337	                cmp $0337
3096	.9d2f		f0 40		beq $9d71	                beq L9D56
3097	.9d31		1a		inc a		                inc a
3098	.9d32		8d 36 03	sta $0336	                sta $0336
3099	.9d35		aa		tax		                tax
3100	.9d36		bd 00 84	lda $8400,x	                lda L8400,x
3101	.9d39		8d 28 03	sta $0328	                sta $0328
3102	.9d3c		bd 00 85	lda $8500,x	                lda L8500,x
3103	.9d3f		8d 2c 03	sta $032c	                sta $032C
3104	.9d42		bd 00 86	lda $8600,x	                lda L8600,x
3105	.9d45		48		pha		                pha
3106	.9d46		4a		lsr a		                lsr a
3107	.9d47		4a		lsr a		                lsr a
3108	.9d48		8d 29 03	sta $0329	                sta $0329
3109	.9d4b		68		pla		                pla
3110	.9d4c		29 03		and #$03	                and #$03
3111	.9d4e		8d 2d 03	sta $032d	                sta $032D
3112	.9d51		bd 00 87	lda $8700,x	                lda L8700,x
3113	.9d54		9c 2b 03	stz $032b	                stz $032B
3114	.9d57		cd 06 03	cmp $0306	                cmp $0306
3115	.9d5a		f0 0a		beq $9d66	                beq L9D4B
3116	.9d5c		85 e0		sta $e0		                sta $E0
3117	.9d5e		1a		inc a		                inc a
3118	.9d5f		20 47 dc	jsr $dc47	                jsr LDC48
3119	.9d62		b0 0d		bcs $9d71	                bcs L9D56
3120	.9d64		a5 e0		lda $e0		                lda $E0
3121	.9d66						L9D4B:
3122	.9d66		cd 02 03	cmp $0302	                cmp $0302
3123	.9d69		f0 ba		beq $9d25	                beq L9D0A
3124	.9d6b		3a		dec a		                dec a
3125	.9d6c		20 47 dc	jsr $dc47	                jsr LDC48
3126	.9d6f		90 b4		bcc $9d25	                bcc L9D0A
3127	.9d71						L9D56:
3128	.9d71		60		rts		                rts

3130	.9d72						L9D57:
3131	.9d72		ad 32 03	lda $0332	                lda $0332
3132	.9d75		a8		tay		                tay
3133	.9d76		cd 2c 03	cmp $032c	                cmp $032C
3134	.9d79		ad 33 03	lda $0333	                lda $0333
3135	.9d7c		aa		tax		                tax
3136	.9d7d		ed 2d 03	sbc $032d	                sbc $032D
3137	.9d80		b0 0a		bcs $9d8c	                bcs L9D71
3138	.9d82		c8		iny		                iny
3139	.9d83		d0 01		bne $9d86	                bne L9D6B
3140	.9d85		e8		inx		                inx
3141	.9d86						L9D6B:
3142	.9d86		8c 2e 03	sty $032e	                sty $032E
3143	.9d89		8e 2f 03	stx $032f	                stx $032F
3144	.9d8c						L9D71:
3145	.9d8c		60		rts		                rts

3147							;-------------------------------------------------------------------------

3149							                .if version>=500
3153							                .endif

3155							;-------------------------------------------------------------------------

3157							                .if version>=500
3161							                .endif

3163							;-------------------------------------------------------------------------
3164							;
3165							; Read byte from EEPROM by 0-based CMOS RAM offset (readCMOSByte) or
3166							; RTC register index (readRTCByte).
3167							;
3168							; (The number of RTC registers on the Compact is 0, so readRTCByte and
3169							; readCMOSByte use the same indexes. Nevertheless, the two routines
3170							; behave differently... presumably I still haven't quite got this bit
3171							; right.)
3172							;
3173							; entry:
3174							;
3175							; X = address to read from
3176							;
3177							; exit:
3178							;
3179							; Y = byte read

3181							                .if version>=500
3208							                .endif

3210							                .if version>=500
3264							                .endif

3266							;-------------------------------------------------------------------------

3268							                .if version>=500
3292							                .endif

3294							;-------------------------------------------------------------------------
3295							;
3296							; Transmit 1 bit over the I2C bus.
3297							;
3298							; preserves: P
3299							;
3300							                .if version>=500
3310							                .endif

3312							;-------------------------------------------------------------------------
3313							;
3314							; Set the I2C clock line high.
3315							;
3316							; preserves: A/C
3317							;
3318							                .if version>=500
3327							                .endif

3329							;-------------------------------------------------------------------------
3330							;
3331							; Set the I2C clock line low.
3332							;
3333							; preserves: A/C
3334							;
3335							                .if version>=500
3343							                .endif

3345							;-------------------------------------------------------------------------
3346							;
3347							; "A change in the state of the data line, from HIGH to LOW, while the
3348							; clock is HIGH, defines the START condition."
3349							;
3350							; preserves: P
3351							                .if version>=500
3365							                .endif

3367							;-------------------------------------------------------------------------
3368							;
3369							; Set the I2C data line low.
3370							;
3371							; preserves: A/C
3372							;
3373							                .if version>=500
3381							                .endif

3383							;-------------------------------------------------------------------------

3385							                .if version>=500
3412							                .endif

3414							;-------------------------------------------------------------------------
3415							;
3416							; Set the I2C data line to a particular value.
3417							;
3418							; entry:
3419							;
3420							; C = state of signal: 1 = high, 0 = low
3421							;
3422							; preserves: C

3424							                .if version>=500
3428							                .endif

3430							;-------------------------------------------------------------------------
3431							;
3432							; Set the I2C data line high.
3433							;
3434							; preserves: A/C
3435							;
3436							                .if version>=500
3444							                .endif

3446							;-------------------------------------------------------------------------
3447							;
3448							; Transmits 1 byte/8 bits over the I2C bus.
3449							;
3450							; entry: A = byte to transmit

3452							                .if version>=500
3465							                .endif

3467							;-------------------------------------------------------------------------

3469							                .if version>=500
3572							                .endif

3574							;-------------------------------------------------------------------------

3576							                .if version>=500
3587							                .endif

3589							;-------------------------------------------------------------------------

3591							                .if version>=500
3620							                .endif

3622							;-------------------------------------------------------------------------

3624							                .if version>=500
3626							                .endif

3628							;-------------------------------------------------------------------------

3630							                .if version==400
3632							                .endif

3634							;-------------------------------------------------------------------------
3635							;
3636							; Utils/Terminal ROM service entry point.
3637							;
3638	.9d8d						utilsServiceEntryPoint:
3639							                .if version==400
3646							                .endif
3647							                .if includeTubeSupport
3648	.9d8d		c9 fe		cmp #$fe	                cmp #romServiceCallTubeSystemPostInitialisation
3649	.9d8f		90 56		bcc $9de7	                bcc handleNonTube
3650	.9d91		d0 14		bne $9da7	                bne handleTubeMainInitialisation
3651	.9d93						handleTubeSystemPostInitialisation:
3652	.9d93		c0 00		cpy #$00	                cpy #$00
3653	.9d95		f0 50		beq $9de7	                beq handleNonTube

3655							                ; [Tube p28] - write out the startup message that the
3656							                ; second processor has been stuck trying to write out.
3657	.9d97						writeSecondProcessorStartupMessageLoop:
3658	.9d97		2c e0 fe	bit $fee0	                bit tube.status1
3659	.9d9a		10 fb		bpl $9d97	                bpl writeSecondProcessorStartupMessageLoop
3660	.9d9c		ad e1 fe	lda $fee1	                lda tube.data1
3661	.9d9f		f0 44		beq $9de5	                beq L9DCA
3662	.9da1		20 ee ff	jsr $ffee	                jsr OSWRCH
3663	.9da4		4c 97 9d	jmp $9d97	                jmp writeSecondProcessorStartupMessageLoop

3665	.9da7						handleTubeMainInitialisation:
3666	.9da7		a9 82		lda #$82	                lda #<tubeHost.eventHandler
3667	.9da9		8d 20 02	sta $0220	                sta EVENTV+0
3668	.9dac		a9 06		lda #$06	                lda #>tubeHost.eventHandler
3669	.9dae		8d 21 02	sta $0221	                sta EVENTV+1
3670	.9db1		a9 16		lda #$16	                lda #<tubeBrkHandlerAddr
3671	.9db3		8d 02 02	sta $0202	                sta BRKV+0
3672	.9db6		a9 00		lda #$00	                lda #>tubeBrkHandlerAddr
3673	.9db8		8d 03 02	sta $0203	                sta BRKV+1
3674	.9dbb		a9 8e		lda #$8e	                lda #tube.status1.S|tube.status1.M|tube.status1.J|tube.status1.I;
3675	.9dbd		8d e0 fe	sta $fee0	                sta tube.status1

3677							                ; Copy Tube host code into main RAM.
3678	.9dc0		a0 00		ldy #$00	                ldy #$00
3679	.9dc2						-
3680	.9dc2		b9 87 ab	lda $ab87,y	                lda tubeHost.codePage0,y
3681	.9dc5		99 00 04	sta $0400,y	                sta tubeHostAddr+0*256,y
3682	.9dc8		b9 7c ac	lda $ac7c,y	                lda tubeHost.codePages12,y
3683	.9dcb		99 00 05	sta $0500,y	                sta tubeHostAddr+1*256,y
3684	.9dce		b9 7c ad	lda $ad7c,y	                lda tubeHost.codePages12+256,y
3685	.9dd1		99 00 06	sta $0600,y	                sta tubeHostAddr+2*256,y
3686	.9dd4		88		dey		                dey
3687	.9dd5		d0 eb		bne $9dc2	                bne -

3689	.9dd7		20 1f 04	jsr $041f	                jsr tubeHost.resetTubeClaim

3691							                ; Copy BRK handler into zero page.
3692	.9dda		a2 41		ldx #$41	                ldx #size(tubeHost.brkHandler)
3693	.9ddc						-
3694	.9ddc		bd 46 ab	lda $ab46,x	                lda tubeHost.brkHandler,x
3695	.9ddf		9d 16 00	sta $0016,x	                sta @w tubeBrkHandlerAddr,x
3696	.9de2		ca		dex		                dex
3697	.9de3		10 f7		bpl $9ddc	                bpl -

3699	.9de5						L9DCA:
3700	.9de5		a9 00		lda #$00	                lda #$00                     ; Claim call and return

3702	.9de7						handleNonTube:
3712							                .endif
3713	.9de7		c9 12		cmp #$12	                cmp #romServiceCallInitialiseFilingSystem
3714	.9de9		d0 1a		bne $9e05	                bne handleBreakInstruction
3715							                .if version==400
3718							                .else
3719	.9deb		c0 04		cpy #$04	                cpy #fsTapeOrROMMax+1
3720	.9ded		b0 42		bcs $9e31	                bcs L9E16                    ; taken if not tape/rom
3721	.9def		c0 00		cpy #$00	                cpy #fsNone
3722	.9df1		f0 3e		beq $9e31	                beq L9E16                    ; taken if no FS
3723	.9df3		a2 03		ldx #$03	                ldx #3                       ; assume tape, 300 baud tape
3724	.9df5		98		tya		                tya                          ; Y = FS number
3725	.9df6		c9 02		cmp #$02	                cmp #fs300BaudTape
3726	.9df8		b0 04		bcs $9dfe	                bcs L9DE3              ; taken if 300 baud tape or ROM
3727	.9dfa		a2 00		ldx #$00	                ldx #$00               ; X=0 for 1200 baud
3728	.9dfc		69 02		adc #$02	                adc #$02            ; adjust so that the result of the
3729							                                    ; following adc will be $8c
3730	.9dfe						L9DE3:
3731	.9dfe		69 89		adc #$89	                adc #$89                     ; Convert to TAPE/ROM select value
3732							                .endif
3733	.9e00		20 00 ed	jsr $ed00	                jsr selectROMOrTAPEByOSBYTE
3734	.9e03		80 e0		bra $9de5	                bra L9DCA                    ; Jump to claim and return

3736	.9e05						handleBreakInstruction:
3737	.9e05		c9 06		cmp #$06	                cmp #romServiceCallBreakInstruction
3738	.9e07		d0 29		bne $9e32	                bne handleCloseAllOpenFiles
3739	.9e09		ad dd df	lda $dfdd	                lda hazel.hasACCCONChanged ; Skip if ACCCON not changed
3740	.9e0c		f0 09		beq $9e17	                beq closeMoveSrcHandle
3741	.9e0e		9c dd df	stz $dfdd	                stz hazel.hasACCCONChanged ; Clear ACCCON changed flag
3742	.9e11		ad dc df	lda $dfdc	                lda hazel.oldACCCON        ; Restore ACCCON
3743	.9e14		8d 34 fe	sta $fe34	                sta ACCCON
3744	.9e17						closeMoveSrcHandle:
3745	.9e17		5a		phy		                phy
3746	.9e18		ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle
3747	.9e1b		f0 06		beq $9e23	                beq closeMoveDestHandle
3748	.9e1d		9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
3749	.9e20		20 e5 8e	jsr $8ee5	                jsr closeFile
3750	.9e23						closeMoveDestHandle:
3751	.9e23		ac d5 df	ldy $dfd5	                ldy hazel.moveDestHandle
3752	.9e26		f0 06		beq $9e2e	                beq L9E13
3753	.9e28		9c d5 df	stz $dfd5	                stz hazel.moveDestHandle
3754	.9e2b		20 e5 8e	jsr $8ee5	                jsr closeFile
3755	.9e2e						L9E13:
3756	.9e2e		7a		ply		                ply
3757	.9e2f		a9 06		lda #$06	                lda #romServiceCallBreakInstruction ; restore A
3758	.9e31						L9E16:
3759	.9e31		60		rts		                rts
3760	.9e32						handleCloseAllOpenFiles:
3761	.9e32		c9 26		cmp #$26	                cmp #romServiceCallCloseAllOpenFiles
3762	.9e34		d0 1d		bne $9e53	                bne handleHelp
3763							                .if version!=400
3764	.9e36		a9 8d		lda #$8d	                lda #$8D
3765	.9e38		20 47 9e	jsr $9e47	                jsr L9E2C
3766	.9e3b		a2 03		ldx #$03	                ldx #$03
3767	.9e3d		a9 04		lda #$04	                lda #$04
3768	.9e3f		24 c6		bit $c6		                bit $C6
3769	.9e41		f0 02		beq $9e45	                beq L9E2A
3770	.9e43		a2 00		ldx #$00	                ldx #$00
3771	.9e45						L9E2A:
3772	.9e45		a9 8c		lda #$8c	                lda #$8C
3773	.9e47						L9E2C:
3774							                .endif
3775	.9e47		20 00 ed	jsr $ed00	                jsr selectROMOrTAPEByOSBYTE
3776	.9e4a		a9 00		lda #$00	                lda #$00
3777	.9e4c		a8		tay		                tay
3778	.9e4d		20 15 a2	jsr $a215	                jsr osfindTapeOrROM
3779	.9e50		a9 26		lda #$26	                lda #$26
3780	.9e52		60		rts		                rts

3782	.9e53						handleHelp
3783	.9e53		c9 09		cmp #$09	                cmp #romServiceCallHelp
3784							                .if version<400&&includeTerminalROM
3785	.9e55		d0 53		bne $9eaa	                bne handleTerminal
3788							                .endif
3789	.9e57		5a		phy		                phy
3790	.9e58		b1 f2		lda ($f2),y	                lda ($F2),y
3791	.9e5a		c9 0d		cmp #$0d	                cmp #$0D
3792	.9e5c		d0 1e		bne $9e7c	                bne L9E61
3793	.9e5e		20 17 9f	jsr $9f17	                jsr L9EFC
3794	.9e61		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
3795	>9e64		20 20 4d 4f 53 0d		                .text "  MOS",13
3796							                .if version<400&&includeTerminalROM
3797	>9e6a		0d 54 45 52 4d 49 4e 41		                .text 13,"TERMINAL 1.20",13
	>9e72		4c 20 31 2e 32 30 0d
3808							                .endif
3809	>9e79		00				                .text 0
3810	.9e7a		80 2a		bra $9ea6	                bra L9E8B
3811	.9e7c						L9E61:
3812	.9e7c		a2 02		ldx #$02	                ldx #size(mosHelpSubject)-1
3813	.9e7e						L9E63:
3814	.9e7e		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
3815	.9e80		c9 2e		cmp #$2e	                cmp #'.'
3816	.9e82		f0 2c		beq $9eb0	                beq L9E95
3817	.9e84		29 df		and #$df	                and #$DF
3818	.9e86		dd ad 9e	cmp $9ead,x	                cmp mosHelpSubject,x
3819	.9e89		d0 0b		bne $9e96	                bne L9E7B
3820	.9e8b		c8		iny		                iny
3821	.9e8c		ca		dex		                dex
3822	.9e8d		10 ef		bpl $9e7e	                bpl L9E63
3823	.9e8f		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
3824	.9e91		20 35 ea	jsr $ea35	                jsr isLetter
3825	.9e94		b0 1a		bcs $9eb0	                bcs L9E95
3826	.9e96						L9E7B:
3827	.9e96		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
3828	.9e98		c9 0d		cmp #$0d	                cmp #13
3829	.9e9a		f0 0a		beq $9ea6	                beq L9E8B
3830	.9e9c		c8		iny		                iny
3831	.9e9d		c9 20		cmp #$20	                cmp #' '
3832	.9e9f		d0 f5		bne $9e96	                bne L9E7B
3833	.9ea1		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
3834	.9ea4		d0 d6		bne $9e7c	                bne L9E61
3835	.9ea6						L9E8B:
3836	.9ea6		7a		ply		                ply
3837	.9ea7		a9 09		lda #$09	                lda #romServiceCallHelp
3838	.9ea9						LA304:
3839	.9ea9		60		rts		                rts

3841							                .if version<400&&includeTerminalROM
3842	.9eaa						handleTerminal:
3843	.9eaa		4c 37 ae	jmp $ae37	                jmp terminalServiceEntryPoint
3844							                .endif

3846	>9ead		53 4f 4d			mosHelpSubject: .text "SOM"

3848	.9eb0						L9E95:
3849	.9eb0		20 17 9f	jsr $9f17	                jsr L9EFC
3850	.9eb3		a9 37		lda #$37	                lda #<mosCommandTable
3851	.9eb5		85 b0		sta $b0		                sta terminalHELPWorkspace.tablePtr+0
3852	.9eb7		a9 81		lda #$81	                lda #>mosCommandTable
3853	.9eb9		85 b1		sta $b1		                sta terminalHELPWorkspace.tablePtr+1
3854	.9ebb						L9EA0:
3855	.9ebb		b2 b0		lda ($b0)	                lda (terminalHELPWorkspace.tablePtr)
3856	.9ebd		30 50		bmi $9f0f	                bmi L9EF4
3857							                .if version==400
3860							                .endif
3861	.9ebf		20 28 9f	jsr $9f28	                jsr printSpace
3862	.9ec2		20 28 9f	jsr $9f28	                jsr printSpace
3863	.9ec5		b2 b0		lda ($b0)	                lda (terminalHELPWorkspace.tablePtr)
3864	.9ec7						L9EAC:
3865							                .if version==400
3868							                .endif
3869	.9ec7		20 2a 9f	jsr $9f2a	                jsr L9F0E
3870	.9eca						LA711:
3871	.9eca		e6 b0		inc $b0		                inc terminalHELPWorkspace.tablePtr+0
3872	.9ecc		d0 02		bne $9ed0	                bne L9EB5
3873	.9ece		e6 b1		inc $b1		                inc terminalHELPWorkspace.tablePtr+1
3874	.9ed0						L9EB5:
3875	.9ed0		b2 b0		lda ($b0)	                lda (terminalHELPWorkspace.tablePtr)
3876	.9ed2		10 f3		bpl $9ec7	                bpl L9EAC

3878							                ; add 4 to tablePtr
3879	.9ed4		a9 04		lda #$04	                lda #$04
3880	.9ed6		18		clc		                clc
3881	.9ed7		65 b0		adc $b0		                adc terminalHELPWorkspace.tablePtr+0
3882	.9ed9		85 b0		sta $b0		                sta terminalHELPWorkspace.tablePtr+0
3883	.9edb		90 02		bcc $9edf	                bcc +
3884	.9edd		e6 b1		inc $b1		                inc terminalHELPWorkspace.tablePtr+1
3885	.9edf						+
3886	.9edf		20 5a e2	jsr $e25a	                jsr LE25C
3887	.9ee2		e0 13		cpx #$13	                cpx #19
3888	.9ee4		f0 24		beq $9f0a	                beq L9EEF
3889	.9ee6						L9ECB:
3890	.9ee6		20 50 e2	jsr $e250	                jsr getTextCursorPositionWithColumn81
3891	.9ee9		8a		txa		                txa
3892	.9eea		f0 cf		beq $9ebb	                beq L9EA0
3893	.9eec		e0 14		cpx #$14	                cpx #20
3894	.9eee		f0 cb		beq $9ebb	                beq L9EA0
3895	.9ef0		90 0d		bcc $9eff	                bcc L9EE4
3896	.9ef2		e0 28		cpx #$28	                cpx #40
3897	.9ef4		f0 c5		beq $9ebb	                beq L9EA0
3898	.9ef6		b0 0c		bcs $9f04	                bcs L9EE9
3899	.9ef8		20 5a e2	jsr $e25a	                jsr LE25C
3900	.9efb		e0 27		cpx #$27	                cpx #39
3901	.9efd		f0 0b		beq $9f0a	                beq L9EEF
3902	.9eff						L9EE4:
3903	.9eff		20 28 9f	jsr $9f28	                jsr printSpace
3904	.9f02		80 e2		bra $9ee6	                bra L9ECB

3906	.9f04						L9EE9:
3907	.9f04		e0 3c		cpx #$3c	                cpx #60
3908	.9f06		90 f7		bcc $9eff	                bcc L9EE4
3909	.9f08		f0 b1		beq $9ebb	                beq L9EA0
3910	.9f0a						L9EEF:
3911	.9f0a		20 3a 9f	jsr $9f3a	                jsr printNewLine
3912	.9f0d		80 ac		bra $9ebb	                bra L9EA0

3914	.9f0f						L9EF4:
3915	.9f0f		20 50 e2	jsr $e250	                jsr getTextCursorPositionWithColumn81
3916	.9f12		8a		txa		                txa
3917	.9f13		f0 91		beq $9ea6	                beq L9E8B
3918	.9f15		80 f3		bra $9f0a	                bra L9EEF

3920	.9f17						L9EFC:
3921	.9f17		5a		phy		                phy
3922	.9f18		20 9a a9	jsr $a99a	                jsr alwaysPrintFollowingMessage
3923	>9f1b		0d 4d 4f 53 20 33 2e 35		                .text 13,versionString,13,0
	>9f23		30 0d 00
3924	.9f26		7a		ply		                ply
3925	.9f27		60		rts		                rts

3927							;-------------------------------------------------------------------------
3928							;
3929	.9f28						printSpace:
3930	.9f28		a9 20		lda #$20	                lda #$20
3931	.9f2a						L9F0E:
3932	.9f2a		da		phx		                phx
3933	.9f2b		a6 b0		ldx $b0		                ldx $B0
3934	.9f2d		da		phx		                phx
3935	.9f2e		a6 b1		ldx $b1		                ldx $B1
3936	.9f30		20 ee ff	jsr $ffee	                jsr OSWRCH
3937	.9f33						restoreB1AndB0:
3938	.9f33		86 b1		stx $b1		                stx $B1
3939	.9f35		fa		plx		                plx
3940	.9f36		86 b0		stx $b0		                stx $B0
3941	.9f38		fa		plx		                plx
3942	.9f39		60		rts		                rts

3944							;-------------------------------------------------------------------------

3946	.9f3a						printNewLine:
3947	.9f3a		da		phx		                phx
3948	.9f3b		a6 b0		ldx $b0		                ldx $B0
3949	.9f3d		da		phx		                phx
3950	.9f3e		a6 b1		ldx $b1		                ldx $B1
3951	.9f40		20 e7 ff	jsr $ffe7	                jsr OSNEWL
3952	.9f43		80 ee		bra $9f33	                bra restoreB1AndB0

3954							;-------------------------------------------------------------------------

3956							; TAPE/ROM OSARGS handler
3957							; =======================
3958	.9f45						osargsTapeOrROM:
3959	.9f45		c0 00		cpy #$00	                cpy #$00       ; Handle<>0 - read/write open file info
3960	.9f47		d0 0e		bne $9f57	                bne L9F3B
3961	.9f49		09 00		ora #$00	                ora #$00 ; A<>0 - read/write filing system info - exit
3962	.9f4b		d0 09		bne $9f56	                bne L9F3A

3964							; A=0, Y=0 - read current filing system
3965							; -------------------------------------
3966	.9f4d		a9 03		lda #$03	                lda #$03                     ; Prepare A=ROMFS
3967							                .if version!=400
3968	.9f4f		2c 47 02	bit $0247	                bit cfsRFSFSSwitch           ; If TAPE/ROM switch
3969	.9f52		d0 02		bne $9f56	                bne L9F3A
3970	.9f54		25 c6		and $c6		                and $C6           ; Mask with speed to give A=2 or A=1
3971							                .endif

3973							; TAPE/ROM FSC 6 - shut down FS
3974							; TAPE/ROM FSC 8 - OS command
3975							; TAPE/ROM FSC 10 - *INFO
3976							; -----------------------------
3977	.9f56						L9F3A:
3978	.9f56		60		rts		                rts

3980							; OSARGS handle<>0 - red/write open file info
3981							; -------------------------------------------
3982	.9f57						L9F3B:
3983	.9f57		c9 00		cmp #$00	                cmp #$00                     ; Not =PTR, exit unsupported
3984	.9f59		d0 fb		bne $9f56	                bne L9F3A
3985	.9f5b		c0 02		cpy #$02	                cpy #$02                     ; =PTR#2 - read PTR on output handle
3986	.9f5d		f0 1d		beq $9f7c	                beq L9F60

3988							; Read PTR on CFS/RFS input file
3989							; ------------------------------
3990	.9f5f		a9 01		lda #$01	                lda #$01                     ; Check if this is input channel and is open
3991	.9f61		20 aa aa	jsr $aaaa	                jsr LAA68
3992	.9f64		ad 9e 03	lda $039e	                lda $039E
3993	.9f67		95 00		sta $00,x	                sta $00,x
3994	.9f69		5a		phy		                phy
3995	.9f6a		ad de 03	lda $03de	                lda $03DE
3996	.9f6d		ac dd 03	ldy $03dd	                ldy $03DD
3997	.9f70		d0 01		bne $9f73	                bne L9F57
3998	.9f72		3a		dec a		                dec a
3999	.9f73						L9F57:
4000	.9f73		88		dey		                dey
4001	.9f74		94 01		sty $01,x	                sty $01,x
4002	.9f76		7a		ply		                ply
4003	.9f77						L9F5B:
4004	.9f77		95 02		sta $02,x	                sta $02,x
4005	.9f79		74 03		stz $03,x	                stz $03,x
4006	.9f7b		60		rts		                rts

4008							; Read PTR on TAPE output file
4009							; ----------------------------
4010	.9f7c						L9F60:
4011	.9f7c		a9 02		lda #$02	                lda #$02                     ; Check if this is output channel and is open
4012	.9f7e		20 aa aa	jsr $aaaa	                jsr LAA68
4013	.9f81		ad 9d 03	lda $039d	                lda $039D                    ; Copy PTR to control block
4014	.9f84		95 00		sta $00,x	                sta $00,x
4015	.9f86		ad 94 03	lda $0394	                lda $0394
4016	.9f89		95 01		sta $01,x	                sta $01,x
4017	.9f8b		ad 95 03	lda $0395	                lda $0395
4018	.9f8e		80 e7		bra $9f77	                bra L9F5B

4020							;-------------------------------------------------------------------------

4022							; TAPE/ROM FSC dispatch table
4023							; ---------------------------

4025							tapeAndROMFSCRoutine: .macro addr,shift
4027							                .endmacro

4029							tapeAndROMFSCRoutinesTable: .macro shift
4042							                .endmacro

4044	.9f90						L9F74:
4026	>9f90		3b				                .byte ((LA422)-1)>>(0)&$ff
4026	>9f91		0a				                .byte ((LA4F1)-1)>>(0)&$ff
4026	>9f92		2b				                .byte ((LA110)-1)>>(0)&$ff
4026	>9f93		44				                .byte ((LA129)-1)>>(0)&$ff
4026	>9f94		2b				                .byte ((LA110)-1)>>(0)&$ff
4026	>9f95		83				                .byte ((LA168)-1)>>(0)&$ff
4026	>9f96		55				                .byte ((L9F3A)-1)>>(0)&$ff
4026	>9f97		b9				                .byte ((L9F9E)-1)>>(0)&$ff
4026	>9f98		55				                .byte ((L9F3A)-1)>>(0)&$ff
4026	>9f99		70				                .byte ((LA155)-1)>>(0)&$ff
4026	>9f9a		55				                .byte ((L9F3A)-1)>>(0)&$ff
4026	>9f9b		2e				                .byte ((LA113)-1)>>(0)&$ff
4046	.9f9c						L9F80:
4026	>9f9c		a4				                .byte ((LA422)-1)>>(8)&$ff
4026	>9f9d		a5				                .byte ((LA4F1)-1)>>(8)&$ff
4026	>9f9e		a1				                .byte ((LA110)-1)>>(8)&$ff
4026	>9f9f		a1				                .byte ((LA129)-1)>>(8)&$ff
4026	>9fa0		a1				                .byte ((LA110)-1)>>(8)&$ff
4026	>9fa1		a1				                .byte ((LA168)-1)>>(8)&$ff
4026	>9fa2		9f				                .byte ((L9F3A)-1)>>(8)&$ff
4026	>9fa3		9f				                .byte ((L9F9E)-1)>>(8)&$ff
4026	>9fa4		9f				                .byte ((L9F3A)-1)>>(8)&$ff
4026	>9fa5		a1				                .byte ((LA155)-1)>>(8)&$ff
4026	>9fa6		9f				                .byte ((L9F3A)-1)>>(8)&$ff
4026	>9fa7		a1				                .byte ((LA113)-1)>>(8)&$ff

4049							;-------------------------------------------------------------------------

4051							; TAPE/ROM FSC
4052							; ============
4053	.9fa8						fscTapeOrROM:
4054	.9fa8		c9 0c		cmp #$0c	                cmp #$0C                     ; function<12 - exit unchanged
4055	.9faa		b0 aa		bcs $9f56	                bcs L9F3A
4056	.9fac		86 bc		stx $bc		                stx $BC                      ; Index into dispatch table
4057	.9fae		aa		tax		                tax
4058	.9faf		bd 9c 9f	lda $9f9c,x	                lda L9F80,x
4059	.9fb2		48		pha		                pha
4060	.9fb3		bd 90 9f	lda $9f90,x	                lda L9F74,x
4061	.9fb6		48		pha		                pha
4062	.9fb7		a6 bc		ldx $bc		                ldx $BC
4063	.9fb9		60		rts		                rts

4065							; TAPE/ROM FSC 7 - obtain file handle range
4066							; -----------------------------------------
4067	.9fba						L9F9E:
4068	.9fba		a2 03		ldx #$03	                ldx #$03
4069	.9fbc		a0 03		ldy #$03	                ldy #$03
4070							                .if version!=400
4071	.9fbe		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4072	.9fc1		d0 93		bne $9f56	                bne L9F3A
4073	.9fc3		88		dey		                dey
4074	.9fc4		a2 01		ldx #$01	                ldx #$01
4075							                .endif
4076	.9fc6		60		rts		                rts

4078	.9fc7						L9FAB:
4079	.9fc7		68		pla		                pla
4080	.9fc8		28		plp		                plp
4081	.9fc9		38		sec		                sec
4082	.9fca		60		rts		                rts

4084	.9fcb						L9FAF:
4085	.9fcb		08		php		                php
4086	.9fcc		48		pha		                pha
4087	.9fcd		20 35 aa	jsr $aa35	                jsr LA9F3
4088	.9fd0		ad c2 03	lda $03c2	                lda $03C2
4089	.9fd3		48		pha		                pha
4090	.9fd4		20 1c a5	jsr $a51c	                jsr LA502
4091	.9fd7		68		pla		                pla
4092	.9fd8		b0 ed		bcs $9fc7	                bcs L9FAB
4093	.9fda		f0 19		beq $9ff5	                beq L9FD9
4094	.9fdc		a2 03		ldx #$03	                ldx #$03
4095	.9fde		a9 ff		lda #$ff	                lda #$FF
4096	.9fe0						L9FC4:
4097	.9fe0		48		pha		                pha
4098	.9fe1		bd be 03	lda $03be,x	                lda $03BE,x
4099	.9fe4		95 b0		sta $b0,x	                sta $B0,x
4100	.9fe6		68		pla		                pla
4101	.9fe7		35 b0		and $b0,x	                and $B0,x
4102	.9fe9		ca		dex		                dex
4103	.9fea		10 f4		bpl $9fe0	                bpl L9FC4
4104	.9fec		1a		inc a		                inc a
4105	.9fed		d0 06		bne $9ff5	                bne L9FD9
4106	.9fef		20 f3 a9	jsr $a9f3	                jsr LA9B1
4107	.9ff2		4c e9 92	jmp $92e9	                jmp badAddressError

4109	.9ff5						L9FD9:
4110	.9ff5		ad ca 03	lda $03ca	                lda $03CA
4111	.9ff8		4a		lsr a		                lsr a
4112	.9ff9		68		pla		                pla
4113	.9ffa		48		pha		                pha
4114	.9ffb		f0 10		beq $a00d	                beq L9FF1
4115	.9ffd		90 15		bcc $a014	                bcc L9FF8
4116	.9fff						L9FE3:
4117	.9fff		20 fd a9	jsr $a9fd	                jsr LA9BB
4118	.a002		20 2f ab	jsr $ab2f	                jsr doFollowingError
4119	>a005		d5 4c 6f 63 6b 65 64 00		                .text $d5,"Locked",0
4120	.a00d						L9FF1:
4121	.a00d		90 05		bcc $a014	                bcc L9FF8
4122	.a00f		a9 03		lda #$03	                lda #$03
4123	.a011		8d 58 02	sta $0258	                sta breakAndESCAPEEffect
4124	.a014						L9FF8:
4125	.a014		a9 30		lda #$30	                lda #$30
4126	.a016		25 bb		and $bb		                and $BB
4127	.a018		f0 04		beq $a01e	                beq LA002
4128	.a01a		a5 c1		lda $c1		                lda $C1
4129	.a01c						LA000:
4130	.a01c		d0 08		bne $a026	                bne LA00A
4131	.a01e						LA002:
4132							                .if includeTubeSupport
4133	.a01e		5a		phy		                phy
4134	.a01f		20 e6 aa	jsr $aae6	                jsr initiateCFSRFSHostToParasiteTransfer
4135	.a022		7a		ply		                ply
4136							                .endif
4137	.a023		20 ec a6	jsr $a6ec	                jsr LA6D2
4138	.a026						LA00A:
4139	.a026		20 e3 a8	jsr $a8e3	                jsr LA8A1
4140	.a029		d0 57		bne $a082	                bne LA066
4141	.a02b		20 77 aa	jsr $aa77	                jsr LAA35
4142	.a02e		2c ca 03	bit $03ca	                bit $03CA
4143	.a031		30 08		bmi $a03b	                bmi LA01F
4144	.a033		20 9e a8	jsr $a89e	                jsr LA85B
4145	.a036		20 92 a6	jsr $a692	                jsr LA678
4146	.a039		80 d9		bra $a014	                bra L9FF8

4148	.a03b						LA01F:
4149	.a03b		68		pla		                pla                          ; RUN, no control block to update
4150	.a03c		f0 33		beq $a071	                beq LA055
4151	.a03e		a0 02		ldy #$02	                ldy #$02
4152	.a040						LA024:
4153	.a040		b9 bc 03	lda $03bc,y	                lda $03BC,y                  ; Copy load/exec to control block
4154	.a043		91 c8		sta ($c8),y	                sta ($C8),y
4155	.a045		c8		iny		                iny
4156	.a046		c0 0a		cpy #$0a	                cpy #$0A
4157	.a048		d0 f6		bne $a040	                bne LA024
4158	.a04a		ad c8 03	lda $03c8	                lda $03C8                    ; Length b0-b7=Block Length b0-b7
4159	.a04d		91 c8		sta ($c8),y	                sta ($C8),y
4160	.a04f		c8		iny		                iny
4161	.a050		ad c9 03	lda $03c9	                lda $03C9
4162	.a053		18		clc		                clc
4163	.a054		6d c6 03	adc $03c6	                adc $03C6                    ; Length b8-b15=Block Number+Block Length b8-b15
4164	.a057		91 c8		sta ($c8),y	                sta ($C8),y
4165	.a059		c8		iny		                iny
4166	.a05a		a9 00		lda #$00	                lda #$00
4167	.a05c		6d c7 03	adc $03c7	                adc $03C7                    ; Length b16-b23=overflow
4168	.a05f		91 c8		sta ($c8),y	                sta ($C8),y
4169	.a061		c8		iny		                iny                          ; Length b24-b31=&00
4170	.a062		a9 00		lda #$00	                lda #$00
4171	.a064		91 c8		sta ($c8),y	                sta ($C8),y
4172	.a066		c8		iny		                iny
4173	.a067						LA04B:
4174	.a067		b9 bd 03	lda $03bd,y	                lda $03BD,y                  ; Attrs=&00000000
4175	.a06a		91 c8		sta ($c8),y	                sta ($C8),y
4176	.a06c		c8		iny		                iny
4177	.a06d		c0 12		cpy #$12	                cpy #$12
4178	.a06f		d0 f6		bne $a067	                bne LA04B
4179	.a071						LA055:
4180	.a071		28		plp		                plp
4181	.a072						LA056:
4182	.a072		20 f3 a9	jsr $a9f3	                jsr LA9B1
4183	.a075						LA059:
4184	.a075		24 ba		bit $ba		                bit $BA                      ; If flag set, skip printing newline
4185	.a077		30 07		bmi $a080	                bmi LA064
4186	.a079						LA05D:
4187	.a079		08		php		                php                          ; Print inline text
4188	.a07a		20 65 a9	jsr $a965	                jsr LA923
4189	>a07d		0d				                .byte 13                     ; Could just do JSR OSNEWL
4190	>a07e		00				                .byte 0
4191	.a07f		28		plp		                plp
4192	.a080						LA064:
4193	.a080		18		clc		                clc
4194	.a081		60		rts		                rts

4196	.a082						LA066:
4197	.a082		20 20 a5	jsr $a520	                jsr LA506
4198	.a085		d0 8d		bne $a014	                bne L9FF8
4199	.a087						LA06B:
4200	.a087		86 f2		stx $f2		                stx $F2
4201	.a089		84 f3		sty $f3		                sty $F3
4202	.a08b		a0 00		ldy #$00	                ldy #$00
4203	.a08d		20 e0 f1	jsr $f1e0	                jsr gsinitForFilenameParsing
4204	.a090		a2 00		ldx #$00	                ldx #$00
4205	.a092						LA076:
4206	.a092		20 f2 f1	jsr $f1f2	                jsr gsreadEntryPoint
4207	.a095		b0 0d		bcs $a0a4	                bcs LA088
4208	.a097		f0 08		beq $a0a1	                beq LA085
4209	.a099		9d d2 03	sta $03d2,x	                sta $03D2,x
4210	.a09c		e8		inx		                inx
4211	.a09d		e0 0b		cpx #$0b	                cpx #$0B
4212	.a09f		d0 f1		bne $a092	                bne LA076
4213	.a0a1						LA085:
4214	.a0a1		4c 02 f2	jmp $f202	                jmp badStringError

4216	.a0a4						LA088:
4217	.a0a4		9e d2 03	stz $03d2,x	                stz $03D2,x
4218	.a0a7		60		rts		                rts

4220							; CFS/RFS OSFILE
4221							; ==============
4222	.a0a8						osfileTapeOrROM:
4223	.a0a8		48		pha		                pha
4224	.a0a9		86 c8		stx $c8		                stx $C8                      ; C8/9=>control block
4225	.a0ab		84 c9		sty $c9		                sty $C9
4226	.a0ad		b2 c8		lda ($c8)	                lda ($C8)                    ; Get XY=>filename
4227	.a0af		aa		tax		                tax
4228	.a0b0		a0 01		ldy #$01	                ldy #$01
4229	.a0b2		b1 c8		lda ($c8),y	                lda ($C8),y
4230	.a0b4		a8		tay		                tay
4231	.a0b5		20 87 a0	jsr $a087	                jsr LA06B                    ; Parse filename
4232	.a0b8		a0 02		ldy #$02	                ldy #$02
4233	.a0ba						LA09E:
4234	.a0ba		b1 c8		lda ($c8),y	                lda ($C8),y
4235	.a0bc		99 bc 03	sta $03bc,y	                sta $03BC,y
4236	.a0bf		99 ae 00	sta $00ae,y	                sta $00AE,y
4237	.a0c2		c8		iny		                iny
4238	.a0c3		c0 0a		cpy #$0a	                cpy #$0A
4239	.a0c5		d0 f3		bne $a0ba	                bne LA09E
4240	.a0c7		68		pla		                pla
4241	.a0c8		f0 07		beq $a0d1	                beq LA0B5
4242	.a0ca		c9 ff		cmp #$ff	                cmp #$FF
4243	.a0cc		d0 b2		bne $a080	                bne LA064
4244	.a0ce		4c cb 9f	jmp $9fcb	                jmp L9FAF

4246	.a0d1						LA0B5:
4247							                .if version==400
4249							                .else
4250	.a0d1		8d c6 03	sta $03c6	                sta $03C6
4251	.a0d4		8d c7 03	sta $03c7	                sta $03C7
4252	.a0d7						LA0BB:
4253	.a0d7		b1 c8		lda ($c8),y	                lda ($C8),y
4254	.a0d9		99 a6 00	sta $00a6,y	                sta $00A6,y
4255	.a0dc		c8		iny		                iny
4256	.a0dd		c0 12		cpy #$12	                cpy #$12
4257	.a0df		d0 f6		bne $a0d7	                bne LA0BB
4258	.a0e1		8a		txa		                txa
4259	.a0e2		f0 bd		beq $a0a1	                beq LA085
4260	.a0e4		20 35 aa	jsr $aa35	                jsr LA9F3
4261	.a0e7		20 3c a8	jsr $a83c	                jsr LA822
4262							                .if includeTubeSupport
4263	.a0ea		a9 00		lda #$00	                lda #tubeReasonMultiByteParasiteToHost
4264	.a0ec		20 e8 aa	jsr $aae8	                jsr LAAA6
4265							                .endif
4266	.a0ef						LA0D3:
4267	.a0ef		38		sec		                sec
4268	.a0f0		a2 fd		ldx #$fd	                ldx #$fd                     ;-3
4269	.a0f2						LA0D6:
4270	.a0f2		bd b7 ff	lda $ffb7,x	                lda ($b4-$fd)&$ffff,x
4271	.a0f5		fd b3 ff	sbc $ffb3,x	                sbc ($b0-$fd)&$ffff,x
4272	.a0f8		9d cb 02	sta $02cb,x	                sta $3c8-$fd,x
4273	.a0fb		e8		inx		                inx
4274	.a0fc		d0 f4		bne $a0f2	                bne LA0D6
4275	.a0fe		a8		tay		                tay
4276	.a0ff		d0 0e		bne $a10f	                bne LA0F3
4277	.a101		ec c8 03	cpx $03c8	                cpx $03C8
4278	.a104		a9 01		lda #$01	                lda #$01
4279	.a106		ed c9 03	sbc $03c9	                sbc $03C9
4280	.a109		90 04		bcc $a10f	                bcc LA0F3
4281	.a10b		a2 80		ldx #$80	                ldx #$80
4282	.a10d		80 08		bra $a117	                bra LA0FB

4284	.a10f						LA0F3:
4285	.a10f		a9 01		lda #$01	                lda #$01
4286	.a111		8d c9 03	sta $03c9	                sta $03C9
4287	.a114		8e c8 03	stx $03c8	                stx $03C8
4288	.a117						LA0FB:
4289	.a117		8e ca 03	stx $03ca	                stx $03CA
4290	.a11a		20 03 a7	jsr $a703	                jsr LA6E9
4291	.a11d		30 78		bmi $a197	                bmi LA17B
4292	.a11f		20 9e a8	jsr $a89e	                jsr LA85B
4293	.a122		ee c6 03	inc $03c6	                inc $03C6
4294	.a125		d0 c8		bne $a0ef	                bne LA0D3
4295	.a127		ee c7 03	inc $03c7	                inc $03C7
4296	.a12a		80 c3		bra $a0ef	                bra LA0D3
4297							                .endif

4299							; TAPE/ROM FSC 2 - */
4300							; TAPE/ROM FSC 4 - *RUN
4301							; ---------------------
4302	.a12c						LA110:
4303	.a12c		38		sec		                sec
4304	.a12d		66 ce		ror $ce		                ror $CE
4305							; TAPE/ROM FSC 11 - *RUN command for library
4306							; ------------------------------------------
4307	.a12f						LA113:
4308	.a12f		da		phx		                phx
4309	.a130		5a		phy		                phy
4310	.a131		20 87 a0	jsr $a087	                jsr LA06B
4311	.a134		a9 00		lda #$00	                lda #$00
4312	.a136		a2 ff		ldx #$ff	                ldx #$FF
4313	.a138		8e c2 03	stx $03c2	                stx $03C2
4314	.a13b		20 cb 9f	jsr $9fcb	                jsr L9FAF
4315	.a13e		7a		ply		                ply
4316	.a13f		fa		plx		                plx
4317	.a140		90 08		bcc $a14a	                bcc LA12E
4318							                .if version!=400
4319	.a142		20 0c aa	jsr $aa0c	                jsr LA9CA
4320							                .endif

4322							; TAPE/ROM FSC 3 - unknown * command
4323							; ----------------------------------
4324	.a145						LA129:
4325	.a145		a9 0b		lda #$0b	                lda #$0B
4326	.a147		6c 1e 02	jmp ($021e)	                jmp (FSCV)

4328	.a14a						LA12E:
4329							                .if includeTubeSupport
4330	.a14a		2c 7a 02	bit $027a	                bit tubePresence
4331	.a14d		10 09		bpl $a158	                bpl LA13C                    ; taken if no Tube
4332	.a14f		ad c4 03	lda $03c4	                lda $03C4
4333	.a152		2d c5 03	and $03c5	                and $03C5
4334	.a155		1a		inc a		                inc a                     ; A=$00 if !&03c2=&FFFFxxxx
4335	.a156		d0 10		bne $a168	                bne LA14C                 ; taken if copro address
4336	.a158						LA13C:
4337							                .endif

4339	.a158		ae c2 03	ldx $03c2	                ldx $03C2
4340	.a15b		ac c3 03	ldy $03c3	                ldy $03C3
4341	.a15e		a9 a4		lda #$a4	                lda #$A4
4342	.a160		20 f4 ff	jsr $fff4	                jsr OSBYTE
4343	.a163		a9 01		lda #$01	                lda #$01
4344	.a165		6c c2 03	jmp ($03c2)	                jmp ($03C2)

4346							                .if includeTubeSupport
4347	.a168						LA14C:
4348	.a168		a2 c2		ldx #$c2	                ldx #$C2
4349	.a16a		a0 03		ldy #$03	                ldy #$03
4350	.a16c		a9 04		lda #$04	                lda #tubeReasonExecute
4351	.a16e		4c f2 aa	jmp $aaf2	                jmp initiateCFSRFSTubeTransfer
4352							                .endif

4354							; TAPE/ROM FSC 9 - *EX
4355							; --------------------
4356	.a171						LA155:
4357	.a171		a9 08		lda #$08	                lda #$08
4358	.a173		04 e2		tsb $e2		                tsb $E2
4359	.a175		a5 e3		lda $e3		                lda $E3
4360	.a177		48		pha		                pha
4361	.a178		09 cc		ora #$cc	                ora #$CC
4362	.a17a		85 e3		sta $e3		                sta $E3
4363	.a17c		20 35 aa	jsr $aa35	                jsr LA9F3
4364	.a17f		68		pla		                pla
4365	.a180		85 e3		sta $e3		                sta $E3
4366	.a182		80 07		bra $a18b	                bra LA16F

4368							; TAPE/ROM FSC 5 - *CAT
4369							; ---------------------
4370	.a184						LA168:
4371	.a184		a9 08		lda #$08	                lda #$08
4372	.a186		04 e2		tsb $e2		                tsb $E2
4373	.a188		20 35 aa	jsr $aa35	                jsr LA9F3
4374	.a18b						LA16F:
4375	.a18b		a9 00		lda #$00	                lda #$00
4376	.a18d		20 98 a1	jsr $a198	                jsr LA17C
4377							                .if version!=400
4378	.a190		20 0c aa	jsr $aa0c	                jsr LA9CA
4379							                .endif
4380	.a193						LA177:
4381	.a193		a9 08		lda #$08	                lda #$08
4382	.a195		14 e2		trb $e2		                trb $E2
4383	.a197						LA17B:
4384	.a197		60		rts		                rts

4386	.a198						LA17C:
4387	.a198		48		pha		                pha
4388							                .if version!=400
4389	.a199		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4390	.a19c		f0 09		beq $a1a7	                beq LA18B
4391							                .endif
4392	.a19e		20 d7 f3	jsr $f3d7	                jsr LF6FC
4393	.a1a1		20 dc f3	jsr $f3dc	                jsr LF701
4394	.a1a4		b8		clv		                clv
4395	.a1a5		b0 50		bcs $a1f7	                bcs LA1DB
4396	.a1a7						LA18B:
4397	.a1a7		20 92 a6	jsr $a692	                jsr LA678
4398	.a1aa		ad c6 03	lda $03c6	                lda $03C6
4399	.a1ad		85 b4		sta $b4		                sta $B4
4400	.a1af		ad c7 03	lda $03c7	                lda $03C7
4401	.a1b2		85 b5		sta $b5		                sta $B5
4402	.a1b4		a2 ff		ldx #$ff	                ldx #$FF
4403	.a1b6		8e df 03	stx $03df	                stx $03DF
4404	.a1b9		64 ba		stz $ba		                stz $BA
4405	.a1bb		80 16		bra $a1d3	                bra LA1B7

4407	.a1bd						LA1A1:
4408							                .if version!=400
4409	.a1bd		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4410	.a1c0		f0 37		beq $a1f9	                beq LA1DD
4411							                .endif
4412	.a1c2						LA1A6:
4413	.a1c2		20 f2 f3	jsr $f3f2	                jsr LF717
4414	.a1c5						LA1A9:
4415	.a1c5		a9 ff		lda #$ff	                lda #$FF
4416	.a1c7		8d c6 03	sta $03c6	                sta $03C6
4417	.a1ca		8d c7 03	sta $03c7	                sta $03C7
4418	.a1cd						LA1B1:
4419	.a1cd		20 77 aa	jsr $aa77	                jsr LAA35
4420	.a1d0		20 92 a6	jsr $a692	                jsr LA678
4421	.a1d3						LA1B7:
4422							                .if version!=400
4423	.a1d3		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4424	.a1d6		f0 02		beq $a1da	                beq LA1BE
4425							                .endif
4426	.a1d8		50 1d		bvc $a1f7	                bvc LA1DB
4427	.a1da						LA1BE:
4428	.a1da		68		pla		                pla
4429	.a1db		48		pha		                pha
4430	.a1dc		f0 1b		beq $a1f9	                beq LA1DD
4431	.a1de		20 9e a9	jsr $a99e	                jsr LA95C
4432	.a1e1		d0 da		bne $a1bd	                bne LA1A1
4433	.a1e3		a9 30		lda #$30	                lda #$30
4434	.a1e5		25 bb		and $bb		                and $BB
4435	.a1e7		f0 0e		beq $a1f7	                beq LA1DB
4436	.a1e9		ad c6 03	lda $03c6	                lda $03C6
4437	.a1ec		c5 b6		cmp $b6		                cmp $B6
4438	.a1ee		d0 cd		bne $a1bd	                bne LA1A1
4439	.a1f0		ad c7 03	lda $03c7	                lda $03C7
4440	.a1f3		c5 b7		cmp $b7		                cmp $B7
4441	.a1f5		d0 c6		bne $a1bd	                bne LA1A1
4442	.a1f7						LA1DB:
4443	.a1f7		68		pla		                pla
4444	.a1f8		60		rts		                rts

4446	.a1f9						LA1DD:
4447	.a1f9		50 05		bvc $a200	                bvc LA1E4
4448	.a1fb		a9 ff		lda #$ff	                lda #$FF
4449	.a1fd		20 ee a6	jsr $a6ee	                jsr LA6D4
4450	.a200						LA1E4:
4451	.a200		a2 00		ldx #$00	                ldx #$00
4452	.a202		20 06 a9	jsr $a906	                jsr LA8C4
4453							                .if version!=400
4454	.a205		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4455	.a208		f0 04		beq $a20e	                beq LA1F2
4456							                .endif
4457	.a20a		24 bb		bit $bb		                bit $BB
4458	.a20c		50 b4		bvc $a1c2	                bvc LA1A6
4459	.a20e						LA1F2:
4460	.a20e		2c ca 03	bit $03ca	                bit $03CA
4461	.a211		30 b2		bmi $a1c5	                bmi LA1A9
4462	.a213		80 b8		bra $a1cd	                bra LA1B1

4464							; CFS/RFS OSFIND HANDLER
4465							; ======================
4466	.a215						osfindTapeOrROM:
4467	.a215		85 bc		sta $bc		                sta $BC
4468	.a217		da		phx		                phx
4469	.a218		5a		phy		                phy
4470	.a219		09 00		ora #$00	                ora #$00
4471	.a21b		d0 1f		bne $a23c	                bne LA220
4472	.a21d		98		tya		                tya
4473	.a21e		d0 0e		bne $a22e	                bne LA212
4474							                .if version!=400
4475	.a220		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4476	.a223		d0 03		bne $a228	                bne LA20C
4477	.a225		20 b8 a2	jsr $a2b8	                jsr LA29C
4478							                .endif
4479	.a228						LA20C:
4480	.a228		a9 01		lda #$01	                lda #$01
4481	.a22a		14 e2		trb $e2		                trb $E2
4482							                .if version==400
4484							                .else
4485	.a22c		80 0c		bra $a23a	                bra LA21E
4486							                .endif
4487	.a22e						LA212:
4488	.a22e		4a		lsr a		                lsr a
4489	.a22f		b0 f7		bcs $a228	                bcs LA20C
4490							                .if version!=400
4491	.a231		4a		lsr a		                lsr a
4492	.a232		b0 03		bcs $a237	                bcs LA21B
4493							                .endif
4494	.a234		4c c3 aa	jmp $aac3	                jmp LAA81

4496							                .if version!=400
4497	.a237						LA21B:
4498	.a237		20 b8 a2	jsr $a2b8	                jsr LA29C
4499	.a23a						LA21E:
4500	.a23a		80 77		bra $a2b3	                bra LA297
4501							                .endif

4503	.a23c						LA220:
4504	.a23c		20 87 a0	jsr $a087	                jsr LA06B
4505	.a23f		24 bc		bit $bc		                bit $BC
4506	.a241		50 39		bvc $a27c	                bvc LA260
4507	.a243		9c 9e 03	stz $039e	                stz $039E
4508	.a246		9c dd 03	stz $03dd	                stz $03DD
4509	.a249		9c de 03	stz $03de	                stz $03DE
4510	.a24c		a9 c1		lda #$c1	                lda #$C1
4511	.a24e		14 e2		trb $e2		                trb $E2
4512	.a250		20 28 aa	jsr $aa28	                jsr LA9E6
4513	.a253		08		php		                php
4514	.a254		20 1c a5	jsr $a51c	                jsr LA502
4515	.a257		20 d1 a5	jsr $a5d1	                jsr LA5B7
4516	.a25a		28		plp		                plp
4517	.a25b		a2 ff		ldx #$ff	                ldx #$FF
4518	.a25d						LA241:
4519	.a25d		e8		inx		                inx
4520	.a25e		bd b2 03	lda $03b2,x	                lda $03B2,x
4521	.a261		9d a7 03	sta $03a7,x	                sta $03A7,x
4522	.a264		d0 f7		bne $a25d	                bne LA241
4523	.a266		1a		inc a		                inc a
4524	.a267		04 e2		tsb $e2		                tsb $E2
4525	.a269		ad e9 02	lda $02e9	                lda tapeInputCurrentBlockSize+0
4526	.a26c		0d ea 02	ora $02ea	                ora tapeInputCurrentBlockSize+1
4527	.a26f		d0 04		bne $a275	                bne LA259
4528	.a271		a9 40		lda #$40	                lda #$40
4529	.a273		04 e2		tsb $e2		                tsb $E2
4530	.a275						LA259:
4531							                .if version==400
4536							                .else
4537	.a275		a9 01		lda #$01	                lda #$01
4538	.a277		0d 47 02	ora $0247	                ora cfsRFSFSSwitch
4539	.a27a		d0 35		bne $a2b1	                bne LA295
4540	.a27c						LA260:
4541	.a27c		8a		txa		                txa
4542	.a27d		d0 03		bne $a282	                bne LA266
4543	.a27f		4c 02 f2	jmp $f202	                jmp badStringError

4545	.a282						LA266:
4546	.a282		a2 ff		ldx #$ff	                ldx #$FF
4547	.a284						LA268:
4548	.a284		e8		inx		                inx
4549	.a285		bd d2 03	lda $03d2,x	                lda $03D2,x
4550	.a288		9d 80 03	sta $0380,x	                sta $0380,x
4551	.a28b		d0 f7		bne $a284	                bne LA268
4552	.a28d		3a		dec a		                dec a
4553	.a28e		a2 08		ldx #$08	                ldx #$08
4554	.a290						LA274:
4555	.a290		9d 8b 03	sta $038b,x	                sta $038B,x
4556	.a293		ca		dex		                dex
4557	.a294		d0 fa		bne $a290	                bne LA274
4558	.a296		8a		txa		                txa
4559	.a297		a2 14		ldx #$14	                ldx #$14
4560	.a299						LA27D:
4561	.a299		9d 80 03	sta $0380,x	                sta $0380,x
4562	.a29c		e8		inx		                inx
4563	.a29d		e0 1e		cpx #$1e	                cpx #$1E
4564	.a29f		d0 f8		bne $a299	                bne LA27D
4565	.a2a1		2e 97 03	rol $0397	                rol $0397
4566	.a2a4		20 35 aa	jsr $aa35	                jsr LA9F3
4567	.a2a7		20 3c a8	jsr $a83c	                jsr LA822
4568	.a2aa		20 fd a9	jsr $a9fd	                jsr LA9BB
4569	.a2ad		a9 02		lda #$02	                lda #$02
4570	.a2af		04 e2		tsb $e2		                tsb $E2
4571							                .endif
4572	.a2b1						LA295:
4573	.a2b1		85 bc		sta $bc		                sta $BC
4574	.a2b3						LA297:
4575	.a2b3		7a		ply		                ply
4576	.a2b4		fa		plx		                plx
4577	.a2b5		a5 bc		lda $bc		                lda $BC
4578	.a2b7						LA29B:
4579	.a2b7		60		rts		                rts

4581							                .if version!=400
4582	.a2b8						LA29C:
4583	.a2b8		a9 02		lda #$02	                lda #$02
4584	.a2ba		25 e2		and $e2		                and $E2
4585	.a2bc		f0 f9		beq $a2b7	                beq LA29B
4586	.a2be		9c 97 03	stz $0397	                stz $0397
4587	.a2c1		a9 80		lda #$80	                lda #$80
4588	.a2c3		ae 9d 03	ldx $039d	                ldx $039D
4589	.a2c6		8e 96 03	stx $0396	                stx $0396
4590	.a2c9		8d 98 03	sta $0398	                sta $0398
4591	.a2cc		20 d4 a2	jsr $a2d4	                jsr LA2B8
4592	.a2cf		a9 02		lda #$02	                lda #$02
4593	.a2d1		14 e2		trb $e2		                trb $E2
4594	.a2d3		60		rts		                rts

4596	.a2d4						LA2B8:
4597	.a2d4		20 28 aa	jsr $aa28	                jsr LA9E6
4598	.a2d7		a2 11		ldx #$11	                ldx #$11
4599	.a2d9						LA2BD:
4600	.a2d9		bd 8c 03	lda $038c,x	                lda $038C,x
4601	.a2dc		9d be 03	sta $03be,x	                sta $03BE,x
4602	.a2df		ca		dex		                dex
4603	.a2e0		10 f7		bpl $a2d9	                bpl LA2BD
4604	.a2e2		86 b2		stx $b2		                stx $B2
4605	.a2e4		86 b3		stx $b3		                stx $B3
4606	.a2e6		64 b0		stz $b0		                stz $B0
4607	.a2e8		a9 09		lda #$09	                lda #$09
4608	.a2ea		85 b1		sta $b1		                sta $B1
4609	.a2ec		a2 7f		ldx #$7f	                ldx #$7F
4610	.a2ee		20 8f aa	jsr $aa8f	                jsr LAA4D
4611	.a2f1		8d df 03	sta $03df	                sta $03DF
4612	.a2f4		20 9c aa	jsr $aa9c	                jsr LAA5A
4613	.a2f7		20 e2 aa	jsr $aae2	                jsr LAAA0
4614	.a2fa		20 03 a7	jsr $a703	                jsr LA6E9
4615	.a2fd		ee 94 03	inc $0394	                inc $0394
4616	.a300		d0 03		bne $a305	                bne LA2E9
4617	.a302		ee 95 03	inc $0395	                inc $0395
4618	.a305						LA2E9:
4619	.a305		60		rts		                rts
4620							                .endif

4622	.a306						bputTapeOrROM:
4623	.a306		da		phx		                phx
4624	.a307		5a		phy		                phy
4625	.a308		a9 01		lda #$01	                lda #$01
4626	.a30a						LA2EE:
4627	.a30a		20 aa aa	jsr $aaaa	                jsr LAA68
4628	.a30d		a5 e2		lda $e2		                lda $E2
4629	.a30f		0a		asl a		                asl a
4630	.a310		b0 4d		bcs $a35f	                bcs LA343
4631	.a312		0a		asl a		                asl a
4632	.a313		90 08		bcc $a31d	                bcc LA301
4633	.a315		a9 80		lda #$80	                lda #$80
4634	.a317		04 e2		tsb $e2		                tsb $E2
4635	.a319		a9 fe		lda #$fe	                lda #$FE
4636	.a31b		b0 3a		bcs $a357	                bcs LA33B
4637	.a31d						LA301:
4638	.a31d		ae 9e 03	ldx $039e	                ldx $039E
4639	.a320		e8		inx		                inx
4640	.a321		ec e9 02	cpx $02e9	                cpx tapeInputCurrentBlockSize+0
4641	.a324		d0 2c		bne $a352	                bne LA336
4642	.a326		2c eb 02	bit $02eb	                bit blockFlagOfCurrentlyResidentBlock
4643	.a329		30 23		bmi $a34e	                bmi LA332
4644	.a32b		ad ec 02	lda $02ec	                lda lastCharacterOfCurrentlyResidentBlock
4645	.a32e		48		pha		                pha
4646	.a32f		20 28 aa	jsr $aa28	                jsr LA9E6
4647	.a332		08		php		                php
4648	.a333		20 c9 a5	jsr $a5c9	                jsr LA5AF
4649	.a336		28		plp		                plp
4650	.a337		68		pla		                pla
4651	.a338		85 bc		sta $bc		                sta $BC
4652	.a33a		18		clc		                clc
4653	.a33b		2c eb 02	bit $02eb	                bit blockFlagOfCurrentlyResidentBlock
4654	.a33e		10 19		bpl $a359	                bpl LA33D
4655	.a340		ad e9 02	lda $02e9	                lda tapeInputCurrentBlockSize+0
4656	.a343		0d ea 02	ora $02ea	                ora tapeInputCurrentBlockSize+1
4657	.a346		d0 11		bne $a359	                bne LA33D
4658	.a348		a9 40		lda #$40	                lda #$40
4659	.a34a		04 e2		tsb $e2		                tsb $E2
4660	.a34c		80 0b		bra $a359	                bra LA33D

4662	.a34e						LA332:
4663	.a34e		a9 40		lda #$40	                lda #$40
4664	.a350		04 e2		tsb $e2		                tsb $E2
4665	.a352						LA336:
4666	.a352		ca		dex		                dex
4667	.a353		18		clc		                clc
4668	.a354		bd 00 0a	lda $0a00,x	                lda $0A00,x
4669	.a357						LA33B:
4670	.a357		85 bc		sta $bc		                sta $BC
4671	.a359						LA33D:
4672	.a359		ee 9e 03	inc $039e	                inc $039E
4673	.a35c		4c b3 a2	jmp $a2b3	                jmp LA297

4675	.a35f						LA343:
4676	.a35f		20 2f ab	jsr $ab2f	                jsr doFollowingError
4677	>a362		df 45 4f 46 00			                .text $df,"EOF",0

4679							                .if version==400
4687							                .endif

4689							                .if version!=400
4690	.a367						bgetTapeOrROM:
4691	.a367		85 c4		sta $c4		                sta $C4
4692	.a369		da		phx		                phx
4693	.a36a		5a		phy		                phy
4694	.a36b		a9 02		lda #$02	                lda #$02
4695	.a36d		20 aa aa	jsr $aaaa	                jsr LAA68
4696	.a370		ae 9d 03	ldx $039d	                ldx $039D
4697	.a373		a5 c4		lda $c4		                lda $C4
4698	.a375		9d 00 09	sta $0900,x	                sta $0900,x
4699	.a378		e8		inx		                inx
4700	.a379		d0 06		bne $a381	                bne LA365
4701	.a37b		20 d4 a2	jsr $a2d4	                jsr LA2B8
4702	.a37e		20 fd a9	jsr $a9fd	                jsr LA9BB
4703	.a381						LA365:
4704	.a381		ee 9d 03	inc $039d	                inc $039D
4705	.a384		a5 c4		lda $c4		                lda $C4
4706	.a386		4c b1 a2	jmp $a2b1	                jmp LA295
4707							                .endif

4709							                .if version!=400
4710							; TAPE/ROM OSGBPB handler
4711							; =======================
4712	.a389						osgbpbTapeOrROM:
4713	.a389		4a		lsr a		                lsr a                        ; Odd numbered calls - change PTR - exit with A=changed, SEC
4714	.a38a		b0 06		bcs $a392	                bcs LA376
4715	.a38c		f0 04		beq $a392	                beq LA376                    ; OSGBPB 0 - exit with A=unchanged, SEC
4716	.a38e		c9 03		cmp #$03	                cmp #$03                     ; function/2<3 - function<6 - function 2 and 4 - jump to do
4717	.a390		90 02		bcc $a394	                bcc LA378
4718	.a392						LA376:
4719	.a392		38		sec		                sec
4720	.a393		60		rts		                rts
4721							                .endif

4723							; Call Return
4724							;  0    A=0   SEC                        - unsupported
4725							;  1    A=0   SEC  Write using new PTR   - unsupported
4726							;  2    A=         Write with current PTR
4727							;  3    A=1   SEC  Read with new PTR     - unsupported
4728							;  4    A=         Read with current PTR
4729							;  5+   A=A/2 SEC                        - unsupported

4731							; TAPE/ROM OSGBPB 2 and 4 - read/write with current PTR
4732							; -----------------------------------------------------
4733	.a394						LA378:
4734							                .if version!=400
4735	.a394		4a		lsr a		                lsr a
4736							                .endif
4737	.a395		86 cc		stx $cc		                stx $CC
4738	.a397		84 cd		sty $cd		                sty $CD
4739	.a399		a0 01		ldy #$01	                ldy #$01
4740	.a39b		b1 cc		lda ($cc),y	                lda ($CC),y
4741	.a39d		85 c8		sta $c8		                sta $C8                      ; address LSB
4742	.a39f		c8		iny		                iny
4743	.a3a0		b1 cc		lda ($cc),y	                lda ($CC),y
4744	.a3a2		85 c9		sta $c9		                sta $C9                      ; address MSB
4745							                .if includeTubeSupport
4746	.a3a4		c8		iny		                iny
4747	.a3a5		b1 cc		lda ($cc),y	                lda ($CC),y
4748	.a3a7		c8		iny		                iny
4749	.a3a8		31 cc		and ($cc),y	                and ($CC),y            ; A=$ff if bits 16-31 are $ffff
4750	.a3aa		1a		inc a		                inc a              ; A!=$00 if bits 16-31 aren't $ffff
4751	.a3ab		2d 7a 02	and $027a	                and tubePresence ; A!=$00 if copro address and copro present
4752	.a3ae		48		pha		                pha              ; save copro usage flag
4753							                .if version!=400
4754	.a3af		08		php		                php                          ; save C
4755							                .endif
4756	.a3b0		f0 0f		beq $a3c1	                beq LA3A7
4757	.a3b2		a6 cc		ldx $cc		                ldx $CC
4758	.a3b4		a4 cd		ldy $cd		                ldy $CD
4759	.a3b6		e8		inx		                inx
4760	.a3b7		d0 01		bne $a3ba	                bne LA39E
4761	.a3b9		c8		iny		                iny
4762	.a3ba						LA39E:
4763							                .if version==400
4766							                .elsif version==350
4767							                ; if C=1, host->parasite; if C=0, parasite->host
4768	.a3ba		a9 01		lda #$01	                lda #tubeReasonMultiByteHostToParasite
4769	.a3bc		e9 00		sbc #$00	                sbc #0                       ;
4776							                .endif                       ; includeTubeSupport
4777	.a3be		20 f2 aa	jsr $aaf2	                jsr initiateCFSRFSTubeTransfer
4778	.a3c1						LA3A7:
4779							                .endif
4780	.a3c1		b2 cc		lda ($cc)	                lda ($CC)                    ; A=handle
4781	.a3c3		a8		tay		                tay                          ; Y=handle
4782	.a3c4		a9 01		lda #$01	                lda #$01
4783							                .if version!=400
4784							                .if includeTubeSupport
4785	.a3c6		28		plp		                plp                          ; restore C
4786							                .endif
4787	.a3c7		08		php		                php                          ; save C
4788	.a3c8		69 00		adc #$00	                adc #$00
4789							                .endif
4790	.a3ca		20 cf aa	jsr $aacf	                jsr LAA8D
4791	.a3cd		b0 0c		bcs $a3db	                bcs LA3C1
4792							                .if version!=400
4793	.a3cf		28		plp		                plp                          ; restore C
4794							                .endif
4795							                .if includeTubeSupport
4796	.a3d0		68		pla		                pla                          ; restore copro usage flag
4797	.a3d1		f0 05		beq $a3d8	                beq LA3BE                    ; taken if not copro
4798	.a3d3		a9 80		lda #$80	                lda #$80
4799	.a3d5		20 06 04	jsr $0406	                jsr tubeHost.entryPoint
4800	.a3d8						LA3BE:
4801							                .endif
4802	.a3d8		4c c3 aa	jmp $aac3	                jmp LAA81

4804	.a3db						LA3C1:
4805							                .if version!=400
4806	.a3db		28		plp		                plp
4807	.a3dc		b0 3d		bcs $a41b	                bcs LA401
4808							                .endif
4809	.a3de		24 e2		bit $e2		                bit $E2
4810	.a3e0		10 0b		bpl $a3ed	                bpl LA3D3
4811							                .if includeTubeSupport
4812	.a3e2		68		pla		                pla                          ; restore copro usage flag
4813	.a3e3		f0 05		beq $a3ea	                beq LA3D0                    ; taken if no copro usage
4814	.a3e5		a9 80		lda #$80	                lda #$80                     ; $80 = RFS/CFS release Tube
4815	.a3e7		20 06 04	jsr $0406	                jsr tubeHost.entryPoint
4816	.a3ea						LA3D0:
4817							                .endif
4818	.a3ea		4c 5f a3	jmp $a35f	                jmp LA343

4820	.a3ed						LA3D3:
4821	.a3ed		20 22 ab	jsr $ab22	                jsr LAAE0
4822	.a3f0		f0 1e		beq $a410	                beq LA3F6
4823	.a3f2		b2 cc		lda ($cc)	                lda ($CC)
4824	.a3f4		a8		tay		                tay
4825	.a3f5		20 06 a3	jsr $a306	                jsr bputTapeOrROM
4826	.a3f8		b0 16		bcs $a410	                bcs LA3F6
4827							                .if includeTubeSupport
4828	.a3fa		fa		plx		                plx                          ; restore copro usage flag
4829	.a3fb		da		phx		                phx                          ; save copro usage flag
4830	.a3fc		f0 05		beq $a403	                beq LA3E9                    ; taken if no copro usage
4831	.a3fe		8d e5 fe	sta $fee5	                sta tube.data3               ; send byte to Tube
4832	.a401		80 08		bra $a40b	                bra LA3F1

4834	.a403						LA3E9:
4835							                .endif
4836	.a403		92 c8		sta ($c8)	                sta ($C8)                    ; store the byte to I/O RAM
4837	.a405		e6 c8		inc $c8		                inc $C8                      ; next address...
4838	.a407		d0 02		bne $a40b	                bne LA3F1
4839	.a409		e6 c9		inc $c9		                inc $C9
4840	.a40b						LA3F1:
4841	.a40b		20 0c ab	jsr $ab0c	                jsr LAACA
4842	.a40e		80 dd		bra $a3ed	                bra LA3D3

4844	.a410						LA3F6:
4845							                .if includeTubeSupport
4846	.a410		68		pla		                pla                          ; restore copro usage flag
4847	.a411		08		php		                php
4848	.a412		f0 05		beq $a419	                beq LA3FF                    ; taken if not copro usage
4849	.a414		a9 80		lda #$80	                lda #$80                     ; $80 = RFS/CFS release Tube
4850	.a416		20 06 04	jsr $0406	                jsr tubeHost.entryPoint
4851	.a419						LA3FF:
4852	.a419		28		plp		                plp
4853							                .endif
4854	.a41a		60		rts		                rts

4856							                .if version!=400
4857	.a41b						LA401:
4858	.a41b		20 22 ab	jsr $ab22	                jsr LAAE0
4859	.a41e		f0 f0		beq $a410	                beq LA3F6
4860	.a420		b2 cc		lda ($cc)	                lda ($CC)
4861	.a422		a8		tay		                tay
4862							                .if includeTubeSupport
4863	.a423		68		pla		                pla                          ; restore copro usage flag
4864	.a424		48		pha		                pha                          ; save copro usage flag
4865	.a425		f0 05		beq $a42c	                beq LA412                    ; taken if not copro usage
4866	.a427		ad e5 fe	lda $fee5	                lda tube.data3               ; receive byte from Tube
4867	.a42a		80 08		bra $a434	                bra LA41A
4868	.a42c						LA412:
4869							                .endif

4871	.a42c		b2 c8		lda ($c8)	                lda ($C8)                    ; read the byte from I/O RAM
4872	.a42e		e6 c8		inc $c8		                inc $C8                      ; next address...
4873	.a430		d0 02		bne $a434	                bne LA41A
4874	.a432		e6 c9		inc $c9		                inc $C9
4875	.a434						LA41A:
4876	.a434		20 67 a3	jsr $a367	                jsr bgetTapeOrROM
4877	.a437		20 0c ab	jsr $ab0c	                jsr LAACA
4878	.a43a		80 df		bra $a41b	                bra LA401
4879							                .endif

4881							; TAPE/ROM FSC 0 - *OPT
4882							; ---------------------
4883	.a43c						LA422:
4884	.a43c		8a		txa		                txa                          ; *OPT 0
4885	.a43d		f0 2e		beq $a46d	                beq LA453
4886	.a43f		e0 03		cpx #$03	                cpx #$03                     ; *OPT 3
4887	.a441		f0 1f		beq $a462	                beq LA448
4888	.a443		c0 03		cpy #$03	                cpy #$03                     ; *OPT n,3+ - error Bad command (*BUG* should be Bad option)
4889	.a445		b0 06		bcs $a44d	                bcs LA433
4890	.a447		ca		dex		                dex                          ; *OPT 1
4891	.a448		f0 06		beq $a450	                beq LA436
4892	.a44a		ca		dex		                dex                          ; *OPT 2
4893	.a44b		f0 0a		beq $a457	                beq LA43D
4894	.a44d						LA433:
4895	.a44d		4c 29 f9	jmp $f929	                jmp badCommandError ; *OPT 4+ - error Bad command (*BUG* should be Bad option)

4897							; *OPT 1 - set message level
4898							; --------------------------
4899	.a450						LA436:
4900	.a450		a9 33		lda #$33	                lda #$33
4901	.a452		c8		iny		                iny
4902	.a453		c8		iny		                iny
4903	.a454		c8		iny		                iny
4904	.a455		80 02		bra $a459	                bra LA43F

4906							; *OPT 2 - set error response level
4907							; ---------------------------------
4908	.a457						LA43D:
4909	.a457		a9 cc		lda #$cc	                lda #$CC
4910	.a459						LA43F:
4911	.a459		c8		iny		                iny
4912	.a45a		25 e3		and $e3		                and $E3
4913	.a45c						LA442:
4914	.a45c		19 70 a4	ora $a470,y	                ora LA456,y
4915	.a45f		85 e3		sta $e3		                sta $E3
4916	.a461		60		rts		                rts

4918							; *OPT 3 - set interblock gap
4919							; ---------------------------
4920	.a462						LA448:
4921	.a462		98		tya		                tya                          ; *OPT 3,128+ - set to default
4922	.a463		30 02		bmi $a467	                bmi LA44D    ;
4923	.a465		d0 02		bne $a469	                bne LA44F                    ; *OPT 3,<>0 - use setting
4924	.a467						LA44D:
4925	.a467		a9 19		lda #$19	                lda #$19                     ; *OPT 3,0 or *OPT 3,128+ - use default of 2.5 sec
4926	.a469						LA44F:
4927	.a469		8d d1 03	sta $03d1	                sta $03D1                    ; Set inter-block gap
4928	.a46c		60		rts		                rts

4930	.a46d						LA453:
4931	.a46d		a8		tay		                tay
4932	.a46e		80 ec		bra $a45c	                bra LA442

4934	.a470						LA456:
4935							                ; LDA ($00,x)
4936							                ; EQUB $22
4937							                ; ORA ($00),y
4938							                ; DEY
4939							                ; CPY LC0C6
4940	>a470		a1				                .byte $A1
4941	>a471		00				                .byte $00
4942	>a472		22				                .byte $22
4943	>a473		11				                .byte $11
4944	>a474		00				                .byte $00
4945	>a475		88				                .byte $88
4946	>a476		cc				                .byte $CC

4948							                .if version!=400
4949	.a477						LA45D:
4950	.a477		c6 c0		dec $c0		                dec $C0
4951	.a479		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4952	.a47c		f0 07		beq $a485	                beq LA46B
4953	.a47e		20 eb f3	jsr $f3eb	                jsr LF710
4954	.a481		a8		tay		                tay
4955	.a482		18		clc		                clc
4956	.a483		80 1a		bra $a49f	                bra LA485

4958	.a485						LA46B:
4959	.a485		ad 08 fe	lda $fe08	                lda ACIA+0
4960	.a488		48		pha		                pha
4961	.a489		29 02		and #$02	                and #$02
4962	.a48b		f0 0b		beq $a498	                beq LA47E
4963	.a48d		a4 ca		ldy $ca		                ldy $CA
4964	.a48f		f0 07		beq $a498	                beq LA47E
4965	.a491		68		pla		                pla
4966	.a492		a5 bd		lda $bd		                lda $BD
4967	.a494		8d 09 fe	sta $fe09	                sta ACIA+1
4968	.a497		60		rts		                rts

4970	.a498						LA47E:
4971	.a498		ac 09 fe	ldy $fe09	                ldy ACIA+1
4972	.a49b		68		pla		                pla
4973	.a49c		4a		lsr a		                lsr a
4974	.a49d		4a		lsr a		                lsr a
4975	.a49e		4a		lsr a		                lsr a
4976	.a49f						LA485:
4977	.a49f		a6 c2		ldx $c2		                ldx $C2
4978	.a4a1		f0 67		beq $a50a	                beq LA4F0
4979	.a4a3		ca		dex		                dex
4980	.a4a4		d0 06		bne $a4ac	                bne LA492
4981	.a4a6		90 62		bcc $a50a	                bcc LA4F0
4982	.a4a8		a0 02		ldy #$02	                ldy #$02
4983	.a4aa		80 5c		bra $a508	                bra LA4EE
4984							                .endif

4986	.a4ac						LA492:
4987							                .if version==400
4996							                .else
4997	.a4ac		ca		dex		                dex
4998	.a4ad		d0 13		bne $a4c2	                bne LA4A8
4999	.a4af		b0 59		bcs $a50a	                bcs LA4F0
5000							                .endif
5001	.a4b1		98		tya		                tya
5002	.a4b2		20 86 aa	jsr $aa86	                jsr LAA44
5003	.a4b5		a0 03		ldy #$03	                ldy #$03
5004	.a4b7		c9 2a		cmp #$2a	                cmp #$2A
5005	.a4b9		f0 4d		beq $a508	                beq LA4EE
5006	.a4bb		20 5e aa	jsr $aa5e	                jsr LAA1C
5007	.a4be		a0 01		ldy #$01	                ldy #$01
5008	.a4c0		80 46		bra $a508	                bra LA4EE

5010	.a4c2						LA4A8:
5011	.a4c2		ca		dex		                dex
5012	.a4c3		d0 0a		bne $a4cf	                bne LA4B5
5013							                .if version!=400
5014	.a4c5		b0 03		bcs $a4ca	                bcs LA4B0
5015							                .endif
5016	.a4c7		84 bd		sty $bd		                sty $BD
5017	.a4c9		60		rts		                rts

5019							                .if version!=400
5020	.a4ca						LA4B0:
5021	.a4ca		a9 80		lda #$80	                lda #$80
5022	.a4cc		85 c0		sta $c0		                sta $C0
5023	.a4ce		60		rts		                rts
5024							                .endif

5026	.a4cf						LA4B5:
5027	.a4cf		ca		dex		                dex
5028	.a4d0		d0 29		bne $a4fb	                bne LA4E1
5029							                .if version!=400
5030	.a4d2		b0 2f		bcs $a503	                bcs LA4E9
5031							                .endif
5032	.a4d4		98		tya		                tya
5033	.a4d5		20 c3 a6	jsr $a6c3	                jsr LA6A9
5034	.a4d8		a4 bc		ldy $bc		                ldy $BC
5035	.a4da		e6 bc		inc $bc		                inc $BC
5036	.a4dc		24 bd		bit $bd		                bit $BD
5037	.a4de		30 0d		bmi $a4ed	                bmi LA4D3
5038							                .if includeTubeSupport
5039	.a4e0		20 fe aa	jsr $aafe	                jsr isTubeAddress
5040	.a4e3		f0 05		beq $a4ea	                beq LA4D0                    ; taken if not Tube address
5041	.a4e5		8e e5 fe	stx $fee5	                stx tube.data3
5042	.a4e8		80 03		bra $a4ed	                bra LA4D3

5044	.a4ea						LA4D0:
5045	.a4ea		8a		txa		                txa                          ; A=byte to write
5046							                .endif
5047	.a4eb		91 b0		sta ($b0),y	                sta ($B0),y                  ; store byte to I/O RAM
5048	.a4ed						LA4D3:
5049	.a4ed		c8		iny		                iny
5050	.a4ee		cc c8 03	cpy $03c8	                cpy $03C8
5051	.a4f1		d0 17		bne $a50a	                bne LA4F0
5052	.a4f3		a9 01		lda #$01	                lda #$01
5053	.a4f5		85 bc		sta $bc		                sta $BC
5054	.a4f7		a0 05		ldy #$05	                ldy #$05
5055	.a4f9		80 0d		bra $a508	                bra LA4EE

5057	.a4fb						LA4E1:
5058	.a4fb		98		tya		                tya
5059	.a4fc		20 c3 a6	jsr $a6c3	                jsr LA6A9
5060	.a4ff		c6 bc		dec $bc		                dec $BC
5061	.a501		10 07		bpl $a50a	                bpl LA4F0
5062							                .if version!=400
5063	.a503						LA4E9:
5064	.a503		20 54 aa	jsr $aa54	                jsr resetACIA
5065							                .endif
5066	.a506		a0 00		ldy #$00	                ldy #$00
5067	.a508						LA4EE:
5068	.a508		84 c2		sty $c2		                sty $C2
5069	.a50a						LA4F0:
5070	.a50a		60		rts		                rts

5072							; TAPE/ROM FSC 1 - =EOF
5073							; ---------------------
5074	.a50b						LA4F1:
5075	.a50b		48		pha		                pha
5076	.a50c		5a		phy		                phy
5077	.a50d		8a		txa		                txa
5078	.a50e		a8		tay		                tay
5079	.a50f		a9 03		lda #$03	                lda #$03                     ; Check if this channel is open for anything
5080	.a511		20 aa aa	jsr $aaaa	                jsr LAA68
5081	.a514		a5 e2		lda $e2		                lda $E2                      ; Get EOF flag
5082	.a516		29 40		and #$40	                and #$40
5083	.a518		aa		tax		                tax                          ; Return in X
5084	.a519		7a		ply		                ply
5085	.a51a		68		pla		                pla
5086	.a51b		60		rts		                rts

5088	.a51c						LA502:
5089	.a51c		64 b4		stz $b4		                stz $B4
5090	.a51e		64 b5		stz $b5		                stz $B5
5091	.a520						LA506:
5092	.a520		46 ce		lsr $ce		                lsr $CE
5093	.a522		a5 b4		lda $b4		                lda $B4
5094	.a524		48		pha		                pha
5095	.a525		85 b6		sta $b6		                sta $B6
5096	.a527		a5 b5		lda $b5		                lda $B5
5097	.a529		48		pha		                pha
5098	.a52a		85 b7		sta $b7		                sta $B7
5099	.a52c		20 65 a9	jsr $a965	                jsr LA923
5100	>a52f		53 65 61 72 63 68 69 6e		                .text "Searching",13,0
	>a537		67 0d 00
5101	.a53a		a9 ff		lda #$ff	                lda #$ff
5102	.a53c		20 98 a1	jsr $a198	                jsr LA17C
5103	.a53f		68		pla		                pla
5104	.a540		85 b5		sta $b5		                sta $B5
5105	.a542		68		pla		                pla
5106	.a543		85 b4		sta $b4		                sta $B4
5107	.a545		a5 b6		lda $b6		                lda $B6
5108	.a547		05 b7		ora $b7		                ora $B7
5109	.a549		d0 33		bne $a57e	                bne LA564
5110	.a54b		64 b4		stz $b4		                stz $B4
5111	.a54d		64 b5		stz $b5		                stz $B5
5112							                .if version!=400
5113	.a54f		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5114	.a552		f0 21		beq $a575	                beq LA55B
5115							                .endif
5116	.a554		70 1f		bvs $a575	                bvs LA55B
5117							                .if version!=400
5118	.a556		20 0c aa	jsr $aa0c	                jsr LA9CA
5119							                .endif
5120	.a559		24 ce		bit $ce		                bit $CE
5121	.a55b		50 0a		bvc $a567	                bvc notFoundError
5122	.a55d		38		sec		                sec
5123	.a55e						rtsA544:
5124	.a55e		60		rts		                rts

5126							;-------------------------------------------------------------------------

5128	.a55f						openFileForReading:
5129	.a55f		a9 40		lda #$40	                lda #$40                     ;open for reading
5130	.a561		20 ce ff	jsr $ffce	                jsr OSFIND
5131	.a564		a8		tay		                tay
5132	.a565		d0 f7		bne $a55e	                bne rtsA544
5133	.a567						notFoundError:
5134	.a567		20 2f ab	jsr $ab2f	                jsr doFollowingError
5135	>a56a		d6 4e 6f 74 20 66 6f 75		                .text $d6,"Not found",0
	>a572		6e 64 00

5137							;-------------------------------------------------------------------------

5139	.a575						LA55B:
5140	.a575		a5 c1		lda $c1		                lda $C1
5141	.a577		d0 05		bne $a57e	                bne LA564
5142	.a579		a2 b1		ldx #$b1	                ldx #$B1
5143	.a57b		20 8f aa	jsr $aa8f	                jsr LAA4D
5144	.a57e						LA564:
5145	.a57e		a0 ff		ldy #$ff	                ldy #$FF
5146	.a580		8c df 03	sty $03df	                sty $03DF
5147	.a583		18		clc		                clc
5148	.a584		60		rts		                rts

5150	.a585						LA56B:
5151	.a585		f0 17		beq $a59e	                beq LA584
5152	.a587		48		pha		                pha
5153	.a588		a9 07		lda #$07	                lda #fscFileHandleRange
5154	.a58a		20 50 f1	jsr $f150	                jsr callFSCV
5155	.a58d		68		pla		                pla
5156	.a58e		18		clc		                clc
5157	.a58f		08		php		                php
5158	.a590		78		sei		                sei
5159	.a591		85 fa		sta $fa		                sta $FA
5160	.a593		c4 fa		cpy $fa		                cpy $FA
5161	.a595		90 06		bcc $a59d	                bcc LA583
5162	.a597		e4 fa		cpx $fa		                cpx $FA
5163	.a599		90 06		bcc $a5a1	                bcc LA587
5164	.a59b		f0 04		beq $a5a1	                beq LA587
5165	.a59d						LA583:
5166	.a59d		28		plp		                plp
5167	.a59e						LA584:
5168	.a59e		68		pla		                pla
5169	.a59f		68		pla		                pla
5170	.a5a0		60		rts		                rts

5172	.a5a1						LA587:
5173	.a5a1		28		plp		                plp
5174	.a5a2		a9 00		lda #$00	                lda #$00
5175	.a5a4		60		rts		                rts

5177	.a5a5						LA58B:
5178	.a5a5		ad 56 02	lda $0256	                lda execFileHandle
5179	.a5a8		20 85 a5	jsr $a585	                jsr LA56B
5180	.a5ab						starEXEC:
5181	.a5ab		08		php		                php
5182	.a5ac		5a		phy		                phy
5183	.a5ad		ac 56 02	ldy $0256	                ldy execFileHandle
5184	.a5b0		8d 56 02	sta $0256	                sta execFileHandle
5185	.a5b3		f0 03		beq $a5b8	                beq LA59E
5186	.a5b5		20 ce ff	jsr $ffce	                jsr OSFIND
5187	.a5b8						LA59E:
5188	.a5b8		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
5189	.a5bb		7a		ply		                ply
5190	.a5bc		28		plp		                plp
5191	.a5bd		f0 09		beq $a5c8	                beq LA5AE
5192	.a5bf		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
5193	.a5c2		20 5f a5	jsr $a55f	                jsr openFileForReading
5194	.a5c5		8d 56 02	sta $0256	                sta execFileHandle
5195	.a5c8						LA5AE:
5196	.a5c8		60		rts		                rts

5198	.a5c9						LA5AF:
5199	.a5c9		a2 a6		ldx #$a6	                ldx #$A6
5200	.a5cb		20 8f aa	jsr $aa8f	                jsr LAA4D
5201	.a5ce		20 92 a6	jsr $a692	                jsr LA678
5202	.a5d1						LA5B7:
5203	.a5d1		ad ca 03	lda $03ca	                lda $03CA
5204	.a5d4		4a		lsr a		                lsr a
5205	.a5d5		90 03		bcc $a5da	                bcc LA5C0
5206	.a5d7		4c ff 9f	jmp $9fff	                jmp L9FE3

5208	.a5da						LA5C0:
5209	.a5da		ad dd 03	lda $03dd	                lda $03DD
5210	.a5dd		85 b4		sta $b4		                sta $B4
5211	.a5df		ad de 03	lda $03de	                lda $03DE
5212	.a5e2		85 b5		sta $b5		                sta $B5
5213	.a5e4		64 b0		stz $b0		                stz $B0
5214	.a5e6		a9 0a		lda #$0a	                lda #$0A
5215	.a5e8		85 b1		sta $b1		                sta $B1
5216	.a5ea		a9 ff		lda #$ff	                lda #$FF
5217	.a5ec		85 b2		sta $b2		                sta $B2
5218	.a5ee		85 b3		sta $b3		                sta $B3
5219	.a5f0		20 ec a6	jsr $a6ec	                jsr LA6D2
5220	.a5f3		20 e3 a8	jsr $a8e3	                jsr LA8A1
5221	.a5f6		d0 25		bne $a61d	                bne LA603
5222	.a5f8		ad ff 0a	lda $0aff	                lda $0AFF
5223	.a5fb		8d ec 02	sta $02ec	                sta lastCharacterOfCurrentlyResidentBlock
5224	.a5fe		20 77 aa	jsr $aa77	                jsr LAA35
5225	.a601		8e dd 03	stx $03dd	                stx $03DD
5226	.a604		8c de 03	sty $03de	                sty $03DE
5227	.a607		a2 02		ldx #$02	                ldx #$02
5228	.a609						LA5EF:
5229	.a609		bd c8 03	lda $03c8,x	                lda $03C8,x
5230	.a60c		9d e9 02	sta $02e9,x	                sta tapeInputCurrentBlockSize+0,x
5231	.a60f		ca		dex		                dex
5232	.a610		10 f7		bpl $a609	                bpl LA5EF
5233	.a612		2c eb 02	bit $02eb	                bit blockFlagOfCurrentlyResidentBlock
5234	.a615		10 03		bpl $a61a	                bpl LA600
5235	.a617		20 75 a0	jsr $a075	                jsr LA059
5236	.a61a						LA600:
5237	.a61a		4c 07 aa	jmp $aa07	                jmp LA9C5

5239	.a61d						LA603:
5240	.a61d		20 20 a5	jsr $a520	                jsr LA506
5241	.a620		80 af		bra $a5d1	                bra LA5B7

5243	.a622						LA608:
5244	.a622		c9 2a		cmp #$2a	                cmp #'*'
5245	.a624		f0 37		beq $a65d	                beq LA643
5246	.a626		c9 23		cmp #$23	                cmp #'#'
5247	.a628		d0 0f		bne $a639	                bne LA61F
5248	.a62a		ee c6 03	inc $03c6	                inc $03C6
5249	.a62d		d0 03		bne $a632	                bne LA618
5250	.a62f		ee c7 03	inc $03c7	                inc $03C7
5251	.a632						LA618:
5252	.a632		a2 ff		ldx #$ff	                ldx #$FF
5253	.a634		2c 5e e3	bit $e35e	                bit valueFF
5254	.a637		80 51		bra $a68a	                bra LA670

5256	.a639						LA61F:
5257	.a639		20 93 a1	jsr $a193	                jsr LA177
5258	.a63c		20 2f ab	jsr $ab2f	                jsr doFollowingError
5259	>a63f		d7				                .byte $D7
5260	>a640		42 61 64 20 52 4f 4d		                .text "Bad ROM"
5261	>a647		00				                .byte 0

5263	.a648						LA62E:
5264							                .if version!=400
5265	.a648		a0 ff		ldy #$ff	                ldy #$FF
5266	.a64a		20 9e aa	jsr $aa9e	                jsr LAA5C
5267	.a64d		a9 01		lda #$01	                lda #$01
5268	.a64f		85 c2		sta $c2		                sta $C2
5269	.a651		20 5e aa	jsr $aa5e	                jsr LAA1C
5270	.a654						LA63A:
5271	.a654		20 c2 a8	jsr $a8c2	                jsr LA880
5272	.a657		a9 03		lda #$03	                lda #$03
5273	.a659		c5 c2		cmp $c2		                cmp $C2
5274	.a65b		d0 f7		bne $a654	                bne LA63A
5275							                .endif
5276	.a65d						LA643:
5277	.a65d		20 88 aa	jsr $aa88	                jsr LAA46
5278	.a660						LA646:
5279	.a660		20 ae a6	jsr $a6ae	                jsr LA694
5280	.a663		50 1a		bvc $a67f	                bvc LA665
5281	.a665		99 b2 03	sta $03b2,y	                sta $03B2,y
5282	.a668		f0 06		beq $a670	                beq LA656
5283	.a66a		c8		iny		                iny
5284	.a66b		c0 0b		cpy #$0b	                cpy #$0B
5285	.a66d		d0 f1		bne $a660	                bne LA646
5286	.a66f		88		dey		                dey
5287	.a670						LA656:
5288	.a670		a2 0c		ldx #$0c	                ldx #$0C
5289	.a672						LA658:
5290	.a672		20 ae a6	jsr $a6ae	                jsr LA694
5291	.a675		50 08		bvc $a67f	                bvc LA665
5292	.a677		9d b2 03	sta $03b2,x	                sta $03B2,x
5293	.a67a		e8		inx		                inx
5294	.a67b		e0 1f		cpx #$1f	                cpx #$1F
5295	.a67d		d0 f3		bne $a672	                bne LA658
5296	.a67f						LA665:
5297	.a67f		98		tya		                tya
5298	.a680		aa		tax		                tax
5299	.a681		9e b2 03	stz $03b2,x	                stz $03B2,x
5300	.a684		a5 be		lda $be		                lda $BE
5301	.a686		05 bf		ora $bf		                ora $BF
5302	.a688		85 c1		sta $c1		                sta $C1
5303	.a68a						LA670:
5304	.a68a		20 86 aa	jsr $aa86	                jsr LAA44
5305	.a68d		84 c2		sty $c2		                sty $C2
5306	.a68f		8a		txa		                txa
5307							                .if version<500
5308	.a690		d0 54		bne $a6e6	                bne LA6CC
5311							                .endif
5312	.a692						LA678:
5313							                .if version!=400
5314	.a692		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5315	.a695		f0 b1		beq $a648	                beq LA62E
5316							                .endif
5317	.a697						LA67D:
5318	.a697		20 eb f3	jsr $f3eb	                jsr LF710
5319	.a69a		c9 2b		cmp #$2b	                cmp #$2B
5320	.a69c		d0 84		bne $a622	                bne LA608
5321	.a69e		a9 08		lda #$08	                lda #$08
5322	.a6a0		25 e2		and $e2		                and $E2
5323	.a6a2		f0 03		beq $a6a7	                beq LA68D
5324	.a6a4		20 79 a0	jsr $a079	                jsr LA05D
5325	.a6a7						LA68D:
5326	.a6a7		20 dc f3	jsr $f3dc	                jsr LF701
5327	.a6aa		90 eb		bcc $a697	                bcc LA67D
5328	.a6ac		b8		clv		                clv
5329	.a6ad		60		rts		                rts

5331	.a6ae						LA694:
5332							                .if version!=400
5333	.a6ae		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5334	.a6b1		f0 0d		beq $a6c0	                beq LA6A6
5335							                .endif
5336	.a6b3		da		phx		                phx
5337	.a6b4		5a		phy		                phy
5338	.a6b5		20 eb f3	jsr $f3eb	                jsr LF710
5339	.a6b8		85 bd		sta $bd		                sta $BD
5340	.a6ba		a9 ff		lda #$ff	                lda #$FF
5341	.a6bc		85 c0		sta $c0		                sta $C0
5342	.a6be		7a		ply		                ply
5343	.a6bf		fa		plx		                plx
5344	.a6c0						LA6A6:
5345	.a6c0		20 92 a7	jsr $a792	                jsr LA778
5346	.a6c3						LA6A9:
5347							                .if version<500
5348	.a6c3		08		php		                php
5349	.a6c4		48		pha		                pha
5350	.a6c5		38		sec		                sec
5351	.a6c6		66 cb		ror $cb		                ror $CB
5352	.a6c8		45 bf		eor $bf		                eor $BF
5353	.a6ca		85 bf		sta $bf		                sta $BF
5354	.a6cc						LA6B2:
5355	.a6cc		a5 bf		lda $bf		                lda $BF
5356	.a6ce		18		clc		                clc
5357	.a6cf		10 0b		bpl $a6dc	                bpl LA6C2
5358	.a6d1		49 08		eor #$08	                eor #$08
5359	.a6d3		85 bf		sta $bf		                sta $BF
5360	.a6d5		a5 be		lda $be		                lda $BE
5361	.a6d7		49 10		eor #$10	                eor #$10
5362	.a6d9		85 be		sta $be		                sta $BE
5363	.a6db		38		sec		                sec
5364	.a6dc						LA6C2:
5365	.a6dc		26 be		rol $be		                rol $BE
5366	.a6de		26 bf		rol $bf		                rol $BF
5367	.a6e0		46 cb		lsr $cb		                lsr $CB
5368	.a6e2		d0 e8		bne $a6cc	                bne LA6B2
5369	.a6e4		68		pla		                pla
5370	.a6e5		28		plp		                plp
5371							                .endif
5372	.a6e6						LA6CC:
5373	.a6e6		60		rts		                rts

5375							                .if version!=400
5376	.a6e7						LA6CD:                                       ;AAA6 in MOS 5.00
5377	.a6e7		20 90 a7	jsr $a790	                jsr LA776
5378	.a6ea		80 d7		bra $a6c3	                bra LA6A9
5379							                .endif

5381	.a6ec						LA6D2:                                       ;AAAB in MOS 5.00
5382	.a6ec		a9 00		lda #$00	                lda #$00
5383	.a6ee						LA6D4:
5384	.a6ee		85 bd		sta $bd		                sta $BD
5385	.a6f0		a2 00		ldx #$00	                ldx #$00
5386	.a6f2		64 bc		stz $bc		                stz $BC
5387	.a6f4		50 0a		bvc $a700	                bvc LA6E6
5388	.a6f6		ad c8 03	lda $03c8	                lda $03C8
5389	.a6f9		0d c9 03	ora $03c9	                ora $03C9
5390	.a6fc		f0 02		beq $a700	                beq LA6E6
5391	.a6fe		a2 04		ldx #$04	                ldx #$04
5392	.a700						LA6E6:
5393	.a700		86 c2		stx $c2		                stx $C2
5394	.a702						rtsAAC1:
5395	.a702		60		rts		                rts

5397							                .if version!=400
5398	.a703						LA6E9:                                       ;AAC2 in MOS 5.00
5399	.a703		08		php		                php
5400	.a704		a2 03		ldx #$03	                ldx #$03
5401	.a706						LA6EC:
5402	.a706		9e cb 03	stz $03cb,x	                stz $03CB,x
5403	.a709		ca		dex		                dex
5404	.a70a		10 fa		bpl $a706	                bpl LA6EC
5405	.a70c		ad c6 03	lda $03c6	                lda $03C6
5406	.a70f		0d c7 03	ora $03c7	                ora $03C7
5407	.a712		d0 05		bne $a719	                bne LA6FF
5408	.a714		20 9e a7	jsr $a79e	                jsr LA784
5409	.a717		80 03		bra $a71c	                bra LA702

5411	.a719						LA6FF:
5412	.a719		20 a2 a7	jsr $a7a2	                jsr LA788
5413	.a71c						LA702:
5414	.a71c		a9 2a		lda #$2a	                lda #$2A
5415	.a71e		85 bd		sta $bd		                sta $BD
5416	.a720		20 86 aa	jsr $aa86	                jsr LAA44
5417	.a723		20 58 aa	jsr $aa58	                jsr LAA16
5418	.a726		20 92 a7	jsr $a792	                jsr LA778
5419	.a729		88		dey		                dey
5420	.a72a						LA710:
5421	.a72a		c8		iny		                iny
5422	.a72b		b9 d2 03	lda $03d2,y	                lda $03D2,y
5423	.a72e		99 b2 03	sta $03b2,y	                sta $03B2,y
5424	.a731		20 e7 a6	jsr $a6e7	                jsr LA6CD
5425	.a734		d0 f4		bne $a72a	                bne LA710
5426	.a736		a2 0c		ldx #$0c	                ldx #$0C
5427	.a738						LA71E:
5428	.a738		bd b2 03	lda $03b2,x	                lda $03B2,x
5429	.a73b		20 e7 a6	jsr $a6e7	                jsr LA6CD
5430	.a73e		e8		inx		                inx
5431	.a73f		e0 1d		cpx #$1d	                cpx #$1D
5432	.a741		d0 f5		bne $a738	                bne LA71E
5433	.a743		20 89 a7	jsr $a789	                jsr LA76F
5434	.a746		ad c8 03	lda $03c8	                lda $03C8
5435	.a749		0d c9 03	ora $03c9	                ora $03C9
5436	.a74c		f0 1b		beq $a769	                beq LA74F
5437	.a74e		20 88 aa	jsr $aa88	                jsr LAA46
5438	.a751						LA737:
5439							                .if includeTubeSupport
5440	.a751		20 fe aa	jsr $aafe	                jsr isTubeAddress
5441	.a754		f0 05		beq $a75b	                beq LA741                   ; taken if notTube address
5442	.a756		ad e5 fe	lda $fee5	                lda tube.data3              ; load from Tube
5443	.a759		80 02		bra $a75d	                bra LA743
5444	.a75b						LA741:
5445							                .endif
5446	.a75b		b1 b0		lda ($b0),y	                lda ($B0),y                  ; load from I/O RAM
5447	.a75d						LA743:
5448	.a75d		20 e7 a6	jsr $a6e7	                jsr LA6CD
5449	.a760		c8		iny		                iny
5450	.a761		cc c8 03	cpy $03c8	                cpy $03C8
5451	.a764		d0 eb		bne $a751	                bne LA737
5452	.a766		20 89 a7	jsr $a789	                jsr LA76F
5453	.a769						LA74F:
5454	.a769		20 92 a7	jsr $a792	                jsr LA778
5455	.a76c		20 92 a7	jsr $a792	                jsr LA778
5456	.a76f		20 54 aa	jsr $aa54	                jsr resetACIA
5457	.a772		a9 01		lda #$01	                lda #$01
5458	.a774		20 a4 a7	jsr $a7a4	                jsr LA78A
5459	.a777		28		plp		                plp
5460	.a778		20 c5 a7	jsr $a7c5	                jsr LA7AB
5461	.a77b		2c ca 03	bit $03ca	                bit $03CA
5462	.a77e		10 08		bpl $a788	                bpl LA76E
5463	.a780		08		php		                php
5464	.a781		20 9e a7	jsr $a79e	                jsr LA784
5465	.a784		20 72 a0	jsr $a072	                jsr LA056
5466	.a787		28		plp		                plp
5467	.a788						LA76E:
5468	.a788		60		rts		                rts

5470	.a789						LA76F:
5471							                .if version<500
5472	.a789		a5 bf		lda $bf		                lda $BF
5475							                .endif
5476	.a78b		20 90 a7	jsr $a790	                jsr LA776
5477							                .if version<500
5478	.a78e		a5 be		lda $be		                lda $BE
5481							                .endif
5482	.a790						LA776:
5483	.a790		85 bd		sta $bd		                sta $BD
5484							                .endif

5486	.a792						LA778:
5487	.a792		20 c2 a8	jsr $a8c2	                jsr LA880
5488	.a795		24 c0		bit $c0		                bit $C0
5489	.a797		10 f9		bpl $a792	                bpl LA778
5490	.a799		64 c0		stz $c0		                stz $C0
5491	.a79b		a5 bd		lda $bd		                lda $BD
5492	.a79d		60		rts		                rts

5494							                .if version!=400
5495	.a79e						LA784:
5496	.a79e		a9 32		lda #$32	                lda #$32
5497	.a7a0		80 02		bra $a7a4	                bra LA78A

5499	.a7a2						LA788:
5500	.a7a2		a5 c7		lda $c7		                lda $C7
5501	.a7a4						LA78A:
5502	.a7a4		a2 05		ldx #$05	                ldx #$05
5503	.a7a6						LA78C:
5504	.a7a6		8d 40 02	sta $0240	                sta cfsTimeoutCounter
5505	.a7a9						LA78F:
5506	.a7a9		20 c2 a8	jsr $a8c2	                jsr LA880
5507	.a7ac		2c 40 02	bit $0240	                bit cfsTimeoutCounter
5508	.a7af		10 f8		bpl $a7a9	                bpl LA78F
5509	.a7b1		ca		dex		                dex
5510	.a7b2		d0 f2		bne $a7a6	                bne LA78C
5511	.a7b4		60		rts		                rts
5512							                .endif

5514	.a7b5						LA79B:
5515	.a7b5		ad c6 03	lda $03c6	                lda $03C6
5516	.a7b8		0d c7 03	ora $03c7	                ora $03C7
5517	.a7bb		f0 05		beq $a7c2	                beq LA7A8
5518	.a7bd		2c df 03	bit $03df	                bit $03DF
5519	.a7c0		10 03		bpl $a7c5	                bpl LA7AB
5520	.a7c2						LA7A8:
5521	.a7c2		20 75 a0	jsr $a075	                jsr LA059
5522	.a7c5						LA7AB:
5523	.a7c5		a0 00		ldy #$00	                ldy #$00
5524	.a7c7		64 ba		stz $ba		                stz $BA
5525	.a7c9		ad ca 03	lda $03ca	                lda $03CA
5526	.a7cc		8d df 03	sta $03df	                sta $03DF
5527	.a7cf		20 fd ed	jsr $edfd	                jsr LEF1B
5528	.a7d2		f0 67		beq $a83b	                beq LA821
5529	.a7d4		a9 0d		lda #$0d	                lda #$0D
5530	.a7d6		20 ee ff	jsr $ffee	                jsr OSWRCH
5531	.a7d9						LA7BF:
5532	.a7d9		b9 b2 03	lda $03b2,y	                lda $03B2,y
5533	.a7dc		f0 10		beq $a7ee	                beq LA7D4
5534	.a7de		c9 20		cmp #$20	                cmp #$20
5535	.a7e0		90 04		bcc $a7e6	                bcc LA7CC
5536	.a7e2		c9 7f		cmp #$7f	                cmp #$7F
5537	.a7e4		90 02		bcc $a7e8	                bcc LA7CE
5538	.a7e6						LA7CC:
5539	.a7e6		a9 3f		lda #$3f	                lda #$3F
5540	.a7e8						LA7CE:
5541	.a7e8		20 ee ff	jsr $ffee	                jsr OSWRCH
5542	.a7eb		c8		iny		                iny
5543	.a7ec		d0 eb		bne $a7d9	                bne LA7BF

5545	.a7ee						LA7D4:
5546							                .if version!=400
5547	.a7ee		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5548	.a7f1		f0 04		beq $a7f7	                beq LA7DD
5549							                .endif
5550	.a7f3		24 bb		bit $bb		                bit $BB
5551	.a7f5		50 44		bvc $a83b	                bvc LA821
5552	.a7f7						LA7DD:
5553	.a7f7		20 28 9f	jsr $9f28	                jsr printSpace
5554	.a7fa		c8		iny		                iny
5555	.a7fb		c0 0b		cpy #$0b	                cpy #$0B
5556	.a7fd		90 ef		bcc $a7ee	                bcc LA7D4
5557	.a7ff		ad c6 03	lda $03c6	                lda $03C6
5558	.a802		aa		tax		                tax
5559	.a803		20 ad a8	jsr $a8ad	                jsr printHexByte
5560	.a806		2c ca 03	bit $03ca	                bit $03CA
5561	.a809		10 30		bpl $a83b	                bpl LA821
5562	.a80b		8a		txa		                txa
5563	.a80c		18		clc		                clc
5564	.a80d		6d c9 03	adc $03c9	                adc $03C9
5565	.a810		20 a8 a8	jsr $a8a8	                jsr printSpaceThenPrintHexByte
5566	.a813						LA7F9:
5567	.a813		ad c8 03	lda $03c8	                lda $03C8
5568	.a816		20 ad a8	jsr $a8ad	                jsr printHexByte
5569	.a819		24 bb		bit $bb		                bit $BB
5570	.a81b		50 1e		bvc $a83b	                bvc LA821
5571	.a81d		a2 04		ldx #$04	                ldx #$04
5572	.a81f						LA805:
5573	.a81f		20 28 9f	jsr $9f28	                jsr printSpace
5574	.a822		ca		dex		                dex
5575	.a823		d0 fa		bne $a81f	                bne LA805
5576	.a825		a2 0f		ldx #$0f	                ldx #$0F
5577	.a827		20 2f a8	jsr $a82f	                jsr LA815
5578	.a82a		20 28 9f	jsr $9f28	                jsr printSpace
5579	.a82d		a2 13		ldx #$13	                ldx #$13
5580	.a82f						LA815:
5581	.a82f		a0 04		ldy #$04	                ldy #$04
5582	.a831						LA817:
5583	.a831		bd b2 03	lda $03b2,x	                lda $03B2,x
5584	.a834		20 ad a8	jsr $a8ad	                jsr printHexByte
5585	.a837		ca		dex		                dex
5586	.a838		88		dey		                dey
5587	.a839		d0 f6		bne $a831	                bne LA817
5588	.a83b						LA821:
5589	.a83b		60		rts		                rts

5591							                .if version!=400
5592	.a83c						LA822:
5593	.a83c		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5594	.a83f		f0 06		beq $a847	                beq LA82D
5595	.a841		20 0c aa	jsr $aa0c	                jsr LA9CA
5596	.a844		4c 29 f9	jmp $f929	                jmp badCommandError

5598	.a847						LA82D:
5599	.a847		20 9c aa	jsr $aa9c	                jsr LAA5A
5600	.a84a		20 e2 aa	jsr $aae2	                jsr LAAA0
5601	.a84d		20 fd ed	jsr $edfd	                jsr LEF1B
5602	.a850		f0 e9		beq $a83b	                beq LA821
5603	.a852		20 65 a9	jsr $a965	                jsr LA923
5604	>a855		52 45 43 4f 52 44 20 74		                .text "RECORD then RETURN"
	>a85d		68 65 6e 20 52 45 54 55 52 4e
5605	>a867		00				                .byte $00

5607	.a868						LA84E:
5608	.a868		20 c2 a8	jsr $a8c2	                jsr LA880
5609	.a86b		20 e0 ff	jsr $ffe0	                jsr OSRDCH
5610	.a86e		c9 0d		cmp #$0d	                cmp #$0D
5611	.a870		d0 f6		bne $a868	                bne LA84E
5612	.a872		4c e7 ff	jmp $ffe7	                jmp OSNEWL
5613							                .endif

5615							;-------------------------------------------------------------------------

5617							                .if version==350
5618							                .include "cfs_errors.s65"

:13	;******  Processing file: src/cfs_errors.s65

1							                ; The MOS code assumes all these error routines have
2							                ; the same MSB of their start address. (There's a
3							                ; .cerror that checks for this.) They all just fit
4							                ; into 32 bytes, so 32-byte alignment will do the
5							                ; trick.
6							                ;
7							                ; (The alignment directive doesn't take effect in any
8							                ; of the default MOS builds. It springs into action to
9							                ; accommodate modifications to other parts of the
10							                ; code.)
11							                .if (>*)!=(>blockError)
13							                .endif

15	.a875						dataError:
16	.a875		20 2f ab	jsr $ab2f	                jsr doFollowingError
17	>a878		d8 0d 44 61 74 61 3f 00		                .text $d8,13,"Data?",0
18	.a880		80 19		bra $a89b	                bra LAB2A

20	.a882						fileError:
21	.a882		20 2f ab	jsr $ab2f	                jsr doFollowingError
22	>a885		db 0d 46 69 6c 65 3f 00		                .text $db,13,"File?",0
23	.a88d		80 0c		bra $a89b	                bra LAB2A

25	.a88f						blockError:
26	.a88f		20 2f ab	jsr $ab2f	                jsr doFollowingError
27	>a892		da 0d 42 6c 6f 63 6b 3f		                .text $da,13,"Block?",0
	>a89a		00
28	.a89b						LAB2A:
29	.a89b		4c ba a9	jmp $a9ba	                jmp LA978


:7	;******  Return to file: src/terminal.s65

5619							                .endif

5621							;-------------------------------------------------------------------------


5624	.a89e						LA85B:
5625	.a89e		a2 fd		ldx #$fd	                ldx #$FD
5626	.a8a0						LA85D:
5627	.a8a0		f6 b4		inc $b4,x	                inc $B4,x
5628	.a8a2		d0 03		bne $a8a7	                bne LA864
5629	.a8a4		e8		inx		                inx
5630	.a8a5		d0 f9		bne $a8a0	                bne LA85D
5631	.a8a7						LA864:
5632	.a8a7		60		rts		                rts

5634							;-------------------------------------------------------------------------

5636	.a8a8						printSpaceThenPrintHexByte:
5637	.a8a8		48		pha		                pha
5638	.a8a9		20 28 9f	jsr $9f28	                jsr printSpace
5639	.a8ac		68		pla		                pla
5640	.a8ad						printHexByte:
5641	.a8ad		48		pha		                pha
5642							                .if version==350
5643	.a8ae		20 20 e5	jsr $e520	                jsr LE520
5649							                .endif
5650	.a8b1		20 b5 a8	jsr $a8b5	                jsr printHexDigit
5651	.a8b4		68		pla		                pla
5652	.a8b5						printHexDigit:
5653	.a8b5		29 0f		and #$0f	                and #$0F
5654	.a8b7		09 30		ora #$30	                ora #'0'                     ;+'0'
5655	.a8b9		c9 3a		cmp #$3a	                cmp #'9'+1
5656	.a8bb		90 02		bcc $a8bf	                bcc LA87D                    ;taken if <='9'
5657	.a8bd		69 06		adc #$06	                adc #'A'-('9'+1)-1           ;adjust - -1 because C set
5658	.a8bf						LA87D:
5659	.a8bf		4c ee ff	jmp $ffee	                jmp OSWRCH

5661							;-------------------------------------------------------------------------

5663	.a8c2						LA880:
5664	.a8c2		08		php		                php
5665	.a8c3		24 eb		bit $eb		                bit $EB
5666	.a8c5		30 04		bmi $a8cb	                bmi LA889
5667	.a8c7		24 ff		bit $ff		                bit $FF
5668	.a8c9		30 02		bmi $a8cd	                bmi LA88B
5669	.a8cb						LA889:
5670	.a8cb		28		plp		                plp
5671	.a8cc		60		rts		                rts

5673	.a8cd						LA88B:
5674	.a8cd		20 93 a1	jsr $a193	                jsr LA177
5675	.a8d0		20 fd a9	jsr $a9fd	                jsr LA9BB
5676	.a8d3						escapeError:
5677	.a8d3		a9 7e		lda #$7e	                lda #$7E
5678	.a8d5		20 f4 ff	jsr $fff4	                jsr OSBYTE
5679	.a8d8		20 2f ab	jsr $ab2f	                jsr doFollowingError
5680	>a8db		11				                .byte $11
5681	>a8dc		45 73 63 61 70 65		                .text "Escape"
5682	>a8e2		00				                .byte $00

5684							;-------------------------------------------------------------------------

5686	.a8e3						LA8A1:
5687	.a8e3		98		tya		                tya
5688	.a8e4		f0 0d		beq $a8f3	                beq LA8B1
5689	.a8e6		20 65 a9	jsr $a965	                jsr LA923
5690	>a8e9		0d				                .byte $0D
5691	>a8ea		4c 6f 61 64 69 6e 67		                .text "Loading"
5692	>a8f1		0d				                .byte $0D
5693	>a8f2		00				                .byte $00
5694	.a8f3						LA8B1:
5695	.a8f3		64 ba		stz $ba		                stz $BA                      ; :
5696	.a8f5		a2 ff		ldx #$ff	                ldx #$FF
5697	.a8f7		a5 c1		lda $c1		                lda $C1
5698	.a8f9		d0 0b		bne $a906	                bne LA8C4
5699	.a8fb		20 9e a9	jsr $a99e	                jsr LA95C
5700	.a8fe		08		php		                php
5701	.a8ff		a2 ff		ldx #$ff	                ldx #$FF
5702	.a901		a0 82		ldy #$82	                ldy #<fileError
5703							                .cwarn (>fileError)!=(>dataError),"must be on same page"
5704	.a903		28		plp		                plp
5705	.a904		d0 16		bne $a91c	                bne LA8DA
5706	.a906						LA8C4:
5707	.a906		a0 75		ldy #$75	                ldy #<dataError
5708	.a908		a5 c1		lda $c1		                lda $C1
5709	.a90a		d0 10		bne $a91c	                bne LA8DA
5710	.a90c		ad c6 03	lda $03c6	                lda $03C6
5711	.a90f		c5 b4		cmp $b4		                cmp $B4
5712	.a911		d0 07		bne $a91a	                bne LA8D8
5713	.a913		ad c7 03	lda $03c7	                lda $03C7
5714	.a916		c5 b5		cmp $b5		                cmp $B5
5715	.a918		f0 0b		beq $a925	                beq LA8E3
5716	.a91a						LA8D8:
5717	.a91a		a0 8f		ldy #$8f	                ldy #<blockError
5718							                .cwarn (>blockError)!=(>dataError),"must be on same page"
5719	.a91c						LA8DA:
5720	.a91c		5a		phy		                phy
5721	.a91d		da		phx		                phx
5722	.a91e		20 c2 a7	jsr $a7c2	                jsr LA7A8
5723	.a921		fa		plx		                plx
5724	.a922		7a		ply		                ply
5725	.a923		80 10		bra $a935	                bra LA8F3

5727	.a925						LA8E3:
5728	.a925		da		phx		                phx
5729	.a926		20 b5 a7	jsr $a7b5	                jsr LA79B
5730	.a929		20 e2 a9	jsr $a9e2	                jsr LA9A0
5731	.a92c		fa		plx		                plx
5732	.a92d		a5 be		lda $be		                lda $BE
5733	.a92f		05 bf		ora $bf		                ora $BF
5734	.a931		f0 79		beq $a9ac	                beq LA96A
5735	.a933		a0 75		ldy #$75	                ldy #<dataError
5736	.a935						LA8F3:
5737	.a935		a9 a8		lda #$a8	                lda #>dataError
5738	.a937		c6 ba		dec $ba		                dec $BA
5739	.a939		48		pha		                pha
5740	.a93a		24 eb		bit $eb		                bit $EB
5741	.a93c		30 0d		bmi $a94b	                bmi LA909
5742	.a93e		8a		txa		                txa
5743							                .if version!=400
5744	.a93f		2d 47 02	and $0247	                and cfsRFSFSSwitch
5745	.a942						LA900:
5746							                .endif
5747	.a942		d0 07		bne $a94b	                bne LA909
5748	.a944		8a		txa		                txa
5749	.a945		29 11		and #$11	                and #$11
5750	.a947		25 bb		and $bb		                and $BB
5751	.a949		f0 0f		beq $a95a	                beq LA918
5752	.a94b						LA909:
5753	.a94b		68		pla		                pla
5754	.a94c		85 b9		sta $b9		                sta $B9
5755	.a94e		84 b8		sty $b8		                sty $B8
5756	.a950		20 a5 a5	jsr $a5a5	                jsr LA58B
5757	.a953		46 eb		lsr $eb		                lsr $EB
5758	.a955		20 f3 a9	jsr $a9f3	                jsr LA9B1
5759	.a958		80 3d		bra $a997	                bra LA955

5761	.a95a						LA918:
5762	.a95a		98		tya		                tya
5763	.a95b		18		clc		                clc
5764	.a95c		69 03		adc #$03	                adc #$03
5765	.a95e		a8		tay		                tay
5766	.a95f		90 03		bcc $a964	                bcc LA922
5767	.a961		68		pla		                pla
5768	.a962		1a		inc a		                inc a
5769	.a963		48		pha		                pha
5770	.a964						LA922:
5771	.a964		5a		phy		                phy
5772	.a965						LA923:
5773	.a965		20 fd ed	jsr $edfd	                jsr LEF1B
5774	.a968		a8		tay		                tay

5776							;-------------------------------------------------------------------------
5777							;
5778							; Print 0-terminated message using address from stack.
5779							;
5780							; entry:
5781							;
5782							; S=[StrL; StrH] - where Str = (address of string)-1
5783							; Y = 0 to print message; otherwise, don't print message
5784							;
5785	.a969						printFollowingMessage:                       ;
5786	.a969		68		pla		                pla
5787	.a96a		85 b8		sta $b8		                sta printMessageAddress+0
5788	.a96c		68		pla		                pla
5789	.a96d		85 b9		sta $b9		                sta printMessageAddress+1
5790	.a96f		5a		phy		                phy                          ;save initial Y
5791	.a970		98		tya		                tya                          ;Z=1 if Y=0
5792	.a971		08		php		                php                          ;save Y=0 state
5793	.a972						fetchNextChar:
5794	.a972		e6 b8		inc $b8		                inc printMessageAddress+0
5795	.a974		d0 02		bne $a978	                bne +
5796	.a976		e6 b9		inc $b9		                inc printMessageAddress+1
5797	.a978						+
5798	.a978		b2 b8		lda ($b8)	                lda (printMessageAddress)   ;fetch next char to print
5799	.a97a		f0 13		beq $a98f	                beq printingFinished        ;branch taken if last char
5800	.a97c		28		plp		                plp                         ;restore Y=0 state
5801	.a97d		08		php		                php                         ;save Y=0 state
5802	.a97e		f0 f2		beq $a972	                beq fetchNextChar ;branch taken if Y=0 - i.e., skip the
5803							                                  ;printing

5805							                ; printMessageAddress is in the $b0-$bf area, so it
5806							                ; needs saving in case there's a *SPOOL going on.
5807	.a980		a4 b8		ldy $b8		                ldy printMessageAddress+0
5808	.a982		5a		phy		                phy
5809	.a983		a4 b9		ldy $b9		                ldy printMessageAddress+1
5810	.a985		20 e3 ff	jsr $ffe3	                jsr OSASCI
5811	.a988		84 b9		sty $b9		                sty printMessageAddress+1
5812	.a98a		7a		ply		                ply
5813	.a98b		84 b8		sty $b8		                sty printMessageAddress+0

5815	.a98d		80 e3		bra $a972	                bra fetchNextChar

5817	.a98f						printingFinished:
5818	.a98f		28		plp		                plp                          ;discard Y=0 state
5819	.a990		e6 b8		inc $b8		                inc printMessageAddress+0
5820	.a992		d0 02		bne $a996	                bne +
5821	.a994		e6 b9		inc $b9		                inc printMessageAddress+1
5822	.a996						+
5823	.a996		7a		ply		                ply                          ;restore initial Y
5824	.a997						LA955:
5825	.a997		6c b8 00	jmp ($00b8)	                jmp (printMessageAddress)

5827	.a99a						alwaysPrintFollowingMessage:
5828	.a99a		a0 01		ldy #$01	                ldy #$01
5829	.a99c		80 cb		bra $a969	                bra printFollowingMessage

5831							;-------------------------------------------------------------------------

5833	.a99e						LA95C:
5834	.a99e		a2 ff		ldx #$ff	                ldx #$FF
5835	.a9a0						LA95E:
5836	.a9a0		e8		inx		                inx
5837	.a9a1		bd d2 03	lda $03d2,x	                lda $03D2,x
5838	.a9a4		d0 07		bne $a9ad	                bne LA96B
5839	.a9a6		8a		txa		                txa
5840	.a9a7		f0 03		beq $a9ac	                beq LA96A
5841	.a9a9		bd b2 03	lda $03b2,x	                lda $03B2,x
5842	.a9ac						LA96A:
5843	.a9ac		60		rts		                rts

5845	.a9ad						LA96B:
5846	.a9ad		20 35 ea	jsr $ea35	                jsr isLetter
5847	.a9b0		5d b2 03	eor $03b2,x	                eor $03B2,x
5848	.a9b3		b0 02		bcs $a9b7	                bcs LA975
5849	.a9b5		29 df		and #$df	                and #$DF
5850	.a9b7						LA975:
5851	.a9b7		f0 e7		beq $a9a0	                beq LA95E
5852	.a9b9						LA977:
5853	.a9b9		60		rts		                rts

5855	.a9ba						LA978:
5856	.a9ba		a5 ba		lda $ba		                lda $BA
5857	.a9bc		f0 21		beq $a9df	                beq LA99D
5858	.a9be		8a		txa		                txa
5859	.a9bf		f0 1e		beq $a9df	                beq LA99D
5860	.a9c1		a9 22		lda #$22	                lda #$22
5861	.a9c3		24 bb		bit $bb		                bit $BB
5862	.a9c5		f0 18		beq $a9df	                beq LA99D
5863							                .if version!=400
5864	.a9c7		20 54 aa	jsr $aa54	                jsr resetACIA
5865							                .endif
5866	.a9ca		a8		tay		                tay
5867	.a9cb		20 69 a9	jsr $a969	                jsr printFollowingMessage
5868	>a9ce		0d				                .byte $0D
5869	>a9cf		07				                .byte $07
5870	>a9d0		52 65 77 69 6e 64 20 74		                .text "Rewind tape"
	>a9d8		61 70 65
5871	>a9db		0d				                .byte $0D
5872	>a9dc		0d				                .byte $0D
5873	>a9dd		00				                .byte $00
5874	.a9de		60		rts		                rts

5876	.a9df						LA99D:
5877	.a9df		20 79 a0	jsr $a079	                jsr LA05D
5878	.a9e2						LA9A0:
5879	.a9e2		a5 c2		lda $c2		                lda $C2
5880	.a9e4		f0 d3		beq $a9b9	                beq LA977
5881	.a9e6		20 c2 a8	jsr $a8c2	                jsr LA880
5882							                .if version!=400
5883	.a9e9		ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5884	.a9ec		f0 f4		beq $a9e2	                beq LA9A0
5885							                .endif
5886							                .if version==400
5888							                .else
5889	.a9ee		20 77 a4	jsr $a477	                jsr LA45D
5890							                .endif
5891	.a9f1		80 ef		bra $a9e2	                bra LA9A0

5893	.a9f3						LA9B1:
5894	.a9f3		20 fd ed	jsr $edfd	                jsr LEF1B
5895	.a9f6		f0 05		beq $a9fd	                beq LA9BB
5896	.a9f8						LA9B6:
5897	.a9f8		a9 07		lda #$07	                lda #$07
5898	.a9fa		20 ee ff	jsr $ffee	                jsr OSWRCH
5899	.a9fd						LA9BB:
5900							                .if includeTubeSupport
5901	.a9fd		ad 7a 02	lda $027a	                lda tubePresence
5902	.aa00		f0 05		beq $aa07	                beq LA9C5                  ; taken if copro not present
5903	.aa02		a9 80		lda #$80	                lda #$80                   ; $80 = CFS/RFS release Tube
5904	.aa04		20 06 04	jsr $0406	                jsr tubeHost.entryPoint
5905							                .endif
5906	.aa07						LA9C5:
5907							                .if version!=400
5908	.aa07		a2 00		ldx #$00	                ldx #$00
5909	.aa09		20 a3 aa	jsr $aaa3	                jsr LAA61
5910	.aa0c						LA9CA:
5911	.aa0c		08		php		                php
5912	.aa0d		78		sei		                sei
5913	.aa0e		ad 82 02	lda $0282	                lda serialULARegister
5914	.aa11		8d 10 fe	sta $fe10	                sta SERPROC+0
5915	.aa14		64 ea		stz $ea		                stz $EA
5916	.aa16		80 01		bra $aa19	                bra LA9D7

5918							;-------------------------------------------------------------------------

5920	.aa18						resetACIAThenRewriteControlRegister:
5921	.aa18		08		php		                php
5922	.aa19						LA9D7:
5923	.aa19		20 54 aa	jsr $aa54	                jsr resetACIA
5924	.aa1c		ad 50 02	lda $0250	                lda aciaControlRegister
5925	.aa1f		4c eb e8	jmp $e8eb	                jmp writeACIAControlRegisterAndCopy

5927							;-------------------------------------------------------------------------

5929	.aa22						LA9E0:
5930	.aa22		28		plp		                plp
5931	.aa23		24 ff		bit $ff		                bit $FF
5932	.aa25		10 18		bpl $aa3f	                bpl LA9FD
5933							                .endif
5934	.aa27		60		rts		                rts

5936	.aa28						LA9E6:
5937	.aa28		a5 e3		lda $e3		                lda $E3
5938	.aa2a		0a		asl a		                asl a
5939	.aa2b		0a		asl a		                asl a
5940	.aa2c		0a		asl a		                asl a
5941	.aa2d		0a		asl a		                asl a
5942	.aa2e		85 bb		sta $bb		                sta $BB
5943							                .if version==400
5945							                .else
5946	.aa30		ad d1 03	lda $03d1	                lda $03D1
5947	.aa33		80 08		bra $aa3d	                bra LA9FB
5948							                .endif

5950	.aa35						LA9F3:
5951	.aa35		a5 e3		lda $e3		                lda $E3
5952	.aa37		29 f0		and #$f0	                and #$F0
5953	.aa39		85 bb		sta $bb		                sta $BB
5954							                .if version!=400
5955	.aa3b		a9 06		lda #$06	                lda #$06
5956	.aa3d						LA9FB:
5957	.aa3d		85 c7		sta $c7		                sta $C7
5958	.aa3f						LA9FD:
5959	.aa3f		58		cli		                cli
5960	.aa40						LA9FE:
5961	.aa40		08		php		                php
5962	.aa41		78		sei		                sei
5963	.aa42						LAA00:
5964	.aa42		2c 4f 02	bit $024f	                bit rs423Busy
5965	.aa45		10 db		bpl $aa22	                bpl LA9E0
5966	.aa47		a5 ea		lda $ea		                lda $EA
5967	.aa49		30 d7		bmi $aa22	                bmi LA9E0
5968	.aa4b		a9 01		lda #$01	                lda #$01
5969	.aa4d		85 ea		sta $ea		                sta $EA
5970	.aa4f		20 54 aa	jsr $aa54	                jsr resetACIA
5971	.aa52		28		plp		                plp
5972							                .endif
5973	.aa53		60		rts		                rts

5975							;-------------------------------------------------------------------------

5977							                .if version!=400
5978	.aa54						resetACIA:
5979	.aa54		a9 03		lda #$03	                lda #ACIA.control.reset
5980	.aa56		80 1b		bra $aa73	                bra writeACIAControlRegister
5981							                .endif

5983							;-------------------------------------------------------------------------

5985	.aa58						LAA16:
5986							                .if version!=400
5987	.aa58		a9 30		lda #$30	                lda #$30
5988	.aa5a		85 ca		sta $ca		                sta $CA
5989	.aa5c		80 13		bra $aa71	                bra LAA2F
5990							                .endif
5991	.aa5e						LAA1C:
5992							                .if version!=400
5993	.aa5e		a9 05		lda #$05	                lda #$05
5994	.aa60		8d 10 fe	sta $fe10	                sta SERPROC+0
5995	.aa63		a2 ff		ldx #$ff	                ldx #$FF
5996	.aa65						LAA23:
5997	.aa65		ca		dex		                dex
5998	.aa66		d0 fd		bne $aa65	                bne LAA23
5999							                .endif
6000	.aa68		64 ca		stz $ca		                stz $CA
6001							                .if version!=400
6002	.aa6a		a9 d0		lda #$d0	                lda #$D0
6003	.aa6c						LAA2A:
6004	.aa6c		a0 85		ldy #$85	                ldy #$85
6005	.aa6e		8c 10 fe	sty $fe10	                sty SERPROC+0
6006	.aa71						LAA2F:
6007	.aa71		05 c6		ora $c6		                ora $C6
6008	.aa73						writeACIAControlRegister:
6009	.aa73		8d 08 fe	sta $fe08	                sta ACIA+0
6010							                .endif
6011	.aa76		60		rts		                rts

6013							;-------------------------------------------------------------------------

6015	.aa77						LAA35:
6016	.aa77		ae c6 03	ldx $03c6	                ldx $03C6
6017	.aa7a		ac c7 03	ldy $03c7	                ldy $03C7
6018	.aa7d		e8		inx		                inx
6019	.aa7e		86 b4		stx $b4		                stx $B4
6020	.aa80		d0 01		bne $aa83	                bne LAA41
6021	.aa82		c8		iny		                iny
6022	.aa83						LAA41:
6023	.aa83		84 b5		sty $b5		                sty $B5
6024	.aa85		60		rts		                rts

6026	.aa86						LAA44:
6027	.aa86		64 c0		stz $c0		                stz $C0
6028	.aa88						LAA46:
6029	.aa88		a0 00		ldy #$00	                ldy #$00
6030	.aa8a		64 be		stz $be		                stz $BE
6031	.aa8c		64 bf		stz $bf		                stz $BF
6032	.aa8e		60		rts		                rts

6034	.aa8f						LAA4D:
6035	.aa8f		a0 ff		ldy #$ff	                ldy #$FF
6036	.aa91						LAA4F:
6037	.aa91		c8		iny		                iny
6038	.aa92		e8		inx		                inx
6039	.aa93		bd 00 03	lda $0300,x	                lda $0300,x
6040	.aa96		99 d2 03	sta $03d2,y	                sta $03D2,y
6041	.aa99		d0 f6		bne $aa91	                bne LAA4F
6042	.aa9b		60		rts		                rts

6044							                .if version!=400
6045	.aa9c						LAA5A:
6046	.aa9c		a0 00		ldy #$00	                ldy #$00
6047	.aa9e						LAA5C:
6048	.aa9e		58		cli		                cli
6049	.aa9f		a2 01		ldx #$01	                ldx #$01
6050	.aaa1		84 c3		sty $c3		                sty $C3
6051	.aaa3						LAA61:
6052	.aaa3		a9 89		lda #$89	                lda #$89
6053	.aaa5		a4 c3		ldy $c3		                ldy $C3
6054	.aaa7		4c f4 ff	jmp $fff4	                jmp OSBYTE
6055							                .endif

6057							; Check if TAPE/ROM channel is open
6058							; ---------------------------------
6059							; Y=handle to check, A=status mask to use
6060	.aaaa						LAA68:
6061	.aaaa		5a		phy		                phy
6062	.aaab		20 cf aa	jsr $aacf	                jsr LAA8D
6063	.aaae		7a		ply		                ply
6064							                .if includeTubeSupport
6065	.aaaf		b0 5a		bcs $ab0b	                bcs rtsAAC9                    ; Channel open, exit
6068							                .endif
6069	.aab1		cc 57 02	cpy $0257	                cpy spoolFileHandle                    ; Not SPOOL handle
6070	.aab4		d0 05		bne $aabb	                bne LAA79
6071	.aab6		9c 57 02	stz $0257	                stz spoolFileHandle                    ; Clear the SPOOL handle
6072	.aab9		80 08		bra $aac3	                bra LAA81
6073	.aabb						LAA79:
6074	.aabb		cc 56 02	cpy $0256	                cpy execFileHandle                    ; Not EXEC handle
6075	.aabe		d0 03		bne $aac3	                bne LAA81
6076	.aac0		9c 56 02	stz $0256	                stz execFileHandle                    ; Clear the EXEC handle
6077	.aac3						LAA81:
6078	.aac3		20 2f ab	jsr $ab2f	                jsr doFollowingError                    ; Generate error
6079	>aac6		de				                .byte $DE
6080	>aac7		43 68 61 6e 6e 65 6c		                .text "Channel"
6081	.aace		00		brk #		                brk

6083	.aacf						LAA8D:
6084	.aacf		48		pha		                pha                          ; Toggle channel with CFS/RFS switch
6085	.aad0		98		tya		                tya
6086							                .if version==400
6088							                .else
6089	.aad1		4d 47 02	eor $0247	                eor cfsRFSFSSwitch
6090							                .endif
6091	.aad4		a8		tay		                tay                          ; If CFS=unchanged, if RFS 1/2/3->3/0/1
6092	.aad5		68		pla		                pla
6093	.aad6		25 e2		and $e2		                and $E2                      ; Mask with open channels bitmask
6094	.aad8		4a		lsr a		                lsr a                        ; Move 'input open if tested' into Carry
6095	.aad9		88		dey		                dey                          ; Exit if testing CFS#1 or RFS#3
6096	.aada		f0 05		beq $aae1	                beq rtsAA9F
6097	.aadc		4a		lsr a		                lsr a                        ; Move 'output open if tested' into Carry
6098	.aadd		88		dey		                dey                          ; Exit if testing CFS#2
6099	.aade		f0 01		beq $aae1	                beq rtsAA9F
6100	.aae0		18		clc		                clc                          ; Otherwise, Carry=Not Open
6101	.aae1						rtsAA9F:
6102	.aae1		60		rts		                rts

6104							                .if version!=400
6105	.aae2						LAAA0:
6106	.aae2		a9 10		lda #$10	                lda #$10
6107	.aae4		80 86		bra $aa6c	                bra LAA2A
6108							                .endif

6110							                .if includeTubeSupport
6111	.aae6						initiateCFSRFSHostToParasiteTransfer:
6112	.aae6		a9 01		lda #$01	                lda #tubeReasonMultiByteHostToParasite
6113	.aae8						LAAA6:
6114	.aae8		20 fe aa	jsr $aafe	                jsr isTubeAddress
6115	.aaeb		f0 1e		beq $ab0b	                beq rtsAAC9
6116	.aaed		8a		txa		                txa                          ; restore transfer type
6117	.aaee		a2 b0		ldx #$b0	                ldx #$B0
6118	.aaf0		a0 00		ldy #$00	                ldy #$00
6119	.aaf2						initiateCFSRFSTubeTransfer:
6120	.aaf2		48		pha		                pha                         ; save transfer type
6121	.aaf3		a9 c0		lda #$c0	                lda #$C0                    ; $c0 = CFS/RFS claim Tube
6122	.aaf5						-
6123	.aaf5		20 06 04	jsr $0406	                jsr tubeHost.entryPoint
6124	.aaf8		90 fb		bcc $aaf5	                bcc -
6125	.aafa		68		pla		                pla                          ; restore transfer type
6126	.aafb		4c 06 04	jmp $0406	                jmp tubeHost.entryPoint      ; initiate transfer

6128	.aafe						isTubeAddress:
6129	.aafe		aa		tax		                tax
6130	.aaff		a5 b2		lda $b2		                lda $B2
6131	.ab01		25 b3		and $b3		                and $B3                 ; $ff if address is $FFFFxxxx
6132	.ab03		1a		inc a		                inc a                   ; $00 if address is $FFFFxxxx
6133	.ab04		f0 05		beq $ab0b	                beq rtsAAC9               ; taken if not Tube address
6134	.ab06		ad 7a 02	lda $027a	                lda tubePresence
6135	.ab09		29 80		and #$80	                and #$80            ; $80 if $FFFFxxxx and Tube active
6136	.ab0b						rtsAAC9:
6137	.ab0b		60		rts		                rts
6138							                .endif

6140	.ab0c						LAACA:
6141	.ab0c		a0 05		ldy #$05	                ldy #$05
6142	.ab0e						LAACC:
6143	.ab0e		b1 cc		lda ($cc),y	                lda ($CC),y
6144	.ab10		d0 07		bne $ab19	                bne LAAD7
6145	.ab12		c8		iny		                iny
6146	.ab13		c0 08		cpy #$08	                cpy #$08
6147	.ab15		90 f7		bcc $ab0e	                bcc LAACC
6148	.ab17						LAAD5:
6149	.ab17		b1 cc		lda ($cc),y	                lda ($CC),y
6150	.ab19						LAAD7:
6151	.ab19		3a		dec a		                dec a
6152	.ab1a		91 cc		sta ($cc),y	                sta ($CC),y
6153	.ab1c		88		dey		                dey
6154	.ab1d		c0 05		cpy #$05	                cpy #$05
6155	.ab1f		b0 f6		bcs $ab17	                bcs LAAD5
6156	.ab21		60		rts		                rts

6158	.ab22						LAAE0:
6159	.ab22		a0 08		ldy #$08	                ldy #$08
6160	.ab24		a9 00		lda #$00	                lda #$00
6161	.ab26						LAAE4:
6162	.ab26		11 cc		ora ($cc),y	                ora ($CC),y
6163	.ab28		88		dey		                dey
6164	.ab29		c0 05		cpy #$05	                cpy #$05
6165	.ab2b		b0 f9		bcs $ab26	                bcs LAAE4
6166	.ab2d		aa		tax		                tax
6167	.ab2e		60		rts		                rts

6169	.ab2f						doFollowingError:
6170	.ab2f		78		sei		                sei
6171	.ab30		68		pla		                pla
6172	.ab31		85 fa		sta $fa		                sta SEIWKA+0
6173	.ab33		68		pla		                pla
6174	.ab34		85 fb		sta $fb		                sta SEIWKA+1
6175	.ab36		9c 00 01	stz $0100	                stz $0100
6176	.ab39		a0 00		ldy #$00	                ldy #$00
6177	.ab3b						-
6178	.ab3b		c8		iny		                iny
6179	.ab3c		b1 fa		lda ($fa),y	                lda (SEIWKA),y
6180	.ab3e		99 00 01	sta $0100,y	                sta $0100,y
6181	.ab41		d0 f8		bne $ab3b	                bne -
6182	.ab43		4c 00 01	jmp $0100	                jmp $0100


6185							                .if version!=350
6187							                .endif

6189							                .if includeTubeSupport
6190							;-------------------------------------------------------------------------
6191							;
6192							; Tube host code
6193							;
6194							; See http://mdfs.net/Software/Tube/M128/Host320.lst
6195							;
6196							; I mostly just copied JGH's comments here.

6198	.ab46						tubeHost: .block          ;tube code

6200	.ab46						brkHandler: .block
6201							                .logical tubeBrkHandlerAddr
6202	.ab46	0016	a9 ff		lda #$ff	                lda #$FF
6203	.ab48	0018	20 73 06	jsr $0673	                jsr sendR4       ;send $ff via R4 to interrupt copro
6204	.ab4b	001b	ad e3 fe	lda $fee3	                lda tube.data2   ;get ACK byte from copro
6205	.ab4e	001e	a9 00		lda #$00	                lda #$00
6206	.ab50	0020	20 68 06	jsr $0668	                jsr sendR2A       ;send $00 via R2 to specify ERROR
6207	.ab53	0023	a8		tay		                tay               ;Y=0
6208	.ab54	0024	b1 fd		lda ($fd),y	                lda ($FD),y       ;get error number
6209	.ab56	0026	20 68 06	jsr $0668	                jsr sendR2A       ;send error number via R2
6210	.ab59	0029					-
6211	.ab59	0029	c8		iny		                iny             ;next char
6212	.ab5a	002a	b1 fd		lda ($fd),y	                lda ($FD),y     ;fetch error string char
6213	.ab5c	002c	20 68 06	jsr $0668	                jsr sendR2A     ;send via R2
6214	.ab5f	002f	aa		tax		                tax             ;set N/Z as per error string char
6215	.ab60	0030	d0 f7		bne $0029	                bne -           ;repeat until terminating $00 sent
6216	.ab62	0032					idleStartup:
6217	.ab62	0032	a2 ff		ldx #$ff	                ldx #$FF
6218	.ab64	0034	9a		txs		                txs             ;clear stack
6219	.ab65	0035	58		cli		                cli
6220	.ab66	0036					idleLoop:
6221	.ab66	0036	2c e0 fe	bit $fee0	                bit tube.status1 ;is there a char in R1?
6222	.ab69	0039	10 06		bpl $0041	                bpl LAB58        ;branch taken if no char in R1
6223	.ab6b	003b					handleOSWRCH:
6224	.ab6b	003b	ad e1 fe	lda $fee1	                lda tube.data1  ;get char from R1
6225	.ab6e	003e	20 ee ff	jsr $ffee	                jsr OSWRCH      ;pass to OSWRCH
6226	.ab71	0041					LAB58:
6227	.ab71	0041	2c e2 fe	bit $fee2	                bit tube.status2 ;is there a command in R2?
6228	.ab74	0044	10 f0		bpl $0036	                bpl idleLoop     ;branch taken if no command in R2
6229	.ab76	0046	2c e0 fe	bit $fee0	                bit tube.status1 ;is there a char in R1?
6230	.ab79	0049	30 f0		bmi $003b	                bmi handleOSWRCH ;branch taken if char in R1
6231	.ab7b	004b	ae e3 fe	ldx $fee3	                ldx tube.data2   ;get command from R2
6232	.ab7e	004e	86 51		stx $51		                stx callCommandRoutine+1 ;use as index into command
6233							                                         ;table
6234	.ab80	0050					callCommandRoutine:
6235							                ; not sure why this can't be jmp
6236							                ; (tubeHost.commandRoutines,x)? - and then the table
6237							                ; wouldn't have to be page-aligned.
6238	.ab80	0050	6c 00 05	jmp ($0500)	                jmp (tubeHost.commandRoutines)

6240							                ; ???
6241	>ab83	0053	00 80 00 00			                .dword $8000
6242							                .here
6243							                .endblock

6245							; Slightly ugly aliases for inner symbol :(
6246	=$32						idleStartup=brkHandler.idleStartup
6247	=$36						idleLoop=brkHandler.idleLoop

6249	.ab87						codePage0:
6250							                .logical tubeHostAddr
6251	.ab87	0400					copyLanguage:
6252	.ab87	0400	4c c1 04	jmp $04c1	                jmp LAC30

6254	.ab8a	0403					copyEscapeStatus:
6255	.ab8a	0403	4c 7c 06	jmp $067c	                jmp LADDA

6257							; Tube transfer/claim/release
6258	.ab8d	0406					entryPoint:
6259	.ab8d	0406	c9 80		cmp #$80	                cmp #$80
6260	.ab8f	0408	90 29		bcc $0433	                bcc dataTransfer
6261	.ab91	040a	c9 c0		cmp #$c0	                cmp #$C0
6262	.ab93	040c	b0 18		bcs $0426	                bcs claim
6263	.ab95	040e	09 40		ora #$40	                ora #$40
6264	.ab97	0410	c5 15		cmp $15		                cmp $15
6265	.ab99	0412	d0 1e		bne $0432	                bne done
6266	.ab9b	0414					release:
6267	.ab9b	0414	08		php		                php
6268	.ab9c	0415	78		sei		                sei
6269	.ab9d	0416	a9 05		lda #$05	                lda #$05
6270	.ab9f	0418	20 73 06	jsr $0673	                jsr sendR4
6271	.aba2	041b	20 71 06	jsr $0671	                jsr sendR4TubeClaimantID
6272	.aba5	041e	28		plp		                plp
6273	.aba6	041f					resetTubeClaim:
6274	.aba6	041f	a9 80		lda #$80	                lda #$80
6275	.aba8	0421	85 15		sta $15		                sta tubeClaimantID
6276	.abaa	0423	85 14		sta $14		                sta tubeNotClaimed
6277	.abac	0425	60		rts		                rts

6279	.abad	0426					claim:
6280	.abad	0426	06 14		asl $14		                asl tubeNotClaimed    ;test if Tube free
6281	.abaf	0428	b0 06		bcs $0430	                bcs claim2         ;taken if Tube free - with C=1 and
6282							                                   ;tube marked as claimed
6283	.abb1	042a	c5 15		cmp $15		                cmp tubeClaimantID
6284	.abb3	042c	f0 04		beq $0432	                beq done       ;taken with C=1 if already claimed
6285	.abb5	042e	18		clc		                clc            ;signal claim failure
6286	.abb6	042f	60		rts		                rts

6288	.abb7	0430					claim2:
6289	.abb7	0430	85 15		sta $15		                sta tubeClaimantID ; store claimant ID
6290	.abb9	0432					done:
6291	.abb9	0432	60		rts		                rts

6293	.abba	0433					dataTransfer:
6294	.abba	0433	08		php		                php
6295	.abbb	0434	78		sei		                sei
6296	.abbc	0435	84 13		sty $13		                sty tubeTransferAddr+1
6297	.abbe	0437	86 12		stx $12		                stx tubeTransferAddr+0
6298	.abc0	0439	20 73 06	jsr $0673	                jsr sendR4      ;send reason code to interrupt copro
6299	.abc3	043c	aa		tax		                tax             ;save reason code
6300	.abc4	043d	a0 03		ldy #$03	                ldy #$03        ;will send 4 bytes
6301	.abc6	043f	20 71 06	jsr $0671	                jsr sendR4TubeClaimantID ;send Tube claimant ID
6302	.abc9	0442					-
6303	.abc9	0442	b1 12		lda ($12),y	                lda (tubeTransferAddr),y
6304	.abcb	0444	20 73 06	jsr $0673	                jsr sendR4
6305	.abce	0447	88		dey		                dey
6306	.abcf	0448	10 f8		bpl $0442	                bpl -

6308							                ; disable R3 FIFO, disable R3 NMI
6309	.abd1	044a	a0 18		ldy #$18	                ldy #tube.status1.V|tube.status1.M
6310	.abd3	044c	8c e0 fe	sty $fee0	                sty tube.status1

6312							                ; disable/enable other per-transfer type flags as
6313							                ; appropriate.
6314	.abd6	044f	bd 18 05	lda $0518,x	                lda dataTransferFlags,x
6315	.abd9	0452	8d e0 fe	sta $fee0	                sta tube.status1 ;STPVMJIQ

6317	.abdc	0455	4a		lsr a		                lsr a           ;0STPVMJI Q
6318	.abdd	0456	4a		lsr a		                lsr a           ;00STPVMJ I
6319	.abde	0457	90 06		bcc $045f	                bcc +           ;branch taken if CoPro->I/O transfer

6321							                ; Read R3 twice to delay and empty FIFO
6322	.abe0	0459	2c e5 fe	bit $fee5	                bit tube.data3
6323	.abe3	045c	2c e5 fe	bit $fee5	                bit tube.data3
6324	.abe6	045f					+
6325	.abe6	045f	20 73 06	jsr $0673	                jsr sendR4      ;send value to synchronize
6326	.abe9	0462					-
6327	.abe9	0462	2c e6 fe	bit $fee6	                bit tube.status4
6328	.abec	0465	50 fb		bvc $0462	                bvc -
6329	.abee	0467	b0 0d		bcs $0476	                bcs LABE4       ;branch taken if I/O->CoPro transfer
6330	.abf0	0469	e0 04		cpx #$04	                cpx #$04        ;$04 = execute in CoPro
6331	.abf2	046b	d0 11		bne $047e	                bne LABEC       ;taken if not execute in CoPro
6332	.abf4	046d					LABDB:
6333	.abf4	046d	20 14 04	jsr $0414	                jsr release
6334	.abf7	0470	20 68 06	jsr $0668	                jsr sendR2A
6335	.abfa	0473	4c 32 00	jmp $0032	                jmp idleStartup

6337	.abfd	0476					LABE4:
6338	.abfd	0476	4a		lsr a		                lsr a            ;000STPVM J
6339	.abfe	0477	90 05		bcc $047e	                bcc LABEC        ;branch taken if J=0
6340	.ac00	0479	a0 88		ldy #$88	                ldy #tube.status1.S|tube.status1.M
6341	.ac02	047b	8c e0 fe	sty $fee0	                sty tube.status1
6342	.ac05	047e					LABEC:
6343	.ac05	047e	28		plp		                plp
6344	.ac06	047f	60		rts		                rts

6346	.ac07	0480					LABEE:
6347	.ac07	0480	ae 8d 02	ldx $028d	                ldx lastBREAKType            ;get last BREAK type
6348	.ac0a	0483	f0 e8		beq $046d	                beq LABDB   ;if soft break, release Tube, send $80 via
6349							                            ;R2, and enter idle loop.

6351							; The current language is not copied across the Tube on soft Break,
6352							; only on Power-On Break and Hard Break, or when entered explicitly
6353							; with OSBYTE 142.

6355	.ac0c	0485					enterNewLanguage: .proc
6356	.ac0c	0485	a9 ff		lda #$ff	                lda #$FF
6357	.ac0e	0487	20 06 04	jsr $0406	                jsr tubeHost.entryPoint ;claim with ID=$3f
6358	.ac11	048a	90 f9		bcc $0485	                bcc enterNewLanguage    ;repeat until claimed
6359	.ac13	048c	20 c8 04	jsr $04c8	                jsr getLanguageParasiteAddr ;sort out addresses

6361	.ac16	048f					transferPage:
6362							                .if version==350
6363	.ac16	048f	20 fa f9	jsr $f9fa	                jsr relocateNextLanguageROMPage
6364							                .endif
6365	.ac19	0492	08		php		                php
6366	.ac1a	0493	78		sei		                sei

6368							                ; initiate I/O->CoPro 256 bytes, then transfer the
6369							                ; next 256 bytes of the language ROM.
6370	.ac1b	0494	a9 07		lda #$07	                lda #$07
6371	.ac1d	0496	20 ba 04	jsr $04ba	                jsr doTube

6373	.ac20	0499	a0 00		ldy #$00	                ldy #$00
6374							                .if version==350
6375	.ac22	049b					transferPageLoop:
6376	.ac22	049b	b9 00 07	lda $0700,y	                lda tubeRelocationBuffer,y
6377	.ac25	049e	8d e5 fe	sta $fee5	                sta tube.data3
6378	.ac28	04a1	48		pha		                pha
6379	.ac29	04a2	68		pla		                pla
6388							                .endif
6389	.ac2a	04a3	c8		iny		                iny
6390	.ac2b	04a4	d0 f5		bne $049b	                bne transferPageLoop
6391	.ac2d	04a6	28		plp		                plp

6393							                ; advance to next dest page.
6394	.ac2e	04a7	e6 54		inc $54		                inc tubeLanguageParasiteAddr+1
6395	.ac30	04a9	d0 06		bne $04b1	                bne +
6396	.ac32	04ab	e6 55		inc $55		                inc tubeLanguageParasiteAddr+2
6397	.ac34	04ad	d0 02		bne $04b1	                bne +
6398	.ac36	04af	e6 56		inc $56		                inc tubeLanguageParasiteAddr+3
6399	.ac38	04b1					+

6401							                .if version!=350
6403							                .endif
6404	.ac38	04b1	24 01		bit $01		                bit tubeLanguageHostAddr+1
6405	.ac3a	04b3	50 da		bvc $048f	                bvc transferPage ;branch taken if source page $c0 not
6406							                                 ;reached yet

6408							                ; copy done - execute language in parasite
6409							                .if version==350
6410	.ac3c	04b5	20 02 fb	jsr $fb02	                jsr getLanguageParasiteAddrAndAssumeRelocatable
6413							                .endif
6414	.ac3f	04b8	a9 04		lda #$04	                lda #$04        ;execute in copro

6416							                ; call Tube entry point with whatever reason code,
6417							                ; supplying language parasite address as the parasite
6418							                ; address.
6419	.ac41	04ba					doTube:
6420	.ac41	04ba	a0 00		ldy #$00	                ldy #>tubeLanguageParasiteAddr
6421	.ac43	04bc	a2 53		ldx #$53	                ldx #<tubeLanguageParasiteAddr
6422	.ac45	04be	4c 06 04	jmp $0406	                jmp tubeHost.entryPoint
6423							                .pend

6425	.ac48	04c1					LAC30:
6426	.ac48	04c1	58		cli		                cli
6427	.ac49	04c2	b0 c1		bcs $0485	                bcs enterNewLanguage
6428	.ac4b	04c4	d0 ba		bne $0480	                bne LABEE
6429	.ac4d	04c6	80 62		bra $052a	                bra LAC8F

6431	.ac4f	04c8					getLanguageParasiteAddr: .proc
6432	.ac4f	04c8	a9 80		lda #$80	                lda #$80
6433	.ac51	04ca	85 54		sta $54		                sta tubeLanguageParasiteAddr+1 ;$xxxx80xx
6434	.ac53	04cc	85 01		sta $01		                sta tubeLanguageHostAddr+1     ;$80xx
6435	.ac55	04ce	a9 20		lda #$20	                lda #$20
6436	.ac57	04d0	2d 06 80	and $8006	                and $8006  ;test parasite address flag
6437	.ac5a	04d3	a8		tay		                tay        ;Y=0 if $8000, Y=$20 if parasite address
6438							                .if version==350
6439	.ac5b	04d4	8c 53 00	sty $0053	                sty @w tubeLanguageParasiteAddr+0
6442							                .endif
6443	.ac5e	04d7	f0 19		beq $04f2	                beq LAC60       ;branch taken if good to go with A=0
6444							                                ;and Y=0

6446	.ac60	04d9	ae 07 80	ldx $8007	                ldx $8007       ;get copyright offset
6447							                ; skip copyright message
6448	.ac63	04dc					-
6449	.ac63	04dc	e8		inx		                inx
6450	.ac64	04dd	bd 00 80	lda $8000,x	                lda $8000,x
6451	.ac67	04e0	d0 fa		bne $04dc	                bne -

6453	.ac69	04e2	bd 01 80	lda $8001,x	                lda $8000+1,x
6454	.ac6c	04e5	85 53		sta $53		                sta tubeLanguageParasiteAddr+0
6455	.ac6e	04e7	bd 02 80	lda $8002,x	                lda $8000+2,x
6456	.ac71	04ea	85 54		sta $54		                sta tubeLanguageParasiteAddr+1
6457	.ac73	04ec	bc 03 80	ldy $8003,x	                ldy $8000+3,x
6458	.ac76	04ef	bd 04 80	lda $8004,x	                lda $8000+4,x
6459	.ac79	04f2					LAC60:
6460							                ; Y = parasite address bits 16-23
6461							                ; A = parasite address bits 24-31
6462							                .if version==350
6463	.ac79	04f2	4c 22 fa	jmp $fa22	                jmp checkForTubeRelocationBitmap
6469							                .endif
6470							                .pend
6471							                .here

6473	.ac7c						codePages12:
6474							                .logical tubeHostAddr+256

6476							; names of the indexes here come from app note 004
6477	.ac7c	0500					commandRoutines:
6478							                .cerror (*&$ff)!=0,"commandRoutines must be paged aligned"
6479	>ac7c	0500	35 05				                .word doRDCH    ;RDCHNO = $00
6480	>ac7e	0502	89 05				                .word doCLI     ;CLINO = $02
6481	>ac80	0504	e0 05				                .word doSBYT    ;SBYTNO = $04
6482	>ac82	0506	f1 05				                .word doBYTE    ;BYTENO = $06
6483	>ac84	0508	0d 06				                .word doWORD    ;WORDNO = $08
6484	>ac86	050a	3c 06				                .word doRDLN    ;RDLNNO = $0a
6485	>ac88	050c	59 05				                .word doARGS     ;ARGSNO = $0c
6486	>ac8a	050e	2c 05				                .word doBGET     ;BGETNO = $0e
6487	>ac8c	0510	20 05				                .word doBPUT     ;BPUTNO = $10
6488	>ac8e	0512	3f 05				                .word doFIND     ;FINDNO = $12
6489	>ac90	0514	b4 05				                .word doFILE    ;FILENO = $14
6490	>ac92	0516	9b 05				                .word doGBPB     ;GBPBNO = $16

6492							                ; Tube data transfer flags
6493	.ac94	0518					dataTransferFlags:
6494							                ; 0 - CoPro->I/O bytes
6495							                ;
6496							                ; Enable: PIRQ from R3, PIRQ from R1
6497	>ac94	0518	86				                .byte tube.status1.S|tube.status1.J|tube.status1.I

6499							                ; 1 - I/O->CoPro bytes
6500							                ;
6501							                ; Enable: PNMI from R3
6502	>ac95	0519	88				                .byte tube.status1.S|tube.status1.M

6504							                ; 2 - CoPro->I/O words
6505							                ;
6506							                ; Enable: 2-byte R3, PIRQ from R2, PIRQ from R1
6507	>ac96	051a	96				                .byte tube.status1.S|tube.status1.V|tube.status1.J|tube.status1.I

6509							                ; 3 - I/O->CoPro words
6510							                ;
6511							                ; Enable: 2-byte R3, PNMI from R3
6512	>ac97	051b	98				                .byte tube.status1.S|tube.status1.V|tube.status1.M

6514							                ; 4 - Execute in CoPro
6515							                ;
6516							                ; Disable: 2-byte R3, PNMI from R3
6517	>ac98	051c	18				                .byte tube.status1.V|tube.status1.M

6519							                ; 5 - Reserved
6520							                ;
6521							                ; Disable: 2-byte R3, PNMI from R3
6522	>ac99	051d	18				                .byte tube.status1.V|tube.status1.M

6524							                ; 6 - CoPro->I/O 256 bytes
6525							                ;
6526							                ; Enable: PIRQ from R1
6527	>ac9a	051e	82				                .byte tube.status1.S|tube.status1.I

6529							                ; 7 - I/O->CoPro 256 bytes
6530							                ;
6531							                ; Disable: 2-byte R3, PNMI from R3
6532	>ac9b	051f	18				                .byte tube.status1.V|tube.status1.M

6534	.ac9c	0520					doBPUT:
6535	.ac9c	0520	20 a8 06	jsr $06a8	                jsr recvR2      ;Receive file handle
6536	.ac9f	0523	a8		tay		                tay             ;Y = file handle
6537	.aca0	0524	20 a8 06	jsr $06a8	                jsr recvR2      ;Receive byte
6538	.aca3	0527	20 d4 ff	jsr $ffd4	                jsr OSBPUT      ;Do OSBPUT
6539	.aca6	052a					LAC8F:
6540	.aca6	052a	80 63		bra $058f	                bra sendR27FThenGoIdle

6542	.aca8	052c					doBGET:
6543	.aca8	052c	20 a8 06	jsr $06a8	                jsr recvR2      ;Receive file handle
6544	.acab	052f	a8		tay		                tay             ;Y = file handle
6545	.acac	0530	20 d7 ff	jsr $ffd7	                jsr OSBGET      ;Do OSBGET
6546	.acaf	0533					LAC98:
6547	.acaf	0533	80 03		bra $0538	                bra sendR2CAThenGoIdle

6549	.acb1	0535					doRDCH:
6550	.acb1	0535	20 e0 ff	jsr $ffe0	                jsr OSRDCH      ;Do OSRDCH
6551	.acb4	0538					sendR2CAThenGoIdle:
6552	.acb4	0538	6a		ror a		                ror a           ;set A bit 7 as per carry
6553	.acb5	0539	20 68 06	jsr $0668	                jsr sendR2A     ;send via R2
6554	.acb8	053c	2a		rol a		                rol a           ;restore A
6555	.acb9	053d	80 52		bra $0591	                bra sendR2AThenGoIdle

6557	.acbb	053f					doFIND: .proc
6558	.acbb	053f	20 a8 06	jsr $06a8	                jsr recvR2            ;Receive reason code
6559	.acbe	0542	f0 0a		beq $054e	                beq close             ;taken if A=$00 - CLOSE#
6560	.acc0	0544	48		pha		                pha                   ;save reason code
6561	.acc1	0545	20 75 05	jsr $0575	                jsr recvR2String      ;receive file name
6562	.acc4	0548	68		pla		                pla                   ;restore reason code
6563	.acc5	0549	20 ce ff	jsr $ffce	                jsr OSFIND            ;call OSFIND
6564	.acc8	054c	80 43		bra $0591	                bra sendR2AThenGoIdle

6566	.acca	054e					close:
6567	.acca	054e	20 a8 06	jsr $06a8	                jsr recvR2      ;Receive file handle
6568	.accd	0551	a8		tay		                tay             ;Y = file handle
6569	.acce	0552	a9 00		lda #$00	                lda #$00        ;A = $00 - CLOSE#
6570	.acd0	0554	20 ce ff	jsr $ffce	                jsr OSFIND      ;call OSFIND
6571	.acd3	0557	80 36		bra $058f	                bra sendR27FThenGoIdle
6572							                .pend

6574							;-------------------------------------------------------------------------
6575							;
6576							; Handle a Tube OSARGS request.
6577							;
6578							; [Tube p24]
6579							;
6580	.acd5	0559					doARGS:
6581	.acd5	0559	20 a8 06	jsr $06a8	                jsr recvR2                   ;receive file handle
6582	.acd8	055c	a8		tay		                tay                          ;Y = file handle
6583	.acd9	055d	a2 04		ldx #$04	                ldx #$04
6584	.acdb	055f	20 9a 06	jsr $069a	                jsr recvR2N ;receive 4 bytes OSARGS data, + operation code
6585	.acde	0562	20 da ff	jsr $ffda	                jsr OSARGS  ;call OSARGS
6586	.ace1	0565	20 68 06	jsr $0668	                jsr sendR2A ;send OSARGS result

6588							                ; send 4 bytes OSARGS data
6589	.ace4	0568	a2 03		ldx #$03	                ldx #$03
6590	.ace6	056a					-
6591							                .if version==350
6592	.ace6	056a	bd 00 00	lda $0000,x	                lda @w $00,x
6595							                .endif
6596	.ace9	056d	20 68 06	jsr $0668	                jsr sendR2A
6597	.acec	0570	ca		dex		                dex
6598	.aced	0571	10 f7		bpl $056a	                bpl -

6600	.acef	0573	80 24		bra $0599	                bra goIdle_0

6602							;-------------------------------------------------------------------------
6603							;
6604							; Receive a CR-terminated string over the Tube via R2.
6605							;
6606							; exit:
6607							; YX = pointer to received string (here, always $0700)
6608							;
6609	.acf1	0575					recvR2String: .proc
6610	.acf1	0575	a2 00		ldx #$00	                ldx #$00
6611	.acf3	0577	a0 00		ldy #$00	                ldy #$00        ;index
6612	.acf5	0579					-
6613	.acf5	0579	20 a8 06	jsr $06a8	                jsr recvR2      ;get next string char
6614	.acf8	057c	99 00 07	sta $0700,y	                sta tubeStringBuffer,y     ;store in string buffer
6615	.acfb	057f	c8		iny		                iny
6616	.acfc	0580	f0 04		beq $0586	                beq +           ;taken if too many bytes received
6617	.acfe	0582	c9 0d		cmp #$0d	                cmp #$0D
6618	.ad00	0584	d0 f3		bne $0579	                bne -           ;taken if end of string data not reached
6619	.ad02	0586					+
6620	.ad02	0586	a0 07		ldy #$07	                ldy #>tubeStringBuffer
6621							                .cerror (<tubeStringBuffer)!=0,"tubeStringBuffer must be page-aligned"
6622	.ad04	0588	60		rts		                rts
6623							                .pend

6625							;-------------------------------------------------------------------------
6626							;
6627							; Handle a Tube OSCLI request.
6628							;
6629							; [Tube p22]
6630							;
6631	.ad05	0589					doCLI:
6632	.ad05	0589	20 75 05	jsr $0575	                jsr recvR2String
6633	.ad08	058c	20 f7 ff	jsr $fff7	                jsr OSCLI
6634	.ad0b	058f					sendR27FThenGoIdle:
6635	.ad0b	058f	a9 7f		lda #$7f	                lda #$7F
6636	.ad0d	0591					sendR2AThenGoIdle:
6637	.ad0d	0591					-
6638	.ad0d	0591	2c e2 fe	bit $fee2	                bit tube.status2
6639	.ad10	0594	50 fb		bvc $0591	                bvc -
6640	.ad12	0596	8d e3 fe	sta $fee3	                sta tube.data2
6641	.ad15	0599					goIdle_0:
6642	.ad15	0599	80 53		bra $05ee	                bra goIdle_1

6644							;-------------------------------------------------------------------------
6645							;
6646							; Handle a Tube OSGBPB request.
6647							;
6648							; [Tube p25]
6649							;
6650	.ad17	059b					doGBPB:
6651	.ad17	059b	a2 0d		ldx #$0d	                ldx #size(OSGBPBParameterBlock)
6652							                .cerror tubeOSGBPBParameterBlock!=0,"Tube OSGBPB parameter block must be at $0000"
6653	.ad19	059d	20 9a 06	jsr $069a	                jsr recvR2N     ;receive parameter block + reason code
6654	.ad1c	05a0	a0 00		ldy #$00	                ldy #>tubeOSGBPBParameterBlock
6655	.ad1e	05a2	20 d1 ff	jsr $ffd1	                jsr OSGBPB      ;call OSGBPB
6656	.ad21	05a5	48		pha		                pha             ;save OSGBPB A result

6658							                ; Send updated OSGBPB parameter block.
6659	.ad22	05a6	a2 0c		ldx #$0c	                ldx #size(OSGBPBParameterBlock)-1
6660	.ad24	05a8					-
6661							                .if version==350
6662	.ad24	05a8	bd 00 00	lda $0000,x	                lda @w tubeOSGBPBParameterBlock,x
6665							                .endif
6666	.ad27	05ab	20 68 06	jsr $0668	                jsr sendR2A
6667	.ad2a	05ae	ca		dex		                dex
6668	.ad2b	05af	10 f7		bpl $05a8	                bpl -
6669	.ad2d	05b1	68		pla		                pla                          ;restore OSGBPB A result
6670	.ad2e	05b2	80 84		bra $0538	                bra sendR2CAThenGoIdle       ;send OSGBPB full result

6672							;-------------------------------------------------------------------------
6673							;
6674							; Handle a Tube OSFILE request.
6675							;
6676							; [Tube p24]
6677							;
6678	.ad30	05b4					doFILE: .proc
6679							                ; receive non-name part of OSFILE parameter block
6680	.ad30	05b4	a2 10		ldx #$10	                ldx #size(OSFILEParameterBlock)-2
6681	.ad32	05b6					-
6682	.ad32	05b6	20 a8 06	jsr $06a8	                jsr recvR2
6683							                .if version==350
6684	.ad35	05b9	9d 01 00	sta $0001,x	                sta @w tubeOSFILEParameterBlock.addresses-1,x
6687							                .endif
6688	.ad38	05bc	ca		dex		                dex
6689	.ad39	05bd	d0 f7		bne $05b6	                bne -
6690	.ad3b	05bf	20 75 05	jsr $0575	                jsr recvR2String
6691							                .if version==350
6692	.ad3e	05c2	8e 00 00	stx $0000	                stx @w tubeOSFILEParameterBlock+0
6693	.ad41	05c5	8c 01 00	sty $0001	                sty @w tubeOSFILEParameterBlock+1
6697							                .endif
6698	.ad44	05c8	a0 00		ldy #$00	                ldy #>tubeOSFILEParameterBlock
6699							                .cerror (<tubeOSFILEParameterBlock)!=0,"Tube OSFILE parameter block must be at $0000"
6700	.ad46	05ca	20 a8 06	jsr $06a8	                jsr recvR2                   ;receive OSFILE reason code
6701	.ad49	05cd	20 dd ff	jsr $ffdd	                jsr OSFILE                   ;call OSFILE
6702	.ad4c	05d0	20 68 06	jsr $0668	                jsr sendR2A                  ;send OSFILE result

6704							                ; send non-name part of updated OSFILE parameter block
6705	.ad4f	05d3	a2 10		ldx #$10	                ldx #size(OSFILEParameterBlock)-2
6706	.ad51	05d5					-
6707							                .if version==350
6708	.ad51	05d5	bd 01 00	lda $0001,x	                lda @w tubeOSFILEParameterBlock.addresses-1,x
6711							                .endif
6712	.ad54	05d8	20 68 06	jsr $0668	                jsr sendR2A
6713	.ad57	05db	ca		dex		                dex
6714	.ad58	05dc	d0 f7		bne $05d5	                bne -
6715	.ad5a	05de	80 0e		bra $05ee	                bra goIdle_1
6716							                .pend

6718							;-------------------------------------------------------------------------
6719							;
6720							; Handle a Tube small (A<$80) OSBYTE.
6721							;
6722							; [Tube p22]
6723							;
6724	.ad5c	05e0					doSBYT:
6725	.ad5c	05e0	20 a4 06	jsr $06a4	                jsr recvR2XA    ;receive X and A arguments
6726	.ad5f	05e3	20 f4 ff	jsr $fff4	                jsr OSBYTE
6727	.ad62	05e6					sendR2X:
6728	.ad62	05e6	2c e2 fe	bit $fee2	                bit tube.status2
6729	.ad65	05e9	50 fb		bvc $05e6	                bvc sendR2X
6730	.ad67	05eb	8e e3 fe	stx $fee3	                stx tube.data2
6731	.ad6a	05ee					goIdle_1:
6732	.ad6a	05ee	4c 36 00	jmp $0036	                jmp idleLoop

6734							;-------------------------------------------------------------------------
6735							;
6736							; Handle a Tube non-small OSBYTE.
6737							;
6738							; [Tube p22]
6739	.ad6d	05f1					doBYTE:
6740	.ad6d	05f1	20 a4 06	jsr $06a4	                jsr recvR2XA                ;receive X and Y arguments
6741	.ad70	05f4	a8		tay		                tay                         ;Y = Y argument
6742	.ad71	05f5	20 a8 06	jsr $06a8	                jsr recvR2                  ;receive A argument
6743	.ad74	05f8	20 f4 ff	jsr $fff4	                jsr OSBYTE                  ;call OSBYTE
6744	.ad77	05fb	49 9d		eor #$9d	                eor #$9D                    ;was it Fast Tube BPUT?
6745	.ad79	05fd	f0 ef		beq $05ee	                beq goIdle_1      ;if it was, done.
6746	.ad7b	05ff	6a		ror a		                ror a
6747	.ad7c	0600	20 68 06	jsr $0668	                jsr sendR2A       ;send carry result
6748	.ad7f	0603					-
6749	.ad7f	0603	2c e2 fe	bit $fee2	                bit tube.status2
6750	.ad82	0606	50 fb		bvc $0603	                bvc -
6751	.ad84	0608	8c e3 fe	sty $fee3	                sty tube.data2               ;send Y result
6752	.ad87	060b	80 d9		bra $05e6	                bra sendR2X                  ;send X result

6754							;-------------------------------------------------------------------------
6755							;
6756							; Handle a Tube OSWORD request.
6757							;
6758							; [Tube p22]
6759							;
6760	.ad89	060d					doWORD:
6761	.ad89	060d	20 a8 06	jsr $06a8	                jsr recvR2
6762	.ad8c	0610	a8		tay		                tay
6763	.ad8d	0611	20 b1 06	jsr $06b1	                jsr LAE0F
6764	.ad90	0614	30 0a		bmi $0620	                bmi LAD7F
6765	.ad92	0616					LAD75:
6766	.ad92	0616	20 a8 06	jsr $06a8	                jsr recvR2
6767	.ad95	0619	9d 28 01	sta $0128,x	                sta tubeOSWORDBuffer,x
6768	.ad98	061c	ca		dex		                dex
6769	.ad99	061d	10 f7		bpl $0616	                bpl LAD75
6770	.ad9b	061f	98		tya		                tya
6771	.ad9c	0620					LAD7F:
6772	.ad9c	0620	a2 28		ldx #$28	                ldx #<tubeOSWORDBuffer
6773	.ad9e	0622	a0 01		ldy #$01	                ldy #>tubeOSWORDBuffer
6774	.ada0	0624	20 f1 ff	jsr $fff1	                jsr OSWORD
6775	.ada3	0627	20 b1 06	jsr $06b1	                jsr LAE0F
6776	.ada6	062a	30 c2		bmi $05ee	                bmi goIdle_1
6777	.ada8	062c					LAD8B:
6778	.ada8	062c	bc 28 01	ldy $0128,x	                ldy tubeOSWORDBuffer,x
6779	.adab	062f					LAD8E:
6780	.adab	062f	2c e2 fe	bit $fee2	                bit tube.status2
6781	.adae	0632	50 fb		bvc $062f	                bvc LAD8E
6782	.adb0	0634	8c e3 fe	sty $fee3	                sty tube.data2
6783	.adb3	0637	ca		dex		                dex
6784	.adb4	0638	10 f2		bpl $062c	                bpl LAD8B
6785	.adb6	063a					LAD99:
6786	.adb6	063a	80 b2		bra $05ee	                bra goIdle_1

6788							;-------------------------------------------------------------------------

6790	.adb8	063c					doRDLN:
6791	.adb8	063c	a2 04		ldx #$04	                ldx #$04
6792	.adba	063e					LAD9D:
6793	.adba	063e	20 a8 06	jsr $06a8	                jsr recvR2
6794							                .if version==350
6795	.adbd	0641	9d 00 00	sta $0000,x	                sta @w $00,x
6798							                .endif
6799	.adc0	0644	ca		dex		                dex
6800	.adc1	0645	10 f7		bpl $063e	                bpl LAD9D
6801	.adc3	0647	e8		inx		                inx
6802	.adc4	0648	8a		txa		                txa
6803	.adc5	0649	a8		tay		                tay
6804	.adc6	064a	20 f1 ff	jsr $fff1	                jsr OSWORD
6805	.adc9	064d	90 05		bcc $0654	                bcc LADB2
6806	.adcb	064f	a9 ff		lda #$ff	                lda #$FF
6807	.adcd	0651	4c 91 05	jmp $0591	                jmp sendR2AThenGoIdle

6809	.add0	0654					LADB2:
6810	.add0	0654	a2 00		ldx #$00	                ldx #$00
6811	.add2	0656	a9 7f		lda #$7f	                lda #$7F
6812	.add4	0658	20 68 06	jsr $0668	                jsr sendR2A
6813	.add7	065b					LADB9:
6814	.add7	065b	bd 00 07	lda $0700,x	                lda $0700,x
6815	.adda	065e	20 68 06	jsr $0668	                jsr sendR2A
6816	.addd	0661	e8		inx		                inx
6817	.adde	0662	c9 0d		cmp #$0d	                cmp #$0D
6818	.ade0	0664	d0 f5		bne $065b	                bne LADB9
6819	.ade2	0666	80 d2		bra $063a	                bra LAD99

6821	.ade4	0668					sendR2A:                          ;adc6/0661
6822	.ade4	0668	2c e2 fe	bit $fee2	                bit tube.status2
6823	.ade7	066b	50 fb		bvc $0668	                bvc sendR2A
6824	.ade9	066d	8d e3 fe	sta $fee3	                sta tube.data2
6825	.adec	0670	60		rts		                rts

6827	.aded	0671					sendR4TubeClaimantID:              ;adcf
6828	.aded	0671	a5 15		lda $15		                lda tubeClaimantID ;get Tube ID
6829	.adef	0673					sendR4:                          ;add1/066c
6830	.adef	0673	2c e6 fe	bit $fee6	                bit tube.status4 ;check R4 status
6831	.adf2	0676	50 fb		bvc $0673	                bvc sendR4       ;branch taken if FIFO full
6832	.adf4	0678	8d e7 fe	sta $fee7	                sta tube.data4   ;put byte in FIFO
6833	.adf7	067b	60		rts		                rts

6835	.adf8	067c					LADDA:
6836	.adf8	067c	a5 ff		lda $ff		                lda $FF
6837	.adfa	067e	38		sec		                sec
6838	.adfb	067f	6a		ror a		                ror a
6839	.adfc	0680	80 0f		bra $0691	                bra LADEF

6841	.adfe	0682					eventHandler:
6842	.adfe	0682	48		pha		                pha
6843	.adff	0683	a9 00		lda #$00	                lda #$00
6844	.ae01	0685	20 91 06	jsr $0691	                jsr LADEF
6845	.ae04	0688	98		tya		                tya
6846	.ae05	0689	20 91 06	jsr $0691	                jsr LADEF
6847	.ae08	068c	8a		txa		                txa
6848	.ae09	068d	20 91 06	jsr $0691	                jsr LADEF
6849	.ae0c	0690	68		pla		                pla
6850	.ae0d	0691					LADEF:
6851	.ae0d	0691	2c e0 fe	bit $fee0	                bit tube.status1
6852	.ae10	0694	50 fb		bvc $0691	                bvc LADEF
6853	.ae12	0696	8d e1 fe	sta $fee1	                sta tube.data1
6854	.ae15	0699	60		rts		                rts

6856							;-------------------------------------------------------------------------
6857							;
6858							; Receive multiple bytes via R2: some kind of parameter block,
6859							; followed by the reason code. Store the first N-1 received in zero
6860							; page, starting at $00.
6861							;
6862							; entry:
6863							;
6864							; X = number of bytes to receive, minus 1
6865							;
6866							; exit:
6867							;
6868							; ?$00, ?$01... = first N-1 bytes received
6869							;
6870							; A = final byte received
6871							;
6872							; X = 0
6873							;
6874	.ae16	069a					recvR2N:
6875	.ae16	069a	20 a8 06	jsr $06a8	                jsr recvR2
6876	.ae19	069d	95 ff		sta $ff,x	                sta $ff,x
6877	.ae1b	069f	ca		dex		                dex
6878	.ae1c	06a0	d0 f8		bne $069a	                bne recvR2N
6879	.ae1e	06a2	80 04		bra $06a8	                bra recvR2

6881							;-------------------------------------------------------------------------
6882							;
6883							; Receive 2 bytes via R2.
6884							;
6885							; exit:
6886							;
6887							; X = first byte received
6888							;
6889							; A = second byte received
6890							;
6891	.ae20	06a4					recvR2XA:
6892	.ae20	06a4	20 a8 06	jsr $06a8	                jsr recvR2
6893	.ae23	06a7	aa		tax		                tax

6895							;-------------------------------------------------------------------------
6896							;
6897							; Receive 1 byte via R2.
6898							;
6899							; exit:
6900							;
6901							; A = byte received
6902							;
6903	.ae24	06a8					recvR2:
6904	.ae24	06a8	2c e2 fe	bit $fee2	                bit tube.status2
6905	.ae27	06ab	10 fb		bpl $06a8	                bpl recvR2
6906	.ae29	06ad	ad e3 fe	lda $fee3	                lda tube.data2
6907	.ae2c	06b0	60		rts		                rts

6909							;-------------------------------------------------------------------------

6911	.ae2d	06b1					LAE0F:
6912	.ae2d	06b1	2c e2 fe	bit $fee2	                bit tube.status2
6913	.ae30	06b4	10 fb		bpl $06b1	                bpl LAE0F
6914	.ae32	06b6	ae e3 fe	ldx $fee3	                ldx tube.data2
6915	.ae35	06b9	ca		dex		                dex
6916	.ae36	06ba	60		rts		                rts
6917							                .here
6918							                .bend

6920							;-------------------------------------------------------------------------
6921							                .endif

6923							                .if version<400&&includeTerminalROM
6924							                .include "terminal_code.s65"

:14	;******  Processing file: src/terminal_code.s65

1							;-------------------------------------------------------------------------

3	.ae37						terminalServiceEntryPoint:
4	.ae37		08		php		                php
5	.ae38		5a		phy		                phy
6	.ae39		da		phx		                phx
7	.ae3a		48		pha		                pha
8	.ae3b		c9 04		cmp #$04	                cmp #romServiceCallUnrecognisedCommand
9	.ae3d		f0 0d		beq $ae4c	                beq handleUnrecognisedCommand
10	.ae3f		c9 07		cmp #$07	                cmp #romServiceCallUnrecognisedOSBYTE
11	.ae41		f0 25		beq $ae68	                beq handleUnrecognisedOSBYTE
12	.ae43		c9 2a		cmp #$2a	                cmp #romServiceCallLanguageChange
13	.ae45		f0 74		beq $aebb	                beq handleLanguageChange
14	.ae47						LAE29:
15	.ae47		68		pla		                pla
16	.ae48		fa		plx		                plx
17	.ae49		7a		ply		                ply
18	.ae4a		28		plp		                plp
19	.ae4b		60		rts		                rts

21	.ae4c						handleUnrecognisedCommand:
22	.ae4c		20 50 b8	jsr $b850	                jsr LB832
23	.ae4f		c9 0b		cmp #$0b	                cmp #$0B
24	.ae51		d0 f4		bne $ae47	                bne LAE29
25	.ae53		68		pla		                pla
26	.ae54		fa		plx		                plx
27	.ae55		a9 8e		lda #$8e	                lda #$8E
28	.ae57		20 f4 ff	jsr $fff4	                jsr OSBYTE
29	.ae5a						LAE3C:
30	.ae5a		a2 04		ldx #$04	                ldx #$04
31	.ae5c						LAE3E:
32	.ae5c		bd 29 02	lda $0229,x	                lda INSV-1,x
33	.ae5f		dd b0 ae	cmp $aeb0,x	                cmp LAE93-1,x
34	.ae62		d0 03		bne $ae67	                bne LAE49
35	.ae64		ca		dex		                dex
36	.ae65		d0 f5		bne $ae5c	                bne LAE3E
37	.ae67						LAE49:
38	.ae67		60		rts		                rts

40	.ae68						handleUnrecognisedOSBYTE:
41	.ae68		5a		phy		                phy
42	.ae69		7a		ply		                ply
43	.ae6a		d0 db		bne $ae47	                bne LAE29
44	.ae6c		a5 ef		lda $ef		                lda $EF
45	.ae6e		c9 60		cmp #$60	                cmp #$60
46	.ae70		d0 d5		bne $ae47	                bne LAE29

48							                ; handle OSBYTE $60
49	.ae72						osbyte60:
50	.ae72		68		pla		                pla
51	.ae73		5a		phy		                phy
52	.ae74		78		sei		                sei
53	.ae75		a5 f0		lda $f0		                lda $F0
54	.ae77		30 11		bmi $ae8a	                bmi LAE6C
55	.ae79		4a		lsr a		                lsr a
56	.ae7a		d0 08		bne $ae84	                bne LAE66
57	.ae7c		a9 11		lda #$11	                lda #$11
58	.ae7e		85 76		sta $76		                sta $76
59	.ae80		66 74		ror $74		                ror $74
60	.ae82		80 c3		bra $ae47	                bra LAE29

62	.ae84						LAE66:

64	.ae84		64 78		stz $78		                stz $78
65	.ae86		66 77		ror $77		                ror $77

67	.ae88						LAE6A:
68	.ae88		80 bd		bra $ae47	                bra LAE29

70	.ae8a						LAE6C:
71	.ae8a		4a		lsr a		                lsr a
72	.ae8b		90 2e		bcc $aebb	                bcc handleLanguageChange
73	.ae8d		64 75		stz $75		                stz $75
74	.ae8f		20 5a ae	jsr $ae5a	                jsr LAE3C
75	.ae92		f0 b3		beq $ae47	                beq LAE29
76	.ae94		a2 04		ldx #$04	                ldx #$04
77	.ae96						LAE78:
78	.ae96		bd 29 02	lda $0229,x	                lda INSV-1,x
79	.ae99		95 6f		sta $6f,x	                sta oldINSV-1,x
80	.ae9b		bd b0 ae	lda $aeb0,x	                lda LAE93-1,x
81	.ae9e		9d 29 02	sta $0229,x	                sta INSV-1,x
82	.aea1		ca		dex		                dex
83	.aea2		d0 f2		bne $ae96	                bne LAE78
84	.aea4		a2 06		ldx #$06	                ldx #$06
85	.aea6						LAE88:
86	.aea6		bd b4 ae	lda $aeb4,x	                lda LAE97-1,x
87	.aea9		9d dd 0d	sta $0ddd,x	                sta ExtendedVectorAddress(INSV)-1,x
88	.aeac		ca		dex		                dex
89	.aead		d0 f7		bne $aea6	                bne LAE88
90	.aeaf		80 d7		bra $ae88	                bra LAE6A

92	.aeb1						LAE93:
93	>aeb1		3f ff				                .word E_INSV
94	>aeb3		42 ff				                .word E_REMV
95	.aeb5						LAE97:
96	>aeb5		f2 ae				                .word LAED4
97	>aeb7		0f				                .byte terminalROM
98	>aeb8		31 af				                .word LAF13
99	>aeba		0f				                .byte terminalROM

101	.aebb						handleLanguageChange:
102	.aebb		78		sei		                sei
103	.aebc		20 5a ae	jsr $ae5a	                jsr LAE3C
104	.aebf		d0 c7		bne $ae88	                bne LAE6A
105	.aec1		a2 06		ldx #$06	                ldx #$06
106	.aec3						LAEA5:
107	.aec3		bd dd 0d	lda $0ddd,x	                lda ExtendedVectorAddress(INSV)-1,x;extendedVectorSpace+insvIndex*3-1,x
108	.aec6		dd b4 ae	cmp $aeb4,x	                cmp LAE97-1,x
109	.aec9		d0 bd		bne $ae88	                bne LAE6A
110	.aecb		ca		dex		                dex
111	.aecc		d0 f5		bne $aec3	                bne LAEA5
112	.aece		a2 04		ldx #$04	                ldx #$04
113	.aed0						LAEB2:
114	.aed0		b5 6f		lda $6f,x	                lda oldINSV-1,x
115	.aed2		9d 29 02	sta $0229,x	                sta INSV-1,x
116	.aed5		ca		dex		                dex
117	.aed6		d0 f8		bne $aed0	                bne LAEB2
118	.aed8		a9 e6		lda #$e6	                lda #$E6
119	.aeda		20 41 b8	jsr $b841	                jsr osbyteX00Y00
120	.aedd		a9 cb		lda #$cb	                lda #$CB
121	.aedf		a2 09		ldx #$09	                ldx #$09
122	.aee1		20 43 b8	jsr $b843	                jsr osbyteY00
123	.aee4		20 38 b1	jsr $b138	                jsr LB11A
124	.aee7		1a		inc a		                inc a
125	.aee8						LAECA:
126	.aee8		20 41 b8	jsr $b841	                jsr osbyteX00Y00
127	.aeeb		3a		dec a		                dec a
128	.aeec		c9 01		cmp #$01	                cmp #$01
129	.aeee		d0 f8		bne $aee8	                bne LAECA
130	.aef0		80 96		bra $ae88	                bra LAE6A

132	.aef2						LAED4:
133	.aef2		08		php		                php
134	.aef3		78		sei		                sei
135	.aef4		e0 01		cpx #$01	                cpx #$01
136	.aef6		d0 31		bne $af29	                bne LAF0B
137	.aef8		24 77		bit $77		                bit $77
138	.aefa		10 0e		bpl $af0a	                bpl LAEEC
139	.aefc		c9 13		cmp #$13	                cmp #$13
140	.aefe		f0 05		beq $af05	                beq LAEE7
141	.af00		c9 11		cmp #$11	                cmp #$11
142	.af02		d0 06		bne $af0a	                bne LAEEC
143	.af04		18		clc		                clc
144	.af05						LAEE7:
145	.af05		66 78		ror $78		                ror $78
146	.af07						LAEE9:
147	.af07		28		plp		                plp
148	.af08		18		clc		                clc
149	.af09		60		rts		                rts

151	.af0a						LAEEC:
152	.af0a		24 74		bit $74		                bit $74
153	.af0c		10 1b		bpl $af29	                bpl LAF0B
154	.af0e		48		pha		                pha
155	.af0f		38		sec		                sec
156	.af10		20 2d af	jsr $af2d	                jsr LAF0F
157	.af13		98		tya		                tya
158	.af14		d0 10		bne $af26	                bne LAF08
159	.af16		e0 20		cpx #$20	                cpx #$20
160	.af18		b0 0c		bcs $af26	                bcs LAF08
161	.af1a		a9 13		lda #$13	                lda #$13
162	.af1c		e0 10		cpx #$10	                cpx #$10
163	.af1e		90 04		bcc $af24	                bcc LAF06
164	.af20		c5 76		cmp $76		                cmp $76
165	.af22		f0 02		beq $af26	                beq LAF08
166	.af24						LAF06:
167	.af24		85 75		sta $75		                sta $75
168	.af26						LAF08:
169	.af26		68		pla		                pla
170	.af27		a2 01		ldx #$01	                ldx #$01
171	.af29						LAF0B:
172	.af29		28		plp		                plp
173	.af2a		6c 70 00	jmp ($0070)	                jmp ($0070)

175	.af2d						LAF0F:
176	.af2d		b8		clv		                clv
177	.af2e		6c 2e 02	jmp ($022e)	                jmp (CNPV)

179	.af31						LAF13:
180	.af31		08		php		                php
181	.af32		78		sei		                sei
182	.af33		e0 01		cpx #$01	                cpx #$01
183	.af35		d0 1e		bne $af55	                bne LAF37
184	.af37		24 74		bit $74		                bit $74
185	.af39		10 16		bpl $af51	                bpl LAF33
186	.af3b		18		clc		                clc
187	.af3c		20 2d af	jsr $af2d	                jsr LAF0F
188	.af3f		c0 00		cpy #$00	                cpy #$00
189	.af41		d0 0c		bne $af4f	                bne LAF31
190	.af43		e0 20		cpx #$20	                cpx #$20
191	.af45		b0 08		bcs $af4f	                bcs LAF31
192	.af47		a9 11		lda #$11	                lda #$11
193	.af49		c5 76		cmp $76		                cmp $76
194	.af4b		f0 02		beq $af4f	                beq LAF31
195	.af4d		85 75		sta $75		                sta $75
196	.af4f						LAF31:
197	.af4f		a2 01		ldx #$01	                ldx #$01
198	.af51						LAF33:
199	.af51		28		plp		                plp
200	.af52		6c 72 00	jmp ($0072)	                jmp ($0072)

202	.af55						LAF37:
203	.af55		e0 02		cpx #$02	                cpx #$02
204	.af57		d0 f8		bne $af51	                bne LAF33
205	.af59		a5 75		lda $75		                lda $75
206	.af5b		a8		tay		                tay
207	.af5c		f0 08		beq $af66	                beq LAF48
208	.af5e		70 a7		bvs $af07	                bvs LAEE9
209	.af60		64 75		stz $75		                stz $75
210	.af62		85 76		sta $76		                sta $76
211	.af64		80 a1		bra $af07	                bra LAEE9

213	.af66						LAF48:
214	.af66		a5 78		lda $78		                lda $78
215	.af68		10 e7		bpl $af51	                bpl LAF33
216	.af6a		28		plp		                plp
217	.af6b		38		sec		                sec
218	.af6c						LAF4E:
219	.af6c		60		rts		                rts

221							;-------------------------------------------------------------------------

223	.af6d						terminalBRKHandler:
224	.af6d		a9 da		lda #$da	                lda #$DA
225	.af6f		20 41 b8	jsr $b841	                jsr osbyteX00Y00             ;Set VDU queue length to 0
226	.af72		20 52 b6	jsr $b652	                jsr disableESCAPE
227	.af75		a0 00		ldy #$00	                ldy #$00
228	.af77		b1 fd		lda ($fd),y	                lda (errPtr),y
229	.af79		d0 06		bne $af81	                bne LAF63
230	.af7b		64 20		stz $20		                stz $20
231	.af7d		a9 16		lda #$16	                lda #$16
232	.af7f		85 6f		sta $6f		                sta $6F
233	.af81						LAF63:
234	.af81		a9 0d		lda #$0d	                lda #13
235	.af83						-
236	.af83		20 e3 ff	jsr $ffe3	                jsr OSASCI
237	.af86		c8		iny		                iny
238	.af87		b1 fd		lda ($fd),y	                lda (errPtr),y
239	.af89		d0 f8		bne $af83	                bne -
240	.af8b		20 e7 ff	jsr $ffe7	                jsr OSNEWL
241	.af8e		38		sec		                sec
242	.af8f		66 19		ror $19		                ror $19
243	.af91		a5 1a		lda $1a		                lda $1A
244	.af93		d0 7d		bne $b012	                bne LAFF4
245	.af95						terminalLanguageEntryPoint:
246	.af95		3a		dec a		                dec a
247	.af96		d0 d4		bne $af6c	                bne LAF4E
248	.af98		a9 01		lda #$01	                lda #$01
249	.af9a		85 6f		sta $6f		                sta $6F
250	.af9c						LAF7E:
251	.af9c		78		sei		                sei
252	.af9d		a2 fe		ldx #$fe	                ldx #$FE
253	.af9f		9a		txs		                txs
254	.afa0		a9 6d		lda #$6d	                lda #<terminalBRKHandler
255	.afa2		8d 02 02	sta $0202	                sta BRKV+0
256	.afa5		a9 af		lda #$af	                lda #>terminalBRKHandler
257	.afa7		8d 03 02	sta $0203	                sta BRKV+1
258	.afaa		a9 cf		lda #$cf	                lda #<terminalINDnHandler
259	.afac		8d 30 02	sta $0230	                sta IND1V+0
260	.afaf		a9 b7		lda #$b7	                lda #>terminalINDnHandler
261	.afb1		8d 31 02	sta $0231	                sta IND1V+1
262	.afb4		a9 cf		lda #$cf	                lda #<terminalINDnHandler
263	.afb6		8d 32 02	sta $0232	                sta IND2V+0
264	.afb9		a9 b7		lda #$b7	                lda #>terminalINDnHandler
265	.afbb		8d 33 02	sta $0233	                sta IND2V+1

267							                ; Clear zero page
268	.afbe		a2 6e		ldx #$6e	                ldx #$6E
269	.afc0						-
270	.afc0		74 00		stz $00,x	                stz $00,x
271	.afc2		ca		dex		                dex
272	.afc3		10 fb		bpl $afc0	                bpl -

274	.afc5		c6 21		dec $21		                dec $21
275	.afc7		c6 34		dec $34		                dec $34
276	.afc9		c6 36		dec $36		                dec $36
277	.afcb		58		cli		                cli
278	.afcc		a9 0b		lda #$0b	                lda #$0B
279	.afce		20 ae b6	jsr $b6ae	                jsr LB690
280	.afd1		a9 87		lda #$87	                lda #$87
281	.afd3		20 f4 ff	jsr $fff4	                jsr OSBYTE                   ;Read screen mode
282	.afd6		98		tya		                tya                          ;A = screen mode
283	.afd7		20 97 b5	jsr $b597	                jsr reinitDisplayMode
284	.afda		a0 ff		ldy #$ff	                ldy #$FF
285	.afdc						-
286	.afdc		c8		iny		                iny
287	.afdd		b9 ec af	lda $afec,y	                lda initOSBYTEAs,y
288	.afe0		f0 30		beq $b012	                beq LAFF4
289	.afe2		be ff af	ldx $afff,y	                ldx initOSBYTEXs,y
290	.afe5		5a		phy		                phy
291	.afe6		20 43 b8	jsr $b843	                jsr osbyteY00
292	.afe9		7a		ply		                ply
293	.afea		80 f0		bra $afdc	                bra -

295							;-------------------------------------------------------------------------

297	.afec						initOSBYTEAs:
298	>afec		cb				                .byte $CB ;OSBYTE 203 (&CB) Read/write RS423 input buffer [MasRef D.2-64]
299	>afed		60				                .byte $60 ;OSBYTE 96 (&60) ???
300	>afee		60				                .byte $60 ;OSBYTE 96 (&60) ???
301	>afef		60				                .byte $60 ;OSBYTE 96 (&60) ???
302	>aff0		0f				                .byte $0F ;OSBYTE 15 (&0F) Flush buffer [MasRef D.2-24]
303	>aff1		0f				                .byte $0F ;OSBYTE 15 (&0F) Flush buffer [MasRef D.2-24]
304	>aff2		dd				                .byte $dd ;OSBYTE 221 (&DD) Read/write interpretation of input values 192-207 [MasRef D.2-73]
305	>aff3		de				                .byte $de ;OSBYTE 222 (&DE) Read/write interpretation of input values 208-223 [MasRef D.2-73]
306	>aff4		df				                .byte $df ;OSBYTE 223 (&DF) Read/write interpretation of input values 224-239 [MasRef D.2-73]
307	>aff5		e0				                .byte $e0 ;OSBYTE 224 (&E0) Read/write interpretation of input values 240-255 [MasRef D.2-73]
308	>aff6		e1				                .byte $e1 ;OSBYTE 225 (&E1) Read/write soft key interpretation [MasRef D.2-74]
309	>aff7		e2				                .byte $E2 ;OSBYTE 226 (&E2) Read/write SHIFT+soft key interpretation [MasRef D.2-74]
310	>aff8		e3				                .byte $E3 ;OSBYTE 227 (&E3) Read/write CTRL+soft key interpretation [MasRef D.2-74]
311	>aff9		e4				                .byte $e4 ;OSBYTE 228 (&E4) Read/write SHIFT+CTRL+soft key interpretation [MasRef D.2-74]
312	>affa		e5				                .byte $e5 ;OSBYTE 229 (&E5) Read/write ESCAPE key status [MasRef D.2-75]
313	>affb		04				                .byte $04 ;OSBYTE 4 (&04) Enable/disable cursor editing [MasRef D.2-19]
314	>affc		7e				                .byte $7e ;OSBYTE 126 (&7E) Acknowledge escape condition [MasRef D.2-37]
315	>affd		e6				                .byte $e6 ;OSBYTE 230 (&E6) Read/write ESCAPE effects [MasRef D.2-75]
316	>affe		02				                .byte $02 ;OSBYTE 2 (&02) Specify input stream [MasRef D.2-18]

318	.afff						initOSBYTEXs:
319	>afff		00				                .byte $00
320	>b000		01				                .byte $01
321	>b001		03				                .byte $03
322	>b002		ff				                .byte $ff
323	>b003		01				                .byte $01
324	>b004		02				                .byte $02
325	>b005		c0				                .byte $c0
326	>b006		d0				                .byte $d0
327	>b007		e0				                .byte $e0
328	>b008		f0				                .byte $f0
329	>b009		01				                .byte $01
330	>b00a		90				                .byte $90
331	>b00b		a0				                .byte $a0
332	>b00c		a0				                .byte $a0
333	>b00d		01				                .byte $01
334	>b00e		00				                .byte $00
335	>b00f		00				                .byte $00
336	>b010		01				                .byte $01
337	>b011		02				                .byte $02

339							;-------------------------------------------------------------------------

341	.b012						LAFF4:
342	.b012		a2 fe		ldx #$fe	                ldx #$FE
343	.b014		9a		txs		                txs
344	.b015		38		sec		                sec
345	.b016		66 1a		ror $1a		                ror $1A
346	.b018		64 1d		stz $1d		                stz $1D
347	.b01a		20 22 b0	jsr $b022	                jsr LB004
348	.b01d		20 22 b0	jsr $b022	                jsr LB004
349	.b020		80 2c		bra $b04e	                bra LB030

351	.b022						LB004:
352	.b022		20 5f b0	jsr $b05f	                jsr LB041
353	.b025		a0 01		ldy #$01	                ldy #$01
354	.b027		91 1b		sta ($1b),y	                sta ($1B),y
355	.b029		c8		iny		                iny
356	.b02a		8a		txa		                txa
357	.b02b		91 1b		sta ($1b),y	                sta ($1B),y
358	.b02d		c8		iny		                iny
359	.b02e		98		tya		                tya
360	.b02f		91 1b		sta ($1b),y	                sta ($1B),y
361	.b031		0a		asl a		                asl a
362	.b032		92 1b		sta ($1b)	                sta ($1B)
363	.b034		60		rts		                rts

365	.b035						LB017:
366	.b035		08		php		                php
367	.b036		48		pha		                pha
368	.b037		da		phx		                phx
369	.b038		5a		phy		                phy
370	.b039		ba		tsx		                tsx
371	.b03a		e8		inx		                inx
372	.b03b		8a		txa		                txa
373	.b03c		49 ff		eor #$ff	                eor #$FF
374	.b03e		92 1b		sta ($1b)	                sta ($1B)
375	.b040		a8		tay		                tay
376	.b041						LB023:
377	.b041		68		pla		                pla
378	.b042		91 1b		sta ($1b),y	                sta ($1B),y
379	.b044		88		dey		                dey
380	.b045		d0 fa		bne $b041	                bne LB023
381	.b047		a9 20		lda #$20	                lda #$20
382	.b049		85 1e		sta $1e		                sta $1E
383	.b04b		20 5f b0	jsr $b05f	                jsr LB041
384	.b04e						LB030:
385	.b04e		b2 1b		lda ($1b)	                lda ($1B)
386	.b050		aa		tax		                tax
387	.b051		a0 00		ldy #$00	                ldy #$00
388	.b053						LB035:
389	.b053		c8		iny		                iny
390	.b054		b1 1b		lda ($1b),y	                lda ($1B),y
391	.b056		48		pha		                pha
392	.b057		ca		dex		                dex
393	.b058		d0 f9		bne $b053	                bne LB035
394	.b05a		7a		ply		                ply
395	.b05b		fa		plx		                plx
396	.b05c		68		pla		                pla
397	.b05d		28		plp		                plp
398	.b05e		60		rts		                rts

400	.b05f						LB041:
401	.b05f		a0 04		ldy #$04	                ldy #$04
402	.b061		84 1c		sty $1c		                sty $1C
403	.b063		a0 20		ldy #$20	                ldy #$20
404							                ; Is this an adress?
405							                .if version==350
406	.b065		a2 6e		ldx #$6e	                ldx #$6e
409							                .endif
410	.b067		a9 b6		lda #$b6	                lda #$B6
411	.b069		46 1d		lsr $1d		                lsr $1D
412	.b06b		b0 0c		bcs $b079	                bcs LB05B
413	.b06d		e6 1d		inc $1d		                inc $1D
414	.b06f		a0 04		ldy #$04	                ldy #$04
415	.b071		84 1c		sty $1c		                sty $1C
416	.b073		a0 00		ldy #$00	                ldy #$00
417							                .if version==350
418	.b075		a2 7b		ldx #$7b	                ldx #$7b
421							                .endif
422	.b077		a9 b0		lda #$b0	                lda #$B0
423	.b079						LB05B:
424	.b079		84 1b		sty $1b		                sty $1B
425	.b07b		60		rts		                rts

427	.b07c						LB05E:
428	.b07c		20 81 b0	jsr $b081	                jsr LB063
429	.b07f		80 fb		bra $b07c	                bra LB05E

431	.b081						LB063:
432	.b081		24 20		bit $20		                bit $20
433	.b083		10 05		bpl $b08a	                bpl LB06C
434	.b085		20 b4 b0	jsr $b0b4	                jsr LB096
435	.b088		90 17		bcc $b0a1	                bcc LB083
436	.b08a						LB06C:
437	.b08a		80 a9		bra $b035	                bra LB017

439	.b08c						LB06E:
440	.b08c		c9 0a		cmp #$0a	                cmp #$0A
441	.b08e		90 0f		bcc $b09f	                bcc LB081
442	.b090		a2 00		ldx #$00	                ldx #$00
443	.b092						LB074:
444	.b092		e8		inx		                inx
445	.b093		e9 0a		sbc #$0a	                sbc #$0A
446	.b095		c9 0a		cmp #$0a	                cmp #$0A
447	.b097		b0 f9		bcs $b092	                bcs LB074
448	.b099		48		pha		                pha
449	.b09a		8a		txa		                txa
450	.b09b		20 8c b0	jsr $b08c	                jsr LB06E
451	.b09e		68		pla		                pla
452	.b09f						LB081:
453	.b09f		09 30		ora #$30	                ora #$30
454	.b0a1						LB083:
455	.b0a1		48		pha		                pha
456	.b0a2		5a		phy		                phy
457	.b0a3		a8		tay		                tay
458	.b0a4		a9 8a		lda #$8a	                lda #$8A
459	.b0a6		a2 02		ldx #$02	                ldx #$02
460	.b0a8		20 f4 ff	jsr $fff4	                jsr OSBYTE
461	.b0ab		7a		ply		                ply
462	.b0ac		68		pla		                pla
463	.b0ad		90 1f		bcc $b0ce	                bcc LB0B0
464	.b0af		20 35 b0	jsr $b035	                jsr LB017
465	.b0b2		80 ed		bra $b0a1	                bra LB083

467	.b0b4						LB096:
468	.b0b4		a4 6f		ldy $6f		                ldy $6F
469	.b0b6		f0 17		beq $b0cf	                beq LB0B1
470	.b0b8		e6 6f		inc $6f		                inc $6F
471	.b0ba		b9 69 b1	lda $b169,y	                lda LB14C-1,y
472	.b0bd		10 0d		bpl $b0cc	                bpl LB0AE
473	.b0bf		64 6f		stz $6f		                stz $6F
474	.b0c1		48		pha		                pha
475	.b0c2		a9 d9		lda #$d9	                lda #$D9
476	.b0c4		20 41 b8	jsr $b841	                jsr osbyteX00Y00
477	.b0c7		68		pla		                pla
478	.b0c8		a0 18		ldy #$18	                ldy #$18
479	.b0ca		84 1f		sty $1f		                sty $1F
480	.b0cc						LB0AE:
481	.b0cc		0a		asl a		                asl a
482	.b0cd		4a		lsr a		                lsr a
483	.b0ce						LB0B0:
484	.b0ce		60		rts		                rts

486	.b0cf						LB0B1:
487	.b0cf		a9 81		lda #$81	                lda #$81
488	.b0d1		20 41 b8	jsr $b841	                jsr osbyteX00Y00
489	.b0d4		8a		txa		                txa
490	.b0d5		b0 f7		bcs $b0ce	                bcs LB0B0
491	.b0d7		10 f5		bpl $b0ce	                bpl LB0B0
492	.b0d9		c9 e0		cmp #$e0	                cmp #$E0
493	.b0db		b0 f1		bcs $b0ce	                bcs LB0B0
494	.b0dd		20 e2 b0	jsr $b0e2	                jsr LB0C4
495	.b0e0		38		sec		                sec
496	.b0e1						LB0C3:
497	.b0e1		60		rts		                rts

499	.b0e2						LB0C4:
500	.b0e2		c9 99		cmp #$99	                cmp #$99
501	.b0e4		f0 62		beq $b148	                beq LB12A
502	.b0e6		29 0f		and #$0f	                and #$0F
503	.b0e8		f0 1d		beq $b107	                beq LB0E9
504	.b0ea		c9 02		cmp #$02	                cmp #$02
505	.b0ec		90 1e		bcc $b10c	                bcc LB0EE
506	.b0ee		f0 f1		beq $b0e1	                beq LB0C3
507	.b0f0		c9 04		cmp #$04	                cmp #$04
508	.b0f2		90 40		bcc $b134	                bcc LB116
509	.b0f4		f0 42		beq $b138	                beq LB11A
510	.b0f6		c9 06		cmp #$06	                cmp #$06
511	.b0f8		90 2e		bcc $b128	                bcc LB10A
512	.b0fa		f0 17		beq $b113	                beq LB0F5
513	.b0fc		c9 08		cmp #$08	                cmp #$08
514	.b0fe		90 e1		bcc $b0e1	                bcc LB0C3
515	.b100		f0 3a		beq $b13c	                beq LB11E
516	.b102		c9 09		cmp #$09	                cmp #$09
517	.b104		f0 46		beq $b14c	                beq LB12E
518	.b106		60		rts		                rts

520	.b107						LB0E9:
521	.b107		a9 0c		lda #$0c	                lda #$0C
522	.b109						LB0EB:
523	.b109		4c ee ff	jmp $ffee	                jmp OSWRCH

525	.b10c						LB0EE:
526	.b10c		a9 16		lda #$16	                lda #$16
527	.b10e		85 6f		sta $6f		                sta $6F
528	.b110		64 20		stz $20		                stz $20
529	.b112		60		rts		                rts

531	.b113						LB0F5:
532	.b113		a2 10		ldx #$10	                ldx #$10
533	.b115		20 1f b1	jsr $b11f	                jsr LB101
534	.b118		29 10		and #$10	                and #$10
535	.b11a		d0 15		bne $b131	                bne LB113
536	.b11c						LB0FE:
537	.b11c		4c d4 b7	jmp $b7d4	                jmp LB7B6

539	.b11f						LB101:
540	.b11f		a9 ec		lda #$ec	                lda #$EC
541	.b121		a0 ff		ldy #$ff	                ldy #$FF
542	.b123		20 f4 ff	jsr $fff4	                jsr OSBYTE
543	.b126		8a		txa		                txa
544	.b127		60		rts		                rts

546	.b128						LB10A:
547	.b128		a2 40		ldx #$40	                ldx #$40
548	.b12a		20 1f b1	jsr $b11f	                jsr LB101
549	.b12d		29 40		and #$40	                and #$40
550	.b12f		f0 eb		beq $b11c	                beq LB0FE
551	.b131						LB113:
552	.b131		4c 00 b8	jmp $b800	                jmp LB7E2

554	.b134						LB116:
555	.b134		a9 02		lda #$02	                lda #$02
556	.b136		80 d1		bra $b109	                bra LB0EB

558	.b138						LB11A:
559	.b138		a9 03		lda #$03	                lda #$03
560	.b13a		80 cd		bra $b109	                bra LB0EB

562	.b13c						LB11E:
563	.b13c		a9 ff		lda #$ff	                lda #$FF
564	.b13e		45 21		eor $21		                eor $21
565	.b140		85 21		sta $21		                sta $21
566	.b142		85 20		sta $20		                sta $20
567	.b144		d0 d6		bne $b11c	                bne LB0FE
568	.b146		80 e9		bra $b131	                bra LB113

570	.b148						LB12A:
571	.b148		a2 0c		ldx #$0c	                ldx #$0C
572	.b14a		80 02		bra $b14e	                bra LB130

574	.b14c						LB12E:
575	.b14c		a2 af		ldx #$af	                ldx #$AF
576	.b14e						LB130:
577	.b14e		da		phx		                phx
578	.b14f		a2 60		ldx #$60	                ldx #$60
579	.b151		20 48 b8	jsr $b848	                jsr LB82A
580	.b154		fa		plx		                plx
581	.b155						LB137:
582	.b155		da		phx		                phx
583	.b156		a9 13		lda #$13	                lda #$13
584	.b158		20 f4 ff	jsr $fff4	                jsr OSBYTE
585	.b15b		fa		plx		                plx
586	.b15c		ca		dex		                dex
587	.b15d		d0 f6		bne $b155	                bne LB137
588	.b15f		a2 00		ldx #$00	                ldx #$00
589	.b161		20 48 b8	jsr $b848	                jsr LB82A
590	.b164						LB146:
591	.b164		20 b6 b1	jsr $b1b6	                jsr LB198
592	.b167		90 fb		bcc $b164	                bcc LB146
593	.b169		60		rts		                rts

595	.b16a						LB14C:
596	>b16a		1b				                .byte $1B
597	.b16b		5e 2a 4b	lsr $4b2a,x	                lsr $4B2A,x
598	.b16e		45 59		eor $59		                eor $59
599	.b170		39 7c 21	and $217c,y	                and $217C,y
600	.b173		7c 59 1b	jmp ($1b59,x)	                jmp ($1B59,x)

602	>b176		5c				                .byte $5C
603	>b177		54				                .byte $54
604	.b178		45 52		eor $52		                eor $52
605	.b17a		4d 49 4e	eor $4e49	                eor $4E49
606	.b17d		41 4c		eor ($4c,x)	                eor ($4C,x)
607	.b17f		0d 0a 3d	ora $3d0a	                ora $3D0A
608	>b182		1b				                .byte $1B
609							;BNE LB187        :\ B165= D0 20       P
610							;BVS LB11A        :\ B167= 70 B1       p1
611	>b183		d0				                .byte $D0
612	.b184						LB166:
613	.b184		20 8e b1	jsr $b18e	                jsr LB170
614	.b187		b0 59		bcs $b1e2	                bcs LB1C4
615	.b189		c9 1b		cmp #$1b	                cmp #$1B
616	.b18b		d0 f7		bne $b184	                bne LB166
617	.b18d		60		rts		                rts

619	.b18e						LB170:
620	.b18e		20 98 b1	jsr $b198	                jsr LB17A
621	.b191		c9 7f		cmp #$7f	                cmp #$7F
622	.b193		f0 f9		beq $b18e	                beq LB170
623	.b195		c9 20		cmp #$20	                cmp #$20
624	.b197		60		rts		                rts

626	.b198						LB17A:
627	.b198		da		phx		                phx
628	.b199		5a		phy		                phy
629	.b19a						LB17C:
630	.b19a		20 a7 b1	jsr $b1a7	                jsr LB189
631	.b19d		b0 03		bcs $b1a2	                bcs LB184
632	.b19f		7a		ply		                ply
633	.b1a0		fa		plx		                plx
634	.b1a1		60		rts		                rts

636	.b1a2						LB184:
637	.b1a2		20 35 b0	jsr $b035	                jsr LB017
638	.b1a5						LB187:
639	.b1a5		80 f3		bra $b19a	                bra LB17C

641	.b1a7						LB189:
642	.b1a7		24 20		bit $20		                bit $20
643	.b1a9		30 03		bmi $b1ae	                bmi LB190
644	.b1ab		4c b4 b0	jmp $b0b4	                jmp LB096

646	.b1ae						LB190:
647	.b1ae		24 25		bit $25		                bit $25
648	.b1b0		30 4c		bmi $b1fe	                bmi LB1E0
649	.b1b2		24 23		bit $23		                bit $23
650	.b1b4		30 0b		bmi $b1c1	                bmi LB1A3
651	.b1b6						LB198:
652	.b1b6		a9 91		lda #$91	                lda #$91
653	.b1b8		a2 01		ldx #$01	                ldx #$01
654	.b1ba		20 f4 ff	jsr $fff4	                jsr OSBYTE
655	.b1bd		98		tya		                tya
656	.b1be		25 22		and $22		                and $22
657	.b1c0						LB1A2:
658	.b1c0		60		rts		                rts

660	.b1c1						LB1A3:
661	.b1c1		20 b6 b1	jsr $b1b6	                jsr LB198
662	.b1c4		b0 fa		bcs $b1c0	                bcs LB1A2
663	.b1c6		20 ee b1	jsr $b1ee	                jsr LB1D0
664	.b1c9		90 54		bcc $b21f	                bcc LB201
665	.b1cb		0a		asl a		                asl a
666	.b1cc		0a		asl a		                asl a
667	.b1cd		0a		asl a		                asl a
668	.b1ce		0a		asl a		                asl a
669	.b1cf		85 24		sta $24		                sta $24
670	.b1d1						LB1B3:
671	.b1d1		20 b6 b1	jsr $b1b6	                jsr LB198
672	.b1d4		90 05		bcc $b1db	                bcc LB1BD
673	.b1d6		20 35 b0	jsr $b035	                jsr LB017
674	.b1d9		80 f6		bra $b1d1	                bra LB1B3

676	.b1db						LB1BD:
677	.b1db		20 ee b1	jsr $b1ee	                jsr LB1D0
678	.b1de		90 f1		bcc $b1d1	                bcc LB1B3
679	.b1e0		05 24		ora $24		                ora $24
680	.b1e2						LB1C4:
681	.b1e2		18		clc		                clc
682	.b1e3		60		rts		                rts

684	.b1e4						LB1C6:
685	.b1e4		20 84 b1	jsr $b184	                jsr LB166
686	.b1e7		90 05		bcc $b1ee	                bcc LB1D0
687	.b1e9		fa		plx		                plx
688	.b1ea		fa		plx		                plx
689	.b1eb		4c a7 b3	jmp $b3a7	                jmp LB389

691	.b1ee						LB1D0:
692	.b1ee		c9 3a		cmp #$3a	                cmp #$3A
693	.b1f0		b0 03		bcs $b1f5	                bcs LB1D7
694	.b1f2		e9 2f		sbc #$2f	                sbc #$2F
695	.b1f4		60		rts		                rts

697	.b1f5						LB1D7:
698	.b1f5		e9 37		sbc #$37	                sbc #$37
699	.b1f7		c9 10		cmp #$10	                cmp #$10
700	.b1f9		b0 e7		bcs $b1e2	                bcs LB1C4
701	.b1fb		c9 0a		cmp #$0a	                cmp #$0A
702	.b1fd						LB1DF:
703	.b1fd		60		rts		                rts

705	.b1fe						LB1E0:
706	.b1fe		64 26		stz $26		                stz $26
707	.b200		20 b6 b1	jsr $b1b6	                jsr LB198
708	.b203		b0 f8		bcs $b1fd	                bcs LB1DF
709	.b205		c9 7f		cmp #$7f	                cmp #$7F
710	.b207		b0 f4		bcs $b1fd	                bcs LB1DF
711	.b209		c9 20		cmp #$20	                cmp #$20
712	.b20b		b0 14		bcs $b221	                bcs LB203
713	.b20d		24 27		bit $27		                bit $27
714	.b20f		30 0e		bmi $b21f	                bmi LB201
715	.b211		c9 07		cmp #$07	                cmp #$07
716	.b213		90 0a		bcc $b21f	                bcc LB201
717	.b215		f0 47		beq $b25e	                beq LB240
718	.b217		c9 0b		cmp #$0b	                cmp #$0B
719	.b219		90 43		bcc $b25e	                bcc LB240
720	.b21b		c9 0d		cmp #$0d	                cmp #$0D
721	.b21d		f0 3f		beq $b25e	                beq LB240
722	.b21f						LB201:
723	.b21f		38		sec		                sec
724	.b220		60		rts		                rts

726	.b221						LB203:
727	.b221		64 27		stz $27		                stz $27
728	.b223		c9 7c		cmp #$7c	                cmp #$7C
729	.b225		d0 35		bne $b25c	                bne LB23E
730	.b227						LB209:
731	.b227		20 b6 b1	jsr $b1b6	                jsr LB198
732	.b22a		90 05		bcc $b231	                bcc LB213
733	.b22c		20 35 b0	jsr $b035	                jsr LB017
734	.b22f		80 f6		bra $b227	                bra LB209

736	.b231						LB213:
737	.b231		c9 20		cmp #$20	                cmp #$20
738	.b233		90 2b		bcc $b260	                bcc LB242
739	.b235		c9 21		cmp #$21	                cmp #$21
740	.b237		d0 14		bne $b24d	                bne LB22F
741	.b239		a9 80		lda #$80	                lda #$80
742	.b23b		85 26		sta $26		                sta $26
743	.b23d						LB21F:
744	.b23d		20 b6 b1	jsr $b1b6	                jsr LB198
745	.b240		90 05		bcc $b247	                bcc LB229
746	.b242		20 35 b0	jsr $b035	                jsr LB017
747	.b245		80 f6		bra $b23d	                bra LB21F

749	.b247						LB229:
750	.b247		c9 20		cmp #$20	                cmp #$20
751	.b249		90 f2		bcc $b23d	                bcc LB21F
752	.b24b		80 d4		bra $b221	                bra LB203

754	.b24d						LB22F:
755	.b24d		c9 3f		cmp #$3f	                cmp #$3F
756	.b24f		d0 03		bne $b254	                bne LB236
757	.b251		a9 7f		lda #$7f	                lda #$7F
758	.b253		18		clc		                clc
759	.b254						LB236:
760	.b254		90 06		bcc $b25c	                bcc LB23E
761	.b256		c9 7c		cmp #$7c	                cmp #$7C
762	.b258		f0 02		beq $b25c	                beq LB23E
763	.b25a		29 9f		and #$9f	                and #$9F
764	.b25c						LB23E:
765	.b25c		05 26		ora $26		                ora $26
766	.b25e						LB240:
767	.b25e		18		clc		                clc
768	.b25f		60		rts		                rts

770	.b260						LB242:
771	.b260		38		sec		                sec
772	.b261		66 27		ror $27		                ror $27
773	.b263		38		sec		                sec
774	.b264		60		rts		                rts

776	.b265						LB247:
777	.b265		a9 00		lda #$00	                lda #$00
778	.b267		85 f2		sta $f2		                sta $F2
779	.b269		a9 05		lda #$05	                lda #$05
780	.b26b		85 f3		sta $f3		                sta $F3
781	.b26d		a0 00		ldy #$00	                ldy #$00
782	.b26f						LB251:
783	.b26f		20 98 b1	jsr $b198	                jsr LB17A
784	.b272		a6 1f		ldx $1f		                ldx $1F
785	.b274		f0 3e		beq $b2b4	                beq LB296
786	.b276		64 2b		stz $2b		                stz $2B
787	.b278		c9 1b		cmp #$1b	                cmp #$1B
788	.b27a		d0 04		bne $b280	                bne LB262
789	.b27c		a0 00		ldy #$00	                ldy #$00
790	.b27e		80 04		bra $b284	                bra LB266

792	.b280						LB262:
793	.b280		c9 0d		cmp #$0d	                cmp #$0D
794	.b282		d0 0d		bne $b291	                bne LB273
795	.b284						LB266:
796	.b284		a9 0d		lda #$0d	                lda #$0D
797	.b286		91 f2		sta ($f2),y	                sta ($F2),y
798	.b288		24 2b		bit $2b		                bit $2B
799	.b28a		30 03		bmi $b28f	                bmi LB271
800	.b28c		20 e3 ff	jsr $ffe3	                jsr OSASCI
801	.b28f						LB271:
802	.b28f		18		clc		                clc
803	.b290		60		rts		                rts

805	.b291						LB273:
806	.b291		c9 7f		cmp #$7f	                cmp #$7F
807	.b293		d0 07		bne $b29c	                bne LB27E
808	.b295		c0 00		cpy #$00	                cpy #$00
809	.b297		f0 d6		beq $b26f	                beq LB251
810	.b299		88		dey		                dey
811	.b29a		80 13		bra $b2af	                bra LB291

813	.b29c						LB27E:
814	.b29c		c9 7f		cmp #$7f	                cmp #$7F
815	.b29e		b0 cf		bcs $b26f	                bcs LB251
816	.b2a0		c9 20		cmp #$20	                cmp #$20
817	.b2a2		90 cb		bcc $b26f	                bcc LB251
818	.b2a4		c0 ff		cpy #$ff	                cpy #$FF
819	.b2a6		b0 c7		bcs $b26f	                bcs LB251
820	.b2a8		91 f2		sta ($f2),y	                sta ($F2),y
821	.b2aa		c8		iny		                iny
822	.b2ab		24 2b		bit $2b		                bit $2B
823	.b2ad		30 c0		bmi $b26f	                bmi LB251
824	.b2af						LB291:
825	.b2af		20 46 b7	jsr $b746	                jsr LB728
826	.b2b2		80 bb		bra $b26f	                bra LB251

828	.b2b4						LB296:
829	.b2b4		c9 1b		cmp #$1b	                cmp #$1B
830	.b2b6		d0 e4		bne $b29c	                bne LB27E
831	.b2b8		20 84 b1	jsr $b184	                jsr LB166
832	.b2bb		c9 5c		cmp #$5c	                cmp #$5C
833	.b2bd		f0 c5		beq $b284	                beq LB266
834	.b2bf		38		sec		                sec
835	.b2c0		60		rts		                rts

837	.b2c1						LB2A3:
838	.b2c1		a2 19		ldx #$19	                ldx #$19
839	.b2c3						LB2A5:
840	.b2c3		ca		dex		                dex
841	.b2c4		74 00		stz $00,x	                stz $00,x
842	.b2c6		d0 fb		bne $b2c3	                bne LB2A5
843	.b2c8						LB2AA:
844	.b2c8		64 3a		stz $3a		                stz $3A
845	.b2ca		64 3b		stz $3b		                stz $3B
846	.b2cc						LB2AE:
847	.b2cc		20 84 b1	jsr $b184	                jsr LB166
848	.b2cf		b0 2d		bcs $b2fe	                bcs LB2E0
849	.b2d1		20 cb b8	jsr $b8cb	                jsr LB8AD
850	.b2d4		90 2d		bcc $b303	                bcc LB2E5
851	.b2d6		48		pha		                pha
852	.b2d7		a5 3a		lda $3a		                lda $3A
853	.b2d9		95 02		sta $02,x	                sta $02,x
854	.b2db		a5 3b		lda $3b		                lda $3B
855	.b2dd		95 03		sta $03,x	                sta $03,x
856	.b2df		68		pla		                pla
857	.b2e0		c9 40		cmp #$40	                cmp #$40
858	.b2e2		b0 2f		bcs $b313	                bcs LB2F5
859	.b2e4		c9 30		cmp #$30	                cmp #$30
860	.b2e6		90 0d		bcc $b2f5	                bcc LB2D7
861	.b2e8		c9 3c		cmp #$3c	                cmp #$3C
862	.b2ea		b0 15		bcs $b301	                bcs LB2E3
863	.b2ec		e6 00		inc $00		                inc $00
864	.b2ee		e8		inx		                inx
865	.b2ef		e8		inx		                inx
866	.b2f0		e8		inx		                inx
867	.b2f1		e0 18		cpx #$18	                cpx #$18
868	.b2f3		90 d3		bcc $b2c8	                bcc LB2AA
869	.b2f5						LB2D7:
870	.b2f5		c9 40		cmp #$40	                cmp #$40
871	.b2f7		b0 1a		bcs $b313	                bcs LB2F5
872	.b2f9		20 84 b1	jsr $b184	                jsr LB166
873	.b2fc		90 f7		bcc $b2f5	                bcc LB2D7
874	.b2fe						LB2E0:
875	.b2fe		4c a7 b3	jmp $b3a7	                jmp LB389

877	.b301						LB2E3:
878	.b301		95 01		sta $01,x	                sta $01,x
879	.b303						LB2E5:
880	.b303		a5 00		lda $00		                lda $00
881	.b305		d0 c5		bne $b2cc	                bne LB2AE
882	.b307		e6 00		inc $00		                inc $00
883	.b309		80 c1		bra $b2cc	                bra LB2AE

885	.b30b						LB2ED:
886	.b30b		a9 01		lda #$01	                lda #$01
887	.b30d		85 02		sta $02		                sta $02
888	.b30f		64 01		stz $01		                stz $01
889	.b311		64 03		stz $03		                stz $03
890	.b313						LB2F5:
891	.b313		60		rts		                rts

893	.b314						LB2F6:
894	.b314		a9 03		lda #$03	                lda #$03
895	.b316		80 02		bra $b31a	                bra LB2FC

897	.b318						LB2FA:
898	.b318		a9 00		lda #$00	                lda #$00
899	.b31a						LB2FC:
900	.b31a		da		phx		                phx
901	.b31b		aa		tax		                tax
902	.b31c		b5 01		lda $01,x	                lda $01,x
903	.b31e		c9 01		cmp #$01	                cmp #$01
904	.b320		b5 03		lda $03,x	                lda $03,x
905	.b322		f0 01		beq $b325	                beq LB307
906	.b324		38		sec		                sec
907	.b325						LB307:
908	.b325		b5 02		lda $02,x	                lda $02,x
909	.b327		fa		plx		                plx
910	.b328		29 ff		and #$ff	                and #$FF
911	.b32a		60		rts		                rts

913	.b32b						LB30D:
914	.b32b		68		pla		                pla
915	.b32c		85 28		sta $28		                sta $28
916	.b32e		68		pla		                pla
917	.b32f		85 29		sta $29		                sta $29
918	.b331		a5 01		lda $01		                lda $01
919	.b333		d0 21		bne $b356	                bne LB338
920	.b335		a5 02		lda $02		                lda $02
921	.b337		05 03		ora $03		                ora $03
922	.b339		d0 02		bne $b33d	                bne LB31F
923	.b33b		e6 02		inc $02		                inc $02
924	.b33d						LB31F:
925	.b33d		a5 02		lda $02		                lda $02
926	.b33f		d0 02		bne $b343	                bne LB325
927	.b341		c6 03		dec $03		                dec $03
928	.b343						LB325:
929	.b343		c6 02		dec $02		                dec $02
930	.b345		d0 04		bne $b34b	                bne LB32D
931	.b347		a5 03		lda $03		                lda $03
932	.b349		f0 05		beq $b350	                beq LB332
933	.b34b						LB32D:
934	.b34b		20 50 b3	jsr $b350	                jsr LB332
935	.b34e		80 ed		bra $b33d	                bra LB31F

937	.b350						LB332:
938	.b350		a5 29		lda $29		                lda $29
939	.b352		48		pha		                pha
940	.b353		a5 28		lda $28		                lda $28
941	.b355		48		pha		                pha
942	.b356						LB338:
943	.b356		60		rts		                rts

945	.b357						LB339:
946	.b357		c6 1e		dec $1e		                dec $1E
947	.b359		d0 03		bne $b35e	                bne LB340
948	.b35b		20 35 b0	jsr $b035	                jsr LB017
949	.b35e						LB340:
950	.b35e		a5 6f		lda $6f		                lda $6F
951	.b360		d0 04		bne $b366	                bne LB348
952	.b362		a5 21		lda $21		                lda $21
953	.b364		85 20		sta $20		                sta $20
954	.b366						LB348:
955	.b366		60		rts		                rts

957	.b367						LB349:
958	.b367		20 6c b3	jsr $b36c	                jsr LB34E
959	.b36a		80 fb		bra $b367	                bra LB349

961	.b36c						LB34E:
962	.b36c		20 57 b3	jsr $b357	                jsr LB339
963	.b36f		20 8e b1	jsr $b18e	                jsr LB170
964	.b372						LB354:
965	.b372		c9 20		cmp #$20	                cmp #$20
966	.b374		90 09		bcc $b37f	                bcc LB361
967	.b376		4c 46 b7	jmp $b746	                jmp LB728

969	.b379						LB35B:
970	.b379		4c 8a b4	jmp $b48a	                jmp LB46C

972	.b37c						LB35E:
973	.b37c		4c b1 b4	jmp $b4b1	                jmp LB493

975	.b37f						LB361:
976	.b37f		48		pha		                pha
977	.b380		20 0b b3	jsr $b30b	                jsr LB2ED
978	.b383		68		pla		                pla
979	.b384		c9 07		cmp #$07	                cmp #$07
980	.b386		90 51		bcc $b3d9	                bcc LB3BB
981	.b388		f0 7d		beq $b407	                beq LB3E9
982	.b38a		c9 09		cmp #$09	                cmp #$09
983	.b38c		90 eb		bcc $b379	                bcc LB35B
984	.b38e		f0 ec		beq $b37c	                beq LB35E
985	.b390		c9 0b		cmp #$0b	                cmp #$0B
986	.b392		90 78		bcc $b40c	                bcc LB3EE
987	.b394		c9 0d		cmp #$0d	                cmp #$0D
988	.b396		f0 6f		beq $b407	                beq LB3E9
989	.b398		c9 1b		cmp #$1b	                cmp #$1B
990	.b39a		d0 3d		bne $b3d9	                bne LB3BB
991	.b39c						LB37E:
992	.b39c		a6 6f		ldx $6f		                ldx $6F
993	.b39e		d0 04		bne $b3a4	                bne LB386
994	.b3a0		24 2d		bit $2d		                bit $2D
995	.b3a2		30 35		bmi $b3d9	                bmi LB3BB
996	.b3a4						LB386:
997	.b3a4		20 84 b1	jsr $b184	                jsr LB166
998	.b3a7						LB389:
999	.b3a7		c9 1b		cmp #$1b	                cmp #$1B
1000	.b3a9		f0 f1		beq $b39c	                beq LB37E
1001	.b3ab		c9 25		cmp #$25	                cmp #$25
1002	.b3ad		f0 70		beq $b41f	                beq LB401
1003	.b3af		c9 28		cmp #$28	                cmp #$28
1004	.b3b1		f0 6f		beq $b422	                beq LB404
1005	.b3b3		c9 44		cmp #$44	                cmp #$44
1006	.b3b5		f0 55		beq $b40c	                beq LB3EE
1007	.b3b7		c9 45		cmp #$45	                cmp #$45
1008	.b3b9		f0 4e		beq $b409	                beq LB3EB
1009	.b3bb		c9 4d		cmp #$4d	                cmp #$4D
1010	.b3bd		f0 46		beq $b405	                beq LB3E7
1011	.b3bf		c9 50		cmp #$50	                cmp #$50
1012	.b3c1		f0 20		beq $b3e3	                beq LB3C5
1013	.b3c3		c9 5b		cmp #$5b	                cmp #$5B
1014	.b3c5		f0 5e		beq $b425	                beq LB407
1015	.b3c7		c9 5d		cmp #$5d	                cmp #$5D
1016	.b3c9		64 2b		stz $2b		                stz $2B
1017	.b3cb		f0 47		beq $b414	                beq LB3F6
1018	.b3cd		c9 5e		cmp #$5e	                cmp #$5E
1019	.b3cf		f0 40		beq $b411	                beq LB3F3
1020	.b3d1		c9 5f		cmp #$5f	                cmp #$5F
1021	.b3d3		f0 05		beq $b3da	                beq LB3BC
1022	.b3d5		c9 63		cmp #$63	                cmp #$63
1023	.b3d7		f0 43		beq $b41c	                beq LB3FE
1024	.b3d9						LB3BB:
1025	.b3d9		60		rts		                rts

1027	.b3da						LB3BC:
1028	.b3da		20 65 b2	jsr $b265	                jsr LB247
1029	.b3dd		b0 c8		bcs $b3a7	                bcs LB389
1030	.b3df						LB3C1:
1031	.b3df		38		sec		                sec
1032	.b3e0		6c 32 02	jmp ($0232)	                jmp (IND2V)

1034	.b3e3						LB3C5:
1035	.b3e3		38		sec		                sec
1036	.b3e4		66 2b		ror $2b		                ror $2B
1037	.b3e6		20 65 b2	jsr $b265	                jsr LB247
1038	.b3e9		b0 bc		bcs $b3a7	                bcs LB389
1039	.b3eb		a6 1f		ldx $1f		                ldx $1F
1040	.b3ed		64 1f		stz $1f		                stz $1F
1041	.b3ef		f0 11		beq $b402	                beq LB3E4
1042	.b3f1		a0 00		ldy #$00	                ldy #$00
1043	.b3f3		20 bc b8	jsr $b8bc	                jsr LB89E
1044	.b3f6		f0 e1		beq $b3d9	                beq LB3BB
1045	.b3f8		86 6f		stx $6f		                stx $6F
1046	.b3fa		c9 2a		cmp #$2a	                cmp #$2A
1047	.b3fc		f0 1b		beq $b419	                beq LB3FB
1048	.b3fe		c9 21		cmp #$21	                cmp #$21
1049	.b400		f0 dd		beq $b3df	                beq LB3C1
1050	.b402						LB3E4:
1051	.b402		4c 10 b5	jmp $b510	                jmp LB4F2

1053	.b405						LB3E7:
1054	.b405		a9 0b		lda #$0b	                lda #$0B
1055	.b407						LB3E9:
1056	.b407		80 05		bra $b40e	                bra LB3F0

1058	.b409						LB3EB:
1059	.b409		4c e7 ff	jmp $ffe7	                jmp OSNEWL

1061	.b40c						LB3EE:
1062	.b40c		a9 0a		lda #$0a	                lda #$0A
1063	.b40e						LB3F0:
1064	.b40e		4c ee ff	jmp $ffee	                jmp OSWRCH

1066	.b411						LB3F3:
1067	.b411		38		sec		                sec
1068	.b412		66 2b		ror $2b		                ror $2B
1069	.b414						LB3F6:
1070	.b414		20 65 b2	jsr $b265	                jsr LB247
1071	.b417		b0 8e		bcs $b3a7	                bcs LB389
1072	.b419						LB3FB:
1073	.b419		4c 3d b6	jmp $b63d	                jmp LB61F

1075	.b41c						LB3FE:
1076	.b41c		4c 9c af	jmp $af9c	                jmp LAF7E

1078	.b41f						LB401:
1079	.b41f		4c 5e b6	jmp $b65e	                jmp LB640

1081	.b422						LB404:
1082	.b422		4c a9 b6	jmp $b6a9	                jmp LB68B

1084	.b425						LB407:
1085	.b425		20 c1 b2	jsr $b2c1	                jsr LB2A3
1086	.b428		a2 0e		ldx #$0e	                ldx #$0E
1087	.b42a						LB40C:
1088	.b42a		dd 3b b4	cmp $b43b,x	                cmp LB41E-1,x
1089	.b42d		f0 07		beq $b436	                beq LB418
1090	.b42f		ca		dex		                dex
1091	.b430		d0 f8		bne $b42a	                bne LB40C
1092	.b432		38		sec		                sec
1093	.b433		6c 30 02	jmp ($0230)	                jmp (IND1V)

1095	.b436						LB418:
1096	.b436		8a		txa		                txa
1097	.b437		0a		asl a		                asl a
1098	.b438		aa		tax		                tax
1099	.b439		7c 48 b4	jmp ($b448,x)	                jmp (LB42C-2,x)
1100	.b43c						LB41E:
1101	>b43c		41 42				                .byte $41,$42
1102	>b43e		43				                .byte $43
1103	>b43f		44				                .byte $44
1104	>b440		48				                .byte $48
1105	>b441		4a				                .byte $4a
1106	>b442		4b				                .byte $4B
1107	>b443		53				                .byte $53
1108	>b444		58				                .byte $58
1109	>b445		68				                .byte $68
1110	>b446		6c				                .byte $6C
1111	>b447		6e				                .byte $6E
1112	>b448		66				                .byte $66
1113	>b449		63				                .byte $63
1114	.b44a						LB42C:
1115	>b44a		e3 b4				                .word LB4C5
1116	>b44c		a3 b4				                .word LB485
1117	>b44e		b1 b4				                .word LB493
1118	>b450		8a b4				                .word LB46C
1119	>b452		c5 b4				                .word LB4A7
1120	>b454		1b b6				                .word LB5FD
1121	>b456		2b b6				                .word LB60D
1122	>b458		3e b7				                .word LB720
1123	>b45a		ff b5				                .word LB5E1
1124	>b45c		cf b6				                .word LB6B1
1125	>b45e		cb b6				                .word LB6AD
1126	>b460		c7 b5				                .word LB5A9
1127	>b462		c5 b4				                .word LB4A7
1128	>b464		ef b4				                .word LB4D1
1129	.b466						LB448:
1130	.b466		20 6b b4	jsr $b46b	                jsr LB44D
1131	.b469		80 fb		bra $b466	                bra LB448
1132	.b46b						LB44D:
1133	.b46b		20 57 b3	jsr $b357	                jsr LB339
1134	.b46e		20 98 b1	jsr $b198	                jsr LB17A
1135	.b471		c9 1b		cmp #$1b	                cmp #$1B
1136	.b473		d0 0f		bne $b484	                bne LB466
1137	.b475		a9 da		lda #$da	                lda #$DA
1138	.b477		a0 ff		ldy #$ff	                ldy #$FF
1139	.b479		a2 00		ldx #$00	                ldx #$00
1140	.b47b		20 f4 ff	jsr $fff4	                jsr OSBYTE
1141	.b47e		a9 1b		lda #$1b	                lda #$1B
1142	.b480		e0 00		cpx #$00	                cpx #$00
1143	.b482		f0 03		beq $b487	                beq LB469
1144	.b484						LB466:
1145	.b484		4c ee ff	jmp $ffee	                jmp OSWRCH

1147	.b487						LB469:
1148	.b487		4c 9c b3	jmp $b39c	                jmp LB37E

1150	.b48a						LB46C:
1151	.b48a		a9 08		lda #$08	                lda #$08
1152	.b48c		85 2c		sta $2c		                sta $2C
1153	.b48e		20 2b b3	jsr $b32b	                jsr LB30D
1154	.b491		20 3f b8	jsr $b83f	                jsr LB821
1155	.b494		8a		txa		                txa
1156	.b495		d0 07		bne $b49e	                bne LB480
1157	.b497		24 34		bit $34		                bit $34
1158	.b499		10 65		bpl $b500	                bpl LB4E2
1159	.b49b						LB47D:
1160	.b49b		98		tya		                tya
1161	.b49c						LB47E:
1162	.b49c		f0 62		beq $b500	                beq LB4E2
1163	.b49e						LB480:
1164	.b49e		a5 2c		lda $2c		                lda $2C
1165	.b4a0						LB482:
1166	.b4a0		4c ee ff	jmp $ffee	                jmp OSWRCH

1168	.b4a3						LB485:
1169	.b4a3		a9 0a		lda #$0a	                lda #$0A
1170	.b4a5		85 2c		sta $2c		                sta $2C
1171	.b4a7		20 2b b3	jsr $b32b	                jsr LB30D
1172	.b4aa		20 3f b8	jsr $b83f	                jsr LB821
1173	.b4ad						LB48F:
1174	.b4ad		c4 39		cpy $39		                cpy zterm.numRowsMinusOne
1175	.b4af		80 eb		bra $b49c	                bra LB47E

1177	.b4b1						LB493:
1178	.b4b1		a9 09		lda #$09	                lda #$09
1179	.b4b3		85 2c		sta $2c		                sta $2C
1180	.b4b5		20 2b b3	jsr $b32b	                jsr LB30D
1181	.b4b8		20 3f b8	jsr $b83f	                jsr LB821
1182	.b4bb		e4 37		cpx $37		                cpx zterm.numColumnsMinusOne
1183	.b4bd						LB49F:
1184	.b4bd		90 df		bcc $b49e	                bcc LB480
1185	.b4bf		a5 34		lda $34		                lda $34
1186	.b4c1		f0 3d		beq $b500	                beq LB4E2
1187	.b4c3		80 e8		bra $b4ad	                bra LB48F

1189	.b4c5						LB4A7:
1190	.b4c5		20 18 b3	jsr $b318	                jsr LB2FA
1191	.b4c8		b0 36		bcs $b500	                bcs LB4E2
1192	.b4ca		a8		tay		                tay
1193	.b4cb		f0 01		beq $b4ce	                beq LB4B0
1194	.b4cd		88		dey		                dey
1195	.b4ce						LB4B0:
1196	.b4ce		20 14 b3	jsr $b314	                jsr LB2F6
1197	.b4d1		b0 2d		bcs $b500	                bcs LB4E2
1198	.b4d3		aa		tax		                tax
1199	.b4d4		f0 01		beq $b4d7	                beq LB4B9
1200	.b4d6		ca		dex		                dex
1201	.b4d7						LB4B9:
1202	.b4d7		a9 1f		lda #$1f	                lda #$1F
1203	.b4d9		20 ee ff	jsr $ffee	                jsr OSWRCH
1204	.b4dc		8a		txa		                txa
1205	.b4dd		20 ee ff	jsr $ffee	                jsr OSWRCH
1206	.b4e0		98		tya		                tya
1207	.b4e1		80 bd		bra $b4a0	                bra LB482

1209	.b4e3						LB4C5:
1210	.b4e3		a9 0b		lda #$0b	                lda #$0B
1211	.b4e5		85 2c		sta $2c		                sta $2C
1212	.b4e7		20 2b b3	jsr $b32b	                jsr LB30D
1213	.b4ea		20 3f b8	jsr $b83f	                jsr LB821
1214	.b4ed		80 ac		bra $b49b	                bra LB47D

1216	.b4ef						LB4D1:
1217	.b4ef		20 18 b3	jsr $b318	                jsr LB2FA
1218	.b4f2		d0 0c		bne $b500	                bne LB4E2
1219	.b4f4		a8		tay		                tay
1220	.b4f5						LB4D7:
1221	.b4f5		a9 1b		lda #$1b	                lda #$1B
1222	.b4f7						LB4D9:
1223	.b4f7		c8		iny		                iny
1224	.b4f8		20 a1 b0	jsr $b0a1	                jsr LB083
1225	.b4fb		b9 00 b5	lda $b500,y	                lda LB4E2,y
1226	.b4fe		d0 f7		bne $b4f7	                bne LB4D9
1227	.b500						LB4E2:
1228	.b500		60		rts		                rts

1230	>b501		5b				                .byte $5B
1231	>b502		3e 35 63			                .byte $3e,$35,$63
1232	>b505		00				                .byte $00
1233	>b506		5b				                .byte $5B
1234	>b507		30 6e				                .byte $30,$6e
1235	>b509		00				                .byte $00
1236	>b50a		5b				                .byte $5B
1237	>b50b		33				                .byte $33
1238	>b50c		6e 00 5b			                .byte $6e,$00,$5b
1239	>b50f		00				                .byte $00
1240	.b510						LB4F2:
1241	.b510		20 4e b8	jsr $b84e	                jsr LB830
1242	.b513		b0 50		bcs $b565	                bcs LB547
1243	.b515		c9 07		cmp #$07	                cmp #$07
1244	.b517		b0 1d		bcs $b536	                bcs LB518
1245	.b519		48		pha		                pha
1246	.b51a		20 50 b8	jsr $b850	                jsr LB832
1247	.b51d		64 2e		stz $2e		                stz $2E
1248	.b51f		c9 0a		cmp #$0a	                cmp #$0A
1249	.b521		f0 06		beq $b529	                beq LB50B
1250	.b523		c6 2e		dec $2e		                dec $2E
1251	.b525		c9 09		cmp #$09	                cmp #$09
1252	.b527		d0 3b		bne $b564	                bne LB546
1253	.b529						LB50B:
1254	.b529		7a		ply		                ply
1255	.b52a		c0 06		cpy #$06	                cpy #$06
1256	.b52c		d0 05		bne $b533	                bne LB515
1257	.b52e		a5 2e		lda $2e		                lda $2E
1258	.b530		85 34		sta $34		                sta $34
1259	.b532						LB514:
1260	.b532		60		rts		                rts

1262	.b533						LB515:
1263	.b533		4c fe b6	jmp $b6fe	                jmp LB6E0

1265	.b536						LB518:
1266	.b536		c9 08		cmp #$08	                cmp #$08
1267	.b538		f0 1e		beq $b558	                beq LB53A
1268	.b53a		b0 2c		bcs $b568	                bcs LB54A
1269	.b53c						LB51E:
1270	.b53c		20 bc b8	jsr $b8bc	                jsr LB89E
1271	.b53f		f0 f1		beq $b532	                beq LB514
1272	.b541		20 83 b5	jsr $b583	                jsr LB565
1273	.b544		20 bc b8	jsr $b8bc	                jsr LB89E
1274	.b547		f0 0a		beq $b553	                beq LB535
1275	.b549		c9 2c		cmp #$2c	                cmp #$2C
1276	.b54b		d0 18		bne $b565	                bne LB547
1277	.b54d		c8		iny		                iny
1278	.b54e		20 53 b5	jsr $b553	                jsr LB535
1279	.b551		80 e9		bra $b53c	                bra LB51E

1281	.b553						LB535:
1282	.b553		a5 3a		lda $3a		                lda $3A
1283	.b555		4c ee ff	jmp $ffee	                jmp OSWRCH

1285	.b558						LB53A:
1286	.b558		20 bc b8	jsr $b8bc	                jsr LB89E
1287	.b55b		20 83 b5	jsr $b583	                jsr LB565
1288	.b55e		b0 05		bcs $b565	                bcs LB547
1289	.b560		a5 3a		lda $3a		                lda $3A
1290	.b562		80 33		bra $b597	                bra reinitDisplayMode

1292	.b564						LB546:
1293	.b564		68		pla		                pla
1294	.b565						LB547:
1295	.b565		4c d1 b7	jmp $b7d1	                jmp LB7B3

1297	.b568						LB54A:
1298	.b568		a0 00		ldy #$00	                ldy #$00
1299	.b56a		c9 0b		cmp #$0b	                cmp #$0B
1300	.b56c		90 f7		bcc $b565	                bcc LB547
1301	.b56e		f0 0f		beq $b57f	                beq LB561
1302	.b570		c8		iny		                iny
1303	.b571		c9 0e		cmp #$0e	                cmp #$0E
1304	.b573		f0 0a		beq $b57f	                beq LB561
1305	.b575		b0 ee		bcs $b565	                bcs LB547
1306	.b577		a0 04		ldy #$04	                ldy #$04
1307	.b579		c9 0c		cmp #$0c	                cmp #$0C
1308	.b57b		f0 02		beq $b57f	                beq LB561
1309	.b57d		a0 05		ldy #$05	                ldy #$05
1310	.b57f						LB561:
1311	.b57f		98		tya		                tya
1312	.b580		4c 6d b6	jmp $b66d	                jmp LB64F

1314	.b583						LB565:
1315	.b583		20 c7 b8	jsr $b8c7	                jsr LB8A9
1316	.b586		b0 09		bcs $b591	                bcs LB573
1317	.b588						LB56A:
1318	.b588		c8		iny		                iny
1319	.b589		b1 f2		lda ($f2),y	                lda ($F2),y
1320	.b58b		20 cb b8	jsr $b8cb	                jsr LB8AD
1321	.b58e		90 f8		bcc $b588	                bcc LB56A
1322	.b590		18		clc		                clc
1323	.b591						LB573:
1324	.b591		60		rts		                rts

1326	.b592		20 18 b3	jsr $b318	                jsr LB2FA
1327	.b595		b0 ce		bcs $b565	                bcs LB547
1328	.b597						reinitDisplayMode:
1329	.b597		a8		tay		                tay              ;Y = screen mode
1330	.b598		29 7f		and #$7f	                and #$7F         ;mask off shadow bit (unnecessarily!)
1331	.b59a		c9 08		cmp #$08	                cmp #$08
1332	.b59c		b0 c7		bcs $b565	                bcs LB547                    ;branch taken if mode>=8
1333	.b59e		aa		tax		                tax                          ;X = mode number
1334	.b59f		bd bf b5	lda $b5bf,x	                lda screenDimensionsForMode,x                  ;
1335	.b5a2		4a		lsr a		                lsr a       ;A = width -1; C = height flag (1=32 rows,
1336							                            ;0=25 rows)
1337	.b5a3		a2 1f		ldx #$1f	                ldx #$1F                     ;assume 32 rows
1338	.b5a5		b0 02		bcs $b5a9	                bcs +                        ;taken if 32 rows
1339	.b5a7		a2 18		ldx #$18	                ldx #$18                     ;25 rows
1340	.b5a9						+
1341	.b5a9		86 39		stx $39		                stx zterm.numRowsMinusOne    ;store rows
1342	.b5ab		85 37		sta $37		                sta zterm.numColumnsMinusOne ;store columns
1343	.b5ad		1a		inc a		                inc a                        ;compute column count
1344	.b5ae		85 38		sta $38		                sta zterm.numColumns

1346							                ; re-select mode
1347	.b5b0		a9 16		lda #$16	                lda #22
1348	.b5b2		20 ee ff	jsr $ffee	                jsr OSWRCH
1349	.b5b5		98		tya		                tya
1350	.b5b6		20 ee ff	jsr $ffee	                jsr OSWRCH

1352	.b5b9		0a		asl a		                asl a
1353	.b5ba		c9 0e		cmp #$0e	                cmp #$0E                     ;C=1 if Mode 7
1354	.b5bc		66 30		ror $30		                ror $30                      ;?$30 bit 7 set if Mode 7
1355	.b5be		60		rts		                rts

1357	.b5bf						screenDimensionsForMode:
1358	>b5bf		9f				                .byte 79<<1|1 ;mode 0 - 80 columns, 32 rows
1359	>b5c0		4f				                .byte 39<<1|1 ;mode 1 - 40 columns, 32 rows
1360	>b5c1		27				                .byte 19<<1|1 ;mode 2 - 20 columns, 32 rows
1361	>b5c2		9e				                .byte 79<<1|0 ;mode 3 - 80 columns, 25 rows
1362	>b5c3		4f				                .byte 39<<1|1 ;mode 4 - 40 columns, 32 rows
1363	>b5c4		27				                .byte 19<<1|1 ;mode 5 - 20 columns, 32 rows
1364	>b5c5		4e				                .byte 39<<1|0 ;mode 6 - 40 columns, 25 rows
1365	>b5c6		4e				                .byte 39<<1|0 ;mode 7 - 40 columns, 25 rows

1367	.b5c7						LB5A9:
1368	.b5c7		20 18 b3	jsr $b318	                jsr LB2FA
1369	.b5ca		b0 58		bcs $b624	                bcs LB606
1370	.b5cc		c9 05		cmp #$05	                cmp #$05
1371	.b5ce		f0 22		beq $b5f2	                beq LB5D4
1372	.b5d0		c9 06		cmp #$06	                cmp #$06
1373	.b5d2						LB5B4:
1374	.b5d2		d0 50		bne $b624	                bne LB606
1375	.b5d4		20 3f b8	jsr $b83f	                jsr LB821
1376	.b5d7		e8		inx		                inx
1377	.b5d8		da		phx		                phx
1378	.b5d9		c8		iny		                iny
1379	.b5da		5a		phy		                phy
1380	.b5db		a0 0d		ldy #$0d	                ldy #$0D
1381	.b5dd		20 f5 b4	jsr $b4f5	                jsr LB4D7
1382	.b5e0		68		pla		                pla
1383	.b5e1		20 8c b0	jsr $b08c	                jsr LB06E
1384	.b5e4		a9 3b		lda #$3b	                lda #$3B
1385	.b5e6		20 a1 b0	jsr $b0a1	                jsr LB083
1386	.b5e9		68		pla		                pla
1387	.b5ea		20 8c b0	jsr $b08c	                jsr LB06E
1388	.b5ed		a9 52		lda #$52	                lda #$52
1389	.b5ef		4c a1 b0	jmp $b0a1	                jmp LB083

1391	.b5f2						LB5D4:
1392	.b5f2		a0 05		ldy #$05	                ldy #$05
1393	.b5f4		24 19		bit $19		                bit $19
1394	.b5f6		64 19		stz $19		                stz $19
1395	.b5f8		10 02		bpl $b5fc	                bpl LB5DE
1396	.b5fa		a0 09		ldy #$09	                ldy #$09
1397	.b5fc						LB5DE:
1398	.b5fc		4c f5 b4	jmp $b4f5	                jmp LB4D7

1400	.b5ff						LB5E1:
1401	.b5ff		20 3f b8	jsr $b83f	                jsr LB821
1402	.b602		da		phx		                phx
1403	.b603		5a		phy		                phy
1404	.b604		a9 20		lda #$20	                lda #$20
1405	.b606		85 2c		sta $2c		                sta $2C
1406	.b608		20 10 b6	jsr $b610	                jsr LB5F2
1407	.b60b		7a		ply		                ply
1408	.b60c		fa		plx		                plx
1409	.b60d		4c d7 b4	jmp $b4d7	                jmp LB4B9

1411	.b610						LB5F2:
1412	.b610		20 2b b3	jsr $b32b	                jsr LB30D
1413	.b613		20 3f b8	jsr $b83f	                jsr LB821
1414	.b616		e4 38		cpx $38		                cpx zterm.numColumns
1415	.b618		4c bd b4	jmp $b4bd	                jmp LB49F

1417	.b61b						LB5FD:
1418	.b61b		20 18 b3	jsr $b318	                jsr LB2FA
1419	.b61e		b0 04		bcs $b624	                bcs LB606
1420	.b620		c9 03		cmp #$03	                cmp #$03
1421	.b622		90 12		bcc $b636	                bcc LB618
1422	.b624						LB606:
1423	.b624		60		rts		                rts

1425	.b625						LB607:
1426	>b625		0f				                .byte $0F
1427	>b626		13				                .byte $13
1428	.b627		1a		inc a		                inc a
1429	.b628		00		brk #		                brk
1430	.b629		04 0b		tsb $0b		                tsb $0B
1431	.b62b						LB60D:
1432	.b62b		20 18 b3	jsr $b318	                jsr LB2FA
1433	.b62e		b0 f4		bcs $b624	                bcs LB606
1434	.b630		c9 03		cmp #$03	                cmp #$03
1435	.b632		b0 f0		bcs $b624	                bcs LB606
1436	.b634		69 03		adc #$03	                adc #$03
1437	.b636						LB618:
1438	.b636		aa		tax		                tax
1439	.b637		bd 25 b6	lda $b625,x	                lda LB607,x
1440	.b63a		4c 04 b8	jmp $b804	                jmp LB7E6

1442	.b63d						LB61F:
1443	.b63d		a5 20		lda $20		                lda $20
1444	.b63f		25 36		and $36		                and $36
1445	.b641		10 03		bpl $b646	                bpl LB628
1446	.b643		4c d1 b7	jmp $b7d1	                jmp LB7B3

1448	.b646						LB628:
1449	.b646		a9 e5		lda #$e5	                lda #$E5
1450	.b648		20 41 b8	jsr $b841	                jsr osbyteX00Y00
1451	.b64b		a2 00		ldx #$00	                ldx #$00
1452	.b64d		a0 05		ldy #$05	                ldy #$05
1453	.b64f		20 f7 ff	jsr $fff7	                jsr OSCLI
1454	.b652						disableESCAPE:
1455	.b652		a9 e5		lda #$e5	                lda #$E5
1456	.b654		a2 01		ldx #$01	                ldx #$01
1457	.b656		20 43 b8	jsr $b843	                jsr osbyteY00                ;disable ESCAPE key
1458	.b659		a9 7e		lda #$7e	                lda #$7E
1459	.b65b		4c f4 ff	jmp $fff4	                jmp OSBYTE                   ;acknowledge ESCAPE

1461	.b65e						LB640:
1462	.b65e		20 e4 b1	jsr $b1e4	                jsr LB1C6
1463	.b661		c9 07		cmp #$07	                cmp #$07
1464	.b663		90 08		bcc $b66d	                bcc LB64F
1465	.b665		d0 bd		bne $b624	                bne LB606
1466	.b667		20 84 b1	jsr $b184	                jsr LB166
1467	.b66a		4c 72 b3	jmp $b372	                jmp LB354

1469	.b66d						LB64F:
1470	.b66d		85 2a		sta $2a		                sta $2A
1471	.b66f		64 25		stz $25		                stz $25
1472	.b671		64 23		stz $23		                stz $23
1473	.b673		a2 fe		ldx #$fe	                ldx #$FE
1474	.b675		9a		txs		                txs
1475	.b676		e8		inx		                inx
1476	.b677		86 22		stx $22		                stx $22
1477	.b679		a5 2a		lda $2a		                lda $2A
1478	.b67b		c9 06		cmp #$06	                cmp #$06
1479	.b67d		90 04		bcc $b683	                bcc LB665
1480	.b67f		66 23		ror $23		                ror $23
1481	.b681		80 08		bra $b68b	                bra LB66D

1483	.b683						LB665:
1484	.b683		c9 04		cmp #$04	                cmp #$04
1485	.b685		90 12		bcc $b699	                bcc LB67B
1486	.b687		f0 06		beq $b68f	                beq LB671
1487	.b689		66 25		ror $25		                ror $25
1488	.b68b						LB66D:
1489	.b68b		64 27		stz $27		                stz $27
1490	.b68d		46 22		lsr $22		                lsr $22
1491	.b68f						LB671:
1492	.b68f		66 30		ror $30		                ror $30
1493	.b691		a9 21		lda #$21	                lda #$21
1494	.b693		20 04 b8	jsr $b804	                jsr LB7E6
1495	.b696		4c 66 b4	jmp $b466	                jmp LB448

1497	.b699						LB67B:
1498	.b699		64 30		stz $30		                stz $30
1499	.b69b		4a		lsr a		                lsr a
1500	.b69c		66 2d		ror $2d		                ror $2D
1501	.b69e		4a		lsr a		                lsr a
1502	.b69f		66 22		ror $22		                ror $22
1503	.b6a1		a9 1e		lda #$1e	                lda #$1E
1504	.b6a3		20 04 b8	jsr $b804	                jsr LB7E6
1505	.b6a6		4c 67 b3	jmp $b367	                jmp LB349

1507	.b6a9						LB68B:
1508	.b6a9		20 e4 b1	jsr $b1e4	                jsr LB1C6
1509	.b6ac		90 0b		bcc $b6b9	                bcc LB69B
1510	.b6ae						LB690:
1511	.b6ae		4a		lsr a		                lsr a
1512	.b6af		29 04		and #$04	                and #$04
1513	.b6b1		d0 07		bne $b6ba	                bne LB69C
1514	.b6b3		6a		ror a		                ror a
1515	.b6b4		4a		lsr a		                lsr a
1516	.b6b5		69 40		adc #$40	                adc #$40
1517	.b6b7		85 33		sta $33		                sta $33
1518	.b6b9						LB69B:
1519	.b6b9		60		rts		                rts

1521	.b6ba						LB69C:
1522	.b6ba		64 33		stz $33		                stz $33
1523	.b6bc		a2 60		ldx #$60	                ldx #$60
1524	.b6be		a0 23		ldy #$23	                ldy #$23
1525	.b6c0		90 04		bcc $b6c6	                bcc LB6A8
1526	.b6c2		da		phx		                phx
1527	.b6c3		5a		phy		                phy
1528	.b6c4		fa		plx		                plx
1529	.b6c5		7a		ply		                ply
1530	.b6c6						LB6A8:
1531	.b6c6		86 31		stx $31		                stx $31
1532	.b6c8		84 32		sty $32		                sty $32
1533	.b6ca		60		rts		                rts

1535	.b6cb						LB6AD:
1536	.b6cb		a9 00		lda #$00	                lda #$00
1537	.b6cd		80 02		bra $b6d1	                bra LB6B3

1539	.b6cf						LB6B1:
1540	.b6cf		a9 ff		lda #$ff	                lda #$FF
1541	.b6d1						LB6B3:
1542	.b6d1		85 2e		sta $2e		                sta $2E
1543	.b6d3		64 2f		stz $2f		                stz $2F
1544	.b6d5						LB6B7:
1545	.b6d5		a6 2f		ldx $2f		                ldx $2F
1546	.b6d7		e8		inx		                inx
1547	.b6d8		e8		inx		                inx
1548	.b6d9		e8		inx		                inx
1549	.b6da		e0 1b		cpx #$1b	                cpx #$1B
1550	.b6dc		f0 1f		beq $b6fd	                beq LB6DF
1551	.b6de		86 2f		stx $2f		                stx $2F
1552	.b6e0		20 e5 b6	jsr $b6e5	                jsr LB6C7
1553	.b6e3		80 f0		bra $b6d5	                bra LB6B7

1555	.b6e5						LB6C7:
1556	.b6e5		bc ff ff	ldy $ffff,x	                ldy $FFFF,x
1557	.b6e8		b5 00		lda $00,x	                lda $00,x
1558	.b6ea		d0 11		bne $b6fd	                bne LB6DF
1559	.b6ec		bd fe ff	lda $fffe,x	                lda LFFFE,x
1560	.b6ef		c9 3e		cmp #$3e	                cmp #$3E
1561	.b6f1		90 0a		bcc $b6fd	                bcc LB6DF
1562	.b6f3		f0 09		beq $b6fe	                beq LB6E0
1563	.b6f5		a5 2e		lda $2e		                lda $2E
1564	.b6f7		c0 07		cpy #$07	                cpy #$07
1565	.b6f9		d0 02		bne $b6fd	                bne LB6DF
1566	.b6fb		85 34		sta $34		                sta $34
1567	.b6fd						LB6DF:
1568	.b6fd		60		rts		                rts

1570	.b6fe						LB6E0:
1571	.b6fe		a5 2e		lda $2e		                lda $2E
1572	.b700		c0 01		cpy #$01	                cpy #$01
1573	.b702		b0 07		bcs $b70b	                bcs LB6ED
1574	.b704		1a		inc a		                inc a
1575	.b705		0a		asl a		                asl a
1576	.b706		aa		tax		                tax
1577	.b707		a9 04		lda #$04	                lda #$04
1578	.b709		80 09		bra $b714	                bra LB6F6

1580	.b70b						LB6ED:
1581	.b70b		d0 0a		bne $b717	                bne LB6F9
1582	.b70d		aa		tax		                tax
1583	.b70e		f0 02		beq $b712	                beq LB6F4
1584	.b710		a2 21		ldx #$21	                ldx #$21
1585	.b712						LB6F4:
1586	.b712		a9 cb		lda #$cb	                lda #$CB
1587	.b714						LB6F6:
1588	.b714		4c 43 b8	jmp $b843	                jmp osbyteY00

1590	.b717						LB6F9:
1591	.b717		c0 03		cpy #$03	                cpy #$03
1592	.b719		b0 0a		bcs $b725	                bcs LB707
1593	.b71b		24 20		bit $20		                bit $20
1594	.b71d		10 03		bpl $b722	                bpl LB704
1595	.b71f		a8		tay		                tay
1596	.b720		f0 db		beq $b6fd	                beq LB6DF
1597	.b722						LB704:
1598	.b722		85 36		sta $36		                sta $36
1599	.b724						LB706:
1600	.b724		60		rts		                rts

1602	.b725						LB707:
1603	.b725		d0 09		bne $b730	                bne LB712
1604	.b727		2a		rol a		                rol a
1605	.b728		a9 00		lda #$00	                lda #$00
1606	.b72a						LB70C:
1607	.b72a		2a		rol a		                rol a
1608	.b72b		aa		tax		                tax
1609	.b72c		a9 60		lda #$60	                lda #$60
1610	.b72e		80 e4		bra $b714	                bra LB6F6

1612	.b730						LB712:
1613	.b730		c0 05		cpy #$05	                cpy #$05
1614	.b732		b0 05		bcs $b739	                bcs LB71B
1615	.b734		2a		rol a		                rol a
1616	.b735		a9 01		lda #$01	                lda #$01
1617	.b737		80 f1		bra $b72a	                bra LB70C

1619	.b739						LB71B:
1620	.b739		d0 e9		bne $b724	                bne LB706
1621	.b73b		85 35		sta $35		                sta $35
1622	.b73d		60		rts		                rts

1624	.b73e						LB720:
1625	.b73e		20 2b b3	jsr $b32b	                jsr LB30D
1626	.b741		a9 23		lda #$23	                lda #$23
1627	.b743		4c 04 b8	jmp $b804	                jmp LB7E6

1629	.b746						LB728:
1630	.b746		5a		phy		                phy
1631	.b747		da		phx		                phx
1632	.b748		48		pha		                pha
1633	.b749		24 30		bit $30		                bit $30
1634	.b74b		30 1d		bmi $b76a	                bmi LB74C
1635	.b74d		c9 40		cmp #$40	                cmp #$40
1636	.b74f		90 06		bcc $b757	                bcc LB739
1637	.b751		a8		tay		                tay
1638	.b752		30 03		bmi $b757	                bmi LB739
1639	.b754		18		clc		                clc
1640	.b755		65 33		adc $33		                adc $33
1641	.b757						LB739:
1642	.b757		a8		tay		                tay
1643	.b758		c0 60		cpy #$60	                cpy #$60
1644	.b75a		d0 02		bne $b75e	                bne LB740
1645	.b75c		a9 bb		lda #$bb	                lda #$BB
1646	.b75e						LB740:
1647	.b75e		c0 bb		cpy #$bb	                cpy #$BB
1648	.b760		d0 02		bne $b764	                bne LB746
1649	.b762		a5 32		lda $32		                lda $32
1650	.b764						LB746:
1651	.b764		c0 23		cpy #$23	                cpy #$23
1652	.b766		d0 02		bne $b76a	                bne LB74C
1653	.b768		a5 31		lda $31		                lda $31
1654	.b76a						LB74C:
1655	.b76a		48		pha		                pha
1656	.b76b		20 3f b8	jsr $b83f	                jsr LB821
1657	.b76e		e4 38		cpx $38		                cpx zterm.numColumns
1658	.b770		f0 0a		beq $b77c	                beq LB75E
1659	.b772						LB754:
1660	.b772		68		pla		                pla
1661	.b773		20 ee ff	jsr $ffee	                jsr OSWRCH
1662	.b776		48		pha		                pha
1663	.b777						LB759:
1664	.b777		68		pla		                pla
1665	.b778		68		pla		                pla
1666	.b779		fa		plx		                plx
1667	.b77a		7a		ply		                ply
1668	.b77b		60		rts		                rts

1670	.b77c						LB75E:
1671	.b77c		24 34		bit $34		                bit $34
1672	.b77e		10 f7		bpl $b777	                bpl LB759
1673	.b780		24 35		bit $35		                bit $35
1674	.b782		10 ee		bpl $b772	                bpl LB754
1675	.b784		68		pla		                pla
1676	.b785		48		pha		                pha
1677	.b786		c9 20		cmp #$20	                cmp #$20
1678	.b788		90 e8		bcc $b772	                bcc LB754
1679	.b78a		d0 05		bne $b791	                bne LB773
1680	.b78c		20 e7 ff	jsr $ffe7	                jsr OSNEWL
1681	.b78f		80 e6		bra $b777	                bra LB759

1683	.b791						LB773:
1684	.b791		a9 0d		lda #$0d	                lda #$0D
1685	.b793		20 ee ff	jsr $ffee	                jsr OSWRCH
1686	.b796		20 d7 b4	jsr $b4d7	                jsr LB4B9
1687	.b799		a0 00		ldy #$00	                ldy #$00
1688	.b79b						LB77D:
1689	.b79b		5a		phy		                phy
1690	.b79c		a9 08		lda #$08	                lda #$08
1691	.b79e		20 ee ff	jsr $ffee	                jsr OSWRCH
1692	.b7a1		a9 87		lda #$87	                lda #$87
1693	.b7a3		20 f4 ff	jsr $fff4	                jsr OSBYTE
1694	.b7a6		7a		ply		                ply
1695	.b7a7		8a		txa		                txa
1696	.b7a8		c9 20		cmp #$20	                cmp #$20
1697	.b7aa		f0 0d		beq $b7b9	                beq LB79B
1698	.b7ac		99 40 04	sta $0440,y	                sta $0440,y
1699	.b7af		c8		iny		                iny
1700	.b7b0		c4 38		cpy $38		                cpy zterm.numColumns
1701	.b7b2		d0 e7		bne $b79b	                bne LB77D
1702	.b7b4		20 e7 ff	jsr $ffe7	                jsr OSNEWL
1703	.b7b7		80 b9		bra $b772	                bra LB754

1705	.b7b9						LB79B:
1706	.b7b9		5a		phy		                phy
1707	.b7ba		a9 00		lda #$00	                lda #$00
1708	.b7bc		20 04 b8	jsr $b804	                jsr LB7E6
1709	.b7bf		20 e7 ff	jsr $ffe7	                jsr OSNEWL
1710	.b7c2		7a		ply		                ply
1711	.b7c3		c8		iny		                iny
1712	.b7c4						LB7A6:
1713	.b7c4		88		dey		                dey
1714	.b7c5		f0 ab		beq $b772	                beq LB754
1715	.b7c7		b9 3f 04	lda $043f,y	                lda $043F,y
1716	.b7ca		20 ee ff	jsr $ffee	                jsr OSWRCH
1717	.b7cd		80 f5		bra $b7c4	                bra LB7A6

1719	.b7cf						terminalINDnHandler:
1720	.b7cf		90 46		bcc $b817	                bcc LB7F9
1721	.b7d1						LB7B3:
1722	.b7d1		38		sec		                sec
1723	.b7d2		66 19		ror $19		                ror $19
1724	.b7d4						LB7B6:
1725	.b7d4		a2 32		ldx #$32	                ldx #$32
1726	.b7d6						LB7B8:
1727	.b7d6		a9 d5		lda #$d5	                lda #$D5
1728	.b7d8		20 43 b8	jsr $b843	                jsr osbyteY00
1729	.b7db		da		phx		                phx
1730	.b7dc		a2 01		ldx #$01	                ldx #$01
1731	.b7de		a9 d6		lda #$d6	                lda #$D6
1732	.b7e0		20 43 b8	jsr $b843	                jsr osbyteY00
1733	.b7e3		da		phx		                phx
1734	.b7e4		a9 ec		lda #$ec	                lda #$EC
1735	.b7e6		a2 14		ldx #$14	                ldx #$14
1736	.b7e8		20 43 b8	jsr $b843	                jsr osbyteY00
1737	.b7eb		a9 07		lda #$07	                lda #$07
1738	.b7ed		20 ee ff	jsr $ffee	                jsr OSWRCH
1739	.b7f0		a9 ec		lda #$ec	                lda #$EC
1740	.b7f2		20 43 b8	jsr $b843	                jsr osbyteY00
1741	.b7f5		fa		plx		                plx
1742	.b7f6		a9 d6		lda #$d6	                lda #$D6
1743	.b7f8		20 43 b8	jsr $b843	                jsr osbyteY00
1744	.b7fb		fa		plx		                plx
1745	.b7fc		a9 d5		lda #$d5	                lda #$D5
1746	.b7fe		80 43		bra $b843	                bra osbyteY00

1748	.b800						LB7E2:
1749	.b800		a2 8c		ldx #$8c	                ldx #$8C
1750	.b802		80 d2		bra $b7d6	                bra LB7B8

1752	.b804						LB7E6:
1753	.b804		a8		tay		                tay
1754	.b805		a2 0a		ldx #$0a	                ldx #$0A
1755	.b807		a9 97		lda #$97	                lda #$97
1756	.b809						LB7EB:
1757	.b809		0a		asl a		                asl a
1758	.b80a		b0 01		bcs $b80d	                bcs LB7EF
1759	.b80c		c8		iny		                iny
1760	.b80d						LB7EF:
1761	.b80d		4a		lsr a		                lsr a
1762	.b80e		20 ee ff	jsr $ffee	                jsr OSWRCH
1763	.b811		b9 18 b8	lda $b818,y	                lda LB7FA,y
1764	.b814		ca		dex		                dex
1765	.b815		d0 f2		bne $b809	                bne LB7EB
1766	.b817						LB7F9:
1767	.b817		60		rts		                rts

1769	.b818						LB7FA:
1770							                ; PHP
1771							                ; ORA $06
1772							                ; BRA LB807

1774							                ; TSB $05
1775							                ; BRK
1776							                ; BRK
1777							                ; ORA ($80,x)
1778							                ; PHP
1779							                ; TSB $06
1780							                ; BRA LB812

1782							                ; ORA $0A
1783							                ; BRA LB816

1785							                ; BRK
1786							                ; ORA $00
1787							                ; BRK
1788	>b818		08				                .byte $08
1789	>b819		05				                .byte $05
1790	>b81a		06				                .byte $06
1791	>b81b		80				                .byte $80
1792	>b81c		08				                .byte $08
1793	>b81d		04				                .byte $04
1794	>b81e		05				                .byte $05
1795	>b81f		00				                .byte $00
1796	>b820		00				                .byte $00
1797	>b821		01				                .byte $01
1798	>b822		80				                .byte $80
1799	>b823		08				                .byte $08
1800	>b824		04				                .byte $04
1801	>b825		06				                .byte $06
1802	>b826		80				                .byte $80
1803	>b827		08				                .byte $08
1804	>b828		05				                .byte $05
1805	>b829		0a				                .byte $0A
1806	>b82a		80				                .byte $80
1807	>b82b		08				                .byte $08
1808	>b82c		00				                .byte $00
1809	>b82d		05				                .byte $05
1810	>b82e		00				                .byte $00
1811	>b82f		00				                .byte $00

1813	.b830						LB812:
1814							;ORA (&80,x)      :\ B812= 01 80       ..
1815	>b830		01				                .byte $01
1816	>b831		80				                .byte $80
1817							;PHP              :\ B814= 08          .
1818	>b832		08				                .byte $08
1819							;BRK              :\ B815= 00          .
1820	>b833		00				                .byte $00
1821							;.LB816
1822							;ASL A            :\ B816= 0A          .
1823	>b834		0a				                .byte $0A
1824							;BRA LB829        :\ B817= 80 10       ..
1825	>b835		80				                .byte $80
1826	>b836		10				                .byte $10
1827							;ORA (&80,x)      :\ B819= 01 80       ..
1828	>b837		01				                .byte $01
1829	>b838		80				                .byte $80
1830							;BPL LB79D        :\ B81B= 10 80       ..
1831	>b839		10				                .byte $10
1832	>b83a		80				                .byte $80
1833	>b83b		07				                .byte $07
1834	>b83c		00				                .byte $00
1835	>b83d		03				                .byte $03
1836							;BRA LB7CB        :\ B820= 80 A9       .)
1837							; LDA &A2          :\ B822= A5 A2       %"
1838							; BRK              :\ B824= 00          .
1839	>b83e		80				                .byte $80
1840	.b83f						LB821:
1841	.b83f		a9 a5		lda #$a5	                lda #$A5
1842	.b841						osbyteX00Y00:
1843	.b841		a2 00		ldx #$00	                ldx #$00
1844	.b843						osbyteY00:
1845	.b843		a0 00		ldy #$00	                ldy #$00
1846	.b845						-
1847	.b845		4c f4 ff	jmp $fff4	                jmp OSBYTE

1849	.b848						LB82A:
1850	.b848		a9 9c		lda #$9c	                lda #$9C
1851	.b84a		a0 9f		ldy #$9f	                ldy #$9F
1852	.b84c		80 f7		bra $b845	                bra -

1854	.b84e						LB830:
1855	.b84e		a0 00		ldy #$00	                ldy #$00
1856	.b850						LB832:
1857	.b850		a2 ff		ldx #$ff	                ldx #$FF
1858	.b852		da		phx		                phx
1859	.b853						LB835:
1860	.b853		68		pla		                pla
1861	.b854		1a		inc a		                inc a
1862	.b855		48		pha		                pha
1863	.b856		5a		phy		                phy
1864	.b857		20 bc b8	jsr $b8bc	                jsr LB89E
1865	.b85a						LB83C:
1866	.b85a		c9 2e		cmp #$2e	                cmp #'.'
1867	.b85c		f0 18		beq $b876	                beq LB858
1868	.b85e		c9 40		cmp #$40	                cmp #'@'
1869	.b860		b0 02		bcs $b864	                bcs LB846
1870	.b862		a9 00		lda #$00	                lda #$00
1871	.b864						LB846:
1872	.b864		29 5f		and #$5f	                and #$5F
1873	.b866		e8		inx		                inx
1874	.b867		5d 89 b8	eor $b889,x	                eor LB86B,x
1875	.b86a		f0 05		beq $b871	                beq LB853
1876	.b86c		0a		asl a		                asl a
1877	.b86d		f0 07		beq $b876	                beq LB858
1878	.b86f		80 0a		bra $b87b	                bra LB85D

1880	.b871						LB853:
1881	.b871		c8		iny		                iny
1882	.b872		b1 f2		lda ($f2),y	                lda ($F2),y
1883	.b874		80 e4		bra $b85a	                bra LB83C

1885	.b876						LB858:
1886	.b876		c8		iny		                iny
1887	.b877		68		pla		                pla
1888	.b878		68		pla		                pla
1889	.b879		18		clc		                clc
1890	.b87a		60		rts		                rts

1892	.b87b						LB85D:
1893	.b87b		7a		ply		                ply
1894	.b87c						LB85E:
1895	.b87c		bd 89 b8	lda $b889,x	                lda LB86B,x
1896	.b87f		d0 03		bne $b884	                bne LB866
1897	.b881		38		sec		                sec
1898	.b882		68		pla		                pla
1899	.b883		60		rts		                rts

1901	.b884						LB866:
1902	.b884		30 cd		bmi $b853	                bmi LB835
1903	.b886		e8		inx		                inx
1904	.b887		80 f3		bra $b87c	                bra LB85E

1906	.b889						LB86B:
1907	>b889		43				                .byte $43
1908	>b88a		4b				                .byte $4B
1909	>b88b		cc 4d 43			                .byte $cc,$4d,$43
1910	>b88e		cc 50 52			                .byte $cc,$50,$52
1911	>b891		4f				                .byte $4F
1912	>b892		d4				                .byte $D4
1913	>b893		52 46				                .byte $52,$46
1914	>b895		c3				                .byte $C3
1915	>b896		54				                .byte $54
1916	>b897		46 c3				                .byte $46,$c3
1917	>b899		57				                .byte $57
1918	>b89a		57				                .byte $57
1919	>b89b		cd 41 57			                .byte $cd,$41,$57
1920	>b89e		cd 56 44			                .byte $cd,$56,$44
1921	>b8a1		d5 4d				                .byte $d5,$4d
1922	>b8a3		4f				                .byte $4F
1923	>b8a4		44				                .byte $44
1924	>b8a5		c5 4f				                .byte $c5,$4f
1925	>b8a7		ce 4f 46			                .byte $ce,$4f,$46
1926	>b8aa		c6 54				                .byte $c6,$54
1927	>b8ac		45 52				                .byte $45,$52
1928	>b8ae		4d 49 4e			                .byte $4d,$49,$4e
1929	>b8b1		41 cc				                .byte $41,$cc
1930	>b8b3		42				                .byte $42
1931	>b8b4		42				                .byte $42
1932	>b8b5		c3				                .byte $C3
1933	>b8b6		47				                .byte $47
1934	>b8b7		d3				                .byte $D3
1935	>b8b8		54				                .byte $54
1936	>b8b9		54				                .byte $54
1937	>b8ba		d9				                .byte $D9
1938	>b8bb		00				                .byte $00
1939	.b8bc						LB89E:
1940	.b8bc		88		dey		                dey
1941	.b8bd						LB89F:
1942	.b8bd		c8		iny		                iny
1943	.b8be		b1 f2		lda ($f2),y	                lda ($F2),y
1944	.b8c0		c9 20		cmp #$20	                cmp #$20
1945	.b8c2		f0 f9		beq $b8bd	                beq LB89F
1946	.b8c4		c9 0d		cmp #$0d	                cmp #$0D
1947	.b8c6		60		rts		                rts

1949	.b8c7						LB8A9:
1950	.b8c7		64 3a		stz $3a		                stz $3A
1951	.b8c9		64 3b		stz $3b		                stz $3B
1952	.b8cb						LB8AD:
1953	.b8cb		c9 30		cmp #$30	                cmp #$30
1954	.b8cd		90 04		bcc $b8d3	                bcc LB8B5
1955	.b8cf		c9 3a		cmp #$3a	                cmp #$3A
1956	.b8d1		90 02		bcc $b8d5	                bcc LB8B7
1957	.b8d3						LB8B5:
1958	.b8d3		38		sec		                sec
1959	.b8d4		60		rts		                rts

1961	.b8d5						LB8B7:
1962	.b8d5		e9 2f		sbc #$2f	                sbc #$2F
1963	.b8d7		48		pha		                pha
1964	.b8d8		a5 3b		lda $3b		                lda $3B
1965	.b8da		48		pha		                pha
1966	.b8db		a5 3a		lda $3a		                lda $3A
1967	.b8dd		0a		asl a		                asl a
1968	.b8de		26 3b		rol $3b		                rol $3B
1969	.b8e0		0a		asl a		                asl a
1970	.b8e1		26 3b		rol $3b		                rol $3B
1971	.b8e3		18		clc		                clc
1972	.b8e4		65 3a		adc $3a		                adc $3A
1973	.b8e6		85 3a		sta $3a		                sta $3A
1974	.b8e8		68		pla		                pla
1975	.b8e9		65 3b		adc $3b		                adc $3B
1976	.b8eb		85 3b		sta $3b		                sta $3B
1977	.b8ed		06 3a		asl $3a		                asl $3A
1978	.b8ef		26 3b		rol $3b		                rol $3B
1979	.b8f1		68		pla		                pla
1980	.b8f2		18		clc		                clc
1981	.b8f3		65 3a		adc $3a		                adc $3A
1982	.b8f5		85 3a		sta $3a		                sta $3A
1983	.b8f7		90 03		bcc $b8fc	                bcc LB8DE
1984	.b8f9		e6 3b		inc $3b		                inc $3B
1985	.b8fb		18		clc		                clc
1986	.b8fc						LB8DE:
1987	.b8fc		60		rts		                rts


:7	;******  Return to file: src/terminal.s65

6925							                .endif

6927							                .if version==350&&!includeTerminalROM
6929							                .endif

6931							                .if version>=500||!includeTerminalROM
6933							                .endif

6935							;-------------------------------------------------------------------------

6937							; Unused space
6938							; ============
6939	>b8fd		ff ff ff			                .fill $b900-*,$ff

6941							; Default font
6942							; ============
6943	.b900						LB900:
6944							                .cerror (<LB900)!=0,"font data must be page aligned"
6945							                ; CHR$32 -
6946	>b900		00				                .byte %00000000
6947	>b901		00				                .byte %00000000
6948	>b902		00				                .byte %00000000
6949	>b903		00				                .byte %00000000
6950	>b904		00				                .byte %00000000
6951	>b905		00				                .byte %00000000
6952	>b906		00				                .byte %00000000
6953	>b907		00				                .byte %00000000

6955							                ; CHR$33 - !
6956	>b908		18				                .byte %00011000
6957	>b909		18				                .byte %00011000
6958	>b90a		18				                .byte %00011000
6959	>b90b		18				                .byte %00011000
6960	>b90c		18				                .byte %00011000
6961	>b90d		00				                .byte %00000000
6962	>b90e		18				                .byte %00011000
6963	>b90f		00				                .byte %00000000

6965							                ; CHR$34 - "
6966	>b910		6c				                .byte %01101100
6967	>b911		6c				                .byte %01101100
6968	>b912		6c				                .byte %01101100
6969	>b913		00				                .byte %00000000
6970	>b914		00				                .byte %00000000
6971	>b915		00				                .byte %00000000
6972	>b916		00				                .byte %00000000
6973	>b917		00				                .byte %00000000

6975							                ; CHR$35 - #
6976	>b918		36				                .byte %00110110
6977	>b919		36				                .byte %00110110
6978	>b91a		7f				                .byte %01111111
6979	>b91b		36				                .byte %00110110
6980	>b91c		7f				                .byte %01111111
6981	>b91d		36				                .byte %00110110
6982	>b91e		36				                .byte %00110110
6983	>b91f		00				                .byte %00000000

6985							                ; CHR$36 - $
6986	>b920		0c				                .byte %00001100
6987	>b921		3f				                .byte %00111111
6988	>b922		68				                .byte %01101000
6989	>b923		3e				                .byte %00111110
6990	>b924		0b				                .byte %00001011
6991	>b925		7e				                .byte %01111110
6992	>b926		18				                .byte %00011000
6993	>b927		00				                .byte %00000000

6995							                ; CHR$37 - %
6996	>b928		60				                .byte %01100000
6997	>b929		66				                .byte %01100110
6998	>b92a		0c				                .byte %00001100
6999	>b92b		18				                .byte %00011000
7000	>b92c		30				                .byte %00110000
7001	>b92d		66				                .byte %01100110
7002	>b92e		06				                .byte %00000110
7003	>b92f		00				                .byte %00000000

7005							                ; CHR$38 - &
7006	>b930		38				                .byte %00111000
7007	>b931		6c				                .byte %01101100
7008	>b932		6c				                .byte %01101100
7009	>b933		38				                .byte %00111000
7010	>b934		6d				                .byte %01101101
7011	>b935		66				                .byte %01100110
7012	>b936		3b				                .byte %00111011
7013	>b937		00				                .byte %00000000

7015							                ; CHR$39 - '
7016	>b938		0c				                .byte %00001100
7017	>b939		18				                .byte %00011000
7018	>b93a		30				                .byte %00110000
7019	>b93b		00				                .byte %00000000
7020	>b93c		00				                .byte %00000000
7021	>b93d		00				                .byte %00000000
7022	>b93e		00				                .byte %00000000
7023	>b93f		00				                .byte %00000000

7025							                ; CHR$40 - (
7026	>b940		0c				                .byte %00001100
7027	>b941		18				                .byte %00011000
7028	>b942		30				                .byte %00110000
7029	>b943		30				                .byte %00110000
7030	>b944		30				                .byte %00110000
7031	>b945		18				                .byte %00011000
7032	>b946		0c				                .byte %00001100
7033	>b947		00				                .byte %00000000

7035							                ; CHR$41 - )
7036	>b948		30				                .byte %00110000
7037	>b949		18				                .byte %00011000
7038	>b94a		0c				                .byte %00001100
7039	>b94b		0c				                .byte %00001100
7040	>b94c		0c				                .byte %00001100
7041	>b94d		18				                .byte %00011000
7042	>b94e		30				                .byte %00110000
7043	>b94f		00				                .byte %00000000

7045							                ; CHR$42 - *
7046	>b950		00				                .byte %00000000
7047	>b951		18				                .byte %00011000
7048	>b952		7e				                .byte %01111110
7049	>b953		3c				                .byte %00111100
7050	>b954		7e				                .byte %01111110
7051	>b955		18				                .byte %00011000
7052	>b956		00				                .byte %00000000
7053	>b957		00				                .byte %00000000

7055							                ; CHR$43 - +
7056	>b958		00				                .byte %00000000
7057	>b959		18				                .byte %00011000
7058	>b95a		18				                .byte %00011000
7059	>b95b		7e				                .byte %01111110
7060	>b95c		18				                .byte %00011000
7061	>b95d		18				                .byte %00011000
7062	>b95e		00				                .byte %00000000
7063	>b95f		00				                .byte %00000000

7065							                ; CHR$44 - ,
7066	>b960		00				                .byte %00000000
7067	>b961		00				                .byte %00000000
7068	>b962		00				                .byte %00000000
7069	>b963		00				                .byte %00000000
7070	>b964		00				                .byte %00000000
7071	>b965		18				                .byte %00011000
7072	>b966		18				                .byte %00011000
7073	>b967		30				                .byte %00110000

7075							                ; CHR$45 - -
7076	>b968		00				                .byte %00000000
7077	>b969		00				                .byte %00000000
7078	>b96a		00				                .byte %00000000
7079	>b96b		7e				                .byte %01111110
7080	>b96c		00				                .byte %00000000
7081	>b96d		00				                .byte %00000000
7082	>b96e		00				                .byte %00000000
7083	>b96f		00				                .byte %00000000

7085							                ; CHR$46 - .
7086	>b970		00				                .byte %00000000
7087	>b971		00				                .byte %00000000
7088	>b972		00				                .byte %00000000
7089	>b973		00				                .byte %00000000
7090	>b974		00				                .byte %00000000
7091	>b975		18				                .byte %00011000
7092	>b976		18				                .byte %00011000
7093	>b977		00				                .byte %00000000

7095							                ; CHR$47 - /
7096	>b978		00				                .byte %00000000
7097	>b979		06				                .byte %00000110
7098	>b97a		0c				                .byte %00001100
7099	>b97b		18				                .byte %00011000
7100	>b97c		30				                .byte %00110000
7101	>b97d		60				                .byte %01100000
7102	>b97e		00				                .byte %00000000
7103	>b97f		00				                .byte %00000000

7105							                ; CHR$48 - 0
7106	>b980		3c				                .byte %00111100
7107	>b981		66				                .byte %01100110
7108	>b982		6e				                .byte %01101110
7109	>b983		7e				                .byte %01111110
7110	>b984		76				                .byte %01110110
7111	>b985		66				                .byte %01100110
7112	>b986		3c				                .byte %00111100
7113	>b987		00				                .byte %00000000

7115							                ; CHR$49 - 1
7116	>b988		18				                .byte %00011000
7117	>b989		38				                .byte %00111000
7118	>b98a		18				                .byte %00011000
7119	>b98b		18				                .byte %00011000
7120	>b98c		18				                .byte %00011000
7121	>b98d		18				                .byte %00011000
7122	>b98e		7e				                .byte %01111110
7123	>b98f		00				                .byte %00000000

7125							                ; CHR$50 - 2
7126	>b990		3c				                .byte %00111100
7127	>b991		66				                .byte %01100110
7128	>b992		06				                .byte %00000110
7129	>b993		0c				                .byte %00001100
7130	>b994		18				                .byte %00011000
7131	>b995		30				                .byte %00110000
7132	>b996		7e				                .byte %01111110
7133	>b997		00				                .byte %00000000

7135							                ; CHR$51 - 3
7136	>b998		3c				                .byte %00111100
7137	>b999		66				                .byte %01100110
7138	>b99a		06				                .byte %00000110
7139	>b99b		1c				                .byte %00011100
7140	>b99c		06				                .byte %00000110
7141	>b99d		66				                .byte %01100110
7142	>b99e		3c				                .byte %00111100
7143	>b99f		00				                .byte %00000000

7145							                ; CHR$52 - 4
7146	>b9a0		0c				                .byte %00001100
7147	>b9a1		1c				                .byte %00011100
7148	>b9a2		3c				                .byte %00111100
7149	>b9a3		6c				                .byte %01101100
7150	>b9a4		7e				                .byte %01111110
7151	>b9a5		0c				                .byte %00001100
7152	>b9a6		0c				                .byte %00001100
7153	>b9a7		00				                .byte %00000000

7155							                ; CHR$53 - 5
7156	>b9a8		7e				                .byte %01111110
7157	>b9a9		60				                .byte %01100000
7158	>b9aa		7c				                .byte %01111100
7159	>b9ab		06				                .byte %00000110
7160	>b9ac		06				                .byte %00000110
7161	>b9ad		66				                .byte %01100110
7162	>b9ae		3c				                .byte %00111100
7163	>b9af		00				                .byte %00000000

7165							                ; CHR$54 - 6
7166	>b9b0		1c				                .byte %00011100
7167	>b9b1		30				                .byte %00110000
7168	>b9b2		60				                .byte %01100000
7169	>b9b3		7c				                .byte %01111100
7170	>b9b4		66				                .byte %01100110
7171	>b9b5		66				                .byte %01100110
7172	>b9b6		3c				                .byte %00111100
7173	>b9b7		00				                .byte %00000000

7175							                ; CHR$55 - 7
7176	>b9b8		7e				                .byte %01111110
7177	>b9b9		06				                .byte %00000110
7178	>b9ba		0c				                .byte %00001100
7179	>b9bb		18				                .byte %00011000
7180	>b9bc		30				                .byte %00110000
7181	>b9bd		30				                .byte %00110000
7182	>b9be		30				                .byte %00110000
7183	>b9bf		00				                .byte %00000000

7185							                ; CHR$56 - 8
7186	>b9c0		3c				                .byte %00111100
7187	>b9c1		66				                .byte %01100110
7188	>b9c2		66				                .byte %01100110
7189	>b9c3		3c				                .byte %00111100
7190	>b9c4		66				                .byte %01100110
7191	>b9c5		66				                .byte %01100110
7192	>b9c6		3c				                .byte %00111100
7193	>b9c7		00				                .byte %00000000

7195							                ; CHR$57 - 9
7196	>b9c8		3c				                .byte %00111100
7197	>b9c9		66				                .byte %01100110
7198	>b9ca		66				                .byte %01100110
7199	>b9cb		3e				                .byte %00111110
7200	>b9cc		06				                .byte %00000110
7201	>b9cd		0c				                .byte %00001100
7202	>b9ce		38				                .byte %00111000
7203	>b9cf		00				                .byte %00000000

7205							                ; CHR$58 - :
7206	>b9d0		00				                .byte %00000000
7207	>b9d1		00				                .byte %00000000
7208	>b9d2		18				                .byte %00011000
7209	>b9d3		18				                .byte %00011000
7210	>b9d4		00				                .byte %00000000
7211	>b9d5		18				                .byte %00011000
7212	>b9d6		18				                .byte %00011000
7213	>b9d7		00				                .byte %00000000

7215							                ; CHR$59 - ;
7216	>b9d8		00				                .byte %00000000
7217	>b9d9		00				                .byte %00000000
7218	>b9da		18				                .byte %00011000
7219	>b9db		18				                .byte %00011000
7220	>b9dc		00				                .byte %00000000
7221	>b9dd		18				                .byte %00011000
7222	>b9de		18				                .byte %00011000
7223	>b9df		30				                .byte %00110000

7225							                ; CHR$60 - <
7226	>b9e0		0c				                .byte %00001100
7227	>b9e1		18				                .byte %00011000
7228	>b9e2		30				                .byte %00110000
7229	>b9e3		60				                .byte %01100000
7230	>b9e4		30				                .byte %00110000
7231	>b9e5		18				                .byte %00011000
7232	>b9e6		0c				                .byte %00001100
7233	>b9e7		00				                .byte %00000000

7235							                ; CHR$61 - =
7236	>b9e8		00				                .byte %00000000
7237	>b9e9		00				                .byte %00000000
7238	>b9ea		7e				                .byte %01111110
7239	>b9eb		00				                .byte %00000000
7240	>b9ec		7e				                .byte %01111110
7241	>b9ed		00				                .byte %00000000
7242	>b9ee		00				                .byte %00000000
7243	>b9ef		00				                .byte %00000000

7245							                ; CHR$62 - >
7246	>b9f0		30				                .byte %00110000
7247	>b9f1		18				                .byte %00011000
7248	>b9f2		0c				                .byte %00001100
7249	>b9f3		06				                .byte %00000110
7250	>b9f4		0c				                .byte %00001100
7251	>b9f5		18				                .byte %00011000
7252	>b9f6		30				                .byte %00110000
7253	>b9f7		00				                .byte %00000000

7255							                ; CHR$63 - ?
7256	>b9f8		3c				                .byte %00111100
7257	>b9f9		66				                .byte %01100110
7258	>b9fa		0c				                .byte %00001100
7259	>b9fb		18				                .byte %00011000
7260	>b9fc		18				                .byte %00011000
7261	>b9fd		00				                .byte %00000000
7262	>b9fe		18				                .byte %00011000
7263	>b9ff		00				                .byte %00000000

7265							                ; CHR$64 - @
7266	>ba00		3c				                .byte %00111100
7267	>ba01		66				                .byte %01100110
7268	>ba02		6e				                .byte %01101110
7269	>ba03		6a				                .byte %01101010
7270	>ba04		6e				                .byte %01101110
7271	>ba05		60				                .byte %01100000
7272	>ba06		3c				                .byte %00111100
7273	>ba07		00				                .byte %00000000

7275							                ; CHR$65 - A
7276	>ba08		3c				                .byte %00111100
7277	>ba09		66				                .byte %01100110
7278	>ba0a		66				                .byte %01100110
7279	>ba0b		7e				                .byte %01111110
7280	>ba0c		66				                .byte %01100110
7281	>ba0d		66				                .byte %01100110
7282	>ba0e		66				                .byte %01100110
7283	>ba0f		00				                .byte %00000000

7285							                ; CHR$66 - B
7286	>ba10		7c				                .byte %01111100
7287	>ba11		66				                .byte %01100110
7288	>ba12		66				                .byte %01100110
7289	>ba13		7c				                .byte %01111100
7290	>ba14		66				                .byte %01100110
7291	>ba15		66				                .byte %01100110
7292	>ba16		7c				                .byte %01111100
7293	>ba17		00				                .byte %00000000

7295							                ; CHR$67 - C
7296	>ba18		3c				                .byte %00111100
7297	>ba19		66				                .byte %01100110
7298	>ba1a		60				                .byte %01100000
7299	>ba1b		60				                .byte %01100000
7300	>ba1c		60				                .byte %01100000
7301	>ba1d		66				                .byte %01100110
7302	>ba1e		3c				                .byte %00111100
7303	>ba1f		00				                .byte %00000000

7305							                ; CHR$68 - D
7306	>ba20		78				                .byte %01111000
7307	>ba21		6c				                .byte %01101100
7308	>ba22		66				                .byte %01100110
7309	>ba23		66				                .byte %01100110
7310	>ba24		66				                .byte %01100110
7311	>ba25		6c				                .byte %01101100
7312	>ba26		78				                .byte %01111000
7313	>ba27		00				                .byte %00000000

7315							                ; CHR$69 - E
7316	>ba28		7e				                .byte %01111110
7317	>ba29		60				                .byte %01100000
7318	>ba2a		60				                .byte %01100000
7319	>ba2b		7c				                .byte %01111100
7320	>ba2c		60				                .byte %01100000
7321	>ba2d		60				                .byte %01100000
7322	>ba2e		7e				                .byte %01111110
7323	>ba2f		00				                .byte %00000000

7325							                ; CHR$70 - F
7326	>ba30		7e				                .byte %01111110
7327	>ba31		60				                .byte %01100000
7328	>ba32		60				                .byte %01100000
7329	>ba33		7c				                .byte %01111100
7330	>ba34		60				                .byte %01100000
7331	>ba35		60				                .byte %01100000
7332	>ba36		60				                .byte %01100000
7333	>ba37		00				                .byte %00000000

7335							                ; CHR$71 - G
7336	>ba38		3c				                .byte %00111100
7337	>ba39		66				                .byte %01100110
7338	>ba3a		60				                .byte %01100000
7339	>ba3b		6e				                .byte %01101110
7340	>ba3c		66				                .byte %01100110
7341	>ba3d		66				                .byte %01100110
7342	>ba3e		3c				                .byte %00111100
7343	>ba3f		00				                .byte %00000000

7345							                ; CHR$72 - H
7346	>ba40		66				                .byte %01100110
7347	>ba41		66				                .byte %01100110
7348	>ba42		66				                .byte %01100110
7349	>ba43		7e				                .byte %01111110
7350	>ba44		66				                .byte %01100110
7351	>ba45		66				                .byte %01100110
7352	>ba46		66				                .byte %01100110
7353	>ba47		00				                .byte %00000000

7355							                ; CHR$73 - I
7356	>ba48		7e				                .byte %01111110
7357	>ba49		18				                .byte %00011000
7358	>ba4a		18				                .byte %00011000
7359	>ba4b		18				                .byte %00011000
7360	>ba4c		18				                .byte %00011000
7361	>ba4d		18				                .byte %00011000
7362	>ba4e		7e				                .byte %01111110
7363	>ba4f		00				                .byte %00000000

7365							                ; CHR$74 - J
7366	>ba50		3e				                .byte %00111110
7367	>ba51		0c				                .byte %00001100
7368	>ba52		0c				                .byte %00001100
7369	>ba53		0c				                .byte %00001100
7370	>ba54		0c				                .byte %00001100
7371	>ba55		6c				                .byte %01101100
7372	>ba56		38				                .byte %00111000
7373	>ba57		00				                .byte %00000000

7375							                ; CHR$75 - K
7376	>ba58		66				                .byte %01100110
7377	>ba59		6c				                .byte %01101100
7378	>ba5a		78				                .byte %01111000
7379	>ba5b		70				                .byte %01110000
7380	>ba5c		78				                .byte %01111000
7381	>ba5d		6c				                .byte %01101100
7382	>ba5e		66				                .byte %01100110
7383	>ba5f		00				                .byte %00000000

7385							                ; CHR$76 - L
7386	>ba60		60				                .byte %01100000
7387	>ba61		60				                .byte %01100000
7388	>ba62		60				                .byte %01100000
7389	>ba63		60				                .byte %01100000
7390	>ba64		60				                .byte %01100000
7391	>ba65		60				                .byte %01100000
7392	>ba66		7e				                .byte %01111110
7393	>ba67		00				                .byte %00000000

7395							                ; CHR$77 - M
7396	>ba68		63				                .byte %01100011
7397	>ba69		77				                .byte %01110111
7398	>ba6a		7f				                .byte %01111111
7399	>ba6b		6b				                .byte %01101011
7400	>ba6c		6b				                .byte %01101011
7401	>ba6d		63				                .byte %01100011
7402	>ba6e		63				                .byte %01100011
7403	>ba6f		00				                .byte %00000000

7405							                ; CHR$78 - N
7406	>ba70		66				                .byte %01100110
7407	>ba71		66				                .byte %01100110
7408	>ba72		76				                .byte %01110110
7409	>ba73		7e				                .byte %01111110
7410	>ba74		6e				                .byte %01101110
7411	>ba75		66				                .byte %01100110
7412	>ba76		66				                .byte %01100110
7413	>ba77		00				                .byte %00000000

7415							                ; CHR$79 - O
7416	>ba78		3c				                .byte %00111100
7417	>ba79		66				                .byte %01100110
7418	>ba7a		66				                .byte %01100110
7419	>ba7b		66				                .byte %01100110
7420	>ba7c		66				                .byte %01100110
7421	>ba7d		66				                .byte %01100110
7422	>ba7e		3c				                .byte %00111100
7423	>ba7f		00				                .byte %00000000

7425							                ; CHR$80 - P
7426	>ba80		7c				                .byte %01111100
7427	>ba81		66				                .byte %01100110
7428	>ba82		66				                .byte %01100110
7429	>ba83		7c				                .byte %01111100
7430	>ba84		60				                .byte %01100000
7431	>ba85		60				                .byte %01100000
7432	>ba86		60				                .byte %01100000
7433	>ba87		00				                .byte %00000000

7435							                ; CHR$81 - Q
7436	>ba88		3c				                .byte %00111100
7437	>ba89		66				                .byte %01100110
7438	>ba8a		66				                .byte %01100110
7439	>ba8b		66				                .byte %01100110
7440	>ba8c		6a				                .byte %01101010
7441	>ba8d		6c				                .byte %01101100
7442	>ba8e		36				                .byte %00110110
7443	>ba8f		00				                .byte %00000000

7445							                ; CHR$82 - R
7446	>ba90		7c				                .byte %01111100
7447	>ba91		66				                .byte %01100110
7448	>ba92		66				                .byte %01100110
7449	>ba93		7c				                .byte %01111100
7450	>ba94		6c				                .byte %01101100
7451	>ba95		66				                .byte %01100110
7452	>ba96		66				                .byte %01100110
7453	>ba97		00				                .byte %00000000

7455							                ; CHR$83 - S
7456	>ba98		3c				                .byte %00111100
7457	>ba99		66				                .byte %01100110
7458	>ba9a		60				                .byte %01100000
7459	>ba9b		3c				                .byte %00111100
7460	>ba9c		06				                .byte %00000110
7461	>ba9d		66				                .byte %01100110
7462	>ba9e		3c				                .byte %00111100
7463	>ba9f		00				                .byte %00000000

7465							                ; CHR$84 - T
7466	>baa0		7e				                .byte %01111110
7467	>baa1		18				                .byte %00011000
7468	>baa2		18				                .byte %00011000
7469	>baa3		18				                .byte %00011000
7470	>baa4		18				                .byte %00011000
7471	>baa5		18				                .byte %00011000
7472	>baa6		18				                .byte %00011000
7473	>baa7		00				                .byte %00000000

7475							                ; CHR$85 - U
7476	>baa8		66				                .byte %01100110
7477	>baa9		66				                .byte %01100110
7478	>baaa		66				                .byte %01100110
7479	>baab		66				                .byte %01100110
7480	>baac		66				                .byte %01100110
7481	>baad		66				                .byte %01100110
7482	>baae		3c				                .byte %00111100
7483	>baaf		00				                .byte %00000000

7485							                ; CHR$86 - V
7486	>bab0		66				                .byte %01100110
7487	>bab1		66				                .byte %01100110
7488	>bab2		66				                .byte %01100110
7489	>bab3		66				                .byte %01100110
7490	>bab4		66				                .byte %01100110
7491	>bab5		3c				                .byte %00111100
7492	>bab6		18				                .byte %00011000
7493	>bab7		00				                .byte %00000000

7495							                ; CHR$87 - W
7496	>bab8		63				                .byte %01100011
7497	>bab9		63				                .byte %01100011
7498	>baba		6b				                .byte %01101011
7499	>babb		6b				                .byte %01101011
7500	>babc		7f				                .byte %01111111
7501	>babd		77				                .byte %01110111
7502	>babe		63				                .byte %01100011
7503	>babf		00				                .byte %00000000

7505							                ; CHR$88 - X
7506	>bac0		66				                .byte %01100110
7507	>bac1		66				                .byte %01100110
7508	>bac2		3c				                .byte %00111100
7509	>bac3		18				                .byte %00011000
7510	>bac4		3c				                .byte %00111100
7511	>bac5		66				                .byte %01100110
7512	>bac6		66				                .byte %01100110
7513	>bac7		00				                .byte %00000000

7515							                ; CHR$89 - Y
7516	>bac8		66				                .byte %01100110
7517	>bac9		66				                .byte %01100110
7518	>baca		66				                .byte %01100110
7519	>bacb		3c				                .byte %00111100
7520	>bacc		18				                .byte %00011000
7521	>bacd		18				                .byte %00011000
7522	>bace		18				                .byte %00011000
7523	>bacf		00				                .byte %00000000

7525							                ; CHR$90 - Z
7526	>bad0		7e				                .byte %01111110
7527	>bad1		06				                .byte %00000110
7528	>bad2		0c				                .byte %00001100
7529	>bad3		18				                .byte %00011000
7530	>bad4		30				                .byte %00110000
7531	>bad5		60				                .byte %01100000
7532	>bad6		7e				                .byte %01111110
7533	>bad7		00				                .byte %00000000

7535							                ; CHR$91 - [
7536	>bad8		7c				                .byte %01111100
7537	>bad9		60				                .byte %01100000
7538	>bada		60				                .byte %01100000
7539	>badb		60				                .byte %01100000
7540	>badc		60				                .byte %01100000
7541	>badd		60				                .byte %01100000
7542	>bade		7c				                .byte %01111100
7543	>badf		00				                .byte %00000000

7545							                ; CHR$92 - \
7546	>bae0		00				                .byte %00000000
7547	>bae1		60				                .byte %01100000
7548	>bae2		30				                .byte %00110000
7549	>bae3		18				                .byte %00011000
7550	>bae4		0c				                .byte %00001100
7551	>bae5		06				                .byte %00000110
7552	>bae6		00				                .byte %00000000
7553	>bae7		00				                .byte %00000000

7555							                ; CHR$93 - ]
7556	>bae8		3e				                .byte %00111110
7557	>bae9		06				                .byte %00000110
7558	>baea		06				                .byte %00000110
7559	>baeb		06				                .byte %00000110
7560	>baec		06				                .byte %00000110
7561	>baed		06				                .byte %00000110
7562	>baee		3e				                .byte %00111110
7563	>baef		00				                .byte %00000000

7565							                ; CHR$94 - ^
7566	>baf0		18				                .byte %00011000
7567	>baf1		3c				                .byte %00111100
7568	>baf2		66				                .byte %01100110
7569	>baf3		42				                .byte %01000010
7570	>baf4		00				                .byte %00000000
7571	>baf5		00				                .byte %00000000
7572	>baf6		00				                .byte %00000000
7573	>baf7		00				                .byte %00000000

7575							                ; CHR$95 - _
7576	>baf8		00				                .byte %00000000
7577	>baf9		00				                .byte %00000000
7578	>bafa		00				                .byte %00000000
7579	>bafb		00				                .byte %00000000
7580	>bafc		00				                .byte %00000000
7581	>bafd		00				                .byte %00000000
7582	>bafe		00				                .byte %00000000
7583	>baff		ff				                .byte %11111111

7585							                ; CHR$96
7586	>bb00		1c				                .byte %00011100
7587	>bb01		36				                .byte %00110110
7588	>bb02		30				                .byte %00110000
7589	>bb03		7c				                .byte %01111100
7590	>bb04		30				                .byte %00110000
7591	>bb05		30				                .byte %00110000
7592	>bb06		7e				                .byte %01111110
7593	>bb07		00				                .byte %00000000

7595							                ; CHR$97 - a
7596	>bb08		00				                .byte %00000000
7597	>bb09		00				                .byte %00000000
7598	>bb0a		3c				                .byte %00111100
7599	>bb0b		06				                .byte %00000110
7600	>bb0c		3e				                .byte %00111110
7601	>bb0d		66				                .byte %01100110
7602	>bb0e		3e				                .byte %00111110
7603	>bb0f		00				                .byte %00000000

7605							                ; CHR$98 - b
7606	>bb10		60				                .byte %01100000
7607	>bb11		60				                .byte %01100000
7608	>bb12		7c				                .byte %01111100
7609	>bb13		66				                .byte %01100110
7610	>bb14		66				                .byte %01100110
7611	>bb15		66				                .byte %01100110
7612	>bb16		7c				                .byte %01111100
7613	>bb17		00				                .byte %00000000

7615							                ; CHR$99 - c
7616	>bb18		00				                .byte %00000000
7617	>bb19		00				                .byte %00000000
7618	>bb1a		3c				                .byte %00111100
7619	>bb1b		66				                .byte %01100110
7620	>bb1c		60				                .byte %01100000
7621	>bb1d		66				                .byte %01100110
7622	>bb1e		3c				                .byte %00111100
7623	>bb1f		00				                .byte %00000000

7625							                ; CHR$100 - d
7626	>bb20		06				                .byte %00000110
7627	>bb21		06				                .byte %00000110
7628	>bb22		3e				                .byte %00111110
7629	>bb23		66				                .byte %01100110
7630	>bb24		66				                .byte %01100110
7631	>bb25		66				                .byte %01100110
7632	>bb26		3e				                .byte %00111110
7633	>bb27		00				                .byte %00000000

7635							                ; CHR$101 - e
7636	>bb28		00				                .byte %00000000
7637	>bb29		00				                .byte %00000000
7638	>bb2a		3c				                .byte %00111100
7639	>bb2b		66				                .byte %01100110
7640	>bb2c		7e				                .byte %01111110
7641	>bb2d		60				                .byte %01100000
7642	>bb2e		3c				                .byte %00111100
7643	>bb2f		00				                .byte %00000000

7645							                ; CHR$102 - f
7646	>bb30		1c				                .byte %00011100
7647	>bb31		30				                .byte %00110000
7648	>bb32		30				                .byte %00110000
7649	>bb33		7c				                .byte %01111100
7650	>bb34		30				                .byte %00110000
7651	>bb35		30				                .byte %00110000
7652	>bb36		30				                .byte %00110000
7653	>bb37		00				                .byte %00000000

7655							                ; CHR$103 - g
7656	>bb38		00				                .byte %00000000
7657	>bb39		00				                .byte %00000000
7658	>bb3a		3e				                .byte %00111110
7659	>bb3b		66				                .byte %01100110
7660	>bb3c		66				                .byte %01100110
7661	>bb3d		3e				                .byte %00111110
7662	>bb3e		06				                .byte %00000110
7663	>bb3f		3c				                .byte %00111100

7665							                ; CHR$104 - h
7666	>bb40		60				                .byte %01100000
7667	>bb41		60				                .byte %01100000
7668	>bb42		7c				                .byte %01111100
7669	>bb43		66				                .byte %01100110
7670	>bb44		66				                .byte %01100110
7671	>bb45		66				                .byte %01100110
7672	>bb46		66				                .byte %01100110
7673	>bb47		00				                .byte %00000000

7675							                ; CHR$105 - i
7676	>bb48		18				                .byte %00011000
7677	>bb49		00				                .byte %00000000
7678	>bb4a		38				                .byte %00111000
7679	>bb4b		18				                .byte %00011000
7680	>bb4c		18				                .byte %00011000
7681	>bb4d		18				                .byte %00011000
7682	>bb4e		3c				                .byte %00111100
7683	>bb4f		00				                .byte %00000000

7685							                ; CHR$106 - j
7686	>bb50		18				                .byte %00011000
7687	>bb51		00				                .byte %00000000
7688	>bb52		38				                .byte %00111000
7689	>bb53		18				                .byte %00011000
7690	>bb54		18				                .byte %00011000
7691	>bb55		18				                .byte %00011000
7692	>bb56		18				                .byte %00011000
7693	>bb57		70				                .byte %01110000

7695							                ; CHR$107 - k
7696	>bb58		60				                .byte %01100000
7697	>bb59		60				                .byte %01100000
7698	>bb5a		66				                .byte %01100110
7699	>bb5b		6c				                .byte %01101100
7700	>bb5c		78				                .byte %01111000
7701	>bb5d		6c				                .byte %01101100
7702	>bb5e		66				                .byte %01100110
7703	>bb5f		00				                .byte %00000000

7705							                ; CHR$108 - l
7706	>bb60		38				                .byte %00111000
7707	>bb61		18				                .byte %00011000
7708	>bb62		18				                .byte %00011000
7709	>bb63		18				                .byte %00011000
7710	>bb64		18				                .byte %00011000
7711	>bb65		18				                .byte %00011000
7712	>bb66		3c				                .byte %00111100
7713	>bb67		00				                .byte %00000000

7715							                ; CHR$109 - m
7716	>bb68		00				                .byte %00000000
7717	>bb69		00				                .byte %00000000
7718	>bb6a		36				                .byte %00110110
7719	>bb6b		7f				                .byte %01111111
7720	>bb6c		6b				                .byte %01101011
7721	>bb6d		6b				                .byte %01101011
7722	>bb6e		63				                .byte %01100011
7723	>bb6f		00				                .byte %00000000

7725							                ; CHR$110 - n
7726	>bb70		00				                .byte %00000000
7727	>bb71		00				                .byte %00000000
7728	>bb72		7c				                .byte %01111100
7729	>bb73		66				                .byte %01100110
7730	>bb74		66				                .byte %01100110
7731	>bb75		66				                .byte %01100110
7732	>bb76		66				                .byte %01100110
7733	>bb77		00				                .byte %00000000

7735							                ; CHR$111 - o
7736	>bb78		00				                .byte %00000000
7737	>bb79		00				                .byte %00000000
7738	>bb7a		3c				                .byte %00111100
7739	>bb7b		66				                .byte %01100110
7740	>bb7c		66				                .byte %01100110
7741	>bb7d		66				                .byte %01100110
7742	>bb7e		3c				                .byte %00111100
7743	>bb7f		00				                .byte %00000000

7745							                ; CHR$112 - p
7746	>bb80		00				                .byte %00000000
7747	>bb81		00				                .byte %00000000
7748	>bb82		7c				                .byte %01111100
7749	>bb83		66				                .byte %01100110
7750	>bb84		66				                .byte %01100110
7751	>bb85		7c				                .byte %01111100
7752	>bb86		60				                .byte %01100000
7753	>bb87		60				                .byte %01100000

7755							                ; CHR$113 - q
7756	>bb88		00				                .byte %00000000
7757	>bb89		00				                .byte %00000000
7758	>bb8a		3e				                .byte %00111110
7759	>bb8b		66				                .byte %01100110
7760	>bb8c		66				                .byte %01100110
7761	>bb8d		3e				                .byte %00111110
7762	>bb8e		06				                .byte %00000110
7763	>bb8f		07				                .byte %00000111

7765							                ; CHR$114 - r
7766	>bb90		00				                .byte %00000000
7767	>bb91		00				                .byte %00000000
7768	>bb92		6c				                .byte %01101100
7769	>bb93		76				                .byte %01110110
7770	>bb94		60				                .byte %01100000
7771	>bb95		60				                .byte %01100000
7772	>bb96		60				                .byte %01100000
7773	>bb97		00				                .byte %00000000

7775							                ; CHR$115 - s
7776	>bb98		00				                .byte %00000000
7777	>bb99		00				                .byte %00000000
7778	>bb9a		3e				                .byte %00111110
7779	>bb9b		60				                .byte %01100000
7780	>bb9c		3c				                .byte %00111100
7781	>bb9d		06				                .byte %00000110
7782	>bb9e		7c				                .byte %01111100
7783	>bb9f		00				                .byte %00000000

7785							                ; CHR$116 - t
7786	>bba0		30				                .byte %00110000
7787	>bba1		30				                .byte %00110000
7788	>bba2		7c				                .byte %01111100
7789	>bba3		30				                .byte %00110000
7790	>bba4		30				                .byte %00110000
7791	>bba5		30				                .byte %00110000
7792	>bba6		1c				                .byte %00011100
7793	>bba7		00				                .byte %00000000

7795							                ; CHR$117 - u
7796	>bba8		00				                .byte %00000000
7797	>bba9		00				                .byte %00000000
7798	>bbaa		66				                .byte %01100110
7799	>bbab		66				                .byte %01100110
7800	>bbac		66				                .byte %01100110
7801	>bbad		66				                .byte %01100110
7802	>bbae		3e				                .byte %00111110
7803	>bbaf		00				                .byte %00000000

7805							                ; CHR$118 - v
7806	>bbb0		00				                .byte %00000000
7807	>bbb1		00				                .byte %00000000
7808	>bbb2		66				                .byte %01100110
7809	>bbb3		66				                .byte %01100110
7810	>bbb4		66				                .byte %01100110
7811	>bbb5		3c				                .byte %00111100
7812	>bbb6		18				                .byte %00011000
7813	>bbb7		00				                .byte %00000000

7815							                ; CHR$119 - w
7816	>bbb8		00				                .byte %00000000
7817	>bbb9		00				                .byte %00000000
7818	>bbba		63				                .byte %01100011
7819	>bbbb		6b				                .byte %01101011
7820	>bbbc		6b				                .byte %01101011
7821	>bbbd		7f				                .byte %01111111
7822	>bbbe		36				                .byte %00110110
7823	>bbbf		00				                .byte %00000000

7825							                ; CHR$120 - x
7826	>bbc0		00				                .byte %00000000
7827	>bbc1		00				                .byte %00000000
7828	>bbc2		66				                .byte %01100110
7829	>bbc3		3c				                .byte %00111100
7830	>bbc4		18				                .byte %00011000
7831	>bbc5		3c				                .byte %00111100
7832	>bbc6		66				                .byte %01100110
7833	>bbc7		00				                .byte %00000000

7835							                ; CHR$121 - y
7836	>bbc8		00				                .byte %00000000
7837	>bbc9		00				                .byte %00000000
7838	>bbca		66				                .byte %01100110
7839	>bbcb		66				                .byte %01100110
7840	>bbcc		66				                .byte %01100110
7841	>bbcd		3e				                .byte %00111110
7842	>bbce		06				                .byte %00000110
7843	>bbcf		3c				                .byte %00111100

7845							                ; CHR$122 - z
7846	>bbd0		00				                .byte %00000000
7847	>bbd1		00				                .byte %00000000
7848	>bbd2		7e				                .byte %01111110
7849	>bbd3		0c				                .byte %00001100
7850	>bbd4		18				                .byte %00011000
7851	>bbd5		30				                .byte %00110000
7852	>bbd6		7e				                .byte %01111110
7853	>bbd7		00				                .byte %00000000

7855							                ; CHR$123 - {
7856	>bbd8		0c				                .byte %00001100
7857	>bbd9		18				                .byte %00011000
7858	>bbda		18				                .byte %00011000
7859	>bbdb		70				                .byte %01110000
7860	>bbdc		18				                .byte %00011000
7861	>bbdd		18				                .byte %00011000
7862	>bbde		0c				                .byte %00001100
7863	>bbdf		00				                .byte %00000000

7865							                ; CHR$124 - |
7866	>bbe0		18				                .byte %00011000
7867	>bbe1		18				                .byte %00011000
7868	>bbe2		18				                .byte %00011000
7869	>bbe3		00				                .byte %00000000
7870	>bbe4		18				                .byte %00011000
7871	>bbe5		18				                .byte %00011000
7872	>bbe6		18				                .byte %00011000
7873	>bbe7		00				                .byte %00000000

7875							                ; CHR$125 - }
7876	>bbe8		30				                .byte %00110000
7877	>bbe9		18				                .byte %00011000
7878	>bbea		18				                .byte %00011000
7879	>bbeb		0e				                .byte %00001110
7880	>bbec		18				                .byte %00011000
7881	>bbed		18				                .byte %00011000
7882	>bbee		30				                .byte %00110000
7883	>bbef		00				                .byte %00000000

7885							                ; CHR$126 - ~
7886	>bbf0		31				                .byte %00110001
7887	>bbf1		6b				                .byte %01101011
7888	>bbf2		46				                .byte %01000110
7889	>bbf3		00				                .byte %00000000
7890	>bbf4		00				                .byte %00000000
7891	>bbf5		00				                .byte %00000000
7892	>bbf6		00				                .byte %00000000
7893	>bbf7		00				                .byte %00000000

7895							                ; CHR$127
7896	.bbf8						chr127:
7897	>bbf8		ff				                .byte %11111111
7898	>bbf9		ff				                .byte %11111111
7899	>bbfa		ff				                .byte %11111111
7900	>bbfb		ff				                .byte %11111111
7901	>bbfc		ff				                .byte %11111111
7902	>bbfd		ff				                .byte %11111111
7903	>bbfe		ff				                .byte %11111111
7904	>bbff		ff				                .byte %11111111

7906							                ; CHR$128
7907							                .if version==350
7908	>bc00		66				                .byte %01100110
7909	>bc01		66				                .byte %01100110
7910	>bc02		00				                .byte %00000000
7911	>bc03		3c				                .byte %00111100
7912	>bc04		66				                .byte %01100110
7913	>bc05		7e				                .byte %01111110
7914	>bc06		66				                .byte %01100110
7915	>bc07		00				                .byte %00000000
7925							                .endif

7927							                ; CHR$129
7928							                .if version==350
7929	>bc08		3c				                .byte %00111100
7930	>bc09		66				                .byte %01100110
7931	>bc0a		3c				                .byte %00111100
7932	>bc0b		3c				                .byte %00111100
7933	>bc0c		66				                .byte %01100110
7934	>bc0d		7e				                .byte %01111110
7935	>bc0e		66				                .byte %01100110
7936	>bc0f		00				                .byte %00000000
7946							                .endif

7948							                ; CHR$130
7949	>bc10		3f				                .byte %00111111
7950	>bc11		66				                .byte %01100110
7951	>bc12		66				                .byte %01100110
7952	>bc13		7f				                .byte %01111111
7953	>bc14		66				                .byte %01100110
7954	>bc15		66				                .byte %01100110
7955	>bc16		67				                .byte %01100111
7956	>bc17		00				                .byte %00000000

7958							                ; CHR$131
7959							                .if version==350
7960	>bc18		3c				                .byte %00111100
7961	>bc19		66				                .byte %01100110
7962	>bc1a		60				                .byte %01100000
7963	>bc1b		60				                .byte %01100000
7964	>bc1c		66				                .byte %01100110
7965	>bc1d		3c				                .byte %00111100
7966	>bc1e		30				                .byte %00110000
7967	>bc1f		60				                .byte %01100000
7977							                .endif

7979							                ; CHR$132
7980	>bc20		0c				                .byte %00001100
7981	>bc21		18				                .byte %00011000
7982	>bc22		7e				                .byte %01111110
7983	>bc23		60				                .byte %01100000
7984	>bc24		7c				                .byte %01111100
7985	>bc25		60				                .byte %01100000
7986	>bc26		7e				                .byte %01111110
7987	>bc27		00				                .byte %00000000

7989							                ; CHR$133
7990							                .if version==350
7991	>bc28		66				                .byte %01100110
7992	>bc29		00				                .byte %00000000
7993	>bc2a		3c				                .byte %00111100
7994	>bc2b		66				                .byte %01100110
7995	>bc2c		66				                .byte %01100110
7996	>bc2d		66				                .byte %01100110
7997	>bc2e		3c				                .byte %00111100
7998	>bc2f		00				                .byte %00000000
8008							                .endif

8010							                ; CHR$134
8011	>bc30		66				                .byte %01100110
8012	>bc31		00				                .byte %00000000
8013	>bc32		66				                .byte %01100110
8014	>bc33		66				                .byte %01100110
8015	>bc34		66				                .byte %01100110
8016	>bc35		66				                .byte %01100110
8017	>bc36		3c				                .byte %00111100
8018	>bc37		00				                .byte %00000000

8020							                ; CHR$135
8021							                .if version==350
8022	>bc38		3c				                .byte %00111100
8023	>bc39		42				                .byte %01000010
8024	>bc3a		99				                .byte %10011001
8025	>bc3b		a1				                .byte %10100001
8026	>bc3c		a1				                .byte %10100001
8027	>bc3d		99				                .byte %10011001
8028	>bc3e		42				                .byte %01000010
8029	>bc3f		3c				                .byte %00111100
8039							                .endif

8041							                ; CHR$136
8042	>bc40		00				                .byte %00000000
8043	>bc41		18				                .byte %00011000
8044	>bc42		38				                .byte %00111000
8045	>bc43		7f				                .byte %01111111
8046	>bc44		38				                .byte %00111000
8047	>bc45		18				                .byte %00011000
8048	>bc46		00				                .byte %00000000
8049	>bc47		00				                .byte %00000000

8051							                ; CHR$137
8052	>bc48		00				                .byte %00000000
8053	>bc49		18				                .byte %00011000
8054	>bc4a		1c				                .byte %00011100
8055	>bc4b		fe				                .byte %11111110
8056	>bc4c		1c				                .byte %00011100
8057	>bc4d		18				                .byte %00011000
8058	>bc4e		00				                .byte %00000000
8059	>bc4f		00				                .byte %00000000

8061							                ; CHR$138
8062	>bc50		18				                .byte %00011000
8063	>bc51		18				                .byte %00011000
8064	>bc52		18				                .byte %00011000
8065	>bc53		18				                .byte %00011000
8066	>bc54		7e				                .byte %01111110
8067	>bc55		3c				                .byte %00111100
8068	>bc56		18				                .byte %00011000
8069	>bc57		00				                .byte %00000000

8071							                ; CHR$139
8072	>bc58		00				                .byte %00000000
8073	>bc59		18				                .byte %00011000
8074	>bc5a		3c				                .byte %00111100
8075	>bc5b		7e				                .byte %01111110
8076	>bc5c		18				                .byte %00011000
8077	>bc5d		18				                .byte %00011000
8078	>bc5e		18				                .byte %00011000
8079	>bc5f		18				                .byte %00011000

8081							                ; CHR$140
8082	>bc60		30				                .byte %00110000
8083	>bc61		18				                .byte %00011000
8084	>bc62		3c				                .byte %00111100
8085	>bc63		06				                .byte %00000110
8086	>bc64		3e				                .byte %00111110
8087	>bc65		66				                .byte %01100110
8088	>bc66		3e				                .byte %00111110
8089	>bc67		00				                .byte %00000000

8091							                ; CHR$141
8092	>bc68		30				                .byte %00110000
8093	>bc69		18				                .byte %00011000
8094	>bc6a		3c				                .byte %00111100
8095	>bc6b		66				                .byte %01100110
8096	>bc6c		7e				                .byte %01111110
8097	>bc6d		60				                .byte %01100000
8098	>bc6e		3c				                .byte %00111100
8099	>bc6f		00				                .byte %00000000

8101							                ; CHR$142
8102	>bc70		66				                .byte %01100110
8103	>bc71		00				                .byte %00000000
8104	>bc72		3c				                .byte %00111100
8105	>bc73		66				                .byte %01100110
8106	>bc74		7e				                .byte %01111110
8107	>bc75		60				                .byte %01100000
8108	>bc76		3c				                .byte %00111100
8109	>bc77		00				                .byte %00000000

8111							                ; CHR$143
8112	>bc78		3c				                .byte %00111100
8113	>bc79		66				                .byte %01100110
8114	>bc7a		3c				                .byte %00111100
8115	>bc7b		66				                .byte %01100110
8116	>bc7c		7e				                .byte %01111110
8117	>bc7d		60				                .byte %01100000
8118	>bc7e		3c				                .byte %00111100
8119	>bc7f		00				                .byte %00000000

8121							                ; CHR$144
8122	>bc80		66				                .byte %01100110
8123	>bc81		00				                .byte %00000000
8124	>bc82		3c				                .byte %00111100
8125	>bc83		06				                .byte %00000110
8126	>bc84		3e				                .byte %00111110
8127	>bc85		66				                .byte %01100110
8128	>bc86		3e				                .byte %00111110
8129	>bc87		00				                .byte %00000000

8131							                ; CHR$145
8132	>bc88		3c				                .byte %00111100
8133	>bc89		66				                .byte %01100110
8134	>bc8a		3c				                .byte %00111100
8135	>bc8b		06				                .byte %00000110
8136	>bc8c		3e				                .byte %00111110
8137	>bc8d		66				                .byte %01100110
8138	>bc8e		3e				                .byte %00111110
8139	>bc8f		00				                .byte %00000000

8141							                ; CHR$146
8142	>bc90		00				                .byte %00000000
8143	>bc91		00				                .byte %00000000
8144	>bc92		3f				                .byte %00111111
8145	>bc93		0d				                .byte %00001101
8146	>bc94		3f				                .byte %00111111
8147	>bc95		6c				                .byte %01101100
8148	>bc96		3f				                .byte %00111111
8149	>bc97		00				                .byte %00000000

8151							                ; CHR$147
8152	>bc98		00				                .byte %00000000
8153	>bc99		00				                .byte %00000000
8154	>bc9a		3c				                .byte %00111100
8155	>bc9b		66				                .byte %01100110
8156	>bc9c		60				                .byte %01100000
8157	>bc9d		66				                .byte %01100110
8158	>bc9e		3c				                .byte %00111100
8159	>bc9f		60				                .byte %01100000

8161							                ; CHR$148
8162	>bca0		0c				                .byte %00001100
8163	>bca1		18				                .byte %00011000
8164	>bca2		3c				                .byte %00111100
8165	>bca3		66				                .byte %01100110
8166	>bca4		7e				                .byte %01111110
8167	>bca5		60				                .byte %01100000
8168	>bca6		3c				                .byte %00111100
8169	>bca7		00				                .byte %00000000

8171							                ; CHR$149
8172							                .if version==350
8173	>bca8		66				                .byte %01100110
8174	>bca9		00				                .byte %00000000
8175	>bcaa		00				                .byte %00000000
8176	>bcab		3c				                .byte %00111100
8177	>bcac		66				                .byte %01100110
8178	>bcad		66				                .byte %01100110
8179	>bcae		3c				                .byte %00111100
8180	>bcaf		00				                .byte %00000000
8190							                .endif

8192							                ; CHR$150
8193							                .if version==350
8194	>bcb0		66				                .byte %01100110
8195	>bcb1		00				                .byte %00000000
8196	>bcb2		00				                .byte %00000000
8197	>bcb3		66				                .byte %01100110
8198	>bcb4		66				                .byte %01100110
8199	>bcb5		66				                .byte %01100110
8200	>bcb6		3e				                .byte %00111110
8201	>bcb7		00				                .byte %00000000
8211							                .endif

8213							                ; CHR$151
8214	>bcb8		30				                .byte %00110000
8215	>bcb9		18				                .byte %00011000
8216	>bcba		00				                .byte %00000000
8217	>bcbb		38				                .byte %00111000
8218	>bcbc		18				                .byte %00011000
8219	>bcbd		18				                .byte %00011000
8220	>bcbe		3c				                .byte %00111100
8221	>bcbf		00				                .byte %00000000

8223							                ; CHR$152
8224	>bcc0		3c				                .byte %00111100
8225	>bcc1		66				                .byte %01100110
8226	>bcc2		00				                .byte %00000000
8227	>bcc3		38				                .byte %00111000
8228	>bcc4		18				                .byte %00011000
8229	>bcc5		18				                .byte %00011000
8230	>bcc6		3c				                .byte %00111100
8231	>bcc7		00				                .byte %00000000

8233							                ; CHR$153
8234	>bcc8		30				                .byte %00110000
8235	>bcc9		18				                .byte %00011000
8236	>bcca		00				                .byte %00000000
8237	>bccb		3c				                .byte %00111100
8238	>bccc		66				                .byte %01100110
8239	>bccd		66				                .byte %01100110
8240	>bcce		3c				                .byte %00111100
8241	>bccf		00				                .byte %00000000

8243							                ; CHR$154
8244	>bcd0		3c				                .byte %00111100
8245	>bcd1		66				                .byte %01100110
8246	>bcd2		00				                .byte %00000000
8247	>bcd3		3c				                .byte %00111100
8248	>bcd4		66				                .byte %01100110
8249	>bcd5		66				                .byte %01100110
8250	>bcd6		3c				                .byte %00111100
8251	>bcd7		00				                .byte %00000000

8253							                ; CHR$155
8254	>bcd8		30				                .byte %00110000
8255	>bcd9		18				                .byte %00011000
8256	>bcda		00				                .byte %00000000
8257	>bcdb		66				                .byte %01100110
8258	>bcdc		66				                .byte %01100110
8259	>bcdd		66				                .byte %01100110
8260	>bcde		3e				                .byte %00111110
8261	>bcdf		00				                .byte %00000000

8263							                ; CHR$156
8264	>bce0		3c				                .byte %00111100
8265	>bce1		66				                .byte %01100110
8266	>bce2		00				                .byte %00000000
8267	>bce3		66				                .byte %01100110
8268	>bce4		66				                .byte %01100110
8269	>bce5		66				                .byte %01100110
8270	>bce6		3e				                .byte %00111110
8271	>bce7		00				                .byte %00000000

8273							                ; CHR$157
8274	>bce8		66				                .byte %01100110
8275	>bce9		00				                .byte %00000000
8276	>bcea		66				                .byte %01100110
8277	>bceb		66				                .byte %01100110
8278	>bcec		66				                .byte %01100110
8279	>bced		3e				                .byte %00111110
8280	>bcee		06				                .byte %00000110
8281	>bcef		3c				                .byte %00111100

8283							                ; CHR$158
8284	>bcf0		00				                .byte %00000000
8285	>bcf1		66				                .byte %01100110
8286	>bcf2		3c				                .byte %00111100
8287	>bcf3		66				                .byte %01100110
8288	>bcf4		66				                .byte %01100110
8289	>bcf5		3c				                .byte %00111100
8290	>bcf6		66				                .byte %01100110
8291	>bcf7		00				                .byte %00000000

8293							                ; CHR$159
8294	>bcf8		3c				                .byte %00111100
8295	>bcf9		60				                .byte %01100000
8296	>bcfa		3c				                .byte %00111100
8297	>bcfb		66				                .byte %01100110
8298	>bcfc		3c				                .byte %00111100
8299	>bcfd		06				                .byte %00000110
8300	>bcfe		3c				                .byte %00111100
8301	>bcff		00				                .byte %00000000

8303							                ; CHR$160
8304	>bd00		3c				                .byte %00111100
8305	>bd01		66				                .byte %01100110
8306	>bd02		3c				                .byte %00111100
8307	>bd03		00				                .byte %00000000
8308	>bd04		00				                .byte %00000000
8309	>bd05		00				                .byte %00000000
8310	>bd06		00				                .byte %00000000
8311	>bd07		00				                .byte %00000000

8313							                ; CHR$161
8314	>bd08		00				                .byte %00000000
8315	>bd09		00				                .byte %00000000
8316	>bd0a		00				                .byte %00000000
8317	>bd0b		18				                .byte %00011000
8318	>bd0c		18				                .byte %00011000
8319	>bd0d		18				                .byte %00011000
8320	>bd0e		18				                .byte %00011000
8321	>bd0f		18				                .byte %00011000

8323							                ; CHR$162
8324	>bd10		00				                .byte %00000000
8325	>bd11		00				                .byte %00000000
8326	>bd12		00				                .byte %00000000
8327	>bd13		1f				                .byte %00011111
8328	>bd14		00				                .byte %00000000
8329	>bd15		00				                .byte %00000000
8330	>bd16		00				                .byte %00000000
8331	>bd17		00				                .byte %00000000

8333							                ; CHR$163
8334	>bd18		00				                .byte %00000000
8335	>bd19		00				                .byte %00000000
8336	>bd1a		00				                .byte %00000000
8337	>bd1b		1f				                .byte %00011111
8338	>bd1c		18				                .byte %00011000
8339	>bd1d		18				                .byte %00011000
8340	>bd1e		18				                .byte %00011000
8341	>bd1f		18				                .byte %00011000

8343							                ; CHR$164
8344	>bd20		00				                .byte %00000000
8345	>bd21		00				                .byte %00000000
8346	>bd22		00				                .byte %00000000
8347	>bd23		f8				                .byte %11111000
8348	>bd24		00				                .byte %00000000
8349	>bd25		00				                .byte %00000000
8350	>bd26		00				                .byte %00000000
8351	>bd27		00				                .byte %00000000

8353							                ; CHR$165
8354	>bd28		00				                .byte %00000000
8355	>bd29		00				                .byte %00000000
8356	>bd2a		00				                .byte %00000000
8357	>bd2b		f8				                .byte %11111000
8358	>bd2c		18				                .byte %00011000
8359	>bd2d		18				                .byte %00011000
8360	>bd2e		18				                .byte %00011000
8361	>bd2f		18				                .byte %00011000

8363							                ; CHR$166
8364	>bd30		00				                .byte %00000000
8365	>bd31		00				                .byte %00000000
8366	>bd32		00				                .byte %00000000
8367	>bd33		ff				                .byte %11111111
8368	>bd34		00				                .byte %00000000
8369	>bd35		00				                .byte %00000000
8370	>bd36		00				                .byte %00000000
8371	>bd37		00				                .byte %00000000

8373							                ; CHR$167
8374	>bd38		00				                .byte %00000000
8375	>bd39		00				                .byte %00000000
8376	>bd3a		00				                .byte %00000000
8377	>bd3b		ff				                .byte %11111111
8378	>bd3c		18				                .byte %00011000
8379	>bd3d		18				                .byte %00011000
8380	>bd3e		18				                .byte %00011000
8381	>bd3f		18				                .byte %00011000

8383							                ; CHR$168
8384	>bd40		18				                .byte %00011000
8385	>bd41		18				                .byte %00011000
8386	>bd42		18				                .byte %00011000
8387	>bd43		18				                .byte %00011000
8388	>bd44		00				                .byte %00000000
8389	>bd45		00				                .byte %00000000
8390	>bd46		00				                .byte %00000000
8391	>bd47		00				                .byte %00000000

8393							                ; CHR$169
8394	>bd48		18				                .byte %00011000
8395	>bd49		18				                .byte %00011000
8396	>bd4a		18				                .byte %00011000
8397	>bd4b		18				                .byte %00011000
8398	>bd4c		18				                .byte %00011000
8399	>bd4d		18				                .byte %00011000
8400	>bd4e		18				                .byte %00011000
8401	>bd4f		18				                .byte %00011000

8403							                ; CHR$170
8404	>bd50		18				                .byte %00011000
8405	>bd51		18				                .byte %00011000
8406	>bd52		18				                .byte %00011000
8407	>bd53		1f				                .byte %00011111
8408	>bd54		00				                .byte %00000000
8409	>bd55		00				                .byte %00000000
8410	>bd56		00				                .byte %00000000
8411	>bd57		00				                .byte %00000000

8413							                ; CHR$171
8414	>bd58		18				                .byte %00011000
8415	>bd59		18				                .byte %00011000
8416	>bd5a		18				                .byte %00011000
8417	>bd5b		1f				                .byte %00011111
8418	>bd5c		18				                .byte %00011000
8419	>bd5d		18				                .byte %00011000
8420	>bd5e		18				                .byte %00011000
8421	>bd5f		18				                .byte %00011000

8423							                ; CHR$172
8424	>bd60		18				                .byte %00011000
8425	>bd61		18				                .byte %00011000
8426	>bd62		18				                .byte %00011000
8427	>bd63		f8				                .byte %11111000
8428	>bd64		00				                .byte %00000000
8429	>bd65		00				                .byte %00000000
8430	>bd66		00				                .byte %00000000
8431	>bd67		00				                .byte %00000000

8433							                ; CHR$173
8434	>bd68		18				                .byte %00011000
8435	>bd69		18				                .byte %00011000
8436	>bd6a		18				                .byte %00011000
8437	>bd6b		f8				                .byte %11111000
8438	>bd6c		18				                .byte %00011000
8439	>bd6d		18				                .byte %00011000
8440	>bd6e		18				                .byte %00011000
8441	>bd6f		18				                .byte %00011000

8443							                ; CHR$174
8444	>bd70		18				                .byte %00011000
8445	>bd71		18				                .byte %00011000
8446	>bd72		18				                .byte %00011000
8447	>bd73		ff				                .byte %11111111
8448	>bd74		00				                .byte %00000000
8449	>bd75		00				                .byte %00000000
8450	>bd76		00				                .byte %00000000
8451	>bd77		00				                .byte %00000000

8453							                ; CHR$175
8454	>bd78		18				                .byte %00011000
8455	>bd79		18				                .byte %00011000
8456	>bd7a		18				                .byte %00011000
8457	>bd7b		ff				                .byte %11111111
8458	>bd7c		18				                .byte %00011000
8459	>bd7d		18				                .byte %00011000
8460	>bd7e		18				                .byte %00011000
8461	>bd7f		18				                .byte %00011000

8463							                ; CHR$176
8464	>bd80		00				                .byte %00000000
8465	>bd81		00				                .byte %00000000
8466	>bd82		00				                .byte %00000000
8467	>bd83		07				                .byte %00000111
8468	>bd84		0c				                .byte %00001100
8469	>bd85		18				                .byte %00011000
8470	>bd86		18				                .byte %00011000
8471	>bd87		18				                .byte %00011000

8473							                ; CHR$177
8474	>bd88		00				                .byte %00000000
8475	>bd89		00				                .byte %00000000
8476	>bd8a		00				                .byte %00000000
8477	>bd8b		e0				                .byte %11100000
8478	>bd8c		30				                .byte %00110000
8479	>bd8d		18				                .byte %00011000
8480	>bd8e		18				                .byte %00011000
8481	>bd8f		18				                .byte %00011000

8483							                ; CHR$178
8484	>bd90		18				                .byte %00011000
8485	>bd91		18				                .byte %00011000
8486	>bd92		0c				                .byte %00001100
8487	>bd93		07				                .byte %00000111
8488	>bd94		00				                .byte %00000000
8489	>bd95		00				                .byte %00000000
8490	>bd96		00				                .byte %00000000
8491	>bd97		00				                .byte %00000000

8493							                ; CHR$179
8494	>bd98		18				                .byte %00011000
8495	>bd99		18				                .byte %00011000
8496	>bd9a		30				                .byte %00110000
8497	>bd9b		e0				                .byte %11100000
8498	>bd9c		00				                .byte %00000000
8499	>bd9d		00				                .byte %00000000
8500	>bd9e		00				                .byte %00000000
8501	>bd9f		00				                .byte %00000000

8503							                ; CHR$180
8504	>bda0		18				                .byte %00011000
8505	>bda1		00				                .byte %00000000
8506	>bda2		18				                .byte %00011000
8507	>bda3		18				                .byte %00011000
8508	>bda4		30				                .byte %00110000
8509	>bda5		66				                .byte %01100110
8510	>bda6		3c				                .byte %00111100
8511	>bda7		00				                .byte %00000000

8513							                ; CHR$181
8514	>bda8		18				                .byte %00011000
8515	>bda9		00				                .byte %00000000
8516	>bdaa		18				                .byte %00011000
8517	>bdab		18				                .byte %00011000
8518	>bdac		18				                .byte %00011000
8519	>bdad		18				                .byte %00011000
8520	>bdae		18				                .byte %00011000
8521	>bdaf		00				                .byte %00000000

8523							                ; CHR$182
8524	>bdb0		36				                .byte %00110110
8525	>bdb1		6c				                .byte %01101100
8526	>bdb2		00				                .byte %00000000
8527	>bdb3		66				                .byte %01100110
8528	>bdb4		76				                .byte %01110110
8529	>bdb5		6e				                .byte %01101110
8530	>bdb6		66				                .byte %01100110
8531	>bdb7		00				                .byte %00000000

8533							                ; CHR$183
8534	>bdb8		36				                .byte %00110110
8535	>bdb9		6c				                .byte %01101100
8536	>bdba		00				                .byte %00000000
8537	>bdbb		7c				                .byte %01111100
8538	>bdbc		66				                .byte %01100110
8539	>bdbd		66				                .byte %01100110
8540	>bdbe		66				                .byte %01100110
8541	>bdbf		00				                .byte %00000000

8543							                ; CHR$184
8544	>bdc0		18				                .byte %00011000
8545	>bdc1		7e				                .byte %01111110
8546	>bdc2		18				                .byte %00011000
8547	>bdc3		18				                .byte %00011000
8548	>bdc4		18				                .byte %00011000
8549	>bdc5		18				                .byte %00011000
8550	>bdc6		18				                .byte %00011000
8551	>bdc7		00				                .byte %00000000

8553							                ; CHR$185
8554	>bdc8		18				                .byte %00011000
8555	>bdc9		7e				                .byte %01111110
8556	>bdca		18				                .byte %00011000
8557	>bdcb		18				                .byte %00011000
8558	>bdcc		18				                .byte %00011000
8559	>bdcd		7e				                .byte %01111110
8560	>bdce		18				                .byte %00011000
8561	>bdcf		00				                .byte %00000000

8563							                ; CHR$186
8564							                .if version==350
8565	>bdd0		18				                .byte %00011000
8566	>bdd1		00				                .byte %00000000
8567	>bdd2		00				                .byte %00000000
8568	>bdd3		00				                .byte %00000000
8569	>bdd4		00				                .byte %00000000
8570	>bdd5		00				                .byte %00000000
8571	>bdd6		00				                .byte %00000000
8572	>bdd7		00				                .byte %00000000
8582							                .endif

8584							                ; CHR$187
8585							                .if version==350
8586	>bdd8		30				                .byte %00110000
8587	>bdd9		18				                .byte %00011000
8588	>bdda		00				                .byte %00000000
8589	>bddb		00				                .byte %00000000
8590	>bddc		00				                .byte %00000000
8591	>bddd		00				                .byte %00000000
8592	>bdde		00				                .byte %00000000
8593	>bddf		00				                .byte %00000000
8603							                .endif

8605							                ; CHR$188
8606							                .if version==350
8607	>bde0		03				                .byte %00000011
8608	>bde1		3e				                .byte %00111110
8609	>bde2		76				                .byte %01110110
8610	>bde3		76				                .byte %01110110
8611	>bde4		36				                .byte %00110110
8612	>bde5		36				                .byte %00110110
8613	>bde6		3e				                .byte %00111110
8614	>bde7		00				                .byte %00000000
8624							                .endif

8626							                ; CHR$189
8627	>bde8		00				                .byte %00000000
8628	>bde9		00				                .byte %00000000
8629	>bdea		00				                .byte %00000000
8630	>bdeb		18				                .byte %00011000
8631	>bdec		18				                .byte %00011000
8632	>bded		00				                .byte %00000000
8633	>bdee		00				                .byte %00000000
8634	>bdef		00				                .byte %00000000

8636							                ; CHR$190
8637	>bdf0		03				                .byte %00000011
8638	>bdf1		03				                .byte %00000011
8639	>bdf2		06				                .byte %00000110
8640	>bdf3		06				                .byte %00000110
8641	>bdf4		76				                .byte %01110110
8642	>bdf5		1c				                .byte %00011100
8643	>bdf6		0c				                .byte %00001100
8644	>bdf7		00				                .byte %00000000

8646							                ; CHR$191
8647	>bdf8		aa				                .byte %10101010
8648	>bdf9		55				                .byte %01010101
8649	>bdfa		aa				                .byte %10101010
8650	>bdfb		55				                .byte %01010101
8651	>bdfc		aa				                .byte %10101010
8652	>bdfd		55				                .byte %01010101
8653	>bdfe		aa				                .byte %10101010
8654	>bdff		55				                .byte %01010101

8656							                ; CHR$192
8657	>be00		3e				                .byte %00111110
8658	>be01		63				                .byte %01100011
8659	>be02		67				                .byte %01100111
8660	>be03		6b				                .byte %01101011
8661	>be04		73				                .byte %01110011
8662	>be05		63				                .byte %01100011
8663	>be06		3e				                .byte %00111110
8664	>be07		00				                .byte %00000000

8666							                ; CHR$193
8667	>be08		1c				                .byte %00011100
8668	>be09		36				                .byte %00110110
8669	>be0a		63				                .byte %01100011
8670	>be0b		63				                .byte %01100011
8671	>be0c		7f				                .byte %01111111
8672	>be0d		63				                .byte %01100011
8673	>be0e		63				                .byte %01100011
8674	>be0f		00				                .byte %00000000

8676							                ; CHR$194
8677	>be10		7e				                .byte %01111110
8678	>be11		33				                .byte %00110011
8679	>be12		33				                .byte %00110011
8680	>be13		3e				                .byte %00111110
8681	>be14		33				                .byte %00110011
8682	>be15		33				                .byte %00110011
8683	>be16		7e				                .byte %01111110
8684	>be17		00				                .byte %00000000

8686							                ; CHR$195
8687	>be18		7f				                .byte %01111111
8688	>be19		63				                .byte %01100011
8689	>be1a		60				                .byte %01100000
8690	>be1b		60				                .byte %01100000
8691	>be1c		60				                .byte %01100000
8692	>be1d		60				                .byte %01100000
8693	>be1e		60				                .byte %01100000
8694	>be1f		00				                .byte %00000000

8696							                ; CHR$196
8697	>be20		1c				                .byte %00011100
8698	>be21		1c				                .byte %00011100
8699	>be22		36				                .byte %00110110
8700	>be23		36				                .byte %00110110
8701	>be24		63				                .byte %01100011
8702	>be25		63				                .byte %01100011
8703	>be26		7f				                .byte %01111111
8704	>be27		00				                .byte %00000000

8706							                ; CHR$197
8707	>be28		7f				                .byte %01111111
8708	>be29		33				                .byte %00110011
8709	>be2a		30				                .byte %00110000
8710	>be2b		3e				                .byte %00111110
8711	>be2c		30				                .byte %00110000
8712	>be2d		33				                .byte %00110011
8713	>be2e		7f				                .byte %01111111
8714	>be2f		00				                .byte %00000000

8716							                ; CHR$198
8717	>be30		7e				                .byte %01111110
8718	>be31		66				                .byte %01100110
8719	>be32		0c				                .byte %00001100
8720	>be33		18				                .byte %00011000
8721	>be34		30				                .byte %00110000
8722	>be35		66				                .byte %01100110
8723	>be36		7e				                .byte %01111110
8724	>be37		00				                .byte %00000000

8726							                ; CHR$199
8727	>be38		77				                .byte %01110111
8728	>be39		33				                .byte %00110011
8729	>be3a		33				                .byte %00110011
8730	>be3b		3f				                .byte %00111111
8731	>be3c		33				                .byte %00110011
8732	>be3d		33				                .byte %00110011
8733	>be3e		77				                .byte %01110111
8734	>be3f		00				                .byte %00000000

8736							                ; CHR$200
8737	>be40		3e				                .byte %00111110
8738	>be41		63				                .byte %01100011
8739	>be42		63				                .byte %01100011
8740	>be43		7f				                .byte %01111111
8741	>be44		63				                .byte %01100011
8742	>be45		63				                .byte %01100011
8743	>be46		3e				                .byte %00111110
8744	>be47		00				                .byte %00000000

8746							                ; CHR$201
8747	>be48		3c				                .byte %00111100
8748	>be49		18				                .byte %00011000
8749	>be4a		18				                .byte %00011000
8750	>be4b		18				                .byte %00011000
8751	>be4c		18				                .byte %00011000
8752	>be4d		18				                .byte %00011000
8753	>be4e		3c				                .byte %00111100
8754	>be4f		00				                .byte %00000000

8756							                ; CHR$202
8757	>be50		63				                .byte %01100011
8758	>be51		66				                .byte %01100110
8759	>be52		6c				                .byte %01101100
8760	>be53		78				                .byte %01111000
8761	>be54		6c				                .byte %01101100
8762	>be55		66				                .byte %01100110
8763	>be56		63				                .byte %01100011
8764	>be57		00				                .byte %00000000

8766							                ; CHR$203
8767	>be58		1c				                .byte %00011100
8768	>be59		1c				                .byte %00011100
8769	>be5a		36				                .byte %00110110
8770	>be5b		36				                .byte %00110110
8771	>be5c		63				                .byte %01100011
8772	>be5d		63				                .byte %01100011
8773	>be5e		63				                .byte %01100011
8774	>be5f		00				                .byte %00000000

8776							                ; CHR$204
8777	>be60		63				                .byte %01100011
8778	>be61		77				                .byte %01110111
8779	>be62		7f				                .byte %01111111
8780	>be63		6b				                .byte %01101011
8781	>be64		63				                .byte %01100011
8782	>be65		63				                .byte %01100011
8783	>be66		63				                .byte %01100011
8784	>be67		00				                .byte %00000000

8786							                ; CHR$205
8787	>be68		63				                .byte %01100011
8788	>be69		73				                .byte %01110011
8789	>be6a		7b				                .byte %01111011
8790	>be6b		6f				                .byte %01101111
8791	>be6c		67				                .byte %01100111
8792	>be6d		63				                .byte %01100011
8793	>be6e		63				                .byte %01100011
8794	>be6f		00				                .byte %00000000

8796							                ; CHR$206
8797	>be70		7e				                .byte %01111110
8798	>be71		00				                .byte %00000000
8799	>be72		00				                .byte %00000000
8800	>be73		3c				                .byte %00111100
8801	>be74		00				                .byte %00000000
8802	>be75		00				                .byte %00000000
8803	>be76		7e				                .byte %01111110
8804	>be77		00				                .byte %00000000

8806							                ; CHR$207
8807	>be78		3e				                .byte %00111110
8808	>be79		63				                .byte %01100011
8809	>be7a		63				                .byte %01100011
8810	>be7b		63				                .byte %01100011
8811	>be7c		63				                .byte %01100011
8812	>be7d		63				                .byte %01100011
8813	>be7e		3e				                .byte %00111110
8814	>be7f		00				                .byte %00000000

8816							                ; CHR$208
8817	>be80		7f				                .byte %01111111
8818	>be81		36				                .byte %00110110
8819	>be82		36				                .byte %00110110
8820	>be83		36				                .byte %00110110
8821	>be84		36				                .byte %00110110
8822	>be85		36				                .byte %00110110
8823	>be86		36				                .byte %00110110
8824	>be87		00				                .byte %00000000

8826							                ; CHR$209
8827	>be88		7e				                .byte %01111110
8828	>be89		33				                .byte %00110011
8829	>be8a		33				                .byte %00110011
8830	>be8b		3e				                .byte %00111110
8831	>be8c		30				                .byte %00110000
8832	>be8d		30				                .byte %00110000
8833	>be8e		78				                .byte %01111000
8834	>be8f		00				                .byte %00000000

8836							                ; CHR$210
8837	>be90		7f				                .byte %01111111
8838	>be91		63				                .byte %01100011
8839	>be92		30				                .byte %00110000
8840	>be93		18				                .byte %00011000
8841	>be94		30				                .byte %00110000
8842	>be95		63				                .byte %01100011
8843	>be96		7f				                .byte %01111111
8844	>be97		00				                .byte %00000000

8846							                ; CHR$211
8847	>be98		7e				                .byte %01111110
8848	>be99		5a				                .byte %01011010
8849	>be9a		18				                .byte %00011000
8850	>be9b		18				                .byte %00011000
8851	>be9c		18				                .byte %00011000
8852	>be9d		18				                .byte %00011000
8853	>be9e		18				                .byte %00011000
8854	>be9f		00				                .byte %00000000

8856							                ; CHR$212
8857	>bea0		66				                .byte %01100110
8858	>bea1		66				                .byte %01100110
8859	>bea2		66				                .byte %01100110
8860	>bea3		3c				                .byte %00111100
8861	>bea4		18				                .byte %00011000
8862	>bea5		18				                .byte %00011000
8863	>bea6		3c				                .byte %00111100
8864	>bea7		00				                .byte %00000000

8866							                ; CHR$213
8867	>bea8		3e				                .byte %00111110
8868	>bea9		08				                .byte %00001000
8869	>beaa		3e				                .byte %00111110
8870	>beab		6b				                .byte %01101011
8871	>beac		3e				                .byte %00111110
8872	>bead		08				                .byte %00001000
8873	>beae		3e				                .byte %00111110
8874	>beaf		00				                .byte %00000000

8876							                ; CHR$214
8877	>beb0		63				                .byte %01100011
8878	>beb1		63				                .byte %01100011
8879	>beb2		36				                .byte %00110110
8880	>beb3		1c				                .byte %00011100
8881	>beb4		36				                .byte %00110110
8882	>beb5		63				                .byte %01100011
8883	>beb6		63				                .byte %01100011
8884	>beb7		00				                .byte %00000000

8886							                ; CHR$215
8887	>beb8		3e				                .byte %00111110
8888	>beb9		08				                .byte %00001000
8889	>beba		6b				                .byte %01101011
8890	>bebb		6b				                .byte %01101011
8891	>bebc		3e				                .byte %00111110
8892	>bebd		08				                .byte %00001000
8893	>bebe		3e				                .byte %00111110
8894	>bebf		00				                .byte %00000000

8896							                ; CHR$216
8897	>bec0		3e				                .byte %00111110
8898	>bec1		63				                .byte %01100011
8899	>bec2		63				                .byte %01100011
8900	>bec3		63				                .byte %01100011
8901	>bec4		36				                .byte %00110110
8902	>bec5		36				                .byte %00110110
8903	>bec6		63				                .byte %01100011
8904	>bec7		00				                .byte %00000000

8906							                ; CHR$217
8907	>bec8		7f				                .byte %01111111
8908	>bec9		63				                .byte %01100011
8909	>beca		63				                .byte %01100011
8910	>becb		36				                .byte %00110110
8911	>becc		36				                .byte %00110110
8912	>becd		1c				                .byte %00011100
8913	>bece		1c				                .byte %00011100
8914	>becf		00				                .byte %00000000

8916							                ; CHR$218
8917	>bed0		18				                .byte %00011000
8918	>bed1		18				                .byte %00011000
8919	>bed2		7e				                .byte %01111110
8920	>bed3		18				                .byte %00011000
8921	>bed4		18				                .byte %00011000
8922	>bed5		00				                .byte %00000000
8923	>bed6		7e				                .byte %01111110
8924	>bed7		00				                .byte %00000000

8926							                ; CHR$219
8927	>bed8		00				                .byte %00000000
8928	>bed9		7e				                .byte %01111110
8929	>beda		00				                .byte %00000000
8930	>bedb		18				                .byte %00011000
8931	>bedc		18				                .byte %00011000
8932	>bedd		7e				                .byte %01111110
8933	>bede		18				                .byte %00011000
8934	>bedf		18				                .byte %00011000

8936							                ; CHR$220
8937	>bee0		18				                .byte %00011000
8938	>bee1		18				                .byte %00011000
8939	>bee2		18				                .byte %00011000
8940	>bee3		18				                .byte %00011000
8941	>bee4		18				                .byte %00011000
8942	>bee5		18				                .byte %00011000
8943	>bee6		18				                .byte %00011000
8944	>bee7		00				                .byte %00000000

8946							                ; CHR$221
8947	>bee8		36				                .byte %00110110
8948	>bee9		36				                .byte %00110110
8949	>beea		36				                .byte %00110110
8950	>beeb		36				                .byte %00110110
8951	>beec		36				                .byte %00110110
8952	>beed		36				                .byte %00110110
8953	>beee		36				                .byte %00110110
8954	>beef		00				                .byte %00000000

8956							                ; CHR$222
8957	>bef0		00				                .byte %00000000
8958	>bef1		66				                .byte %01100110
8959	>bef2		66				                .byte %01100110
8960	>bef3		66				                .byte %01100110
8961	>bef4		66				                .byte %01100110
8962	>bef5		66				                .byte %01100110
8963	>bef6		3c				                .byte %00111100
8964	>bef7		00				                .byte %00000000

8966							                ; CHR$223
8967	>bef8		00				                .byte %00000000
8968	>bef9		3c				                .byte %00111100
8969	>befa		66				                .byte %01100110
8970	>befb		66				                .byte %01100110
8971	>befc		66				                .byte %01100110
8972	>befd		66				                .byte %01100110
8973	>befe		66				                .byte %01100110
8974	>beff		00				                .byte %00000000

8976							                ; CHR$224
8977							                .if version==350
8978	>bf00		00				                .byte %00000000
8979	>bf01		02				                .byte %00000010
8980	>bf02		3c				                .byte %00111100
8981	>bf03		6e				                .byte %01101110
8982	>bf04		76				                .byte %01110110
8983	>bf05		66				                .byte %01100110
8984	>bf06		bc				                .byte %10111100
8985	>bf07		00				                .byte %00000000
8995							                .endif

8997							                ; CHR$225
8998	>bf08		00				                .byte %00000000
8999	>bf09		00				                .byte %00000000
9000	>bf0a		3b				                .byte %00111011
9001	>bf0b		6e				                .byte %01101110
9002	>bf0c		66				                .byte %01100110
9003	>bf0d		6e				                .byte %01101110
9004	>bf0e		3b				                .byte %00111011
9005	>bf0f		00				                .byte %00000000

9007							                ; CHR$226
9008	>bf10		1e				                .byte %00011110
9009	>bf11		33				                .byte %00110011
9010	>bf12		33				                .byte %00110011
9011	>bf13		3e				                .byte %00111110
9012	>bf14		33				                .byte %00110011
9013	>bf15		33				                .byte %00110011
9014	>bf16		3e				                .byte %00111110
9015	>bf17		60				                .byte %01100000

9017							                ; CHR$227
9018	>bf18		00				                .byte %00000000
9019	>bf19		00				                .byte %00000000
9020	>bf1a		66				                .byte %01100110
9021	>bf1b		36				                .byte %00110110
9022	>bf1c		1c				                .byte %00011100
9023	>bf1d		18				                .byte %00011000
9024	>bf1e		30				                .byte %00110000
9025	>bf1f		30				                .byte %00110000

9027							                ; CHR$228
9028	>bf20		3c				                .byte %00111100
9029	>bf21		60				                .byte %01100000
9030	>bf22		30				                .byte %00110000
9031	>bf23		3c				                .byte %00111100
9032	>bf24		66				                .byte %01100110
9033	>bf25		66				                .byte %01100110
9034	>bf26		3c				                .byte %00111100
9035	>bf27		00				                .byte %00000000

9037							                ; CHR$229
9038	>bf28		00				                .byte %00000000
9039	>bf29		00				                .byte %00000000
9040	>bf2a		1e				                .byte %00011110
9041	>bf2b		30				                .byte %00110000
9042	>bf2c		1c				                .byte %00011100
9043	>bf2d		30				                .byte %00110000
9044	>bf2e		1e				                .byte %00011110
9045	>bf2f		00				                .byte %00000000

9047							                ; CHR$230
9048	>bf30		3e				                .byte %00111110
9049	>bf31		0c				                .byte %00001100
9050	>bf32		18				                .byte %00011000
9051	>bf33		30				                .byte %00110000
9052	>bf34		60				                .byte %01100000
9053	>bf35		60				                .byte %01100000
9054	>bf36		3e				                .byte %00111110
9055	>bf37		06				                .byte %00000110

9057							                ; CHR$231
9058	>bf38		00				                .byte %00000000
9059	>bf39		00				                .byte %00000000
9060	>bf3a		7c				                .byte %01111100
9061	>bf3b		66				                .byte %01100110
9062	>bf3c		66				                .byte %01100110
9063	>bf3d		66				                .byte %01100110
9064	>bf3e		06				                .byte %00000110
9065	>bf3f		06				                .byte %00000110

9067							                ; CHR$232
9068	>bf40		3c				                .byte %00111100
9069	>bf41		66				                .byte %01100110
9070	>bf42		66				                .byte %01100110
9071	>bf43		7e				                .byte %01111110
9072	>bf44		66				                .byte %01100110
9073	>bf45		66				                .byte %01100110
9074	>bf46		3c				                .byte %00111100
9075	>bf47		00				                .byte %00000000

9077							                ; CHR$233
9078	>bf48		00				                .byte %00000000
9079	>bf49		00				                .byte %00000000
9080	>bf4a		18				                .byte %00011000
9081	>bf4b		18				                .byte %00011000
9082	>bf4c		18				                .byte %00011000
9083	>bf4d		18				                .byte %00011000
9084	>bf4e		0c				                .byte %00001100
9085	>bf4f		00				                .byte %00000000

9087							                ; CHR$234
9088	>bf50		00				                .byte %00000000
9089	>bf51		00				                .byte %00000000
9090	>bf52		66				                .byte %01100110
9091	>bf53		6c				                .byte %01101100
9092	>bf54		78				                .byte %01111000
9093	>bf55		6c				                .byte %01101100
9094	>bf56		66				                .byte %01100110
9095	>bf57		00				                .byte %00000000

9097							                ; CHR$235
9098	>bf58		60				                .byte %01100000
9099	>bf59		30				                .byte %00110000
9100	>bf5a		18				                .byte %00011000
9101	>bf5b		1c				                .byte %00011100
9102	>bf5c		36				                .byte %00110110
9103	>bf5d		63				                .byte %01100011
9104	>bf5e		63				                .byte %01100011
9105	>bf5f		00				                .byte %00000000

9107							                ; CHR$236
9108	>bf60		00				                .byte %00000000
9109	>bf61		00				                .byte %00000000
9110	>bf62		33				                .byte %00110011
9111	>bf63		33				                .byte %00110011
9112	>bf64		33				                .byte %00110011
9113	>bf65		33				                .byte %00110011
9114	>bf66		3e				                .byte %00111110
9115	>bf67		60				                .byte %01100000

9117							                ; CHR$237
9118	>bf68		00				                .byte %00000000
9119	>bf69		00				                .byte %00000000
9120	>bf6a		63				                .byte %01100011
9121	>bf6b		33				                .byte %00110011
9122	>bf6c		1b				                .byte %00011011
9123	>bf6d		1e				                .byte %00011110
9124	>bf6e		1c				                .byte %00011100
9125	>bf6f		00				                .byte %00000000

9127							                ; CHR$238
9128							                .if version==350
9129	>bf70		0c				                .byte %00001100
9130	>bf71		3e				                .byte %00111110
9131	>bf72		60				                .byte %01100000
9132	>bf73		3c				                .byte %00111100
9133	>bf74		60				                .byte %01100000
9134	>bf75		3e				                .byte %00111110
9135	>bf76		06				                .byte %00000110
9136	>bf77		0c				                .byte %00001100
9146							                .endif

9148							                ; CHR$239
9149	>bf78		00				                .byte %00000000
9150	>bf79		00				                .byte %00000000
9151	>bf7a		3e				                .byte %00111110
9152	>bf7b		63				                .byte %01100011
9153	>bf7c		63				                .byte %01100011
9154	>bf7d		63				                .byte %01100011
9155	>bf7e		3e				                .byte %00111110
9156	>bf7f		00				                .byte %00000000

9158							                ; CHR$240
9159	>bf80		00				                .byte %00000000
9160	>bf81		00				                .byte %00000000
9161	>bf82		7f				                .byte %01111111
9162	>bf83		36				                .byte %00110110
9163	>bf84		36				                .byte %00110110
9164	>bf85		36				                .byte %00110110
9165	>bf86		36				                .byte %00110110
9166	>bf87		00				                .byte %00000000

9168							                ; CHR$241
9169	>bf88		00				                .byte %00000000
9170	>bf89		00				                .byte %00000000
9171	>bf8a		3c				                .byte %00111100
9172	>bf8b		66				                .byte %01100110
9173	>bf8c		66				                .byte %01100110
9174	>bf8d		7c				                .byte %01111100
9175	>bf8e		60				                .byte %01100000
9176	>bf8f		60				                .byte %01100000

9178							                ; CHR$242
9179	>bf90		00				                .byte %00000000
9180	>bf91		00				                .byte %00000000
9181	>bf92		3f				                .byte %00111111
9182	>bf93		66				                .byte %01100110
9183	>bf94		66				                .byte %01100110
9184	>bf95		66				                .byte %01100110
9185	>bf96		3c				                .byte %00111100
9186	>bf97		00				                .byte %00000000

9188							                ; CHR$243
9189	>bf98		00				                .byte %00000000
9190	>bf99		00				                .byte %00000000
9191	>bf9a		7e				                .byte %01111110
9192	>bf9b		18				                .byte %00011000
9193	>bf9c		18				                .byte %00011000
9194	>bf9d		18				                .byte %00011000
9195	>bf9e		0c				                .byte %00001100
9196	>bf9f		00				                .byte %00000000

9198							                ; CHR$244
9199	>bfa0		00				                .byte %00000000
9200	>bfa1		00				                .byte %00000000
9201	>bfa2		73				                .byte %01110011
9202	>bfa3		33				                .byte %00110011
9203	>bfa4		33				                .byte %00110011
9204	>bfa5		33				                .byte %00110011
9205	>bfa6		1e				                .byte %00011110
9206	>bfa7		00				                .byte %00000000

9208							                ; CHR$245
9209	>bfa8		00				                .byte %00000000
9210	>bfa9		00				                .byte %00000000
9211	>bfaa		3e				                .byte %00111110
9212	>bfab		6b				                .byte %01101011
9213	>bfac		6b				                .byte %01101011
9214	>bfad		3e				                .byte %00111110
9215	>bfae		18				                .byte %00011000
9216	>bfaf		18				                .byte %00011000

9218							                ; CHR$246
9219	>bfb0		00				                .byte %00000000
9220	>bfb1		00				                .byte %00000000
9221	>bfb2		66				                .byte %01100110
9222	>bfb3		36				                .byte %00110110
9223	>bfb4		1c				                .byte %00011100
9224	>bfb5		1c				                .byte %00011100
9225	>bfb6		36				                .byte %00110110
9226	>bfb7		33				                .byte %00110011

9228							                ; CHR$247
9229	>bfb8		00				                .byte %00000000
9230	>bfb9		00				                .byte %00000000
9231	>bfba		63				                .byte %01100011
9232	>bfbb		6b				                .byte %01101011
9233	>bfbc		6b				                .byte %01101011
9234	>bfbd		3e				                .byte %00111110
9235	>bfbe		18				                .byte %00011000
9236	>bfbf		18				                .byte %00011000

9238							                ; CHR$248
9239							                .if version==350
9240	>bfc0		00				                .byte %00000000
9241	>bfc1		00				                .byte %00000000
9242	>bfc2		63				                .byte %01100011
9243	>bfc3		63				                .byte %01100011
9244	>bfc4		6b				                .byte %01101011
9245	>bfc5		7f				                .byte %01111111
9246	>bfc6		36				                .byte %00110110
9247	>bfc7		00				                .byte %00000000
9257							                .endif

9259							                ; CHR$249
9260	>bfc8		38				                .byte %00111000
9261	>bfc9		0c				                .byte %00001100
9262	>bfca		06				                .byte %00000110
9263	>bfcb		3e				                .byte %00111110
9264	>bfcc		66				                .byte %01100110
9265	>bfcd		66				                .byte %01100110
9266	>bfce		3c				                .byte %00111100
9267	>bfcf		00				                .byte %00000000

9269							                ; CHR$250
9270	>bfd0		00				                .byte %00000000
9271	>bfd1		31				                .byte %00110001
9272	>bfd2		6b				                .byte %01101011
9273	>bfd3		46				                .byte %01000110
9274	>bfd4		00				                .byte %00000000
9275	>bfd5		7f				                .byte %01111111
9276	>bfd6		00				                .byte %00000000
9277	>bfd7		00				                .byte %00000000

9279							                ; CHR$251
9280	>bfd8		00				                .byte %00000000
9281	>bfd9		7e				                .byte %01111110
9282	>bfda		00				                .byte %00000000
9283	>bfdb		7e				                .byte %01111110
9284	>bfdc		00				                .byte %00000000
9285	>bfdd		7e				                .byte %01111110
9286	>bfde		00				                .byte %00000000
9287	>bfdf		00				                .byte %00000000

9289							                ; CHR$252
9290	>bfe0		07				                .byte %00000111
9291	>bfe1		1c				                .byte %00011100
9292	>bfe2		70				                .byte %01110000
9293	>bfe3		1c				                .byte %00011100
9294	>bfe4		07				                .byte %00000111
9295	>bfe5		00				                .byte %00000000
9296	>bfe6		7f				                .byte %01111111
9297	>bfe7		00				                .byte %00000000

9299							                ; CHR$253
9300	>bfe8		06				                .byte %00000110
9301	>bfe9		0c				                .byte %00001100
9302	>bfea		7e				                .byte %01111110
9303	>bfeb		18				                .byte %00011000
9304	>bfec		7e				                .byte %01111110
9305	>bfed		30				                .byte %00110000
9306	>bfee		60				                .byte %01100000
9307	>bfef		00				                .byte %00000000

9309							                ; CHR$254
9310	>bff0		70				                .byte %01110000
9311	>bff1		1c				                .byte %00011100
9312	>bff2		07				                .byte %00000111
9313	>bff3		1c				                .byte %00011100
9314	>bff4		70				                .byte %01110000
9315	>bff5		00				                .byte %00000000
9316	>bff6		7f				                .byte %01111111
9317	>bff7		00				                .byte %00000000

9319							                ; CHR$255
9320	>bff8		ff				                .byte %11111111
9321	>bff9		ff				                .byte %11111111
9322	>bffa		ff				                .byte %11111111
9323	>bffb		ff				                .byte %11111111
9324	>bffc		ff				                .byte %11111111
9325	>bffd		ff				                .byte %11111111
9326	>bffe		ff				                .byte %11111111
9327	>bfff		ff				                .byte %11111111


:1	;******  Return to file: mos350.s65

33							                .endsection

35							                .section mos
36							                .include "src/mos.s65"

:15	;******  Processing file: src/mos.s65

1							; -*- comment-column:45; -*-

3							; VDU driver entry block
4							; ======================
5	.c000						LC000:                                       ; Read from VDU memory
6	.c000		b1 d6		lda ($d6),y	                lda (ZMEMG),y
7	.c002		60		rts		                rts
8	.c003						LC003:                                       ; Write to VDU memory
9	.c003		91 d6		sta ($d6),y	                sta (ZMEMG),y
10	.c005		60		rts		                rts

12							; MasRef E.4-6
13							;
14							; JSR PLBYTE plots the mask held in ZMASK into the byte pointed to by
15							; (ZMEMG),y, using ZGORA and ZGEOR as colour masks. See GADDR below
16							; for an example of its use.
17							;
18							; PLBYTE uses ZTEMP as workspace and preserves X, Y, V and C.
19	.c006						PLBYTE:
20	.c006		4c 50 db	jmp $db50	                jmp plbyteEntryPoint

22							; MasRef E.4-6
23							;
24							; JSR HPLOT plots a fast horizontal line in the current graphics
25							; colour or ECF and the current graphics mode (all as set by VDU 18)
26							; between two specified points. It is the low level primitive used by
27							; all the MOS area fill commands.
28							;
29							; On entry, two 4 byte areas at &300+X and &300+Y contain the
30							; coordinates of the two endpoints, in the standard
31							; lowX,highX,lowY,highY order. Should the Y coordinates differ, the Y
32							; coordinate of the line plotted is taken from the leftmost of the two
33							; points specified.
34							;
35							; Only portions of the line inside the graphics window are plotted.
36							; Subject to this, both endpoints of the line are plotted.
37							;
38							; HPLOT uses ZGORA, ZGEOR, ZMASK, ZMEMG, ZTEMP (but not ZTEMP+1),
39							; ZTEMPB, ZTEMPB+1, ZTEMPC and ZTEMPC+1 as workspace. No registers or
40							; flags are preserved.
41	.c009						HPLOT:
42	.c009		4c e7 da	jmp $dae7	                jmp LDAE8

44							; MasRef E.4-6
45							;
46							; JSR EIGABS converts the 4 byte pair of external coordinates at
47							; &300+X where X>=2 (in standard lowX,highX,lowY,highY order) into the
48							; corresponding pair of pixel coordinates by offsetting by the
49							; graphics origin, then dividing by an appropriate power of 2.
50							;
51							; EIGABS uses ZTEMP as workspace, and corrupts all registers and
52							; flags.
53	.c00c						EIGABS:
54	.c00c		4c dd d1	jmp $d1dd	                jmp eigabsEntryPoint

56							; MasRef E.4-7
57							;
58							; JSR WIND windows the 4 byte pair of pixel coordinates (in standard
59							; lowX,highX,lowY,highY order) at &300+X, and returns a result in A
60							; according to its position with respect to the window:

62							; 9 | 8 | 10
63							; --+---+---
64							; 1 | 0 | 2
65							; --+---+---
66							; 5 | 4 | 6

68							; WIND uses ZTEMP as workspace, preserves X and sets N and Z according
69							; to A.
70	.c00f						WIND:
71	.c00f		4c a7 d1	jmp $d1a7	                jmp windEntryPoint

73							; MasRef E.4-7
74							;
75							; JSR GADDR addresses the pixel whose 4 byte pair of pixel coordinates
76							; (in standard lowX,highX,lowY,highY order) is at &300+X. GADDR should
77							; not be called without first ensuring (typically by means of WIND)
78							; that the point concerned does lie within the screen.
79							;
80							; GADDR initialises the following variables:
81							;
82							; . ZMEMG to the start of the page of memory containing the pixel.
83							;
84							; . Y and VDU variable &1A (i.e. location &31A) to contain the offset
85							; of the byte containing the pixel within this page - i.e. (ZMEMG),y
86							; points to the byte containing the pixel.
87							;
88							; . ZMASK to a mask indicating which bits of this byte constitute the
89							; pixel.
90							;
91							; . ZGORA and ZGEOR to the correct colour masks for the current
92							; graphics plot mode (found in VDU variable &5A) and colour/ECF
93							;
94							; . X to Y MOD 7, i.e. the scan line within a character row of the
95							; pixel.
96							;
97							; Additionally, GADDR uses ZTEMP as workspace and returns A=0, Z=1.
98							;
99							; An example of the use of PLBYTE, WIND and GADDR is the following
100							; code, which effectively re-implements the VDU 25 64-71 (plot a
101							; point) calls. It assumes that the routine addresses have been
102							; previously defined and that the graphics plot mode, etc. were set up
103							; by the VDU 25 code before the unknown PLOT codes vector was entered:

105							; .POINT
106							;  LDX #&20   ;Addresses new point within VDU queue, as
107							;             ;left on entry to the unknown PLOT codes
108							;             ;vector.
109							;  JSR WIND   ;Is the point inside the window?
110							;  BNE END    ;Return if not.
111							;  JSR GADDR  ;Address the point now we know it's on
112							;             ;screen.
113							;  JSR PLBYTE ;And plot the point.
114							; .END
115							;  RTS
116	.c012						GADDR:
117	.c012		4c c8 de	jmp $dec8	                jmp gaddrEntryPoint

119							; MasRef E.4-8
120							;
121							; JSR IEG takes the internal pixel coordinates of the graphics cursor
122							; (in VDU variables &24-&27), converts it back to external coordinates
123							; and stores the result in VDU variables &10-&13.
124							;
125							; It should be called whenever the graphics code generates a new
126							; graphics cursor position (e.g. in the VDU drivers, it is called
127							; after a character is printed in VDU 5 mode). Its purpose is to make
128							; the two versions of the graphics cursor agree again, and thus
129							; prevent errors occurring with relative plots.
130							;
131							; IEG uses no page zero locations and corrupts all registers and
132							; flags.
133	.c015						IEG:
134	.c015		4c de c4	jmp $c4de	                jmp LC4DF

136							;-------------------------------------------------------------------------

138	.c018						LC018:                                       ; Fetch byte from ROM Y
139	.c018		a6 f4		ldx $f4		                ldx $F4                      ; Get current ROM
140	.c01a		84 f4		sty $f4		                sty $F4                      ; Select ROM in Y
141	.c01c		8c 30 fe	sty $fe30	                sty ROMSEL
142	.c01f		b2 f6		lda ($f6)	                lda ($F6)                    ; Get byte with ROM Y paged in
143	.c021		4c 4b e5	jmp $e54b	                jmp selectROMX                    ; Page in ROM X and return

145	.c024						LC024:
146	.c024		6c 5d 03	jmp ($035d)	                jmp ($035D)

148							;-------------------------------------------------------------------------
149							;
150							; VDU driver entry point
151							;
152							; Output to VDU.
153							;
154	.c027						outputToVDU:
155	.c027		ae 6a 02	ldx $026a	                ldx vduQueueNegativeLength  ;get VDU queue length
156	.c02a		f0 2d		beq $c059	                beq outputCharToVDU         ;taken if empty
157	.c02c		9d 24 02	sta $0224,x	                sta vduv.queueEnd-1-255,x   ;add to queue
158	.c02f		ee 6a 02	inc $026a	                inc vduQueueNegativeLength  ;one more in the queue...
159	.c032		f0 02		beq $c036	                beq outputQueueToVDU        ;taken if queue now filled
160	.c034						clc_rts_c034:
161	.c034		18		clc		                clc

163							;-------------------------------------------------------------------------
164							;
165							; VDU 0 (&00) Null [MasRef E.3-1]
166							; VDU 6 (&06) Enable VDU driver [MasRef E.3-3]
167							; VDU 27 (&1B) Null [MasRef E.3-34]
168							;
169	.c035						vdu0EntryPoint:
170	.c035						vdu6EntryPoint:
171	.c035						vdu27EntryPoint:
172	.c035						rtsC035:
173	.c035		60		rts		                rts

175							;-------------------------------------------------------------------------

177	.c036						outputQueueToVDU:
178	.c036		24 d0		bit $d0		                bit STATE
179	.c038		10 19		bpl $c053	                bpl LC053              ;branch taken if not VDU21 mode

181							                ; ????
182	.c03a		ac 5e 03	ldy $035e	                ldy vduv.jumpVector+1
183	.c03d		c0 c0		cpy #$c0	                cpy #>vdu1EntryPoint
184	.c03f		d0 f3		bne $c034	                bne clc_rts_c034
185	.c041		ac 5d 03	ldy $035d	                ldy vduv.jumpVector+0
186	.c044		c0 e1		cpy #$e1	                cpy #<vdu1EntryPoint
187	.c046		d0 ec		bne $c034	                bne clc_rts_c034

189	.c048						outputCharToPrinter:
190	.c048		aa		tax		                tax                          ;save char to print
191	.c049		a5 d0		lda $d0		                lda STATE
192	.c04b		4a		lsr a		                lsr a                       ;C set if isPrinterEnabled
193	.c04c		90 e7		bcc $c035	                bcc rtsC035 ;taken if printer disabled - VDU 1 then a no-op
194	.c04e		8a		txa		                txa                          ;restore char to print
195	.c04f		18		clc		                clc
196							                .if version<350
198							                .else
199	.c050		4c db e2	jmp $e2db	                jmp LE2ED
200							                .endif

202	.c053						LC053:
203	.c053		20 f9 c0	jsr $c0f9	                jsr stopCursorEditing
204	.c056		18		clc		                clc
205	.c057		80 66		bra $c0bf	                bra LC0C0

207	.c059						outputCharToVDU:
208	.c059		20 f9 c0	jsr $c0f9	                jsr stopCursorEditing
209	.c05c		50 0f		bvc $c06d	                bvc LC06D             ;taken if not previously editing
210	.c05e		30 0d		bmi $c06d	                bmi LC06D             ;taken if VDU 21
211	.c060		c9 0d		cmp #$0d	                cmp #$0D
212	.c062		d0 09		bne $c06d	                bne LC06D                  ;taken if not printing a CR
213	.c064		48		pha		                pha                        ;save char to print
214	.c065		a9 42		lda #$42	                lda #STATE.isCursorEditing|STATE.isScrollingDisabled
215	.c067		14 d0		trb $d0		                trb STATE
216	.c069		20 4f cf	jsr $cf4f	                jsr showCursor
217	.c06c		68		pla		                pla                          ;restore char to print
218	.c06d						LC06D:
219	.c06d		c9 20		cmp #$20	                cmp #$20
220	.c06f		90 06		bcc $c077	                bcc handleControlChar
221	.c071		c9 7f		cmp #$7f	                cmp #$7F
222	.c073		d0 20		bne $c095	                bne LC096                    ;taken if not backspace
223	.c075		a9 20		lda #$20	                lda #$20 ;backspace is entry 32 in the VDU routines table
224	.c077						handleControlChar:
225	.c077		a8		tay		                tay                          ;Y=index in table
226	.c078		b9 25 e0	lda $e025,y	                lda vduRoutinesLSBTable,y
227	.c07b		8d 5d 03	sta $035d	                sta vduv.jumpVector+0 ; Store jump address LSB (see MasRef E.4-3)
228	.c07e		b9 46 e0	lda $e046,y	                lda vduRoutinesMSBTable,y
229	.c081		30 2f		bmi $c0b2	                bmi LC0B3           ;branch taken if MSB directly
230	.c083		aa		tax		                tax                          ; Save original MSB value
231	.c084		09 f0		ora #$f0	                ora #$F0
232	.c086		8d 6a 02	sta $026a	                sta vduQueueNegativeLength ;initialise initial VDU queue length
233	.c089		8a		txa		                txa                          ; Restore original MSB value
234							                .if version==350
235	.c08a		20 20 e5	jsr $e520	                jsr LE520
241							                .endif
242	.c08d		18		clc		                clc                          ;
243	.c08e		69 c0		adc #$c0	                adc #vduRoutinesPage         ; form MSB
244	.c090		8d 5e 03	sta $035e	                sta vduv.jumpVector+1
245	.c093		80 34		bra $c0c9	                bra reinstateCursorEditing                    ; Continue

247	.c095						LC096:
248	.c095		24 d0		bit $d0		                bit STATE
249	.c097		30 2d		bmi $c0c6	                bmi LC0C7                    ;taken if VDU21
250	.c099		20 0c ce	jsr $ce0c	                jsr LCE0C
251	.c09c		a9 20		lda #$20	                lda #$20
252	.c09e		2c 66 03	bit $0366	                bit $0366
253	.c0a1		d0 23		bne $c0c6	                bne LC0C7
254	.c0a3		20 75 c2	jsr $c275	                jsr LC276
255	.c0a6		80 1e		bra $c0c6	                bra LC0C7

257	.c0a8						LC0A9:
258	.c0a8		49 06		eor #$06	                eor #$06
259	.c0aa		d0 18		bne $c0c4	                bne LC0C5
260	.c0ac		a9 80		lda #$80	                lda #STATE.isVDU21
261	.c0ae		14 d0		trb $d0		                trb STATE
262	.c0b0		80 17		bra $c0c9	                bra reinstateCursorEditing

264	.c0b2						LC0B3:
265	.c0b2		8d 5e 03	sta $035e	                sta vduv.jumpVector+1
266	.c0b5		98		tya		                tya
267	.c0b6		49 f7		eor #$f7	                eor #$F7
268	.c0b8		c9 fa		cmp #$fa	                cmp #$FA
269	.c0ba		98		tya		                tya
270	.c0bb		24 d0		bit $d0		                bit STATE
271	.c0bd		30 e9		bmi $c0a8	                bmi LC0A9             ;branch taken if VDU21 in effect
272	.c0bf						LC0C0:
273	.c0bf		08		php		                php
274	.c0c0		20 24 c0	jsr $c024	                jsr LC024
275	.c0c3		28		plp		                plp
276	.c0c4						LC0C5:
277	.c0c4		90 03		bcc $c0c9	                bcc reinstateCursorEditing
278	.c0c6						LC0C7:
279	.c0c6		a5 d0		lda $d0		                lda STATE
280	.c0c8		4a		lsr a		                lsr a                          ;C=1 if printer enabled
281	.c0c9						reinstateCursorEditing:
282	.c0c9		24 d0		bit $d0		                bit STATE
283	.c0cb		50 13		bvc $c0e0	                bvc rtsC0E1               ;taken if not cursor editing
284	.c0cd		20 04 c1	jsr $c104	                jsr activateEditCursor
285	.c0d0						exchangeCursors:
286	.c0d0		08		php		                php
287	.c0d1		48		pha		                pha
288	.c0d2		a5 d0		lda $d0		                lda STATE
289	.c0d4		49 02		eor #$02	                eor #STATE.isScrollingDisabled
290	.c0d6		85 d0		sta $d0		                sta STATE
291	.c0d8		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
292	.c0db		20 d7 c6	jsr $c6d7	                jsr updateCRTCTextCursor
293	.c0de		68		pla		                pla
294	.c0df		28		plp		                plp
295	.c0e0						rtsC0E1:
296	.c0e0		60		rts		                rts

298							;-------------------------------------------------------------------------
299							;
300							; VDU 1 (&01) Send next character to printer only [MasRef E.3-2]
301							;
302	.c0e1						vdu1EntryPoint:
303	.c0e1		20 c9 c0	jsr $c0c9	                jsr reinstateCursorEditing
304	.c0e4		20 48 c0	jsr $c048	                jsr outputCharToPrinter
305	.c0e7		80 10		bra $c0f9	                bra stopCursorEditing

307							;-------------------------------------------------------------------------
308							;
309							; VDU 2 (&02) Enable printer [MasRef E.3-2]
310							; VDU 3 (&03) Disable printer [MasRef E.3-3]
311							;
312	.c0e9						vdu2EntryPoint:
313	.c0e9						vdu3EntryPoint:
314	.c0e9		48		pha		                pha                          ;
315	.c0ea		20 c9 c0	jsr $c0c9	                jsr reinstateCursorEditing
316							                .if version<350
318							                .else
319	.c0ed		20 d5 e2	jsr $e2d5	                jsr LE2E7
320							                .endif
321	.c0f0		a9 01		lda #$01	                lda #STATE.isPrinterEnabled  ;
322	.c0f2		04 d0		tsb $d0		                tsb STATE
323	.c0f4		68		pla		                pla
324	.c0f5		29 01		and #$01	                and #STATE.isPrinterEnabled
325	.c0f7		14 d0		trb $d0		                trb STATE

327							;-------------------------------------------------------------------------
328							;
329							; Stop cursor editing, if it's on.
330							;
331							; exit:
332							;
333							; V=1 if cursor editing previous on
334							; N=1 if VDU 21 on
335							;
336	.c0f9						stopCursorEditing:
337	.c0f9		24 d0		bit $d0		                bit STATE
338	.c0fb		50 e3		bvc $c0e0	                bvc rtsC0E1                    ;taken if not cursor editing
339	.c0fd		20 d0 c0	jsr $c0d0	                jsr exchangeCursors
340	.c100		08		php		                php
341	.c101						deactivateEditCursor:
342	.c101		38		sec		                sec
343	.c102		80 02		bra $c106	                bra updateEditCursorState

345							;-------------------------------------------------------------------------

347	.c104						activateEditCursor:
348	.c104		08		php		                php
349	.c105		18		clc		                clc

351							;-------------------------------------------------------------------------
352							;
353							; Handle cursor editing on/off.
354							;
355							; entry:
356							;
357							; C=0 - cursor editing on; add fake cursor
358							;
359							; C=1 = cursor editing off; remove fake cursor and restore screen
360							;
361	.c106						updateEditCursorState: .proc
362	.c106		48		pha		                pha
363	.c107		a5 d8		lda $d8		                lda ZMEMT+0
364	.c109		85 e0		sta $e0		                sta ZTEMPD+0
365	.c10b		a5 d9		lda $d9		                lda ZMEMT+1
366	.c10d		85 e1		sta $e1		                sta ZTEMPD+1
367	.c10f		ac 4f 03	ldy $034f	                ldy vduv.bytesPerCharacter
368	.c112		88		dey		                dey
369	.c113		d0 0e		bne $c123	                bne bitmap

371	.c115						teletext:
372	.c115		ad 38 03	lda $0338	                lda vduv.workspace._38 ;get old byte under fake cursor (may be bogus)
373	.c118		b0 17		bcs $c131	                bcs storeToScreen      ;taken if switching off
374	.c11a		b2 d8		lda ($d8)	                lda (ZMEMT)            ;get screen byte
375	.c11c		8d 38 03	sta $0338	                sta vduv.workspace._38 ;store old byte
376	.c11f		a9 7f		lda #$7f	                lda #$7F               ;store solid block to screen
377	.c121		80 0e		bra $c131	                bra storeToScreen

379	.c123						bitmap:
380	.c123		a9 ff		lda #$ff	                lda #%11111111          ;invert all bits
381	.c125		c0 1f		cpy #$1f	                cpy #$1F      ;check for 32 chars/byte - i.e., MODE 2
382	.c127		d0 02		bne $c12b	                bne +         ;taken if not MODE 2
383	.c129		a9 3f		lda #$3f	                lda #%00111111       ;avoid flashing colours in MODE 2
384	.c12b						+
385	.c12b		85 da		sta $da		                sta ZTEMP
386	.c12d						loop:
387	.c12d		b2 e0		lda ($e0)	                lda (ZTEMPD)
388	.c12f		45 da		eor $da		                eor ZTEMP
389	.c131						storeToScreen:
390	.c131		92 e0		sta ($e0)	                sta (ZTEMPD)
391	.c133		e6 e0		inc $e0		                inc ZTEMPD+0
392	.c135		d0 09		bne $c140	                bne +                    ;taken if no carry out of LSB
393	.c137		e6 e1		inc $e1		                inc ZTEMPD+1
394	.c139		10 05		bpl $c140	                bpl +                 ;taken if no screen address wrap
395	.c13b		ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
396	.c13e		85 e1		sta $e1		                sta ZTEMPD+1
397	.c140						+
398	.c140		88		dey		                dey               ;Y=$ff after 1 iteration in teletext
399	.c141		10 ea		bpl $c12d	                bpl loop
400	.c143		68		pla		                pla
401	.c144		28		plp		                plp
402	.c145		60		rts		                rts
403							                .endproc

405							;-------------------------------------------------------------------------

407	.c146						LC147:
408	>c146		bd c1				                .word LC1BE
409	>c148		b0 c1				                .word LC1B1
410	>c14a		bd c1				                .word LC1BE
411	>c14c		b0 c1				                .word LC1B1
412	>c14e		94 c1				                .word LC195
413	>c150		94 c1				                .word LC195
414	>c152		a1 c1				                .word LC1A2
415	>c154		a1 c1				                .word LC1A2

417							;-------------------------------------------------------------------------

419	.c156						LC157:
420	>c156		00 c2				                .word LC201
421	>c158		ed c1				                .word LC1EE
422	>c15a		00 c2				                .word LC201
423	>c15c		ed c1				                .word LC1EE
424	>c15e		20 c2				                .word LC221
425	>c160		20 c2				                .word LC221
426	>c162		0f c2				                .word LC210
427	>c164		0f c2				                .word LC210

429							;-------------------------------------------------------------------------
430							;
431							; Indexed by the swapAxes, invertVertical and invertHorizontal cursor
432							; flags bits.
433							;
434	.c166						setTextCursorXPositionRoutinesTable:
435	>c166		d2 c2				                .word setTextCursorXPosition           ;0
436	>c168		ca c2				                .word setTextCursorXPositionInvertHorizontal ;invertHorizontal
437	>c16a		d2 c2				                .word setTextCursorXPosition ;invertVertical
438	>c16c		ca c2				                .word setTextCursorXPositionInvertHorizontal ;invertVertical|invertHorizontal
439	>c16e		e1 c2				                .word setTextCursorXPositionSwapAxes         ;swapAxes
440	>c170		e1 c2				                .word setTextCursorXPositionSwapAxes ;swapAxes|invertHorizontal
441	>c172		d9 c2				                .word setTextCursorXPositionSwapAxesInvertVertical ;swapAxes|invertVertical
442	>c174		d9 c2				                .word setTextCursorXPositionSwapAxesInvertVertical ;swapAxes|invertVertical|invertHorizontal

444							;-------------------------------------------------------------------------

446	.c176						LC177:
447	>c176		0f c3				                .word LC310
448	>c178		f1 c2				                .word LC2F2
449	>c17a		0f c3				                .word LC310
450	>c17c		f1 c2				                .word LC2F2
451	>c17e		59 c3				                .word LC35A
452	>c180		59 c3				                .word LC35A
453	>c182		37 c3				                .word LC338
454	>c184		37 c3				                .word LC338

456							;-------------------------------------------------------------------------

458	.c186						LC187:
459	.c186		4d 66 03	eor $0366	                eor $0366
460	.c189		29 0e		and #$0e	                and #$0E
461	.c18b		48		pha		                pha
462	.c18c		20 a5 d1	jsr $d1a5	                jsr LD1A6
463	.c18f		fa		plx		                plx
464	.c190		38		sec		                sec
465	.c191		7c 46 c1	jmp ($c146,x)	                jmp (LC147,x)

467	.c194						LC195:
468	.c194		ad 26 03	lda $0326	                lda $0326
469	.c197		e9 08		sbc #$08	                sbc #$08
470	.c199		8d 26 03	sta $0326	                sta $0326
471	.c19c		ce 27 03	dec $0327	                dec $0327
472	.c19f		80 08		bra $c1a9	                bra LC1AA

474	.c1a1						LC1A2:
475	.c1a1		ad 26 03	lda $0326	                lda $0326
476	.c1a4		69 07		adc #$07	                adc #$07
477	.c1a6		8d 26 03	sta $0326	                sta $0326
478	.c1a9						LC1AA:
479	.c1a9		90 1f		bcc $c1ca	                bcc LC1CB
480	.c1ab		ee 27 03	inc $0327	                inc $0327
481	.c1ae		80 1a		bra $c1ca	                bra LC1CB

483	.c1b0						LC1B1:
484	.c1b0		ad 24 03	lda $0324	                lda $0324
485	.c1b3		e9 08		sbc #$08	                sbc #$08
486	.c1b5		8d 24 03	sta $0324	                sta $0324
487	.c1b8		ce 25 03	dec $0325	                dec $0325
488	.c1bb		80 08		bra $c1c5	                bra LC1C6

490	.c1bd						LC1BE:
491	.c1bd		ad 24 03	lda $0324	                lda $0324
492	.c1c0		69 07		adc #$07	                adc #$07
493	.c1c2		8d 24 03	sta $0324	                sta $0324
494	.c1c5						LC1C6:
495	.c1c5		90 03		bcc $c1ca	                bcc LC1CB
496	.c1c7		ee 25 03	inc $0325	                inc $0325
497	.c1ca						LC1CB:
498	.c1ca		a5 da		lda $da		                lda $DA
499	.c1cc		d0 0c		bne $c1da	                bne LC1DB
500	.c1ce		2c 66 03	bit $0366	                bit $0366
501	.c1d1		70 07		bvs $c1da	                bvs LC1DB
502	.c1d3		da		phx		                phx
503	.c1d4		20 a5 d1	jsr $d1a5	                jsr LD1A6
504	.c1d7		fa		plx		                plx
505	.c1d8		a8		tay		                tay
506	.c1d9		60		rts		                rts

508	.c1da						LC1DB:
509	.c1da		a9 00		lda #$00	                lda #$00
510	.c1dc		60		rts		                rts

512	.c1dd						LC1DE:
513	.c1dd		a9 00		lda #$00	                lda #$00
514	.c1df						LC1E0:
515	.c1df		64 da		stz $da		                stz $DA
516	.c1e1		0a		asl a		                asl a
517	.c1e2		26 da		rol $da		                rol $DA
518	.c1e4		0a		asl a		                asl a
519	.c1e5		26 da		rol $da		                rol $DA
520	.c1e7		0a		asl a		                asl a
521	.c1e8		26 da		rol $da		                rol $DA
522	.c1ea		7c 56 c1	jmp ($c156,x)	                jmp (LC157,x)

524	.c1ed						LC1EE:
525	.c1ed		49 f9		eor #$f9	                eor #$F9
526	.c1ef		6d 04 03	adc $0304	                adc $0304
527	.c1f2		8d 24 03	sta $0324	                sta $0324
528	.c1f5		a5 da		lda $da		                lda $DA
529	.c1f7		49 ff		eor #$ff	                eor #$FF
530	.c1f9		6d 05 03	adc $0305	                adc $0305
531	.c1fc		8d 25 03	sta $0325	                sta $0325
532	.c1ff		60		rts		                rts

534	.c200						LC201:
535	.c200		6d 00 03	adc $0300	                adc $0300
536	.c203		8d 24 03	sta $0324	                sta $0324
537	.c206		a5 da		lda $da		                lda $DA
538	.c208		6d 01 03	adc $0301	                adc $0301
539	.c20b		8d 25 03	sta $0325	                sta $0325
540	.c20e		60		rts		                rts

542	.c20f						LC210:
543	.c20f		49 07		eor #$07	                eor #$07
544	.c211		6d 02 03	adc $0302	                adc $0302
545	.c214		8d 26 03	sta $0326	                sta $0326
546	.c217		a5 da		lda $da		                lda $DA
547	.c219		6d 03 03	adc $0303	                adc $0303
548	.c21c		8d 27 03	sta $0327	                sta $0327
549	.c21f		60		rts		                rts

551	.c220						LC221:
552	.c220		38		sec		                sec
553	.c221		49 ff		eor #$ff	                eor #$FF
554	.c223		6d 06 03	adc $0306	                adc $0306
555	.c226		8d 26 03	sta $0326	                sta $0326
556	.c229		a5 da		lda $da		                lda $DA
557	.c22b		49 ff		eor #$ff	                eor #$FF
558	.c22d		6d 07 03	adc $0307	                adc $0307
559	.c230		8d 27 03	sta $0327	                sta $0327
560	.c233		60		rts		                rts

562	.c234						LC235:
563	.c234		a9 00		lda #$00	                lda #$00
564	.c236		20 86 c1	jsr $c186	                jsr LC187
565	.c239		f0 0d		beq $c248	                beq LC249
566	.c23b		20 dd c1	jsr $c1dd	                jsr LC1DE
567	.c23e						LC23F:
568	.c23e		a9 08		lda #$08	                lda #$08
569	.c240						LC241:
570	.c240		20 86 c1	jsr $c186	                jsr LC187
571	.c243		f0 03		beq $c248	                beq LC249
572	.c245		20 dd c1	jsr $c1dd	                jsr LC1DE
573	.c248						LC249:
574	.c248		4c de c4	jmp $c4de	                jmp LC4DF

576	.c24b						vdu9EntryPoint:
577	.c24b		20 2c d1	jsr $d12c	                jsr handleColumn81
578	.c24e		b0 e4		bcs $c234	                bcs LC235
579	.c250		a9 00		lda #$00	                lda #$00
580	.c252		20 e8 c2	jsr $c2e8	                jsr LC2E9
581	.c255		90 1b		bcc $c272	                bcc LC273
582	.c257						LC258:
583	.c257		20 8e c3	jsr $c38e	                jsr LC38F
584	.c25a						vdu10EntryPoint:
585	.c25a		20 d0 e2	jsr $e2d0	                jsr testVDU5State
586	.c25d		d0 df		bne $c23e	                bne LC23F
587	.c25f		18		clc		                clc
588	.c260		20 90 c8	jsr $c890	                jsr LC88E
589	.c263		a9 08		lda #$08	                lda #$08
590	.c265		20 e8 c2	jsr $c2e8	                jsr LC2E9
591	.c268						LC269:
592	.c268		90 08		bcc $c272	                bcc LC273
593	.c26a		20 7a c3	jsr $c37a	                jsr LC37B
594	.c26d		90 03		bcc $c272	                bcc LC273
595	.c26f		4c 50 d0	jmp $d050	                jmp LD051

597	.c272						LC273:
598	.c272		4c ec c6	jmp $c6ec	                jmp updateCRTCCursorAddress

600	.c275						LC276:
601	.c275		20 d0 e2	jsr $e2d0	                jsr testVDU5State
602	.c278		d0 ba		bne $c234	                bne LC235
603	.c27a		20 e8 c2	jsr $c2e8	                jsr LC2E9
604	.c27d		90 f3		bcc $c272	                bcc LC273
605	.c27f		a9 01		lda #$01	                lda #$01
606	.c281		2c 66 03	bit $0366	                bit $0366
607	.c284		f0 d1		beq $c257	                beq LC258
608	.c286		38		sec		                sec
609	.c287		6e 6c 03	ror $036c	                ror $036C
610	.c28a						LC28B:
611	.c28a		60		rts		                rts

613	.c28b						LC28C:
614	.c28b		a9 06		lda #$06	                lda #$06
615	.c28d		20 86 c1	jsr $c186	                jsr LC187
616	.c290		f0 b6		beq $c248	                beq LC249
617	.c292		20 dd c1	jsr $c1dd	                jsr LC1DE
618	.c295						LC296:
619	.c295		a9 0e		lda #$0e	                lda #$0E
620	.c297		80 a7		bra $c240	                bra LC241

622	.c299						vdu8EntryPoint:
623	.c299		20 d0 e2	jsr $e2d0	                jsr testVDU5State
624	.c29c		d0 ed		bne $c28b	                bne LC28C
625	.c29e		4e 6c 03	lsr $036c	                lsr $036C
626	.c2a1		2c 6c 03	bit $036c	                bit $036C
627	.c2a4		70 e4		bvs $c28a	                bvs LC28B
628	.c2a6		a9 06		lda #$06	                lda #$06
629	.c2a8		20 e8 c2	jsr $c2e8	                jsr LC2E9
630	.c2ab		90 c5		bcc $c272	                bcc LC273
631	.c2ad		20 8e c3	jsr $c38e	                jsr LC38F
632	.c2b0						vdu11EntryPoint:
633	.c2b0		20 d0 e2	jsr $e2d0	                jsr testVDU5State
634	.c2b3		d0 e0		bne $c295	                bne LC296
635	.c2b5		ce 69 02	dec $0269	                dec pagedModeCounter
636	.c2b8		10 03		bpl $c2bd	                bpl LC2BE
637	.c2ba		ee 69 02	inc $0269	                inc pagedModeCounter
638	.c2bd						LC2BE:
639	.c2bd		a9 0e		lda #$0e	                lda #$0E
640	.c2bf		20 e8 c2	jsr $c2e8	                jsr LC2E9
641	.c2c2		80 a4		bra $c268	                bra LC269

643							;-------------------------------------------------------------------------
644							;
645							; Set/reset cursor position, taking cursor flags into account.
646							;
647							; entry:
648							;
649							; (set only) A = cursor position
650							;
651							; X = cursorFlags bits: swapAxes, invertVertical, invertHorizontal
652							;
653	.c2c4						resetTextCursorXPositionWithCursorFlags:
654	.c2c4		a9 00		lda #$00	                lda #$00
655	.c2c6						setTextCursorXPositionWithCursorFlags:
656	.c2c6		18		clc		                clc
657	.c2c7		7c 66 c1	jmp ($c166,x)	                jmp (setTextCursorXPositionRoutinesTable,x)

659							;-------------------------------------------------------------------------

661	.c2ca						setTextCursorXPositionInvertHorizontal:
662	.c2ca		38		sec		                sec                          ;+1
663	.c2cb		49 ff		eor #$ff	                eor #$FF          ;^$ff+1 (i.e., adc will add the -ve)
664	.c2cd		6d 0a 03	adc $030a	                adc vduv.textWindowRight
665	.c2d0		80 03		bra $c2d5	                bra staTextCursorXPosition

667							;-------------------------------------------------------------------------

669	.c2d2						setTextCursorXPosition:
670	.c2d2		6d 08 03	adc $0308	                adc vduv.textWindowLeft
671	.c2d5						staTextCursorXPosition:
672	.c2d5		8d 18 03	sta $0318	                sta vduv.textCursorXPosition
673	.c2d8		60		rts		                rts

675							;-------------------------------------------------------------------------

677	.c2d9						setTextCursorXPositionSwapAxesInvertVertical:
678	.c2d9		38		sec		                sec
679	.c2da		49 ff		eor #$ff	                eor #$FF
680	.c2dc		6d 09 03	adc $0309	                adc vduv.textWindowBottom
681	.c2df		80 03		bra $c2e4	                bra staTextCursorYPosition

683	.c2e1						setTextCursorXPositionSwapAxes:
684	.c2e1		6d 0b 03	adc $030b	                adc vduv.textWindowTop
685	.c2e4						staTextCursorYPosition:
686	.c2e4		8d 19 03	sta $0319	                sta vduv.textCursorYPosition
687	.c2e7		60		rts		                rts

689							;-------------------------------------------------------------------------

691	.c2e8						LC2E9:
692	.c2e8		4d 66 03	eor $0366	                eor $0366
693	.c2eb		29 0e		and #$0e	                and #$0E
694	.c2ed		aa		tax		                tax
695	.c2ee						LC2EF:
696	.c2ee		7c 76 c1	jmp ($c176,x)	                jmp (LC177,x)

698	.c2f1						LC2F2:
699	.c2f1		ad 08 03	lda $0308	                lda $0308
700	.c2f4		cd 18 03	cmp $0318	                cmp $0318
701	.c2f7		b0 3d		bcs $c336	                bcs LC337
702	.c2f9		ce 18 03	dec $0318	                dec $0318
703	.c2fc		38		sec		                sec
704	.c2fd		ad 4a 03	lda $034a	                lda $034A
705	.c300		ed 4f 03	sbc $034f	                sbc $034F
706	.c303		8d 4a 03	sta $034a	                sta $034A
707	.c306		85 d8		sta $d8		                sta ZMEMT+0
708	.c308		b0 2b		bcs $c335	                bcs LC336
709	.c30a		ce 4b 03	dec $034b	                dec $034B
710	.c30d		80 1b		bra $c32a	                bra LC32B

712	.c30f						LC310:
713	.c30f		ad 18 03	lda $0318	                lda $0318
714	.c312		cd 0a 03	cmp $030a	                cmp $030A
715	.c315		b0 1f		bcs $c336	                bcs LC337
716	.c317		ee 18 03	inc $0318	                inc $0318
717	.c31a		ad 4a 03	lda $034a	                lda $034A
718	.c31d		6d 4f 03	adc $034f	                adc $034F
719	.c320		8d 4a 03	sta $034a	                sta $034A
720	.c323		85 d8		sta $d8		                sta ZMEMT+0
721	.c325		90 0f		bcc $c336	                bcc LC337
722	.c327		ee 4b 03	inc $034b	                inc $034B
723	.c32a						LC32B:
724	.c32a		ad 4b 03	lda $034b	                lda $034B
725	.c32d						LC32E:
726	.c32d		10 04		bpl $c333	                bpl LC334
727	.c32f		38		sec		                sec
728	.c330		ed 54 03	sbc $0354	                sbc $0354
729	.c333						LC334:
730	.c333		85 d9		sta $d9		                sta ZMEMT+1
731	.c335						LC336:
732	.c335		18		clc		                clc
733	.c336						LC337:
734	.c336		60		rts		                rts

736	.c337						LC338:
737	.c337		ad 0b 03	lda $030b	                lda $030B
738	.c33a		cd 19 03	cmp $0319	                cmp $0319
739	.c33d		b0 f7		bcs $c336	                bcs LC337
740	.c33f		ce 19 03	dec $0319	                dec $0319
741	.c342		38		sec		                sec
742	.c343		ad 4a 03	lda $034a	                lda $034A
743	.c346		ed 52 03	sbc $0352	                sbc $0352
744	.c349		8d 4a 03	sta $034a	                sta $034A
745	.c34c		85 d8		sta $d8		                sta ZMEMT+0
746	.c34e		ad 4b 03	lda $034b	                lda $034B
747	.c351		ed 53 03	sbc $0353	                sbc $0353
748	.c354		8d 4b 03	sta $034b	                sta $034B
749	.c357		80 d4		bra $c32d	                bra LC32E

751	.c359						LC35A:
752	.c359		ad 19 03	lda $0319	                lda $0319
753	.c35c		cd 09 03	cmp $0309	                cmp $0309
754	.c35f		b0 d5		bcs $c336	                bcs LC337
755	.c361		ee 19 03	inc $0319	                inc $0319
756	.c364		ad 4a 03	lda $034a	                lda $034A
757	.c367		6d 52 03	adc $0352	                adc $0352
758	.c36a		8d 4a 03	sta $034a	                sta $034A
759	.c36d		85 d8		sta $d8		                sta ZMEMT+0
760	.c36f		ad 4b 03	lda $034b	                lda $034B
761	.c372		6d 53 03	adc $0353	                adc $0353
762	.c375		8d 4b 03	sta $034b	                sta $034B
763	.c378		80 b3		bra $c32d	                bra LC32E

765	.c37a						LC37B:
766	.c37a		a9 10		lda #$10	                lda #$10
767	.c37c		2c 66 03	bit $0366	                bit $0366
768	.c37f		d0 0d		bne $c38e	                bne LC38F
769	.c381		8a		txa		                txa
770	.c382		49 06		eor #$06	                eor #$06
771	.c384		48		pha		                pha
772	.c385		a9 42		lda #$42	                lda #$42
773	.c387		24 d0		bit $d0		                bit STATE
774	.c389		f0 16		beq $c3a1	                beq LC3A2
775	.c38b		70 09		bvs $c396	                bvs LC397
776	.c38d		68		pla		                pla
777	.c38e						LC38F:
778	.c38e		20 c4 c2	jsr $c2c4	                jsr resetTextCursorXPositionWithCursorFlags
779	.c391		20 fa cc	jsr $ccfa	                jsr updateZMEMTWithTextCursorPosition
780	.c394		18		clc		                clc
781	.c395		60		rts		                rts

783	.c396						LC397:
784	.c396		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
785	.c399		fa		plx		                plx
786	.c39a		da		phx		                phx
787	.c39b		20 ee c2	jsr $c2ee	                jsr LC2EF
788	.c39e		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
789	.c3a1						LC3A2:
790	.c3a1		fa		plx		                plx
791	.c3a2		38		sec		                sec
792	.c3a3						LC3A4:
793	.c3a3		60		rts		                rts

795	.c3a4						vdu28EntryPoint:
796	.c3a4		ae 55 03	ldx $0355	                ldx $0355
797	.c3a7		ad 21 03	lda $0321	                lda $0321
798	.c3aa		cd 23 03	cmp $0323	                cmp $0323
799	.c3ad		90 f4		bcc $c3a3	                bcc LC3A4
800	.c3af		dd ff e0	cmp $e0ff,x	                cmp modeMaxRow,x
801	.c3b2		f0 02		beq $c3b6	                beq LC3B7
802	.c3b4		b0 ed		bcs $c3a3	                bcs LC3A4
803	.c3b6						LC3B7:
804	.c3b6		ad 22 03	lda $0322	                lda $0322
805	.c3b9		dd 07 e1	cmp $e107,x	                cmp modeMaxColumn,x
806	.c3bc		f0 03		beq $c3c1	                beq LC3C2
807	.c3be		b0 e3		bcs $c3a3	                bcs LC3A4
808	.c3c0		38		sec		                sec
809	.c3c1						LC3C2:
810	.c3c1		ed 20 03	sbc $0320	                sbc $0320
811	.c3c4		90 dd		bcc $c3a3	                bcc LC3A4
812	.c3c6		20 7f c7	jsr $c77f	                jsr setTextWindowWidthInBytes
813	.c3c9		a9 08		lda #$08	                lda #$08
814	.c3cb		04 d0		tsb $d0		                tsb STATE
815	.c3cd		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
816	.c3cf		a0 08		ldy #$08	                ldy #VDUVariables.textWindowLeft
817	.c3d1		20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
818	.c3d4		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
819	.c3d7		20 da cc	jsr $ccda	                jsr LCCDA
820	.c3da		90 03		bcc $c3df	                bcc LC3E0
821	.c3dc		20 e7 c3	jsr $c3e7	                jsr LC3E8
822	.c3df						LC3E0:
823	.c3df		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
824	.c3e2		20 da cc	jsr $ccda	                jsr LCCDA
825	.c3e5		90 1f		bcc $c406	                bcc LC407
826	.c3e7						LC3E8:
827	.c3e7		a5 d0		lda $d0		                lda STATE
828	.c3e9		48		pha		                pha
829	.c3ea		29 df		and #$df	                and #$DF
830	.c3ec		85 d0		sta $d0		                sta STATE
831	.c3ee		20 7b c4	jsr $c47b	                jsr vdu30EntryPoint
832	.c3f1		68		pla		                pla
833	.c3f2		85 d0		sta $d0		                sta STATE
834	.c3f4		60		rts		                rts

836	.c3f5						vdu13EntryPoint:
837	.c3f5		ad 66 03	lda $0366	                lda $0366
838	.c3f8		29 0e		and #$0e	                and #$0E
839	.c3fa		aa		tax		                tax
840	.c3fb		20 d0 e2	jsr $e2d0	                jsr testVDU5State
841	.c3fe		d0 09		bne $c409	                bne LC40A
842	.c400		4e 6c 03	lsr $036c	                lsr $036C
843	.c403		20 8e c3	jsr $c38e	                jsr LC38F
844	.c406						LC407:
845	.c406		4c ec c6	jmp $c6ec	                jmp updateCRTCCursorAddress

847	.c409						LC40A:
848	.c409		20 dd c1	jsr $c1dd	                jsr LC1DE
849	.c40c		4c de c4	jmp $c4de	                jmp LC4DF

851	.c40f						LC410:
852	.c40f		20 7b c4	jsr $c47b	                jsr vdu30EntryPoint

854							;-------------------------------------------------------------------------
855							;
856							; VDU 16 (&10) Clear graphics window [MasRef E.3-7]
857							;
858	.c412						vdu16EntryPoint:
859	.c412		ad 61 03	lda $0361	                lda vduv.pixelsPerByteMinusOne
860	.c415		f0 8c		beq $c3a3	                beq LC3A4                    ;taken if MODE 7
861	.c417		a2 00		ldx #$00	                ldx #VDUVariables.graphicsWindowPixelsLeft
862	.c419		20 02 c9	jsr $c902	                jsr copyEightBytesToWorkspace28
863	.c41c		20 51 c9	jsr $c951	                jsr prepareForPlotBackground
864	.c41f						LC420:
865	.c41f		a2 2a		ldx #$2a	                ldx #$2A
866	.c421		a0 2e		ldy #$2e	                ldy #$2E
867	.c423		20 b0 e2	jsr $e2b0	                jsr exchangeTwoVDUBytes
868	.c426						LC427:
869	.c426		a2 28		ldx #$28	                ldx #$28
870	.c428		a0 2c		ldy #$2c	                ldy #$2C
871	.c42a		20 e7 da	jsr $dae7	                jsr LDAE8
872	.c42d		ad 2a 03	lda $032a	                lda $032A
873	.c430		d0 03		bne $c435	                bne LC436
874	.c432		ce 2b 03	dec $032b	                dec $032B
875	.c435						LC436:
876	.c435		ce 2a 03	dec $032a	                dec $032A
877	.c438		ad 2a 03	lda $032a	                lda $032A
878	.c43b		cd 2e 03	cmp $032e	                cmp $032E
879	.c43e		ad 2b 03	lda $032b	                lda $032B
880	.c441		ed 2f 03	sbc $032f	                sbc $032F
881	.c444		10 e0		bpl $c426	                bpl LC427
882	.c446		60		rts		                rts

884	.c447						LC448:
885	.c447		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
886	.c449		20 e6 c8	jsr $c8e6	                jsr prepareAABB
887	.c44c		80 d1		bra $c41f	                bra LC420

889							;-------------------------------------------------------------------------
890							;
891							; VDU 12 (&0C) Clear text window [MasRef E.3-5]
892							;
893	.c44e						vdu12EntryPoint:
894	.c44e		a9 20		lda #$20	                lda #STATE.isVDU5
895	.c450		24 d0		bit $d0		                bit STATE
896	.c452		d0 bb		bne $c40f	                bne LC410                    ;taken if VDU 5 mode
897	.c454		a9 08		lda #$08	                lda #STATE.isTextWindow
898	.c456		24 d0		bit $d0		                bit STATE
899	.c458		d0 03		bne $c45d	                bne clearTextWindow                    ;taken if text window
900	.c45a		4c 68 c8	jmp $c868	                jmp clsFastPath

902							                ; Clear screen within text window
903							                ; -------------------------------
904	.c45d						clearTextWindow:
905	.c45d		20 08 c9	jsr $c908	                jsr copyTextWindowWidthInBytesToWorkspace28
906	.c460		ae 08 03	ldx $0308	                ldx vduv.textWindowLeft
907	.c463		8e 18 03	stx $0318	                stx vduv.textCursorXPosition
908	.c466		ae 0b 03	ldx $030b	                ldx vduv.textWindowTop
909	.c469						clearTextWindowRowsLoop:
910	.c469		8e 19 03	stx $0319	                stx vduv.textCursorYPosition
911	.c46c		20 fa cc	jsr $ccfa	                jsr updateZMEMTWithTextCursorPosition
912	.c46f		20 e8 ca	jsr $cae8	                jsr LCAE8
913	.c472		ae 19 03	ldx $0319	                ldx vduv.textCursorYPosition
914	.c475		ec 09 03	cpx $0309	                cpx vduv.textWindowBottom
915	.c478		e8		inx		                inx
916	.c479		90 ee		bcc $c469	                bcc clearTextWindowRowsLoop

918							;-------------------------------------------------------------------------
919							;
920							; VDU 30 (&1E) Home cursor [MasRef E.3-36]
921							;
922	.c47b						vdu30EntryPoint:
923							                ; pretend it's VDU 31,0,0
924	.c47b		9c 23 03	stz $0323	                stz vduv.queueEnd-1
925	.c47e		9c 22 03	stz $0322	                stz vduv.queueEnd-2

927							;-------------------------------------------------------------------------
928							;
929							; VDU 31 (&1F) Tab cursor [MasRef E.3-36]
930							;
931	.c481						vdu31EntryPoint:
932	.c481		ad 66 03	lda $0366	                lda vduv.cursorFlags
933	.c484		29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
934	.c486		aa		tax		                tax
935	.c487						LC488:
936	.c487		20 d0 e2	jsr $e2d0	                jsr testVDU5State
937	.c48a		d0 42		bne $c4ce	                bne LC4CF                    ;taken if VDU 5
938	.c48c		ad 18 03	lda $0318	                lda vduv.textCursorXPosition
939	.c48f		48		pha		                pha                          ;save old X pos
940	.c490		ad 19 03	lda $0319	                lda vduv.textCursorYPosition
941	.c493		48		pha		                pha                          ;save old Y pos
942	.c494		ad 22 03	lda $0322	                lda vduv.queueEnd-2          ;X coordinate
943	.c497		20 c6 c2	jsr $c2c6	                jsr setTextCursorXPositionWithCursorFlags
944	.c49a		da		phx		                phx                          ;save true cursorFlags bits
945	.c49b		8a		txa		                txa
946	.c49c		49 08		eor #$08	                eor #vduv.cursorFlags.swapAxes ;cheekily do the other axis by just changing the cursor flags
947	.c49e		aa		tax		                tax
948	.c49f		ad 23 03	lda $0323	                lda vduv.queueEnd-1          ;Y coordinate
949	.c4a2		20 d7 cc	jsr $ccd7	                jsr LCCD7
950	.c4a5		fa		plx		                plx                    ;restore true cursorFlags bits
951	.c4a6		90 11		bcc $c4b9	                bcc LC4BA              ;taken if no scrolling required
952	.c4a8		a9 01		lda #$01	                lda #vduv.cursorFlags.scrollProtect
953	.c4aa		2c 66 03	bit $0366	                bit $0366
954	.c4ad		f0 11		beq $c4c0	                beq LC4C1                 ;taken if scroll protect off

956							                ; Wrap text cursor X.
957	.c4af		ad 22 03	lda $0322	                lda vduv.queueEnd-2       ;X coordinate
958	.c4b2		3a		dec a		                dec a
959	.c4b3		20 d7 cc	jsr $ccd7	                jsr LCCD7
960	.c4b6		b0 08		bcs $c4c0	                bcs LC4C1
961	.c4b8		38		sec		                sec
962	.c4b9						LC4BA:
963	.c4b9		6e 6c 03	ror $036c	                ror vduv.column81
964	.c4bc		68		pla		                pla                          ;discard old Y pos
965	.c4bd		68		pla		                pla                          ;discard old X pos
966	.c4be		80 0b		bra $c4cb	                bra LC4CC

968	.c4c0						LC4C1:
969	.c4c0		68		pla		                pla
970	.c4c1		8d 19 03	sta $0319	                sta vduv.textCursorYPosition ;restore old Y pos
971	.c4c4		68		pla		                pla
972	.c4c5		8d 18 03	sta $0318	                sta vduv.textCursorXPosition ;restore old X pos
973	.c4c8		20 fa cc	jsr $ccfa	                jsr updateZMEMTWithTextCursorPosition
974	.c4cb						LC4CC:
975	.c4cb		4c ec c6	jmp $c6ec	                jmp updateCRTCCursorAddress

977	.c4ce						LC4CF:
978	.c4ce		ad 22 03	lda $0322	                lda $0322
979	.c4d1		20 df c1	jsr $c1df	                jsr LC1E0
980	.c4d4		8a		txa		                txa
981	.c4d5		49 08		eor #$08	                eor #$08
982	.c4d7		aa		tax		                tax
983	.c4d8		ad 23 03	lda $0323	                lda $0323
984	.c4db		20 df c1	jsr $c1df	                jsr LC1E0
985	.c4de						LC4DF:
986	.c4de		a0 10		ldy #$10	                ldy #$10
987	.c4e0		20 1c c9	jsr $c91c	                jsr copyGraphicsCursorPixels
988	.c4e3		a2 02		ldx #$02	                ldx #$02
989	.c4e5		a0 02		ldy #$02	                ldy #$02
990	.c4e7		20 fb c4	jsr $c4fb	                jsr LC4FC
991	.c4ea		a2 00		ldx #$00	                ldx #$00
992	.c4ec		a0 04		ldy #$04	                ldy #$04
993	.c4ee		ad 61 03	lda $0361	                lda $0361
994	.c4f1						LC4F2:
995	.c4f1		88		dey		                dey
996	.c4f2		4a		lsr a		                lsr a
997	.c4f3		d0 fc		bne $c4f1	                bne LC4F2
998	.c4f5		ad 56 03	lda $0356	                lda $0356
999	.c4f8		f0 01		beq $c4fb	                beq LC4FC
1000	.c4fa		c8		iny		                iny
1001	.c4fb						LC4FC:
1002	.c4fb		1e 10 03	asl $0310,x	                asl $0310,x
1003	.c4fe		3e 11 03	rol $0311,x	                rol $0311,x
1004	.c501		88		dey		                dey
1005	.c502		d0 f7		bne $c4fb	                bne LC4FC
1006	.c504		38		sec		                sec
1007	.c505		20 09 c5	jsr $c509	                jsr LC50A
1008	.c508		e8		inx		                inx
1009	.c509						LC50A:
1010	.c509		bd 10 03	lda $0310,x	                lda $0310,x
1011	.c50c		fd 0c 03	sbc $030c,x	                sbc $030C,x
1012	.c50f		9d 10 03	sta $0310,x	                sta $0310,x
1013	.c512		60		rts		                rts

1015							;-------------------------------------------------------------------------
1016							;
1017							; VDU 14 (&0E) Page mode on [MasRef E.3-6]
1018							;
1019	.c513						vdu14EntryPoint:
1020	.c513		9c 69 02	stz $0269	                stz pagedModeCounter
1021	.c516		a9 91		lda #$91	                lda #$91

1023							;-------------------------------------------------------------------------
1024							;
1025							; VDU 21 (&15) Disable VDU driver [MasRef E.3-11]
1026							;
1027	.c518						vdu21EntryPoint:
1028	.c518		49 95		eor #$95	                eor #$95
1029	.c51a						LC51B:
1030	.c51a		04 d0		tsb $d0		                tsb STATE
1031	.c51c		60		rts		                rts

1033							;-------------------------------------------------------------------------
1034							;
1035							; VDU 4 (&04) Print at text cursor [MasRef E.3-2]
1036							;
1037	.c51d						vdu4EntryPoint:
1038	.c51d		ad 61 03	lda $0361	                lda $0361
1039	.c520		f0 09		beq $c52b	                beq LC52C
1040	.c522		20 4f cf	jsr $cf4f	                jsr showCursor
1041	.c525		a9 2b		lda #$2b	                lda #$2B

1043							                ; fall through to vdu15EntryPoint

1045							;-------------------------------------------------------------------------
1046							;
1047							; VDU 15 (&0F) Page mode off [MasRef E.3-6]
1048							;
1049	.c527						vdu15EntryPoint:
1050	.c527		49 0b		eor #$0b	                eor #$0B
1051	.c529		14 d0		trb $d0		                trb STATE
1052	.c52b						LC52C:
1053	.c52b		60		rts		                rts

1055							;-------------------------------------------------------------------------
1056							;
1057							; VDU 5 (&05) Print text at graphics cursor [MasRef E.3-3]
1058							;
1059	.c52c						vdu5EntryPoint:
1060	.c52c		ad 61 03	lda $0361	                lda $0361
1061	.c52f		f0 fa		beq $c52b	                beq LC52C
1062	.c531		a9 20		lda #$20	                lda #$20
1063	.c533		20 52 cf	jsr $cf52	                jsr setCRTCRegister10
1064	.c536		80 e2		bra $c51a	                bra LC51B

1066							;-------------------------------------------------------------------------
1067							;
1068							; VDU 17 (&11) Define text colour [MasRef E.3-7]
1069							;
1070	.c538						vdu17EntryPoint:
1071	.c538		a0 00		ldy #$00	                ldy #$00
1072	.c53a		ad 23 03	lda $0323	                lda $0323
1073	.c53d		10 01		bpl $c540	                bpl LC541
1074	.c53f		c8		iny		                iny
1075	.c540						LC541:
1076	.c540		2d 60 03	and $0360	                and $0360
1077	.c543		85 da		sta $da		                sta $DA
1078	.c545		ad 60 03	lda $0360	                lda $0360
1079	.c548		f0 18		beq $c562	                beq LC563
1080	.c54a		29 07		and #$07	                and #$07
1081	.c54c		18		clc		                clc
1082	.c54d		65 da		adc $da		                adc $DA
1083	.c54f		aa		tax		                tax
1084	.c550		bd 49 e1	lda $e149,x	                lda solidColoursTable-1,x
1085	.c553		99 57 03	sta $0357,y	                sta $0357,y
1086	.c556		ad 57 03	lda $0357	                lda $0357
1087	.c559		49 ff		eor #$ff	                eor #$FF
1088	.c55b		85 d3		sta $d3		                sta ZEOR
1089	.c55d		4d 58 03	eor $0358	                eor $0358
1090	.c560		85 d2		sta $d2		                sta ZORA
1091	.c562						LC563:
1092	.c562		60		rts		                rts

1094							;-------------------------------------------------------------------------
1095							;
1096							; VDU 18 (&12) Define graphics colour [MasRef E.3-7]
1097							;
1098	.c563						vdu18EntryPoint:
1099	.c563		a0 00		ldy #$00	                ldy #$00                    ;assume setting foreground
1100	.c565		ad 23 03	lda $0323	                lda vduv.queueEnd-1         ;get colour
1101	.c568		10 01		bpl $c56b	                bpl +                     ;taken if setting foreground
1102	.c56a		c8		iny		                iny                       ;setting background
1103	.c56b						+
1104	.c56b		2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne
1105	.c56e		99 6d 03	sta $036d,y	                sta vduv.foregroundGraphicsColour,y
1106	.c571		ad 22 03	lda $0322	                lda vduv.queueEnd-2          ;get GCOL mode
1107	.c574		99 5b 03	sta $035b,y	                sta vduv.foregroundGCOLMode,y
1108	.c577		29 f0		and #$f0	                and #$F0                     ;non-zero if ECF
1109	.c579		99 6a 03	sta $036a,y	                sta vduv.isForegroundECF,y
1110	.c57c						initializeCurrentECFPatterns:
1111	.c57c		ad 5b 03	lda $035b	                lda vduv.foregroundGCOLMode
1112	.c57f		ae 6d 03	ldx $036d	                ldx vduv.foregroundGraphicsColour
1113	.c582		a0 00		ldy #$00	                ldy #andy.fgECFPattern-andy.currentECFPatterns
1114	.c584		20 8f c5	jsr $c58f	                jsr initializeCurrentECFPattern
1115	.c587		ad 5c 03	lda $035c	                lda vduv.backgroundGCOLMode
1116	.c58a		ae 6e 03	ldx $036e	                ldx vduv.backgroundGraphicsColour
1117	.c58d		a0 08		ldy #$08	                ldy #andy.bgECFPattern-andy.currentECFPatterns
1118	.c58f						initializeCurrentECFPattern:
1119	.c58f		29 f0		and #$f0	                and #$F0                     ;GCOL mode ECF bits
1120	.c591		d0 18		bne $c5ab	                bne initializeECFPatternFromPattern

1122	.c593						initializeECFPatternFromColour:
1123	.c593		86 da		stx $da		                stx ZTEMP+0                  ;colour low bits
1124	.c595		ad 60 03	lda $0360	                lda vduv.numberOfLogicalColoursMinusOne
1125	.c598		29 07		and #$07	                and #$07
1126	.c59a		18		clc		                clc
1127	.c59b		65 da		adc $da		                adc ZTEMP+0
1128	.c59d		aa		tax		                tax
1129							                ; use solid colour as ECF "pattern".
1130	.c59e		bd 49 e1	lda $e149,x	                lda solidColoursTable-1,x
1131	.c5a1		a2 07		ldx #$07	                ldx #$07
1132	.c5a3						-
1133	.c5a3		99 20 88	sta $8820,y	                sta andy.fgECFPattern,y
1134	.c5a6		c8		iny		                iny
1135	.c5a7		ca		dex		                dex
1136	.c5a8		10 f9		bpl $c5a3	                bpl -
1137	.c5aa		60		rts		                rts

1139	.c5ab						initializeECFPatternFromPattern:
1140	.c5ab		4a		lsr a		                lsr a                        ;(index+1)*8
1141	.c5ac		aa		tax		                tax
1142	.c5ad		a9 07		lda #$07	                lda #$07
1143	.c5af		85 da		sta $da		                sta ZTEMP+0
1144	.c5b1						-
1145	.c5b1		bd f8 87	lda $87f8,x	                lda andy.ecfPatterns-8,x     ;-8 due to index+1 above
1146	.c5b4		99 20 88	sta $8820,y	                sta andy.fgECFPattern,y
1147	.c5b7		e8		inx		                inx
1148	.c5b8		c8		iny		                iny
1149	.c5b9		c6 da		dec $da		                dec ZTEMP+0
1150	.c5bb		10 f4		bpl $c5b1	                bpl -
1151	.c5bd		60		rts		                rts

1153							;-------------------------------------------------------------------------
1154							;
1155							; VDU 20 (&14) Restore default logical colours [MasRef E.3-10]
1156							;
1157	.c5be						setBackgroundTextColourForTeletext:
1158	.c5be		a9 20		lda #$20	                lda #' '
1159	.c5c0		8d 58 03	sta $0358	                sta vduv.backgroundTextColour
1160	.c5c3		60		rts		                rts

1162	.c5c4						vdu20EntryPoint:
1163	.c5c4		a2 05		ldx #$05	                ldx #$05
1164	.c5c6						-
1165	.c5c6		9e 57 03	stz $0357,x	                stz vduv.foregroundTextColour,x
1166	.c5c9		ca		dex		                dex
1167	.c5ca		10 fa		bpl $c5c6	                bpl -
1168	.c5cc		9c 6e 03	stz $036e	                stz vduv.backgroundGraphicsColour
1169	.c5cf		9c 6b 03	stz $036b	                stz vduv.isBackgroundECF
1170	.c5d2		a9 ff		lda #$ff	                lda #%11111111
1171	.c5d4		ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
1172	.c5d7		f0 e5		beq $c5be	                beq setBackgroundTextColourForTeletext
1173	.c5d9		e0 0f		cpx #$0f	                cpx #$0F
1174	.c5db		d0 02		bne $c5df	                bne +                        ;taken unless MODE 2
1175	.c5dd		a9 3f		lda #$3f	                lda #%00111111               ;MODE 2 default foreground colour is 7
1176	.c5df						+
1177	.c5df		8d 57 03	sta $0357	                sta vduv.foregroundTextColour
1178	.c5e2		49 ff		eor #$ff	                eor #$FF
1179	.c5e4		85 d2		sta $d2		                sta ZORA
1180	.c5e6		85 d3		sta $d3		                sta ZEOR
1181	.c5e8		8a		txa		                txa
1182	.c5e9		29 07		and #$07	                and #$07
1183	.c5eb		8d 6d 03	sta $036d	                sta vduv.foregroundGraphicsColour
1184	.c5ee		9c 6a 03	stz $036a	                stz vduv.isForegroundECF
1185	.c5f1		da		phx		                phx                          ;save numberOfLogicalColoursMinusOne
1186	.c5f2		20 7c c5	jsr $c57c	                jsr initializeCurrentECFPatterns
1187	.c5f5		fa		plx		                plx                          ;restore numberOfLogicalColoursMinusOne
1188	.c5f6		8e 1f 03	stx $031f	                stx vduv.queueEnd-5          ;Prepare VDU19,<max logical colour>
1189	.c5f9		e0 03		cpx #$03	                cpx #$03
1190	.c5fb		f0 11		beq $c60e	                beq reset4Colours            ;taken if MODE 1/5
1191	.c5fd		90 20		bcc $c61f	                bcc reset2Colours            ;taken if MODE 0/3/4/6
1192	.c5ff						reset16Colours:
1193	.c5ff		8e 20 03	stx $0320	                stx vduv.queueEnd-4          ;start with VDU19,15,15,_,_,_
1194	.c602						-
1195	.c602		20 2c c6	jsr $c62c	                jsr vdu19EntryPoint
1196	.c605		ce 20 03	dec $0320	                dec vduv.queueEnd-4
1197	.c608		ce 1f 03	dec $031f	                dec vduv.queueEnd-5
1198	.c60b		10 f5		bpl $c602	                bpl -
1199	.c60d		60		rts		                rts

1201	.c60e						reset4Colours:
1202	.c60e		a2 07		ldx #$07	                ldx #$07
1203	.c610		8e 20 03	stx $0320	                stx vduv.queueEnd-4          ;start with VDU19,3,7,_,_,_
1204	.c613						-
1205	.c613		20 2c c6	jsr $c62c	                jsr vdu19EntryPoint          ;2,3, then 1,1, then 0,0
1206	.c616		4e 20 03	lsr $0320	                lsr vduv.queueEnd-4
1207	.c619		ce 1f 03	dec $031f	                dec vduv.queueEnd-5
1208	.c61c		10 f5		bpl $c613	                bpl -
1209	.c61e		60		rts		                rts

1211	.c61f						reset2Colours:
1212	.c61f		a2 07		ldx #$07	                ldx #$07
1213	.c621		20 29 c6	jsr $c629	                jsr +                        ;VDU19,1,7,_,_,_
1214	.c624		a2 00		ldx #$00	                ldx #$00
1215	.c626		9c 1f 03	stz $031f	                stz vduv.queueEnd-5          ;VDU19,0,0,_,_,_
1216	.c629						+
1217	.c629		8e 20 03	stx $0320	                stx vduv.queueEnd-4          ;VDU19,N,X,_,_,_

1219							                ; fall through to VDU19

1221							;-------------------------------------------------------------------------
1222							;
1223							; VDU 19 (&13) Define logical colour [MasRef E.3-9]
1224							;
1225	.c62c						vdu19EntryPoint:
1226	.c62c		08		php		                php
1227	.c62d		78		sei		                sei
1228	.c62e		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get logical colour
1229	.c631		2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne ;apply logical colour limit
1230	.c634		aa		tax		                tax                        ;X = clamped logical colour
1231	.c635		ad 20 03	lda $0320	                lda vduv.queueEnd-4        ;get physical colour
1232	.c638						LC639:
1233	.c638		29 0f		and #$0f	                and #$0F                     ;apply physical colour limit
1234	.c63a		9d 6f 03	sta $036f,x	                sta vduv.currentPalette,x    ;update palette
1235	.c63d		a8		tay		                tay                          ;Y = physical colour
1236	.c63e		ad 60 03	lda $0360	                lda vduv.numberOfLogicalColoursMinusOne
1237	.c641		85 fa		sta $fa		                sta SEIWKA
1238	.c643		c9 03		cmp #$03	                cmp #$03 ;Z=1 C=1 if 4 colour; Z=0 C=1 if 16 colour; Z=0 C=0 if 2 colour
1239	.c645		08		php		                php      ;save flags
1240	.c646		8a		txa		                txa                          ;A = logical colour

1242							                ;put the logical colour value in the top 1, 2 or 4
1243							                ;bits of SEIWKA, depending on the colour depth.
1244							                ;
1245							                ; 2 colours: turn %0000000a into %a0000000
1246							                ; 4 colours: turn %000000ab into %ab000000
1247							                ;16 colours: turn %0000abcd into %abcd0000
1248	.c647						-
1249	.c647		4a		lsr a		                lsr a
1250	.c648		66 fa		ror $fa		                ror SEIWKA
1251	.c64a		b0 fb		bcs $c647	                bcs -
1252	.c64c		06 fa		asl $fa		                asl SEIWKA

1254	.c64e		98		tya		                tya                          ;A = physical colour
1255	.c64f		05 fa		ora $fa		                ora SEIWKA                   ;mix in logical colour
1256	.c651		aa		tax		                tax                          ;X = VPALETTE value
1257	.c652		a0 f0		ldy #$f0	                ldy #$F0 ;counts up to zero - counter for setting
1258							                         ;multiple logical colours [AUG p380]
1259	.c654						LC655:
1260	.c654		28		plp		                plp                          ;restore flags
1261	.c655		08		php		                php                          ;save flags
1262	.c656		d0 03		bne $c65b	                bne +                     ;taken if 2 colour/16 colour
1263	.c658		20 6e c6	jsr $c66e	                jsr fixUpVPALETTEFor4Colours
1264	.c65b						+
1265	.c65b		20 d4 f1	jsr $f1d4	                jsr writeVPALETTE
1266	.c65e		18		clc		                clc
1267	.c65f		98		tya		                tya
1268	.c660		6d 60 03	adc $0360	                adc vduv.numberOfLogicalColoursMinusOne
1269	.c663		a8		tay		                tay
1270	.c664		8a		txa		                txa
1271	.c665		69 10		adc #$10	                adc #$10                     ;next logical colour
1272	.c667		aa		tax		                tax
1273	.c668		c8		iny		                iny                          ;Y+=numberOfLogicalColours
1274	.c669		d0 e9		bne $c654	                bne LC655                    ;all logical colours set once zero
1275	.c66b		28		plp		                plp
1276	.c66c		28		plp		                plp
1277	.c66d		60		rts		                rts

1279	.c66e						fixUpVPALETTEFor4Colours:
1280	.c66e		2a		rol a		                rol a                        ;A BCDabcd1
1281	.c66f		85 da		sta $da		                sta ZTEMP+0                  ;  BCDabcd1
1282	.c671		2a		rol a		                rol a                        ;B CDabcd1A
1283	.c672		2a		rol a		                rol a                        ;C Dabcd1AB
1284	.c673		08		php		                php                          ;C
1285	.c674		26 da		rol $da		                rol ZTEMP+0                  ;B CDabcd1C
1286	.c676		6a		ror a		                ror a                        ;B BDabcd1A
1287	.c677		28		plp		                plp                          ;C BDabcd1A
1288	.c678		6a		ror a		                ror a                        ;A CBDabcd1
1289	.c679		6a		ror a		                ror a                        ;1 ACBDabcd
1290	.c67a		60		rts		                rts                          ;

1292							;-------------------------------------------------------------------------
1293							;
1294							; VDU 23 (&17) Various functions [MasRef E.3-12]
1295							;
1296	.c67b						vdu23EntryPoint:
1297	.c67b		ad 1b 03	lda $031b	                lda vduv.queueEnd-9           ;get VDU 23 code
1298	.c67e		c9 20		cmp #$20	                cmp #$20
1299	.c680		90 0e		bcc $c690	                bcc LC691         ;branch taken if <32 - i.e., special

1301							                ; copy the 8 bytes of character definition to the
1302							                ; appropriate place.
1303	.c682		20 2a e2	jsr $e22a	                jsr getSoftCharacterDefinitionAddress
1304	.c685		a0 07		ldy #$07	                ldy #$07
1305	.c687						LC688:
1306	.c687		b9 1c 03	lda $031c,y	                lda vduv.queueEnd-8,y
1307	.c68a		91 de		sta ($de),y	                sta ($DE),y
1308	.c68c		88		dey		                dey
1309	.c68d		10 f8		bpl $c687	                bpl LC688
1310	.c68f		60		rts		                rts

1312	.c690						LC691:
1313	.c690		0a		asl a		                asl a
1314	.c691		aa		tax		                tax
1315	.c692		4a		lsr a		                lsr a
1316	.c693		c9 11		cmp #$11	                cmp #$11
1317	.c695		b0 0f		bcs $c6a6	                bcs callVDUV    ;call with C=1 - invalid code [MasRef
1318							                                ;E.3-19]
1319	.c697		7c 67 e0	jmp ($e067,x)	                jmp (vdu23EntryPointTable,x)

1321							;-------------------------------------------------------------------------
1322							;
1323							; VDU 25 (&19) PLOT commands [MasRef E.3-21]
1324							;
1325	.c69a						vdu25EntryPoint:
1326	.c69a		ae 61 03	ldx $0361	                ldx vduv.pixelsPerByteMinusOne
1327	.c69d		f0 03		beq $c6a2	                beq callVDUVForPLOT          ;non-graphics PLOT
1328	.c69f		4c 45 d1	jmp $d145	                jmp handlePLOT

1330							;-------------------------------------------------------------------------
1331							;
1332							; Call VDUV for a PLOT call, either to handle non-graphics PLOT
1333							; [MasRef E.3-21] or PLOT 240-255 [MasRef E.3-34].
1334							;
1335	.c6a2						callVDUVForPLOT:
1336	.c6a2		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT code
1337	.c6a5		18		clc		                clc ;call with C=0 - non-graphics PLOT [MasRef E.3-21]

1339							;-------------------------------------------------------------------------
1340							;
1341							; Call VDUV.
1342							;
1343	.c6a6						callVDUV:
1344							                .if version<350
1346							                .else
1347	.c6a6		4c e1 e2	jmp $e2e1	                jmp LE2F3
1348							                .endif

1350							;-------------------------------------------------------------------------
1351							;
1352							; VDU 26 (&1A) Restore default windows [MasRef E.3-34]
1353							;
1354	.c6a9						vdu26EntryPoint:
1355	.c6a9		a2 2c		ldx #$2c	                ldx #VDUVariables.workspace._2C
1356	.c6ab						-
1357	.c6ab		9e 00 03	stz $0300,x	                stz vduv,x                    ;reset workspace
1358	.c6ae		ca		dex		                dex
1359	.c6af		10 fa		bpl $c6ab	                bpl -

1361	.c6b1		20 a0 e2	jsr $e2a0	                jsr getDefaultBoundsForCurrentScreenMODE
1362	.c6b4		8e 0a 03	stx $030a	                stx vduv.textWindowRight
1363	.c6b7		8c 09 03	sty $0309	                sty vduv.textWindowBottom

1365	.c6ba		8a		txa		                txa
1366	.c6bb		20 7f c7	jsr $c77f	                jsr setTextWindowWidthInBytes

1368							                ; Set up the VDU queue as if VDU 24,0;0;1279;1023;,
1369							                ; then call the VDU 24 entry point.

1371							                ; 1c - ll - $00
1372							                ; 1d - lh - $00
1373							                ; 1e - tl - $00
1374							                ; 1f - th - $00
1375							                ; 20 - rl - $ff
1376							                ; 21 - rh - $04
1377							                ; 22 - tl - $ff
1378							                ; 23 - th - $03

1380	.c6be		a0 03		ldy #$03	                ldy #$03
1381	.c6c0		8c 23 03	sty $0323	                sty $0323
1382	.c6c3		c8		iny		                iny
1383	.c6c4		8c 21 03	sty $0321	                sty $0321
1384	.c6c7		ce 22 03	dec $0322	                dec $0322
1385	.c6ca		ce 20 03	dec $0320	                dec $0320
1386	.c6cd		20 1e c7	jsr $c71e	                jsr vdu24EntryPoint

1388	.c6d0		a9 08		lda #$08	                lda #STATE.isTextWindow
1389	.c6d2		14 d0		trb $d0		                trb STATE                    ;reset isTextWindow

1391	.c6d4		4c 7b c4	jmp $c47b	                jmp vdu30EntryPoint          ;reset text cursor

1393							;-------------------------------------------------------------------------
1394							;
1395							; Update CRTC cursor address to reflect text cursor position.
1396							;
1397	.c6d7						updateCRTCTextCursor:
1398	.c6d7		20 fa cc	jsr $ccfa	                jsr updateZMEMTWithTextCursorPosition
1399	.c6da		80 10		bra $c6ec	                bra updateCRTCCursorAddress

1401							;-------------------------------------------------------------------------

1403	.c6dc						setCRTCCursorAddress:
1404	.c6dc		8e 4a 03	stx $034a	                stx vduv.textCursorCRTCAddress+0
1405	.c6df		8d 4b 03	sta $034b	                sta vduv.textCursorCRTCAddress+1
1406	.c6e2		10 04		bpl $c6e8	                bpl +
1407	.c6e4		38		sec		                sec
1408	.c6e5		ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte
1409	.c6e8						+
1410	.c6e8		86 d8		stx $d8		                stx ZMEMT+0
1411	.c6ea		85 d9		sta $d9		                sta ZMEMT+1

1413							;-------------------------------------------------------------------------
1414							;
1415							;
1416	.c6ec						updateCRTCCursorAddress:
1417	.c6ec		ae 4a 03	ldx $034a	                ldx vduv.textCursorCRTCAddress+0
1418	.c6ef		ad 4b 03	lda $034b	                lda vduv.textCursorCRTCAddress+1
1419	.c6f2		a0 0e		ldy #$0e	                ldy #$0E

1421							;-------------------------------------------------------------------------
1422							;
1423							; Set CRTC address - cursor, or screen start.
1424							;
1425							; entry:
1426							;
1427							; A (msb), X (msb) = 6502 address to set
1428							;
1429							; Y = first CRTC register to set
1430							;
1431	.c6f4						setCRTCAddress:
1432	.c6f4		48		pha		                pha                          ;save screen address MSB
1433	.c6f5		ad 55 03	lda $0355	                lda vduv.currentScreenMODE
1434	.c6f8		c9 07		cmp #$07	                cmp #$07
1435	.c6fa		68		pla		                pla                        ;restore screen address MSB
1436	.c6fb		b0 0f		bcs $c70c	                bcs adjustAddressForMODE7
1437	.c6fd		86 da		stx $da		                stx ZTEMP+0
1438	.c6ff		4a		lsr a		                lsr a
1439	.c700		66 da		ror $da		                ror ZTEMP+0                  ;/2
1440	.c702		4a		lsr a		                lsr a
1441	.c703		66 da		ror $da		                ror ZTEMP+0                  ;/4
1442	.c705		4a		lsr a		                lsr a
1443	.c706		66 da		ror $da		                ror ZTEMP+0                  ;/8
1444	.c708		a6 da		ldx $da		                ldx ZTEMP+0
1445	.c70a		80 04		bra $c710	                bra setCRTCAddressRegisters

1447	.c70c						adjustAddressForMODE7:
1448							                ; C=1
1449	.c70c		e9 74		sbc #$74	                sbc #$74                 ;adjust for Mode 7 addressing
1450	.c70e		49 20		eor #$20	                eor #$20                 ;adjust for Mode 7 addressing
1451	.c710						setCRTCAddressRegisters:
1452	.c710		8c 00 fe	sty $fe00	                sty CRTC+0
1453	.c713		8d 01 fe	sta $fe01	                sta CRTC+1
1454	.c716		c8		iny		                iny
1455	.c717		8c 00 fe	sty $fe00	                sty CRTC+0
1456	.c71a		8e 01 fe	stx $fe01	                stx CRTC+1
1457	.c71d		60		rts		                rts

1459							;-------------------------------------------------------------------------
1460							;
1461							; VDU 24 (&18) Define graphics window [MasRef E.3-21]
1462							;
1463							; VDU queue:
1464							;
1465							; -8 = <left
1466							; -7 = >left
1467							; -6 = <bottom
1468							; -5 = >bottom
1469							; -4 = <right
1470							; -3 = >right
1471							; -2 = <top
1472							; -1 = >top
1473							;
1474	.c71e						vdu24EntryPoint:
1475	.c71e		20 78 c7	jsr $c778	                jsr LC779

1477	.c721		a2 02		ldx #$02	                ldx #2
1478	.c723						-
1479	.c723		38		sec		                sec

1481							                ; <height when X=2, then <width when X=0
1482	.c724		bd 20 03	lda $0320,x	                lda vduv.queueEnd-4+0,x
1483	.c727		fd 1c 03	sbc $031c,x	                sbc vduv.queueEnd-8+0,x
1484	.c72a		9d 2c 03	sta $032c,x	                sta vduv.workspace._2C+0,x

1486							                ; >height when X=2, then >width when X=0
1487	.c72d		bd 21 03	lda $0321,x	                lda vduv.queueEnd-4+1,x
1488	.c730		fd 1d 03	sbc $031d,x	                sbc vduv.queueEnd-8+1,x
1489	.c733		9d 2d 03	sta $032d,x	                sta vduv.workspace._2C+1,x

1491	.c736		ca		dex		                dex
1492	.c737		ca		dex		                dex
1493	.c738		10 e9		bpl $c723	                bpl -

1495	.c73a		0d 2f 03	ora $032f	                ora vduv.workspace._2C+3     ;A=>width|>height
1496	.c73d		30 39		bmi $c778	                bmi LC779 ;taken if either dimension negative - window invalid
1497	.c73f		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4 ;left bottom
1498	.c741		20 dd d1	jsr $d1dd	                jsr eigabsEntryPoint         ;convert to pixels
1499	.c744		a2 1c		ldx #$1c	                ldx #VDUVariables.queueEnd-8 ;right top
1500	.c746		20 dd d1	jsr $d1dd	                jsr eigabsEntryPoint         ;convert to pixels
1501	.c749		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;>bottom
1502	.c74c		0d 1d 03	ora $031d	                ora vduv.queueEnd-7          ;>left
1503	.c74f		30 27		bmi $c778	                bmi LC779 ;taken if either bottom or left negative - window invalid
1504	.c751		ad 23 03	lda $0323	                lda vduv.queueEnd-1          ;>top
1505	.c754		d0 22		bne $c778	                bne LC779          ;taken if top>=256 - window invalid
1506	.c756		ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
1507	.c759		ad 21 03	lda $0321	                lda vduv.queueEnd-3          ;>right
1508	.c75c		85 da		sta $da		                sta ZTEMP+0
1509	.c75e		ad 20 03	lda $0320	                lda vduv.queueEnd-4          ;<right
1510	.c761		46 da		lsr $da		                lsr ZTEMP+0                  ;>(right/2)
1511	.c763		6a		ror a		                ror a                        ;<(right/2)
1512	.c764		46 da		lsr $da		                lsr ZTEMP+0                  ;>(right/4)

1514							                ; 639>>2=159 - so any valid pixel X in any mode will
1515							                ; have an MSB of 0 after being shifted right 2.
1516	.c766		d0 10		bne $c778	                bne LC779 ;taken if right edge definitely off screen - window invalid
1517	.c768		6a		ror a		                ror a     ;<(right/4)
1518	.c769		4a		lsr a		                lsr a     ;<(right/8)
1519	.c76a		dd 07 e1	cmp $e107,x	                cmp modeMaxColumn,x
1520	.c76d		f0 02		beq $c771	                beq LC772                    ;taken if right edge just on screen
1521	.c76f		10 07		bpl $c778	                bpl LC779 ;taken if right edge off screen - window definitely invalid
1522	.c771						LC772:
1523	.c771		a0 00		ldy #$00	                ldy #VDUVariables.graphicsWindowPixelsLeft
1524	.c773		a2 1c		ldx #$1c	                ldx #VDUVariables.queueEnd-8
1525	.c775		20 04 c9	jsr $c904	                jsr copyEightBytesWithinVDUVariables
1526	.c778						LC779:
1527	.c778		a2 10		ldx #$10	                ldx #VDUVariables.graphicsCursorPositionX
1528	.c77a		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
1529	.c77c		4c b8 e2	jmp $e2b8	                jmp exchangeFourVDUBytes

1531							;-------------------------------------------------------------------------
1532							;
1533							; Call getBytesPerInclusiveTextRow, and store the result in the
1534							; textWindowWidthInBytes VDU variable.
1535							;
1536	.c77f						setTextWindowWidthInBytes:
1537	.c77f		20 3b c9	jsr $c93b	                jsr getBytesPerInclusiveTextRow
1538	.c782		8d 4c 03	sta $034c	                sta vduv.textWindowWidthInBytes+0
1539	.c785		8e 4d 03	stx $034d	                stx vduv.textWindowWidthInBytes+1
1540	.c788		60		rts		                rts

1542							;-------------------------------------------------------------------------
1543							;
1544							; VDU 29 (&1D) Define graphics origin [MasRef E.3-35]
1545							;
1546	.c789						vdu29EntryPoint:
1547	.c789		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
1548	.c78b		a0 0c		ldy #$0c	                ldy #VDUVariables.graphicsWindowOriginX
1549	.c78d		20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
1550	.c790		4c de c4	jmp $c4de	                jmp LC4DF

1552							;-------------------------------------------------------------------------
1553							;
1554							; VDU 22 (&16) Select screen mode [MasRef E.3-11]
1555							;
1556	.c793						vdu22EntryPoint:
1557	.c793		ad 23 03	lda $0323	                lda vduv.queueEnd-1          ;get MODE number
1558	.c796		80 26		bra $c7be	                bra setMODE

1560							;-------------------------------------------------------------------------
1561							;
1562	.c798						setStartupMODE:
1563							                .if version==350
1564	.c798		20 5c f3	jsr $f35c	                jsr withTSTClear
1565							                .endif
1566	.c79b		85 da		sta $da		                sta ZTEMP+0                  ;save MODE
1567	.c79d		a5 f4		lda $f4		                lda $F4
1568	.c79f		48		pha		                pha
1569	.c7a0		09 80		ora #$80	                ora #$80                     ;page in ANDY
1570	.c7a2		20 5c e5	jsr $e55c	                jsr selectROMA
1571	.c7a5		20 ac c7	jsr $c7ac	                jsr +
1572	.c7a8		68		pla		                pla
1573	.c7a9		4c 5c e5	jmp $e55c	                jmp selectROMA               ;restore old ROM

1575	.c7ac						+
1576							                ; TODO but what of the reserved byte here?
1577	.c7ac		a2 7f		ldx #$7f	                ldx #size(VDUVariables)-1
1578	.c7ae		64 d0		stz $d0		                stz STATE
1579	.c7b0		ad 66 03	lda $0366	                lda vduv.cursorFlags
1580	.c7b3						-
1581	.c7b3		9e ff 02	stz $02ff,x	                stz vduv-1,x
1582	.c7b6		ca		dex		                dex
1583	.c7b7		d0 fa		bne $c7b3	                bne -
1584	.c7b9		8d 66 03	sta $0366	                sta vduv.cursorFlags
1585	.c7bc		a5 da		lda $da		                lda ZTEMP                    ;restore MODE

1587							                ; fall through to setMODE

1589							;-------------------------------------------------------------------------
1590							;
1591							;
1592							;
1593	.c7be						setMODE:
1594	.c7be		9c 8a 02	stz $028a	                stz vduDriverMemory
1595	.c7c1		9c 8b 02	stz $028b	                stz displayMemory
1596	.c7c4		a8		tay		                tay                          ;Y=mode
1597	.c7c5		30 10		bmi $c7d7	                bmi setShadowMODE
1598	.c7c7		ae 7f 02	ldx $027f	                ldx shadowRAMState
1599	.c7ca		f0 0b		beq $c7d7	                beq setShadowMODE
1600	.c7cc		a9 10		lda #$10	                lda #STATE.isShadowMode
1601	.c7ce		14 d0		trb $d0		                trb STATE
1602	.c7d0		a9 03		lda #$03	                lda #ACCCON.D|ACCCON.E
1603	.c7d2		1c 34 fe	trb $fe34	                trb ACCCON ;display main RAM, VDU code accesses main RAM
1604	.c7d5		80 09		bra $c7e0	                bra +

1606	.c7d7						setShadowMODE:
1607	.c7d7		a9 10		lda #$10	                lda #STATE.isShadowMode
1608	.c7d9		04 d0		tsb $d0		                tsb STATE
1609	.c7db		a9 03		lda #$03	                lda #ACCCON.D|ACCCON.E
1610	.c7dd		0c 34 fe	tsb $fe34	                tsb ACCCON ;display shadow RAM, VDU code accesses shadow RAM
1611	.c7e0						+
1612	.c7e0		98		tya		                tya                          ;A=mode
1613	.c7e1		29 07		and #$07	                and #$07                     ;get MODE 0-7
1614	.c7e3		aa		tax		                tax                          ;X=MODE 0-7
1615	.c7e4		8e 55 03	stx $0355	                stx vduv.currentScreenMODE
1616	.c7e7		bd 3a e1	lda $e13a,x	                lda numberOfLogicalColoursMinusOneForMODE,x
1617	.c7ea		8d 60 03	sta $0360	                sta vduv.numberOfLogicalColoursMinusOne
1618	.c7ed		bd 17 e1	lda $e117,x	                lda bytesPerCharacterForMODE,x
1619	.c7f0		8d 4f 03	sta $034f	                sta vduv.bytesPerCharacter
1620	.c7f3		bd 60 e1	lda $e160,x	                lda pixelsPerByteMinusOneForMODE,x
1621	.c7f6		8d 61 03	sta $0361	                sta vduv.pixelsPerByteMinusOne
1622	.c7f9		d0 02		bne $c7fd	                bne +                        ;taken if graphics mode
1623	.c7fb		a9 07		lda #$07	                lda #$07                     ;assume 8 px/byte for non-graphics modes
1624	.c7fd						+
1625	.c7fd		0a		asl a		                asl a            ;convert to pixelMasks index for rightmost pixel
1626	.c7fe		a8		tay		                tay
1627	.c7ff		b9 2c e1	lda $e12c,y	                lda pixelMasks-1,y
1628	.c802		8d 63 03	sta $0363	                sta vduv.colourMaskRight
1629	.c805						-
1630	.c805		0a		asl a		                asl a
1631	.c806		10 fd		bpl $c805	                bpl -   ;keep shifting until leftmost pixel mask found
1632	.c808		8d 62 03	sta $0362	                sta vduv.colourMaskLeft
1633	.c80b		bc 66 e1	ldy $e166,x	                ldy screenMODEGroupForMODE,x
1634	.c80e		8c 56 03	sty $0356	                sty vduv.currentScreenMODEGroup
1635	.c811		b9 72 e1	lda $e172,y	                lda latchBit4ForScreenMODEGroup,y
1636	.c814		08		php		                php
1637	.c815		78		sei		                sei
1638	.c816		8d 40 fe	sta $fe40	                sta systemVIA.orb
1639	.c819		b9 6e e1	lda $e16e,y	                lda latchBit5ForScreenMODEGroup,y
1640	.c81c		8d 40 fe	sta $fe40	                sta systemVIA.orb
1641	.c81f		28		plp		                plp
1642	.c820		b9 77 e1	lda $e177,y	                lda screenSizeHighByteForScreenMODEGroup,y
1643	.c823		8d 54 03	sta $0354	                sta vduv.screenSizeHighByte
1644	.c826		b9 7c e1	lda $e17c,y	                lda startScreenAddressHighByteForScreenMODEGroup,y
1645	.c829		8d 4e 03	sta $034e	                sta vduv.startScreenAddressHighByte
1646	.c82c		a9 ee		lda #$ee	                lda #STATE.isVDU21|STATE.isCursorEditing|STATE.isVDU5|STATE.isTextWindow|STATE.isPagedScrolling|STATE.isScrollingDisabled
1647	.c82e		14 d0		trb $d0		                trb STATE
1648	.c830		ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
1649	.c833		bd 0f e1	lda $e10f,x	                lda vcontrolForScreenMODE,x
1650	.c836		20 c3 f1	jsr $f1c3	                jsr setVCONTROL
1651	.c839		08		php		                php
1652	.c83a		78		sei		                sei
1653	.c83b		be 81 e1	ldx $e181,y	                ldx crtcRegisterLastIndexForScreenMODEGroup,y
1654	.c83e		a0 0b		ldy #$0b	                ldy #$0B
1655	.c840						-
1656	.c840		bd 86 e1	lda $e186,x	                lda crtcRegisterValues,x
1657	.c843		20 00 cf	jsr $cf00	                jsr setCRTCRegister
1658	.c846		ca		dex		                dex
1659	.c847		88		dey		                dey
1660	.c848		10 f6		bpl $c840	                bpl -
1661	.c84a		28		plp		                plp
1662	.c84b		20 c4 c5	jsr $c5c4	                jsr vdu20EntryPoint
1663	.c84e		20 6c cf	jsr $cf6c	                jsr vdu23_11_EntryPoint
1664	.c851		a9 aa		lda #$aa	                lda #%10101010
1665	.c853		8d 67 03	sta $0367	                sta vduv.dotPattern
1666	.c856		8d 68 03	sta $0368	                sta vduv.dotPatternState
1667	.c859		20 a9 c6	jsr $c6a9	                jsr vdu26EntryPoint
1668	.c85c		ad 4c 03	lda $034c	                lda vduv.textWindowWidthInBytes+0
1669	.c85f		ae 4d 03	ldx $034d	                ldx vduv.textWindowWidthInBytes+1
1670	.c862		8d 52 03	sta $0352	                sta vduv.bytesPerCharacterRow+0
1671	.c865		8e 53 03	stx $0353	                stx vduv.bytesPerCharacterRow+1

1673							                ; Do a fast hardware CLS of the whole screen
1674							                ; ------------------------------------------
1675	.c868						clsFastPath:
1676	.c868		a2 00		ldx #$00	                ldx #$00
1677	.c86a		ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
1678	.c86d		9c 50 03	stz $0350	                stz vduv.screenTopLeftAddress+0
1679	.c870		8d 51 03	sta $0351	                sta vduv.screenTopLeftAddress+1
1680	.c873		20 dc c6	jsr $c6dc	                jsr setCRTCCursorAddress
1681	.c876		a0 0c		ldy #$0c	                ldy #$0C
1682	.c878		20 10 c7	jsr $c710	                jsr setCRTCAddressRegisters
1683	.c87b		9c 69 02	stz $0269	                stz pagedModeCounter
1684	.c87e		38		sec		                sec
1685	.c87f		a9 80		lda #$80	                lda #$80
1686	.c881		ed 4e 03	sbc $034e	                sbc vduv.startScreenAddressHighByte
1687	.c884		aa		tax		                tax
1688	.c885		a0 00		ldy #$00	                ldy #$00
1689	.c887		20 84 cb	jsr $cb84	                jsr clearTextMemory
1690	.c88a		4c 7b c4	jmp $c47b	                jmp vdu30EntryPoint

1692	.c88d						LC88B:
1693	.c88d		20 d0 c8	jsr $c8d0	                jsr LC8CF                    ; Clear paged mode counter
1694	.c890						LC88E:
1695	.c890		20 a3 f1	jsr $f1a3	                jsr osbyte76    ; Call KEYV to test Shift & Ctrl keys
1696	.c893		90 02		bcc $c897	                bcc LC895                    ; Ctrl not pressed, exit loop
1697	.c895		30 f6		bmi $c88d	                bmi LC88B                    ; Shift pressed, loop back
1698	.c897						LC895:
1699	.c897		a5 d0		lda $d0		                lda STATE
1700	.c899		49 04		eor #$04	                eor #STATE.isPagedScrolling
1701	.c89b		29 46		and #$46	                and #STATE.isCursorEditing|STATE.isPagedScrolling|STATE.isScrollingDisabled;
1702	.c89d		d0 37		bne $c8d6	                bne LC8D6
1703	.c89f		20 d7 c8	jsr $c8d7	                jsr LC8D7
1704	.c8a2		b9 18 03	lda $0318,y	                lda vduv.textCursorXPosition,y
1705	.c8a5		dd 08 03	cmp $0308,x	                cmp vduv.textWindowLeft,x
1706	.c8a8		d0 29		bne $c8d3	                bne LC8D3
1707							                .if version==400||version==350
1708	.c8aa		c0 00		cpy #$00	                cpy #0
1713							                .endif
1714	.c8ac		d0 08		bne $c8b6	                bne LC8B5
1715	.c8ae		ad 0a 03	lda $030a	                lda vduv.textWindowRight
1716	.c8b1		ed 08 03	sbc $0308	                sbc vduv.textWindowLeft
1717	.c8b4		80 06		bra $c8bc	                bra LC8BB

1719	.c8b6						LC8B5:
1720	.c8b6		ad 09 03	lda $0309	                lda vduv.textWindowBottom
1721	.c8b9		ed 0b 03	sbc $030b	                sbc vduv.textWindowTop
1722	.c8bc						LC8BB:
1723	.c8bc		48		pha		                pha
1724	.c8bd		4a		lsr a		                lsr a
1725	.c8be		4a		lsr a		                lsr a
1726	.c8bf		85 da		sta $da		                sta ZTEMP+0
1727	.c8c1		38		sec		                sec
1728	.c8c2		68		pla		                pla
1729	.c8c3		e5 da		sbc $da		                sbc ZTEMP+0
1730	.c8c5		cd 69 02	cmp $0269	                cmp pagedModeCounter
1731	.c8c8		b0 09		bcs $c8d3	                bcs LC8D3
1732	.c8ca						LC8C9:
1733	.c8ca		20 a3 f1	jsr $f1a3	                jsr osbyte76
1734	.c8cd		38		sec		                sec
1735	.c8ce		10 fa		bpl $c8ca	                bpl LC8C9

1737	.c8d0						LC8CF:
1738	.c8d0		9c 69 02	stz $0269	                stz pagedModeCounter        ; Clear paged mode counter
1739							                .if version!=400&&version!=350
1741							                .endif
1742	.c8d3						LC8D3:
1743	.c8d3		ee 69 02	inc $0269	                inc pagedModeCounter
1744	.c8d6						LC8D6:
1745	.c8d6		60		rts		                rts

1747	.c8d7						LC8D7:
1748	.c8d7		ad 66 03	lda $0366	                lda vduv.cursorFlags
1749	.c8da		29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
1750	.c8dc		4a		lsr a		                lsr a                        ;xvh
1751	.c8dd		aa		tax		                tax
1752	.c8de		bd 02 e2	lda $e202,x	                lda LE204,x
1753	.c8e1		aa		tax		                tax
1754	.c8e2		29 01		and #$01	                and #$01
1755	.c8e4		a8		tay		                tay
1756	.c8e5		60		rts		                rts

1758							;-------------------------------------------------------------------------
1759							;
1760							; Prepare AABB based on the current graphics cursor and some other
1761							; coordinate.
1762							;
1763							; entry:
1764							;
1765							; X = VDU variable offset of other coordinate (4 bytes: X;Y;)
1766							;
1767							; exit:
1768							;
1769							; vduv.workspace._28 = minimum
1770							;
1771							; vduv.workspace._2c = maximum
1772							;
1773	.c8e6						prepareAABB:
1774	.c8e6		a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixels
1775	.c8e8		20 b6 d5	jsr $d5b6	                jsr sortVDUVariableCoordinates
1776	.c8eb		5a		phy		                phy                          ;save greater Y
1777	.c8ec		da		phx		                phx                          ;save lesser Y
1778	.c8ed		20 cb d5	jsr $d5cb	                jsr sortVDUVariableWords     ;X=lesser X, Y=greater X
1779	.c8f0		68		pla		                pla                          ;A=lesser Y
1780	.c8f1		5a		phy		                phy                          ;save greater X
1781	.c8f2		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
1782	.c8f4		20 f9 c8	jsr $c8f9	                jsr +
1783	.c8f7		fa		plx		                plx                          ;X=greater X
1784	.c8f8		68		pla		                pla                          ;A=greater Y
1785	.c8f9						+
1786							                ; Copy VDU variable word +X to VDU variable word+Y.
1787							                ; Then cropy VDU variable word +A+2 to VDU variable
1788							                ; word+Y+2. Return with updated Y.
1789	.c8f9		48		pha		                pha
1790	.c8fa		20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
1791	.c8fd		fa		plx		                plx
1792	.c8fe		e8		inx		                inx
1793	.c8ff		e8		inx		                inx
1794	.c900		80 0a		bra $c90c	                bra copyTwoBytesWithinVDUVariables

1796							;-------------------------------------------------------------------------
1797							;
1798							; Copy 8 bytes to workspace 28 in the VDU variables.
1799							;
1800							; entry:
1801							;
1802							; X = source offset
1803							;
1804	.c902						copyEightBytesToWorkspace28:
1805	.c902		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28

1807							;-------------------------------------------------------------------------
1808							;
1809							; Copy 8 bytes in the VDU variables.
1810							;
1811							; entry:
1812							;
1813							; X = source offset
1814							;
1815							; Y = dest offset
1816							;
1817	.c904						copyEightBytesWithinVDUVariables:
1818	.c904		a9 08		lda #$08	                lda #$08
1819	.c906		80 18		bra $c920	                bra copyABytesWithinVDUVariables

1821							;-------------------------------------------------------------------------
1822							;
1823							; copyTextWindowWidthInBytesToWorkspace28
1824	.c908						copyTextWindowWidthInBytesToWorkspace28:
1825	.c908		a2 4c		ldx #$4c	                ldx #VDUVariables.textWindowWidthInBytes
1826	.c90a		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28

1828							;-------------------------------------------------------------------------
1829							;
1830							;
1831	.c90c						copyTwoBytesWithinVDUVariables:
1832	.c90c		a9 02		lda #$02	                lda #$02
1833	.c90e		80 10		bra $c920	                bra copyABytesWithinVDUVariables

1835							;-------------------------------------------------------------------------
1836							;
1837							; Copy text window info to workspace2C.
1838							;
1839	.c910						copyTextWindowToWorkspace2C:
1840	.c910		a2 08		ldx #$08	                ldx #VDUVariables.textWindowLeft
1841	.c912		a0 2c		ldy #$2c	                ldy #VDUVariables.workspace._2C
1842	.c914		80 08		bra $c91e	                bra copyFourBytesWithinVDUVariables

1844							;-------------------------------------------------------------------------
1845							;
1846							; Copy last 4 bytes of VDU queue somewhere.
1847							;
1848	.c916						copyLastFourVDUQueueBytes:
1849	.c916		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
1850	.c918		80 04		bra $c91e	                bra copyFourBytesWithinVDUVariables

1852							;-------------------------------------------------------------------------
1853							;
1854							; Copy old graphics cursor position to current graphics cursor position.
1855							;
1856	.c91a						copyGraphicsCursorPixelsToOldGraphicsCursorPixels:
1857	.c91a		a0 14		ldy #$14	                ldy #VDUVariables.oldGraphicsCursorPixelsX

1859							;-------------------------------------------------------------------------
1860							;
1861							; Copy the graphics cursor position somewhere.
1862							;
1863	.c91c						copyGraphicsCursorPixels:
1864	.c91c		a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX

1866							;-------------------------------------------------------------------------
1867							;
1868							; Copy 4 bytes in the VDU variables.
1869							;
1870							; entry:
1871							;
1872							; X = source offset
1873							;
1874							; Y = dest offset
1875							;
1876	.c91e						copyFourBytesWithinVDUVariables:
1877	.c91e		a9 04		lda #$04	                lda #$04

1879							                ; fall through to copyABytesWithinVDUVariables

1881							;-------------------------------------------------------------------------
1882							;
1883							; Copy some bytes in the VDU variables.
1884							;
1885							; entry:
1886							;
1887							; A = number of bytes
1888							;
1889							; X = source offset
1890							;
1891							; Y = dest offset
1892							;
1893							; exit:
1894							;
1895							; X = updated source offset
1896							;
1897							; Y = updated dest offset
1898							;
1899	.c920						copyABytesWithinVDUVariables:
1900	.c920		48		pha		                pha
1901	.c921		bd 00 03	lda $0300,x	                lda vduv,x
1902	.c924		99 00 03	sta $0300,y	                sta vduv,y
1903	.c927		e8		inx		                inx
1904	.c928		c8		iny		                iny
1905	.c929		68		pla		                pla
1906	.c92a		3a		dec a		                dec a
1907	.c92b		d0 f3		bne $c920	                bne copyABytesWithinVDUVariables
1908	.c92d		60		rts		                rts

1910							;-------------------------------------------------------------------------
1911							;
1912							; Negate a 16-bit value stored in Y/A
1913							;
1914							; entry:
1915							;
1916							; Y (LSB), A (MSB) = value
1917							;
1918							; exit:
1919							;
1920							; Y (LSB), A (MSB) = -value
1921							;
1922	.c92e						negateAY:
1923	.c92e		48		pha		                pha
1924	.c92f		98		tya		                tya
1925	.c930		49 ff		eor #$ff	                eor #$FF
1926	.c932		a8		tay		                tay
1927	.c933		68		pla		                pla
1928	.c934		49 ff		eor #$ff	                eor #$FF
1929	.c936		c8		iny		                iny
1930	.c937		d0 01		bne $c93a	                bne +
1931	.c939		1a		inc a		                inc a
1932	.c93a						+
1933	.c93a		60		rts		                rts

1935							;-------------------------------------------------------------------------
1936							;
1937							; Multiply a text window width by the number of bytes per char. There
1938							; are inclusive and exclusive versions, depending on how the width was
1939							; calculated.
1940							;
1941							; entry:
1942							;
1943							; A = value-1 to multiply (inclusive), value to multiply (exclusive)
1944							;
1945							; exit:
1946							;
1947							; A (lsb), X (msb) = value*vduv.bytesPerCharacter
1948							;
1949	.c93b						getBytesPerInclusiveTextRow:
1950	.c93b		1a		inc a		                inc a
1951	.c93c						getBytesPerExclusiveTextRow:
1952	.c93c		85 da		sta $da		                sta $DA
1953	.c93e		64 db		stz $db		                stz $DB
1954	.c940		ad 4f 03	lda $034f	                lda vduv.bytesPerCharacter    ;A=1/8/16/32
1955	.c943						-
1956	.c943		4a		lsr a		                lsr a
1957	.c944		b0 06		bcs $c94c	                bcs +                     ;taken when multiply is done
1958	.c946		06 da		asl $da		                asl $DA              ;shift size LSB
1959	.c948		26 db		rol $db		                rol $DB              ;carry into size MSB
1960	.c94a		80 f7		bra $c943	                bra -

1962	.c94c						+
1963	.c94c		a5 da		lda $da		                lda $DA
1964	.c94e		a6 db		ldx $db		                ldx $DB
1965	.c950		60		rts		                rts

1967							;-------------------------------------------------------------------------
1968							;
1969							;
1970	.c951						prepareForPlotBackground:
1971	.c951		a2 08		ldx #$08	                ldx #$08                     ;plot background
1972	.c953		8e 59 03	stx $0359	                stx vduv.graphicsPlotState
1973	.c956		ad 5c 03	lda $035c	                lda vduv.backgroundGCOLMode
1974	.c959		29 0f		and #$0f	                and #$0F
1975	.c95b		8d 5a 03	sta $035a	                sta vduv.graphicsPlotMode
1976	.c95e		60		rts		                rts

1978							;-------------------------------------------------------------------------

1980	.c95f						LC95F:
1981	.c95f		a9 00		lda #$00	                lda #$00
1982	.c961		48		pha		                pha
1983	.c962		48		pha		                pha
1984	.c963		ae 2a 03	ldx $032a	                ldx $032A
1985	.c966		20 7d cc	jsr $cc7d	                jsr LCC7D
1986	.c969		80 14		bra $c97f	                bra LC97F

1988	.c96b						LC96B:
1989	.c96b		38		sec		                sec
1990	.c96c		ad 4f 03	lda $034f	                lda $034F
1991	.c96f		ed 2a 03	sbc $032a	                sbc $032A
1992	.c972		48		pha		                pha
1993	.c973		20 a0 e2	jsr $e2a0	                jsr getDefaultBoundsForCurrentScreenMODE
1994	.c976		da		phx		                phx
1995	.c977		a9 00		lda #$00	                lda #$00
1996	.c979		ae 2a 03	ldx $032a	                ldx $032A
1997	.c97c		20 5d cc	jsr $cc5d	                jsr LCC5D
1998	.c97f						LC97F:
1999							                ; scroll left/right
2000	.c97f		8e 50 03	stx $0350	                stx vduv.screenTopLeftAddress+0
2001	.c982		8d 51 03	sta $0351	                sta vduv.screenTopLeftAddress+1
2002	.c985		fa		plx		                plx
2003	.c986		a0 00		ldy #$00	                ldy #$00
2004	.c988		20 b0 cc	jsr $ccb0	                jsr getAddressForTextPosition
2005	.c98b		fa		plx		                plx
2006	.c98c		a9 00		lda #$00	                lda #$00
2007	.c98e		20 5d cc	jsr $cc5d	                jsr LCC5D
2008	.c991		86 d8		stx $d8		                stx ZMEMT+0
2009	.c993		85 d9		sta $d9		                sta ZMEMT+1
2010	.c995		20 a0 e2	jsr $e2a0	                jsr getDefaultBoundsForCurrentScreenMODE
2011	.c998		20 ae ca	jsr $caae	                jsr LCAAE
2012	.c99b		80 1b		bra $c9b8	                bra LC9B8

2014	.c99d						LC99D:
2015	.c99d		a0 00		ldy #$00	                ldy #$00
2016	.c99f		20 77 cc	jsr $cc77	                jsr LCC77
2017	.c9a2		80 06		bra $c9aa	                bra LC9AA

2019	.c9a4						LC9A4:
2020	.c9a4		20 a0 e2	jsr $e2a0	                jsr getDefaultBoundsForCurrentScreenMODE
2021	.c9a7		20 57 cc	jsr $cc57	                jsr LCC57
2022	.c9aa						LC9AA:
2023	.c9aa		8e 50 03	stx $0350	                stx vduv.screenTopLeftAddress+0
2024	.c9ad		8d 51 03	sta $0351	                sta vduv.screenTopLeftAddress+1
2025	.c9b0		a2 00		ldx #$00	                ldx #$00
2026	.c9b2		20 b0 cc	jsr $ccb0	                jsr getAddressForTextPosition
2027	.c9b5		20 e8 ca	jsr $cae8	                jsr LCAE8
2028	.c9b8						LC9B8:
2029	.c9b8		a0 0c		ldy #$0c	                ldy #$0C
2030	.c9ba		ad 51 03	lda $0351	                lda vduv.screenTopLeftAddress+1
2031	.c9bd		ae 50 03	ldx $0350	                ldx vduv.screenTopLeftAddress+0
2032	.c9c0		4c f4 c6	jmp $c6f4	                jmp setCRTCAddress

2034	.c9c3						LC9C3:
2035	.c9c3		20 a0 cc	jsr $cca0	                jsr LCCA0
2036	.c9c6						LC9C6:
2037	.c9c6		85 dd		sta $dd		                sta $DD
2038	.c9c8		86 dc		stx $dc		                stx $DC
2039	.c9ca		20 2c cc	jsr $cc2c	                jsr LCC2C
2040	.c9cd		ad 29 03	lda $0329	                lda $0329
2041	.c9d0		ae 28 03	ldx $0328	                ldx $0328
2042	.c9d3		20 5d cc	jsr $cc5d	                jsr LCC5D
2043	.c9d6		20 88 cc	jsr $cc88	                jsr LCC88
2044	.c9d9		86 d8		stx $d8		                stx ZMEMT+0
2045	.c9db		85 d9		sta $d9		                sta ZMEMT+1
2046	.c9dd		a9 00		lda #$00	                lda #$00
2047	.c9df		ae 2a 03	ldx $032a	                ldx $032A
2048	.c9e2		20 7d cc	jsr $cc7d	                jsr LCC7D
2049	.c9e5		20 88 cc	jsr $cc88	                jsr LCC88
2050	.c9e8		86 da		stx $da		                stx $DA
2051	.c9ea		85 db		sta $db		                sta $DB
2052	.c9ec		ac 28 03	ldy $0328	                ldy $0328
2053	.c9ef		ae 29 03	ldx $0329	                ldx $0329
2054	.c9f2		50 23		bvc $ca17	                bvc LCA17
2055	.c9f4		a4 e0		ldy $e0		                ldy $E0
2056	.c9f6		a6 e1		ldx $e1		                ldx $E1
2057	.c9f8		20 e7 cb	jsr $cbe7	                jsr LCBE7
2058	.c9fb		a4 e0		ldy $e0		                ldy $E0
2059	.c9fd		90 09		bcc $ca08	                bcc LCA08
2060	.c9ff		a2 80		ldx #$80	                ldx #$80
2061	.ca01		86 db		stx $db		                stx $DB
2062	.ca03		64 da		stz $da		                stz $DA
2063	.ca05		ac 2a 03	ldy $032a	                ldy $032A
2064	.ca08						LCA08:
2065	.ca08		a2 00		ldx #$00	                ldx #$00
2066	.ca0a		20 f3 cb	jsr $cbf3	                jsr LCBF3
2067	.ca0d		a2 80		ldx #$80	                ldx #$80
2068	.ca0f		86 d9		stx $d9		                stx ZMEMT+1
2069	.ca11		64 d8		stz $d8		                stz ZMEMT+0
2070	.ca13		a4 de		ldy $de		                ldy $DE
2071	.ca15		a6 df		ldx $df		                ldx $DF
2072	.ca17						LCA17:
2073	.ca17		20 e7 cb	jsr $cbe7	                jsr LCBE7
2074	.ca1a		20 97 cc	jsr $cc97	                jsr LCC97
2075	.ca1d		20 94 cc	jsr $cc94	                jsr LCC94
2076	.ca20		20 57 cc	jsr $cc57	                jsr LCC57
2077	.ca23		86 d8		stx $d8		                stx ZMEMT+0
2078	.ca25		85 d9		sta $d9		                sta ZMEMT+1
2079	.ca27		ce 2b 03	dec $032b	                dec $032B
2080	.ca2a		10 9a		bpl $c9c6	                bpl LC9C6
2081	.ca2c		60		rts		                rts

2083	.ca2d						LCA2D:
2084	.ca2d		20 a0 cc	jsr $cca0	                jsr LCCA0
2085	.ca30						LCA30:
2086	.ca30		20 2c cc	jsr $cc2c	                jsr LCC2C
2087	.ca33		a9 00		lda #$00	                lda #$00
2088	.ca35		ae 2a 03	ldx $032a	                ldx $032A
2089	.ca38		20 5d cc	jsr $cc5d	                jsr LCC5D
2090	.ca3b		86 da		stx $da		                stx $DA
2091	.ca3d		85 db		sta $db		                sta $DB
2092	.ca3f		20 57 cc	jsr $cc57	                jsr LCC57
2093	.ca42		86 dc		stx $dc		                stx $DC
2094	.ca44		85 dd		sta $dd		                sta $DD
2095	.ca46		ac 28 03	ldy $0328	                ldy $0328
2096	.ca49		ae 29 03	ldx $0329	                ldx $0329
2097	.ca4c		50 25		bvc $ca73	                bvc LCA73
2098	.ca4e		a4 de		ldy $de		                ldy $DE
2099	.ca50		a6 df		ldx $df		                ldx $DF
2100	.ca52		20 a8 cb	jsr $cba8	                jsr LCBA8
2101	.ca55		a4 de		ldy $de		                ldy $DE
2102	.ca57		90 0a		bcc $ca63	                bcc LCA63
2103	.ca59		ae 4e 03	ldx $034e	                ldx $034E
2104	.ca5c		86 db		stx $db		                stx $DB
2105	.ca5e		64 da		stz $da		                stz $DA
2106	.ca60		ac 2a 03	ldy $032a	                ldy $032A
2107	.ca63						LCA63:
2108	.ca63		a2 00		ldx #$00	                ldx #$00
2109	.ca65		20 b4 cb	jsr $cbb4	                jsr LCBB4
2110	.ca68		ae 4e 03	ldx $034e	                ldx $034E
2111	.ca6b		86 d9		stx $d9		                stx ZMEMT+1
2112	.ca6d		64 d8		stz $d8		                stz ZMEMT+0
2113	.ca6f		a4 e0		ldy $e0		                ldy $E0
2114	.ca71		a6 e1		ldx $e1		                ldx $E1
2115	.ca73						LCA73:
2116	.ca73		20 a8 cb	jsr $cba8	                jsr LCBA8
2117	.ca76		20 94 cc	jsr $cc94	                jsr LCC94
2118	.ca79		ce 2b 03	dec $032b	                dec $032B
2119	.ca7c		10 b2		bpl $ca30	                bpl LCA30
2120	.ca7e						LCA7E:
2121	.ca7e		60		rts		                rts

2123	.ca7f						LCA7F:
2124	.ca7f		86 dc		stx $dc		                stx $DC
2125	.ca81		aa		tax		                tax
2126	.ca82		38		sec		                sec
2127	.ca83		e5 dc		sbc $dc		                sbc $DC
2128	.ca85		f0 f7		beq $ca7e	                beq LCA7E
2129	.ca87		85 dd		sta $dd		                sta $DD
2130	.ca89		da		phx		                phx
2131	.ca8a		20 3c c9	jsr $c93c	                jsr getBytesPerExclusiveTextRow
2132	.ca8d		fa		plx		                plx
2133	.ca8e		ad 66 03	lda $0366	                lda $0366
2134	.ca91		89 08		bit #$08	                bit #$08
2135	.ca93		d0 0b		bne $caa0	                bne LCAA0
2136	.ca95		89 02		bit #$02	                bit #$02
2137	.ca97		20 ca cc	jsr $ccca	                jsr LCCCA
2138	.ca9a		a4 da		ldy $da		                ldy $DA
2139	.ca9c		a6 db		ldx $db		                ldx $DB
2140	.ca9e		80 2e		bra $cace	                bra LCACE

2142	.caa0						LCAA0:
2143	.caa0		89 04		bit #$04	                bit #$04
2144	.caa2		20 ca cc	jsr $ccca	                jsr LCCCA
2145	.caa5		ad 4f 03	lda $034f	                lda $034F
2146	.caa8		8d 2a 03	sta $032a	                sta $032A
2147	.caab		a4 dd		ldy $dd		                ldy $DD
2148	.caad		88		dey		                dey
2149	.caae						LCAAE:
2150	.caae		98		tya		                tya
2151	.caaf		f0 18		beq $cac9	                beq LCAC9
2152	.cab1		84 dc		sty $dc		                sty $DC
2153	.cab3						LCAB3:
2154	.cab3		20 57 cc	jsr $cc57	                jsr LCC57
2155	.cab6		86 da		stx $da		                stx $DA
2156	.cab8		85 db		sta $db		                sta $DB
2157	.caba		20 c9 ca	jsr $cac9	                jsr LCAC9
2158	.cabd		a6 da		ldx $da		                ldx $DA
2159	.cabf		86 d8		stx $d8		                stx ZMEMT+0
2160	.cac1		a5 db		lda $db		                lda $DB
2161	.cac3		85 d9		sta $d9		                sta ZMEMT+1
2162	.cac5		c6 dc		dec $dc		                dec $DC
2163	.cac7		d0 ea		bne $cab3	                bne LCAB3
2164	.cac9						LCAC9:
2165	.cac9		a2 00		ldx #$00	                ldx #$00
2166	.cacb		ac 2a 03	ldy $032a	                ldy $032A
2167	.cace						LCACE:
2168	.cace		ad 28 03	lda $0328	                lda $0328
2169	.cad1		48		pha		                pha
2170	.cad2		ad 29 03	lda $0329	                lda $0329
2171	.cad5		48		pha		                pha
2172	.cad6		8c 28 03	sty $0328	                sty $0328
2173	.cad9		8e 29 03	stx $0329	                stx $0329
2174	.cadc		20 e8 ca	jsr $cae8	                jsr LCAE8
2175	.cadf		68		pla		                pla
2176	.cae0		8d 29 03	sta $0329	                sta $0329
2177	.cae3		68		pla		                pla
2178	.cae4		8d 28 03	sta $0328	                sta $0328
2179	.cae7		60		rts		                rts

2181							;-------------------------------------------------------------------------

2183	.cae8						LCAE8:
2184	.cae8		a6 d8		ldx $d8		                ldx ZMEMT+0
2185	.caea		a5 d9		lda $d9		                lda ZMEMT+1
2186	.caec		20 2c cc	jsr $cc2c	                jsr LCC2C
2187	.caef		80 79		bra $cb6a	                bra LCB6A

2189							;-------------------------------------------------------------------------

2191	.caf1						LCAF1:
2192	.caf1		a2 77		ldx #$77	                ldx #<LCC77
2193	.caf3		a9 cc		lda #$cc	                lda #>LCC77
2194	.caf5		ac 2d 03	ldy $032d	                ldy $032D
2195	.caf8		80 07		bra $cb01	                bra LCB01

2197	.cafa						LCAFA:
2198	.cafa		a2 57		ldx #$57	                ldx #<LCC57
2199	.cafc		a9 cc		lda #$cc	                lda #>LCC57
2200	.cafe		ac 2f 03	ldy $032f	                ldy $032F
2201	.cb01						LCB01:
2202	.cb01		8e 5d 03	stx $035d	                stx $035D
2203	.cb04		8d 5e 03	sta $035e	                sta $035E
2204	.cb07		38		sec		                sec
2205	.cb08		ad 2d 03	lda $032d	                lda $032D
2206	.cb0b		ed 2f 03	sbc $032f	                sbc $032F
2207	.cb0e		8d 2b 03	sta $032b	                sta $032B
2208	.cb11		ae 2c 03	ldx $032c	                ldx $032C
2209	.cb14		20 b0 cc	jsr $ccb0	                jsr getAddressForTextPosition
2210	.cb17		85 dd		sta $dd		                sta $DD
2211	.cb19		86 dc		stx $dc		                stx $DC
2212	.cb1b		20 2c cc	jsr $cc2c	                jsr LCC2C
2213	.cb1e		ad 2b 03	lda $032b	                lda $032B
2214	.cb21		f0 47		beq $cb6a	                beq LCB6A
2215	.cb23						LCB23:
2216	.cb23		08		php		                php
2217	.cb24		20 24 c0	jsr $c024	                jsr LC024
2218	.cb27		86 da		stx $da		                stx $DA
2219	.cb29		85 db		sta $db		                sta $DB
2220	.cb2b		86 dc		stx $dc		                stx $DC
2221	.cb2d		85 dd		sta $dd		                sta $DD
2222	.cb2f		28		plp		                plp
2223	.cb30		50 1d		bvc $cb4f	                bvc LCB4F
2224	.cb32		b8		clv		                clv
2225	.cb33						LCB33:
2226	.cb33		a6 df		ldx $df		                ldx $DF
2227	.cb35		a4 de		ldy $de		                ldy $DE
2228	.cb37		20 b4 cb	jsr $cbb4	                jsr LCBB4
2229	.cb3a		ad 4e 03	lda $034e	                lda $034E
2230	.cb3d		70 06		bvs $cb45	                bvs LCB45
2231	.cb3f		85 d9		sta $d9		                sta ZMEMT+1
2232	.cb41		64 d8		stz $d8		                stz ZMEMT+0
2233	.cb43		80 04		bra $cb49	                bra LCB49

2235	.cb45						LCB45:
2236	.cb45		85 db		sta $db		                sta $DB
2237	.cb47		64 da		stz $da		                stz $DA
2238	.cb49						LCB49:
2239	.cb49		a6 e1		ldx $e1		                ldx $E1
2240	.cb4b		a4 e0		ldy $e0		                ldy $E0
2241	.cb4d		80 0b		bra $cb5a	                bra LCB5A

2243	.cb4f						LCB4F:
2244	.cb4f		20 2c cc	jsr $cc2c	                jsr LCC2C
2245	.cb52		70 df		bvs $cb33	                bvs LCB33
2246	.cb54		ae 29 03	ldx $0329	                ldx $0329
2247	.cb57		ac 28 03	ldy $0328	                ldy $0328
2248	.cb5a						LCB5A:
2249	.cb5a		20 b4 cb	jsr $cbb4	                jsr LCBB4
2250	.cb5d		a6 dc		ldx $dc		                ldx $DC
2251	.cb5f		86 d8		stx $d8		                stx ZMEMT+0
2252	.cb61		a5 dd		lda $dd		                lda $DD
2253	.cb63		85 d9		sta $d9		                sta ZMEMT+1
2254	.cb65		ce 2b 03	dec $032b	                dec $032B
2255	.cb68		d0 b9		bne $cb23	                bne LCB23
2256	.cb6a						LCB6A:
2257	.cb6a		ae 29 03	ldx $0329	                ldx $0329
2258	.cb6d		ac 28 03	ldy $0328	                ldy $0328
2259	.cb70		50 12		bvc $cb84	                bvc clearTextMemory
2260	.cb72		a6 df		ldx $df		                ldx $DF
2261	.cb74		a4 de		ldy $de		                ldy $DE
2262	.cb76		20 84 cb	jsr $cb84	                jsr clearTextMemory
2263	.cb79		ad 4e 03	lda $034e	                lda $034E
2264	.cb7c		85 d9		sta $d9		                sta ZMEMT+1
2265	.cb7e		64 d8		stz $d8		                stz ZMEMT+0
2266	.cb80		a6 e1		ldx $e1		                ldx $E1
2267	.cb82		a4 e0		ldy $e0		                ldy $E0

2269							;-------------------------------------------------------------------------
2270							;
2271							; Clear a block of text screen memory.
2272							;
2273							; entry:
2274							;
2275							; (ZMEMT),y - first byte to clear
2276							;
2277							; X = number of pages (including first, possibly partial page) to clear
2278							;
2279	.cb84						clearTextMemory:
2280							                ; align memory so that Y=0 on each page boundary
2281							                ; crossing.
2282							                ;
2283							                ; e.g., on entry ZMEMT=$30f8, Y=$08 - then after,
2284							                ; ZMEMT=$3000, Y=$F7; or, ZMEMT=$30f0, Y=$08 -> ZMEMT=$2ff8, Y=$F7.
2285	.cb84		98		tya		                tya                          ;A=initial offset
2286	.cb85		18		clc		                clc
2287	.cb86		65 d8		adc $d8		                adc ZMEMT+0                  ;add to dest address
2288	.cb88		85 d8		sta $d8		                sta ZMEMT+0
2289	.cb8a		b0 02		bcs $cb8e	                bcs +
2290	.cb8c		c6 d9		dec $d9		                dec ZMEMT+1
2291	.cb8e						+
2292	.cb8e		98		tya		                tya
2293	.cb8f		49 ff		eor #$ff	                eor #$FF
2294	.cb91		a8		tay		                tay
2295	.cb92		4a		lsr a		                lsr a                        ;C set if odd
2296	.cb93		ad 58 03	lda $0358	                lda vduv.backgroundTextColour
2297	.cb96		b0 07		bcs $cb9f	                bcs nextByte                    ;taken if odd - slightly different loop
2298	.cb98		80 02		bra $cb9c	                bra clearTextMemoryByte

2300	.cb9a						clearTextMemoryLoop:
2301	.cb9a		91 d8		sta ($d8),y	                sta (ZMEMT),y
2302	.cb9c						clearTextMemoryByte:
2303	.cb9c		c8		iny		                iny
2304	.cb9d		91 d8		sta ($d8),y	                sta (ZMEMT),y
2305	.cb9f						nextByte:
2306	.cb9f		c8		iny		                iny
2307	.cba0		d0 f8		bne $cb9a	                bne clearTextMemoryLoop
2308	.cba2		e6 d9		inc $d9		                inc ZMEMT+1
2309	.cba4		ca		dex		                dex
2310	.cba5		10 f3		bpl $cb9a	                bpl clearTextMemoryLoop
2311	.cba7		60		rts		                rts

2313							;-------------------------------------------------------------------------

2315	.cba8						LCBA8:
2316	.cba8		38		sec		                sec
2317	.cba9		98		tya		                tya
2318	.cbaa		ed 2a 03	sbc $032a	                sbc $032A
2319	.cbad		a8		tay		                tay
2320	.cbae		b0 04		bcs $cbb4	                bcs LCBB4
2321	.cbb0		ca		dex		                dex
2322	.cbb1		30 33		bmi $cbe6	                bmi LCBE6
2323	.cbb3		38		sec		                sec
2324	.cbb4						LCBB4:
2325	.cbb4		08		php		                php
2326	.cbb5		98		tya		                tya
2327	.cbb6		18		clc		                clc
2328	.cbb7		65 da		adc $da		                adc ZTEMP+0
2329	.cbb9		85 da		sta $da		                sta ZTEMP+0
2330	.cbbb		b0 02		bcs $cbbf	                bcs LCBBF
2331	.cbbd		c6 db		dec $db		                dec ZTEMP+1
2332	.cbbf						LCBBF:
2333	.cbbf		98		tya		                tya
2334	.cbc0		18		clc		                clc
2335	.cbc1		65 d8		adc $d8		                adc ZMEMT+0
2336	.cbc3		85 d8		sta $d8		                sta ZMEMT+0
2337	.cbc5		b0 02		bcs $cbc9	                bcs LCBC9
2338	.cbc7		c6 d9		dec $d9		                dec ZMEMT+1
2339	.cbc9						LCBC9:
2340	.cbc9		98		tya		                tya
2341	.cbca		49 ff		eor #$ff	                eor #$FF
2342	.cbcc		a8		tay		                tay
2343	.cbcd		4a		lsr a		                lsr a
2344	.cbce		b0 0b		bcs $cbdb	                bcs LCBDB
2345	.cbd0		80 04		bra $cbd6	                bra LCBD6

2347	.cbd2						LCBD2:
2348	.cbd2		b1 da		lda ($da),y	                lda ($DA),y
2349	.cbd4		91 d8		sta ($d8),y	                sta (ZMEMT),y
2350	.cbd6						LCBD6:
2351	.cbd6		c8		iny		                iny
2352	.cbd7		b1 da		lda ($da),y	                lda ($DA),y
2353	.cbd9		91 d8		sta ($d8),y	                sta (ZMEMT),y
2354	.cbdb						LCBDB:
2355	.cbdb		c8		iny		                iny
2356	.cbdc		d0 f4		bne $cbd2	                bne LCBD2
2357	.cbde		e6 db		inc $db		                inc $DB
2358	.cbe0		e6 d9		inc $d9		                inc ZMEMT+1
2359	.cbe2		ca		dex		                dex
2360	.cbe3		10 ed		bpl $cbd2	                bpl LCBD2
2361	.cbe5						LCBE5:
2362	.cbe5		28		plp		                plp
2363	.cbe6						LCBE6:
2364	.cbe6		60		rts		                rts

2366	.cbe7						LCBE7:
2367	.cbe7		38		sec		                sec
2368	.cbe8		98		tya		                tya
2369	.cbe9		ed 2a 03	sbc $032a	                sbc $032A
2370	.cbec		a8		tay		                tay
2371	.cbed		b0 04		bcs $cbf3	                bcs LCBF3
2372	.cbef		ca		dex		                dex
2373	.cbf0		30 f4		bmi $cbe6	                bmi LCBE6
2374	.cbf2		38		sec		                sec
2375	.cbf3						LCBF3:
2376	.cbf3		08		php		                php
2377	.cbf4		98		tya		                tya
2378	.cbf5		49 ff		eor #$ff	                eor #$FF
2379	.cbf7		48		pha		                pha
2380	.cbf8		38		sec		                sec
2381	.cbf9		65 da		adc $da		                adc $DA
2382	.cbfb		85 da		sta $da		                sta $DA
2383	.cbfd		b0 02		bcs $cc01	                bcs LCC01
2384	.cbff		c6 db		dec $db		                dec $DB
2385	.cc01						LCC01:
2386	.cc01		68		pla		                pla
2387	.cc02		38		sec		                sec
2388	.cc03		65 d8		adc $d8		                adc ZMEMT+0
2389	.cc05		85 d8		sta $d8		                sta ZMEMT+0
2390	.cc07		b0 02		bcs $cc0b	                bcs LCC0B
2391	.cc09		c6 d9		dec $d9		                dec ZMEMT+1
2392	.cc0b						LCC0B:
2393	.cc0b		98		tya		                tya
2394	.cc0c		4a		lsr a		                lsr a
2395	.cc0d		b0 14		bcs $cc23	                bcs LCC23
2396	.cc0f		d0 0d		bne $cc1e	                bne LCC1E
2397	.cc11						LCC11:
2398	.cc11		ca		dex		                dex
2399	.cc12		30 d1		bmi $cbe5	                bmi LCBE5
2400	.cc14		c6 db		dec $db		                dec $DB
2401	.cc16		c6 d9		dec $d9		                dec ZMEMT+1
2402	.cc18		80 04		bra $cc1e	                bra LCC1E

2404	.cc1a						LCC1A:
2405	.cc1a		b1 da		lda ($da),y	                lda ($DA),y
2406	.cc1c		91 d8		sta ($d8),y	                sta (ZMEMT),y
2407	.cc1e						LCC1E:
2408	.cc1e		88		dey		                dey
2409	.cc1f		b1 da		lda ($da),y	                lda ($DA),y
2410	.cc21		91 d8		sta ($d8),y	                sta (ZMEMT),y
2411	.cc23						LCC23:
2412	.cc23		88		dey		                dey
2413	.cc24		d0 f4		bne $cc1a	                bne LCC1A
2414	.cc26		b2 da		lda ($da)	                lda ($DA)
2415	.cc28		92 d8		sta ($d8)	                sta (ZMEMT)
2416	.cc2a		80 e5		bra $cc11	                bra LCC11

2418							;-------------------------------------------------------------------------
2419							;
2420							; Get pointers for a text window row.
2421							;
2422							; entry:
2423							;
2424							; vduv.workspace._28; = text window stride, in bytes
2425							;
2426							; >A, <X = address
2427							;
2428							; exit:
2429							;
2430							; V=0: >A, <X = new address
2431							;
2432							; V=1: (ZTEMPC) =

2434	.cc2c						LCC2C:
2435	.cc2c		48		pha		                pha                          ;save >address
2436	.cc2d		8a		txa		                txa                          ;A=<address
2437	.cc2e		18		clc		                clc
2438	.cc2f		6d 28 03	adc $0328	                adc vduv.workspace._28       ;A=<(new address)
2439	.cc32		aa		tax		                tax                          ;X=<(new address)
2440	.cc33		68		pla		                pla                          ;restore >addcess
2441	.cc34		6d 29 03	adc $0329	                adc vduv.workspace._29       ;A=>(new address)
2442	.cc37		50 1d		bvc $cc56	                bvc rtsCC56                  ;taken if no address wrap
2443	.cc39		86 e0		stx $e0		                stx ZTEMPD+0
2444	.cc3b		29 7f		and #$7f	                and #$7F                     ;
2445	.cc3d		85 e1		sta $e1		                sta ZTEMPD+1
2446	.cc3f		05 e0		ora $e0		                ora ZTEMPD+0
2447	.cc41		f0 12		beq $cc55	                beq clv_rts
2448	.cc43		08		php		                php
2449	.cc44		38		sec		                sec
2450	.cc45		ad 28 03	lda $0328	                lda vduv.workspace._28
2451	.cc48		e5 e0		sbc $e0		                sbc ZTEMPD+0
2452	.cc4a		85 de		sta $de		                sta ZTEMPC+0
2453	.cc4c		ad 29 03	lda $0329	                lda vduv.workspace._29
2454	.cc4f		e5 e1		sbc $e1		                sbc ZTEMPD+1
2455	.cc51		85 df		sta $df		                sta ZTEMPC+1
2456	.cc53		28		plp		                plp
2457	.cc54		60		rts		                rts

2459							;-------------------------------------------------------------------------

2461	.cc55						clv_rts:
2462	.cc55		b8		clv		                clv
2463	.cc56						rtsCC56:
2464	.cc56		60		rts		                rts

2466	.cc57						LCC57:
2467	.cc57		ad 53 03	lda $0353	                lda vduv.bytesPerCharacterRow+1
2468	.cc5a		ae 52 03	ldx $0352	                ldx vduv.bytesPerCharacterRow+0
2469	.cc5d						LCC5D:
2470	.cc5d		18		clc		                clc
2471	.cc5e						LCC5E:
2472	.cc5e		08		php		                php
2473	.cc5f		48		pha		                pha
2474	.cc60		8a		txa		                txa
2475	.cc61		65 d8		adc $d8		                adc ZMEMT+0
2476	.cc63		aa		tax		                tax
2477	.cc64		68		pla		                pla
2478	.cc65		65 d9		adc $d9		                adc ZMEMT+1
2479	.cc67		10 04		bpl $cc6d	                bpl +
2480	.cc69		38		sec		                sec
2481	.cc6a		ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte ;handle wraparound at end
2482	.cc6d						+
2483	.cc6d		cd 4e 03	cmp $034e	                cmp vduv.startScreenAddressHighByte
2484	.cc70		b0 03		bcs $cc75	                bcs +
2485	.cc72		6d 54 03	adc $0354	                adc vduv.screenSizeHighByte ;handle wraparound at start
2486	.cc75						+
2487	.cc75		28		plp		                plp
2488	.cc76		60		rts		                rts

2490	.cc77						LCC77:
2491	.cc77		ad 53 03	lda $0353	                lda $0353
2492	.cc7a		ae 52 03	ldx $0352	                ldx $0352
2493	.cc7d						LCC7D:
2494	.cc7d		48		pha		                pha
2495	.cc7e		8a		txa		                txa
2496	.cc7f		49 ff		eor #$ff	                eor #$FF
2497	.cc81		aa		tax		                tax
2498	.cc82		68		pla		                pla
2499	.cc83		49 ff		eor #$ff	                eor #$FF
2500	.cc85		38		sec		                sec
2501	.cc86		80 d6		bra $cc5e	                bra LCC5E

2503	.cc88						LCC88:
2504	.cc88		cd 4e 03	cmp $034e	                cmp $034E
2505	.cc8b		d0 06		bne $cc93	                bne LCC93
2506	.cc8d		e0 00		cpx #$00	                cpx #$00
2507	.cc8f		d0 02		bne $cc93	                bne LCC93
2508	.cc91		a9 80		lda #$80	                lda #$80
2509	.cc93						LCC93:
2510	.cc93		60		rts		                rts

2512	.cc94						LCC94:
2513	.cc94		20 c9 ca	jsr $cac9	                jsr LCAC9
2514	.cc97						LCC97:
2515	.cc97		a6 dc		ldx $dc		                ldx $DC
2516	.cc99		86 d8		stx $d8		                stx ZMEMT+0
2517	.cc9b		a5 dd		lda $dd		                lda $DD
2518	.cc9d		85 d9		sta $d9		                sta ZMEMT+1
2519	.cc9f		60		rts		                rts

2521	.cca0						LCCA0:
2522	.cca0		38		sec		                sec
2523	.cca1		ad 2d 03	lda $032d	                lda $032D
2524	.cca4		ed 2f 03	sbc $032f	                sbc $032F
2525	.cca7		8d 2b 03	sta $032b	                sta $032B
2526	.ccaa		ae 2c 03	ldx $032c	                ldx $032C
2527	.ccad		ac 2f 03	ldy $032f	                ldy $032F

2529							;-------------------------------------------------------------------------
2530							;
2531							; Get display address for a text position.
2532							;
2533	.ccb0						getAddressForTextPosition:
2534	.ccb0		ad 18 03	lda $0318	                lda vduv.textCursorXPosition
2535	.ccb3		48		pha		                pha
2536	.ccb4		ad 19 03	lda $0319	                lda vduv.textCursorYPosition
2537	.ccb7		48		pha		                pha
2538	.ccb8		8e 18 03	stx $0318	                stx vduv.textCursorXPosition
2539	.ccbb		8c 19 03	sty $0319	                sty vduv.textCursorYPosition
2540	.ccbe		20 fa cc	jsr $ccfa	                jsr updateZMEMTWithTextCursorPosition
2541	.ccc1		7a		ply		                ply
2542	.ccc2		8c 19 03	sty $0319	                sty vduv.textCursorYPosition
2543	.ccc5		7a		ply		                ply
2544	.ccc6		8c 18 03	sty $0318	                sty vduv.textCursorXPosition
2545	.ccc9		60		rts		                rts

2547							;-------------------------------------------------------------------------

2549	.ccca						LCCCA:
2550	.ccca		f0 03		beq $cccf	                beq LCCCF
2551	.cccc		ca		dex		                dex
2552	.cccd		86 dc		stx $dc		                stx ZTEMPB+0
2553	.cccf						LCCCF:
2554	.cccf		ad 66 03	lda $0366	                lda vduv.cursorFlags
2555	.ccd2		29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
2556	.ccd4		aa		tax		                tax
2557	.ccd5		a5 dc		lda $dc		                lda ZTEMPB+0
2558	.ccd7						LCCD7:
2559	.ccd7		20 c6 c2	jsr $c2c6	                jsr setTextCursorXPositionWithCursorFlags
2560	.ccda						LCCDA:
2561	.ccda		ae 18 03	ldx $0318	                ldx vduv.textCursorXPosition
2562	.ccdd		ec 08 03	cpx $0308	                cpx vduv.textWindowLeft
2563	.cce0		30 16		bmi $ccf8	                bmi LCCF8            ;taken if off left edge of window
2564	.cce2		ec 0a 03	cpx $030a	                cpx vduv.textWindowRight
2565	.cce5		f0 02		beq $cce9	                beq LCCE9            ;taken if at right edge of window
2566	.cce7		10 0f		bpl $ccf8	                bpl LCCF8            ;taken if off right edge of window
2567	.cce9						LCCE9:
2568	.cce9		ae 19 03	ldx $0319	                ldx vduv.textCursorYPosition
2569	.ccec		ec 0b 03	cpx $030b	                cpx vduv.textWindowTop
2570	.ccef		30 07		bmi $ccf8	                bmi LCCF8
2571	.ccf1		ec 09 03	cpx $0309	                cpx vduv.textWindowBottom
2572	.ccf4		30 04		bmi $ccfa	                bmi updateZMEMTWithTextCursorPosition
2573	.ccf6		f0 02		beq $ccfa	                beq updateZMEMTWithTextCursorPosition
2574	.ccf8						LCCF8:
2575	.ccf8		38		sec		                sec
2576	.ccf9		60		rts		                rts

2578							;-------------------------------------------------------------------------
2579							;
2580							; Get display address for current text cursor position.
2581							;
2582							; Set up display address without using BBC lookup table at &E0/1
2583							;
2584	.ccfa						updateZMEMTWithTextCursorPosition:
2585	.ccfa		ad 56 03	lda $0356	                lda vduv.currentScreenMODEGroup
2586	.ccfd		29 fe		and #$fe	                and #$fe                     ; Reduce to 0,0,2,2,4
2587	.ccff		aa		tax		                tax                          ; Index into jump table
2588	.cd00		ac 19 03	ldy $0319	                ldy vduv.textCursorYPosition  ; Get current line
2589	.cd03		7c 06 cd	jmp ($cd06,x)	                jmp (multiplyRoutinesTable,x) ; Jump to calculation setup

2591	.cd06						multiplyRoutinesTable:
2592	>cd06		21 cd				                .word multiplyBy640     ; Memory map 0,1  MODE 0,1,2,3
2593	>cd08		15 cd				                .word multiplyBy320       ; Memory map 2,3  MODE 4,5,6
2594	>cd0a		0c cd				                .word multiplyBy40        ; Memory map 4    MODE 7

2596	.cd0c						multiplyBy40:
2597	.cd0c		be ad e0	ldx $e0ad,y	                ldx multiplyBy40TableHigh,y ; Get offset high byte for start of this line
2598	.cd0f		b9 c6 e0	lda $e0c6,y	                lda multiplyBy40TableLow,y ; Get offset low byte for start of this line
2599	.cd12		18		clc		                clc
2600	.cd13		80 14		bra $cd29	                bra LCD29

2602	.cd15						multiplyBy320:
2603	.cd15		b9 df e0	lda $e0df,y	                lda multiplyBy640TableHigh,y
2604	.cd18		4a		lsr a		                lsr a
2605	.cd19		aa		tax		                tax
2606	.cd1a		98		tya		                tya
2607	.cd1b		29 03		and #$03	                and #$03
2608	.cd1d		4a		lsr a		                lsr a
2609	.cd1e		6a		ror a		                ror a
2610	.cd1f		80 07		bra $cd28	                bra LCD28

2612	.cd21						multiplyBy640:
2613	.cd21		be df e0	ldx $e0df,y	                ldx multiplyBy640TableHigh,y
2614	.cd24		98		tya		                tya
2615	.cd25		29 01		and #$01	                and #$01
2616	.cd27		4a		lsr a		                lsr a
2617	.cd28						LCD28:
2618	.cd28		6a		ror a		                ror a                        ; A=A/2 +(128*carry)

2620	.cd29						LCD29:
2621	.cd29		6d 50 03	adc $0350	                adc vduv.screenTopLeftAddress+0
2622	.cd2c		85 d8		sta $d8		                sta ZMEMT+0                      ; store it
2623	.cd2e		8a		txa		                txa
2624	.cd2f		6d 51 03	adc $0351	                adc vduv.screenTopLeftAddress+1 ; window start address hi
2625	.cd32		a8		tay		                tay
2626	.cd33		ad 18 03	lda $0318	                lda vduv.textCursorXPosition  ; text column
2627	.cd36		ae 4f 03	ldx $034f	                ldx vduv.bytesPerCharacter    ; bytes per character
2628	.cd39		ca		dex		                dex
2629	.cd3a		f0 12		beq $cd4e	                beq LCD4E                    ; 1 colour, MODE 7
2630	.cd3c		e0 0f		cpx #$0f	                cpx #$0F
2631	.cd3e		f0 03		beq $cd43	                beq LCD43                    ; 4 colours, MODE 1 or MODE 5
2632	.cd40		90 02		bcc $cd44	                bcc LCD44                    ; 2 colours, MODE 0,3,4,6
2633	.cd42		0a		asl a		                asl a                        ; 16 colours, MODE 2
2634	.cd43						LCD43:
2635	.cd43		0a		asl a		                asl a
2636	.cd44						LCD44:
2637	.cd44		0a		asl a		                asl a
2638	.cd45		0a		asl a		                asl a
2639	.cd46		90 02		bcc $cd4a	                bcc LCD4A
2640	.cd48		c8		iny		                iny
2641	.cd49		c8		iny		                iny
2642	.cd4a						LCD4A:
2643	.cd4a		0a		asl a		                asl a
2644	.cd4b		90 02		bcc $cd4f	                bcc LCD4F
2645	.cd4d		c8		iny		                iny
2646	.cd4e						LCD4E:
2647	.cd4e		18		clc		                clc
2648	.cd4f						LCD4F:
2649	.cd4f		65 d8		adc $d8		                adc ZMEMT+0
2650	.cd51		85 d8		sta $d8		                sta ZMEMT+0
2651	.cd53		8d 4a 03	sta $034a	                sta vduv.textCursorCRTCAddress+0
2652	.cd56		aa		tax		                tax
2653	.cd57		98		tya		                tya
2654	.cd58		69 00		adc #$00	                adc #$00
2655	.cd5a		8d 4b 03	sta $034b	                sta vduv.textCursorCRTCAddress+1
2656	.cd5d		10 04		bpl $cd63	                bpl LCD63
2657	.cd5f		38		sec		                sec
2658	.cd60		ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte
2659	.cd63						LCD63:
2660	.cd63		85 d9		sta $d9		                sta ZMEMT+1
2661	.cd65		18		clc		                clc
2662	.cd66		60		rts		                rts

2664							;-------------------------------------------------------------------------

2666	.cd67						nextMaskedCharColumn
2667	.cd67		ee 24 03	inc $0324	                inc vduv.graphicsCursorPixelsX+0
2668	.cd6a		d0 03		bne $cd6f	                bne +
2669	.cd6c		ee 25 03	inc $0325	                inc vduv.graphicsCursorPixelsX+1
2670	.cd6f						+
2671	.cd6f		0a		asl a		                asl a
2672	.cd70						plotMaskedCharRow:
2673							                ; find next pixel to plot, updating graphics cursor X
2674							                ; as it goes. A is non-zero, so this loop will finish
2675							                ; eventually.
2676	.cd70		10 f5		bpl $cd67	                bpl nextMaskedCharColumn
2677	.cd72		5a		phy		                phy
2678	.cd73		85 dd		sta $dd		                sta ZTEMPB+1                 ;
2679	.cd75		a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixels
2680	.cd77		20 c8 de	jsr $dec8	                jsr gaddrEntryPoint
2681	.cd7a		80 02		bra $cd7e	                bra plotMaskedCharPixel

2683	.cd7c						plotMaskedCharPixelsLoop:
2684	.cd7c		10 03		bpl $cd81	                bpl nextMaskedCharPixel
2685	.cd7e						plotMaskedCharPixel:
2686	.cd7e		20 50 db	jsr $db50	                jsr plbyteEntryPoint
2687	.cd81						nextMaskedCharPixel
2688	.cd81		46 d1		lsr $d1		                lsr ZMASK
2689	.cd83		90 03		bcc $cd88	                bcc +
2690	.cd85		20 66 da	jsr $da66	                jsr nextColumnAndResetMask
2691	.cd88						+
2692	.cd88		06 dd		asl $dd		                asl ZTEMPB+1
2693	.cd8a		d0 f0		bne $cd7c	                bne plotMaskedCharPixelsLoop
2694	.cd8c		a2 28		ldx #$28	                ldx #VDUVariables.workspace._28
2695	.cd8e		a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixelsX
2696	.cd90		20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
2697	.cd93		7a		ply		                ply
2698	.cd94		80 50		bra $cde6	                bra nextMaskedCharY

2700	.cd96						plotCharAtGraphicsCursor:
2701	.cd96		20 2a e2	jsr $e22a	                jsr getSoftCharacterDefinitionAddress
2702	.cd99		9c 59 03	stz $0359	                stz vduv.graphicsPlotState   ;plot in foreground colour
2703	.cd9c		ad 5b 03	lda $035b	                lda vduv.foregroundGCOLMode
2704	.cd9f		29 0f		and #$0f	                and #$0F
2705	.cda1						plotFontDataAtGraphicsCursorWithPlotMode:
2706	.cda1		8d 5a 03	sta $035a	                sta vduv.graphicsPlotMode
2707	.cda4		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
2708	.cda6		20 1c c9	jsr $c91c	                jsr copyGraphicsCursorPixels
2709	.cda9		a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixelsX
2710	.cdab		a2 00		ldx #$00	                ldx #VDUVariables.graphicsWindowPixelsLeft
2711	.cdad		20 b3 ce	jsr $ceb3	                jsr getDistanceMask
2712	.cdb0		85 dc		sta $dc		                sta ZTEMPB+0
2713	.cdb2		a2 04		ldx #$04	                ldx #VDUVariables.graphicsWindowPixelsRight
2714	.cdb4		20 b3 ce	jsr $ceb3	                jsr getDistanceMask
2715	.cdb7		6a		ror a		                ror a
2716	.cdb8		14 dc		trb $dc		                trb ZTEMPB+0
2717	.cdba		a2 26		ldx #$26	                ldx #VDUVariables.graphicsCursorPixelsY
2718	.cdbc		a0 06		ldy #$06	                ldy #VDUVariables.graphicsWindowPixelsTop
2719	.cdbe		20 b3 ce	jsr $ceb3	                jsr getDistanceMask
2720	.cdc1		85 dd		sta $dd		                sta ZTEMPB+1
2721	.cdc3		a2 26		ldx #$26	                ldx #VDUVariables.graphicsCursorPixelsY
2722	.cdc5		a0 02		ldy #$02	                ldy #VDUVariables.graphicsWindowPixelsBottom
2723	.cdc7		20 b3 ce	jsr $ceb3	                jsr getDistanceMask
2724	.cdca		6a		ror a		                ror a
2725	.cdcb		14 dd		trb $dd		                trb ZTEMPB+1
2726	.cdcd		a0 07		ldy #$07	                ldy #$07
2727	.cdcf						copyMaskedCharLoop:
2728	.cdcf		b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte
2729	.cdd1		25 dc		and $dc		                and ZTEMPB+0                 ;mask out columns
2730	.cdd3		46 dd		lsr $dd		                lsr ZTEMPB+1                 ;test row
2731	.cdd5		b0 02		bcs $cdd9	                bcs +
2732	.cdd7		a9 00		lda #$00	                lda #$00                     ;mask out this row
2733	.cdd9						+
2734	.cdd9		99 2c 03	sta $032c,y	                sta vduv.workspace._2C,y
2735	.cddc		88		dey		                dey
2736	.cddd		10 f0		bpl $cdcf	                bpl copyMaskedCharLoop
2737	.cddf		a0 f8		ldy #$f8	                ldy #$F8
2738	.cde1						plotMaskedCharLoop:
2739	.cde1		b9 34 02	lda $0234,y	                lda vduv.workspace._2C-$f8,y ;get masked byte
2740	.cde4		d0 8a		bne $cd70	                bne plotMaskedCharRow        ;taken if data to write
2741	.cde6						nextMaskedCharY:
2742	.cde6		ae 26 03	ldx $0326	                ldx vduv.graphicsCursorPixelsY+0
2743	.cde9		d0 03		bne $cdee	                bne +
2744	.cdeb		ce 27 03	dec $0327	                dec vduv.graphicsCursorPixelsY+1
2745	.cdee						+
2746	.cdee		ce 26 03	dec $0326	                dec vduv.graphicsCursorPixelsY+0
2747	.cdf1		c8		iny		                iny
2748	.cdf2		d0 ed		bne $cde1	                bne plotMaskedCharLoop
2749	.cdf4		a2 2a		ldx #$2a	                ldx #VDUVariables.workspace._2A
2750	.cdf6		a0 26		ldy #$26	                ldy #VDUVariables.graphicsCursorPixelsY
2751	.cdf8		4c 0c c9	jmp $c90c	                jmp copyTwoBytesWithinVDUVariables

2753	.cdfb						vdu127AtGraphicsCursor:
2754							                ; CHR$127 is a solid block, not a backspace.
2755	.cdfb		a9 f8		lda #$f8	                lda #<chr127
2756	.cdfd		85 de		sta $de		                sta ZTEMPC+0
2757	.cdff		a9 bb		lda #$bb	                lda #>chr127
2758	.ce01		85 df		sta $df		                sta ZTEMPC+1
2759	.ce03		a2 08		ldx #$08	                ldx #$08
2760	.ce05		8e 59 03	stx $0359	                stx vduv.graphicsPlotState   ;plot in background colour
2761	.ce08		a9 00		lda #$00	                lda #$00
2762	.ce0a		80 95		bra $cda1	                bra plotFontDataAtGraphicsCursorWithPlotMode

2764	.ce0c						LCE0C:
2765	.ce0c		20 2c d1	jsr $d12c	                jsr handleColumn81
2766	.ce0f		b0 85		bcs $cd96	                bcs plotCharAtGraphicsCursor          ;taken if VDU5
2767	.ce11		ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
2768	.ce14		f0 37		beq $ce4d	                beq writeTeletextChar
2769	.ce16		20 2a e2	jsr $e22a	                jsr getSoftCharacterDefinitionAddress
2770	.ce19						writeBitmapChar:
2771	.ce19		a0 07		ldy #$07	                ldy #$07
2772	.ce1b		e0 03		cpx #$03	                cpx #$03
2773	.ce1d		f0 34		beq $ce53	                beq write2bppChar            ;taken if MODE 1/5
2774	.ce1f		b0 5a		bcs $ce7b	                bcs write4bppChar                    ;taken if MODE 2
2775	.ce21						write1bppChar:
2776	.ce21		b1 de		lda ($de),y	                lda (ZTEMPC),y
2777	.ce23		05 d2		ora $d2		                ora ZORA
2778	.ce25		45 d3		eor $d3		                eor ZEOR
2779	.ce27		91 d8		sta ($d8),y	                sta (ZMEMT),y
2780	.ce29		88		dey		                dey
2781	.ce2a		10 f5		bpl $ce21	                bpl write1bppChar
2782	.ce2c		60		rts		                rts

2784	.ce2d						vdu127EntryPoint:
2785	.ce2d		a9 20		lda #$20	                lda #$20
2786	.ce2f		2c 66 03	bit $0366	                bit $0366
2787	.ce32		d0 03		bne $ce37	                bne LCE37
2788	.ce34		20 99 c2	jsr $c299	                jsr vdu8EntryPoint
2789	.ce37						LCE37:
2790	.ce37		20 d0 e2	jsr $e2d0	                jsr testVDU5State
2791	.ce3a		d0 bf		bne $cdfb	                bne vdu127AtGraphicsCursor
2792	.ce3c		ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
2793	.ce3f		f0 0a		beq $ce4b	                beq writeTeletextSpaceChar   ;taken if teletext mode

2795							                ; Address of space char is known.
2796	.ce41		a9 00		lda #$00	                lda #<LB900
2797	.ce43		85 de		sta $de		                sta ZTEMPC+0
2798	.ce45		a9 b9		lda #$b9	                lda #>LB900
2799	.ce47		85 df		sta $df		                sta ZTEMPC+1
2800	.ce49		80 ce		bra $ce19	                bra writeBitmapChar

2802	.ce4b						writeTeletextSpaceChar:
2803	.ce4b		a9 20		lda #$20	                lda #$20
2804	.ce4d						writeTeletextChar:
2805	.ce4d		20 e4 dd	jsr $dde4	                jsr getSAA5050FromASCII
2806	.ce50		92 d8		sta ($d8)	                sta (ZMEMT)
2807	.ce52		60		rts		                rts

2809	.ce53						write2bppChar:
2810	.ce53		a5 d9		lda $d9		                lda ZMEMT+1
2811	.ce55		a6 d8		ldx $d8		                ldx ZMEMT+0
2812	.ce57		20 e6 ce	jsr $cee6	                jsr getNextColumnAddress
2813	.ce5a						-
2814	.ce5a		b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte
2815	.ce5c		29 0f		and #$0f	                and #$0F                     ;get data for right 4 pixels
2816	.ce5e		aa		tax		                tax
2817	.ce5f		bd 11 e0	lda $e011,x	                lda LE013,x                  ;form byte
2818	.ce62		05 d2		ora $d2		                ora ZORA
2819	.ce64		45 d3		eor $d3		                eor ZEOR
2820	.ce66		91 e0		sta ($e0),y	                sta (ZTEMPD),y               ;write to right column
2821	.ce68		b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte
2822							                .if version==350
2823	.ce6a		20 20 e5	jsr $e520	                jsr LE520
2829							                .endif
2830	.ce6d		aa		tax		                tax                          ;
2831	.ce6e		bd 11 e0	lda $e011,x	                lda LE013,x                  ;form byte
2832	.ce71		05 d2		ora $d2		                ora ZORA
2833	.ce73		45 d3		eor $d3		                eor ZEOR
2834	.ce75		91 d8		sta ($d8),y	                sta (ZMEMT),y                ;write to left column
2835	.ce77		88		dey		                dey
2836	.ce78		10 e0		bpl $ce5a	                bpl -
2837	.ce7a		60		rts		                rts

2839	.ce7b						write4bppChar:
2840	.ce7b		a5 d9		lda $d9		                lda ZMEMT+1
2841	.ce7d		a6 d8		ldx $d8		                ldx ZMEMT+0
2842	.ce7f		20 d8 ce	jsr $ced8	                jsr getNext3ColumnAddresses
2843	.ce82						-
2844	.ce82		b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte - %abcdefgh
2845	.ce84		20 a8 ce	jsr $cea8	                jsr get4bppScreenByteFor2Pixels ;pixels g and h
2846	.ce87		91 e0		sta ($e0),y	                sta ($E0),y
2847	.ce89		b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte - %abcdefgh
2848	.ce8b		4a		lsr a		                lsr a                        ;%0abcdefg
2849	.ce8c		4a		lsr a		                lsr a                        ;%00abcdef
2850	.ce8d		48		pha		                pha                          ;save %00abcdef
2851	.ce8e		20 a8 ce	jsr $cea8	                jsr get4bppScreenByteFor2Pixels ;pixels e and f
2852	.ce91		91 dc		sta ($dc),y	                sta (ZTEMPB),y
2853	.ce93		68		pla		                pla                          ;restore %00abcdef
2854	.ce94		4a		lsr a		                lsr a                        ;%000abcde
2855	.ce95		4a		lsr a		                lsr a                        ;%0000abcd
2856	.ce96		48		pha		                pha                          ;save %0000abcd
2857	.ce97		20 a8 ce	jsr $cea8	                jsr get4bppScreenByteFor2Pixels ;pixels c and d
2858	.ce9a		91 da		sta ($da),y	                sta (ZTEMP),y
2859	.ce9c		68		pla		                pla                          ;restore %0000abcd
2860	.ce9d		4a		lsr a		                lsr a                        ;%00000abc
2861	.ce9e		4a		lsr a		                lsr a                        ;%000000ab
2862	.ce9f		20 a8 ce	jsr $cea8	                jsr get4bppScreenByteFor2Pixels ;pixels a and b
2863	.cea2		91 d8		sta ($d8),y	                sta (ZMEMT),y
2864	.cea4		88		dey		                dey
2865	.cea5		10 db		bpl $ce82	                bpl -
2866	.cea7		60		rts		                rts

2868	.cea8						get4bppScreenByteFor2Pixels:
2869	.cea8		29 03		and #$03	                and #$03                     ;mask out 2 pixels
2870	.ceaa		aa		tax		                tax
2871	.ceab		bd 21 e0	lda $e021,x	                lda LE023,x                  ;form byte
2872	.ceae		05 d2		ora $d2		                ora ZORA
2873	.ceb0		45 d3		eor $d3		                eor ZEOR
2874	.ceb2		60		rts		                rts

2876							;-------------------------------------------------------------------------
2877							;
2878							; Get mask indicating the distance between two 16-bit VDU variable
2879							; values - >=8, or some amount less than that.
2880							;
2881							; (These can be used for masking pixels, or counting loops, or
2882							; whatever.)
2883							;
2884							; entry:
2885							;
2886							; X = offset of value A in VDU variables
2887							;
2888							; Y = offset of value B in VDU variables
2889							;
2890							; exit:
2891							;
2892							; if distance<=0, A=255, C=1
2893							;
2894							; if distance>=8, A=0, C=0
2895							;
2896							; otherwise, A=255>>distance, C=0
2897							;
2898	.ceb3						getDistanceMask:
2899	.ceb3		38		sec		                sec
2900	.ceb4		bd 00 03	lda $0300,x	                lda vduv+0,x
2901	.ceb7		f9 00 03	sbc $0300,y	                sbc vduv+0,y
2902	.ceba		85 da		sta $da		                sta ZTEMP                    ;get result LSB
2903	.cebc		bd 01 03	lda $0301,x	                lda vduv+1,x
2904	.cebf		f9 01 03	sbc $0301,y	                sbc vduv+1,y
2905	.cec2		30 0c		bmi $ced0	                bmi distanceMask255                  ;taken if result -ve
2906	.cec4		d0 0e		bne $ced4	                bne distanceMask0                  ;taken if result >=256
2907	.cec6		a6 da		ldx $da		                ldx ZTEMP
2908	.cec8		e0 08		cpx #$08	                cpx #$08
2909	.ceca		b0 08		bcs $ced4	                bcs distanceMask0                    ;taken if result>=8
2910	.cecc		bd 25 e1	lda $e125,x	                lda distanceMasksTable,x             ;get mask for <8 items
2911	.cecf		60		rts		                rts

2913	.ced0						distanceMask255:
2914	.ced0		a9 ff		lda #$ff	                lda #%11111111
2915	.ced2		38		sec		                sec
2916	.ced3		60		rts		                rts

2918	.ced4						distanceMask0:
2919	.ced4		a9 00		lda #$00	                lda #$00
2920	.ced6		18		clc		                clc
2921	.ced7		60		rts		                rts

2923							;-------------------------------------------------------------------------
2924							;
2925							; Get addresses of next 3 columns on screen.
2926							;
2927							; entry:
2928							;
2929							; A (MSB)/X (LSB) = address
2930							;
2931							; exit:
2932							;
2933							; (ZTEMP) = column N+1
2934							; (ZTEMPB) = column N+2
2935							; (ZTEMPC) = column N+3
2936							;
2937	.ced8						getNext3ColumnAddresses:
2938	.ced8		20 e6 ce	jsr $cee6	                jsr getNextColumnAddress
2939	.cedb		86 da		stx $da		                stx ZTEMP+0
2940	.cedd		85 db		sta $db		                sta ZTEMP+1
2941	.cedf		20 e6 ce	jsr $cee6	                jsr getNextColumnAddress
2942	.cee2		86 dc		stx $dc		                stx ZTEMPB+0
2943	.cee4		85 dd		sta $dd		                sta ZTEMPB+1

2945							;-------------------------------------------------------------------------
2946							;
2947							; Get address of next column on screen.
2948							;
2949							; entry:
2950							;
2951							; A (MSB)/X (LSB) = address
2952							;
2953							; exit:
2954							;
2955							; A (MSB)/X (LSB) = address of next column
2956							; (ZTEMPD) = address of next column
2957							;
2958	.cee6						getNextColumnAddress:
2959	.cee6		48		pha		                pha
2960	.cee7		8a		txa		                txa
2961	.cee8		18		clc		                clc
2962	.cee9		69 08		adc #$08	                adc #$08                     ;next column...
2963	.ceeb		aa		tax		                tax
2964	.ceec		68		pla		                pla
2965	.ceed		90 06		bcc $cef5	                bcc +                        ;taken if no carry
2966	.ceef		1a		inc a		                inc a
2967	.cef0		10 03		bpl $cef5	                bpl +           ;taken if no screen address wraparound
2968	.cef2		ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
2969	.cef5						+
2970	.cef5		86 e0		stx $e0		                stx ZTEMPD+0
2971	.cef7		85 e1		sta $e1		                sta ZTEMPD+1
2972	.cef9		60		rts		                rts

2974							;-------------------------------------------------------------------------
2975							;
2976							; VDU 23 0 Control 6845 CRTC directly [MasRef E.3-12]
2977							;
2978	.cefa						vdu23_0_EntryPoint:
2979	.cefa		ad 1d 03	lda $031d	                lda vduv.queueEnd-7           ;get value
2980	.cefd		ac 1c 03	ldy $031c	                ldy vduv.queueEnd-8           ;get register

2982							                ; fall through to setCRTCRegister

2984							;-------------------------------------------------------------------------
2985							;
2986							; Set a CRTC register, adjusting and/or noting values if appropriate.
2987							;
2988							; entry:
2989							;
2990							; Y = register to set
2991							;
2992							; A = value

2994	.cf00						setCRTCRegister:
2995	.cf00		c0 07		cpy #$07	                cpy #$07
2996	.cf02		90 1f		bcc $cf23	                bcc setCRTCRegisterRaw
2997	.cf04		d0 03		bne $cf09	                bne +        ;taken if not setting R7

2999							                ; Setting R7 (vsync position), so apply the *TV offset.
3000	.cf06		6d 90 02	adc $0290	                adc tvOffset
3001	.cf09						+
3002	.cf09		c0 08		cpy #$08	                cpy #$08
3003	.cf0b		d0 07		bne $cf14	                bne +                    ;taken if not setting R8

3005							                ; Setting R8 (interlace/delay register), so apply the
3006							                ; *TV interlace setting.
3007	.cf0d		09 00		ora #$00	                ora #$00
3008	.cf0f		30 03		bmi $cf14	                bmi +       ;branch taken if bit 7 set - this is taken
3009							                            ;to imply the mode being set is Mode 7
3010	.cf11		4d 91 02	eor $0291	                eor tvInterlace ;apply *TV interlace setting
3011	.cf14						+
3012	.cf14		c0 0a		cpy #$0a	                cpy #$0A
3013	.cf16		d0 0b		bne $cf23	                bne setCRTCRegisterRaw

3015							                ; Setting R10 (cursor start register). Note the new
3016							                ; setting in the VDU variable. If in VDU5 mode, reuse
3017							                ; the result of testVDU5State - i.e., 32 - as the
3018							                ; setting, hiding the cursor.
3019	.cf18		8d 5f 03	sta $035f	                sta vduv.lastCursorStartRegisterValue
3020	.cf1b		20 d0 e2	jsr $e2d0	                jsr testVDU5State
3021	.cf1e		d0 09		bne $cf29	                bne rtsCF2A
3022	.cf20		ad 5f 03	lda $035f	                lda vduv.lastCursorStartRegisterValue

3024							                ; fall through to setCRTCRegisterRaw

3026							;-------------------------------------------------------------------------
3027							;
3028							; Set a CRTC register.
3029							;
3030	.cf23						setCRTCRegisterRaw:
3031	.cf23		8c 00 fe	sty $fe00	                sty CRTC+0
3032	.cf26		8d 01 fe	sta $fe01	                sta CRTC+1
3033	.cf29						rtsCF2A:
3034	.cf29		60		rts		                rts

3036							;-------------------------------------------------------------------------
3037							;
3038							; VDU 23 1 Turn cursor on/off [MasRef E.3-12]
3039							;
3040	.cf2a						vdu23_1_EntryPoint:
3041	.cf2a		20 d0 e2	jsr $e2d0	                jsr testVDU5State
3042	.cf2d		d0 fa		bne $cf29	                bne rtsCF2A                  ;taken if VDU5
3043	.cf2f		ad 1c 03	lda $031c	                lda vduv.queueEnd-8           ;get new cursor state
3044	.cf32		29 03		and #$03	                and #$03                     ;mask off bits of interest
3045	.cf34		0a		asl a		                asl a
3046	.cf35		aa		tax		                tax
3047	.cf36		a9 20		lda #$20	                lda #$20 ;R10 value for hiding the cursor - save a few
3048							                         ;bytes by loading this here
3049	.cf38		7c 3b cf	jmp ($cf3b,x)	                jmp (LCF3C,x)

3051	.cf3b						LCF3C:
3052	>cf3b		52 cf				                .word setCRTCRegister10            ; 23,1,0... - hide
3053	>cf3d		4f cf				                .word showCursor            ; 23,1,1... - show
3054	>cf3f		43 cf				                .word steadyCursor          ; 23,1,2... - steady
3055	>cf41		4a cf				                .word slowFlashCursor       ; 23,1,3... - flash slowly

3057	.cf43						steadyCursor:
3058	.cf43		a9 60		lda #$60	                lda #%01100000
3059	.cf45		1c 5f 03	trb $035f	                trb vduv.lastCursorStartRegisterValue ;steady cursor
3060	.cf48		80 05		bra $cf4f	                bra showCursor

3062	.cf4a						slowFlashCursor:
3063	.cf4a		a9 60		lda #$60	                lda #%01100000
3064	.cf4c		0c 5f 03	tsb $035f	                tsb vduv.lastCursorStartRegisterValue ;slow blink cursor
3065	.cf4f						showCursor:
3066	.cf4f		ad 5f 03	lda $035f	                lda vduv.lastCursorStartRegisterValue
3067	.cf52						setCRTCRegister10:
3068	.cf52		a0 0a		ldy #$0a	                ldy #$0A
3069	.cf54		80 cd		bra $cf23	                bra setCRTCRegisterRaw

3071							;-------------------------------------------------------------------------
3072							;
3073							; VDU 23 2-5 Set ECF patterns [MasRef E.3-13]
3074							;
3075	.cf56						vdu23_2_EntryPoint:
3076	.cf56						vdu23_3_EntryPoint:
3077	.cf56						vdu23_4_EntryPoint:
3078	.cf56						vdu23_5_EntryPoint:
3079	.cf56		e9 01		sbc #$01	                sbc #$01  ;subtract 2 (C=0 on entry...) to get pattern
3080							                          ;index
3081	.cf58		0a		asl a		                asl a
3082	.cf59		0a		asl a		                asl a
3083	.cf5a		0a		asl a		                asl a                        ;index*8
3084	.cf5b		69 07		adc #$07	                adc #$07                     ;index*8+7
3085	.cf5d		a8		tay		                tay
3086	.cf5e		a2 07		ldx #$07	                ldx #$07
3087	.cf60						-
3088	.cf60		bd 1c 03	lda $031c,x	                lda vduv.queueEnd-8,x
3089	.cf63		99 00 88	sta $8800,y	                sta andy.ecfPatterns,y
3090	.cf66		88		dey		                dey
3091	.cf67		ca		dex		                dex
3092	.cf68		10 f6		bpl $cf60	                bpl -
3093	.cf6a		80 26		bra $cf92	                bra LCF93

3095							;-------------------------------------------------------------------------

3097	.cf6c						vdu23_11_EntryPoint:
3098	.cf6c		ad 55 03	lda $0355	                lda vduv.currentScreenMODE
3099	.cf6f		d0 01		bne $cf72	                bne +
3100							                ; Use a different table for MODE 0 - see MasRef E.3-16.
3101	.cf71		3a		dec a		                dec a                        ;
3102	.cf72						+
3103	.cf72		29 03		and #$03	                and #$03 ;index=0 (mode 4); 1 (mode 1/5); 2 (mode 2);
3104							                         ;3 (mode 0)
3105	.cf74		1a		inc a		                inc a
3106	.cf75		0a		asl a		                asl a
3107	.cf76		0a		asl a		                asl a
3108	.cf77		0a		asl a		                asl a
3109	.cf78		0a		asl a		                asl a                        ;(index+1)*16
3110	.cf79		aa		tax		                tax
3111	.cf7a		a0 1c		ldy #$1c	                ldy #32-4
3112	.cf7c						setDefaultECFPatterns:
3113	.cf7c		bd c1 e1	lda $e1c1,x	                lda defaultECFPatterns-1,x
3114	.cf7f		99 ff 87	sta $87ff,y	                sta andy.ecfPatterns-1,y     ;copy first repeat
3115	.cf82		99 03 88	sta $8803,y	                sta andy.ecfPatterns+4-1,y   ;copy second repeat
3116	.cf85		ca		dex		                dex                          ;next byte in defaults table
3117	.cf86		88		dey		                dey
3118	.cf87		98		tya		                tya
3119	.cf88		89 07		bit #$07	                bit #$07
3120	.cf8a		d0 f0		bne $cf7c	                bne setDefaultECFPatterns ;taken if pattern not filled
3121							                ; skip to start of previous pattern
3122	.cf8c		88		dey		                dey
3123	.cf8d		88		dey		                dey
3124	.cf8e		88		dey		                dey
3125	.cf8f		88		dey		                dey
3126	.cf90		10 ea		bpl $cf7c	                bpl setDefaultECFPatterns
3127	.cf92						LCF93:
3128	.cf92		4c 7c c5	jmp $c57c	                jmp initializeCurrentECFPatterns

3130							;-------------------------------------------------------------------------
3131							;
3132							; VDU 23 12-15 Set simple ECF pattern [MasRef E.3-17]
3133							;
3134	.cf95						vdu23_12_EntryPoint:
3135	.cf95						vdu23_13_EntryPoint:
3136	.cf95						vdu23_14_EntryPoint:
3137	.cf95						vdu23_15_EntryPoint:
3138	.cf95		e9 0b		sbc #$0b	                sbc #$0B                     ;-12 to get pattern index
3139	.cf97		0a		asl a		                asl a                        ;index*2
3140	.cf98		0a		asl a		                asl a                        ;index*4
3141	.cf99		0a		asl a		                asl a                        ;index*8, C=0
3142	.cf9a		69 03		adc #$03	                adc #$03                     ;index*8+3, C=0
3143	.cf9c		48		pha		                pha                          ;save offset
3144	.cf9d		a2 07		ldx #$07	                ldx #$07                     ;
3145	.cf9f						LCFA0:
3146	.cf9f		bd 1c 03	lda $031c,x	                lda vduv.queueEnd-8,x        ;get simple pattern byte
3147	.cfa2		2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne ;apply logical colour limit
3148	.cfa5		85 da		sta $da		                sta ZTEMP+0
3149	.cfa7		ad 60 03	lda $0360	                lda vduv.numberOfLogicalColoursMinusOne
3150	.cfaa		29 07		and #$07	                and #$07                     ;1/3/7
3151	.cfac		65 da		adc $da		                adc ZTEMP+0                  ;select 2/4/16 colour table
3152	.cfae		a8		tay		                tay
3153	.cfaf		b9 49 e1	lda $e149,y	                lda solidColoursTable-1,y
3154	.cfb2		9d 1c 03	sta $031c,x	                sta vduv.queueEnd-8,x
3155	.cfb5		ca		dex		                dex
3156	.cfb6		10 e7		bpl $cf9f	                bpl LCFA0
3157	.cfb8		a9 55		lda #$55	                lda #%01010101
3158	.cfba		ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
3159	.cfbd		d0 02		bne $cfc1	                bne +                 ;taken if not MODE 0
3160	.cfbf		a9 33		lda #$33	                lda #%00110011        ;double-width pattern for MODE 0
3161	.cfc1						+
3162	.cfc1		85 da		sta $da		                sta ZTEMP+0
3163	.cfc3		7a		ply		                ply
3164	.cfc4		a2 07		ldx #$07	                ldx #$07
3165	.cfc6						LCFC7:
3166	.cfc6		bd 1c 03	lda $031c,x	                lda vduv.queueEnd-8,x
3167	.cfc9		ca		dex		                dex
3168	.cfca		5d 1c 03	eor $031c,x	                eor vduv.queueEnd-8,x
3169	.cfcd		25 da		and $da		                and ZTEMP+0
3170	.cfcf		5d 1c 03	eor $031c,x	                eor vduv.queueEnd-8,x
3171	.cfd2		99 00 88	sta $8800,y	                sta andy.ecfPatterns+0,y
3172	.cfd5		99 04 88	sta $8804,y	                sta andy.ecfPatterns+4,y
3173	.cfd8		88		dey		                dey
3174	.cfd9		ca		dex		                dex
3175	.cfda		10 ea		bpl $cfc6	                bpl LCFC7
3176	.cfdc		80 b4		bra $cf92	                bra LCF93

3178							;-------------------------------------------------------------------------
3179							;
3180							; VDU 23 6 Set dotted lines pattern [MasRef E.3-13]
3181							;
3182	.cfde						vdu23_6_EntryPoint:
3183	.cfde		ad 1c 03	lda $031c	                lda vduv.queueEnd-8
3184	.cfe1		8d 67 03	sta $0367	                sta vduv.dotPattern
3185	.cfe4		60		rts		                rts

3187							;-------------------------------------------------------------------------
3188							;
3189							; VDU 23 7 Scroll window directly [MasRef E.3-14]
3190							;
3191	.cfe5						vdu23_7_EntryPoint:
3192	.cfe5		ad 1c 03	lda $031c	                lda vduv.queueEnd-8           ;get <m>
3193	.cfe8		d0 0a		bne $cff4	                bne scrollEntireScreen
3194	.cfea		20 10 c9	jsr $c910	                jsr copyTextWindowToWorkspace2C
3195	.cfed		a5 d0		lda $d0		                lda STATE
3196	.cfef		29 08		and #$08	                and #STATE.isTextWindow
3197	.cff1		0a		asl a		                asl a ;A=$10 (text window active) or $00 (no text window)
3198	.cff2		80 11		bra $d005	                bra +

3200	.cff4						scrollEntireScreen:
3201	.cff4		a9 00		lda #$00	                lda #$00
3202	.cff6		8d 2c 03	sta $032c	                sta vduv.workspace._2C          ;left
3203	.cff9		8d 2f 03	sta $032f	                sta vduv.workspace._2F          ;top
3204	.cffc		20 a0 e2	jsr $e2a0	                jsr getDefaultBoundsForCurrentScreenMODE
3205	.cfff		8e 2e 03	stx $032e	                stx vduv.workspace._2E          ;right
3206	.d002		8c 2d 03	sty $032d	                sty vduv.workspace._2D          ;bottom
3207	.d005						+
3208	.d005		85 dc		sta $dc		                sta ZTEMPB+0
3209	.d007		38		sec		                sec
3210	.d008		ad 2e 03	lda $032e	                lda vduv.workspace._2E          ;right
3211	.d00b		ed 2c 03	sbc $032c	                sbc vduv.workspace._2C          ;right-left
3212	.d00e		20 3b c9	jsr $c93b	                jsr getBytesPerInclusiveTextRow
3213	.d011		8d 28 03	sta $0328	                sta vduv.workspace._28+0        ;bytes per row LSB
3214	.d014		8e 29 03	stx $0329	                stx vduv.workspace._28+1        ;bytes per row MSB
3215	.d017		ae 4f 03	ldx $034f	                ldx vduv.bytesPerCharacter
3216	.d01a		e0 01		cpx #$01	                cpx #$01
3217	.d01c		f0 07		beq $d025	                beq +  ;when 1 byte/char, no cell/byte distinction
3218	.d01e		ad 1e 03	lda $031e	                lda vduv.queueEnd-6       ;get <z>
3219	.d021		f0 02		beq $d025	                beq +                ;taken if scrolling by 1 cell
3220	.d023		a2 08		ldx #$08	                ldx #$08                 ;scroll by 1 horizontal byte
3221	.d025						+
3222	.d025		8e 2a 03	stx $032a	                stx vduv.workspace._2A

3224							; <d> is a bitmask - %00000AVN.
3225							;
3226							; A is set if scrolling by axis (controlled by the VDU cursor flags)
3227							; rather than by direction.
3228							;
3229							; V is set to scroll vertically/in Y rather than horizontally/in X.
3230							;
3231							; N is set to scroll in the negative direction.

3233	.d028		ad 1d 03	lda $031d	                lda vduv.queueEnd-7           ;00000avn C=?
3234	.d02b		4a		lsr a		                lsr a                        ;000000av C=n
3235	.d02c		08		php		                php
3236	.d02d		2a		rol a		                rol a                        ;00000avn C=0
3237	.d02e		28		plp		                plp                          ;00000avn C=n
3238	.d02f		2a		rol a		                rol a                        ;0000avnn C=0
3239	.d030		0a		asl a		                asl a                        ;000avnn0 C=0
3240	.d031		c9 10		cmp #$10	                cmp #$10                     ;$10 = 000a0000
3241	.d033		90 03		bcc $d038	                bcc LD039                 ;taken if scrolling by direction
3242	.d035		4d 66 03	eor $0366	                eor vduv.cursorFlags       ;adjust axes
3243	.d038						LD039:
3244	.d038		29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
3245	.d03a		05 dc		ora $dc		                ora ZTEMPB+0
3246	.d03c						LD03D:
3247	.d03c		aa		tax		                tax
3248	.d03d		ad 50 03	lda $0350	                lda vduv.screenTopLeftAddress+0
3249	.d040		85 d8		sta $d8		                sta ZMEMT+0
3250	.d042		ad 51 03	lda $0351	                lda vduv.screenTopLeftAddress+1
3251	.d045		85 d9		sta $d9		                sta ZMEMT+1
3252	.d047		20 4d d0	jsr $d04d	                jsr callScrollRoutine
3253	.d04a		4c d7 c6	jmp $c6d7	                jmp updateCRTCTextCursor

3255	.d04d						callScrollRoutine:
3256	.d04d		7c 0a e2	jmp ($e20a,x)	                jmp (scrollRoutinesTable,x)

3258	.d050						LD051:
3259	.d050		da		phx		                phx
3260	.d051		20 10 c9	jsr $c910	                jsr copyTextWindowToWorkspace2C
3261	.d054		20 08 c9	jsr $c908	                jsr copyTextWindowWidthInBytesToWorkspace28
3262	.d057		ae 4f 03	ldx $034f	                ldx $034F
3263	.d05a		8e 2a 03	stx $032a	                stx $032A
3264	.d05d		68		pla		                pla
3265	.d05e		4a		lsr a		                lsr a
3266	.d05f		45 d0		eor $d0		                eor STATE
3267	.d061		29 f7		and #$f7	                and #(~STATE.isTextWindow)&$ff
3268	.d063		45 d0		eor $d0		                eor STATE
3269	.d065		0a		asl a		                asl a
3270	.d066		80 d4		bra $d03c	                bra LD03D

3272							;-------------------------------------------------------------------------
3273							;
3274							; VDU 23 8 Clear block [MasRef E.3-15]
3275							;
3276	.d068						vdu23_8_EntryPoint:
3277	.d068		9c 34 03	stz $0334	                stz $0334
3278	.d06b		9c 35 03	stz $0335	                stz $0335
3279	.d06e		20 50 e2	jsr $e250	                jsr getTextCursorPositionWithColumn81
3280	.d071		8e 36 03	stx $0336	                stx $0336
3281	.d074		8c 37 03	sty $0337	                sty $0337
3282	.d077		20 5a e2	jsr $e25a	                jsr LE25C
3283	.d07a		e8		inx		                inx
3284	.d07b		8e 38 03	stx $0338	                stx $0338
3285	.d07e		8c 39 03	sty $0339	                sty $0339
3286	.d081		a0 00		ldy #$00	                ldy #$00
3287	.d083		ad 1c 03	lda $031c	                lda $031C
3288	.d086		20 e4 d0	jsr $d0e4	                jsr LD0E5
3289	.d089		ad 1d 03	lda $031d	                lda $031D
3290	.d08c		20 e4 d0	jsr $d0e4	                jsr LD0E5
3291	.d08f		ad 33 03	lda $0333	                lda $0333
3292	.d092		cd 31 03	cmp $0331	                cmp $0331
3293	.d095		90 76		bcc $d10d	                bcc LD10E
3294	.d097		d0 08		bne $d0a1	                bne LD0A2
3295	.d099		ad 30 03	lda $0330	                lda $0330
3296	.d09c		cd 32 03	cmp $0332	                cmp $0332
3297	.d09f		b0 6c		bcs $d10d	                bcs LD10E
3298	.d0a1						LD0A2:
3299	.d0a1		ad 18 03	lda $0318	                lda $0318
3300	.d0a4		48		pha		                pha
3301	.d0a5		ad 19 03	lda $0319	                lda $0319
3302	.d0a8		48		pha		                pha
3303	.d0a9		ac 31 03	ldy $0331	                ldy $0331
3304	.d0ac						LD0AD:
3305	.d0ac		5a		phy		                phy
3306	.d0ad		ad 66 03	lda $0366	                lda $0366
3307	.d0b0		49 08		eor #$08	                eor #$08
3308	.d0b2		29 0e		and #$0e	                and #$0E
3309	.d0b4		aa		tax		                tax
3310	.d0b5		98		tya		                tya
3311	.d0b6		20 c6 c2	jsr $c2c6	                jsr setTextCursorXPositionWithCursorFlags
3312	.d0b9		a2 00		ldx #$00	                ldx #$00
3313	.d0bb		ad 38 03	lda $0338	                lda $0338
3314	.d0be		cc 31 03	cpy $0331	                cpy $0331
3315	.d0c1		d0 03		bne $d0c6	                bne LD0C7
3316	.d0c3		ae 30 03	ldx $0330	                ldx $0330
3317	.d0c6						LD0C7:
3318	.d0c6		cc 33 03	cpy $0333	                cpy $0333
3319	.d0c9		f0 07		beq $d0d2	                beq LD0D3
3320	.d0cb		20 7f ca	jsr $ca7f	                jsr LCA7F
3321	.d0ce		7a		ply		                ply
3322	.d0cf		c8		iny		                iny
3323	.d0d0		80 da		bra $d0ac	                bra LD0AD

3325	.d0d2						LD0D3:
3326	.d0d2		ad 32 03	lda $0332	                lda $0332
3327	.d0d5		20 7f ca	jsr $ca7f	                jsr LCA7F
3328	.d0d8		7a		ply		                ply
3329	.d0d9		68		pla		                pla
3330	.d0da		8d 19 03	sta $0319	                sta $0319
3331	.d0dd		68		pla		                pla
3332	.d0de		8d 18 03	sta $0318	                sta $0318
3333	.d0e1		4c fa cc	jmp $ccfa	                jmp updateZMEMTWithTextCursorPosition

3335	.d0e4						LD0E5:
3336	.d0e4		48		pha		                pha
3337	.d0e5		29 03		and #$03	                and #$03
3338	.d0e7		0a		asl a		                asl a
3339	.d0e8		20 ef d0	jsr $d0ef	                jsr LD0F0
3340	.d0eb		68		pla		                pla
3341	.d0ec		4a		lsr a		                lsr a
3342	.d0ed		09 01		ora #$01	                ora #$01
3343	.d0ef						LD0F0:
3344	.d0ef		aa		tax		                tax
3345	.d0f0		29 01		and #$01	                and #$01
3346	.d0f2		48		pha		                pha
3347	.d0f3		bd 34 03	lda $0334,x	                lda $0334,x
3348	.d0f6		fa		plx		                plx
3349	.d0f7		18		clc		                clc
3350	.d0f8		c8		iny		                iny
3351	.d0f9		79 1d 03	adc $031d,y	                adc $031D,y
3352	.d0fc		30 0a		bmi $d108	                bmi LD109
3353	.d0fe		dd 38 03	cmp $0338,x	                cmp $0338,x
3354	.d101		90 07		bcc $d10a	                bcc LD10B
3355	.d103		bd 38 03	lda $0338,x	                lda $0338,x
3356	.d106		80 02		bra $d10a	                bra LD10B

3358	.d108						LD109:
3359	.d108		a9 00		lda #$00	                lda #$00
3360	.d10a						LD10B:
3361	.d10a		99 2f 03	sta $032f,y	                sta $032F,y
3362	.d10d						LD10E:
3363	.d10d		60		rts		                rts

3365							;-------------------------------------------------------------------------
3366							;
3367							; VDU 23 9 Set 1st flash time [MasRef E.3-16]
3368							;
3369	.d10e						vdu23_9_EntryPoint:
3370	.d10e		38		sec		                sec

3372							;-------------------------------------------------------------------------
3373							;
3374							; VDU 23 10 Set 2nd flash time [MasRef E.3-16]
3375							;
3376	.d10f						vdu23_10_EntryPoint:
3377	.d10f		ae 1c 03	ldx $031c	                ldx vduv.queueEnd-8          ;get flash value
3378	.d112		a0 00		ldy #$00	                ldy #$00                     ;Y=0 for OSBYTE call
3379	.d114		90 03		bcc $d119	                bcc doOSBYTE0A               ;taken if VDU23,10
3380	.d116		4c de eb	jmp $ebde	                jmp osbyte09
3381	.d119						doOSBYTE0A:
3382	.d119		38		sec		                sec
3383	.d11a		4c e0 eb	jmp $ebe0	                jmp osbyte0A

3385							;-------------------------------------------------------------------------
3386							;
3387							; VDU 23 16 Cursor movement control [MasRef E.3-17]
3388							;
3389	.d11d						vdu23_16_EntryPoint:
3390	.d11d		ad 66 03	lda $0366	                lda vduv.cursorFlags
3391	.d120		2d 1d 03	and $031d	                and vduv.queueEnd-7          ;value AND <y>
3392	.d123		4d 1c 03	eor $031c	                eor vduv.queueEnd-8          ;(value AND <y>) EOR <x>
3393	.d126		8d 66 03	sta $0366	                sta vduv.cursorFlags
3394	.d129		4a		lsr a		                lsr a
3395	.d12a		b0 18		bcs $d144	                bcs rtsD145            ;taken if scrollProtect flag on
3396							                ; scroll protect flag is off, so handle column 81 if
3397							                ; necessary.

3399							;-------------------------------------------------------------------------
3400							;
3401							; Handle column 81, if necessary.
3402							;
3403							; TODO - probably misnamed due to the return value
3404							;
3405							; exit:
3406							;
3407							; C=0 if not VDU 5
3408							;
3409							; C=1 if VDU 5
3410							;
3411	.d12c						handleColumn81:
3412	.d12c		48		pha		                pha
3413	.d12d		da		phx		                phx
3414	.d12e		20 d0 e2	jsr $e2d0	                jsr testVDU5State
3415	.d131		38		sec		                sec
3416	.d132		d0 0e		bne $d142	                bne plx_pla_rts        ;taken if VDU5
3417	.d134		18		clc		                clc
3418	.d135		2c 6c 03	bit $036c	                bit vduv.column81
3419	.d138		10 08		bpl $d142	                bpl plx_pla_rts        ;taken if not column 81
3420	.d13a		08		php		                php
3421	.d13b		20 f5 c3	jsr $c3f5	                jsr vdu13EntryPoint          ;CR
3422	.d13e		20 5a c2	jsr $c25a	                jsr vdu10EntryPoint          ;LF
3423	.d141		28		plp		                plp
3424	.d142						plx_pla_rts:
3425	.d142		fa		plx		                plx
3426	.d143		68		pla		                pla
3427	.d144						rtsD145:
3428	.d144		60		rts		                rts

3430							;-------------------------------------------------------------------------
3431							;
3432							; Handle PLOT. [MasRef E.3-21]
3433							;
3434							; PLOT numbers are of the form %pppppamm, where %ppppp is the PLOT
3435							; type, %a the absolute flag and %mm the PLOT mode.
3436							;
3437							; Absolute flag and mode are clear enough from [MasRef E.3-22]. The
3438							; %ppppp part isn't documented as such, so here's a list:
3439							;
3440							; %00000 =  0 = 0-7 = Plot solid line (both endpoints included) [MasRef E.3-23]
3441							; %00001 =  1 = 8-15 = Plot solid line (final point omitted) [MasRef E.3-23]
3442							; %00010 =  2 = 16-23 = Plot solid line (final point omitted) [MasRef E.3-23]
3443							; %00011 =  3 = 24-31 = Plot dotted line (final point omitted) [MasRef E.3-23]
3444							; %00100 =  4 = 32-39 = Plot solid line (initial point omitted) [MasRef E.3-24]
3445							; %00101 =  5 = 40-47 = Plot solid line (both endpoints omitted) [MasRef E.3-24]
3446							; %00110 =  6 = 48-55 = Plot dotted line (initial point omitted) [MasRef E.3-24]
3447							; %00111 =  7 = 56-63 = Plot dotted line (both endpoints omitted) [MasRef E.3-24]
3448							; %01000 =  8 = 64-71 = Plot point [MasRef E.3-24]
3449							; %01001 =  9 = 72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
3450							; %01010 = 10 = 80-87 = Plot triangle [MasRef E.3-25]
3451							; %01011 = 11 = 88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
3452							; %01100 = 12 = 96-103 = Plot rectangle [MasRef E.3-26]
3453							; %01101 = 13 = 104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
3454							; %01110 = 14 = 112-119 = Plot parallelogram [MasRef E.3-27]
3455							; %01111 = 15 = 120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
3456							; %10000 = 16 = 128-135 = Flood fill to non-background [MasRef E.3-28]
3457							; %10001 = 17 = 136-143 = Flood fill to foreground [MasRef E.3-28]
3458							; %10010 = 18 = 144-151 = Plot circle outline [MasRef E.3-28]
3459							; %10011 = 19 = 152-159 = Plot filled circle [MasRef E.3-29]
3460							; %10100 = 20 = 160-167 = Plot circular arc [MasRef E.3-29]
3461							; %10101 = 21 = 168-175 = Plot filled chord segment [MasRef E.3-30]
3462							; %10110 = 22 = 176-183 = Plot filled sector [MasRef E.3-30]
3463							; %10111 = 23 = 184-191 = Move/copy rectangle [MasRef E.3-31]
3464							; %11000 = 24 = 192-199 = Plot ellipse outline [MasRef E.3-32]
3465							; %11001 = 25 = 200-207 = Plot solid ellipse [MasRef E.3-32]
3466							; %11010 = 26 = 208-215 = Reserved [MasRef E.3-34]
3467							; %11011 = 27 = 215-223 = Reserved [MasRef E.3-34]
3468							; %11100 = 28 = 224-231 = Reserved [MasRef E.3-34]
3469							; %11101 = 29 = 232-239 = Reserved for Acornsoft sprites [MasRef E.3-34]
3470							; %11110 = 30 = 240-247 = User program calls [MasRef E.3-34]
3471							; %11111 = 31 = 248-255 = User program calls [MasRef E.3-34]
3472							;
3473							; entry:
3474							;
3475							; vduQueueEnd-5 = PLOT number
3476							;
3477							; vduQueueEnd-3 = X coordinate
3478							;
3479							; vduQueueEnd-1 = Y coordinate
3480							;;

3482	.d145						handlePLOT:
3483	.d145		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
3484	.d147		20 e1 d1	jsr $d1e1	                jsr eigabsForPLOT
3485	.d14a		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number
3486	.d14d		a0 05		ldy #$05	                ldy #gcolModeLeave                     ;
3487	.d14f		29 03		and #$03	                and #$03                     ;mask out colour/plot mode [MasRef E.3-22]
3488	.d151		f0 0c		beq $d15f	                beq LD160 ;taken if <p> MOD 4=0 - early out
3489	.d153		4a		lsr a		                lsr a                        ;C=1 if using VDU18 settings
3490	.d154		88		dey		                dey                          ;Y=gcolModeInvert
3491	.d155		90 08		bcc $d15f	                bcc LD160                    ;taken if invert mode
3492	.d157		aa		tax		                tax              ;X=0 if fg settings, 1 if bg settings
3493	.d158		bc 5b 03	ldy $035b,x	                ldy vduv.foregroundGCOLMode,x
3494	.d15b		0a		asl a		                asl a
3495	.d15c		0a		asl a		                asl a
3496	.d15d		0a		asl a		                asl a
3497	.d15e		aa		tax		                tax              ;X=0 if fg settings, 8 if bg settings
3498	.d15f						LD160:
3499	.d15f		8e 59 03	stx $0359	                stx vduv.graphicsPlotState
3500	.d162		98		tya		                tya
3501	.d163		29 0f		and #$0f	                and #$0F
3502	.d165		8d 5a 03	sta $035a	                sta vduv.graphicsPlotMode
3503	.d168		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number pppppmmm
3504	.d16b		4a		lsr a		                lsr a                        ;0pppppmm
3505	.d16c		4a		lsr a		                lsr a                        ;00pppppm
3506	.d16d		29 fe		and #$fe	                and #$fe                     ;00ppppp0
3507	.d16f		aa		tax		                tax
3508	.d170		c9 34		cmp #$34	                cmp #208/4
3509	.d172		b0 1b		bcs $d18f	                bcs LD190                    ;taken if reserved PLOT
3510	.d174		29 f3		and #$f3	                and #$F3                     ;00pp00p0
3511	.d176		c9 12		cmp #$12	                cmp #$12                     ;
3512	.d178		08		php		                php                          ;
3513	.d179		f0 08		beq $d183	                beq LD184                ;taken if horizonal line fill
3514	.d17b		e0 2e		cpx #$2e	                cpx #184/4
3515	.d17d		f0 04		beq $d183	                beq LD184                ;taken if move/copy rectangle
3516	.d17f		c0 05		cpy #$05	                cpy #gcolModeLeave
3517	.d181		f0 19		beq $d19c	                beq LD19D
3518	.d183						LD184:
3519	.d183		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number
3520	.d186		20 92 d1	jsr $d192	                jsr LD193
3521	.d189		28		plp		                plp
3522	.d18a		d0 11		bne $d19d	                bne LD19E
3523	.d18c		4c de c4	jmp $c4de	                jmp LC4DF

3525	.d18f						LD190:
3526	.d18f		4c a2 c6	jmp $c6a2	                jmp callVDUVForPLOT

3528	.d192						LD193:
3529	.d192		e0 10		cpx #$10	                cpx #64/4
3530	.d194		b0 03		bcs $d199	                bcs LD19A                     ;taken if PLOT >=64
3531	.d196		4c a8 d8	jmp $d8a8	                jmp LD8A9                    ;handle line PLOTs

3533	.d199						LD19A:
3534	.d199		7c 79 e0	jmp ($e079,x)	                jmp (plotEntryPointTable-8*2,x)

3536	.d19c						LD19D:
3537	.d19c		68		pla		                pla
3538	.d19d						LD19E:
3539	.d19d		20 1a c9	jsr $c91a	                jsr copyGraphicsCursorPixelsToOldGraphicsCursorPixels
3540	.d1a0		a0 24		ldy #$24	                ldy #$24
3541	.d1a2		4c 16 c9	jmp $c916	                jmp copyLastFourVDUQueueBytes

3543	.d1a5						LD1A6:
3544	.d1a5		a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX

3546							;-------------------------------------------------------------------------
3547							;
3548							; WIND [MasRef E.4-7]. The result is a bit field, %vvhh, where %vv is
3549							; the outcode for the vertical axis and %hh the outcode for the
3550							; horizontal axis. Each outcode is %xn, where x is set if point above
3551							; maximum and n set if point below minimum. (Of course, %11 is then
3552							; not possible.)
3553							;
3554							; See https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm
3555							;
3556							; So the possible results, in binary, are:
3557							;
3558							; %1001 | %1000 | %1010
3559							; ------+-------+------
3560							; %0001 | %0000 | %0010
3561							; ------+-------+------
3562							; %0101 | %0100 | %0110
3563							;
3564	.d1a7						windEntryPoint:
3565	.d1a7		e8		inx		                inx
3566	.d1a8		e8		inx		                inx                          ;point to Y coordinate
3567	.d1a9		20 b4 d1	jsr $d1b4	                jsr getOutcodeForYAxis                    ;process Y coordinate
3568	.d1ac		ca		dex		                dex
3569	.d1ad		ca		dex		                dex                          ;point to X coordinate
3570	.d1ae		0a		asl a		                asl a
3571	.d1af		0a		asl a		                asl a                        ;shift Y outcode into bits 2/3
3572	.d1b0		a0 00		ldy #$00	                ldy #$00                     ;doing Y axis
3573	.d1b2		80 04		bra $d1b8	                bra updateOutcodeForAxis

3575							;-------------------------------------------------------------------------
3576							;
3577	.d1b4						getOutcodeForYAxis:
3578	.d1b4		a0 02		ldy #$02	                ldy #$02                     ;Y=2 for Y coordinate
3579							;-------------------------------------------------------------------------
3580							;
3581							; Get outcode for X or Y axis.
3582							;
3583							; entry:
3584							;
3585							; X = offset in VDU variables of coordinate
3586							;
3587							; Y = 0 if X axis, 2 if Y axis
3588							;
3589							; exit:
3590							;
3591							; ZTEMP?0 = outcode - 0, 1 or 2
3592							;
3593							; A = outcode
3594							;
3595							; N/Z set as per outcode
3596							;
3597	.d1b6						getOutcodeForAxis:
3598	.d1b6		a9 00		lda #$00	                lda #$00                     ;initialize result

3600							;-------------------------------------------------------------------------
3601							;
3602							; Update outcode for X or Y axis
3603							;
3604							; entry: as per getOutcodeForAxis
3605							;
3606							; exit:
3607							;
3608							; ZTEMP?0 = updated; outcode is added to its existing value
3609							;
3610	.d1b8						updateOutcodeForAxis:
3611	.d1b8		85 da		sta $da		                sta ZTEMP+0                  ;save current result
3612							                ; set flags for coordinate-minimum
3613	.d1ba		bd 00 03	lda $0300,x	                lda vduv+0,x
3614	.d1bd		d9 00 03	cmp $0300,y	                cmp vduv.graphicsWindowPixelsLeft+0,y
3615	.d1c0		bd 01 03	lda $0301,x	                lda vduv+1,x
3616	.d1c3		f9 01 03	sbc $0301,y	                sbc vduv.graphicsWindowPixelsLeft+1,y
3617	.d1c6		30 10		bmi $d1d8	                bmi add1ToOutcode ;taken if point below minimum - outcode is 1

3619							                ; set flags for maximum-coordinate
3620	.d1c8		b9 04 03	lda $0304,y	                lda vduv.graphicsWindowPixelsRight+0,y
3621	.d1cb		dd 00 03	cmp $0300,x	                cmp vduv+0,x
3622	.d1ce		b9 05 03	lda $0305,y	                lda vduv.graphicsWindowPixelsRight+1,y
3623	.d1d1		fd 01 03	sbc $0301,x	                sbc vduv+1,x
3624	.d1d4		10 04		bpl $d1da	                bpl gotOutcode ;taken if point below maximum - axis outcode is 0
3625							                ; point is above maximum - axis outcode is 2
3626	.d1d6						add2ToOutcode:
3627	.d1d6		e6 da		inc $da		                inc ZTEMP+0
3628	.d1d8						add1ToOutcode:
3629	.d1d8		e6 da		inc $da		                inc ZTEMP+0
3630	.d1da						gotOutcode:
3631	.d1da		a5 da		lda $da		                lda ZTEMP+0
3632	.d1dc		60		rts		                rts

3634							;-------------------------------------------------------------------------
3635							;
3636							; EIGABS entry point.
3637							;
3638	.d1dd						eigabsEntryPoint:
3639	.d1dd		a9 ff		lda #$ff	                lda #$FF ;pretend it's PLOT 255 (as that would be absolute coordinates)
3640	.d1df		80 03		bra $d1e4	                bra eigabsCommon

3642							;-------------------------------------------------------------------------
3643							;
3644							; EIGABS, but for a VDU 25. Handles relative/absolute addressing,
3645							; based on the PLOT number in the VDU queue.
3646							;
3647	.d1e1						eigabsForPLOT:
3648	.d1e1		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number

3650							;-------------------------------------------------------------------------
3651							;
3652							; EIGABS shared code.
3653							;
3654	.d1e4						eigabsCommon:
3655	.d1e4		85 da		sta $da		                sta ZTEMP+0                  ;save PLOT number
3656	.d1e6		a0 02		ldy #$02	                ldy #$02                     ;process Y
3657	.d1e8		20 0a d2	jsr $d20a	                jsr handleExternalCoordinate
3658	.d1eb		20 41 d2	jsr $d241	                jsr divideCoordinatesBy2     ;divide Y by 4 - convert 0-1023 to 0-255
3659	.d1ee		a0 00		ldy #$00	                ldy #$00                     ;process X
3660	.d1f0		ca		dex		                dex                          ;...
3661	.d1f1		ca		dex		                dex                          ;...
3662	.d1f2		20 0a d2	jsr $d20a	                jsr handleExternalCoordinate
3663	.d1f5		ac 61 03	ldy $0361	                ldy vduv.pixelsPerByteMinusOne
3664	.d1f8		c0 03		cpy #$03	                cpy #$03  ;
3665	.d1fa		f0 05		beq $d201	                beq +     ;branch taken if mode 1/5 - divide by 4 or 8
3666	.d1fc		b0 06		bcs $d204	                bcs ++    ;branch taken if mode 0/4 - divide by 2 or 4
3667	.d1fe		20 41 d2	jsr $d241	                jsr divideCoordinatesBy2     ;mode 2 - divide by 8
3668	.d201						+
3669	.d201		20 41 d2	jsr $d241	                jsr divideCoordinatesBy2
3670	.d204						+
3671	.d204		ad 56 03	lda $0356	                lda vduv.currentScreenMODEGroup
3672	.d207		d0 38		bne $d241	                bne divideCoordinatesBy2     ;branch taken if MODE 4/5
3673	.d209		60		rts		                rts

3675							;-------------------------------------------------------------------------
3676							;
3677							; Handle external coordinate.
3678							;
3679							; 1. Deal with absolute or relative PLOTting
3680							;
3681							; 2. Update graphics cursor position
3682							;
3683							; 3. Handle window origin
3684							;
3685							; 4. Update input coordinate
3686							;
3687							; 5. Divide result by 2 (as this always needs doing at least once)
3688							;
3689							; entry:
3690							;
3691							; ZTEMP?0 = PLOT number
3692							;
3693							; X = offset-2 of external coordinates
3694							;
3695							; Y = 0 to process X coordinate, 2 to process Y coordinate
3696							;
3697	.d20a						handleExternalCoordinate:
3698	.d20a		18		clc		                clc
3699	.d20b		a5 da		lda $da		                lda ZTEMP+0                  ;get PLOT number
3700	.d20d		29 04		and #$04	                and #$04                     ;get absolute/relative flag
3701	.d20f		f0 09		beq $d21a	                beq relativePLOT             ;branch taken if relative
3702	.d211						absolutePLOT:
3703	.d211		bd 02 03	lda $0302,x	                lda vduv+2,x                 ;get coordinate LSB
3704	.d214		48		pha		                pha                          ;save coordinate LSB
3705	.d215		bd 03 03	lda $0303,x	                lda vduv+3,x                 ;get coordinate MSB
3706	.d218		80 0e		bra $d228	                bra LD229                    ;

3708	.d21a						relativePLOT:
3709	.d21a		bd 02 03	lda $0302,x	                lda vduv+2,x                 ;get coordinate LSB
3710	.d21d		79 10 03	adc $0310,y	                adc vduv.graphicsCursorPositionX+0,y ;add current position LSB
3711	.d220		48		pha		                pha                                  ;save coordinate LSB
3712	.d221		bd 03 03	lda $0303,x	                lda vduv+3,x                 ;get coordinate MSB
3713	.d224		79 11 03	adc $0311,y	                adc vduv.graphicsCursorPositionX+1,y ;add current position MSB
3714	.d227		18		clc		                clc
3715	.d228						LD229:
3716	.d228		99 11 03	sta $0311,y	                sta vduv.graphicsCursorPositionX+1,y ;update current position MSB
3717	.d22b		79 0d 03	adc $030d,y	                adc vduv.graphicsWindowOriginX+1,y   ;add window origin MSB
3718	.d22e		9d 03 03	sta $0303,x	                sta vduv+3,x                  ;update coordinate MSB
3719	.d231		68		pla		                pla                          ;restore coordinate LSB
3720	.d232		99 10 03	sta $0310,y	                sta vduv.graphicsCursorPositionX+0,y ;update current position LSB
3721	.d235		18		clc		                clc
3722	.d236		79 0c 03	adc $030c,y	                adc vduv.graphicsWindowOriginX+0,y ;add window origin LSB
3723	.d239		9d 02 03	sta $0302,x	                sta vduv+2,x                       ;update coordinate LSB
3724	.d23c		90 03		bcc $d241	                bcc +
3725	.d23e		fe 03 03	inc $0303,x	                inc vduv+3,x       ;handle carry, ignored earlier
3726	.d241						+

3728	.d241						divideCoordinatesBy2:
3729	.d241		bd 03 03	lda $0303,x	                lda vduv+3,x
3730	.d244		0a		asl a		                asl a                        ;C=bit 7
3731	.d245		7e 03 03	ror $0303,x	                ror vduv+3,x                  ;signed divide by 2
3732	.d248		7e 02 03	ror $0302,x	                ror vduv+2,x                  ;signed divide by 2
3733	.d24b		60		rts		                rts

3735							;-------------------------------------------------------------------------

3737	.d24c						LD24D:
3738	.d24c		da		phx		                phx
3739	.d24d		5a		phy		                phy
3740	.d24e		5a		phy		                phy
3741	.d24f		da		phx		                phx
3742	.d250		5a		phy		                phy
3743	.d251		20 7f d2	jsr $d27f	                jsr LD280
3744	.d254		fa		plx		                plx
3745	.d255		20 7f d2	jsr $d27f	                jsr LD280
3746	.d258		fa		plx		                plx
3747	.d259		7a		ply		                ply
3748	.d25a		20 e7 da	jsr $dae7	                jsr LDAE8
3749	.d25d		fa		plx		                plx
3750	.d25e		20 67 d2	jsr $d267	                jsr LD268
3751	.d261		fa		plx		                plx
3752	.d262		80 03		bra $d267	                bra LD268

3754	.d264						LD265:
3755	.d264		20 24 9b	jsr $9b24	                jsr L9B09
3756	.d267						LD268:
3757	.d267		a0 00		ldy #$00	                ldy #$00
3758	.d269		20 6f d2	jsr $d26f	                jsr LD270
3759	.d26c		e8		inx		                inx
3760	.d26d		a0 02		ldy #$02	                ldy #$02
3761	.d26f						LD270:
3762	.d26f		38		sec		                sec
3763	.d270		20 75 d2	jsr $d275	                jsr LD276
3764	.d273		e8		inx		                inx
3765	.d274		c8		iny		                iny
3766	.d275						LD276:
3767	.d275		bd 00 03	lda $0300,x	                lda $0300,x
3768	.d278		f9 14 03	sbc $0314,y	                sbc $0314,y
3769	.d27b		9d 00 03	sta $0300,x	                sta $0300,x
3770	.d27e						LD27F:
3771	.d27e		60		rts		                rts

3773	.d27f						LD280:
3774	.d27f		a0 00		ldy #$00	                ldy #$00
3775	.d281		20 87 d2	jsr $d287	                jsr LD288
3776	.d284		e8		inx		                inx
3777	.d285		a0 02		ldy #$02	                ldy #$02
3778	.d287						LD288:
3779	.d287		18		clc		                clc
3780	.d288		20 8d d2	jsr $d28d	                jsr LD28E
3781	.d28b		e8		inx		                inx
3782	.d28c		c8		iny		                iny
3783	.d28d						LD28E:
3784	.d28d		bd 00 03	lda $0300,x	                lda $0300,x
3785	.d290		79 14 03	adc $0314,y	                adc $0314,y
3786	.d293		9d 00 03	sta $0300,x	                sta $0300,x
3787	.d296		60		rts		                rts

3789	.d297						LD298:
3790	.d297		85 e1		sta $e1		                sta $E1
3791	.d299		20 24 d4	jsr $d424	                jsr LD425
3792	.d29c		f0 e0		beq $d27e	                beq LD27F
3793	.d29e		a0 14		ldy #$14	                ldy #$14
3794	.d2a0		a9 20		lda #$20	                lda #$20
3795	.d2a2		a2 2c		ldx #$2c	                ldx #$2C
3796	.d2a4		20 64 d2	jsr $d264	                jsr LD265
3797	.d2a7		20 a9 d3	jsr $d3a9	                jsr LD3AA
3798	.d2aa		a9 01		lda #$01	                lda #$01
3799	.d2ac						LD2AD:
3800	.d2ac		84 e0		sty $e0		                sty $E0
3801	.d2ae		04 e0		tsb $e0		                tsb $E0
3802	.d2b0		a2 2c		ldx #$2c	                ldx #VDUVariables.workspace._2C
3803	.d2b2		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
3804	.d2b4		20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
3805	.d2b7		2c 35 03	bit $0335	                bit $0335
3806	.d2ba		08		php		                php
3807	.d2bb		a2 2c		ldx #$2c	                ldx #$2C
3808	.d2bd		20 25 d7	jsr $d725	                jsr LD726
3809	.d2c0		28		plp		                plp
3810	.d2c1		10 03		bpl $d2c6	                bpl LD2C7
3811	.d2c3		20 a9 d3	jsr $d3a9	                jsr LD3AA
3812	.d2c6						LD2C7:
3813	.d2c6		ac 2c 03	ldy $032c	                ldy $032C
3814	.d2c9		ad 2d 03	lda $032d	                lda $032D
3815	.d2cc		30 03		bmi $d2d1	                bmi LD2D2
3816	.d2ce		20 2e c9	jsr $c92e	                jsr negateAY
3817	.d2d1						LD2D2:
3818	.d2d1		48		pha		                pha
3819	.d2d2		18		clc		                clc
3820	.d2d3		98		tya		                tya
3821	.d2d4		6d 30 88	adc $8830	                adc L8830
3822	.d2d7		a8		tay		                tay
3823	.d2d8		68		pla		                pla
3824	.d2d9		6d 31 88	adc $8831	                adc L8831
3825	.d2dc		10 ce		bpl $d2ac	                bpl LD2AD
3826	.d2de		1a		inc a		                inc a
3827	.d2df		d0 23		bne $d304	                bne LD305
3828	.d2e1		c8		iny		                iny
3829	.d2e2		d0 20		bne $d304	                bne LD305
3830	.d2e4		a5 e0		lda $e0		                lda $E0
3831	.d2e6		f0 1c		beq $d304	                beq LD305
3832	.d2e8		ad 2c 03	lda $032c	                lda $032C
3833	.d2eb		cd 28 03	cmp $0328	                cmp $0328
3834	.d2ee		f0 14		beq $d304	                beq LD305
3835	.d2f0		a2 2c		ldx #$2c	                ldx #$2C
3836	.d2f2		a0 28		ldy #$28	                ldy #$28
3837	.d2f4		ad 36 03	lda $0336	                lda $0336
3838	.d2f7		0a		asl a		                asl a
3839	.d2f8		4d 36 03	eor $0336	                eor $0336
3840	.d2fb		10 04		bpl $d301	                bpl LD302
3841	.d2fd		e8		inx		                inx
3842	.d2fe		e8		inx		                inx
3843	.d2ff		c8		iny		                iny
3844	.d300		c8		iny		                iny
3845	.d301						LD302:
3846	.d301		20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
3847	.d304						LD305:
3848	.d304		20 24 d4	jsr $d424	                jsr LD425
3849	.d307		ad 29 03	lda $0329	                lda $0329
3850	.d30a		aa		tax		                tax
3851	.d30b		4d 1c 03	eor $031c	                eor $031C
3852	.d30e		30 18		bmi $d328	                bmi LD329
3853	.d310		a0 02		ldy #$02	                ldy #$02
3854	.d312		20 6e d4	jsr $d46e	                jsr LD46F
3855	.d315		d0 0c		bne $d323	                bne LD324
3856	.d317		ae 2b 03	ldx $032b	                ldx $032B
3857	.d31a		a0 00		ldy #$00	                ldy #$00
3858	.d31c		20 6e d4	jsr $d46e	                jsr LD46F
3859	.d31f		f0 11		beq $d332	                beq LD333
3860	.d321		49 80		eor #$80	                eor #$80
3861	.d323						LD324:
3862	.d323		86 da		stx $da		                stx $DA
3863	.d325		45 da		eor $da		                eor $DA
3864	.d327		aa		tax		                tax
3865	.d328						LD329:
3866	.d328		8a		txa		                txa
3867	.d329		29 80		and #$80	                and #$80
3868	.d32b		f0 02		beq $d32f	                beq LD330
3869	.d32d		a9 c0		lda #$c0	                lda #$C0
3870	.d32f						LD330:
3871	.d32f		04 e1		tsb $e1		                tsb $E1
3872	.d331		18		clc		                clc
3873	.d332						LD333:
3874	.d332		60		rts		                rts

3876	.d333						LD334:
3877	.d333		a5 e1		lda $e1		                lda $E1
3878	.d335		8d 48 88	sta $8848	                sta L8848
3879	.d338		89 03		bit #$03	                bit #$03
3880	.d33a		f0 f6		beq $d332	                beq LD333
3881	.d33c		a9 10		lda #$10	                lda #$10
3882	.d33e		85 dc		sta $dc		                sta $DC
3883	.d340		0a		asl a		                asl a
3884	.d341		85 dd		sta $dd		                sta $DD
3885	.d343		a2 1b		ldx #$1b	                ldx #$1B
3886	.d345		20 4e d3	jsr $d34e	                jsr LD34F
3887	.d348		06 dc		asl $dc		                asl $DC
3888	.d34a		46 dd		lsr $dd		                lsr $DD
3889	.d34c		a2 28		ldx #$28	                ldx #$28
3890	.d34e						LD34F:
3891	.d34e		a9 80		lda #$80	                lda #$80
3892	.d350		85 da		sta $da		                sta $DA
3893	.d352		bd 02 03	lda $0302,x	                lda $0302,x
3894	.d355		cd 32 88	cmp $8832	                cmp L8832
3895	.d358		d0 d8		bne $d332	                bne LD333
3896	.d35a		bd 03 03	lda $0303,x	                lda $0303,x
3897	.d35d		cd 33 88	cmp $8833	                cmp L8833
3898	.d360		d0 d0		bne $d332	                bne LD333
3899	.d362		bc 00 03	ldy $0300,x	                ldy $0300,x
3900	.d365		bd 01 03	lda $0301,x	                lda $0301,x
3901	.d368		10 05		bpl $d36f	                bpl LD370
3902	.d36a		46 da		lsr $da		                lsr $DA
3903	.d36c		20 2e c9	jsr $c92e	                jsr negateAY
3904	.d36f						LD370:
3905	.d36f		cc 30 88	cpy $8830	                cpy L8830
3906	.d372		d0 be		bne $d332	                bne LD333
3907	.d374		cd 31 88	cmp $8831	                cmp L8831
3908	.d377		d0 b9		bne $d332	                bne LD333
3909	.d379		a5 e1		lda $e1		                lda $E1
3910	.d37b		89 02		bit #$02	                bit #$02
3911	.d37d		f0 19		beq $d398	                beq LD399
3912	.d37f		a0 30		ldy #$30	                ldy #$30
3913	.d381		89 01		bit #$01	                bit #$01
3914	.d383		f0 02		beq $d387	                beq LD388
3915	.d385		a4 dc		ldy $dc		                ldy $DC
3916	.d387						LD388:
3917	.d387		98		tya		                tya
3918	.d388		4a		lsr a		                lsr a
3919	.d389		4a		lsr a		                lsr a
3920	.d38a		24 e1		bit $e1		                bit $E1
3921	.d38c		d0 06		bne $d394	                bne LD395
3922	.d38e		05 dc		ora $dc		                ora $DC
3923	.d390		04 e1		tsb $e1		                tsb $E1
3924	.d392		80 04		bra $d398	                bra LD399

3926	.d394						LD395:
3927	.d394		05 dd		ora $dd		                ora $DD
3928	.d396		14 e1		trb $e1		                trb $E1
3929	.d398						LD399:
3930	.d398		a5 da		lda $da		                lda $DA
3931	.d39a		24 e1		bit $e1		                bit $E1
3932	.d39c		f0 91		beq $d32f	                beq LD330
3933	.d39e		14 e1		trb $e1		                trb $E1
3934	.d3a0		a5 e1		lda $e1		                lda $E1
3935	.d3a2		8d 48 88	sta $8848	                sta L8848
3936	.d3a5		8d 49 88	sta $8849	                sta L8849
3937	.d3a8		60		rts		                rts

3939	.d3a9						LD3AA:
3940	.d3a9		ad 2e 03	lda $032e	                lda $032E
3941	.d3ac		8d 32 88	sta $8832	                sta L8832
3942	.d3af		ad 2f 03	lda $032f	                lda $032F
3943	.d3b2		8d 33 88	sta $8833	                sta L8833
3944	.d3b5		20 fb d3	jsr $d3fb	                jsr LD3FC
3945	.d3b8		20 12 d5	jsr $d512	                jsr LD513
3946	.d3bb		8c 30 88	sty $8830	                sty L8830
3947	.d3be		ad 46 88	lda $8846	                lda L8846
3948	.d3c1		4a		lsr a		                lsr a
3949	.d3c2		ad 3d 88	lda $883d	                lda L883D
3950	.d3c5		90 06		bcc $d3cd	                bcc LD3CE
3951	.d3c7		c9 80		cmp #$80	                cmp #$80
3952	.d3c9		6a		ror a		                ror a
3953	.d3ca		6e 30 88	ror $8830	                ror L8830
3954	.d3cd						LD3CE:
3955	.d3cd		8d 31 88	sta $8831	                sta L8831
3956	.d3d0		60		rts		                rts

3958	.d3d1						LD3D2:
3959	.d3d1		9c 47 88	stz $8847	                stz L8847
3960	.d3d4		9c 30 88	stz $8830	                stz L8830
3961	.d3d7		9c 31 88	stz $8831	                stz L8831
3962	.d3da		9c 34 88	stz $8834	                stz L8834
3963	.d3dd		9c 35 88	stz $8835	                stz L8835
3964	.d3e0		ad 32 88	lda $8832	                lda L8832
3965	.d3e3		0a		asl a		                asl a
3966	.d3e4		8d 36 88	sta $8836	                sta L8836
3967	.d3e7		ad 33 88	lda $8833	                lda L8833
3968	.d3ea		2a		rol a		                rol a
3969	.d3eb		8d 37 88	sta $8837	                sta L8837
3970	.d3ee		ad 46 88	lda $8846	                lda L8846
3971	.d3f1		89 02		bit #$02	                bit #$02
3972	.d3f3		f0 06		beq $d3fb	                beq LD3FC
3973	.d3f5		0e 36 88	asl $8836	                asl L8836
3974	.d3f8		2e 37 88	rol $8837	                rol L8837
3975	.d3fb						LD3FC:
3976	.d3fb		ad 46 88	lda $8846	                lda L8846
3977	.d3fe		4a		lsr a		                lsr a
3978	.d3ff		4a		lsr a		                lsr a
3979	.d400		ac 32 88	ldy $8832	                ldy L8832
3980	.d403		ad 33 88	lda $8833	                lda L8833
3981	.d406		20 c4 d4	jsr $d4c4	                jsr LD4C5
3982	.d409		38		sec		                sec
3983	.d40a		a2 fc		ldx #$fc	                ldx #$FC
3984	.d40c						LD40D:
3985	.d40c		bd 3c 87	lda $873c,x	                lda L873C,x
3986	.d40f		fd 44 87	sbc $8744,x	                sbc L8744,x
3987	.d412		9d 44 87	sta $8744,x	                sta L8744,x
3988	.d415		e8		inx		                inx
3989	.d416		d0 f4		bne $d40c	                bne LD40D
3990	.d418		60		rts		                rts

3992	.d419						LD41A:
3993	.d419		20 1a c9	jsr $c91a	                jsr copyGraphicsCursorPixelsToOldGraphicsCursorPixels
3994	.d41c		64 e1		stz $e1		                stz $E1
3995	.d41e		a2 20		ldx #$20	                ldx #$20
3996	.d420		20 26 d4	jsr $d426	                jsr LD427
3997	.d423		60		rts		                rts

3999	.d424						LD425:
4000	.d424		a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX
4001	.d426						LD427:
4002	.d426		a0 1b		ldy #$1b	                ldy #VDUVariables.queueEnd-9
4003	.d428		20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
4004	.d42b		a2 1b		ldx #$1b	                ldx #$1B
4005	.d42d		20 67 d2	jsr $d267	                jsr LD268
4006	.d430		20 85 d4	jsr $d485	                jsr LD486
4007	.d433		20 12 d5	jsr $d512	                jsr LD513
4008	.d436		a0 0c		ldy #$0c	                ldy #$0C
4009	.d438		20 aa d4	jsr $d4aa	                jsr LD4AB
4010	.d43b		20 12 d5	jsr $d512	                jsr LD513
4011	.d43e		c9 20		cmp #$20	                cmp #$20
4012	.d440		90 05		bcc $d447	                bcc LD448
4013	.d442		68		pla		                pla
4014	.d443		68		pla		                pla
4015	.d444		68		pla		                pla
4016	.d445		68		pla		                pla
4017	.d446		60		rts		                rts

4019	.d447						LD448:
4020	.d447		8c 44 88	sty $8844	                sty L8844
4021	.d44a		8d 45 88	sta $8845	                sta L8845
4022	.d44d		ad 46 88	lda $8846	                lda L8846
4023	.d450		89 02		bit #$02	                bit #$02
4024	.d452		f0 06		beq $d45a	                beq LD45B
4025	.d454		4e 45 88	lsr $8845	                lsr L8845
4026	.d457		6e 44 88	ror $8844	                ror L8844
4027	.d45a						LD45B:
4028	.d45a		ac 44 88	ldy $8844	                ldy L8844
4029	.d45d		ad 45 88	lda $8845	                lda L8845
4030	.d460		20 2e c9	jsr $c92e	                jsr negateAY
4031	.d463		8c 32 88	sty $8832	                sty L8832
4032	.d466		8d 33 88	sta $8833	                sta L8833
4033	.d469		0d 32 88	ora $8832	                ora L8832
4034	.d46c		38		sec		                sec
4035	.d46d		60		rts		                rts

4037	.d46e						LD46F:
4038	.d46e		64 da		stz $da		                stz $DA
4039	.d470		b9 1b 03	lda $031b,y	                lda $031B,y
4040	.d473		d9 28 03	cmp $0328,y	                cmp $0328,y
4041	.d476		f0 02		beq $d47a	                beq LD47B
4042	.d478		e6 da		inc $da		                inc $DA
4043	.d47a						LD47B:
4044	.d47a		b9 1c 03	lda $031c,y	                lda $031C,y
4045	.d47d		f9 29 03	sbc $0329,y	                sbc $0329,y
4046	.d480		d0 02		bne $d484	                bne LD485
4047	.d482		a5 da		lda $da		                lda $DA
4048	.d484						LD485:
4049	.d484		60		rts		                rts

4051	.d485						LD486:
4052	.d485		ae 55 03	ldx $0355	                ldx $0355
4053	.d488		bd be d4	lda $d4be,x	                lda LD4BF,x
4054	.d48b		8d 46 88	sta $8846	                sta L8846
4055	.d48e		4a		lsr a		                lsr a
4056	.d48f		48		pha		                pha
4057	.d490		a2 04		ldx #$04	                ldx #$04
4058	.d492						LD493:
4059	.d492		9e 37 88	stz $8837,x	                stz L8837,x
4060	.d495		ca		dex		                dex
4061	.d496		d0 fa		bne $d492	                bne LD493
4062	.d498		20 9f d4	jsr $d49f	                jsr LD4A0
4063	.d49b		68		pla		                pla
4064	.d49c		4a		lsr a		                lsr a
4065	.d49d		a2 02		ldx #$02	                ldx #$02
4066	.d49f						LD4A0:
4067	.d49f		bc 1b 03	ldy $031b,x	                ldy $031B,x
4068	.d4a2		bd 1c 03	lda $031c,x	                lda $031C,x
4069	.d4a5		20 c4 d4	jsr $d4c4	                jsr LD4C5
4070	.d4a8		a0 10		ldy #$10	                ldy #$10
4071	.d4aa						LD4AB:
4072	.d4aa		18		clc		                clc
4073	.d4ab		a2 fc		ldx #$fc	                ldx #$FC
4074	.d4ad						LD4AE:
4075	.d4ad		bd 3c 87	lda $873c,x	                lda L873C,x
4076	.d4b0		79 30 88	adc $8830,y	                adc L8830,y
4077	.d4b3		9d 3c 87	sta $873c,x	                sta L873C,x
4078	.d4b6		9d 44 87	sta $8744,x	                sta L8744,x
4079	.d4b9		c8		iny		                iny
4080	.d4ba		e8		inx		                inx
4081	.d4bb		d0 f0		bne $d4ad	                bne LD4AE
4082	.d4bd		60		rts		                rts

4084	.d4be						LD4BF:
4085	>d4be		02				                .byte $02
4086	.d4bf		00		brk #		                brk
4087	.d4c0		01 ff		ora ($ff,x)	                ora ($FF,x)
4088	.d4c2		00		brk #		                brk
4089							;ORA (&8C,x)      :\ D4C4= 01       ..
4090	>d4c3		01				                .byte $01
4091	.d4c4						LD4C5:
4092	.d4c4		8c 3c 88	sty $883c	                sty L883C
4093	.d4c7		90 04		bcc $d4cd	                bcc LD4CE
4094	.d4c9		0e 3c 88	asl $883c	                asl L883C
4095	.d4cc		2a		rol a		                rol a
4096	.d4cd						LD4CE:
4097	.d4cd		8d 3d 88	sta $883d	                sta L883D
4098	.d4d0		ac 3c 88	ldy $883c	                ldy L883C
4099	.d4d3		aa		tax		                tax
4100	.d4d4		10 03		bpl $d4d9	                bpl LD4DA
4101	.d4d6		20 2e c9	jsr $c92e	                jsr negateAY
4102	.d4d9						LD4DA:
4103	.d4d9		8c 3c 88	sty $883c	                sty L883C
4104	.d4dc		8d 3d 88	sta $883d	                sta L883D
4105	.d4df		8c 40 88	sty $8840	                sty L8840
4106	.d4e2		9c 42 88	stz $8842	                stz L8842
4107	.d4e5		9c 43 88	stz $8843	                stz L8843
4108	.d4e8		a0 0f		ldy #$0f	                ldy #$0F
4109	.d4ea		4a		lsr a		                lsr a
4110	.d4eb		8d 41 88	sta $8841	                sta L8841
4111	.d4ee		6e 40 88	ror $8840	                ror L8840
4112	.d4f1						LD4F2:
4113	.d4f1		90 13		bcc $d506	                bcc LD507
4114	.d4f3		18		clc		                clc
4115	.d4f4		ad 3c 88	lda $883c	                lda L883C
4116	.d4f7		6d 42 88	adc $8842	                adc L8842
4117	.d4fa		8d 42 88	sta $8842	                sta L8842
4118	.d4fd		ad 3d 88	lda $883d	                lda L883D
4119	.d500		6d 43 88	adc $8843	                adc L8843
4120	.d503		8d 43 88	sta $8843	                sta L8843
4121	.d506						LD507:
4122	.d506		a2 03		ldx #$03	                ldx #$03
4123	.d508						LD509:
4124	.d508		7e 40 88	ror $8840,x	                ror L8840,x
4125	.d50b		ca		dex		                dex
4126	.d50c		10 fa		bpl $d508	                bpl LD509
4127	.d50e		88		dey		                dey
4128	.d50f		10 e0		bpl $d4f1	                bpl LD4F2
4129	.d511		60		rts		                rts

4131	.d512						LD513:
4132	.d512		a2 02		ldx #$02	                ldx #$02
4133	.d514						LD515:
4134	.d514		9e 3c 88	stz $883c,x	                stz L883C,x
4135	.d517		74 db		stz $db,x	                stz $DB,x
4136	.d519		ca		dex		                dex
4137	.d51a		10 f8		bpl $d514	                bpl LD515
4138	.d51c		a0 03		ldy #$03	                ldy #$03
4139	.d51e						LD51F:
4140	.d51e		b9 40 88	lda $8840,y	                lda L8840,y
4141	.d521		85 da		sta $da		                sta $DA
4142	.d523		5a		phy		                phy
4143	.d524		a0 03		ldy #$03	                ldy #$03
4144	.d526						LD527:
4145	.d526		5a		phy		                phy
4146	.d527		38		sec		                sec
4147	.d528		2e 3c 88	rol $883c	                rol L883C
4148	.d52b		2e 3d 88	rol $883d	                rol L883D
4149	.d52e		2e 3e 88	rol $883e	                rol L883E
4150	.d531		a2 01		ldx #$01	                ldx #$01
4151	.d533		a5 db		lda $db		                lda $DB
4152	.d535						LD536:
4153	.d535		06 da		asl $da		                asl $DA
4154	.d537		2a		rol a		                rol a
4155	.d538		26 dc		rol $dc		                rol $DC
4156	.d53a		26 dd		rol $dd		                rol $DD
4157	.d53c		ca		dex		                dex
4158	.d53d		10 f6		bpl $d535	                bpl LD536
4159	.d53f		85 db		sta $db		                sta $DB
4160	.d541		38		sec		                sec
4161	.d542		ed 3c 88	sbc $883c	                sbc L883C
4162	.d545		aa		tax		                tax
4163	.d546		a5 dc		lda $dc		                lda $DC
4164	.d548		ed 3d 88	sbc $883d	                sbc L883D
4165	.d54b		a8		tay		                tay
4166	.d54c		a5 dd		lda $dd		                lda $DD
4167	.d54e		ed 3e 88	sbc $883e	                sbc L883E
4168	.d551		90 0b		bcc $d55e	                bcc LD55F
4169	.d553		85 dd		sta $dd		                sta $DD
4170	.d555		84 dc		sty $dc		                sty $DC
4171	.d557		86 db		stx $db		                stx $DB
4172	.d559		ee 3c 88	inc $883c	                inc L883C
4173	.d55c		80 03		bra $d561	                bra LD562

4175	.d55e						LD55F:
4176	.d55e		ce 3c 88	dec $883c	                dec L883C
4177	.d561						LD562:
4178	.d561		7a		ply		                ply
4179	.d562		88		dey		                dey
4180	.d563		10 c1		bpl $d526	                bpl LD527
4181	.d565		7a		ply		                ply
4182	.d566		88		dey		                dey
4183	.d567		10 b5		bpl $d51e	                bpl LD51F
4184	.d569		4e 3e 88	lsr $883e	                lsr L883E
4185	.d56c		6e 3d 88	ror $883d	                ror L883D
4186	.d56f		6e 3c 88	ror $883c	                ror L883C
4187	.d572		9c 3e 88	stz $883e	                stz L883E
4188	.d575		9c 3f 88	stz $883f	                stz L883F
4189	.d578		ac 3c 88	ldy $883c	                ldy L883C
4190	.d57b		ad 3d 88	lda $883d	                lda L883D
4191	.d57e		60		rts		                rts

4193							;-------------------------------------------------------------------------
4194							;
4195							; Add dimension of region to a coordinate.
4196							;
4197							; entry:
4198							;
4199							; X = VDU variable offset of coordinate
4200							;
4201							; A = VDU variable offset of minimum coordinate of region
4202							;
4203							; Y = VDU variable offset of maximum coordinate of region
4204							;
4205							; ZTEMP?0 = VDU variable offset for result
4206							;
4207							; exit:
4208							;
4209							; result variable = coordinate+(min-max)
4210							;
4211	.d57f						addRegionDimensionsToVDUVariableCoordinates:
4212	.d57f		20 8c d5	jsr $d58c	                jsr addRegionDimensionToVDUVariableCoordinate ;do X

4214							                ; bump offsets to do Y.
4215	.d582		c8		iny		                iny
4216	.d583		c8		iny		                iny
4217	.d584		e8		inx		                inx
4218	.d585		e8		inx		                inx
4219	.d586		1a		inc a		                inc a
4220	.d587		1a		inc a		                inc a
4221	.d588		e6 da		inc $da		                inc ZTEMP+0
4222	.d58a		e6 da		inc $da		                inc ZTEMP+0

4224							                ; TODO - not a great name. Could probably just be
4225							                ; addDifference, or something.
4226	.d58c						addRegionDimensionToVDUVariableCoordinate:
4227	.d58c		da		phx		                phx                          ;save VX
4228	.d58d		5a		phy		                phy                          ;save VY
4229	.d58e		48		pha		                pha                          ;save VA
4230	.d58f		18		clc		                clc
4231	.d590		bd 00 03	lda $0300,x	                lda vduv+0,x                 ;<VX
4232	.d593		79 00 03	adc $0300,y	                adc vduv+0,y                 ;<(VX+VY)
4233	.d596		85 de		sta $de		                sta ZTEMPC+0                 ;ZTEMPC?0=<(VX+VY)
4234	.d598		bd 01 03	lda $0301,x	                lda vduv+1,x                 ;>VX
4235	.d59b		79 01 03	adc $0301,y	                adc vduv+1,y                 ;>(VX+VY)
4236	.d59e		fa		plx		                plx                          ;X=VA
4237	.d59f		48		pha		                pha                          ;save >(VX+VY)
4238	.d5a0		a4 da		ldy $da		                ldy ZTEMP+0                  ;Y=VT
4239	.d5a2		38		sec		                sec
4240	.d5a3		a5 de		lda $de		                lda ZTEMPC+0                 ;<(VX+VY)
4241	.d5a5		fd 00 03	sbc $0300,x	                sbc vduv+0,x                 ;<(VX+VY-VA)
4242	.d5a8		99 00 03	sta $0300,y	                sta vduv+0,y                 ;<VT=<(VX+VY-VA)
4243	.d5ab		68		pla		                pla                          ;>(VX+VY)
4244	.d5ac		fd 01 03	sbc $0301,x	                sbc vduv+1,x                 ;>(VX+VY-VA)
4245	.d5af		99 01 03	sta $0301,y	                sta vduv+1,y                 ;>VT=<(VX+VY-VA)
4246	.d5b2		8a		txa		                txa                          ;restore old A
4247	.d5b3		7a		ply		                ply                          ;restore old Y
4248	.d5b4		fa		plx		                plx                          ;restore old X
4249	.d5b5		60		rts		                rts

4251							;-------------------------------------------------------------------------
4252							;
4253							; Sort points by Y coordinate, then X.
4254							;
4255							; entry:
4256							;
4257							; X = VDU variable offset of point A (4 bytes: X;Y;)
4258							;
4259							; Y = VDU variable offset of point B (4 bytes: X;Y;)
4260							;
4261							; exit:
4262							;
4263							; X = offset of point with lesser Y (or lesser X, if same Y)
4264							;
4265							; Y = offset of point with greater Y (or greater X, if same Y)
4266							;
4267	.d5b6						sortVDUVariableCoordinates:
4268	.d5b6		38		sec		                sec
4269	.d5b7		b9 02 03	lda $0302,y	                lda vduv+2,y
4270	.d5ba		fd 02 03	sbc $0302,x	                sbc vduv+2,x
4271	.d5bd		85 de		sta $de		                sta ZTEMPC
4272	.d5bf		b9 03 03	lda $0303,y	                lda vduv+3,y
4273	.d5c2		fd 03 03	sbc $0303,x	                sbc vduv+3,x
4274	.d5c5		30 09		bmi $d5d0	                bmi exchangeXAndY           ;taken if PX.y>PY.y
4275	.d5c7		05 de		ora $de		                ora ZTEMPC
4276	.d5c9		d0 09		bne $d5d4	                bne rtsD5D5                  ;taken if PX.y<PY.y

4278							;-------------------------------------------------------------------------
4279							;
4280							; Sort words by value.
4281							;
4282							; entry:
4283							;
4284							; X = VDU variable offset of word A
4285							;
4286							; Y = VDU variable offset of word B
4287							;
4288							; exit:
4289							;
4290							; X = offset of lesser value
4291							;
4292							; Y = offset of greater value
4293							;
4294	.d5cb						sortVDUVariableWords:
4295	.d5cb		20 d5 d5	jsr $d5d5	                jsr compareVDUVariableWords
4296	.d5ce		10 04		bpl $d5d4	                bpl rtsD5D5
4297	.d5d0						exchangeXAndY:
4298	.d5d0		8a		txa		                txa
4299	.d5d1		5a		phy		                phy
4300	.d5d2		fa		plx		                plx
4301	.d5d3		a8		tay		                tay
4302	.d5d4						rtsD5D5:
4303	.d5d4		60		rts		                rts

4305							;-------------------------------------------------------------------------
4306							;
4307							; Compare 2 16-bit VDU variable values.
4308							;
4309							; entry:
4310							;
4311							; X = offset of one variable
4312							;
4313							; Y = offset of the other variable
4314							;
4315							; exit:
4316							;
4317							; N=1 if X>Y
4318							;
4319	.d5d5						compareVDUVariableWords:
4320	.d5d5		b9 00 03	lda $0300,y	                lda vduv+0,y
4321	.d5d8		dd 00 03	cmp $0300,x	                cmp vduv+0,x
4322	.d5db		b9 01 03	lda $0301,y	                lda vduv+1,y
4323	.d5de		fd 01 03	sbc $0301,x	                sbc vduv+1,x
4324	.d5e1		60		rts		                rts

4326							;-------------------------------------------------------------------------

4328	.d5e2						LD5E3:
4329	.d5e2		ee 47 88	inc $8847	                inc L8847
4330	.d5e5						LD5E6:
4331	.d5e5		ad 47 88	lda $8847	                lda L8847
4332	.d5e8		d0 0f		bne $d5f9	                bne LD5FA
4333	.d5ea		ad 32 88	lda $8832	                lda L8832
4334	.d5ed		0d 33 88	ora $8833	                ora L8833
4335	.d5f0		f0 f0		beq $d5e2	                beq LD5E3
4336	.d5f2		a2 00		ldx #$00	                ldx #$00
4337	.d5f4		20 43 d6	jsr $d643	                jsr LD644
4338	.d5f7		10 49		bpl $d642	                bpl LD643
4339	.d5f9						LD5FA:
4340	.d5f9		a2 02		ldx #$02	                ldx #$02
4341	.d5fb		20 43 d6	jsr $d643	                jsr LD644
4342	.d5fe		10 42		bpl $d642	                bpl LD643
4343	.d600		a2 00		ldx #$00	                ldx #$00
4344	.d602		20 09 d6	jsr $d609	                jsr LD60A
4345	.d605		10 3b		bpl $d642	                bpl LD643
4346	.d607		a2 02		ldx #$02	                ldx #$02
4347	.d609						LD60A:
4348	.d609		bd 30 88	lda $8830,x	                lda L8830,x
4349	.d60c		d0 03		bne $d611	                bne LD612
4350	.d60e		de 31 88	dec $8831,x	                dec L8831,x
4351	.d611						LD612:
4352	.d611		de 30 88	dec $8830,x	                dec L8830,x
4353	.d614		8a		txa		                txa
4354	.d615		4a		lsr a		                lsr a
4355	.d616		1a		inc a		                inc a
4356	.d617		2c 46 88	bit $8846	                bit L8846
4357	.d61a		f0 03		beq $d61f	                beq LD620
4358	.d61c		20 1f d6	jsr $d61f	                jsr LD620
4359	.d61f						LD620:
4360	.d61f		20 35 d6	jsr $d635	                jsr LD636
4361	.d622		18		clc		                clc
4362	.d623		ad 40 88	lda $8840	                lda L8840
4363	.d626		7d 34 88	adc $8834,x	                adc L8834,x
4364	.d629		8d 40 88	sta $8840	                sta L8840
4365	.d62c		ad 41 88	lda $8841	                lda L8841
4366	.d62f		7d 35 88	adc $8835,x	                adc L8835,x
4367	.d632		8d 41 88	sta $8841	                sta L8841
4368	.d635						LD636:
4369	.d635		08		php		                php
4370	.d636		bd 34 88	lda $8834,x	                lda L8834,x
4371	.d639		d0 03		bne $d63e	                bne LD63F
4372	.d63b		de 35 88	dec $8835,x	                dec L8835,x
4373	.d63e						LD63F:
4374	.d63e		de 34 88	dec $8834,x	                dec L8834,x
4375	.d641		28		plp		                plp
4376	.d642						LD643:
4377	.d642		60		rts		                rts

4379	.d643						LD644:
4380	.d643		fe 30 88	inc $8830,x	                inc L8830,x
4381	.d646		d0 03		bne $d64b	                bne LD64C
4382	.d648		fe 31 88	inc $8831,x	                inc L8831,x
4383	.d64b						LD64C:
4384	.d64b		8a		txa		                txa
4385	.d64c		4a		lsr a		                lsr a
4386	.d64d		1a		inc a		                inc a
4387	.d64e		2c 46 88	bit $8846	                bit L8846
4388	.d651		f0 03		beq $d656	                beq LD657
4389	.d653		20 56 d6	jsr $d656	                jsr LD657
4390	.d656						LD657:
4391	.d656		20 6c d6	jsr $d66c	                jsr LD66D
4392	.d659		38		sec		                sec
4393	.d65a		ad 40 88	lda $8840	                lda L8840
4394	.d65d		fd 34 88	sbc $8834,x	                sbc L8834,x
4395	.d660		8d 40 88	sta $8840	                sta L8840
4396	.d663		ad 41 88	lda $8841	                lda L8841
4397	.d666		fd 35 88	sbc $8835,x	                sbc L8835,x
4398	.d669		8d 41 88	sta $8841	                sta L8841
4399	.d66c						LD66D:
4400	.d66c		08		php		                php
4401	.d66d		fe 34 88	inc $8834,x	                inc L8834,x
4402	.d670		d0 03		bne $d675	                bne LD676
4403	.d672		fe 35 88	inc $8835,x	                inc L8835,x
4404	.d675						LD676:
4405	.d675		28		plp		                plp
4406	.d676		60		rts		                rts

4408	.d677						LD678:
4409	.d677		48		pha		                pha
4410	.d678		38		sec		                sec
4411	.d679		b9 00 03	lda $0300,y	                lda $0300,y
4412	.d67c		fd 00 03	sbc $0300,x	                sbc $0300,x
4413	.d67f		48		pha		                pha
4414	.d680		b9 01 03	lda $0301,y	                lda $0301,y
4415	.d683		fd 01 03	sbc $0301,x	                sbc $0301,x
4416	.d686		7a		ply		                ply
4417	.d687		c9 80		cmp #$80	                cmp #$80
4418	.d689		90 03		bcc $d68e	                bcc LD68F
4419	.d68b		20 2e c9	jsr $c92e	                jsr negateAY
4420	.d68e						LD68F:
4421	.d68e		fa		plx		                plx
4422	.d68f		9d 01 03	sta $0301,x	                sta $0301,x
4423	.d692		98		tya		                tya
4424	.d693		9d 00 03	sta $0300,x	                sta $0300,x
4425	.d696		60		rts		                rts

4427	.d697						LD698:
4428	.d697		a2 37		ldx #$37	                ldx #$37
4429	.d699		20 22 d7	jsr $d722	                jsr LD723
4430	.d69c						LD69D:
4431	.d69c		3c 0a 03	bit $030a,x	                bit $030A,x
4432	.d69f		70 10		bvs $d6b1	                bvs LD6B2
4433	.d6a1		60		rts		                rts

4435	.d6a2						LD6A3:
4436	.d6a2		a2 2c		ldx #$2c	                ldx #$2C
4437	.d6a4		20 22 d7	jsr $d722	                jsr LD723
4438	.d6a7						LD6A8:
4439	.d6a7		3c 0a 03	bit $030a,x	                bit $030A,x
4440	.d6aa		50 05		bvc $d6b1	                bvc LD6B2
4441	.d6ac		60		rts		                rts

4443	.d6ad						LD6AE:
4444	.d6ad		fa		plx		                plx
4445	.d6ae		20 25 d7	jsr $d725	                jsr LD726
4446	.d6b1						LD6B2:
4447	.d6b1		bd 09 03	lda $0309,x	                lda $0309,x
4448	.d6b4		30 10		bmi $d6c6	                bmi LD6C7
4449	.d6b6		a0 03		ldy #$03	                ldy #$03
4450	.d6b8		da		phx		                phx
4451	.d6b9						LD6BA:
4452	.d6b9		bd 00 03	lda $0300,x	                lda $0300,x
4453	.d6bc		dd 1e 88	cmp $881e,x	                cmp L881E,x
4454	.d6bf		d0 ec		bne $d6ad	                bne LD6AE
4455	.d6c1		e8		inx		                inx
4456	.d6c2		88		dey		                dey
4457	.d6c3		10 f4		bpl $d6b9	                bpl LD6BA
4458	.d6c5		fa		plx		                plx
4459	.d6c6						LD6C7:
4460	.d6c6		60		rts		                rts

4462	.d6c7						LD6C8:
4463	.d6c7		20 fc d6	jsr $d6fc	                jsr LD6FD
4464	.d6ca		bd 0a 03	lda $030a,x	                lda $030A,x
4465	.d6cd		0a		asl a		                asl a
4466	.d6ce		0a		asl a		                asl a
4467	.d6cf		bd 0a 03	lda $030a,x	                lda $030A,x
4468	.d6d2		6a		ror a		                ror a
4469	.d6d3		85 da		sta $da		                sta $DA
4470	.d6d5		18		clc		                clc
4471	.d6d6		10 0f		bpl $d6e7	                bpl LD6E8
4472	.d6d8		bd 02 03	lda $0302,x	                lda $0302,x
4473	.d6db		ed 04 03	sbc $0304	                sbc $0304
4474	.d6de		a8		tay		                tay
4475	.d6df		bd 03 03	lda $0303,x	                lda $0303,x
4476	.d6e2		ed 05 03	sbc $0305	                sbc $0305
4477	.d6e5		80 0d		bra $d6f4	                bra LD6F5

4479	.d6e7						LD6E8:
4480	.d6e7		ad 00 03	lda $0300	                lda $0300
4481	.d6ea		fd 02 03	sbc $0302,x	                sbc $0302,x
4482	.d6ed		a8		tay		                tay
4483	.d6ee		ad 01 03	lda $0301	                lda $0301
4484	.d6f1		fd 03 03	sbc $0303,x	                sbc $0303,x
4485	.d6f4						LD6F5:
4486	.d6f4		20 a3 d7	jsr $d7a3	                jsr LD7A4
4487	.d6f7		20 fc d6	jsr $d6fc	                jsr LD6FD
4488	.d6fa		80 58		bra $d754	                bra LD755

4490	.d6fc						LD6FD:
4491	.d6fc		8a		txa		                txa
4492	.d6fd		1a		inc a		                inc a
4493	.d6fe		48		pha		                pha
4494	.d6ff		1a		inc a		                inc a
4495	.d700		a8		tay		                tay
4496	.d701		20 b0 e2	jsr $e2b0	                jsr exchangeTwoVDUBytes
4497	.d704		e8		inx		                inx
4498	.d705		e8		inx		                inx
4499	.d706		c8		iny		                iny
4500	.d707		c8		iny		                iny
4501	.d708		20 b0 e2	jsr $e2b0	                jsr exchangeTwoVDUBytes
4502	.d70b		fa		plx		                plx
4503	.d70c		20 10 d7	jsr $d710	                jsr LD711
4504	.d70f		ca		dex		                dex
4505	.d710						LD711:
4506	.d710		bd 08 03	lda $0308,x	                lda $0308,x
4507	.d713		49 ff		eor #$ff	                eor #$FF
4508	.d715		9d 08 03	sta $0308,x	                sta $0308,x
4509	.d718		60		rts		                rts

4511	.d719						LD71A:
4512	.d719		20 25 d7	jsr $d725	                jsr LD726
4513	.d71c						LD71D:
4514	.d71c		bd 09 03	lda $0309,x	                lda $0309,x
4515	.d71f		10 f8		bpl $d719	                bpl LD71A
4516	.d721		60		rts		                rts

4518	.d722						LD723:
4519	.d722		20 1c d7	jsr $d71c	                jsr LD71D
4520	.d725						LD726:
4521	.d725		bd 09 03	lda $0309,x	                lda $0309,x
4522	.d728		10 2a		bpl $d754	                bpl LD755
4523	.d72a						LD72B:
4524	.d72a		18		clc		                clc
4525	.d72b		bd 08 03	lda $0308,x	                lda $0308,x
4526	.d72e		7d 04 03	adc $0304,x	                adc $0304,x
4527	.d731		9d 08 03	sta $0308,x	                sta $0308,x
4528	.d734		bd 09 03	lda $0309,x	                lda $0309,x
4529	.d737		7d 05 03	adc $0305,x	                adc $0305,x
4530	.d73a		9d 09 03	sta $0309,x	                sta $0309,x
4531	.d73d		30 03		bmi $d742	                bmi LD743
4532	.d73f		20 54 d7	jsr $d754	                jsr LD755
4533	.d742						LD743:
4534	.d742		da		phx		                phx
4535	.d743		e8		inx		                inx
4536	.d744		e8		inx		                inx
4537	.d745		3c 08 03	bit $0308,x	                bit $0308,x
4538	.d748		30 23		bmi $d76d	                bmi LD76E
4539	.d74a						LD74B:
4540	.d74a		fe 00 03	inc $0300,x	                inc $0300,x
4541	.d74d		d0 03		bne $d752	                bne LD753
4542	.d74f		fe 01 03	inc $0301,x	                inc $0301,x
4543	.d752						LD753:
4544	.d752		fa		plx		                plx
4545	.d753		60		rts		                rts

4547	.d754						LD755:
4548	.d754		38		sec		                sec
4549	.d755		bd 08 03	lda $0308,x	                lda $0308,x
4550	.d758		fd 06 03	sbc $0306,x	                sbc $0306,x
4551	.d75b		9d 08 03	sta $0308,x	                sta $0308,x
4552	.d75e		bd 09 03	lda $0309,x	                lda $0309,x
4553	.d761		fd 07 03	sbc $0307,x	                sbc $0307,x
4554	.d764		9d 09 03	sta $0309,x	                sta $0309,x
4555	.d767		da		phx		                phx
4556	.d768		3c 0a 03	bit $030a,x	                bit $030A,x
4557	.d76b		50 dd		bvc $d74a	                bvc LD74B
4558	.d76d						LD76E:
4559	.d76d		bd 00 03	lda $0300,x	                lda $0300,x
4560	.d770		d0 03		bne $d775	                bne LD776
4561	.d772		de 01 03	dec $0301,x	                dec $0301,x
4562	.d775						LD776:
4563	.d775		de 00 03	dec $0300,x	                dec $0300,x
4564	.d778		fa		plx		                plx
4565	.d779		60		rts		                rts

4567	.d77a						LD77B:
4568	.d77a		18		clc		                clc
4569	.d77b		bd 0a 03	lda $030a,x	                lda $030A,x
4570	.d77e		85 da		sta $da		                sta $DA
4571	.d780		10 0f		bpl $d791	                bpl LD792
4572	.d782		bd 02 03	lda $0302,x	                lda $0302,x
4573	.d785		ed 06 03	sbc $0306	                sbc $0306
4574	.d788		a8		tay		                tay
4575	.d789		bd 03 03	lda $0303,x	                lda $0303,x
4576	.d78c		ed 07 03	sbc $0307	                sbc $0307
4577	.d78f		80 0d		bra $d79e	                bra LD79F

4579	.d791						LD792:
4580	.d791		ad 02 03	lda $0302	                lda $0302
4581	.d794		fd 02 03	sbc $0302,x	                sbc $0302,x
4582	.d797		a8		tay		                tay
4583	.d798		ad 03 03	lda $0303	                lda $0303
4584	.d79b		fd 03 03	sbc $0303,x	                sbc $0303,x
4585	.d79e						LD79F:
4586	.d79e		20 a3 d7	jsr $d7a3	                jsr LD7A4
4587	.d7a1		80 87		bra $d72a	                bra LD72B

4589	.d7a3						LD7A4:
4590	.d7a3		84 de		sty $de		                sty $DE
4591	.d7a5		85 df		sta $df		                sta $DF
4592	.d7a7		bd 02 03	lda $0302,x	                lda $0302,x
4593	.d7aa		bc 03 03	ldy $0303,x	                ldy $0303,x
4594	.d7ad		06 da		asl $da		                asl $DA
4595	.d7af		b0 0a		bcs $d7bb	                bcs LD7BC
4596	.d7b1		65 de		adc $de		                adc $DE
4597	.d7b3		9d 02 03	sta $0302,x	                sta $0302,x
4598	.d7b6		98		tya		                tya
4599	.d7b7		65 df		adc $df		                adc $DF
4600	.d7b9		80 08		bra $d7c3	                bra LD7C4

4602	.d7bb						LD7BC:
4603	.d7bb		e5 de		sbc $de		                sbc $DE
4604	.d7bd		9d 02 03	sta $0302,x	                sta $0302,x
4605	.d7c0		98		tya		                tya
4606	.d7c1		e5 df		sbc $df		                sbc $DF
4607	.d7c3						LD7C4:
4608	.d7c3		9d 03 03	sta $0303,x	                sta $0303,x
4609	.d7c6		a9 00		lda #$00	                lda #$00
4610	.d7c8		3c 09 03	bit $0309,x	                bit $0309,x
4611	.d7cb		10 01		bpl $d7ce	                bpl LD7CF
4612	.d7cd		3a		dec a		                dec a
4613	.d7ce						LD7CF:
4614	.d7ce		85 dc		sta $dc		                sta $DC
4615	.d7d0		4a		lsr a		                lsr a
4616	.d7d1		85 dd		sta $dd		                sta $DD
4617	.d7d3		a0 10		ldy #$10	                ldy #$10
4618	.d7d5						LD7D6:
4619	.d7d5		a5 dd		lda $dd		                lda $DD
4620	.d7d7		0a		asl a		                asl a
4621	.d7d8		3e 08 03	rol $0308,x	                rol $0308,x
4622	.d7db		3e 09 03	rol $0309,x	                rol $0309,x
4623	.d7de		26 dc		rol $dc		                rol $DC
4624	.d7e0		26 dd		rol $dd		                rol $DD
4625	.d7e2		06 de		asl $de		                asl $DE
4626	.d7e4		26 df		rol $df		                rol $DF
4627	.d7e6		90 19		bcc $d801	                bcc LD802
4628	.d7e8		18		clc		                clc
4629	.d7e9		a5 dc		lda $dc		                lda $DC
4630	.d7eb		7d 04 03	adc $0304,x	                adc $0304,x
4631	.d7ee		85 dc		sta $dc		                sta $DC
4632	.d7f0		a5 dd		lda $dd		                lda $DD
4633	.d7f2		7d 05 03	adc $0305,x	                adc $0305,x
4634	.d7f5		85 dd		sta $dd		                sta $DD
4635	.d7f7		90 08		bcc $d801	                bcc LD802
4636	.d7f9		fe 08 03	inc $0308,x	                inc $0308,x
4637	.d7fc		d0 03		bne $d801	                bne LD802
4638	.d7fe		fe 09 03	inc $0309,x	                inc $0309,x
4639	.d801						LD802:
4640	.d801		88		dey		                dey
4641	.d802		d0 d1		bne $d7d5	                bne LD7D6
4642	.d804		3c 09 03	bit $0309,x	                bit $0309,x
4643	.d807		50 0b		bvc $d814	                bvc LD815
4644	.d809		a5 dc		lda $dc		                lda $DC
4645	.d80b		9d 08 03	sta $0308,x	                sta $0308,x
4646	.d80e		a5 dd		lda $dd		                lda $DD
4647	.d810		9d 09 03	sta $0309,x	                sta $0309,x
4648	.d813		60		rts		                rts

4650	.d814						LD815:
4651	.d814		a0 10		ldy #$10	                ldy #$10
4652	.d816						LD817:
4653	.d816		26 dc		rol $dc		                rol $DC
4654	.d818		26 dd		rol $dd		                rol $DD
4655	.d81a		3e 08 03	rol $0308,x	                rol $0308,x
4656	.d81d		3e 09 03	rol $0309,x	                rol $0309,x
4657	.d820		38		sec		                sec
4658	.d821		bd 08 03	lda $0308,x	                lda $0308,x
4659	.d824		fd 06 03	sbc $0306,x	                sbc $0306,x
4660	.d827		85 de		sta $de		                sta $DE
4661	.d829		bd 09 03	lda $0309,x	                lda $0309,x
4662	.d82c		fd 07 03	sbc $0307,x	                sbc $0307,x
4663	.d82f		90 08		bcc $d839	                bcc LD83A
4664	.d831		9d 09 03	sta $0309,x	                sta $0309,x
4665	.d834		a5 de		lda $de		                lda $DE
4666	.d836		9d 08 03	sta $0308,x	                sta $0308,x
4667	.d839						LD83A:
4668	.d839		88		dey		                dey
4669	.d83a		d0 da		bne $d816	                bne LD817
4670	.d83c		26 dc		rol $dc		                rol $DC
4671	.d83e		26 dd		rol $dd		                rol $DD
4672	.d840		38		sec		                sec
4673	.d841		bd 08 03	lda $0308,x	                lda $0308,x
4674	.d844		fd 06 03	sbc $0306,x	                sbc $0306,x
4675	.d847		9d 08 03	sta $0308,x	                sta $0308,x
4676	.d84a		bd 09 03	lda $0309,x	                lda $0309,x
4677	.d84d		fd 07 03	sbc $0307,x	                sbc $0307,x
4678	.d850		9d 09 03	sta $0309,x	                sta $0309,x
4679	.d853		bd 00 03	lda $0300,x	                lda $0300,x
4680	.d856		bc 01 03	ldy $0301,x	                ldy $0301,x
4681	.d859		06 da		asl $da		                asl $DA
4682	.d85b		b0 0b		bcs $d868	                bcs LD869
4683	.d85d		38		sec		                sec
4684	.d85e		65 dc		adc $dc		                adc $DC
4685	.d860		9d 00 03	sta $0300,x	                sta $0300,x
4686	.d863		98		tya		                tya
4687	.d864		65 dd		adc $dd		                adc $DD
4688	.d866		80 09		bra $d871	                bra LD872

4690	.d868						LD869:
4691	.d868		18		clc		                clc
4692	.d869		e5 dc		sbc $dc		                sbc $DC
4693	.d86b		9d 00 03	sta $0300,x	                sta $0300,x
4694	.d86e		98		tya		                tya
4695	.d86f		e5 dd		sbc $dd		                sbc $DD
4696	.d871						LD872:
4697	.d871		9d 01 03	sta $0301,x	                sta $0301,x
4698	.d874						LD875:
4699	.d874		60		rts		                rts

4701	.d875						LD876:
4702	.d875		0e 32 03	asl $0332	                asl $0332
4703	.d878		a0 2c		ldy #$2c	                ldy #$2C
4704	.d87a		20 16 c9	jsr $c916	                jsr copyLastFourVDUQueueBytes
4705	.d87d		06 db		asl $db		                asl $DB
4706	.d87f		90 0d		bcc $d88e	                bcc LD88F
4707	.d881		20 25 da	jsr $da25	                jsr LDA26
4708	.d884		f0 ee		beq $d874	                beq LD875
4709	.d886		a2 00		ldx #$00	                ldx #$00
4710	.d888		ad 32 03	lda $0332	                lda $0332
4711	.d88b		20 0e da	jsr $da0e	                jsr LDA0F
4712	.d88e						LD88F:
4713	.d88e		24 db		bit $db		                bit $DB
4714	.d890		50 0f		bvc $d8a1	                bvc LD8A2
4715	.d892		20 25 da	jsr $da25	                jsr LDA26
4716	.d895		f0 dd		beq $d874	                beq LD875
4717	.d897		a2 04		ldx #$04	                ldx #$04
4718	.d899		ad 32 03	lda $0332	                lda $0332
4719	.d89c		49 80		eor #$80	                eor #$80
4720	.d89e		20 0e da	jsr $da0e	                jsr LDA0F
4721	.d8a1						LD8A2:
4722	.d8a1		a2 28		ldx #$28	                ldx #$28
4723	.d8a3		a0 2c		ldy #$2c	                ldy #$2C
4724	.d8a5		4c e7 da	jmp $dae7	                jmp LDAE8

4726	.d8a8						LD8A9:
4727	.d8a8		0a		asl a		                asl a
4728	.d8a9		0a		asl a		                asl a
4729	.d8aa		85 db		sta $db		                sta $DB
4730	.d8ac		29 c0		and #$c0	                and #$C0
4731	.d8ae		49 40		eor #$40	                eor #$40
4732	.d8b0		d0 06		bne $d8b8	                bne LD8B9
4733	.d8b2		ad 67 03	lda $0367	                lda $0367
4734	.d8b5		8d 68 03	sta $0368	                sta $0368
4735	.d8b8						LD8B9:
4736	.d8b8		20 a5 d1	jsr $d1a5	                jsr LD1A6
4737	.d8bb		85 dc		sta $dc		                sta $DC
4738	.d8bd		f0 04		beq $d8c3	                beq LD8C4
4739	.d8bf		a9 80		lda #$80	                lda #$80
4740	.d8c1		14 db		trb $db		                trb $DB
4741	.d8c3						LD8C4:
4742	.d8c3		a2 20		ldx #$20	                ldx #$20
4743	.d8c5		20 a7 d1	jsr $d1a7	                jsr windEntryPoint
4744	.d8c8		85 e0		sta $e0		                sta $E0
4745	.d8ca		f0 0a		beq $d8d6	                beq LD8D7
4746	.d8cc		aa		tax		                tax
4747	.d8cd		a9 20		lda #$20	                lda #$20
4748	.d8cf		14 db		trb $db		                trb $DB
4749	.d8d1		8a		txa		                txa
4750	.d8d2		24 dc		bit $dc		                bit $DC
4751	.d8d4						LD8D5:
4752	.d8d4		d0 9e		bne $d874	                bne LD875
4753	.d8d6						LD8D7:
4754	.d8d6		a0 24		ldy #$24	                ldy #$24
4755	.d8d8		a9 20		lda #$20	                lda #$20
4756	.d8da		a2 28		ldx #$28	                ldx #$28
4757	.d8dc		20 24 9b	jsr $9b24	                jsr L9B09
4758	.d8df		24 db		bit $db		                bit $DB
4759	.d8e1		70 08		bvs $d8eb	                bvs LD8EC
4760	.d8e3		ad 2e 03	lda $032e	                lda $032E
4761	.d8e6		0d 2f 03	ora $032f	                ora $032F
4762	.d8e9		f0 8a		beq $d875	                beq LD876
4763	.d8eb						LD8EC:
4764	.d8eb		a5 dc		lda $dc		                lda $DC
4765	.d8ed		89 0c		bit #$0c	                bit #$0C
4766	.d8ef		f0 0e		beq $d8ff	                beq LD900
4767	.d8f1		a2 28		ldx #$28	                ldx #$28
4768	.d8f3		20 7a d7	jsr $d77a	                jsr LD77B
4769	.d8f6		a2 28		ldx #$28	                ldx #$28
4770	.d8f8		20 a7 d1	jsr $d1a7	                jsr windEntryPoint
4771	.d8fb		24 e0		bit $e0		                bit $E0
4772	.d8fd		d0 d5		bne $d8d4	                bne LD8D5
4773	.d8ff						LD900:
4774	.d8ff		89 03		bit #$03	                bit #$03
4775	.d901		f0 0a		beq $d90d	                beq LD90E
4776	.d903		a2 28		ldx #$28	                ldx #$28
4777	.d905		20 c7 d6	jsr $d6c7	                jsr LD6C8
4778	.d908		a2 28		ldx #$28	                ldx #$28
4779	.d90a		20 a7 d1	jsr $d1a7	                jsr windEntryPoint
4780	.d90d						LD90E:
4781	.d90d		a8		tay		                tay
4782	.d90e		d0 c4		bne $d8d4	                bne LD8D5
4783	.d910		a0 20		ldy #$20	                ldy #$20
4784	.d912		a2 22		ldx #$22	                ldx #$22
4785	.d914		a5 e0		lda $e0		                lda $E0
4786	.d916		f0 0f		beq $d927	                beq LD928
4787	.d918		a0 04		ldy #$04	                ldy #$04
4788	.d91a		a2 06		ldx #$06	                ldx #$06
4789	.d91c		2c 32 03	bit $0332	                bit $0332
4790	.d91f		10 02		bpl $d923	                bpl LD924
4791	.d921		a2 02		ldx #$02	                ldx #$02
4792	.d923						LD924:
4793	.d923		50 02		bvc $d927	                bvc LD928
4794	.d925		a0 00		ldy #$00	                ldy #$00
4795	.d927						LD928:
4796	.d927		18		clc		                clc
4797	.d928		bd 00 03	lda $0300,x	                lda $0300,x
4798	.d92b		ed 2a 03	sbc $032a	                sbc $032A
4799	.d92e		90 03		bcc $d933	                bcc LD934
4800	.d930		1a		inc a		                inc a
4801	.d931		49 ff		eor #$ff	                eor #$FF
4802	.d933						LD934:
4803	.d933		85 dc		sta $dc		                sta $DC
4804	.d935		18		clc		                clc
4805	.d936		b9 00 03	lda $0300,y	                lda $0300,y
4806	.d939		ed 28 03	sbc $0328	                sbc $0328
4807	.d93c		aa		tax		                tax
4808	.d93d		b9 01 03	lda $0301,y	                lda $0301,y
4809	.d940		ed 29 03	sbc $0329	                sbc $0329
4810	.d943		30 0c		bmi $d951	                bmi LD952
4811	.d945		e8		inx		                inx
4812	.d946		d0 01		bne $d949	                bne LD94A
4813	.d948		1a		inc a		                inc a
4814	.d949						LD94A:
4815	.d949		49 ff		eor #$ff	                eor #$FF
4816	.d94b		a8		tay		                tay
4817	.d94c		8a		txa		                txa
4818	.d94d		49 ff		eor #$ff	                eor #$FF
4819	.d94f		aa		tax		                tax
4820	.d950		98		tya		                tya
4821	.d951						LD952:
4822	.d951		85 dd		sta $dd		                sta $DD
4823	.d953		86 e0		stx $e0		                stx $E0
4824	.d955		a2 28		ldx #$28	                ldx #$28
4825	.d957		20 41 df	jsr $df41	                jsr LDF41
4826	.d95a		06 db		asl $db		                asl $DB
4827	.d95c		b0 2a		bcs $d988	                bcs LD989
4828	.d95e						LD95F:
4829	.d95e		24 db		bit $db		                bit $DB
4830	.d960		50 0b		bvc $d96d	                bvc LD96E
4831	.d962		a5 e0		lda $e0		                lda $E0
4832	.d964		25 dc		and $dc		                and $DC
4833	.d966		25 dd		and $dd		                and $DD
4834	.d968		1a		inc a		                inc a
4835	.d969		f0 34		beq $d99f	                beq LD9A0
4836	.d96b		24 db		bit $db		                bit $DB
4837	.d96d						LD96E:
4838	.d96d		10 09		bpl $d978	                bpl LD979
4839	.d96f		ad 68 03	lda $0368	                lda $0368
4840	.d972		0a		asl a		                asl a
4841	.d973		2e 68 03	rol $0368	                rol $0368
4842	.d976		90 10		bcc $d988	                bcc LD989
4843	.d978						LD979:
4844	.d978		a5 d1		lda $d1		                lda ZMASK
4845	.d97a		25 d4		and $d4		                and ZGORA
4846	.d97c		11 d6		ora ($d6),y	                ora (ZMEMG),y
4847	.d97e		85 da		sta $da		                sta $DA
4848	.d980		a5 d1		lda $d1		                lda ZMASK
4849	.d982		25 d5		and $d5		                and ZGEOR
4850	.d984		45 da		eor $da		                eor $DA
4851	.d986		91 d6		sta ($d6),y	                sta (ZMEMG),y
4852	.d988						LD989:
4853	.d988		ad 31 03	lda $0331	                lda $0331
4854	.d98b		10 4e		bpl $d9db	                bpl LD9DC
4855	.d98d		e6 dc		inc $dc		                inc $DC
4856	.d98f		f0 0e		beq $d99f	                beq LD9A0
4857	.d991		2c 32 03	bit $0332	                bit $0332
4858	.d994		30 0a		bmi $d9a0	                bmi LD9A1
4859	.d996		88		dey		                dey
4860	.d997		ca		dex		                dex
4861	.d998		10 24		bpl $d9be	                bpl LD9BF
4862	.d99a		20 4b da	jsr $da4b	                jsr LDA4C
4863	.d99d		80 1f		bra $d9be	                bra LD9BF

4865	.d99f						LD9A0:
4866	.d99f		60		rts		                rts

4868	.d9a0						LD9A1:
4869	.d9a0		c8		iny		                iny
4870	.d9a1		e8		inx		                inx
4871	.d9a2		e0 08		cpx #$08	                cpx #$08
4872	.d9a4		d0 18		bne $d9be	                bne LD9BF
4873	.d9a6		38		sec		                sec
4874	.d9a7		98		tya		                tya
4875	.d9a8		e9 08		sbc #$08	                sbc #$08
4876	.d9aa		18		clc		                clc
4877	.d9ab		6d 52 03	adc $0352	                adc $0352
4878	.d9ae		a8		tay		                tay
4879	.d9af		a5 d7		lda $d7		                lda ZMEMG+1
4880	.d9b1		6d 53 03	adc $0353	                adc $0353
4881	.d9b4		10 04		bpl $d9ba	                bpl LD9BB
4882	.d9b6		38		sec		                sec
4883	.d9b7		ed 54 03	sbc $0354	                sbc $0354
4884	.d9ba						LD9BB:
4885	.d9ba		85 d7		sta $d7		                sta ZMEMG+1
4886	.d9bc		a2 00		ldx #$00	                ldx #$00
4887	.d9be						LD9BF:
4888	.d9be		ad 69 03	lda $0369	                lda $0369
4889	.d9c1		f0 03		beq $d9c6	                beq LD9C7
4890	.d9c3		20 7b da	jsr $da7b	                jsr setupColourMasks
4891	.d9c6						LD9C7:
4892	.d9c6		18		clc		                clc
4893	.d9c7		ad 30 03	lda $0330	                lda $0330
4894	.d9ca		6d 2c 03	adc $032c	                adc $032C
4895	.d9cd		8d 30 03	sta $0330	                sta $0330
4896	.d9d0		ad 31 03	lda $0331	                lda $0331
4897	.d9d3		6d 2d 03	adc $032d	                adc $032D
4898	.d9d6		8d 31 03	sta $0331	                sta $0331
4899	.d9d9		30 83		bmi $d95e	                bmi LD95F
4900	.d9db						LD9DC:
4901	.d9db		e6 e0		inc $e0		                inc $E0
4902	.d9dd		d0 04		bne $d9e3	                bne LD9E4
4903	.d9df		e6 dd		inc $dd		                inc $DD
4904	.d9e1		f0 bc		beq $d99f	                beq LD9A0
4905	.d9e3						LD9E4:
4906	.d9e3		2c 32 03	bit $0332	                bit $0332
4907	.d9e6		70 09		bvs $d9f1	                bvs LD9F2
4908	.d9e8		46 d1		lsr $d1		                lsr ZMASK
4909	.d9ea		90 0c		bcc $d9f8	                bcc LD9F9
4910	.d9ec		20 66 da	jsr $da66	                jsr nextColumnAndResetMask
4911	.d9ef		80 07		bra $d9f8	                bra LD9F9

4913	.d9f1						LD9F2:
4914	.d9f1		06 d1		asl $d1		                asl ZMASK
4915	.d9f3		90 03		bcc $d9f8	                bcc LD9F9
4916	.d9f5		20 33 da	jsr $da33	                jsr previousColumnAndResetMask
4917	.d9f8						LD9F9:
4918	.d9f8		38		sec		                sec
4919	.d9f9		ad 30 03	lda $0330	                lda $0330
4920	.d9fc		ed 2e 03	sbc $032e	                sbc $032E
4921	.d9ff		8d 30 03	sta $0330	                sta $0330
4922	.da02		ad 31 03	lda $0331	                lda $0331
4923	.da05		ed 2f 03	sbc $032f	                sbc $032F
4924	.da08		8d 31 03	sta $0331	                sta $0331
4925	.da0b		4c 5e d9	jmp $d95e	                jmp LD95F

4927	.da0e						LDA0F:
4928	.da0e		30 09		bmi $da19	                bmi LDA1A
4929	.da10		fe 28 03	inc $0328,x	                inc $0328,x
4930	.da13		d0 0f		bne $da24	                bne LDA25
4931	.da15		fe 29 03	inc $0329,x	                inc $0329,x
4932	.da18		60		rts		                rts

4934	.da19						LDA1A:
4935	.da19		bd 28 03	lda $0328,x	                lda $0328,x
4936	.da1c		d0 03		bne $da21	                bne LDA22
4937	.da1e		de 29 03	dec $0329,x	                dec $0329,x
4938	.da21						LDA22:
4939	.da21		de 28 03	dec $0328,x	                dec $0328,x
4940	.da24						LDA25:
4941	.da24		60		rts		                rts

4943	.da25						LDA26:
4944	.da25		a0 04		ldy #$04	                ldy #$04
4945	.da27						LDA28:
4946	.da27		b9 27 03	lda $0327,y	                lda $0327,y
4947	.da2a		d9 2b 03	cmp $032b,y	                cmp $032B,y
4948	.da2d		d0 03		bne $da32	                bne LDA33
4949	.da2f		88		dey		                dey
4950	.da30		d0 f5		bne $da27	                bne LDA28
4951	.da32						LDA33:
4952	.da32		60		rts		                rts

4954							;-------------------------------------------------------------------------

4956	.da33						previousColumnAndResetMask:
4957	.da33		ad 63 03	lda $0363	                lda vduv.colourMaskRight
4958	.da36		85 d1		sta $d1		                sta ZMASK
4959	.da38		98		tya		                tya
4960	.da39		e9 08		sbc #$08	                sbc #$08
4961	.da3b		a8		tay		                tay
4962	.da3c		b0 0c		bcs $da4a	                bcs rtsDA4B
4963	.da3e		a5 d7		lda $d7		                lda ZMEMG+1
4964	.da40		3a		dec a		                dec a
4965	.da41		cd 4e 03	cmp $034e	                cmp vduv.startScreenAddressHighByte
4966	.da44		b0 02		bcs $da48	                bcs +
4967	.da46		a9 7f		lda #$7f	                lda #$7F
4968	.da48						+
4969	.da48		85 d7		sta $d7		                sta ZMEMG+1
4970	.da4a						rtsDA4B:
4971	.da4a		60		rts		                rts

4973							;-------------------------------------------------------------------------

4975	.da4b						LDA4C:
4976	.da4b		18		clc		                clc
4977	.da4c		98		tya		                tya
4978	.da4d		69 08		adc #$08	                adc #$08
4979	.da4f		38		sec		                sec
4980	.da50		ed 52 03	sbc $0352	                sbc $0352
4981	.da53		a8		tay		                tay
4982	.da54		a5 d7		lda $d7		                lda ZMEMG+1
4983	.da56		ed 53 03	sbc $0353	                sbc $0353
4984	.da59		cd 4e 03	cmp $034e	                cmp $034E
4985	.da5c		b0 03		bcs $da61	                bcs LDA62
4986	.da5e		6d 54 03	adc $0354	                adc $0354
4987	.da61						LDA62:
4988	.da61		85 d7		sta $d7		                sta ZMEMG+1
4989	.da63		a2 07		ldx #$07	                ldx #$07
4990	.da65		60		rts		                rts

4992							;-------------------------------------------------------------------------
4993							;
4994	.da66						nextColumnAndResetMask:
4995	.da66		ad 62 03	lda $0362	                lda vduv.colourMaskLeft
4996	.da69		85 d1		sta $d1		                sta ZMASK

4998							;-------------------------------------------------------------------------
4999							;
5000							; Add 8 to (ZMEMG),Y, taking into account screen wrap.
5001							;
5002							; entry:
5003							;
5004							; C=1
5005							;
5006							; (ZMEMG),Y = screen address
5007							;
5008							; exit:
5009							;
5010							; (ZMEMG),Y = new screen address
5011							;
5012	.da6b						nextColumn:
5013	.da6b		98		tya		                tya
5014	.da6c		69 07		adc #$07	                adc #$07
5015	.da6e		a8		tay		                tay
5016	.da6f		90 09		bcc $da7a	                bcc +
5017	.da71		e6 d7		inc $d7		                inc ZMEMG+1
5018	.da73		10 05		bpl $da7a	                bpl +
5019	.da75		ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
5020	.da78		85 d7		sta $d7		                sta ZMEMG+1
5021	.da7a						+
5022	.da7a		60		rts		                rts

5024							;-------------------------------------------------------------------------
5025							;
5026							; Set up colour masks, taking into account ECF pattern.
5027							;
5028							; entry:
5029							;
5030							; X = scanline in row, 0-7
5031							;
5032	.da7b						setupColourMasks:
5033	.da7b		da		phx		                phx                          ;save scanline
5034	.da7c		8a		txa		                txa                          ;A=scanline
5035	.da7d		0d 59 03	ora $0359	                ora vduv.graphicsPlotState   ;0-7 if fg, 8-15 if bg
5036	.da80		aa		tax		                tax
5037	.da81		bd 20 88	lda $8820,x	                lda andy.fgECFPattern,x      ;get appropriate ECF byte
5038	.da84		ae 5a 03	ldx $035a	                ldx vduv.graphicsPlotMode
5039	.da87		48		pha		                pha
5040	.da88		1d 42 e1	ora $e142,x	                ora zgoraORTable,x
5041	.da8b		5d 43 e1	eor $e143,x	                eor zgoraEORTable,x
5042	.da8e		85 d4		sta $d4		                sta ZGORA
5043	.da90		68		pla		                pla
5044	.da91		1d 41 e1	ora $e141,x	                ora zgeorORTable,x
5045	.da94		5d 46 e1	eor $e146,x	                eor zgeorEORTable,x
5046	.da97		85 d5		sta $d5		                sta ZGEOR
5047	.da99		fa		plx		                plx
5048	.da9a		60		rts		                rts

5050							;-------------------------------------------------------------------------

5052	.da9b						LDA9C:
5053	.da9b		b9 01 03	lda $0301,y	                lda $0301,y
5054	.da9e		48		pha		                pha
5055	.da9f		b9 00 03	lda $0300,y	                lda $0300,y
5056	.daa2		48		pha		                pha
5057	.daa3		2d 61 03	and $0361	                and $0361
5058	.daa6		18		clc		                clc
5059	.daa7		6d 61 03	adc $0361	                adc $0361
5060	.daaa		a8		tay		                tay
5061	.daab		b9 2c e1	lda $e12c,y	                lda pixelMasks-1,y
5062	.daae		59 1e e1	eor $e11e,y	                eor LE120,y
5063	.dab1		85 dc		sta $dc		                sta $DC
5064	.dab3		bd 00 03	lda $0300,x	                lda $0300,x
5065	.dab6		2d 61 03	and $0361	                and $0361
5066	.dab9		6d 61 03	adc $0361	                adc $0361
5067	.dabc		a8		tay		                tay
5068	.dabd		b9 1e e1	lda $e11e,y	                lda LE120,y
5069	.dac0		85 d1		sta $d1		                sta ZMASK
5070	.dac2		38		sec		                sec
5071	.dac3		68		pla		                pla
5072	.dac4		0d 61 03	ora $0361	                ora $0361
5073	.dac7		fd 00 03	sbc $0300,x	                sbc $0300,x
5074	.daca		a8		tay		                tay
5075	.dacb		68		pla		                pla
5076	.dacc		fd 01 03	sbc $0301,x	                sbc $0301,x
5077	.dacf		85 dd		sta $dd		                sta $DD
5078	.dad1		98		tya		                tya
5079	.dad2		ac 61 03	ldy $0361	                ldy $0361
5080	.dad5		c0 03		cpy #$03	                cpy #$03
5081	.dad7		f0 05		beq $dade	                beq LDADF
5082	.dad9		90 06		bcc $dae1	                bcc LDAE2
5083	.dadb		46 dd		lsr $dd		                lsr $DD
5084	.dadd		6a		ror a		                ror a
5085	.dade						LDADF:
5086	.dade		46 dd		lsr $dd		                lsr $DD
5087	.dae0		6a		ror a		                ror a
5088	.dae1						LDAE2:
5089	.dae1		4a		lsr a		                lsr a
5090	.dae2						LDAE3:
5091	.dae2		60		rts		                rts

5093	.dae3						LDAE4:                                       ; fillRow?
5094	.dae3		a2 42		ldx #$42	                ldx #$42
5095	.dae5		a0 46		ldy #$46	                ldy #$46
5096	.dae7						LDAE8:                                       ; fillRowInternal?
5097	.dae7		20 cb d5	jsr $d5cb	                jsr sortVDUVariableWords
5098	.daea		86 de		stx $de		                stx $DE
5099	.daec		84 df		sty $df		                sty $DF
5100	.daee		a6 df		ldx $df		                ldx $DF
5101	.daf0		a0 00		ldy #$00	                ldy #$00
5102	.daf2		20 b6 d1	jsr $d1b6	                jsr getOutcodeForAxis
5103	.daf5		f0 07		beq $dafe	                beq LDAFF
5104	.daf7		4a		lsr a		                lsr a
5105	.daf8		f0 e8		beq $dae2	                beq LDAE3
5106	.dafa		a2 04		ldx #$04	                ldx #$04
5107	.dafc		86 df		stx $df		                stx $DF
5108	.dafe						LDAFF:
5109	.dafe		a6 de		ldx $de		                ldx $DE
5110	.db00		20 a7 d1	jsr $d1a7	                jsr windEntryPoint
5111	.db03		4a		lsr a		                lsr a
5112	.db04		d0 dc		bne $dae2	                bne LDAE3
5113	.db06		bd 02 03	lda $0302,x	                lda $0302,x
5114	.db09		90 04		bcc $db0f	                bcc LDB10
5115	.db0b		a2 00		ldx #$00	                ldx #$00
5116	.db0d		86 de		stx $de		                stx $DE
5117	.db0f						LDB10:
5118	.db0f		20 cb de	jsr $decb	                jsr LDECB
5119	.db12		a6 de		ldx $de		                ldx $DE
5120	.db14		a4 df		ldy $df		                ldy $DF
5121	.db16		20 9b da	jsr $da9b	                jsr LDA9C
5122	.db19		aa		tax		                tax
5123	.db1a		ac 1a 03	ldy $031a	                ldy $031A
5124	.db1d		8a		txa		                txa
5125	.db1e		f0 23		beq $db43	                beq LDB44
5126	.db20		20 50 db	jsr $db50	                jsr plbyteEntryPoint
5127	.db23		80 08		bra $db2d	                bra LDB2E

5129	.db25						LDB26:
5130	.db25		b1 d6		lda ($d6),y	                lda (ZMEMG),y
5131	.db27		05 d4		ora $d4		                ora ZGORA
5132	.db29		45 d5		eor $d5		                eor ZGEOR
5133	.db2b		91 d6		sta ($d6),y	                sta (ZMEMG),y
5134	.db2d						LDB2E:
5135	.db2d		98		tya		                tya
5136	.db2e		18		clc		                clc
5137	.db2f		69 08		adc #$08	                adc #$08
5138	.db31		a8		tay		                tay
5139	.db32		90 09		bcc $db3d	                bcc LDB3E
5140	.db34		e6 d7		inc $d7		                inc ZMEMG+1
5141	.db36		10 05		bpl $db3d	                bpl LDB3E
5142	.db38		ad 4e 03	lda $034e	                lda $034E
5143	.db3b		85 d7		sta $d7		                sta ZMEMG+1
5144	.db3d						LDB3E:
5145	.db3d		ca		dex		                dex
5146	.db3e		d0 e5		bne $db25	                bne LDB26
5147	.db40		ca		dex		                dex
5148	.db41		86 d1		stx $d1		                stx ZMASK
5149	.db43						LDB44:
5150	.db43		a5 dc		lda $dc		                lda $DC
5151	.db45		14 d1		trb $d1		                trb ZMASK
5152	.db47		80 07		bra $db50	                bra plbyteEntryPoint

5154							;-------------------------------------------------------------------------
5155							;
5156							; mem mask ora eor | result
5157							; --- ---- --- --- | ------
5158							;  0    0   0   0  |   0
5159							;  0    0   0   1  |   0
5160							;  0    0   1   0  |   0
5161							;  0    0   1   1  |   0
5162							;  0    1   0   0  |   0
5163							;  0    1   0   1  |   1
5164							;  0    1   1   0  |   1
5165							;  0    1   1   1  |   0
5166							;  1    0   0   0  |   1
5167							;  1    0   0   1  |   1
5168							;  1    0   1   0  |   1
5169							;  1    0   1   1  |   1
5170							;  1    1   0   0  |   1
5171							;  1    1   0   1  |   0
5172							;  1    1   1   0  |   1
5173							;  1    1   1   1  |   0
5174							;
5175	.db49						plotPoint:
5176	.db49		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
5177	.db4b						plotPointInternal:
5178	.db4b		20 c3 de	jsr $dec3	                jsr windGADDR
5179	.db4e		d0 10		bne $db60	                bne rtsDB61                  ;taken if point outside window
5180	.db50						plbyteEntryPoint:
5181	.db50		a5 d1		lda $d1		                lda ZMASK
5182	.db52		25 d4		and $d4		                and ZGORA
5183	.db54		11 d6		ora ($d6),y	                ora (ZMEMG),y
5184	.db56		85 da		sta $da		                sta ZTEMP+0
5185	.db58		a5 d5		lda $d5		                lda ZGEOR
5186	.db5a		25 d1		and $d1		                and ZMASK
5187	.db5c		45 da		eor $da		                eor ZTEMP+0
5188	.db5e						oswrscCode:
5189	.db5e		91 d6		sta ($d6),y	                sta (ZMEMG),y
5190	.db60						rtsDB61:
5191	.db60		60		rts		                rts

5193							;-------------------------------------------------------------------------

5195	.db61						LDB62:
5196	.db61		a2 2a		ldx #$2a	                ldx #VDUVariables.workspace._2A
5197	.db63		a0 32		ldy #$32	                ldy #VDUVariables.workspace._32
5198	.db65		20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
5199	.db68		a2 36		ldx #$36	                ldx #VDUVariables.workspace._36
5200	.db6a		a0 3e		ldy #$3e	                ldy #VDUVariables.workspace._3E
5201	.db6c		20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
5202	.db6f		a2 2a		ldx #$2a	                ldx #$2A
5203	.db71		20 b4 d1	jsr $d1b4	                jsr getOutcodeForYAxis
5204	.db74		48		pha		                pha
5205	.db75		a2 36		ldx #$36	                ldx #$36
5206	.db77		20 b4 d1	jsr $d1b4	                jsr getOutcodeForYAxis
5207	.db7a		f0 0f		beq $db8b	                beq LDB8C
5208	.db7c		68		pla		                pla
5209	.db7d		d0 05		bne $db84	                bne LDB85
5210	.db7f		ad 45 03	lda $0345	                lda $0345
5211	.db82		f0 01		beq $db85	                beq LDB86
5212	.db84						LDB85:
5213	.db84		60		rts		                rts

5215	.db85						LDB86:
5216	.db85		a2 28		ldx #$28	                ldx #$28
5217	.db87		a0 2c		ldy #$2c	                ldy #$2C
5218	.db89		80 07		bra $db92	                bra LDB93

5220	.db8b						LDB8C:
5221	.db8b		68		pla		                pla
5222	.db8c		f0 07		beq $db95	                beq LDB96
5223	.db8e		a2 34		ldx #$34	                ldx #$34
5224	.db90		a0 38		ldy #$38	                ldy #$38
5225	.db92						LDB93:
5226	.db92		4c e7 da	jmp $dae7	                jmp LDAE8

5228	.db95						LDB96:
5229	.db95		a2 30		ldx #$30	                ldx #$30
5230	.db97		20 c8 de	jsr $dec8	                jsr gaddrEntryPoint
5231	.db9a		2c 47 03	bit $0347	                bit $0347
5232	.db9d		30 09		bmi $dba8	                bmi LDBA9
5233	.db9f		98		tya		                tya
5234	.dba0		38		sec		                sec
5235	.dba1		e9 08		sbc #$08	                sbc #$08
5236	.dba3		a8		tay		                tay
5237	.dba4		b0 02		bcs $dba8	                bcs LDBA9
5238	.dba6		c6 d7		dec $d7		                dec ZMEMG+1
5239	.dba8						LDBA9:
5240	.dba8		ad 44 03	lda $0344	                lda $0344
5241	.dbab		85 dd		sta $dd		                sta $DD
5242	.dbad						LDBAE:
5243	.dbad		b1 d6		lda ($d6),y	                lda (ZMEMG),y
5244	.dbaf		ae 42 03	ldx $0342	                ldx $0342
5245	.dbb2		f0 04		beq $dbb8	                beq LDBB9
5246	.dbb4						LDBB5:
5247	.dbb4		0a		asl a		                asl a
5248	.dbb5		ca		dex		                dex
5249	.dbb6		d0 fc		bne $dbb4	                bne LDBB5
5250	.dbb8						LDBB9:
5251	.dbb8		85 da		sta $da		                sta $DA
5252	.dbba		38		sec		                sec
5253	.dbbb		20 6b da	jsr $da6b	                jsr nextColumn
5254	.dbbe		b1 d6		lda ($d6),y	                lda (ZMEMG),y
5255	.dbc0		ae 43 03	ldx $0343	                ldx $0343
5256	.dbc3		f0 04		beq $dbc9	                beq LDBCA
5257	.dbc5						LDBC6:
5258	.dbc5		4a		lsr a		                lsr a
5259	.dbc6		ca		dex		                dex
5260	.dbc7		d0 fc		bne $dbc5	                bne LDBC6
5261	.dbc9						LDBCA:
5262	.dbc9		45 da		eor $da		                eor $DA
5263	.dbcb		25 e1		and $e1		                and $E1
5264	.dbcd		45 da		eor $da		                eor $DA
5265	.dbcf		a6 dd		ldx $dd		                ldx $DD
5266	.dbd1		9d 30 88	sta $8830,x	                sta L8830,x
5267	.dbd4		c6 dd		dec $dd		                dec $DD
5268	.dbd6		10 d5		bpl $dbad	                bpl LDBAE
5269	.dbd8		a2 34		ldx #$34	                ldx #$34
5270	.dbda		a0 38		ldy #$38	                ldy #$38
5271	.dbdc		20 e7 da	jsr $dae7	                jsr LDAE8
5272	.dbdf		ad 45 03	lda $0345	                lda $0345
5273	.dbe2		d0 03		bne $dbe7	                bne LDBE8
5274	.dbe4		20 85 db	jsr $db85	                jsr LDB86
5275	.dbe7						LDBE8:
5276	.dbe7		a2 3c		ldx #$3c	                ldx #$3C
5277	.dbe9		20 c8 de	jsr $dec8	                jsr gaddrEntryPoint
5278	.dbec		ad 46 03	lda $0346	                lda $0346
5279	.dbef		85 da		sta $da		                sta $DA
5280	.dbf1		ae 44 03	ldx $0344	                ldx $0344
5281	.dbf4		f0 15		beq $dc0b	                beq LDC0C
5282	.dbf6		20 0f dc	jsr $dc0f	                jsr LDC10
5283	.dbf9		a9 ff		lda #$ff	                lda #$FF
5284	.dbfb		85 da		sta $da		                sta $DA
5285	.dbfd		80 05		bra $dc04	                bra LDC05

5287	.dbff						LDC00_code:
5288	.dbff		bd 30 88	lda $8830,x	                lda L8830,x
5289	.dc02		91 d6		sta ($d6),y	                sta (ZMEMG),y
5290	.dc04						LDC05:
5291	.dc04		38		sec		                sec
5292	.dc05		20 6b da	jsr $da6b	                jsr nextColumn
5293	.dc08		ca		dex		                dex
5294	.dc09		d0 f4		bne $dbff	                bne LDC00_code
5295	.dc0b						LDC0C:
5296	.dc0b		a5 e0		lda $e0		                lda $E0
5297	.dc0d		14 da		trb $da		                trb $DA
5298	.dc0f						LDC10:
5299	.dc0f		bd 30 88	lda $8830,x	                lda L8830,x
5300	.dc12		51 d6		eor ($d6),y	                eor (ZMEMG),y
5301	.dc14		25 da		and $da		                and $DA
5302	.dc16		51 d6		eor ($d6),y	                eor (ZMEMG),y
5303	.dc18		91 d6		sta ($d6),y	                sta (ZMEMG),y
5304	.dc1a		60		rts		                rts

5306	.dc1b						LDC1C:
5307	.dc1b		ad 37 03	lda $0337	                lda $0337
5308	.dc1e		1a		inc a		                inc a
5309	.dc1f		cd 36 03	cmp $0336	                cmp $0336
5310	.dc22		f0 22		beq $dc46	                beq LDC47
5311	.dc24		8d 37 03	sta $0337	                sta $0337
5312	.dc27		aa		tax		                tax
5313	.dc28		ad 2e 03	lda $032e	                lda $032E
5314	.dc2b		9d 00 84	sta $8400,x	                sta L8400,x
5315	.dc2e		ad 32 03	lda $0332	                lda $0332
5316	.dc31		9d 00 85	sta $8500,x	                sta L8500,x
5317	.dc34		ad 2f 03	lda $032f	                lda $032F
5318	.dc37		0a		asl a		                asl a
5319	.dc38		0a		asl a		                asl a
5320	.dc39		0d 33 03	ora $0333	                ora $0333
5321	.dc3c		9d 00 86	sta $8600,x	                sta L8600,x
5322	.dc3f		ad 30 03	lda $0330	                lda $0330
5323	.dc42		9d 00 87	sta $8700,x	                sta L8700,x
5324	.dc45						LDC46:
5325	.dc45		18		clc		                clc
5326	.dc46						LDC47:
5327	.dc46		60		rts		                rts

5329	.dc47						LDC48:
5330	.dc47		8d 2a 03	sta $032a	                sta $032A
5331	.dc4a		a2 28		ldx #$28	                ldx #$28
5332	.dc4c		20 af dc	jsr $dcaf	                jsr LDCB0
5333	.dc4f		d0 0a		bne $dc5b	                bne LDC5C
5334	.dc51						LDC52:
5335	.dc51		20 1b dc	jsr $dc1b	                jsr LDC1C
5336	.dc54		b0 f0		bcs $dc46	                bcs LDC47
5337	.dc56		20 72 9d	jsr $9d72	                jsr L9D57
5338	.dc59		b0 ea		bcs $dc45	                bcs LDC46
5339	.dc5b						LDC5C:
5340	.dc5b		20 c0 dc	jsr $dcc0	                jsr LDCC1
5341	.dc5e		20 72 9d	jsr $9d72	                jsr L9D57
5342	.dc61		b0 e2		bcs $dc45	                bcs LDC46
5343	.dc63		20 d6 dc	jsr $dcd6	                jsr LDCD7
5344	.dc66		20 b7 dc	jsr $dcb7	                jsr LDCB8
5345	.dc69		80 e6		bra $dc51	                bra LDC52

5347							;-------------------------------------------------------------------------
5348							;
5349							; 72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
5350							; 88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
5351							; 104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
5352							; 120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
5353							;
5354	.dc6b						plotHorizontalLineFill:
5355	.dc6b		20 9e dd	jsr $dd9e	                jsr copyECFPatternForLineFill
5356	.dc6e		20 af dc	jsr $dcaf	                jsr LDCB0
5357	.dc71		18		clc		                clc
5358	.dc72		80 0e		bra $dc82	                bra LDC83

5360	.dc74						plotHorizontalLineFillRight:
5361	.dc74		20 9e dd	jsr $dd9e	                jsr copyECFPatternForLineFill
5362	.dc77		20 c8 dc	jsr $dcc8	                jsr LDCC9
5363	.dc7a		20 d1 dc	jsr $dcd1	                jsr LDCD2
5364	.dc7d		d0 03		bne $dc82	                bne LDC83
5365	.dc7f		20 b7 dc	jsr $dcb7	                jsr LDCB8
5366	.dc82						LDC83:
5367	.dc82		08		php		                php
5368	.dc83		a2 2e		ldx #$2e	                ldx #VDUVariables.hlfw.pixelsX
5369	.dc85		a0 14		ldy #$14	                ldy #VDUVariables.oldGraphicsCursorPixelsX
5370	.dc87		20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
5371	.dc8a		28		plp		                plp
5372	.dc8b		08		php		                php
5373	.dc8c		f0 02		beq $dc90	                beq LDC91
5374	.dc8e		a2 2e		ldx #$2e	                ldx #VDUVariables.hlfw.pixelsX
5375	.dc90						LDC91:
5376	.dc90		a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixelsX
5377	.dc92		20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
5378	.dc95		a2 30		ldx #$30	                ldx #VDUVariables.hlfw.pixelsY
5379	.dc97		20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
5380	.dc9a		28		plp		                plp
5381	.dc9b		f0 05		beq $dca2	                beq LDCA3
5382	.dc9d		b0 04		bcs $dca3	                bcs LDCA4
5383	.dc9f		ee 16 03	inc $0316	                inc $0316
5384	.dca2						LDCA3:
5385	.dca2		60		rts		                rts

5387	.dca3						LDCA4:
5388	.dca3		ad 24 03	lda $0324	                lda $0324
5389	.dca6		d0 03		bne $dcab	                bne LDCAC
5390	.dca8		ce 25 03	dec $0325	                dec $0325
5391	.dcab						LDCAC:
5392	.dcab		ce 24 03	dec $0324	                dec $0324
5393	.dcae		60		rts		                rts

5395							;-------------------------------------------------------------------------

5397	.dcaf						LDCB0:
5398	.dcaf		20 d1 dc	jsr $dcd1	                jsr LDCD2
5399	.dcb2		d0 55		bne $dd09	                bne rtsDD0A
5400	.dcb4		20 0a dd	jsr $dd0a	                jsr LDD0B
5401	.dcb7						LDCB8:
5402	.dcb7		a2 2e		ldx #$2e	                ldx #$2E
5403	.dcb9		a0 32		ldy #$32	                ldy #$32
5404	.dcbb		20 e7 da	jsr $dae7	                jsr LDAE8
5405	.dcbe		80 46		bra $dd06	                bra LDD07

5407	.dcc0						LDCC1:
5408	.dcc0		20 c8 dc	jsr $dcc8	                jsr LDCC9
5409	.dcc3		a2 2c		ldx #$2c	                ldx #$2C
5410	.dcc5		20 d8 dc	jsr $dcd8	                jsr LDCD9
5411	.dcc8						LDCC9:
5412	.dcc8		08		php		                php
5413	.dcc9		a5 e1		lda $e1		                lda $E1
5414	.dccb		49 08		eor #$08	                eor #$08
5415	.dccd		85 e1		sta $e1		                sta $E1
5416	.dccf		28		plp		                plp
5417	.dcd0		60		rts		                rts

5419							;-------------------------------------------------------------------------

5421	.dcd1						LDCD2:
5422	.dcd1		a0 2e		ldy #$2e	                ldy #VDUVariables.hlfw.pixelsX
5423	.dcd3		20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
5424	.dcd6						LDCD7:
5425	.dcd6		a2 04		ldx #$04	                ldx #VDUVariables.graphicsWindowPixelsRight
5426	.dcd8						LDCD9:
5427	.dcd8		a0 34		ldy #$34	                ldy #VDUVariables.hlfw.pixelsLimitX
5428	.dcda		20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
5429	.dcdd		a2 34		ldx #$34	                ldx #VDUVariables.hlfw.pixelsLimitX
5430	.dcdf		20 34 dd	jsr $dd34	                jsr shouldFillPixel
5431	.dce2		d0 25		bne $dd09	                bne rtsDD0A  ;taken if pixel not to be filled, so done
5432	.dce4						LDCE5:
5433	.dce4		46 d1		lsr $d1		                lsr ZMASK                    ;next pixel
5434	.dce6		90 08		bcc $dcf0	                bcc LDCF1                    ;taken if still in same byte
5435	.dce8						LDCE9:
5436	.dce8		20 66 da	jsr $da66	                jsr nextColumnAndResetMask
5437	.dceb		20 64 dd	jsr $dd64	                jsr shouldFillByte
5438	.dcee		b0 f8		bcs $dce8	                bcs LDCE9
5439	.dcf0						LDCF1:
5440	.dcf0		20 84 dd	jsr $dd84	                jsr LDD85
5441	.dcf3		b0 ef		bcs $dce4	                bcs LDCE5
5442	.dcf5		38		sec		                sec
5443	.dcf6		ad 34 03	lda $0334	                lda vduv.hlfw.pixelsLimitX+0
5444	.dcf9		e5 de		sbc $de		                sbc zhlfw.pixelsX+0
5445	.dcfb		8d 32 03	sta $0332	                sta vduv.hlfw.pixelsRightEndX+0
5446	.dcfe		ad 35 03	lda $0335	                lda vduv.hlfw.pixelsLimitX+1
5447	.dd01		e5 df		sbc $df		                sbc zhlfw.pixelsX+1
5448	.dd03		8d 33 03	sta $0333	                sta vduv.hlfw.pixelsRightEndX+1
5449	.dd06						LDD07:
5450	.dd06		a9 00		lda #$00	                lda #$00
5451	.dd08		38		sec		                sec
5452	.dd09						rtsDD0A:
5453	.dd09		60		rts		                rts

5455	.dd0a						LDD0B:
5456	.dd0a		a2 00		ldx #$00	                ldx #VDUVariables.graphicsWindowPixelsLeft
5457	.dd0c		20 34 dd	jsr $dd34	                jsr shouldFillPixel
5458	.dd0f		d0 f8		bne $dd09	                bne rtsDD0A                    ;taken if pixel not to be filled, so done
5459	.dd11						LDD12:
5460	.dd11		06 d1		asl $d1		                asl ZMASK                      ;next pixel
5461	.dd13		90 08		bcc $dd1d	                bcc LDD1E                    ;taken if still in same byte
5462	.dd15						LDD16:
5463	.dd15		20 33 da	jsr $da33	                jsr previousColumnAndResetMask
5464	.dd18		20 64 dd	jsr $dd64	                jsr shouldFillByte
5465	.dd1b		b0 f8		bcs $dd15	                bcs LDD16
5466	.dd1d						LDD1E:
5467	.dd1d		20 84 dd	jsr $dd84	                jsr LDD85
5468	.dd20		b0 ef		bcs $dd11	                bcs LDD12
5469	.dd22		ad 00 03	lda $0300	                lda vduv.graphicsWindowPixelsLeft+0
5470	.dd25		65 de		adc $de		                adc zhlfw.pixelsX+0
5471	.dd27		8d 2e 03	sta $032e	                sta vduv.hlfw.pixelsX+0
5472	.dd2a		ad 01 03	lda $0301	                lda vduv.graphicsWindowPixelsLeft+1
5473	.dd2d		65 df		adc $df		                adc zhlfw.pixelsX+1
5474	.dd2f		8d 2f 03	sta $032f	                sta vduv.hlfw.pixelsX+1
5475	.dd32		80 d2		bra $dd06	                bra LDD07

5477							;-------------------------------------------------------------------------
5478							;
5479							; Check whether line fill should fill a pixel.
5480							;
5481							; entry:
5482							;
5483							; X = VDU variable offset of edge of window
5484							;
5485							; vduv.workspace._2E - pixel X, Y coordinates
5486							;
5487							; exit:
5488							;
5489							; Z=1 if pixel should be filled
5490							;
5491							; ZTEMPC = ???
5492							;
5493	.dd34						shouldFillPixel:
5494	.dd34		38		sec		                sec
5495	.dd35		ad 2e 03	lda $032e	                lda vduv.workspace._2E+0
5496	.dd38		fd 00 03	sbc $0300,x	                sbc vduv+0,x
5497	.dd3b		a8		tay		                tay
5498	.dd3c		ad 2f 03	lda $032f	                lda vduv.workspace._2E+1
5499	.dd3f		fd 01 03	sbc $0301,x	                sbc vduv+1,x
5500	.dd42		10 03		bpl $dd47	                bpl +
5501	.dd44		20 2e c9	jsr $c92e	                jsr negateAY
5502	.dd47						+
5503	.dd47		84 de		sty $de		                sty zhlfw.pixelsX+0
5504	.dd49		85 df		sta $df		                sta zhlfw.pixelsX+1
5505	.dd4b		a2 2e		ldx #$2e	                ldx #VDUVariables.workspace._2E
5506	.dd4d		20 c3 de	jsr $dec3	                jsr windGADDR
5507	.dd50		18		clc		                clc
5508	.dd51		d0 10		bne $dd63	                bne rtsDD64                    ;taken if point outside window
5509	.dd53		b1 d6		lda ($d6),y	                lda (ZMEMG),y                  ;get screen byte
5510	.dd55		5d 30 88	eor $8830,x	                eor andy.hlfw.ecfPattern,x     ;EOR with appropriate pattern
5511	.dd58		85 da		sta $da		                sta zhlfw.notByteMatch ;0 if whole byte matches
5512	.dd5a		25 d1		and $d1		                and ZMASK                      ;0 if masked byte matches
5513	.dd5c		f0 02		beq $dd60	                beq +              ;taken if masked byte matches - A=0
5514	.dd5e		a9 08		lda #$08	                lda #$08              ;masked byte doesn't match - A=8
5515	.dd60						+
5516	.dd60		45 e1		eor $e1		                eor zhlfw.resultEOR ;maybe invert result
5517	.dd62		38		sec		                sec
5518	.dd63						rtsDD64:
5519	.dd63		60		rts		                rts

5521							;-------------------------------------------------------------------------

5523	.dd64						shouldFillByte:
5524	.dd64		b1 d6		lda ($d6),y	                lda (ZMEMG),y
5525	.dd66		5d 30 88	eor $8830,x	                eor andy.hlfw.ecfPattern,x
5526	.dd69		85 da		sta $da		                sta zhlfw.notByteMatch
5527	.dd6b		05 e1		ora $e1		                ora zhlfw.resultEOR
5528	.dd6d		18		clc		                clc
5529	.dd6e		d0 13		bne $dd83	                bne rtsDD84
5530	.dd70		a5 de		lda $de		                lda zhlfw.pixelsX+0
5531	.dd72		ed 61 03	sbc $0361	                sbc vduv.pixelsPerByteMinusOne
5532	.dd75		48		pha		                pha
5533	.dd76		a5 df		lda $df		                lda zhlfw.pixelsX+1
5534	.dd78		e9 00		sbc #$00	                sbc #$00
5535	.dd7a		90 06		bcc $dd82	                bcc pla_rts_DD83             ;taken if past X=0
5536	.dd7c		85 df		sta $df		                sta zhlfw.pixelsX+1
5537	.dd7e		68		pla		                pla
5538	.dd7f		85 de		sta $de		                sta zhlfw.pixelsX+0
5539	.dd81		60		rts		                rts

5541	.dd82						pla_rts_DD83:
5542	.dd82		68		pla		                pla
5543	.dd83						rtsDD84:
5544	.dd83		60		rts		                rts

5546							;-------------------------------------------------------------------------

5548	.dd84						LDD85:
5549	.dd84		a5 da		lda $da		                lda zhlfw.notByteMatch
5550	.dd86		25 d1		and $d1		                and ZMASK
5551	.dd88		f0 02		beq $dd8c	                beq +
5552	.dd8a		a9 08		lda #$08	                lda #$08
5553	.dd8c						+
5554	.dd8c		45 e1		eor $e1		                eor zhlfw.resultEOR
5555	.dd8e		d0 0d		bne $dd9d	                bne rtsDD9E

5557							                ; pixelsX -= 1
5558	.dd90		a5 de		lda $de		                lda zhlfw.pixelsX+0
5559	.dd92		d0 06		bne $dd9a	                bne +
5560	.dd94		a5 df		lda $df		                lda zhlfw.pixelsX+1
5561	.dd96		f0 05		beq $dd9d	                beq rtsDD9E
5562	.dd98		c6 df		dec $df		                dec zhlfw.pixelsX+1
5563	.dd9a						+
5564	.dd9a		c6 de		dec $de		                dec zhlfw.pixelsX+0
5565	.dd9c		38		sec		                sec
5566	.dd9d						rtsDD9E:
5567	.dd9d		60		rts		                rts

5569							;-------------------------------------------------------------------------
5570							;
5571							; Copy appropriate ECF pattern for line fill.
5572							;
5573							; entry:
5574							;
5575							; A = horizontal line fill PLOT code
5576							;
5577							; exit:
5578							;
5579							; andy.hlfw.ecfPattern = holds bg/fg ECF pattern as required
5580							;
5581							; ZTEMPD?1 = 0 for fill to matching, 8 to fill to non-matching
5582							;
5583	.dd9e						copyECFPatternForLineFill:
5584	.dd9e		4a		lsr a		                lsr a                        ;36-39; 44-47; 52-55; 60-63
5585	.dd9f		4a		lsr a		                lsr a                        ;18-19; 42-43; 26-27; 30-31
5586	.dda0						LDDA1:
5587	.dda0		29 08		and #$08	                and #$08                     ;8 if PLOT >= 104
5588	.dda2		85 e1		sta $e1		                sta zhlfw.resultEOR
5589	.dda4		49 0f		eor #$0f	                eor #$0F                     ;
5590	.dda6		aa		tax		                tax
5591	.dda7		a0 07		ldy #$07	                ldy #$07
5592	.dda9						-
5593	.dda9		bd 20 88	lda $8820,x	                lda andy.currentECFPatterns,x
5594	.ddac		99 30 88	sta $8830,y	                sta andy.hlfw.ecfPattern,y
5595	.ddaf		ca		dex		                dex
5596	.ddb0		88		dey		                dey
5597	.ddb1		10 f6		bpl $dda9	                bpl -
5598	.ddb3		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
5599	.ddb5		60		rts		                rts

5601							;-------------------------------------------------------------------------
5602							;
5603							;
5604							; entry:
5605							;
5606							; A = offset into VDU variables of coordinates
5607							;
5608							; exit:
5609							;
5610							; A = colour, or $ff if off screen/teletext (as per OSWORD $09)
5611							;
5612	.ddb6						readPixelColour: .proc
5613	.ddb6		20 f9 c0	jsr $c0f9	                jsr stopCursorEditing
5614	.ddb9		ae 61 03	ldx $0361	                ldx vduv.pixelsPerByteMinusOne
5615	.ddbc		f0 21		beq $dddf	                beq invalid             ;taken if teletext
5616	.ddbe		48		pha		                pha
5617	.ddbf		aa		tax		                tax
5618	.ddc0		20 dd d1	jsr $d1dd	                jsr eigabsEntryPoint
5619	.ddc3		fa		plx		                plx
5620	.ddc4		20 c3 de	jsr $dec3	                jsr windGADDR
5621	.ddc7		d0 16		bne $dddf	                bne invalid             ;taken if off screen
5622	.ddc9		b1 d6		lda ($d6),y	                lda (ZMEMG),y
5623	.ddcb		64 da		stz $da		                stz ZTEMP+0
5624	.ddcd		80 01		bra $ddd0	                bra shiftMask

5626							                ; Keep shifting the byte and the mask. When a 1 bit is
5627							                ; shifted out of the mask, shift the corresponding
5628							                ; byte bit bit into ZTEMP+0, building up the pixel
5629							                ; colour a bit at a time.
5630							                ;
5631							                ; When the mask becomes 0, done.
5632	.ddcf						shiftByteAndMask:
5633	.ddcf		0a		asl a		                asl a
5634	.ddd0						shiftMask:
5635	.ddd0		06 d1		asl $d1		                asl ZMASK
5636	.ddd2		90 fb		bcc $ddcf	                bcc shiftByteAndMask
5637	.ddd4		0a		asl a		                asl a
5638	.ddd5		26 da		rol $da		                rol ZTEMP+0
5639	.ddd7		a6 d1		ldx $d1		                ldx ZMASK
5640	.ddd9		d0 f5		bne $ddd0	                bne shiftMask
5641	.dddb		a5 da		lda $da		                lda ZTEMP+0
5642	.dddd		80 02		bra $dde1	                bra done

5644	.dddf						invalid:
5645	.dddf		a9 ff		lda #$ff	                lda #$FF
5646	.dde1						done:
5647	.dde1		4c c9 c0	jmp $c0c9	                jmp reinstateCursorEditing
5648							                .endproc

5650							;-------------------------------------------------------------------------
5651							;
5652							; Translate ASCII char to the SAA5050 character set.
5653							;
5654							; # ($23) becomes $5f
5655							; _ ($5f) becomes $60
5656							; GBP ($60) becomes $23
5657							;
5658							; Because the mapping is a kind of cycle, you can call this routine
5659							; twice to translate from SAA5050 to ASCII.
5660							;
5661							; entry:
5662							;
5663							; A = ASCII char
5664							;
5665							; exit:
5666							;
5667							; A = SAA550 char
5668							;
5669	.dde4						getSAA5050FromASCII:
5670	.dde4		c9 23		cmp #$23	                cmp #$23
5671	.dde6		f0 0a		beq $ddf2	                beq translateHash
5672	.dde8		c9 5f		cmp #$5f	                cmp #$5F
5673	.ddea		f0 08		beq $ddf4	                beq translateUnderscore
5674	.ddec		c9 60		cmp #$60	                cmp #$60
5675	.ddee		d0 06		bne $ddf6	                bne rtsDDF7
5676	.ddf0						translateGBP:
5677	.ddf0		49 3f		eor #$3f	                eor #$3F                     ;0x60->0x5f
5678	.ddf2						translateHash:
5679	.ddf2		49 43		eor #$43	                eor #$43                     ;0x23->0x5f or 0x5f->0x1c
5680	.ddf4						translateUnderscore:
5681	.ddf4		49 3f		eor #$3f	                eor #$3F                     ;0x5f->0x60 or 0x1c->0x23
5682	.ddf6						rtsDDF7:
5683	.ddf6		60		rts		                rts

5685							;-------------------------------------------------------------------------

5687	.ddf7						readCharacterAtTextCursor: .proc
5688	.ddf7		58		cli		                cli
5689	.ddf8		24 d0		bit $d0		                bit STATE
5690	.ddfa		50 06		bvc $de02	                bvc +                      ;taken if not cursor editing
5691	.ddfc		20 f9 c0	jsr $c0f9	                jsr stopCursorEditing
5692	.ddff		20 d0 c0	jsr $c0d0	                jsr exchangeCursors
5693	.de02						+
5694	.de02		ac 60 03	ldy $0360	                ldy vduv.numberOfLogicalColoursMinusOne
5695	.de05		d0 17		bne $de1e	                bne bitmapMode
5696	.de07						readTeletextChar:
5697	.de07		b2 d8		lda ($d8)	                lda (ZMEMT)                  ;read character from screen
5698	.de09		20 e4 dd	jsr $dde4	                jsr getSAA5050FromASCII      ;call 2x to convert to ASCII
5699	.de0c		20 e4 dd	jsr $dde4	                jsr getSAA5050FromASCII      ;call 2x to convert to ASCII
5700	.de0f						done:
5701	.de0f		24 d0		bit $d0		                bit STATE
5702	.de11		50 06		bvc $de19	                bvc +                     ;taken if not cursor editing
5703	.de13		20 d0 c0	jsr $c0d0	                jsr exchangeCursors
5704	.de16		20 c9 c0	jsr $c0c9	                jsr reinstateCursorEditing
5705	.de19						+
5706	.de19		ac 55 03	ldy $0355	                ldy vduv.currentScreenMODE
5707	.de1c		aa		tax		                tax
5708	.de1d		60		rts		                rts

5710	.de1e						bitmapMode:
5711	.de1e		20 56 de	jsr $de56	                jsr LDE56
5712	.de21		a5 f4		lda $f4		                lda $F4
5713	.de23		48		pha		                pha
5714	.de24		20 49 e5	jsr $e549	                jsr selectTerminalROMAndANDY
5715	.de27		a9 20		lda #$20	                lda #$20
5716	.de29		aa		tax		                tax                          ;X = ASCII code for char
5717	.de2a		20 2a e2	jsr $e22a	                jsr getSoftCharacterDefinitionAddress
5718	.de2d						compare:
5719	.de2d		a0 07		ldy #$07	                ldy #$07
5720	.de2f						-
5721	.de2f		b9 28 03	lda $0328,y	                lda vduv.workspace._28,y
5722	.de32		51 de		eor ($de),y	                eor (ZTEMPC),y
5723	.de34		d0 0e		bne $de44	                bne nextFontChar ;taken if no match - can't be this char
5724	.de36		88		dey		                dey
5725	.de37		10 f6		bpl $de2f	                bpl -

5727	.de39		8a		txa		                txa                          ;A = char found
5728							                .if version==350
5729	.de3a		10 02		bpl $de3e	                bpl bitmapModeDone
5730	.de3c		49 7f		eor #$7f	                eor #$7f
5731							                .endif
5732	.de3e						bitmapModeDone:
5733	.de3e		fa		plx		                plx
5734	.de3f		20 4b e5	jsr $e54b	                jsr selectROMX
5735	.de42		80 cb		bra $de0f	                bra done

5737	.de44						nextFontChar:
5738	.de44		e8		inx		                inx                          ;next ASCII code
5739							                .if version==350
5740	.de45		8a		txa		                txa
5741	.de46		10 02		bpl $de4a	                bpl LDE4A
5742	.de48		49 7f		eor #$7f	                eor #$7f
5743	.de4a						LDE4A:
5744	.de4a		20 2a e2	jsr $e22a	                jsr getSoftCharacterDefinitionAddress
5752							                .endif
5753	.de4d						gotCharAddress:
5754	.de4d		e0 7f		cpx #$7f	                cpx #$7F
5755	.de4f		f0 f3		beq $de44	                beq nextFontChar                 ;skip CHR$127
5756	.de51		8a		txa		                txa
5757	.de52		d0 d9		bne $de2d	                bne compare           ;taken if more chars to consider
5758	.de54		80 e8		bra $de3e	                bra bitmapModeDone ;finish with A=0 - i.e., no match found
5759							                .endproc

5761							;-------------------------------------------------------------------------
5762							;
5763							; Copy character out of screen memory, and store as a 1 bpp bitmap in
5764							; VDU variables workspace.
5765							;
5766	.de56						LDE56: .proc
5767	.de56		a6 d8		ldx $d8		                ldx ZMEMT+0
5768	.de58		a5 d9		lda $d9		                lda ZMEMT+1
5769	.de5a		20 d8 ce	jsr $ced8	                jsr getNext3ColumnAddresses
5770	.de5d		a0 07		ldy #$07	                ldy #$07
5771	.de5f						loop:
5772	.de5f		ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
5773	.de62		e0 03		cpx #$03	                cpx #$03
5774	.de64		f0 09		beq $de6f	                beq read2bppChar
5775	.de66		b0 13		bcs $de7b	                bcs read4bppChar
5776	.de68						read1bppChar:
5777	.de68		b1 d8		lda ($d8),y	                lda (ZMEMT),y
5778	.de6a		4d 58 03	eor $0358	                eor vduv.backgroundTextColour
5779	.de6d		80 22		bra $de91	                bra next

5781	.de6f						read2bppChar:
5782	.de6f		b1 d8		lda ($d8),y	                lda (ZMEMT),y                ;get pixels 0-3
5783	.de71		20 a2 de	jsr $dea2	                jsr get4Pixels
5784	.de74		b1 da		lda ($da),y	                lda (ZTEMP),y                  ;get pixels 4-7
5785	.de76		20 a2 de	jsr $dea2	                jsr get4Pixels
5786	.de79		80 14		bra $de8f	                bra LDE8F

5788	.de7b						read4bppChar:
5789	.de7b		b1 d8		lda ($d8),y	                lda (ZMEMT),y                ;get pixels 0/1
5790	.de7d		20 98 de	jsr $de98	                jsr get2Pixels
5791	.de80		b1 da		lda ($da),y	                lda (ZTEMP),y                ;get pixels 2/3
5792	.de82		20 98 de	jsr $de98	                jsr get2Pixels
5793	.de85		b1 dc		lda ($dc),y	                lda (ZTEMPB),y               ;get pixels 4/5
5794	.de87		20 98 de	jsr $de98	                jsr get2Pixels
5795	.de8a		b1 e0		lda ($e0),y	                lda (ZTEMPD),y               ;get pixels 6/7
5796	.de8c		20 98 de	jsr $de98	                jsr get2Pixels
5797	.de8f						LDE8F:
5798	.de8f		a5 df		lda $df		                lda ZTEMPC+1
5799	.de91						next:
5800	.de91		99 28 03	sta $0328,y	                sta vduv.workspace._28,y
5801	.de94		88		dey		                dey
5802	.de95		10 c8		bpl $de5f	                bpl loop
5803	.de97		60		rts		                rts

5805	.de98						get2Pixels:
5806	.de98		4d 58 03	eor $0358	                eor vduv.backgroundTextColour ;reset background pixel bits
5807	.de9b		20 b5 de	jsr $deb5	                jsr or2Pixels
5808	.de9e		29 03		and #$03	                and #%00000011               ;2 pixels/byte
5809	.dea0		80 0c		bra $deae	                bra shiftIn2

5811	.dea2						get4Pixels:
5812	.dea2		4d 58 03	eor $0358	                eor vduv.backgroundTextColour ;
5813	.dea5		20 ba de	jsr $deba	                jsr or4Pixels
5814	.dea8		29 0f		and #$0f	                and #%00001111               ;4 pixels/byte

5816							                ; Build up the 1bpp char row in ZTEMPC?1, 2 or 4 bits
5817							                ; at a time.
5818	.deaa		06 df		asl $df		                asl ZTEMPC+1
5819	.deac		06 df		asl $df		                asl ZTEMPC+1
5820	.deae						shiftIn2:
5821	.deae		06 df		asl $df		                asl ZTEMPC+1
5822	.deb0		06 df		asl $df		                asl ZTEMPC+1
5823	.deb2		04 df		tsb $df		                tsb ZTEMPC+1
5824	.deb4		60		rts		                rts

5826							                ; OR together all the N bits for each pixel, making a
5827							                ; byte in which the bottom N bits have a bit set for
5828							                ; each non-0 pixel in the byte.
5829	.deb5						or2Pixels:
5830	.deb5		85 de		sta $de		                sta ZTEMPC+0
5831	.deb7		20 be de	jsr $debe	                jsr shiftOut2
5832	.deba						or4Pixels:
5833	.deba		85 de		sta $de		                sta ZTEMPC+0                 ;%abcdABCD
5834	.debc		4a		lsr a		                lsr a                        ;%0abcdABC
5835	.debd		4a		lsr a		                lsr a                        ;%00abcdAB
5836	.debe						shiftOut2:
5837	.debe		4a		lsr a		                lsr a                        ;%000abcdA
5838	.debf		4a		lsr a		                lsr a                        ;%0000abcd
5839	.dec0		05 de		ora $de		                ora ZTEMPC+0                 ;%0000abcd|%abcdABCD
5840							                .endproc
5841	.dec2						rtsDEC2:
5842	.dec2		60		rts		                rts

5844							;-------------------------------------------------------------------------
5845							;
5846							; Do WIND. If point not in window, return with Z=0. Otherwise, call
5847							; GADDR and return with Z=1.
5848							;
5849	.dec3						windGADDR:
5850	.dec3		20 a7 d1	jsr $d1a7	                jsr windEntryPoint
5851	.dec6		d0 fa		bne $dec2	                bne rtsDEC2                  ;taken if point outside window
5852	.dec8						gaddrEntryPoint:
5853	.dec8		bd 02 03	lda $0302,x	                lda vduv+2,x                 ;get Y coordinate
5854	.decb						LDECB:
5855	.decb		49 ff		eor #$ff	                eor #$FF                     ;invert Y coordinate
5856	.decd		a8		tay		                tay                          ;Y=Y coordinate
5857	.dece		29 07		and #$07	                and #$07                ;get scanline in character row
5858	.ded0		85 da		sta $da		                sta ZTEMP+0             ;save scanline
5859	.ded2		98		tya		                tya                          ;A=Y coordinate
5860	.ded3		29 f8		and #$f8	                and #$F8                     ;row*8
5861	.ded5		4a		lsr a		                lsr a                        ;row*4
5862	.ded6		85 d7		sta $d7		                sta ZMEMG+1                  ;>(row*1024)
5863	.ded8		4a		lsr a		                lsr a                        ;>(row*512)
5864	.ded9		4a		lsr a		                lsr a                        ;>(row*256)
5865	.deda		65 d7		adc $d7		                adc ZMEMG+1                  ;>(row*1280)
5866	.dedc		4a		lsr a		                lsr a                        ;>(row*640)
5867	.dedd		85 d7		sta $d7		                sta ZMEMG+1                  ;
5868	.dedf		a9 00		lda #$00	                lda #$00                     ;
5869	.dee1		6a		ror a		                ror a                        ;<(row*640) - $00/$80
5870	.dee2		ac 56 03	ldy $0356	                ldy vduv.currentScreenMODEGroup
5871	.dee5		f0 03		beq $deea	                beq +                      ;taken if 640 bytes per row
5872	.dee7		46 d7		lsr $d7		                lsr ZMEMG+1                ;>(row*320)
5873	.dee9		6a		ror a		                ror a                    ;<(row*320) - $00/$40/$80/$c0
5874	.deea						+
5875	.deea		05 da		ora $da		                ora ZTEMP+0               ;include the scanline offset
5876	.deec		6d 50 03	adc $0350	                adc vduv.screenTopLeftAddress+0 ;include LSB of screen base
5877	.deef		8d 1a 03	sta $031a	                sta vduv.graphicsAddressOffset

5879							                ; add MSB of screen base to ZMEMG+1
5880	.def2		a5 d7		lda $d7		                lda ZMEMG+1
5881	.def4		6d 51 03	adc $0351	                adc vduv.screenTopLeftAddress+1
5882	.def7		85 d7		sta $d7		                sta ZMEMG+1

5884	.def9		bd 01 03	lda $0301,x	                lda vduv+1,x                 ;get >X
5885	.defc		85 d6		sta $d6		                sta ZMEMG+0                  ;save >X
5886	.defe		bd 00 03	lda $0300,x	                lda vduv+0,x                 ;get <X
5887	.df01		2d 61 03	and $0361	                and vduv.pixelsPerByteMinusOne ;index for pixel
5888	.df04		6d 61 03	adc $0361	                adc vduv.pixelsPerByteMinusOne ;offset into pixel mask table
5889	.df07		a8		tay		                tay
5890	.df08		b9 2c e1	lda $e12c,y	                lda pixelMasks-1,y
5891	.df0b		85 d1		sta $d1		                sta ZMASK

5893							                ; Form 16-bit column address offset (LSB in A, MSB in
5894							                ; ZMEMG+0), assuming 8 bits/pixel. No adjustment
5895							                ; needed if MODE 0/4, but scale up by 2 if MODE 1/5 or
5896							                ; 4 if MODE 2.

5898	.df0d		bd 00 03	lda $0300,x	                lda vduv+0,x                 ;A = <X
5899	.df10		ac 61 03	ldy $0361	                ldy vduv.pixelsPerByteMinusOne
5900	.df13		c0 03		cpy #$03	                cpy #$03
5901	.df15		f0 05		beq $df1c	                beq LDF1C         ;taken if 4 px/byte - i.e., MODE 1/5
5902	.df17		b0 06		bcs $df1f	                bcs LDF1F        ;taken if >4 px/byte - i.e., MODE 0/4
5903	.df19		0a		asl a		                asl a
5904	.df1a		26 d6		rol $d6		                rol ZMEMG+0
5905	.df1c						LDF1C:
5906	.df1c		0a		asl a		                asl a
5907	.df1d		26 d6		rol $d6		                rol ZMEMG+0
5908	.df1f						LDF1F:
5909	.df1f		29 f8		and #$f8	                and #$F8                     ;<column offset
5910	.df21		18		clc		                clc
5911	.df22		6d 1a 03	adc $031a	                adc vduv.graphicsAddressOffset
5912	.df25		8d 1a 03	sta $031a	                sta vduv.graphicsAddressOffset
5913	.df28		a5 d6		lda $d6		                lda ZMEMG+0                  ;>column offset
5914	.df2a		65 d7		adc $d7		                adc ZMEMG+1                  ;add to address MSB
5915	.df2c		10 04		bpl $df32	                bpl +                        ;taken if no wrap
5916	.df2e		38		sec		                sec
5917	.df2f		ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte ;handle wrap at end of screen
5918	.df32						+
5919	.df32		85 d7		sta $d7		                sta ZMEMG+1                  ;got MSB
5920	.df34		64 d6		stz $d6		                stz ZMEMG+0 ;LSB always 0 - the offset takes care of this
5921	.df36		a6 da		ldx $da		                ldx ZTEMP+0 ;get scanline in row
5922	.df38		20 7b da	jsr $da7b	                jsr setupColourMasks
5923	.df3b		ac 1a 03	ldy $031a	                ldy vduv.graphicsAddressOffset
5924	.df3e						ldaim00_rts_DF3E:
5925	.df3e		a9 00		lda #$00	                lda #$00                     ;return with Z=1, as per WIND
5926	.df40		60		rts		                rts

5928							;-------------------------------------------------------------------------

5930	.df41						LDF41:
5931	.df41		20 c8 de	jsr $dec8	                jsr gaddrEntryPoint
5932	.df44		da		phx		                phx
5933	.df45		a2 00		ldx #$00	                ldx #$00
5934	.df47		ad 5a 03	lda $035a	                lda $035A
5935	.df4a		c9 04		cmp #$04	                cmp #$04
5936	.df4c		b0 0b		bcs $df59	                bcs LDF59
5937	.df4e		ae 6a 03	ldx $036a	                ldx $036A
5938	.df51		ad 59 03	lda $0359	                lda $0359
5939	.df54		f0 03		beq $df59	                beq LDF59
5940	.df56		ae 6b 03	ldx $036b	                ldx $036B
5941	.df59						LDF59:
5942	.df59		8e 69 03	stx $0369	                stx $0369
5943	.df5c		fa		plx		                plx
5944	.df5d		60		rts		                rts

5946							;-------------------------------------------------------------------------

5948	.df5e						handleCopyKey:
5949	.df5e		a9 20		lda #$20	                lda #STATE.isVDU5
5950	.df60		24 d0		bit $d0		                bit STATE
5951	.df62		50 da		bvc $df3e	                bvc ldaim00_rts_DF3E      ;taken if not cursor editing
5952	.df64		d0 d8		bne $df3e	                bne ldaim00_rts_DF3E      ;taken if VDU5
5953							                .if version==350&&!finmos329
5954	.df66		20 0a fb	jsr $fb0a	                jsr LFB0A
5961							                .endif
5962	.df69		f0 0c		beq $df77	                beq rtsDF77              ;taken if char not recognised
5963	.df6b		48		pha		                pha                      ;save char recognised
5964	.df6c		20 d5 df	jsr $dfd5	                jsr isCursorEditingPossible
5965	.df6f		d0 05		bne $df76	                bne pla_rts_DF76
5966	.df71		a9 09		lda #$09	                lda #$09
5967	.df73		20 bc df	jsr $dfbc	                jsr moveEditCursor
5968	.df76						pla_rts_DF76:
5969	.df76		68		pla		                pla
5970	.df77						rtsDF77:
5971	.df77		60		rts		                rts

5973							;-------------------------------------------------------------------------
5974							;
5975							; Handle cursor key press.
5976							;
5977							; Entry: A = one of the cursor key codes:
5978							;            $88 = left
5979							;            $89 = right
5980							;            $8a = down
5981							;            $8b = up

5983	.df78						handleCursorKey:
5984	.df78		48		pha		                pha                          ;save cursor key code
5985	.df79		20 d5 df	jsr $dfd5	                jsr isCursorEditingPossible
5986	.df7c		d0 f8		bne $df76	                bne pla_rts_DF76             ;bail if editing not possible
5987	.df7e		70 16		bvs $df96	                bvs editing                  ;taken if already editing
5988	.df80						beginEditing:
5989	.df80		ad 5f 03	lda $035f	                lda vduv.lastCursorStartRegisterValue
5990	.df83		29 df		and #$df	                and #%11011111
5991	.df85		20 52 cf	jsr $cf52	                jsr setCRTCRegister10        ;hide cursor
5992	.df88		a2 18		ldx #$18	                ldx #VDUVariables.textCursorXPosition
5993	.df8a		a0 64		ldy #$64	                ldy #VDUVariables.editCursorXPosition
5994	.df8c		20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables ;edit cursor pos =
5995							                                                   ;text cursor pos
5996	.df8f		20 04 c1	jsr $c104	                jsr activateEditCursor
5997	.df92		a9 02		lda #$02	                lda #STATE.isScrollingDisabled
5998	.df94		04 d0		tsb $d0		                tsb STATE
5999	.df96						editing:
6000	.df96		68		pla		                pla                          ;restore cursor key code

6002							                ; Form appropriate VDU command (8/9/10/11) for the
6003							                ; key, assuming no VDU axis rearrangement.
6004	.df97		29 7f		and #$7f	                and #$7F
6005	.df99		85 da		sta $da		                sta ZTEMP                    ;save VDU command

6007							                ; Adjust VDU command based on axis swap/inversion.
6008	.df9b		c9 0a		cmp #$0a	                cmp #$0A
6009	.df9d		b0 0e		bcs $dfad	                bcs handleCursorUpOrDown     ;taken if up/down
6010	.df9f						handleCursorLeftOrRightOrCopy:
6011	.df9f		ad 66 03	lda $0366	                lda vduv.cursorFlags
6012	.dfa2		4a		lsr a		                lsr a
6013	.dfa3		29 05		and #$05	                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertHorizontal)>>1
6014	.dfa5		89 04		bit #$04	                bit #vduv.cursorFlags.swapAxes>>1
6015	.dfa7		f0 11		beq $dfba	                beq gotActualMoveCommand

6017	.dfa9		49 07		eor #$07	                eor #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal)>>1
6018	.dfab		80 0d		bra $dfba	                bra gotActualMoveCommand

6020	.dfad						handleCursorUpOrDown:
6021	.dfad		ad 66 03	lda $0366	                lda vduv.cursorFlags
6022	.dfb0		4a		lsr a		                lsr a
6023	.dfb1		4a		lsr a		                lsr a
6024	.dfb2		29 03		and #$03	                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical)>>2 ;000000SV
6025	.dfb4		89 02		bit #$02	                bit #vduv.cursorFlags.swapAxes>>2
6026	.dfb6		f0 02		beq $dfba	                beq gotActualMoveCommand

6028	.dfb8		49 01		eor #$01	                eor #vduv.cursorFlags.invertVertical>>2
6029	.dfba						gotActualMoveCommand:
6030	.dfba		45 da		eor $da		                eor ZTEMP
6031	.dfbc						moveEditCursor:
6032	.dfbc		a8		tay		                tay                          ;save command
6033	.dfbd		a9 40		lda #$40	                lda #STATE.isCursorEditing
6034	.dfbf		14 d0		trb $d0		                trb STATE            ;temporarily disable edit mode
6035	.dfc1		98		tya		                tya                  ;restore command
6036	.dfc2		ae 6c 03	ldx $036c	                ldx vduv.column81
6037	.dfc5		da		phx		                phx                  ;save old column 81 flag
6038	.dfc6		4e 6c 03	lsr $036c	                lsr vduv.column81    ;temporarily reset column 81 flag
6039	.dfc9		20 27 c0	jsr $c027	                jsr outputToVDU      ;print the cursor movement command
6040	.dfcc		68		pla		                pla
6041	.dfcd		8d 6c 03	sta $036c	                sta vduv.column81            ;restore column 81 flag
6042	.dfd0		a9 40		lda #$40	                lda #STATE.isCursorEditing
6043	.dfd2		04 d0		tsb $d0		                tsb STATE                    ;reinstate edit mode
6044	.dfd4		60		rts		                rts

6046							; Check if cursor editing is possible.
6047							;
6048							; Exit: Z=1 - editing is possible
6049							;             V reflects current STATE.isCursorEditing bit
6050							;       Z=0 - editing not possible
6051	.dfd5						isCursorEditingPossible:
6052	.dfd5		ae 6a 02	ldx $026a	                ldx vduQueueNegativeLength
6053	.dfd8		d0 04		bne $dfde	                bne +                        ;return with Z=0 if VDU
6054							                                             ;queue not empty
6055	.dfda		a9 a0		lda #$a0	                lda #STATE.isVDU21|STATE.isVDU5
6056	.dfdc		24 d0		bit $d0		                bit STATE   ;return with Z=0 if neither VDU21 nor VDU5
6057	.dfde						+
6058	.dfde		60		rts		                rts

6060							;-------------------------------------------------------------------------
6061							;
6062							; 184-191 = Move/copy rectangle [MasRef E.3-31]
6063							;
6064							                .if version!=400
6065	.dfdf						selectExtROMAndPlotMoveOrCopyRectangle:
6066	.dfdf		a2 89		ldx #$89	                ldx #$80|extROM   ; select VIEW+ANDY
6067	.dfe1		20 4b e5	jsr $e54b	                jsr selectROMX
6068	.dfe4		20 c9 b6	jsr $b6c9	                jsr plotMoveOrCopyRectangle
6069	.dfe7		80 08		bra $dff1	                bra LDFF1
6070							                .endif

6072							;-------------------------------------------------------------------------
6073							;
6074							; 192-199 = Plot ellipse outline [MasRef E.3-32]
6075							;
6076							                .if version!=400
6077	.dfe9						selectExtROMAndPlotEllipseOutline:
6078	.dfe9		a2 89		ldx #$89	                ldx #$80|extROM
6079	.dfeb		20 4b e5	jsr $e54b	                jsr selectROMX
6080	.dfee		20 f3 b1	jsr $b1f3	                jsr plotEllipseOutline
6081	.dff1						LDFF1:
6082	.dff1		4c 49 e5	jmp $e549	                jmp selectTerminalROMAndANDY
6083							                .endif

6085							;-------------------------------------------------------------------------
6086							;
6087							; 200-207 = Plot solid ellipse [MasRef E.3-32]
6088							;
6089							                .if version!=400
6090	.dff4						selectExtROMAndPlotEllipseFilled:
6091	.dff4		a2 89		ldx #$89	                ldx #$80|extROM
6092	.dff6		20 4b e5	jsr $e54b	                jsr selectROMX
6093	.dff9		20 72 b2	jsr $b272	                jsr plotEllipseFilled
6094	.dffc		80 f3		bra $dff1	                bra LDFF1
6095							                .endif

6097							                .if version==400
6099							                .endif

6101							;-------------------------------------------------------------------------

6103							; Pretty sure I have the logic for this all wrong...

6105							                .if !finmos329
6106	>dffe						                .align 16
6107							                .endif
6108	.e000						startupMessages: .block
6109							                .if version==500||version==510||autocue
6111							                .endif

6113							                .if version>=511&&!autocue
6115							                .endif
6116	.e000						acornMOS:
6117	>e000		0d				                .text 13
6118							                .if olivetti
6120							                .elsif version==350
6121							                .if CFA3000
6125							                .else
6126	>e001		41 43 4f 52 4e 20 4d 4f		                .text "ACORN MOS"
	>e009		53
6127							                .endif
6130							                .endif
6131							                .if version==400||version==350
6132	>e00a		20				                .text " "
6133							                .endif
6134	>e00b		00				                .byte 0
6135	.e00c						beep:
6136	>e00c		07				                .byte 7
6137	>e00d		00				                .byte 0
6138							                .if version!=400&&version!=350
6140							                .endif

6142	.e00e						twoNewlines:
6143	>e00e		08				                .byte 8
6144	>e00f		0d				                .byte $0D
6145	>e010		0d				                .byte $0D
6146							                ; terminating 0 comes from following table!
6147							                .cerror *!=LE013,"startupMessages needs a terminating 0"
6148							                .endblock
6149	.e011						LE013:
6150	>e011		00				                .byte %00000000;$00
6151	>e012		11				                .byte %00010001;$11
6152	>e013		22				                .byte %00100010;$22
6153	>e014		33				                .byte %00110011;$33
6154	>e015		44				                .byte %01000100;$44
6155	>e016		55				                .byte %01010101;$55
6156	>e017		66				                .byte %01100110;$66
6157	>e018		77				                .byte %01110111;$77
6158	>e019		88				                .byte %10001000;$88
6159	>e01a		99				                .byte %10011001;$99
6160	>e01b		aa				                .byte %10101010;$AA
6161	>e01c		bb				                .byte %10111011;$BB
6162	>e01d		cc				                .byte %11001100;$CC
6163	>e01e		dd				                .byte %11011101;$DD
6164	>e01f		ee				                .byte %11101110;$EE
6165	>e020		ff				                .byte %11111111;$FF
6166	.e021						LE023:
6167	>e021		00				                .byte %00000000;$00
6168	>e022		55				                .byte %01010101;$55
6169	>e023		aa				                .byte %10101010;$AA
6170	>e024		ff				                .byte %11111111;$FF

6172							; VDU control code dispatch tables
6173							; ================================
6174							;
6175							; entry:
6176							;
6177							;

6179							; each routine is (address, number of additional VDU bytes)
6180	=[($c035,0)]					_:=[(vdu0EntryPoint,0)] ; VDU0
6181	=[($c035,0),($c0e1,1)]				_..=[(vdu1EntryPoint,1)] ; VDU1
6182	=[($c035,0),($c0e1,1),($c0e9,0)]		_..=[(vdu2EntryPoint,0)] ; VDU2
6183	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0)]	_..=[(vdu3EntryPoint,0)] ; VDU3
6184	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0)]
							_..=[(vdu4EntryPoint,0)] ; VDU4
6185	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0)]
							_..=[(vdu5EntryPoint,0)] ; VDU5
6186	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0)]
							_..=[(vdu6EntryPoint,0)] ; VDU6
6187	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0)]
							_..=[(vdu7EntryPoint,0)] ; VDU7
6188	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0)]
							_..=[(vdu8EntryPoint,0)] ; VDU8
6189	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0)]
							_..=[(vdu9EntryPoint,0)] ; VDU9
6190	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0)]
							_..=[(vdu10EntryPoint,0)] ; VDU10
6191	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0)]
							_..=[(vdu11EntryPoint,0)] ; VDU11
6192	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0)]
							_..=[(vdu12EntryPoint,0)] ; VDU12
6193	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0)]
							_..=[(vdu13EntryPoint,0)] ; VDU13
6194	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0)]
							_..=[(vdu14EntryPoint,0)] ; VDU14
6195	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0)]
							_..=[(vdu15EntryPoint,0)] ; VDU15
6196	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0)]
							_..=[(vdu16EntryPoint,0)] ; VDU16
6197	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1)]
							_..=[(vdu17EntryPoint,1)] ; VDU17
6198	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2)]
							_..=[(vdu18EntryPoint,2)] ; VDU18
6199	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5)]
							_..=[(vdu19EntryPoint,5)] ; VDU19
6200	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0)]
							_..=[(vdu20EntryPoint,0)] ; VDU20
6201	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0)]
							_..=[(vdu21EntryPoint,0)] ; VDU21
6202	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1)]
							_..=[(vdu22EntryPoint,1)] ; VDU22
6203	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1),($c67b,9)]
							_..=[(vdu23EntryPoint,9)] ; VDU23
6204	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1),($c67b,9),($c71e,8)]
							_..=[(vdu24EntryPoint,8)] ; VDU24
6205	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1),($c67b,9),($c71e,8),($c69a,5)]
							_..=[(vdu25EntryPoint,5)] ; VDU25
6206	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1),($c67b,9),($c71e,8),($c69a,5),($c6a9,0)]
							_..=[(vdu26EntryPoint,0)] ; VDU26
6207	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1),($c67b,9),($c71e,8),($c69a,5),($c6a9,0),($c035,0)]
							_..=[(vdu27EntryPoint,0)] ; VDU27
6208	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1),($c67b,9),($c71e,8),($c69a,5),($c6a9,0),($c035,0),($c3a4,4)]
							_..=[(vdu28EntryPoint,4)] ; VDU28
6209	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1),($c67b,9),($c71e,8),($c69a,5),($c6a9,0),($c035,0),($c3a4,4),($c789,4)]
							_..=[(vdu29EntryPoint,4)] ; VDU29
6210	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1),($c67b,9),($c71e,8),($c69a,5),($c6a9,0),($c035,0),($c3a4,4),($c789,4),($c47b,0)]
							_..=[(vdu30EntryPoint,0)] ; VDU30
6211	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1),($c67b,9),($c71e,8),($c69a,5),($c6a9,0),($c035,0),($c3a4,4),($c789,4),($c47b,0),($c481,2)]
							_..=[(vdu31EntryPoint,2)] ; VDU31
6212	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1),($c67b,9),($c71e,8),($c69a,5),($c6a9,0),($c035,0),($c3a4,4),($c789,4),($c47b,0),($c481,2),($ce2d,0)]
							_..=[(vdu127EntryPoint,0)] ; VDU127
6213	=[($c035,0),($c0e1,1),($c0e9,0),($c0e9,0),($c51d,0),($c52c,0),($c035,0),($ef19,0),($c299,0),($c24b,0),($c25a,0),($c2b0,0),($c44e,0),($c3f5,0),($c513,0),($c527,0),($c412,0),($c538,1),($c563,2),($c62c,5),($c5c4,0),($c518,0),($c793,1),($c67b,9),($c71e,8),($c69a,5),($c6a9,0),($c035,0),($c3a4,4),($c789,4),($c47b,0),($c481,2),($ce2d,0)]
							vdu_routines=_

6215							; LSB of routine address
6216	.e025						vduRoutinesLSBTable:
6217							                .for _i=0,_i<len(vdu_routines),_i+=1
6218	>e025		35				                .byte <vdu_routines[_i][0]
6218	>e026		e1				                .byte <vdu_routines[_i][0]
6218	>e027		e9				                .byte <vdu_routines[_i][0]
6218	>e028		e9				                .byte <vdu_routines[_i][0]
6218	>e029		1d				                .byte <vdu_routines[_i][0]
6218	>e02a		2c				                .byte <vdu_routines[_i][0]
6218	>e02b		35				                .byte <vdu_routines[_i][0]
6218	>e02c		19				                .byte <vdu_routines[_i][0]
6218	>e02d		99				                .byte <vdu_routines[_i][0]
6218	>e02e		4b				                .byte <vdu_routines[_i][0]
6218	>e02f		5a				                .byte <vdu_routines[_i][0]
6218	>e030		b0				                .byte <vdu_routines[_i][0]
6218	>e031		4e				                .byte <vdu_routines[_i][0]
6218	>e032		f5				                .byte <vdu_routines[_i][0]
6218	>e033		13				                .byte <vdu_routines[_i][0]
6218	>e034		27				                .byte <vdu_routines[_i][0]
6218	>e035		12				                .byte <vdu_routines[_i][0]
6218	>e036		38				                .byte <vdu_routines[_i][0]
6218	>e037		63				                .byte <vdu_routines[_i][0]
6218	>e038		2c				                .byte <vdu_routines[_i][0]
6218	>e039		c4				                .byte <vdu_routines[_i][0]
6218	>e03a		18				                .byte <vdu_routines[_i][0]
6218	>e03b		93				                .byte <vdu_routines[_i][0]
6218	>e03c		7b				                .byte <vdu_routines[_i][0]
6218	>e03d		1e				                .byte <vdu_routines[_i][0]
6218	>e03e		9a				                .byte <vdu_routines[_i][0]
6218	>e03f		a9				                .byte <vdu_routines[_i][0]
6218	>e040		35				                .byte <vdu_routines[_i][0]
6218	>e041		a4				                .byte <vdu_routines[_i][0]
6218	>e042		89				                .byte <vdu_routines[_i][0]
6218	>e043		7b				                .byte <vdu_routines[_i][0]
6218	>e044		81				                .byte <vdu_routines[_i][0]
6218	>e045		2d				                .byte <vdu_routines[_i][0]
6219							                .next

6221							; If bit 7 set: MSB of routine address
6222							;
6223							; If bit 7 clear:
6224							;
6225							; Top 4 bits are bits 8-11 of routine address (bits 12-15 are %1010,
6226							; so address is $C0xx to $C7xx)
6227							;
6228							; Bottom 4 bits are ORed with $f0 and stored in $26a - -ve bytes left
6229							; in VDU queue.
6230	.e046						vduRoutinesMSBTable:
6231							                .for _i=0,_i<len(vdu_routines),_i+=1
6232							                .if vdu_routines[_i][1]==0
6233	>e046		c0				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e047		0f				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e048		c0				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e049		c0				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04a		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04b		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04c		c0				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04d		ef				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04e		c2				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04f		c2				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e050		c2				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e051		c2				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e052		c4				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e053		c3				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e054		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e055		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e056		c4				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e057		5f				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e058		5e				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e059		6b				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e05a		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e05b		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e05c		7f				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e05d		67				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e05e		78				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e05f		6b				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e060		c6				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e061		c0				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e062		3c				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e063		7c				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e064		c4				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e065		4e				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e066		ce				                .byte >vdu_routines[_i][0]
6238							                .endif
6239							                .next

6241							;-------------------------------------------------------------------------
6242							;
6243							; entry:
6244							;
6245							; C=0
6246							;
6247							; A = vdu 23 code
6248							;
6249							; VDU queue = the full 9 bytes of the VDU 23
6250							;
6251	.e067						vdu23EntryPointTable:
6252	>e067		fa ce				                .word vdu23_0_EntryPoint
6253	>e069		2a cf				                .word vdu23_1_EntryPoint
6254	>e06b		56 cf				                .word vdu23_2_EntryPoint
6255	>e06d		56 cf				                .word vdu23_3_EntryPoint
6256	>e06f		56 cf				                .word vdu23_4_EntryPoint
6257	>e071		56 cf				                .word vdu23_5_EntryPoint
6258	>e073		de cf				                .word vdu23_6_EntryPoint
6259	>e075		e5 cf				                .word vdu23_7_EntryPoint
6260	>e077		68 d0				                .word vdu23_8_EntryPoint
6261	>e079		0e d1				                .word vdu23_9_EntryPoint
6262	>e07b		0f d1				                .word vdu23_10_EntryPoint
6263	>e07d		6c cf				                .word vdu23_11_EntryPoint
6264	>e07f		95 cf				                .word vdu23_12_EntryPoint
6265	>e081		95 cf				                .word vdu23_13_EntryPoint
6266	>e083		95 cf				                .word vdu23_14_EntryPoint
6267	>e085		95 cf				                .word vdu23_15_EntryPoint
6268	>e087		1d d1				                .word vdu23_16_EntryPoint

6270							;-------------------------------------------------------------------------
6271							;
6272							; entry:
6273							;
6274							; A = plot number
6275							;
6276	.e089						plotEntryPointTable:
6277	>e089		49 db				                .word plotPoint    ;64-71 = Plot point [MasRef E.3-24]
6278	>e08b		6b dc				                .word plotHorizontalLineFill ;72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
6279	>e08d		12 9c				                .word L9BF7 ;80-87 = Plot triangle [MasRef E.3-25]
6280	>e08f		74 dc				                .word plotHorizontalLineFillRight ;88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
6281	>e091		47 c4				                .word LC448 ;96-103 = Plot rectangle [MasRef E.3-26]
6282	>e093		6b dc				                .word plotHorizontalLineFill ;104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
6283	>e095		be 9b				                .word plotParallelogram ;112-119 = Plot parallelogram [MasRef E.3-27]
6284	>e097		74 dc				                .word plotHorizontalLineFillRight ;120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
6285	>e099		14 9d				                .word L9CF9 ;128-135 = Flood fill to non-background [MasRef E.3-28]
6286	>e09b		14 9d				                .word L9CF9 ;136-143 = Flood fill to foreground [MasRef E.3-28]
6287	>e09d		bf 99				                .word L99A4 ;144-151 = Plot circle outline [MasRef E.3-28]
6288	>e09f		5f 99				                .word L9944 ;152-159 = Plot filled circle [MasRef E.3-29]
6289	>e0a1		b4 99				                .word L9999 ;160-167 = Plot circular arc [MasRef E.3-29]
6290	>e0a3		50 99				                .word L9935 ;168-175 = Plot filled chord segment [MasRef E.3-30]
6291	>e0a5		3e 99				                .word L9923 ;176-183 = Plot filled sector [MasRef E.3-30]
6292	>e0a7		df df				                .word selectExtROMAndPlotMoveOrCopyRectangle ;184-191 = Move/copy rectangle [MasRef E.3-31]
6293	>e0a9		e9 df				                .word selectExtROMAndPlotEllipseOutline ;192-199 = Plot ellipse outline [MasRef E.3-32]
6294	>e0ab		f4 df				                .word selectExtROMAndPlotEllipseFilled ;200-207 = Plot solid ellipse [MasRef E.3-32]

6296							; Times 40 lookup table, high bytes
6297	.e0ad						multiplyBy40TableHigh:
6298							                .for _i=0,_i<25,_i+=1
6299	>e0ad		00				                .byte >_i*40
6299	>e0ae		00				                .byte >_i*40
6299	>e0af		00				                .byte >_i*40
6299	>e0b0		00				                .byte >_i*40
6299	>e0b1		00				                .byte >_i*40
6299	>e0b2		00				                .byte >_i*40
6299	>e0b3		00				                .byte >_i*40
6299	>e0b4		01				                .byte >_i*40
6299	>e0b5		01				                .byte >_i*40
6299	>e0b6		01				                .byte >_i*40
6299	>e0b7		01				                .byte >_i*40
6299	>e0b8		01				                .byte >_i*40
6299	>e0b9		01				                .byte >_i*40
6299	>e0ba		02				                .byte >_i*40
6299	>e0bb		02				                .byte >_i*40
6299	>e0bc		02				                .byte >_i*40
6299	>e0bd		02				                .byte >_i*40
6299	>e0be		02				                .byte >_i*40
6299	>e0bf		02				                .byte >_i*40
6299	>e0c0		02				                .byte >_i*40
6299	>e0c1		03				                .byte >_i*40
6299	>e0c2		03				                .byte >_i*40
6299	>e0c3		03				                .byte >_i*40
6299	>e0c4		03				                .byte >_i*40
6299	>e0c5		03				                .byte >_i*40
6300							                .next

6302							; Times 40 lookup table, low bytes
6303	.e0c6						multiplyBy40TableLow:
6304							                .for _i=0,_i<25,_i+=1
6305	>e0c6		00				                .byte <_i*40
6305	>e0c7		28				                .byte <_i*40
6305	>e0c8		50				                .byte <_i*40
6305	>e0c9		78				                .byte <_i*40
6305	>e0ca		a0				                .byte <_i*40
6305	>e0cb		c8				                .byte <_i*40
6305	>e0cc		f0				                .byte <_i*40
6305	>e0cd		18				                .byte <_i*40
6305	>e0ce		40				                .byte <_i*40
6305	>e0cf		68				                .byte <_i*40
6305	>e0d0		90				                .byte <_i*40
6305	>e0d1		b8				                .byte <_i*40
6305	>e0d2		e0				                .byte <_i*40
6305	>e0d3		08				                .byte <_i*40
6305	>e0d4		30				                .byte <_i*40
6305	>e0d5		58				                .byte <_i*40
6305	>e0d6		80				                .byte <_i*40
6305	>e0d7		a8				                .byte <_i*40
6305	>e0d8		d0				                .byte <_i*40
6305	>e0d9		f8				                .byte <_i*40
6305	>e0da		20				                .byte <_i*40
6305	>e0db		48				                .byte <_i*40
6305	>e0dc		70				                .byte <_i*40
6305	>e0dd		98				                .byte <_i*40
6305	>e0de		c0				                .byte <_i*40
6306							                .next

6308							; Times 640 lookup table, high bytes
6309	.e0df						multiplyBy640TableHigh:
6310							                .for _i=0,_i<32,_i+=1
6311	>e0df		00				                .byte >_i*640
6311	>e0e0		02				                .byte >_i*640
6311	>e0e1		05				                .byte >_i*640
6311	>e0e2		07				                .byte >_i*640
6311	>e0e3		0a				                .byte >_i*640
6311	>e0e4		0c				                .byte >_i*640
6311	>e0e5		0f				                .byte >_i*640
6311	>e0e6		11				                .byte >_i*640
6311	>e0e7		14				                .byte >_i*640
6311	>e0e8		16				                .byte >_i*640
6311	>e0e9		19				                .byte >_i*640
6311	>e0ea		1b				                .byte >_i*640
6311	>e0eb		1e				                .byte >_i*640
6311	>e0ec		20				                .byte >_i*640
6311	>e0ed		23				                .byte >_i*640
6311	>e0ee		25				                .byte >_i*640
6311	>e0ef		28				                .byte >_i*640
6311	>e0f0		2a				                .byte >_i*640
6311	>e0f1		2d				                .byte >_i*640
6311	>e0f2		2f				                .byte >_i*640
6311	>e0f3		32				                .byte >_i*640
6311	>e0f4		34				                .byte >_i*640
6311	>e0f5		37				                .byte >_i*640
6311	>e0f6		39				                .byte >_i*640
6311	>e0f7		3c				                .byte >_i*640
6311	>e0f8		3e				                .byte >_i*640
6311	>e0f9		41				                .byte >_i*640
6311	>e0fa		43				                .byte >_i*640
6311	>e0fb		46				                .byte >_i*640
6311	>e0fc		48				                .byte >_i*640
6311	>e0fd		4b				                .byte >_i*640
6311	>e0fe		4d				                .byte >_i*640
6312							                .next

6314							;-------------------------------------------------------------------------

6316	.e0ff						modeMaxRow:
6317	>e0ff		1f				                .byte 31                     ;MODE 0 = 32 rows
6318	>e100		1f				                .byte 31                     ;MODE 1 = 32 rows
6319	>e101		1f				                .byte 31                     ;MODE 2 = 32 rows
6320	>e102		18				                .byte 24                     ;MODE 3 = 25 rows
6321	>e103		1f				                .byte 31                     ;MODE 4 = 32 rows
6322	>e104		1f				                .byte 31                     ;MODE 5 = 32 rows
6323	>e105		18				                .byte 24                     ;MODE 6 = 25 rows
6324	>e106		18				                .byte 24                     ;MODE 7 = 25 rows

6326							;-------------------------------------------------------------------------

6328	.e107						modeMaxColumn:
6329	>e107		4f				                .byte 79                     ;MODE 0 = 80 columns
6330	>e108		27				                .byte 39                     ;MODE 1 = 40 columns
6331	>e109		13				                .byte 19                     ;MODE 2 = 20 columns
6332	>e10a		4f				                .byte 79                     ;MODE 3 = 80 columns
6333	>e10b		27				                .byte 39                     ;MODE 4 = 40 columns
6334	>e10c		13				                .byte 19                     ;MODE 5 = 20 columns
6335	>e10d		27				                .byte 39                     ;MODE 6 = 40 columns
6336	>e10e		27				                .byte 39                     ;MODE 7 = 40 columns

6338							;-------------------------------------------------------------------------

6340	.e10f						vcontrolForScreenMODE:
6341	>e10f		9c				                .byte VCONTROL.cursorX___|VCONTROL.crtc2MHz|VCONTROL.shift16MHz ; $9C - MODE 0
6342	>e110		d8				                .byte VCONTROL.cursorXX__|VCONTROL.crtc2MHz|VCONTROL.shift8MHz ; $d8 - MODE 1
6343	>e111		f4				                .byte VCONTROL.cursorXXXX|VCONTROL.crtc2MHz|VCONTROL.shift4MHz ; $F4 - MODE 2
6344	>e112		9c				                .byte VCONTROL.cursorX___|VCONTROL.crtc2MHz|VCONTROL.shift16MHz ; $9C - MODE 3
6345	>e113		88				                .byte VCONTROL.cursorX___|VCONTROL.crtc1MHz|VCONTROL.shift8MHz ; $88 - MODE 4
6346	>e114		c4				                .byte VCONTROL.cursorXX__|VCONTROL.crtc1MHz|VCONTROL.shift4MHz ; $C4 - MODE 5
6347	>e115		88				                .byte VCONTROL.cursorX___|VCONTROL.crtc1MHz|VCONTROL.shift8MHz ; $88 - MODE 6
6348	>e116		4b				                .byte VCONTROL.cursor_X__|VCONTROL.crtc1MHz|VCONTROL.shift8MHz|VCONTROL.isTeletext|VCONTROL.flash ; $4B - MODE 7

6350							;-------------------------------------------------------------------------

6352	.e117						bytesPerCharacterForMODE:
6353	>e117		08				                .byte 8                      ;MODE 0
6354	>e118		10				                .byte 16                     ;MODE 1
6355	>e119		20				                .byte 32                     ;MODE 2
6356	>e11a		08				                .byte 8                      ;MODE 3
6357	>e11b		08				                .byte 8                      ;MODE 4
6358	>e11c		10				                .byte 16                     ;MODE 5
6359	>e11d		08				                .byte 8                      ;MODE 6
6360	.e11e						LE120:
6361	>e11e		01				                .byte %00000001              ;MODE 7
6362	>e11f		ff				                .byte %11111111
6363	>e120		55				                .byte %01010101
6364	>e121		ff				                .byte %11111111
6365	>e122		77				                .byte %01110111
6366	>e123		33				                .byte %00110011
6367	>e124		11				                .byte %00010001

6369							;-------------------------------------------------------------------------

6371	.e125						distanceMasksTable:
6372	>e125		ff				                .byte %11111111
6373	>e126		7f				                .byte %01111111
6374	>e127		3f				                .byte %00111111
6375	>e128		1f				                .byte %00011111
6376	>e129		0f				                .byte %00001111
6377	>e12a		07				                .byte %00000111
6378	>e12b		03				                .byte %00000011
6379	>e12c		01				                .byte %00000001

6381							;-------------------------------------------------------------------------
6382							;
6383							; These graphics tables often overlap. I haven't always bothered
6384							; commenting the MODEs for the MODE-indexed tables, as even those
6385							; sometimes overlap.
6386							;
6387							;------------------------------------------------------------------------

6389							;-------------------------------------------------------------------------
6390							;
6391							; This is 3 tables in one. Use the numberOfLogicalColoursMinusOne VDU
6392							; variable to access it:
6393							; pixelMasks[(numberOfLogicalColoursMinusOne&7)-1+colour&numberOfLogicalColoursMinusOne=
6394							;
6395	.e12d						pixelMasks:
6396	>e12d		aa				                .byte %10101010
6397	>e12e		55				                .byte %01010101

6399	>e12f		88				                .byte %10001000
6400	>e130		44				                .byte %01000100
6401	>e131		22				                .byte %00100010
6402	>e132		11				                .byte %00010001

6404	>e133		80				                .byte %10000000
6405	>e134		40				                .byte %01000000
6406	>e135		20				                .byte %00100000
6407	>e136		10				                .byte %00010000
6408	>e137		08				                .byte %00001000
6409	>e138		04				                .byte %00000100
6410	>e139		02				                .byte %00000010
6411	.e13a						numberOfLogicalColoursMinusOneForMODE:
6412	>e13a		01				                .byte %00000001              ;MODE 0 (also part of pixelMasks)
6413	>e13b		03				                .byte 3                      ;MODE 1
6414	>e13c		0f				                .byte 15                     ;MODE 2
6415	>e13d		01				                .byte 1                      ;MODE 3
6416	>e13e		01				                .byte 1                      ;MODE 4
6417	>e13f		03				                .byte 3                      ;MODE 5
6418	>e140		01				                .byte 1                      ;MODE 6
6419							                ; MODE 7 value (0) is in next table

6421							;-------------------------------------------------------------------------
6422							;
6423							; Overwrite: ZGORA=$ff, ZGEOR=$ff
6424							; OR: ZGORA=value, ZGEOR=$00
6425							; AND: ZGORA=~value, ZGEOR=$00
6426							; EOR: ZGORA=$00, ZGEOR=value
6427							; Invert: ZGORA=$00, ZGEOR=$ff
6428							; Leave: ZGORA=$00, ZGEOR=$ff
6429							;
6430	.e141						zgeorORTable:
6431	>e141		00				                .byte $00
6432	.e142						zgoraORTable:
6433	>e142		ff				                .byte $FF
6434	.e143						zgoraEORTable:
6435	>e143		00				                .byte $00
6436	>e144		00				                .byte $00
6437	>e145		ff				                .byte $FF
6438	.e146						zgeorEORTable:
6439	>e146		ff				                .byte $FF
6440	>e147		ff				                .byte $FF
6441	>e148		ff				                .byte $FF
6442	>e149		00				                .byte $00

6444							;-------------------------------------------------------------------------
6445							;
6446							; Index using logical colour value to get a byte with that colour
6447							; value in every pixel.
6448							;
6449							; This is 3 tables in one. Use the numberOfLogicalColoursMinusOne VDU
6450							; variable to access it:
6451							; solidColoursTable[(numberOfLogicalColoursMinusOne&7)-1+colour&numberOfLogicalColoursMinusOne=
6452							;
6453	.e14a						solidColoursTable:

6455							                ; 1 bpp
6456	>e14a		00				                .byte %00000000
6457	>e14b		ff				                .byte %11111111

6459							                ; 2 bpp
6460	>e14c		00				                .byte %00000000
6461	>e14d		0f				                .byte %00001111
6462	>e14e		f0				                .byte %11110000
6463	>e14f		ff				                .byte %11111111

6465							                ; 4 bpp
6466	>e150		00				                .byte %00000000
6467	>e151		03				                .byte %00000011
6468	>e152		0c				                .byte %00001100
6469	>e153		0f				                .byte %00001111
6470	>e154		30				                .byte %00110000
6471	>e155		33				                .byte %00110011
6472	>e156		3c				                .byte %00111100
6473	>e157		3f				                .byte %00111111
6474	>e158		c0				                .byte %11000000
6475	>e159		c3				                .byte %11000011
6476	>e15a		cc				                .byte %11001100
6477	>e15b		cf				                .byte %11001111
6478	>e15c		f0				                .byte %11110000
6479	>e15d		f3				                .byte %11110011
6480	>e15e		fc				                .byte %11111100
6481	>e15f		ff				                .byte %11111111

6483	.e160						pixelsPerByteMinusOneForMODE:
6484	>e160		07				                .byte 7
6485	>e161		03				                .byte 3
6486	>e162		01				                .byte 1
6487	.e163						LE165:
6488	>e163		00				                .byte 0
6489	>e164		07				                .byte 7
6490	>e165		03				                .byte 3
6491	.e166						screenMODEGroupForMODE:
6492	>e166		00				                .byte 0
6493	>e167		00				                .byte 0
6494	.e168		00		brk #		                brk
6495	.e169		01 02		ora ($02,x)	                ora ($02,x)
6496	>e16b		02				                .byte $02
6497	>e16c		03				                .byte $03
6498							;TSB &0D          :\ E16F= 04 0D       ..
6499	>e16d		04				                .byte $04

6501							;-------------------------------------------------------------------------
6502							;
6503							; Hardware scrolling wraparound size settings for screen mode group.
6504							;
6505							; The values for group 4 (1 KB) are bogus - the Mode 7 addressing
6506							; wraparound is handled differently.
6507							;
6508	.e16e						latchBit5ForScreenMODEGroup:
6509	>e16e		0d				                .byte 5|8                    ;20 KB
6510	>e16f		05				                .byte 5|0                    ;16 KB
6511	>e170		0d				                .byte 5|8                    ;10 KB
6512	>e171		05				                .byte 5|0                    ; 8 KB
6513	.e172						latchBit4ForScreenMODEGroup:
6514	>e172		04				                .byte 4|0                    ;20 KB (also benign value for 1 KB)
6515	>e173		04				                .byte 4|0                    ;16 KB
6516	>e174		0c				                .byte 4|8                    ;10 KB
6517	>e175		0c				                .byte 4|8                    ; 8 KB
6518	>e176		04				                .byte 4|0                    ;(benign value for 1 KB)

6520							;-------------------------------------------------------------------------

6522	.e177						screenSizeHighByteForScreenMODEGroup:
6523	>e177		50				                .byte $50
6524	>e178		40				                .byte $40
6525	>e179		28				                .byte $28
6526	>e17a		20				                .byte $20
6527	>e17b		04				                .byte $04
6528	.e17c						startScreenAddressHighByteForScreenMODEGroup:
6529	>e17c		30				                .byte $30
6530	>e17d		40				                .byte $40
6531	>e17e		58				                .byte $58
6532	>e17f		60				                .byte $60
6533	>e180		7c				                .byte $7c
6534	.e181						crtcRegisterLastIndexForScreenMODEGroup:
6535	>e181		0b				                .byte (crtcRegisterValues20KB-crtcRegisterValues)+$0B
6536	>e182		17				                .byte (crtcRegisterValues16KB-crtcRegisterValues)+$0B
6537	>e183		23				                .byte (crtcRegisterValues10KB-crtcRegisterValues)+$0B
6538	>e184		2f				                .byte (crtcRegisterValues8KB-crtcRegisterValues)+$0B
6539	>e185		3b				                .byte (crtcRegisterValues1KB-crtcRegisterValues)+$0B
6540	.e186						crtcRegisterValues:
6541	.e186						crtcRegisterValues20KB:                   ;MODEs 0/1/2
6542	>e186		7f				                .byte $7F            ;R0 - Horizontal Total
6543	>e187		50				                .byte $50            ;R1 - Horizontal Displayed
6544	>e188		62				                .byte $62            ;R2 - Horizontal Sync
6545	>e189		28				                .byte $28            ;R3 - Sync Width (%vvvvhhhh)
6546	>e18a		26				                .byte $26            ;R4 - Vertical Total
6547	>e18b		00				                .byte $00            ;R5 - Vertical Total Adjust
6548	>e18c		20				                .byte $20            ;R6 - Vertical Displayed
6549	>e18d		22				                .byte $22            ;R7 - Vertical Sync Position
6550	>e18e		01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6551	>e18f		07				                .byte $07               ;R9 - Scan lines per character
6552	>e190		67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6553	>e191		08				                .byte 8                    ;R11 - Cursor End
6554	.e192						crtcRegisterValues16KB:                    ;MODE 3
6555	>e192		7f				                .byte $7F                 ;R0 - Horizontal Total
6556	>e193		50				                .byte $50                 ;R1 - Horizontal Displayed
6557	>e194		62				                .byte $62                 ;R2 - Horizontal Sync
6558	>e195		28				                .byte $28                 ;R3 - Sync Width (%vvvvhhhh)
6559	>e196		1e				                .byte $1e                 ;R4 - Vertical Total
6560	>e197		02				                .byte $02                 ;R5 - Vertical Total Adjust
6561	>e198		19				                .byte $19                 ;R6 - Vertical Displayed
6562	>e199		1b				                .byte $1B                 ;R7 - Vertical Sync Position
6563	>e19a		01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6564	>e19b		09				                .byte $09               ;R9 - Scan lines per character
6565	>e19c		67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6566	>e19d		09				                .byte 9                      ;R11 - Cursor End
6567	.e19e						crtcRegisterValues10KB:                      ;MODEs 4/5
6568	>e19e		3f				                .byte $3f                 ;R0 - Horizontal Total
6569	>e19f		28				                .byte $28                 ;R1 - Horizontal Displayed
6570	>e1a0		31				                .byte $31                 ;R2 - Horizontal Sync
6571	>e1a1		24				                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
6572	>e1a2		26				                .byte $26                 ;R4 - Vertical Total
6573	>e1a3		00				                .byte $00                 ;R5 - Vertical Total Adjust
6574	>e1a4		20				                .byte $20                 ;R6 - Vertical Displayed
6575	>e1a5		22				                .byte $22                 ;R7 - Vertical Sync Position
6576	>e1a6		01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6577	>e1a7		07				                .byte $07               ;R9 - Scan lines per character
6578	>e1a8		67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6579	>e1a9		08				                .byte 8                      ;R11 - Cursor End
6580	.e1aa						crtcRegisterValues8KB:                       ;MODE 6
6581	>e1aa		3f				                .byte $3F                 ;R0 - Horizontal Total
6582	>e1ab		28				                .byte $28                 ;R1 - Horizontal Displayed
6583	>e1ac		31				                .byte $31                 ;R2 - Horizontal Sync
6584	>e1ad		24				                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
6585	>e1ae		1e				                .byte $1e                 ;R4 - Vertical Total
6586	>e1af		02				                .byte $02                 ;R5 - Vertical Total Adjust
6587	>e1b0		19				                .byte $19                 ;R6 - Vertical Displayed
6588	>e1b1		1b				                .byte $1B                 ;R7 - Vertical Sync Position
6589	>e1b2		01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6590	>e1b3		09				                .byte $09               ;R9 - Scan lines per character
6591	>e1b4		67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6592	>e1b5		09				                .byte 9                      ;R11 - Cursor End
6593	.e1b6						crtcRegisterValues1KB:                       ;MODE 7
6594	>e1b6		3f				                .byte $3f                 ;R0 - Horizontal Total
6595	>e1b7		28				                .byte $28                 ;R1 - Horizontal Displayed
6596	>e1b8		33				                .byte $33                 ;R2 - Horizontal Sync
6597	>e1b9		24				                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
6598	>e1ba		1e				                .byte $1e                 ;R4 - Vertical Total
6599	>e1bb		02				                .byte $02                 ;R5 - Vertical Total Adjust
6600	>e1bc		19				                .byte $19                 ;R6 - Vertical Displayed
6601	>e1bd		1b				                .byte $1b                 ;R7 - Vertical Sync Position
6602	>e1be		93				                .byte CRTC.R8.cursorDelay2|CRTC.R8.displayDelay1|CRTC.R8.interlaceSyncAndVideo ;R8 - Interlace/Delay
6603	>e1bf		12				                .byte $12               ;R9 - Scan lines per character
6604	>e1c0		72				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|18 ;R10 - Cursor blink/start
6605	>e1c1		13				                .byte 19                     ;R11 - Cursor End

6607							;-------------------------------------------------------------------------
6608							;
6609							; Default ECF patterns [MasRef E.3-16]
6610							;
6611							; Only half the pattern is stored. Each pattern repeats every 4
6612							; scanlines.
6613							;
6614	.e1c2						defaultECFPatterns:
6615							                ; MODE 4
6616	>e1c2		aa 00 aa 00			                .byte $aa,$00,$aa,$00        ;1 - Dark grey
6617	>e1c6		aa 55 aa 55			                .byte $aa,$55,$aa,$55        ;2 - Grey
6618	>e1ca		ff 55 ff 55			                .byte $ff,$55,$ff,$55        ;3 - Light grey
6619	>e1ce		11 22 44 88			                .byte $11,$22,$44,$88        ;4 - Hatching

6621							                ; MODE 1/5
6622	>e1d2		a5 0f a5 0f			                .byte $a5,$0f,$a5,$0f        ;1 - Red-orange
6623	>e1d6		a5 5a a5 5a			                .byte $a5,$5a,$a5,$5a        ;2 - Orange
6624	>e1da		f0 5a f0 5a			                .byte $f0,$5a,$f0,$5a        ;3 - Yellow-orange
6625	>e1de		f5 fa f5 fa			                .byte $f5,$fa,$f5,$fa        ;4 - Cream

6627							                ; MODE 2
6628	>e1e2		0b 07 0b 07			                .byte $0b,$07,$0b,$07        ;1 - Orange
6629	>e1e6		23 13 23 13			                .byte $23,$13,$23,$13        ;2 - Pink
6630	>e1ea		0e 0d 0e 0d			                .byte $0e,$0d,$0e,$0d        ;3 - Yellow-green
6631	>e1ee		1f 2f 1f 2f			                .byte $1f,$2f,$1f,$2f        ;4 - Cream

6633							                ; MODE 0
6634	>e1f2		cc 00 cc 00			                .byte $cc,$00,$cc,$00        ;0 - Dark grey
6635	>e1f6		cc 33 cc 33			                .byte $cc,$33,$cc,$33        ;1 - Grey
6636	>e1fa		ff 33 ff 33			                .byte $ff,$33,$ff,$33        ;2 - Light grey
6637	>e1fe		03 0c 30 c0			                .byte $03,$0c,$30,$c0        ;4 - Hatching

6639	.e202						LE204:
6640	>e202		01				                .byte $01                    ;---
6641	>e203		01				                .byte $01                    ;--h
6642	>e204		03				                .byte $03                    ;-v-
6643	>e205		03				                .byte $03                    ;-vh
6644	>e206		02				                .byte $02                    ;x--
6645	>e207		00				                .byte $00                    ;x-h
6646	>e208		02				                .byte $02                    ;xv-
6647	>e209		00				                .byte $00                    ;xvh

6649	.e20a						scrollRoutinesTable:
6650	>e20a		5f c9				                .word LC95F
6651	>e20c		6b c9				                .word LC96B
6652	>e20e		5f c9				                .word LC95F
6653	>e210		6b c9				                .word LC96B
6654	>e212		9d c9				                .word LC99D
6655	>e214		9d c9				                .word LC99D
6656	>e216		a4 c9				                .word LC9A4
6657	>e218		a4 c9				                .word LC9A4
6658	>e21a		c3 c9				                .word LC9C3
6659	>e21c		2d ca				                .word LCA2D
6660	>e21e		c3 c9				                .word LC9C3
6661	>e220		2d ca				                .word LCA2D
6662	>e222		f1 ca				                .word LCAF1
6663	>e224		f1 ca				                .word LCAF1
6664	>e226		fa ca				                .word LCAFA
6665	>e228		fa ca				                .word LCAFA

6667							;-------------------------------------------------------------------------
6668							;
6669							; Get address of soft character definition.
6670							;
6671							; entry:
6672							;
6673							; A = character (32-255)
6674							;
6675							; exit:
6676							;
6677							; (ZTEMPC) = address
6678							;
6679	.e22a						getSoftCharacterDefinitionAddress:
6680	.e22a		0a		asl a		                asl a                        ;a bcdefgh0
6681	.e22b		2a		rol a		                rol a                        ;b cdefgh0a
6682	.e22c		2a		rol a		                rol a                        ;c defgh0ab
6683	.e22d		a8		tay		                tay
6684	.e22e		29 03		and #$03	                and #$03                     ;c 000000ab
6685	.e230		2a		rol a		                rol a                        ;0 00000abc
6686	.e231		69 88		adc #$88	                adc #(>andy.softCharacterDefinitions)-1
6687	.e233		85 df		sta $df		                sta ZTEMPC+1
6688	.e235		98		tya		                tya                          ;0 defgh0ab
6689	.e236		29 f8		and #$f8	                and #$F8                     ;0 defgh000
6690	.e238		85 de		sta $de		                sta ZTEMPC+0
6691	.e23a		60		rts		                rts                          ;

6693							;-------------------------------------------------------------------------
6694							;
6695							; OSBYTE 165 (&A5) Read output cursor position [MasRef D.2-50]
6696							;
6697	.e23b						osbyteA5:
6698	.e23b		20 2d f3	jsr $f32d	                jsr withMOSROM
6699	.e23e		24 d0		bit $d0		                bit STATE
6700	.e240		50 0e		bvc $e250	                bvc getTextCursorPositionWithColumn81                    ;taken if cursor editing
6701	.e242		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
6702	.e245		20 50 e2	jsr $e250	                jsr getTextCursorPositionWithColumn81
6703	.e248		da		phx		                phx
6704	.e249		5a		phy		                phy
6705	.e24a		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
6706	.e24d		7a		ply		                ply
6707	.e24e		fa		plx		                plx
6708	.e24f		60		rts		                rts

6710							;-------------------------------------------------------------------------
6711							;
6712							; Get text cursor position, taking the column 81 flag into account and
6713							; reporting the X coordinate as N+1 in that case.
6714							;
6715	.e250						getTextCursorPositionWithColumn81:
6716	.e250		20 6b e2	jsr $e26b	                jsr getTextCursorPosition
6717	.e253		2c 6c 03	bit $036c	                bit vduv.column81
6718	.e256		10 01		bpl $e259	                bpl +                       ;taken if not at column 81
6719	.e258		e8		inx		                inx                         ;X=81
6720	.e259						+
6721	.e259		60		rts		                rts

6723							;-------------------------------------------------------------------------

6725	.e25a						LE25C:
6726	.e25a		38		sec		                sec
6727	.e25b		ad 0a 03	lda $030a	                lda vduv.textWindowRight
6728	.e25e		ed 08 03	sbc $0308	                sbc vduv.textWindowLeft
6729	.e261		48		pha		                pha
6730	.e262		a9 00		lda #$00	                lda #$00
6731	.e264		a8		tay		                tay
6732	.e265		80 10		bra $e277	                bra LE279

6734							;-------------------------------------------------------------------------
6735							;
6736							; OSBYTE 134 (&86) Read text cursor position [MasRef D.2-41]
6737							;
6738	.e267						osbyte86:
6739	.e267		24 d0		bit $d0		                bit STATE
6740	.e269		50 d0		bvc $e23b	                bvc osbyteA5       ;taken if not cursor editing
6741	.e26b						getTextCursorPosition:
6742	.e26b		a9 02		lda #$02	                lda #VDUVariables.cursorFlags.invertHorizontal
6743	.e26d		a0 10		ldy #$10	                ldy #VDUVariables.textCursorXPosition-VDUVariables.textWindow
6744	.e26f		a2 00		ldx #$00	                ldx #VDUVariables.textWindowLeft-VDUVariables.textWindow
6745	.e271		20 88 e2	jsr $e288	                jsr getTextWindowRelativePosition
6746	.e274		48		pha		                pha                          ;save X position
6747	.e275		a9 04		lda #$04	                lda #VDUVariables.cursorFlags.invertVertical
6748	.e277						LE279:
6749	.e277		c8		iny		                iny               ;i.e., offset of textCursorYPosition
6750	.e278		a2 03		ldx #$03	                ldx #VDUVariables.textWindowTop-VDUVariables.textWindow
6751	.e27a		20 88 e2	jsr $e288	                jsr getTextWindowRelativePosition
6752	.e27d		aa		tax		                tax                          ;X = Y position
6753	.e27e		a8		tay		                tay                          ;Y = Y position
6754	.e27f		a9 08		lda #$08	                lda #vduv.cursorFlags.swapAxes
6755	.e281		2c 66 03	bit $0366	                bit vduv.cursorFlags
6756	.e284		f0 24		beq $e2aa	                beq plx_rts ;taken if axes unswapped - so X = X position, Y = Y position
6757	.e286		7a		ply		                ply                          ;Y = Y position, X = X position
6758	.e287		60		rts		                rts

6760							;-------------------------------------------------------------------------
6761							;
6762							; Get text window-relative cursor position, taking into account cursor
6763							; flags.
6764							;
6765							; entry:
6766							;
6767							; A = cursorFlags bit for axis of interest - invertHorizontal or invertVertical
6768							;
6769							; X = offset in VDU variables of text window minimum for axis of interest
6770							;
6771							; Y = offset in VDU variables of cursor position for axis of interest
6772							;
6773							; exit:
6774							;
6775							; A = text window-relative coordinate
6776							;
6777	.e288						getTextWindowRelativePosition:
6778	.e288		38		sec		                sec                     ;C=1 ready for the subtraction
6779	.e289		2c 66 03	bit $0366	                bit vduv.cursorFlags ;test cursor flags inversion bit of interest
6780	.e28c		f0 0b		beq $e299	                beq axisNotInverted
6781	.e28e						axisInverted:
6782	.e28e		8a		txa		                txa
6783	.e28f		49 02		eor #$02	                eor #$02                     ;swap min and max
6784	.e291		aa		tax		                tax
6785	.e292		bd 08 03	lda $0308,x	                lda vduv.textWindow,x
6786	.e295		f9 08 03	sbc $0308,y	                sbc vduv.textWindow,y
6787	.e298		60		rts		                rts

6789	.e299						axisNotInverted:
6790	.e299		b9 08 03	lda $0308,y	                lda vduv.textWindow,y
6791	.e29c		fd 08 03	sbc $0308,x	                sbc vduv.textWindow,x
6792	.e29f		60		rts		                rts

6794							;-------------------------------------------------------------------------
6795							;
6796							; Get default bounds for current mode.
6797							;
6798							; exit:
6799							;
6800							; X = max column (19, 39 or 79)
6801							;
6802							; Y = max row (24 or 31)
6803							;
6804							; preserves: A, C
6805							;
6806	.e2a0						getDefaultBoundsForCurrentScreenMODE:
6807	.e2a0		ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
6808	.e2a3		bc 07 e1	ldy $e107,x	                ldy modeMaxColumn,x          ;Y = max column
6809	.e2a6		5a		phy		                phy                          ;save max column
6810	.e2a7		bc ff e0	ldy $e0ff,x	                ldy modeMaxRow,x             ;Y = max row
6811	.e2aa						plx_rts:
6812	.e2aa		fa		plx		                plx                          ;X = max column
6813	.e2ab		60		rts		                rts

6815							;-------------------------------------------------------------------------
6816							;
6817							; Swap edit cursor position and text cursor position.
6818							;
6819	.e2ac						exchangeEditCursorPositionAndTextCursorPosition:
6820	.e2ac		a2 18		ldx #$18	                ldx #VDUVariables.textCursorXPosition
6821	.e2ae		a0 64		ldy #$64	                ldy #VDUVariables.editCursorXPosition

6823							;-------------------------------------------------------------------------
6824							;
6825							; Swap 2 bytes in the VDU variables.
6826							;
6827							; entry:
6828							;
6829							; X = offset of one set of 2 bytes
6830							;
6831							; Y = offset of the other set of 2 bytes
6832							;
6833	.e2b0						exchangeTwoVDUBytes:
6834	.e2b0		a9 02		lda #$02	                lda #$02
6835	.e2b2		80 06		bra $e2ba	                bra exchangeVDUVariables

6837							;-------------------------------------------------------------------------
6838							;
6839							; Swap graphics cursor and old graphics cursor.
6840							;
6841	.e2b4						LE2B6:
6842	.e2b4		a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX
6843	.e2b6						LE2B8:
6844	.e2b6		a0 14		ldy #$14	                ldy #VDUVariables.oldGraphicsCursorPixelsX

6846							;-------------------------------------------------------------------------
6847							;
6848							; Swap 4 bytes in the VDU variables.
6849							;
6850							; entry:
6851							;
6852							; X = offset of one set of 4 bytes
6853							;
6854							; Y = offset of the other set of 4 bytes
6855							;
6856	.e2b8						exchangeFourVDUBytes:
6857	.e2b8		a9 04		lda #$04	                lda #$04

6859							;-------------------------------------------------------------------------
6860							;
6861							; Swap bytes in the VDU variables.
6862							;
6863							; entry:
6864							;
6865							; A = number of bytes to swap
6866							;
6867							; X = offset of one set of bytes
6868							;
6869							; Y = offset of the other set of bytes
6870							;
6871	.e2ba						exchangeVDUVariables:
6872	.e2ba		48		pha		                pha                          ;save count remaining
6873	.e2bb		bd 00 03	lda $0300,x	                lda vduv,x
6874	.e2be		48		pha		                pha
6875	.e2bf		b9 00 03	lda $0300,y	                lda vduv,y
6876	.e2c2		9d 00 03	sta $0300,x	                sta vduv,x
6877	.e2c5		68		pla		                pla
6878	.e2c6		99 00 03	sta $0300,y	                sta vduv,y
6879	.e2c9		e8		inx		                inx
6880	.e2ca		c8		iny		                iny
6881	.e2cb		68		pla		                pla
6882	.e2cc		3a		dec a		                dec a
6883	.e2cd		d0 eb		bne $e2ba	                bne exchangeVDUVariables
6884	.e2cf		60		rts		                rts

6886							;-------------------------------------------------------------------------
6887							;
6888							; Test current VDU4/VDU5 status.
6889							;
6890							; exit:
6891							;
6892							; Z=0 if VDU5 mode
6893	.e2d0						testVDU5State:
6894	.e2d0		a5 d0		lda $d0		                lda STATE
6895	.e2d2		29 20		and #$20	                and #STATE.isVDU5
6896	.e2d4		60		rts		                rts

6898							;-------------------------------------------------------------------------

6900							                .if version>=350
6901	.e2d5						LE2E7:
6902	.e2d5		20 2d f3	jsr $f32d	                jsr withMOSROM
6903	.e2d8		4c 04 e9	jmp $e904	                jmp callPrinterDriverWithPrinterBuffer
6904							                .endif

6906							;-------------------------------------------------------------------------

6908							                .if version>=350
6909	.e2db						LE2ED:
6910	.e2db		20 2d f3	jsr $f32d	                jsr withMOSROM
6911	.e2de		4c 83 e8	jmp $e883	                jmp LE8B9
6912							                .endif

6914							;-------------------------------------------------------------------------

6916							                .if version>=350
6917	.e2e1						LE2F3:
6918	.e2e1		20 2d f3	jsr $f32d	                jsr withMOSROM
6919	.e2e4		6c 26 02	jmp ($0226)	                jmp (VDUV)
6920							                .endif

6922							;-------------------------------------------------------------------------

6924							; Default vector table
6925							; ====================
6926	.e2e7						defaultVectorTable: .block
6927	>e2e7		29 f9				                .word badCommandError        ; USERV=$200
6928	>e2e9		2f e5				                .word defaultBRKHandler      ; BRKV=$202
6929	>e2eb		c9 e5				                .word irq1EntryPoint         ; IRQ1V=$204
6930	>e2ed		d6 e5				                .word irq2EntryPoint         ; IRQ2V=$206
6931	>e2ef		ce e7				                .word oscliEntryPoint        ; CLIV=$208
6932	>e2f1		21 ee				                .word osbyteEntryPoint       ; BYTEV=$20a
6933	>e2f3		98 ee				                .word oswordEntryPoint       ; WORDV=$20c
6934	>e2f5		ee e7				                .word oswrchEntryPoint       ; WRCHV=$20e
6935	>e2f7		88 e7				                .word osrdchEntryPoint       ; RDCHV=$210
6936	.e2f9						fsVectors: .block
6937	>e2f9		1b ff				                .word E_FILEV                ; FILEV=$212
6938	>e2fb		1e ff				                .word E_ARGSV                ; ARGSV=$214
6939	>e2fd		21 ff				                .word E_BGETV                ; BGETV=$216
6940	>e2ff		24 ff				                .word E_BPUTV                ; BPUTV=$218
6941	>e301		27 ff				                .word E_GBPBV                ; GBPBV=$21a
6942	>e303		2a ff				                .word E_FINDV                ; FINDV=$21c
6943	>e305		2d ff				                .word E_FSCV                 ; FSCV=$21e
6944	.e307						end:
6945							                .bend
6946	>e307		aa ff				                .word rtsFFAA                ; EVENTV=$220
6947	>e309		aa ff				                .word rtsFFAA                ; UPTV=$222
6948	>e30b		aa ff				                .word rtsFFAA                ; NETV=$224
6949	>e30d		aa ff				                .word rtsFFAA                ; VDUV=$226
6950	>e30f		27 f4				                .word keyEntryPoint          ; KEYV=$228
6951	>e311		07 ea				                .word insEntryPoint          ; INSV=$22a
6952	>e313		bc e9				                .word remEntryPoint          ; REMV=$22c
6953	>e315		45 e9				                .word cnpEntryPoint          ; CNPV=$22e
6954	>e317		aa ff				                .word rtsFFAA                ; IND1V=$230
6955	>e319		aa ff				                .word rtsFFAA                ; IND2V=$232
6956	>e31b		aa ff				                .word rtsFFAA                ; IND3V=$234
6957	.e31d						end:
6958							                .bend

6960							                ; valueFF is a (presumably arbitrary) byte with the
6961							                ; value 255, that's BIT'd in a few places to set the V
6962							                ; flag.
6963	.e31d						defaultMOSVariables:
6964	>e31d		90 01				                .word mosVariables-166       ;mosVariablesAddress
6965	>e31f		9f 0d				                .word extendedVectorSpace    ;extendedVectorSpaceAddress
6966	>e321		a1 02				                .word romInformationTable  ;romInformationTableAddress
6967	>e323		a0 f5				                .word keyTranslationTable-16 ;keyboardTranslationTableAddress
6968	>e325		00 03				                .word vduv                   ;vduVariablesAddress
6969	>e327		00				                .byte $00                    ;cfsTimeoutCounter
6970	>e328		00				                .byte $00                    ;inputSource
6971	>e329		ff				                .byte $FF                    ;keyboardSemaphore
6972	>e32a		00				                .byte $00                    ;romPollingSemaphore
6973	>e32b		00				                .byte $00                    ;oshwm
6974	>e32c		01				                .byte $01                    ;rs423InputInterpretationStatus
6975	>e32d		00				                .byte $00                    ;noignoreState
6976	>e32e		00				                .byte $00                    ;cfsRFSFSSwitch
6977	>e32f		00				                .byte $00                    ;vcontrolRegister
6978	>e330		00				                .byte $00                    ;vpaletteRegister
6979	>e331		00				                .byte $00                    ;romActiveAtLastBRK
6980	>e332		ff				                .byte $FF                    ;basicROMNumber
6981							                .if version<500
6982	>e333		04				                .byte $04                    ;currentADCChannel
6983	>e334		04				                .byte $04                    ;maximumADCChannel
6987							                .endif
6988	>e335		00				                .byte $00                    ;adcConversionType
6989	>e336		ff				                .byte $FF                    ;rs423Busy
6990							                .if version==400
6992							                .else
6993	>e337		42				                .byte $42                    ;aciaControlRegister
6994							                .endif
6995	>e338		19				                .byte $19                    ;flashCounter
6996	>e339		19				                .byte $19                    ;firstFlashColourDuration
6997	>e33a		19				                .byte $19                    ;secondFlashColourDuration
6998	>e33b		32				                .byte $32                    ;keyboardAutoRepeatDelay
6999	>e33c		08				                .byte $08                    ;keyboardAutoRepeatRate
7000	>e33d		00				                .byte $00                    ;execFileHandle
7001	>e33e		00				                .byte $00                    ;spoolFileHandle
7002	>e33f		00				                .byte $00                    ;breakAndESCAPEEffect
7003	>e340		00				                .byte $00                    ;keyboardStatus
7004	>e341		20				                .byte $20                    ;keyboardStatusByte
7005	>e342		09				                .byte $09                    ;rs423InputBufferMinimumSpace
7006	>e343		00				                .byte $00                    ;rs423Ignore
7007	>e344		00				                .byte $00                    ;rs423Destination
7008	>e345		00				                .byte $00                    ;econetInterceptionStatus
7009	>e346		00				                .byte $00                    ;econetInputInterpretationStatus
7010	>e347		00				                .byte $00                    ;econetOutputInterpretationStatus
7011	>e348		00				                .byte $00                    ;speechSystemByte1
7012	>e349		00				                .byte $00                    ;soundSuppressionStatus
7013	>e34a		03				                .byte $03                    ;bellChannel
7014	>e34b		90				                .byte $90                    ;bellSound
7015	>e34c		64				                .byte $64                    ;bellFrequency
7016	>e34d		06				                .byte $06                    ;bellDuration
7017	>e34e		81				                .byte $81                    ;startupMessageSuppressionStatus
7018	>e34f		00				                .byte $00                    ;softKeyStringLength
7019	>e350		00				                .byte $00                    ;pagedModeCounter
7020	>e351		00				                .byte $00                    ;vduQueueNegativeLength
7021	>e352		09				                .byte $09                    ;tabKeyCode
7022	>e353		1b				                .byte $1B                    ;escapeCharacter
7023	>e354		01				                .byte $01                    ;input192To207Interpretation
7024	>e355		d0				                .byte $D0                    ;input208To223Interpretation
7025	>e356		e0				                .byte $E0                    ;input224To239Interpretation
7026	>e357		f0				                .byte $F0                    ;input240To255Interpretation
7027	>e358		01				                .byte $01                    ;softKeyInterpretation
7028	>e359		80				                .byte $80                    ;shiftSoftKeyInterpretation
7029	>e35a		90				                .byte $90                    ;ctrlSoftKeyInterpretation
7030	>e35b		00				                .byte $00                    ;shiftCtrlSoftKeyInterpretation
7031	>e35c		00				                .byte $00                    ;escapeKeyStatus
7032	>e35d		00				                .byte $00                    ;escapeEffects
7033	>e35e		ff				valueFF:        .byte $FF                    ;userVIAInterruptMask
7034	>e35f		ff				                .byte $FF                    ;rs423InterruptMask
7035	>e360		ff				                .byte $FF                    ;systemVIAInterruptMask
7036	>e361		00				                .byte $00                    ;tubePresence
7037	>e362		00				                .byte $00                    ;speechSystemByte2
7038	>e363		00				                .byte $00                    ;characterDestinationStatus
7039	>e364		00				                .byte editKeysMode.editKeys  ;editKeysMode
7040	>e365		30				                .byte $30                    ;numericKeypadInterpretation
7041	>e366		01				                .byte $01                    ;shadowRAMState
7042	>e367		00				                .byte $00                    ;countryFlag
7043	>e368		00				                .byte $00                    ;userFlag
7044							                .if version==400
7046							                .else
7047	>e369		64				                .byte $64                    ;serialULARegister
7048							                .endif
7049	>e36a		05				                .byte initialTimerSwitchState ;timerSwitchState
7050	>e36b		ff				                .byte $FF                    ;softKeyConsistencyFlag
7051							                .if version==400
7053							                .else
7054	>e36c		01				                .byte $01                    ;printerDriverType
7055							                .endif
7056	>e36d		0a				                .byte $0a                    ;printerIgnoreChar
7057	>e36e		00				                .byte $00                    ;breakVectorByte0
7058	>e36f		00				                .byte $00                    ;breakVectorByte1
7059	>e370		00				                .byte $00                    ;breakVectorByte2
7060	>e371		00				                .byte $00                    ;vduDriverMemory
7061	>e372		00				                .byte $00                    ;displayMemory
7062	>e373		ff				                .byte $FF                    ;currentLanguageROM

7064							;-------------------------------------------------------------------------
7065							;
7066							; STARTUP
7067							; =======
7068							;
7069	.e374						resetEntryPoint:                ;e364
7070	.e374		a9 40		lda #$40	                lda #$40        ; $40 = RTI
7071	.e376		8d 00 0d	sta $0d00	                sta nmiEntryPoint ; make NMI routine a no-op
7072	.e379		78		sei		                sei
7073	.e37a		a9 53		lda #$53	                lda #$53                 ; ???
7074	.e37c		8d 8e fe	sta $fe8e	                sta LFE8E                ; ???
7075							                .if version==350
7076	.e37f		a9 fe		lda #$fe	                lda #~ACCCON.D
7077	.e381		1c 34 fe	trb $fe34	                trb ACCCON
7078	.e384		1c 66 03	trb $0366	                trb vduv.cursorFlags
7079	.e387		ad 34 fe	lda $fe34	                lda ACCCON
7080	.e38a		09 4c		ora #$4c	                ora #ACCCON.TST|ACCCON.Y|ACCCON.X
7081							                .endif
7082							                .if version==350
7083	.e38c		20 92 e3	jsr $e392	                jsr staTEMPAAndACCCON
7084	.e38f		4c 00 fc	jmp $fc00	                jmp reset
7088							                .endif

7090							;-------------------------------------------------------------------------

7092							                .if version==350
7093	.e392						staTEMPAAndACCCON:
7094	.e392		85 fc		sta $fc		                sta TEMPA
7095	.e394		8d 34 fe	sta $fe34	                sta ACCCON
7096	.e397		60		rts		                rts
7097							                .endif

7099							;-------------------------------------------------------------------------

7101							                .if version!=350&&(includeTubeSupport||version>=500)
7103							                .endif

7105							;-------------------------------------------------------------------------
7106							;
7107							;
7108							;
7109							                .if version==350
7110	.e398						clearTSTAndLE389:
7111	.e398		20 5c f3	jsr $f35c	                jsr withTSTClear
7112							                .endif

7114	.e39b						LE389:
7115	.e39b		5a		phy		                phy
7116	.e39c		da		phx		                phx
7117							                .if useTableDrivenConfigure
7118	.e39d		20 5a e5	jsr $e55a	                jsr selectTerminalROM
7119	.e3a0		20 f4 84	jsr $84f4	                jsr L873F
7127							                .endif
7128	.e3a3		c9 01		cmp #$01	                cmp #$01                     ;C set if ROM is inserted
7129	.e3a5		fa		plx		                plx
7130	.e3a6		7a		ply		                ply
7131	.e3a7		4c 4b e5	jmp $e54b	                jmp selectROMX

7133							;-------------------------------------------------------------------------
7134							;
7135							; Scan ROMs and fill in the rom information table.
7136							;
7137							; entry:
7138							;
7139							; X = first ROM to scan
7140							;
7141							                .if version!=350
7146							                .endif

7148							;-------------------------------------------------------------------------
7149							;
7150							; Checks a ROM is valid - i.e., has a valid-looking copyright string.
7151							;
7152							; Entry:
7153							;
7154							; X = ROM to check
7155							;
7156							; Exit:
7157							;
7158							; C=0 if ROM invalid; C=1 if ROM valid
7159							;
7160							; ROM of interest is selected
7161							;
7162	.e3aa						isROMValid: .proc ;e3f7
7163	.e3aa		20 4b e5	jsr $e54b	                jsr selectROMX
7164	.e3ad		a2 03		ldx #$03	                ldx #$03
7165	.e3af		ac 07 80	ldy $8007	                ldy $8007       ; fetch ROM copyright offset pointer
7166	.e3b2		18		clc		                clc             ; assume no match
7167	.e3b3						-
7168	.e3b3		b9 00 80	lda $8000,y	                lda $8000,y     ; fetch possible ROM copyright char
7169	.e3b6		5d ce e4	eor $e4ce,x	                eor sidewaysROMCopyrightPrefix,x     ; Z=1 if it matches "\x0(C)"
7170	.e3b9		d0 05		bne $e3c0	                bne +           ; branch taken if no match
7171	.e3bb		c8		iny		                iny             ; next copyright byte
7172	.e3bc		ca		dex		                dex             ; count 4 chars
7173	.e3bd		10 f4		bpl $e3b3	                bpl -
7174	.e3bf		38		sec		                sec             ; C=1 means a match
7175	.e3c0						+
7176	.e3c0		60		rts		                rts
7177							                .pend

7179							;-------------------------------------------------------------------------

7181							; End of STARTUP code
7182							; ===================
7183	.e3c1						LE40E:
7184	.e3c1		38		sec		                sec                      ; Call Break Intercept Vector
7185	.e3c2		20 d8 f2	jsr $f2d8	                jsr osbyte247EntryPoint
7186	.e3c5		a2 27		ldx #$27	                ldx #romServiceCallInformReset
7187	.e3c7		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
7188	.e3ca		ac 56 02	ldy $0256	                ldy execFileHandle ; Get Exec handle, skip past if closed
7189	.e3cd		f0 08		beq $e3d7	                beq LE424
7190	.e3cf		9c 56 02	stz $0256	                stz execFileHandle           ; Clear Exec handle
7191	.e3d2		a9 00		lda #$00	                lda #$00                     ; Close Exec channel
7192	.e3d4		20 ce ff	jsr $ffce	                jsr OSFIND
7193	.e3d7						LE424:
7194	.e3d7		38		sec		                sec                          ;
7195	.e3d8		6e 00 df	ror $df00	                ror hazel.currentFS
7196	.e3db		ad 8d 02	lda $028d	                lda lastBREAKType            ; Soft Break
7197	.e3de		f0 04		beq $e3e4	                beq LE431
7198	.e3e0		38		sec		                sec                          ;
7199	.e3e1		6e 02 df	ror $df02	                ror hazel.libFS
7200	.e3e4						LE431:
7201	.e3e4		20 a7 ed	jsr $eda7	                jsr LEE64                    ; Set default ROMFS/TAPEFS settings
7202	.e3e7		20 a3 f1	jsr $f1a3	                jsr osbyte76                    ; Test Shift and Ctrl keys
7203							                .if version==350
7204	.e3ea		20 20 e5	jsr $e520	                jsr LE520
7210							                .endif
7211	.e3ed		4d 8f 02	eor $028f	                eor startupOptions ; Toggle with OSBYTE 255 boot status
7212	.e3f0		29 08		and #$08	                and #$08
7213	.e3f2		a8		tay		                tay
7214	.e3f3		ae 03 df	ldx $df03	                ldx hazel.currentFSROM
7215	.e3f6		ad 8d 02	lda $028d	                lda lastBREAKType ; Soft Break, use current filing system
7216	.e3f9		f0 09		beq $e404	                beq LE454
7217	.e3fb		20 5a e5	jsr $e55a	                jsr selectTerminalROM
7218							                .if useTableDrivenConfigure
7219	.e3fe		a2 3b		ldx #$3b	                ldx #configureTable.file.metadata-configureTable
7220	.e400		20 34 88	jsr $8834	                jsr readConfigurationByte
7226							                .endif

7228	.e403		aa		tax		                tax
7229	.e404						LE454:
7230	.e404		3c a1 02	bit $02a1,x	                bit romInformationTable,x
7231	.e407		10 1f		bpl $e428	                bpl LE478
7232	.e409		20 4b e5	jsr $e54b	                jsr selectROMX
7233	.e40c		e0 0f		cpx #$0f	                cpx #terminalROM
7234	.e40e		d0 0c		bne $e41c	                bne LE46C
7235	.e410		20 31 f6	jsr $f631	                jsr osbyte7A
7236	.e413		e8		inx		                inx
7237	.e414		f0 19		beq $e42f	                beq LE47F
7238	.e416		e0 63		cpx #$63	                cpx #$63
7239	.e418		f0 15		beq $e42f	                beq LE47F
7240	.e41a		80 0c		bra $e428	                bra LE478

7242	.e41c						LE46C:
7243	.e41c		a9 03		lda #$03	                lda #romServiceCallAutoBoot  ; Filing System selection
7244	.e41e		20 03 80	jsr $8003	                jsr $8003
7245	.e421		aa		tax		                tax
7246	.e422		20 5a e5	jsr $e55a	                jsr selectTerminalROM
7247	.e425		8a		txa		                txa
7248	.e426		f0 2b		beq $e453	                beq LE4A3
7249	.e428						LE478:
7250	.e428		a2 03		ldx #$03	                ldx #romServiceCallAutoBoot
7251	.e42a		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
7252	.e42d		f0 24		beq $e453	                beq LE4A3
7253	.e42f						LE47F:
7254	.e42f		98		tya		                tya
7255	.e430		d0 17		bne $e449	                bne LE499
7256	.e432		a9 8d		lda #$8d	                lda #$8D
7257	.e434		20 da ec	jsr $ecda	                jsr osbyte8C8D
7258	.e437		a2 b5		ldx #$b5	                ldx #<starRunBOOT
7259	.e439		a0 f3		ldy #$f3	                ldy #>starRunBOOT
7260	.e43b		ce 67 02	dec $0267	                dec startupMessageSuppressionStatus
7261	.e43e		20 f7 ff	jsr $fff7	                jsr OSCLI
7262	.e441		ee 67 02	inc $0267	                inc startupMessageSuppressionStatus
7263	.e444		80 0d		bra $e453	                bra LE4A3

7265							;-------------------------------------------------------------------------

7267	.e446						LE496:
7268	.e446		ee 67 02	inc $0267	                inc startupMessageSuppressionStatus ;set bit 0
7269	.e449						LE499:
7270	.e449		38		sec		                sec
7271	.e44a		6e 00 df	ror $df00	                ror hazel.currentFS
7272							                .if version<400
7273	.e44d		a9 00		lda #$00	                lda #$00
7274	.e44f		aa		tax		                tax
7275	.e450		20 02 ed	jsr $ed02	                jsr selectROMOrTAPE
7281							                .endif
7282	.e453						LE4A3:
7283	.e453		a9 05		lda #$05	                lda #$05                     ;
7284	.e455		ae 85 02	ldx $0285	                ldx printerDriverType        ; *FX5,<current printer>
7285	.e458		20 21 ee	jsr $ee21	                jsr osbyteEntryPoint
7286	.e45b		ad 8d 02	lda $028d	                lda lastBREAKType ; If not Soft Break, select default language
7287	.e45e		d0 0e		bne $e46e	                bne LE4BB
7288	.e460		ae 8c 02	ldx $028c	                ldx currentLanguageROM      ; Get current language ROM
7289							                .if version==350&&!finmos329
7290	.e463		8a		txa		                txa
7291	.e464		29 bf		and #$bf	                and #$bf
7292	.e466		c9 10		cmp #$10	                cmp #$10
7295							                .endif
7296	.e468		90 0d		bcc $e477	                bcc LE4C2
7297							                .if version==350&&!finmos329
7298	.e46a		c9 1f		cmp #$1f	                cmp #$10+terminalROM
7301							                .endif
7302	.e46c		f0 56		beq $e4c4	                beq LE509
7303	.e46e						LE4BB:
7304	.e46e		20 5a e5	jsr $e55a	                jsr selectTerminalROM     ; Page in ROM 15 - UTILS ROM
7305							                .if useTableDrivenConfigure
7306	.e471		a2 5f		ldx #$5f	                ldx #configureTable.lang.metadata-configureTable
7307	.e473		20 34 88	jsr $8834	                jsr readConfigurationByte
7310							                .endif
7311	.e476		aa		tax		                tax
7312	.e477						LE4C2:
7313	.e477		18		clc		                clc

7315							;-------------------------------------------------------------------------
7316							;
7317							; OSBYTE 142 (&8E) Enter language ROM [MasRef D.2-44]
7318							;
7319	.e478						osbyte8E:
7320							                .if version==350
7321	.e478		da		phx		                phx
7322	.e479		8a		txa		                txa
7323	.e47a		29 0f		and #$0f	                and #$f
7324	.e47c		aa		tax		                tax
7325							                .endif
7326	.e47d		3c a1 02	bit $02a1,x	                bit romInformationTable,x ; b6=0, error Not a language
7327							                .if version==350
7328	.e480		fa		plx		                plx
7329							                .endif
7330	.e481		50 4e		bvc $e4d1	                bvc thisIsNotALanguageError
7331	.e483		08		php		                php
7332	.e484		90 16		bcc $e49c	                bcc LE4E1 ;taken if not OSBYTE 142 - so skip ROM check
7333	.e486		20 4b e5	jsr $e54b	                jsr selectROMX
7334	.e489		ad 06 80	lda $8006	                lda sidewaysROMType
7335	.e48c		29 0d		and #$0d	                and #%00001101
7336	.e48e		f0 05		beq $e495	                beq is6502ROM ;taken if low nybble is 0 (6502 BASIC) or 2 (other 6502 ROM)
7337							                .if includeTubeSupport
7338	.e490		2c 7a 02	bit $027a	                bit tubePresence
7341							                .endif
7342	.e493		10 54		bpl $e4e9	                bpl iCannotRunThisCodeError  ;taken if no Tube - assume impossible to run
7343	.e495						is6502ROM:
7344	.e495		da		phx		                phx                          ;save ROM slot
7345	.e496		a2 2a		ldx #$2a	                ldx #romServiceCallLanguageChange
7346	.e498		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
7347	.e49b		fa		plx		                plx                          ;restore ROM slot
7348	.e49c						LE4E1:
7349	.e49c		8e 8c 02	stx $028c	                stx currentLanguageROM
7350	.e49f		20 4b e5	jsr $e54b	                jsr selectROMX
7351	.e4a2		a9 80		lda #$80	                lda #>sidewaysROMName
7352	.e4a4		a0 08		ldy #$08	                ldy #(<sidewaysROMName)-1
7353	.e4a6		20 6f e7	jsr $e76f	                jsr print0TerminatedString
7354	.e4a9		84 fd		sty $fd		                sty errPtr+0
7355	.e4ab		20 e7 ff	jsr $ffe7	                jsr OSNEWL
7356	.e4ae		20 e7 ff	jsr $ffe7	                jsr OSNEWL
7357	.e4b1		28		plp		                plp
7358							                .if includeTubeSupport
7359	.e4b2		a9 01		lda #$01	                lda #$01               ; A=1 on default language entry
7360	.e4b4		2c 7a 02	bit $027a	                bit tubePresence
7361	.e4b7		30 12		bmi $e4cb	                bmi copyLanguageOverTube     ;taken if Tube is present
7362							                .endif
7363	.e4b9		ad 06 80	lda $8006	                lda sidewaysROMType
7364	.e4bc		29 0d		and #$0d	                and #%00001101
7365	.e4be		d0 29		bne $e4e9	                bne iCannotRunThisCodeError ;taken if low nybble isn't 0 (6502 BASIC) or 2 (other 6502 ROM)
7366	.e4c0		1a		inc a		                inc a                   ;A=1 on default language entry
7367	.e4c1		4c 00 80	jmp $8000	                jmp sidewaysROMLanguageEntry

7369	.e4c4						LE509:
7370	.e4c4		a9 00		lda #$00	                lda #$00
7371							                .if includeTubeSupport
7372	.e4c6		2c 7a 02	bit $027a	                bit tubePresence
7373	.e4c9		10 78		bpl $e543	                bpl startCommandLineUI
7374	.e4cb						copyLanguageOverTube:
7375	.e4cb		4c 00 04	jmp $0400	                jmp tubeHost.copyLanguage
7378							                .endif

7380							;-------------------------------------------------------------------------

7382	.e4ce						sidewaysROMCopyrightPrefix: .block
7383	>e4ce		29 43 28			                .text ")C("
7384	.e4d1						end:
7385							                .endblock

7387							;-------------------------------------------------------------------------

7389	.e4d1						thisIsNotALanguageError:
7390	.e4d1		00		brk #		                brk
7391	>e4d2		00 54 68 69 73 20 69 73		                .text 0,"This is not a language"
	>e4da		20 6e 6f 74 20 61 20 6c 61 6e 67 75 61 67 65

7393							;-------------------------------------------------------------------------

7395	.e4e9						iCannotRunThisCodeError:
7396	.e4e9		00		brk #		                brk
7397	>e4ea		00 49 20 63 61 6e 6e 6f		                .text 0,"I cannot run this code",0
	>e4f2		74 20 72 75 6e 20 74 68 69 73 20 63 6f 64 65 00

7399							;-------------------------------------------------------------------------
7400							;
7401							; OSBYTE 164 (&A4) Check processor type [MasRef D.2-50]
7402							;
7403	.e502						osbyteA4:
7404	.e502		a2 03		ldx #$03	                ldx #sidewaysROMCopyrightPrefix.end-sidewaysROMCopyrightPrefix
7405	.e504		a0 07		ldy #$07	                ldy #<sidewaysROMCopyrightOffset
7406	.e506		b1 f0		lda ($f0),y	                lda (originalX),y
7407	.e508		a8		tay		                tay
7408	.e509						-
7409	.e509		b1 f0		lda ($f0),y	                lda (originalX),y
7410	.e50b		dd ce e4	cmp $e4ce,x	                cmp sidewaysROMCopyrightPrefix,x
7411	.e50e		d0 0f		bne $e51f	                bne rtsE564 ;taken if (C) not found - must be OK, if it's not a ROM?
7412	.e510		c8		iny		                iny
7413	.e511		ca		dex		                dex
7414	.e512		10 f5		bpl $e509	                bpl -
7415	.e514		a0 06		ldy #$06	                ldy #<sidewaysROMType
7416	.e516		b1 f0		lda ($f0),y	                lda (originalX),y
7417	.e518		0a		asl a		                asl a
7418	.e519		10 b6		bpl $e4d1	                bpl thisIsNotALanguageError ;taken if no language entry point
7419	.e51b		29 1a		and #$1a	                and #%00001101<<1
7420	.e51d		d0 ca		bne $e4e9	                bne iCannotRunThisCodeError ;taken if low nybble wasn't 0 (6502 BASIC) or 2 (other 6502 ROM)
7421	.e51f						rtsE564:
7422	.e51f		60		rts		                rts

7424							;-------------------------------------------------------------------------

7426							                .if version==350
7427	.e520						LE520:
7428	.e520		4a		lsr a		                lsr a
7429	.e521		4a		lsr a		                lsr a
7430	.e522		4a		lsr a		                lsr a
7431	.e523		4a		lsr a		                lsr a
7432	.e524		60		rts		                rts
7433							                .endif

7435							;-------------------------------------------------------------------------

7437							                .if version==350
7438	.e525						LE525:
7439	.e525		a2 2c		ldx #$2c	                ldx #$2c                     ;???
7440	.e527		a0 03		ldy #$03	                ldy #$03
7441	.e529		20 c8 96	jsr $96c8	                jsr writeCMOSByte
7442	.e52c		4c 35 80	jmp $8035	                jmp printCMOSRamResetMessage
7443							                .endif

7445							;-------------------------------------------------------------------------

7447	.e52f						defaultBRKHandler:
7448	.e52f		a0 00		ldy #$00	                ldy #$00
7449	.e531		20 73 e7	jsr $e773	                jsr printBRKMessage
7450	.e534		20 e7 ff	jsr $ffe7	                jsr OSNEWL
7451	.e537		ad 67 02	lda $0267	                lda startupMessageSuppressionStatus
7452	.e53a		6a		ror a		                ror a
7453	.e53b		b0 06		bcs $e543	                bcs startCommandLineUI                   ;taken if bit 0 was set
7454	.e53d		20 e7 ff	jsr $ffe7	                jsr OSNEWL
7455	.e540		4c 46 e4	jmp $e446	                jmp LE496

7457							;-------------------------------------------------------------------------

7459	.e543						startCommandLineUI:
7460	.e543		20 5a e5	jsr $e55a	                jsr selectTerminalROM
7461	.e546		4c 29 84	jmp $8429	                jmp commandLineUI

7463							;-------------------------------------------------------------------------
7464							;
7465							; Select paged ROM bank 15 - TERMINAL - with ANDY paged in,
7466							;
7467							; Preserves A/Y
7468	.e549						selectTerminalROMAndANDY:   ;e57f
7469	.e549		a2 8f		ldx #$8f	                ldx #$80|terminalROM
7470							                ; fall through into selectROMX

7472							;-------------------------------------------------------------------------
7473							;-------------------------------------------------------------------------
7474							;
7475							; Select paged ROM bank.
7476							;
7477							; Entry:
7478							;
7479							; X = bank to select.
7480							;
7481							; Preserves A/X/Y/P
7482	.e54b						selectROMX:   ;e581
7483	.e54b		86 f4		stx $f4		                stx $F4
7484	.e54d		8e 30 fe	stx $fe30	                stx ROMSEL
7485	.e550		60		rts		                rts

7487							;-------------------------------------------------------------------------
7488							;
7489	.e551						isROMValidThenSelectTerminalROM:
7490	.e551		5a		phy		                phy
7491	.e552		20 aa e3	jsr $e3aa	                jsr isROMValid
7492	.e555		20 5a e5	jsr $e55a	                jsr selectTerminalROM
7493	.e558		7a		ply		                ply
7494	.e559		60		rts		                rts

7496							;-------------------------------------------------------------------------
7497							;
7498							; Select paged ROM bank 15 -
7499							;
7500							; Preserves X/Y
7501	.e55a						selectTerminalROM:            ;e590
7502	.e55a		a9 0f		lda #$0f	                lda #terminalROM
7503							                ; fall through into selectROMA

7505							;-------------------------------------------------------------------------
7506							;
7507							; Select paged ROM bank.
7508							;
7509							; A = bank to select.
7510							;
7511							; Preserves A/X/Y/P
7512	.e55c						selectROMA:                   ;e592
7513	.e55c		85 f4		sta $f4		                sta $F4         ;update ROMSEL copy
7514	.e55e		8d 30 fe	sta $fe30	                sta ROMSEL
7515	.e561		60		rts		                rts

7517							;-------------------------------------------------------------------------
7518							;
7519							; Select paged ROM bank 15 - TERMINAL - with ANDY paged in,
7520							;
7521							; Preserves A/X/Y

7523	.e562						selectTerminalROMAndANDY2:
7524	.e562		da		phx		                phx
7525	.e563		20 49 e5	jsr $e549	                jsr selectTerminalROMAndANDY
7526	.e566		fa		plx		                plx
7527	.e567		60		rts		                rts

7529							;-------------------------------------------------------------------------

7531	.e568						irqEntryPoint:
7532	.e568		85 fc		sta $fc		                sta TEMPA
7533	.e56a		68		pla		                pla                          ;restore P
7534	.e56b		48		pha		                pha                          ;save P
7535	.e56c		29 10		and #$10	                and #$10
7536	.e56e		d0 03		bne $e573	                bne brkEntryPoint
7537	.e570		6c 04 02	jmp ($0204)	                jmp (IRQ1V)

7539	.e573						brkEntryPoint:
7540	.e573		da		phx		                phx
7541	.e574		ba		tsx		                tsx
7542	.e575		bd 03 01	lda $0103,x	                lda $0103,x                  ;get BRK address+1 LSB
7543	.e578		d8		cld		                cld                          ;
7544	.e579		38		sec		                sec                          ;
7545	.e57a		e9 01		sbc #$01	                sbc #$01                     ;get BRK address LSB
7546	.e57c		85 fd		sta $fd		                sta errPtr+0
7547	.e57e		bd 04 01	lda $0104,x	                lda $0104,x                  ;get BRK address+1 MSB
7548	.e581		e9 00		sbc #$00	                sbc #$00                     ;get BRK address MSB
7549	.e583		85 fe		sta $fe		                sta errPtr+1
7550	.e585		a5 f4		lda $f4		                lda $F4
7551	.e587		8d 4a 02	sta $024a	                sta romActiveAtLastBRK
7552	.e58a		86 f0		stx $f0		                stx originalX
7553	.e58c		a2 06		ldx #$06	                ldx #romServiceCallBreakInstruction
7554	.e58e		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
7555	.e591		ae 8c 02	ldx $028c	                ldx currentLanguageROM
7556	.e594		20 4b e5	jsr $e54b	                jsr selectROMX
7557	.e597		fa		plx		                plx
7558	.e598		a5 fc		lda $fc		                lda TEMPA
7559	.e59a		58		cli		                cli
7560	.e59b		6c 02 02	jmp ($0202)	                jmp (BRKV)

7562							;-------------------------------------------------------------------------

7564							                .if version!=400
7565	.e59e						LE5D4:
7566	.e59e		38		sec		                sec
7567	.e59f		6e 4f 02	ror $024f	                ror rs423Busy
7568	.e5a2		2c 50 02	bit $0250	                bit aciaControlRegister
7569	.e5a5		10 07		bpl $e5ae	                bpl LE5E4
7570	.e5a7		20 73 ec	jsr $ec73	                jsr getRS423InputBufferFreeBytes
7571	.e5aa		a2 00		ldx #$00	                ldx #$00
7572	.e5ac		b0 02		bcs $e5b0	                bcs LE5E6
7573	.e5ae						LE5E4:
7574	.e5ae		a2 40		ldx #$40	                ldx #$40
7575	.e5b0						LE5E6:
7576	.e5b0		4c dc e8	jmp $e8dc	                jmp resetACIAState

7578	.e5b3						LE5E9:
7579	.e5b3		ac 09 fe	ldy $fe09	                ldy ACIA+1
7580	.e5b6		29 3a		and #$3a	                and #$3A
7581	.e5b8		d0 38		bne $e5f2	                bne LE628
7582	.e5ba		ae 5c 02	ldx $025c	                ldx rs423Ignore
7583	.e5bd		d0 09		bne $e5c8	                bne LE5FE
7584	.e5bf		e8		inx		                inx
7585	.e5c0		20 47 ea	jsr $ea47	                jsr osbyte99
7586	.e5c3		20 73 ec	jsr $ec73	                jsr getRS423InputBufferFreeBytes
7587	.e5c6		90 e6		bcc $e5ae	                bcc LE5E4
7588	.e5c8						LE5FE:
7589	.e5c8		60		rts		                rts
7590							                .endif

7592							;-------------------------------------------------------------------------

7594	.e5c9						irq1EntryPoint:
7595	.e5c9		a5 fc		lda $fc		                lda TEMPA
7596	.e5cb		48		pha		                pha
7597	.e5cc		da		phx		                phx
7598	.e5cd		5a		phy		                phy
7599							                .if version!=400
7600	.e5ce		b8		clv		                clv
7601							                .endif
7602	.e5cf		20 d9 e5	jsr $e5d9	                jsr irq1Handler
7603	.e5d2		7a		ply		                ply
7604	.e5d3		fa		plx		                plx
7605	.e5d4		68		pla		                pla
7606	.e5d5		40		rti		                rti

7608							;-------------------------------------------------------------------------

7610	.e5d6						irq2EntryPoint:
7611	.e5d6		a5 fc		lda $fc		                lda TEMPA
7612	.e5d8		40		rti		                rti

7614							;-------------------------------------------------------------------------

7616							                .if version==400
7619							                .else
7620	.e5d9						irq1Handler:
7621	.e5d9		ad 08 fe	lda $fe08	                lda ACIA+0
7622							                .if version>=500
7624							                .endif
7625	.e5dc		70 02		bvs $e5e0	                bvs LE616
7626	.e5de		10 5e		bpl $e63e	                bpl checkForSystemVIAInterrupt
7627	.e5e0						LE616:
7628	.e5e0		a6 ea		ldx $ea		                ldx $EA
7629	.e5e2		ca		dex		                dex
7630	.e5e3		30 33		bmi $e618	                bmi LE64E
7631	.e5e5		70 30		bvs $e617	                bvs rtsE64D
7632	.e5e7		20 16 f3	jsr $f316	                jsr withTerminalROM
7633	.e5ea		4c 77 a4	jmp $a477	                jmp LA45D

7635	.e5ed						LE623:
7636	.e5ed		ac 09 fe	ldy $fe09	                ldy ACIA+1
7637	.e5f0		2a		rol a		                rol a
7638	.e5f1		0a		asl a		                asl a
7639	.e5f2						LE628:
7640	.e5f2		aa		tax		                tax
7641	.e5f3		98		tya		                tya
7642	.e5f4		a0 07		ldy #$07	                ldy #$07
7643	.e5f6		4c ec e9	jmp $e9ec	                jmp eventEntryPoint

7645	.e5f9						LE62F:
7646	.e5f9		a2 02		ldx #$02	                ldx #$02
7647	.e5fb		20 b8 e9	jsr $e9b8	                jsr osbyte91
7648	.e5fe		90 10		bcc $e610	                bcc LE646
7649	.e600		ad 85 02	lda $0285	                lda printerDriverType
7650	.e603		c9 02		cmp #$02	                cmp #$02
7651	.e605		d0 97		bne $e59e	                bne LE5D4
7652	.e607		e8		inx		                inx
7653	.e608		20 b8 e9	jsr $e9b8	                jsr osbyte91
7654	.e60b		6e d1 02	ror $02d1	                ror bufferEmptyFlags+bufferPrinter
7655	.e60e		30 8e		bmi $e59e	                bmi LE5D4
7656	.e610						LE646:
7657	.e610		8d 09 fe	sta $fe09	                sta ACIA+1
7658	.e613		a9 e7		lda #$e7	                lda #$E7
7659	.e615		85 ea		sta $ea		                sta $EA
7660	.e617						rtsE64D:
7661	.e617		60		rts		                rts

7663	.e618						LE64E:
7664							                .if version<500
7665	.e618		2d 78 02	and $0278	                and rs423InterruptMask
7666							                .endif
7667	.e61b		4a		lsr a		                lsr a
7668	.e61c		90 07		bcc $e625	                bcc LE65B
7669	.e61e		70 05		bvs $e625	                bvs LE65B
7670	.e620		ac 50 02	ldy $0250	                ldy aciaControlRegister
7671	.e623		30 8e		bmi $e5b3	                bmi LE5E9
7672	.e625						LE65B:
7673	.e625		4a		lsr a		                lsr a
7674	.e626		6a		ror a		                ror a
7675	.e627		b0 c4		bcs $e5ed	                bcs LE623
7676	.e629		30 ce		bmi $e5f9	                bmi LE62F
7677	.e62b		70 ea		bvs $e617	                bvs rtsE64D
7678							                .endif

7680							;-------------------------------------------------------------------------

7682	.e62d						handleUnrecogisedInterrupt:
7683	.e62d		a2 05		ldx #$05	                ldx #romServiceCallUnrecognisedInterrupt
7684	.e62f		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
7685	.e632		f0 e3		beq $e617	                beq rtsE64D                  ;taken if handled

7687							                ; Pass unrecognised, unhandled interrupts to IRQ2V.
7688	.e634		68		pla		                pla
7689	.e635		68		pla		                pla
7690	.e636		7a		ply		                ply
7691	.e637		fa		plx		                plx
7692	.e638		68		pla		                pla
7693							                .if version==350
7694	.e639		85 fc		sta $fc		                sta TEMPA
7695							                .endif
7696	.e63b		6c 06 02	jmp ($0206)	                jmp (IRQ2V)

7698							;-------------------------------------------------------------------------

7700							                .if version==400
7702							                .else
7703	.e63e						checkForSystemVIAInterrupt:
7704							                .endif
7705	.e63e		ad 4d fe	lda $fe4d	                lda systemVIA.ifr
7706							                .if version==400
7708							                .else
7709	.e641		10 3c		bpl $e67f	                bpl checkForUserVIAInterrupt
7710							                .endif
7711	.e643		2d 79 02	and $0279	                and systemVIAInterruptMask
7712	.e646		2d 4e fe	and $fe4e	                and systemVIA.ier
7713	.e649		89 02		bit #$02	                bit #VIA.irq.ca1
7714	.e64b		f0 54		beq $e6a1	                beq checkForSystemVIAT1Interrupt

7716							                ; Handle CA1 interrupt - CRTC vsync.

7718	.e64d		ce 40 02	dec $0240	                dec cfsTimeoutCounter
7719							                .if version!=400
7720	.e650		a5 ea		lda $ea		                lda $EA
7721	.e652		10 02		bpl $e656	                bpl +
7722	.e654		e6 ea		inc $ea		                inc $EA
7723	.e656						+
7724							                .endif
7725	.e656		ad 51 02	lda $0251	                lda flashCounter
7726	.e659		f0 1a		beq $e675	                beq flashDone                    ;taken if no flash
7727	.e65b		ce 51 02	dec $0251	                dec flashCounter             ;count down
7728	.e65e		d0 15		bne $e675	                bne flashDone
7729	.e660		ae 52 02	ldx $0252	                ldx firstFlashColourDuration ;assume first flash colour is next
7730	.e663		ad 48 02	lda $0248	                lda vcontrolRegister
7731	.e666		4a		lsr a		                lsr a                        ;C=flash bit
7732	.e667		90 03		bcc $e66c	                bcc +                        ;taken if first flash colour is next
7733	.e669		ae 53 02	ldx $0253	                ldx secondFlashColourDuration ;actually, second flash colour is next
7734	.e66c						+
7735	.e66c		2a		rol a		                rol a                        ;reinstate old register value
7736	.e66d		49 01		eor #$01	                eor #VCONTROL.flash          ;toggle flash bit
7737	.e66f		20 c3 f1	jsr $f1c3	                jsr setVCONTROL
7738	.e672		8e 51 02	stx $0251	                stx flashCounter
7739	.e675						flashDone:
7740	.e675		a0 04		ldy #$04	                ldy #eventStartOfVerticalSync
7741	.e677		20 ec e9	jsr $e9ec	                jsr eventEntryPoint
7742	.e67a		a9 02		lda #$02	                lda #VIA.irq.ca1
7743							                .if version==400
7745							                .else
7746	.e67c		4c 56 e7	jmp $e756	                jmp staSystemVIAIFR          ;acknowledge CA1
7747							                .endif

7749							                .if version!=400
7750	.e67f						checkForUserVIAInterrupt:
7751	.e67f		ad 6d fe	lda $fe6d	                lda userVIA.ifr
7752	.e682		10 a9		bpl $e62d	                bpl handleUnrecogisedInterrupt
7753	.e684		2d 77 02	and $0277	                and userVIAInterruptMask
7754	.e687		2d 6e fe	and $fe6e	                and userVIA.ier
7755	.e68a		6a		ror a		                ror a                        ;C=CA2
7756	.e68b		6a		ror a		                ror a                        ;C=CA1
7757	.e68c		90 9f		bcc $e62d	                bcc handleUnrecogisedInterrupt
7758	.e68e		ac 85 02	ldy $0285	                ldy printerDriverType
7759	.e691		88		dey		                dey
7760	.e692		d0 99		bne $e62d	                bne handleUnrecogisedInterrupt ;taken if printerDriverType not 1
7761	.e694		a9 02		lda #$02	                lda #VIA.irq.ca1
7762	.e696		8d 6d fe	sta $fe6d	                sta userVIA.ifr              ;acknowledge CA1
7763	.e699		8d 6e fe	sta $fe6e	                sta userVIA.ier              ;inhibit CA1
7764	.e69c		a2 03		ldx #$03	                ldx #bufferPrinter
7765	.e69e		4c 9f e8	jmp $e89f	                jmp LE8D5
7766							                .endif

7768	.e6a1						checkForSystemVIAT1Interrupt:
7769	.e6a1		89 40		bit #$40	                bit #VIA.irq.t1
7770							                .if version<400
7771	.e6a3		f0 75		beq $e71a	                beq checkForSystemVIACB1Interrupt
7774							                .endif

7776							                ; Handle T1 interrupt - 100 Hz timer.

7778	.e6a5		a9 40		lda #$40	                lda #VIA.irq.t1
7779	.e6a7		8d 4d fe	sta $fe4d	                sta systemVIA.ifr            ;acknowledge T1 interrupt
7780	.e6aa		ad 83 02	lda $0283	                lda timerSwitchState
7781	.e6ad		aa		tax		                tax                          ;X=old timerSwitchState
7782	.e6ae		49 0f		eor #$0f	                eor #$0F
7783	.e6b0		48		pha		                pha                          ;save new timerSwitchState
7784	.e6b1		a8		tay		                tay                          ;Y=new timerSwitchState
7785	.e6b2		38		sec		                sec                          ;C=1 - increment
7786	.e6b3						updateTIMELoop:
7787	.e6b3		bd 91 02	lda $0291,x	                lda timer0-1,x
7788	.e6b6		69 00		adc #$00	                adc #$00
7789	.e6b8		99 91 02	sta $0291,y	                sta timer0-1,y

7791							                ; one of X or Y will get to 0 to indicate the end of
7792							                ; the loop.
7793	.e6bb		ca		dex		                dex
7794	.e6bc		f0 03		beq $e6c1	                beq updateTIMEDone
7795	.e6be		88		dey		                dey
7796	.e6bf		d0 f2		bne $e6b3	                bne updateTIMELoop
7797	.e6c1						updateTIMEDone:
7798	.e6c1		68		pla		                pla                          ;restore new timerSwitchState
7799	.e6c2		8d 83 02	sta $0283	                sta timerSwitchState
7800	.e6c5		a2 05		ldx #$05	                ldx #$05
7801	.e6c7						incrementIntervalTimer:
7802	.e6c7		fe 9b 02	inc $029b,x	                inc intervalTimer-1,x
7803	.e6ca		d0 08		bne $e6d4	                bne intervalTimerDone
7804	.e6cc		ca		dex		                dex
7805	.e6cd		d0 f8		bne $e6c7	                bne incrementIntervalTimer
7806	.e6cf		a0 05		ldy #$05	                ldy #eventIntervalTimerCrossingZero
7807	.e6d1		20 ec e9	jsr $e9ec	                jsr eventEntryPoint
7808	.e6d4						intervalTimerDone:
7809	.e6d4		ad b1 02	lda $02b1	                lda inkeyTimeoutCounter+0
7810	.e6d7		d0 08		bne $e6e1	                bne LE715
7811	.e6d9		ad b2 02	lda $02b2	                lda inkeyTimeoutCounter+1
7812	.e6dc		f0 06		beq $e6e4	                beq LE718
7813	.e6de		ce b2 02	dec $02b2	                dec inkeyTimeoutCounter+1
7814	.e6e1						LE715:
7815	.e6e1		ce b1 02	dec $02b1	                dec inkeyTimeoutCounter+0
7816	.e6e4						LE718:
7817	.e6e4		2c cd 02	bit $02cd	                bit previousKeyPressedWhenReadingOSBYTE
7818	.e6e7		10 0b		bpl $e6f4	                bpl LE728
7819	.e6e9		ee cd 02	inc $02cd	                inc previousKeyPressedWhenReadingOSBYTE
7820	.e6ec		58		cli		                cli
7821							                .if version==350
7822	.e6ed		20 c5 f3	jsr $f3c5	                jsr LF3C5_350
7825							                .endif
7826	.e6f0		78		sei		                sei
7827	.e6f1		ce cd 02	dec $02cd	                dec previousKeyPressedWhenReadingOSBYTE
7828	.e6f4						LE728:
7829	.e6f4		2c 5e e3	bit $e35e	                bit valueFF                  ;V=1
7830							                .if version!=400
7831	.e6f7		20 d9 e5	jsr $e5d9	                jsr irq1Handler
7832							                .endif
7833	.e6fa		a5 ec		lda $ec		                lda lastKeyPressedInternal
7834	.e6fc		05 ed		ora $ed		                ora firstKeyPressedInternal
7835	.e6fe		2d 42 02	and $0242	                and keyboardSemaphore
7836	.e701		f0 04		beq $e707	                beq +
7837	.e703		38		sec		                sec
7838	.e704		20 1d f6	jsr $f61d	                jsr LF8FF
7839	.e707						+
7840							                .if version>=500
7842							                .endif
7843	.e707		20 fd e8	jsr $e8fd	                jsr pollPrinterDriver
7844	.e70a		ac 43 02	ldy $0243	                ldy romPollingSemaphore
7845							                .if version==400
7847							                .else
7848	.e70d		f0 05		beq $e714	                beq LE748
7849							                .endif
7850	.e70f		a2 15		ldx #$15	                ldx #romServiceCallPollingInterrupt
7851							                .if version==400
7853							                .else
7854	.e711		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
7855	.e714						LE748:
7856							                .if version<500
7857	.e714		2c 18 fe	bit $fe18	                bit HADC+0
7858	.e717		70 05		bvs $e71e	                bvs LE752
7859							                .endif
7860	.e719		60		rts		                rts
7861							                .endif

7863							                .if version!=400
7864	.e71a						checkForSystemVIACB1Interrupt:
7865							                .if version<500
7866	.e71a		89 10		bit #$10	                bit #VIA.irq.cb1
7867	.e71c		f0 3c		beq $e75a	                beq checkForSystemVIACA2Interrupt

7869							                ; Handle CB1 interrupt - ADC conversion complete.
7870	.e71e						LE752:
7871	.e71e		ae 4c 02	ldx $024c	                ldx currentADCChannel
7872	.e721		f0 31		beq $e754	                beq acknowledgeSystemVIACB1Interrupt
7873	.e723		ad 1a fe	lda $fe1a	                lda HADC+2
7874	.e726		9d b5 02	sta $02b5,x	                sta adcResultLSBs-1,x
7875	.e729		ad 19 fe	lda $fe19	                lda HADC+1
7876	.e72c		9d b9 02	sta $02b9,x	                sta adcResultMSBs-1,x
7877	.e72f		8e be 02	stx $02be	                stx adcLastConvertedChannel
7878	.e732		a0 03		ldy #$03	                ldy #eventADCConversionComplete
7879	.e734		20 ec e9	jsr $e9ec	                jsr eventEntryPoint
7880	.e737		ca		dex		                dex                          ;next ADC channel
7881	.e738		d0 03		bne $e73d	                bne initiateADCConversion
7882	.e73a		ae 4d 02	ldx $024d	                ldx maximumADCChannel
7883	.e73d						initiateADCConversion:
7884	.e73d		e0 05		cpx #$05	                cpx #$05
7885	.e73f		90 02		bcc $e743	                bcc +
7886	.e741		a2 04		ldx #$04	                ldx #$04                     ;clamp ADC channel
7887	.e743						+
7888	.e743		8e 4c 02	stx $024c	                stx currentADCChannel
7889	.e746		ad 4e 02	lda $024e	                lda adcConversionType
7890	.e749		3a		dec a		                dec a            ;$FF=default, $07=8 bits, $0b=12 bits
7891	.e74a		29 08		and #$08	                and #$08         ;8=12 bits, 0=8 bits
7892	.e74c		18		clc		                clc
7893	.e74d		6d 4c 02	adc $024c	                adc currentADCChannel        ;mix in ADC channel, 1-4
7894	.e750		3a		dec a		                dec a ;convert to hardware ADC channel, 0-3 (no risk of borrow)
7895	.e751		8d 18 fe	sta $fe18	                sta HADC+0                   ;initiate conversion
7896	.e754						acknowledgeSystemVIACB1Interrupt:
7897	.e754		a9 10		lda #$10	                lda #$10
7898	.e756						staSystemVIAIFR:
7899	.e756		8d 4d fe	sta $fe4d	                sta systemVIA.ifr
7900	.e759		60		rts		                rts
7904							                .endif
7905							                .endif

7907	.e75a						checkForSystemVIACA2Interrupt:
7908	.e75a		4a		lsr a		                lsr a                        ;C = CA2
7909	.e75b		90 08		bcc $e765	                bcc handleUnrecognisedInterruptE799

7911							                ; Handle CA2 interrupt - keyboard.

7913	.e75d		18		clc		                clc
7914	.e75e		20 1d f6	jsr $f61d	                jsr LF8FF
7915	.e761		a9 01		lda #$01	                lda #VIA.irq.ca2
7916							                .if version<400
7917	.e763		80 f1		bra $e756	                bra staSystemVIAIFR
7923							                .endif

7925	.e765						handleUnrecognisedInterruptE799:
7926	.e765		4c 2d e6	jmp $e62d	                jmp handleUnrecogisedInterrupt

7928							;-------------------------------------------------------------------------
7929							;
7930							; OSBYTE 17 (&11) Write next ADC channel to be sampled [MasRef D.2-25]
7931							;
7932	.e768						osbyte11:
7933							                .if version!=400
7934							                .if version<500
7935	.e768		8c be 02	sty $02be	                sty adcLastConvertedChannel
7938							                .endif
7939	.e76b		80 d0		bra $e73d	                bra initiateADCConversion
7940							                .endif

7942							;-------------------------------------------------------------------------
7943							;
7944							; Print a 0-terminated string at some offset from startupMessages.
7945							;
7946							; entry:
7947							;
7948							; Y = offset-1 of message
7949							;
7950	.e76d						printStartupMessage:
7951	.e76d		a9 e0		lda #$e0	                lda #>startupMessages
7952							                ; .cerror (<startupMessages)!=0,"startupMessages must be page-aligned" ;it's more flexible than this, but this'll do for now

7954							;-------------------------------------------------------------------------
7955							;
7956							; Print a 0-terminated string.
7957							;
7958							; entry:
7959							;
7960							; A = address MSB
7961							;
7962							; Y = (address LSB)-1
7963							;
7964	.e76f						print0TerminatedString:
7965	.e76f		85 fe		sta $fe		                sta errPtr+1
7966	.e771		64 fd		stz $fd		                stz errPtr+0

7968							;-------------------------------------------------------------------------
7969							;
7970							; Print the BRK message.
7971							;
7972							; entry:
7973							;
7974							; (errPtr) = pointer to the error number (as will be the case after a
7975							; BRK)
7976							;
7977							; Y=0
7978							;
7979	.e773						printBRKMessage:
7980	.e773		c8		iny		                iny
7981	.e774		b1 fd		lda ($fd),y	                lda (errPtr),y
7982	.e776		20 e3 ff	jsr $ffe3	                jsr OSASCI
7983	.e779		aa		tax		                tax
7984	.e77a		d0 f7		bne $e773	                bne printBRKMessage
7985	.e77c						rtsE7B0:
7986	.e77c		60		rts		                rts

7988							;-------------------------------------------------------------------------

7990							                .if version>=500
8230							                .endif

8232							;-------------------------------------------------------------------------

8234	.e77d						osbyte81Timed:
8235	.e77d		8e b1 02	stx $02b1	                stx inkeyTimeoutCounter+0
8236	.e780		8c b2 02	sty $02b2	                sty inkeyTimeoutCounter+1
8237	.e783		66 e6		ror $e6		                ror readCharacterTimedFlag   ;set the timed flag
8238	.e785		58		cli		                cli
8239	.e786		80 02		bra $e78a	                bra osrdchWithTimeout

8241							;-------------------------------------------------------------------------

8243	.e788						osrdchEntryPoint:
8244	.e788		64 e6		stz $e6		                stz readCharacterTimedFlag   ;clear the timed flag
8245	.e78a						osrdchWithTimeout:
8246	.e78a		da		phx		                phx
8247	.e78b		5a		phy		                phy
8248	.e78c		ac 56 02	ldy $0256	                ldy execFileHandle
8249	.e78f		f0 12		beq $e7a3	                beq osrdchLoop               ;taken if not *EXEC'ing
8250	.e791		38		sec		                sec
8251	.e792		66 eb		ror $eb		                ror tapeCritical
8252	.e794		20 d7 ff	jsr $ffd7	                jsr OSBGET             ;get 1 byte from the *EXEC file
8253	.e797		64 eb		stz $eb		                stz tapeCritical
8254	.e799		90 24		bcc $e7bf	                bcc osrdchDone                    ;taken if byte valid
8255	.e79b		a9 00		lda #$00	                lda #$00                     ;OSFIND close file
8256	.e79d		9c 56 02	stz $0256	                stz execFileHandle           ;reset *EXEC handle
8257	.e7a0		20 ce ff	jsr $ffce	                jsr OSFIND                   ;close *EXEC file
8258	.e7a3						osrdchLoop:
8259	.e7a3		a5 ff		lda $ff		                lda escapeFlag               ;b7 set if ESCAPE pressed
8260	.e7a5		0a		asl a		                asl a                        ;C=1 if ESCAPE pressed
8261	.e7a6		a9 1b		lda #$1b	                lda #27                      ;ASCII for ESCAPE
8262	.e7a8		b0 15		bcs $e7bf	                bcs osrdchDone               ;exit with C=1 if ESCAPE
8263							                                             ;pressed
8264							                .if version!=400
8265	.e7aa		ae 41 02	ldx $0241	                ldx inputSource
8266							                .endif
8267	.e7ad		20 f7 ea	jsr $eaf7	                jsr readFromEconetOrSoftKeyOrInputBufferA ;handle Econet/soft key stuff???
8268	.e7b0		90 0d		bcc $e7bf	                bcc osrdchDone
8269	.e7b2		24 e6		bit $e6		                bit readCharacterTimedFlag
8270	.e7b4		10 ed		bpl $e7a3	                bpl osrdchLoop     ;taken if no timeout - keep looping
8271	.e7b6		ad b2 02	lda $02b2	                lda inkeyTimeoutCounter+1
8272	.e7b9		0d b1 02	ora $02b1	                ora inkeyTimeoutCounter+0
8273	.e7bc		d0 e5		bne $e7a3	                bne osrdchLoop     ;taken if timeout not timed out yet
8274	.e7be		3a		dec a		                dec a              ;timed out: A=$ff, C=1
8275	.e7bf						osrdchDone:
8276	.e7bf		7a		ply		                ply
8277	.e7c0		fa		plx		                plx
8278	.e7c1		60		rts		                rts

8280							;-------------------------------------------------------------------------

8282	.e7c2						starLIBFS:
8283	.e7c2		ad 01 df	lda $df01	                lda hazel.activeFS
8284	.e7c5		8d 02 df	sta $df02	                sta hazel.libFS
8285	.e7c8		60		rts		                rts

8287							;-------------------------------------------------------------------------

8289							                .if includeStarX
8290	.e7c9						starX:
8291	.e7c9		8d e8 fe	sta $fee8	                sta TUBE+8
8292	.e7cc						LE800:
8293	.e7cc		80 fe		bra $e7cc	                bra LE800
8294							                .endif

8296							;-------------------------------------------------------------------------
8297							;
8298							; OSCLI
8299							;
8300							; MasRef D.4-1
8301							;

8303	.e7ce						oscliEntryPoint: .block
8304	.e7ce		20 fa ec	jsr $ecfa	                jsr selectHAZEL
8305	.e7d1		86 f2		stx $f2		                stx stringInputBufferAddress+0
8306	.e7d3		84 f3		sty $f3		                sty stringInputBufferAddress+1
8307	.e7d5		a0 00		ldy #$00	                ldy #$00
8308	.e7d7						-
8309	.e7d7		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
8310	.e7d9		99 00 dc	sta $dc00,y	                sta hazel.commandLine,y
8311	=$e7dd						emptyCommandLine=*+1                         ;arbitrary place that's
8312							                                             ;just a 13 byte...
8313	.e7dc		c9 0d		cmp #$0d	                cmp #$0D
8314	.e7de		f0 04		beq $e7e4	                beq +     ;branch taken if end of command line reached
8315	.e7e0		c8		iny		                iny
8316	.e7e1		d0 f4		bne $e7d7	                bne -

8318							                ; OSCLI is a no-op if the command line is too long.
8319	.e7e3		60		rts		                rts

8321	.e7e4						+
8322	.e7e4		a0 dc		ldy #$dc	                ldy #>hazel.commandLine
8323	.e7e6		a2 00		ldx #$00	                ldx #<hazel.commandLine
8324	.e7e8		20 16 f3	jsr $f316	                jsr withTerminalROM
8325	.e7eb		4c 0a 83	jmp $830a	                jmp oscli
8326							                .endblock

8328	=$e7dd						emptyCommandLine=oscliEntryPoint.emptyCommandLine

8330							                ; OSWRCH
8331							                ; ======
8332	.e7ee						oswrchEntryPoint:
8333	.e7ee		48		pha		                pha                          ;S=[ch]
8334	.e7ef		da		phx		                phx                          ;S=[x; ch]
8335	.e7f0		5a		phy		                phy                          ;S=[y; x; ch]
8336	.e7f1		48		pha		                pha                          ;S=[ch; y; x; ch]
8337	.e7f2		2c 60 02	bit $0260	                bit econetOutputInterpretationStatus
8338	.e7f5		10 08		bpl $e7ff	                bpl LE833
8339	.e7f7		a8		tay		                tay
8340	.e7f8		a9 04		lda #$04	                lda #netWriteCharacterAttempted
8341	.e7fa		20 fe ea	jsr $eafe	                jsr callNETV
8342	.e7fd		b0 70		bcs $e86f	                bcs LE8A5
8343	.e7ff						LE833:
8344	.e7ff		a9 02		lda #$02	                lda #$02
8345	.e801		2c 7c 02	bit $027c	                bit characterDestinationStatus
8346	.e804		d0 26		bne $e82c	                bne LE862
8347	.e806		68		pla		                pla                          ;restore char to print
8348	.e807		48		pha		                pha                          ;save it again
8349	.e808		aa		tax		                tax                          ;X=char to print
8350	.e809		ad 34 fe	lda $fe34	                lda ACCCON                   ;
8351	.e80c		48		pha		                pha                          ;S=[old ACCCON; ch; y; x; ch]
8352							                .if version==350
8353	.e80d		20 f4 ec	jsr $ecf4	                jsr selectMOS
8357							                .endif
8358	.e810		a5 f4		lda $f4		                lda $F4
8359	.e812		48		pha		                pha          ;S=[old ROMSEL; old ACCCON; ch; y; x; ch]
8360	.e813		a9 8f		lda #$8f	                lda #$80|terminalROM
8361	.e815		85 f4		sta $f4		                sta $F4
8362	.e817		8d 30 fe	sta $fe30	                sta ROMSEL                   ;page in ANDY+Terminal
8363	.e81a		8a		txa		                txa                          ;A=char to print
8364	.e81b		20 27 c0	jsr $c027	                jsr outputToVDU
8365	.e81e		68		pla		                pla
8366	.e81f		85 f4		sta $f4		                sta $F4
8367	.e821		8d 30 fe	sta $fe30	                sta ROMSEL
8368	.e824		68		pla		                pla
8369	.e825		29 08		and #$08	                and #ACCCON.Y
8370	.e827		0c 34 fe	tsb $fe34	                tsb ACCCON
8371	.e82a		b0 07		bcs $e833	                bcs LE869
8372	.e82c						LE862:
8373	.e82c		a9 08		lda #$08	                lda #$08
8374	.e82e		2c 7c 02	bit $027c	                bit characterDestinationStatus
8375	.e831		f0 05		beq $e838	                beq LE86E
8376	.e833						LE869:
8377	.e833		68		pla		                pla
8378	.e834		48		pha		                pha
8379	.e835		20 74 e8	jsr $e874	                jsr LE8AA
8380	.e838						LE86E:
8381							                .if version!=400
8382	.e838		ad 7c 02	lda $027c	                lda characterDestinationStatus
8383	.e83b		6a		ror a		                ror a
8384	.e83c		90 1b		bcc $e859	                bcc LE88F
8385	.e83e		a4 ea		ldy $ea		                ldy $EA
8386	.e840		88		dey		                dey
8387	.e841		10 16		bpl $e859	                bpl LE88F
8388	.e843		68		pla		                pla
8389	.e844		48		pha		                pha
8390	.e845		08		php		                php
8391	.e846		78		sei		                sei
8392	.e847		a2 02		ldx #$02	                ldx #$02
8393	.e849		48		pha		                pha
8394	.e84a		20 b3 e9	jsr $e9b3	                jsr osbyte98
8395	.e84d		90 03		bcc $e852	                bcc LE888
8396	.e84f		20 d2 e8	jsr $e8d2	                jsr clearRS423BusyAndSetRS423Active
8397	.e852						LE888:
8398	.e852		68		pla		                pla
8399	.e853		a2 02		ldx #$02	                ldx #$02
8400	.e855		20 6d e9	jsr $e96d	                jsr LE9A3
8401	.e858		28		plp		                plp
8402	.e859						LE88F:
8403							                .endif

8405	.e859		a9 10		lda #$10	                lda #$10
8406	.e85b		2c 7c 02	bit $027c	                bit characterDestinationStatus
8407	.e85e		d0 0f		bne $e86f	                bne LE8A5
8408	.e860		ac 57 02	ldy $0257	                ldy spoolFileHandle
8409	.e863		f0 0a		beq $e86f	                beq LE8A5
8410	.e865		68		pla		                pla
8411	.e866		48		pha		                pha
8412	.e867		38		sec		                sec
8413	.e868		66 eb		ror $eb		                ror $EB
8414	.e86a		20 d4 ff	jsr $ffd4	                jsr OSBPUT
8415	.e86d		46 eb		lsr $eb		                lsr $EB
8416	.e86f						LE8A5:
8417	.e86f		68		pla		                pla
8418	.e870		7a		ply		                ply
8419	.e871		fa		plx		                plx
8420	.e872		68		pla		                pla
8421	.e873		60		rts		                rts

8423	.e874						LE8AA:
8424	.e874		2c 7c 02	bit $027c	                bit characterDestinationStatus
8425	.e877		70 25		bvs $e89e	                bvs LE8D4
8426	.e879		cd 86 02	cmp $0286	                cmp printerIgnoreChar
8427	.e87c		d0 05		bne $e883	                bne LE8B9
8428	.e87e		2c 46 02	bit $0246	                bit noignoreState
8429	.e881		10 1b		bpl $e89e	                bpl LE8D4
8430	.e883						LE8B9:
8431	.e883		08		php		                php
8432	.e884		78		sei		                sei
8433	.e885		aa		tax		                tax
8434	.e886		a9 04		lda #$04	                lda #$04
8435	.e888		2c 7c 02	bit $027c	                bit characterDestinationStatus
8436	.e88b		d0 10		bne $e89d	                bne LE8D3
8437	.e88d		8a		txa		                txa
8438	.e88e		a2 03		ldx #$03	                ldx #$03
8439	.e890		20 6d e9	jsr $e96d	                jsr LE9A3
8440	.e893		b0 08		bcs $e89d	                bcs LE8D3
8441	.e895		2c d1 02	bit $02d1	                bit bufferEmptyFlags+bufferPrinter
8442	.e898		10 03		bpl $e89d	                bpl LE8D3
8443	.e89a		20 9f e8	jsr $e89f	                jsr LE8D5
8444	.e89d						LE8D3:
8445	.e89d		28		plp		                plp
8446	.e89e						LE8D4:
8447	.e89e		60		rts		                rts

8449	.e89f						LE8D5:                                       ;E7CA in MOS 4.00
8450	.e89f		ad 85 02	lda $0285	                lda printerDriverType
8451							                .if version!=400
8452	.e8a2		f0 7f		beq $e923	                beq LE959
8453	.e8a4		3a		dec a		                dec a
8454	.e8a5		d0 20		bne $e8c7	                bne LE8FD
8455	.e8a7		20 b8 e9	jsr $e9b8	                jsr osbyte91
8456	.e8aa		6e d1 02	ror $02d1	                ror bufferEmptyFlags+bufferPrinter
8457	.e8ad		30 43		bmi $e8f2	                bmi rtsE928
8458	.e8af		a0 82		ldy #$82	                ldy #$82
8459	.e8b1		8c 6e fe	sty $fe6e	                sty userVIA.ier
8460	.e8b4		8d 61 fe	sta $fe61	                sta userVIA.ora
8461	.e8b7		ad 6c fe	lda $fe6c	                lda userVIA.pcr
8462	.e8ba		29 f1		and #$f1	                and #$F1
8463	.e8bc		09 0c		ora #$0c	                ora #$0C
8464	.e8be		8d 6c fe	sta $fe6c	                sta userVIA.pcr
8465	.e8c1		09 0e		ora #$0e	                ora #$0E
8466	.e8c3		8d 6c fe	sta $fe6c	                sta userVIA.pcr
8467	.e8c6		60		rts		                rts

8469	.e8c7						LE8FD:
8470	.e8c7		3a		dec a		                dec a
8471	.e8c8		d0 29		bne $e8f3	                bne activatePrinterDriver
8472	.e8ca		a4 ea		ldy $ea		                ldy $EA
8473	.e8cc		88		dey		                dey
8474	.e8cd		10 54		bpl $e923	                bpl LE959
8475	.e8cf		4e d1 02	lsr $02d1	                lsr bufferEmptyFlags+bufferPrinter
8476	.e8d2						clearRS423BusyAndSetRS423Active:
8477	.e8d2		4e 4f 02	lsr $024f	                lsr rs423Busy
8478	.e8d5						setRS423Active:
8479	.e8d5		20 73 ec	jsr $ec73	                jsr getRS423InputBufferFreeBytes
8480	.e8d8		90 18		bcc $e8f2	                bcc rtsE928
8481	.e8da		a2 20		ldx #$20	                ldx #ACIA.control.rtsLowTXInterruptEnabled
8482	.e8dc						resetACIAState:
8483	.e8dc		a0 9f		ldy #$9f	                ldy #ACIA.control.rtsRTSInterruptEnabled|ACIA.control.word8DataOddParity1Stop|ACIA.control.reset

8485							;-------------------------------------------------------------------------
8486							;
8487							; OSBYTE 156 (&9C) Read/write serial ACIA control [MasRef D.2-47]
8488							;
8489	.e8de						osbyte9C:
8490	.e8de		08		php		                php
8491	.e8df		78		sei		                sei
8492	.e8e0		98		tya		                tya
8493	.e8e1		86 fa		stx $fa		                stx SEIWKA
8494	.e8e3		2d 50 02	and $0250	                and aciaControlRegister
8495	.e8e6		45 fa		eor $fa		                eor SEIWKA
8496	.e8e8		ae 50 02	ldx $0250	                ldx aciaControlRegister
8497	.e8eb						writeACIAControlRegisterAndCopy:
8498	.e8eb		8d 50 02	sta $0250	                sta aciaControlRegister
8499	.e8ee		8d 08 fe	sta $fe08	                sta ACIA.control
8500	.e8f1		28		plp		                plp
8501	.e8f2						rtsE928:
8502	.e8f2		60		rts		                rts

8513							                .endif

8515							;-------------------------------------------------------------------------

8517	.e8f3						activatePrinterDriver:
8518	.e8f3		18		clc		                clc
8519	.e8f4		a9 01		lda #$01	                lda #printerDriverActivate
8520	.e8f6		20 04 e9	jsr $e904	                jsr callPrinterDriverWithPrinterBuffer

8522							                ; printer driver will set C=0 if active, C=1 if
8523							                ; inactive.

8525							;-------------------------------------------------------------------------
8526							;
8527							; OSBYTE 123 (&7B) Inform MOS of printer driver going dormant [MasRef
8528							; D.2-36]
8529							;
8530	.e8f9						osbyte7B:
8531	.e8f9		6e d1 02	ror $02d1	                ror bufferEmptyFlags+bufferPrinter   ;C=1 on entry, so set bit 7
8532	.e8fc						rtsE932:
8533	.e8fc		60		rts		                rts

8535							;-------------------------------------------------------------------------

8537	.e8fd						pollPrinterDriver:
8538	.e8fd		2c d1 02	bit $02d1	                bit bufferEmptyFlags+bufferPrinter
8539	.e900		30 fa		bmi $e8fc	                bmi rtsE932           ;taken if printer driver dormant
8540	.e902		a9 00		lda #$00	                lda #printerDriverPoll
8541	.e904						callPrinterDriverWithPrinterBuffer:
8542	.e904		a2 03		ldx #$03	                ldx #bufferPrinter
8543	.e906						callPrinterDriver:
8544	.e906		ac 85 02	ldy $0285	                ldy printerDriverType
8545	.e909		20 fe ea	jsr $eafe	                jsr callNETV
8546	.e90c		6c 22 02	jmp ($0222)	                jmp (UPTV)

8548							;-------------------------------------------------------------------------
8549							;
8550							; OSBYTE 15 (&0F) Flush buffer
8551							;
8552	.e90f						osbyte0F:
8553	.e90f		d0 0f		bne $e920	                bne LE956
8554	.e911						LE947:
8555	.e911		a2 08		ldx #$08	                ldx #$08
8556	.e913						LE949:
8557	.e913		58		cli		                cli
8558	.e914		78		sei		                sei
8559	.e915		20 1b e9	jsr $e91b	                jsr osbyte15
8560	.e918		ca		dex		                dex
8561	.e919		10 f8		bpl $e913	                bpl LE949

8563							;-------------------------------------------------------------------------
8564							;
8565							; OSBYTE 21 (&15) Flush selected buffer
8566							;
8567	.e91b						osbyte15:                                    ;e951
8568	.e91b		e0 09		cpx #$09	                cpx #bufferMax+1
8569	.e91d		90 04		bcc $e923	                bcc LE959
8570	.e91f		60		rts		                rts

8572	.e920						LE956:
8573	.e920		ae 41 02	ldx $0241	                ldx inputSource
8574	.e923						LE959:
8575	.e923		18		clc		                clc
8576	.e924						LE95A:
8577	.e924		48		pha		                pha
8578	.e925		08		php		                php
8579	.e926		78		sei		                sei
8580	.e927		b0 08		bcs $e931	                bcs LE967
8581	.e929		8a		txa		                txa
8582	.e92a		29 04		and #$04	                and #$04                     ;buffer 4-7?
8583	.e92c		f0 03		beq $e931	                beq LE967                    ;taken if not sound buffer
8584	.e92e		20 bc f3	jsr $f3bc	                jsr clearSoundChannelBuffer
8585	.e931						LE967:
8586	.e931		38		sec		                sec
8587	.e932		7e ce 02	ror $02ce,x	                ror bufferEmptyFlags,x
8588	.e935		e0 02		cpx #$02	                cpx #bufferFirstOutput
8589	.e937		b0 06		bcs $e93f	                bcs LE975                    ;taken if output buffer
8590	.e939		9c 68 02	stz $0268	                stz softKeyStringLength
8591	.e93c		9c 6a 02	stz $026a	                stz vduQueueNegativeLength
8592	.e93f						LE975:
8593	.e93f		20 6d ec	jsr $ec6d	                jsr purgeBufferViaCNPV
8594	.e942		28		plp		                plp
8595	.e943		68		pla		                pla
8596	.e944		60		rts		                rts

8598							;-------------------------------------------------------------------------
8599							;
8600							; Count/purge entry point [AUG p264]
8601							;
8602	.e945						cnpEntryPoint:
8603	.e945		50 07		bvc $e94e	                bvc countBuffer
8604	.e947						purgeBuffer:
8605	.e947		bd d7 02	lda $02d7,x	                lda bufferStartIndices,x
8606	.e94a		9d e0 02	sta $02e0,x	                sta bufferEndIndices,x
8607	.e94d		60		rts		                rts

8609	.e94e						countBuffer:
8610	.e94e		08		php		                php
8611	.e94f		78		sei		                sei
8612	.e950		08		php		                php
8613	.e951		38		sec		                sec
8614	.e952		bd e0 02	lda $02e0,x	                lda bufferEndIndices,x
8615	.e955		fd d7 02	sbc $02d7,x	                sbc bufferStartIndices,x
8616	.e958		b0 04		bcs $e95e	                bcs LE994
8617	.e95a		38		sec		                sec
8618	.e95b		fd 9f e9	sbc $e99f,x	                sbc bufferIndex0Offsets,x
8619	.e95e						LE994:
8620	.e95e		28		plp		                plp
8621	.e95f		90 06		bcc $e967	                bcc LE99D
8622	.e961		18		clc		                clc
8623	.e962		7d 9f e9	adc $e99f,x	                adc bufferIndex0Offsets,x
8624	.e965		49 ff		eor #$ff	                eor #$FF
8625	.e967						LE99D:
8626	.e967		a0 00		ldy #$00	                ldy #$00
8627	.e969		aa		tax		                tax
8628	.e96a		28		plp		                plp
8629	.e96b						rtsE9A1:
8630	.e96b		60		rts		                rts

8632							;-------------------------------------------------------------------------

8634	.e96c						LE9A2:
8635	.e96c		58		cli		                cli
8636	.e96d						LE9A3:
8637	.e96d		78		sei		                sei
8638	.e96e						LE9A4:
8639	.e96e		20 04 ea	jsr $ea04	                jsr callINSV
8640	.e971		90 f8		bcc $e96b	                bcc rtsE9A1
8641	.e973		20 b4 f1	jsr $f1b4	                jsr LF241
8642	.e976		48		pha		                pha
8643	.e977		20 10 f4	jsr $f410	                jsr updateKeyboardLEDs
8644	.e97a		0a		asl a		                asl a
8645	.e97b		68		pla		                pla
8646	.e97c		90 ee		bcc $e96c	                bcc LE9A2
8647	.e97e		60		rts		                rts

8649							;-------------------------------------------------------------------------
8650							;
8651							; OSBYTE $77
8652							;
8653							; D.2-33
8654							;
8655							                .if version!=350
8659							                .endif

8661							;-------------------------------------------------------------------------
8662							;
8663							; Get *IGNORE CMOS byte offset and mask for a given ROM.
8664							;
8665							; entry:
8666							;
8667							; Y = ROM number
8668							;
8669							; exit:
8670							;
8671							; A = mask
8672							;
8673							; X = RTC address of byte
8674							;
8675	.e97f						getROMInsertedFlagRTCAddressAndMask:
8676	.e97f		a9 00		lda #$00	                lda #$00
8677	.e981		38		sec		                sec
8678	.e982		a2 14		ldx #$14	                ldx #CMOSBytes.insertedROMs+0+cmosBytesOffset
8679	.e984						-
8680	.e984		2a		rol a		                rol a
8681	.e985		d0 02		bne $e989	                bne +
8682	.e987		e8		inx		                inx
8683	.e988		2a		rol a		                rol a
8684	.e989						+
8685	.e989		88		dey		                dey
8686	.e98a		10 f8		bpl $e984	                bpl -
8687	.e98c		60		rts		                rts

8689							;-------------------------------------------------------------------------

8691	=[]						_:=[]
8692	=[($03e0,32)]					_..=[(bufferKeyboardAddress,bufferKeyboardSize)]
8693	=[($03e0,32),($0a00,256)]			_..=[(bufferRS423InputAddress,bufferRS423InputSize)]
8694	=[($03e0,32),($0a00,256),($0900,192)]		_..=[(bufferRS423OutputAddress,bufferRS423OutputSize)]
8695	=[($03e0,32),($0a00,256),($0900,192),($0880,64)]
							_..=[(bufferPrinterAddress,bufferPrinterSize)]
8696	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16)]
							_..=[(bufferSoundChannel0Address,bufferSoundChannel0Size)]
8697	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16)]
							_..=[(bufferSoundChannel1Address,bufferSoundChannel1Size)]
8698	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16)]
							_..=[(bufferSoundChannel2Address,bufferSoundChannel2Size)]
8699	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16),($0870,16)]
							_..=[(bufferSoundChannel3Address,bufferSoundChannel3Size)]
8700	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16),($0870,16),($09c0,64)]
							_..=[(buffer8Address,buffer8Size)]
8701	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16),($0870,16),($09c0,64)]
							buffers=_

8703							BufferTableIndex0Offset: .function buffer
8704							                .endfunction 256-buffer[1]

8706							BufferTableBase: .function buffer
8707							                .endfunction buffer[0]-BufferTableIndex0Offset(buffer)

8709							;-------------------------------------------------------------------------
8710							;
8711							; Buffer base addresses - each buffer's address, offset by the offset
8712							; for index 0 (see bufferIndex0Offsets).
8713							;
8714	.e98d						bufferBaseAddressMSBs:
8715							                .for _i=0,_i<len(buffers),_i+=1
8716	>e98d		03				                .byte >BufferTableBase(buffers[_i])
8716	>e98e		0a				                .byte >BufferTableBase(buffers[_i])
8716	>e98f		08				                .byte >BufferTableBase(buffers[_i])
8716	>e990		07				                .byte >BufferTableBase(buffers[_i])
8716	>e991		07				                .byte >BufferTableBase(buffers[_i])
8716	>e992		07				                .byte >BufferTableBase(buffers[_i])
8716	>e993		07				                .byte >BufferTableBase(buffers[_i])
8716	>e994		07				                .byte >BufferTableBase(buffers[_i])
8716	>e995		09				                .byte >BufferTableBase(buffers[_i])
8717							                .endfor

8719	.e996						bufferBaseAddressLSBs:
8720							                .for _i=0,_i<len(buffers),_i+=1
8721	>e996		00				                .byte <BufferTableBase(buffers[_i])
8721	>e997		00				                .byte <BufferTableBase(buffers[_i])
8721	>e998		c0				                .byte <BufferTableBase(buffers[_i])
8721	>e999		c0				                .byte <BufferTableBase(buffers[_i])
8721	>e99a		50				                .byte <BufferTableBase(buffers[_i])
8721	>e99b		60				                .byte <BufferTableBase(buffers[_i])
8721	>e99c		70				                .byte <BufferTableBase(buffers[_i])
8721	>e99d		80				                .byte <BufferTableBase(buffers[_i])
8721	>e99e		00				                .byte <BufferTableBase(buffers[_i])
8722							                .endfor

8724							;-------------------------------------------------------------------------

8726							; Offset of buffer index 0 for each buffer. Index 0 is (-buffer size)
8727							; - buffer indexes count up, and wrap once they reach 0.

8729	.e99f						bufferIndex0Offsets:
8730							                .for _i=0,_i<len(buffers),_i+=1
8731	>e99f		e0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e9a0		00				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e9a1		40				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e9a2		c0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e9a3		f0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e9a4		f0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e9a5		f0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e9a6		f0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e9a7		c0				                .byte BufferTableIndex0Offset(buffers[_i])
8732							                .endfor

8734							;-------------------------------------------------------------------------
8735							;
8736							; Get base address for a buffer.
8737							;
8738							; entry:
8739							;
8740							; X = buffer number
8741							;
8742							; exit:
8743							;
8744							; (SEIWKA) = buffer base address
8745							;
8746	.e9a8						getBufferBaseAddress:
8747	.e9a8		bd 96 e9	lda $e996,x	                lda bufferBaseAddressLSBs,x
8748	.e9ab		85 fa		sta $fa		                sta SEIWKA
8749	.e9ad		bd 8d e9	lda $e98d,x	                lda bufferBaseAddressMSBs,x
8750	.e9b0		85 fb		sta $fb		                sta SEIWKB
8751	.e9b2		60		rts		                rts

8753							;-------------------------------------------------------------------------
8754							;
8755							; OSBYTE 152 (&98) Examine buffer status [MasRef D.2-45]
8756							;
8757	.e9b3						osbyte98:
8758	.e9b3		2c 5e e3	bit $e35e	                bit valueFF                  ;V=1
8759	.e9b6		80 01		bra $e9b9	                bra callREMV

8761							;-------------------------------------------------------------------------
8762							;
8763							; OSBYTE 145 (&91) Get character from buffer [MasRef D.2-45]
8764							;
8765							; X = buffer number
8766	.e9b8						osbyte91:
8767	.e9b8		b8		clv		                clv                          ;remove
8768	.e9b9						callREMV:
8769	.e9b9		6c 2c 02	jmp ($022c)	                jmp (REMV)

8771							;-------------------------------------------------------------------------
8772							;
8773							; Buffer remove entry point. [AUG p263]
8774							;
8775							; Even in remove mode, A is the character removed on exit. Some of the
8776							; other MOS routines rely on this.
8777							;
8778	.e9bc						remEntryPoint:
8779	.e9bc		08		php		                php
8780	.e9bd		78		sei		                sei
8781	.e9be		bd d7 02	lda $02d7,x	                lda bufferStartIndices,x
8782	.e9c1		dd e0 02	cmp $02e0,x	                cmp bufferEndIndices,x
8783	.e9c4		f0 6c		beq $ea32	                beq plp_sec_rts  ;taken if buffer empty
8784	.e9c6		a8		tay		                tay                          ;Y=start index
8785	.e9c7		20 a8 e9	jsr $e9a8	                jsr getBufferBaseAddress
8786	.e9ca		b1 fa		lda ($fa),y	                lda (SEIWKA),y               ;get byte from buffer
8787	.e9cc		70 1a		bvs $e9e8	                bvs tay_plp_clc_rts                  ;taken if only looking
8788	.e9ce		48		pha		                pha                          ;save buffered byte
8789	.e9cf		c8		iny		                iny                          ;next char in buffer
8790	.e9d0		98		tya		                tya                          ;set Z if wrap
8791	.e9d1		d0 03		bne $e9d6	                bne +                        ;branch taken if no wrap
8792	.e9d3		bd 9f e9	lda $e99f,x	                lda bufferIndex0Offsets,x    ;reset index on wrap
8793	.e9d6						+
8794	.e9d6		9d d7 02	sta $02d7,x	                sta bufferStartIndices,x

8796							                ; Issue output buffer empty event when appropriate.
8797	.e9d9		e0 02		cpx #$02	                cpx #bufferFirstOutput
8798	.e9db		90 0a		bcc $e9e7	                bcc pla_tay_plp_clc_rts ;taken if keyboard or RS423
8799							                                        ;input - i.e., buffer is input
8800	.e9dd		dd e0 02	cmp $02e0,x	                cmp bufferEndIndices,x       ;buffer now empty?
8801	.e9e0		d0 05		bne $e9e7	                bne pla_tay_plp_clc_rts           ;taken if not empty
8802	.e9e2		a0 00		ldy #$00	                ldy #eventOutputBufferEmpty
8803	.e9e4		20 ec e9	jsr $e9ec	                jsr eventEntryPoint
8804	.e9e7						pla_tay_plp_clc_rts:
8805	.e9e7		68		pla		                pla                          ;restore buffered byte
8806	.e9e8						tay_plp_clc_rts:
8807	.e9e8		a8		tay		                tay                          ;Y=buffered byte
8808	.e9e9						plp_clc_rts:
8809	.e9e9		28		plp		                plp
8810	.e9ea		18		clc		                clc
8811	.e9eb		60		rts		                rts

8813							;-------------------------------------------------------------------------
8814							;
8815							; [MasRef D.9-1]
8816							;
8817	.e9ec						eventEntryPoint:
8818	.e9ec		08		php		                php
8819	.e9ed		78		sei		                sei
8820	.e9ee		48		pha		                pha
8821	.e9ef		b9 bf 02	lda $02bf,y	                lda eventEnabledFlags,y      ;is the event enabled?
8822	.e9f2		f0 3d		beq $ea31	                beq pla_plp_sec_rts                    ;
8823	.e9f4		98		tya		                tya
8824	.e9f5		7a		ply		                ply
8825	.e9f6		5a		phy		                phy
8826	.e9f7		20 dd f5	jsr $f5dd	                jsr LF8BF
8827	.e9fa		80 eb		bra $e9e7	                bra pla_tay_plp_clc_rts

8829							;-------------------------------------------------------------------------
8830							;
8831							; Insert character into buffer and issue an event for it.
8832							;
8833							; entry:
8834							;
8835							; Y = buffer number
8836							;
8837	.e9fc						insertCharacterIntoBuffer:
8838	.e9fc		98		tya		                tya
8839	.e9fd		a0 02		ldy #$02	                ldy #eventCharacterEnteringBuffer
8840	.e9ff		20 ec e9	jsr $e9ec	                jsr eventEntryPoint
8841	.ea02		a8		tay		                tay

8843							;-------------------------------------------------------------------------
8844							;
8845							; OSBYTE 138 (&8A) Insert character code into buffer [MasRef D.2-43]
8846							;
8847	.ea03						osbyte8A:
8848	.ea03		98		tya		                tya
8849	.ea04						callINSV:
8850	.ea04		6c 2a 02	jmp ($022a)	                jmp (INSV)

8852							;-------------------------------------------------------------------------
8853							;
8854							; Default INSV entry point [AUG p263]
8855							;
8856	.ea07						insEntryPoint:
8857	.ea07		08		php		                php
8858	.ea08		78		sei		                sei
8859	.ea09		48		pha		                pha                          ;save value to insert
8860	.ea0a		bd e0 02	lda $02e0,x	                lda bufferEndIndices,x       ;get buffer index
8861	.ea0d		1a		inc a		                inc a                        ;bump index
8862	.ea0e		d0 03		bne $ea13	                bne +          ;taken if index hasn't wrapped around
8863	.ea10		bd 9f e9	lda $e99f,x	                lda bufferIndex0Offsets,x        ;reset index due to wrap
8864	.ea13						+
8865	.ea13		dd d7 02	cmp $02d7,x	                cmp bufferStartIndices,x     ;are we at the start index?
8866	.ea16		f0 0e		beq $ea26	                beq bufferFull       ;taken if yes - i.e., buffer full
8867	.ea18		bc e0 02	ldy $02e0,x	                ldy bufferEndIndices,x       ;note old buffer end
8868	.ea1b		9d e0 02	sta $02e0,x	                sta bufferEndIndices,x       ;update buffer end
8869	.ea1e		20 a8 e9	jsr $e9a8	                jsr getBufferBaseAddress
8870	.ea21		68		pla		                pla                          ;restore value to insert
8871	.ea22		91 fa		sta ($fa),y	                sta (SEIWKA),y               ;store byte in buffer
8872	.ea24		80 c3		bra $e9e9	                bra plp_clc_rts              ;done

8874	.ea26						bufferFull
8875							                ; Issue input buffer full event when appropriate.
8876	.ea26		68		pla		                pla
8877	.ea27		e0 02		cpx #$02	                cpx #bufferFirstOutput
8878	.ea29		b0 07		bcs $ea32	                bcs plp_sec_rts  ;taken if output buffer
8879	.ea2b		a0 01		ldy #$01	                ldy #eventInputBufferFull
8880	.ea2d		20 ec e9	jsr $e9ec	                jsr eventEntryPoint
8881	.ea30		48		pha		                pha
8882	.ea31						pla_plp_sec_rts:
8883	.ea31		68		pla		                pla
8884	.ea32						plp_sec_rts:
8885	.ea32		28		plp		                plp
8886	.ea33		38		sec		                sec
8887	.ea34		60		rts		                rts

8889							;-------------------------------------------------------------------------
8890							;
8891							; Check if character is a letter - A-Z or a-z.
8892							;
8893							; Entry:
8894							;
8895							; A = character to test
8896							;
8897							; Exit:
8898							;
8899							; C=0 if character is letter, C=1 otherwise
8900							;
8901							; Preserves: A/X/Y
8902	.ea35						isLetter: .proc                 ;EA71
8903	.ea35		48		pha		                pha
8904	.ea36		29 df		and #$df	                and #$DF        ;convert to upper case
8905	.ea38		c9 5b		cmp #$5b	                cmp #'Z'+1
8906	.ea3a		b0 04		bcs $ea40	                bcs +           ;branch taken with C=1 if past Z
8907	.ea3c		49 ff		eor #$ff	                eor #$FF
8908	.ea3e		c9 bf		cmp #$bf	                cmp #-'A'       ;C=1 if past A
8909	.ea40						+
8910	.ea40		68		pla		                pla
8911	.ea41		60		rts		                rts
8912							                .pend

8914							;-------------------------------------------------------------------------
8915							;
8916							; OSBYTE 153 (&99) Insert character code into buffer, checking for
8917							; ESCAPE [MasRef D.2-46]
8918							;
8919							                .if version==350
8920	.ea42						clearTSTAndInsertCharacterIntoKeyboardBuffer:
8921	.ea42		20 5c f3	jsr $f35c	                jsr withTSTClear
8922							                .endif
8923	.ea45						insertCharacterIntoKeyboardBuffer:
8924	.ea45		a2 00		ldx #$00	                ldx #$00
8925	.ea47						osbyte99:
8926							                .if version!=400
8927	.ea47		8a		txa		                txa                          ;X=1 if RS423, 0 if keyboard
8928	.ea48		2d 45 02	and $0245	                and rs423InputInterpretationStatus ;A=0 if RS423 simulates keyboard, 1=default
8929	.ea4b		d0 b6		bne $ea03	                bne osbyte8A ;taken if default - don't treat RS423 as keyboard
8930							                .endif
8931	.ea4d		98		tya		                tya          ;A=char
8932	.ea4e		4d 6c 02	eor $026c	                eor escapeCharacter
8933	.ea51		0d 75 02	ora $0275	                ora escapeKeyStatus
8934	.ea54		d0 a6		bne $e9fc	                bne insertCharacterIntoBuffer
8935	.ea56		ad 58 02	lda $0258	                lda breakAndESCAPEEffect
8936	.ea59		6a		ror a		                ror a                        ;C=0 if normal ESCAPE action
8937	.ea5a		98		tya		                tya                          ;A=char
8938	.ea5b		b0 0a		bcs $ea67	                bcs osbyte99Done             ;taken if ESCAPE inhibited
8939	.ea5d		a0 06		ldy #$06	                ldy #eventESCAPEPressed
8940	.ea5f		20 ec e9	jsr $e9ec	                jsr eventEntryPoint
8941	.ea62		90 03		bcc $ea67	                bcc osbyte99Done             ;taken if event handled
8942	.ea64		20 9f eb	jsr $eb9f	                jsr osbyte7D
8943	.ea67						osbyte99Done:
8944	.ea67		18		clc		                clc
8945	.ea68		60		rts		                rts

8947							;-------------------------------------------------------------------------

8949							; A = 0 (edit keys)/1 (ascii keys)/2 (F keys)
8950	.ea69						handleCursorKeysAndCopy:
8951							                .if version<500
8952	.ea69		6a		ror a		                ror a                        ;test edit keys mode bit 0
8953	.ea6a		68		pla		                pla                          ;restore translated value
8954	.ea6b		b0 28		bcs $ea95	                bcs clc_rts_EABD       ;taken if value was asciiKeys
8959							                .endif

8961	.ea6d						handleFunctionKey:
8962	.ea6d		98		tya		                tya
8963							                .if version<500&&version!=350
8965							                .endif
8966							                .if version==350
8967	.ea6e		48		pha		                pha
8968	.ea6f		20 20 e5	jsr $e520	                jsr LE520
8976							                .endif
8977	.ea72		49 04		eor #$04	                eor #$04
8978	.ea74		a8		tay		                tay
8979	.ea75		b9 65 02	lda $0265,y	                lda input192To207Interpretation-8,y
8980	.ea78		4a		lsr a		                lsr a
8981							                .if version<500&&version!=350
8986							                .else
8987	.ea79		d0 03		bne $ea7e	                bne +
8988	.ea7b		4c 39 eb	jmp $eb39	                jmp LEC99
8989	.ea7e						+
8990	.ea7e		2a		rol a		                rol a
8991	.ea7f		c9 02		cmp #$02	                cmp #2
8992	.ea81		d0 0b		bne $ea8e	                bne LEBF5
8993	.ea83						LEBEA:
8994	.ea83		68		pla		                pla
8995	.ea84		85 f8		sta $f8		                sta softKeyExpansionPtr
8996	.ea86		a9 ff		lda #$ff	                lda #$ff
8997	.ea88		8d 68 02	sta $0268	                sta softKeyStringLength
8998	.ea8b		1a		inc a		                inc a
8999	.ea8c		80 07		bra $ea95	                bra clc_rts_EABD

9001	.ea8e						LEBF5:
9002	.ea8e		68		pla		                pla
9003	.ea8f		29 0f		and #$0f	                and #$0f
9004	.ea91		18		clc		                clc
9005	.ea92		79 65 02	adc $0265,y	                adc input192To207Interpretation-8,y
9006							                .endif

9008	.ea95						clc_rts_EABD:
9009	.ea95		18		clc		                clc
9010	.ea96		60		rts		                rts

9012							;-------------------------------------------------------------------------

9014	.ea97						copyCharNotRecognised:
9015	.ea97		20 19 ef	jsr $ef19	                jsr vdu7EntryPoint           ;beep
9016	.ea9a		fa		plx		                plx
9017	.ea9b						readFromInputBufferX:
9018	.ea9b		20 b8 e9	jsr $e9b8	                jsr osbyte91          ;extract character from buffer X
9019							                .if version<500&&version!=350
9021							                .elsif version>=500||version==350
9022	.ea9e		b0 0c		bcs $eaac	                bcs LEC0D
9023	.eaa0		a8		tay		                tay
9024	.eaa1		d0 1f		bne $eac2	                bne LEAC8
9025							                .if version>=511||version==350
9026	.eaa3		8a		txa		                txa
9027	.eaa4		2d 45 02	and $0245	                and rs423InputInterpretationStatus
9028	.eaa7		d0 18		bne $eac1	                bne LEC29
9029							                .endif
9030							                .if version==350&&!finmos329
9031	.eaa9		20 75 eb	jsr $eb75	                jsr LEB75
9034							                .endif
9035	.eaac						LEC0D:
9036	.eaac		b0 7e		bcs $eb2c	                bcs rtsEB28
9037	.eaae		a8		tay		                tay
9038	.eaaf		d0 e4		bne $ea95	                bne clc_rts_EABD
9039	.eab1		48		pha		                pha
9040	.eab2		a0 08		ldy #$08	                ldy #8

9042	.eab4						LEC15:
9043	.eab4		b9 6c 02	lda $026c,y	                lda shiftCtrlSoftKeyInterpretation-8,y
9044	.eab7		c9 02		cmp #$02	                cmp #2
9045	.eab9		f0 c8		beq $ea83	                beq LEBEA
9046	.eabb		88		dey		                dey
9047	.eabc		d0 f6		bne $eab4	                bne LEC15
9048	.eabe		68		pla		                pla
9049	.eabf		80 d4		bra $ea95	                bra clc_rts_EABD
9050							                .endif

9052							                .if version>=511||version==350
9053	.eac1						LEC29:
9054	.eac1		98		tya		                tya
9055							                .endif

9057							                .if version!=400
9058	.eac2						LEAC8:
9059	.eac2		48		pha		                pha                   ;save character extracted
9060	.eac3		e0 01		cpx #$01	                cpx #bufferRS423Input ;was it RS423 input buffer?
9061	.eac5		d0 06		bne $eacd	                bne LEAD3             ;taken if not RS423 input buffer
9062	.eac7		20 d5 e8	jsr $e8d5	                jsr setRS423Active
9063	.eaca		38		sec		                sec
9064	.eacb		a2 01		ldx #$01	                ldx #bufferRS423Input

9066	.eacd						LEAD3:
9067	.eacd		68		pla		                pla                          ;restore char extracted
9068	.eace		90 05		bcc $ead5	                bcc LEADB                    ;taken if keyboard buffer
9069	.ead0		ac 45 02	ldy $0245	                ldy rs423InputInterpretationStatus ;D.2-54
9070	.ead3		d0 56		bne $eb2b	                bne clc_rts_EB27             ;taken if default mode
9071							                .endif

9073	.ead5						LEADB:
9074	.ead5		a8		tay		                tay                          ;Y = char
9075	.ead6		10 53		bpl $eb2b	                bpl clc_rts_EB27             ;if normal char, all good
9076	.ead8		29 0f		and #$0f	                and #$0F
9077	.eada		c9 0b		cmp #$0b	                cmp #$0B
9078	.eadc		90 8f		bcc $ea6d	                bcc handleFunctionKey        ;taken if F key
9079	.eade		69 7b		adc #$7b	                adc #$7B    ;C=1, so +$7c - convert $0b-0$f to $87-$8B
9080	.eae0		48		pha		                pha         ;save translated value
9081	.eae1		ad 7d 02	lda $027d	                lda editKeysMode
9082	.eae4		d0 83		bne $ea69	                bne handleCursorKeysAndCopy  ;taken if not editKeys
9083	.eae6		ad 7c 02	lda $027c	                lda characterDestinationStatus
9084	.eae9		6a		ror a		                ror a                        ;C=rs423_enable
9085	.eaea		6a		ror a		                ror a                        ;C=vdu_disable
9086	.eaeb		68		pla		                pla                          ;restore translated value
9087	.eaec		b0 ad		bcs $ea9b	                bcs readFromInputBufferX     ;taken if VDU output disabled
9088	.eaee		c9 87		cmp #$87	                cmp #$87                     ;COPY?
9089	.eaf0		f0 3b		beq $eb2d	                beq readCopyChar
9090	.eaf2		da		phx		                phx                          ;save buffer number
9091	.eaf3		20 69 eb	jsr $eb69	                jsr handleCursorKeyThunk     ;handle cursor key
9092	.eaf6		fa		plx		                plx
9093	.eaf7						readFromEconetOrSoftKeyOrInputBufferA:
9094							                .if version==400
9096							                .endif
9097	.eaf7		2c 5f 02	bit $025f	                bit econetInputInterpretationStatus
9098	.eafa		10 05		bpl $eb01	                bpl readFromSoftKeyOrInputBufferA
9099	.eafc		a9 06		lda #$06	                lda #netReadCharacterAttempted
9100	.eafe						callNETV:
9101	.eafe		6c 24 02	jmp ($0224)	                jmp (NETV)

9103	.eb01						readFromSoftKeyOrInputBufferA:
9104	.eb01		ad 68 02	lda $0268	                lda softKeyStringLength
9105	.eb04		f0 95		beq $ea9b	                beq readFromInputBufferX
9106							                .if version>=500||version==350
9107	.eb06		1a		inc a		                inc a
9108	.eb07		d0 07		bne $eb10	                bne LEC70
9109	.eb09		9c 68 02	stz $0268	                stz softKeyStringLength
9110	.eb0c		a5 f8		lda $f8		                lda softKeyExpansionPtr
9111	.eb0e		80 1b		bra $eb2b	                bra clc_rts_EB27
9112	.eb10						LEC70:
9113							                .endif
9114							                .if version!=400
9115	.eb10		8a		txa		                txa
9116	.eb11		2d 45 02	and $0245	                and rs423InputInterpretationStatus
9117	.eb14		d0 85		bne $ea9b	                bne readFromInputBufferX
9118							                .endif
9119	.eb16		a5 f4		lda $f4		                lda $F4
9120	.eb18		48		pha		                pha
9121	.eb19		20 62 e5	jsr $e562	                jsr selectTerminalROMAndANDY2
9122	.eb1c		b2 f8		lda ($f8)	                lda (softKeyExpansionPtr)
9123	.eb1e		fa		plx		                plx
9124	.eb1f		20 4b e5	jsr $e54b	                jsr selectROMX
9125	.eb22		ce 68 02	dec $0268	                dec softKeyStringLength
9126	.eb25		e6 f8		inc $f8		                inc softKeyExpansionPtr+0
9127	.eb27		d0 02		bne $eb2b	                bne clc_rts_EB27
9128	.eb29		e6 f9		inc $f9		                inc softKeyExpansionPtr+1
9129	.eb2b						clc_rts_EB27:
9130	.eb2b		18		clc		                clc
9131	.eb2c						rtsEB28:
9132	.eb2c		60		rts		                rts

9134	.eb2d						readCopyChar:
9135	.eb2d		da		phx		                phx
9136	.eb2e		20 6f eb	jsr $eb6f	                jsr handleCopyKeyThunk
9137							                .if version<500&&version!=350
9139							                .else
9140	.eb31		d0 03		bne $eb36	                bne +
9141	.eb33		4c 97 ea	jmp $ea97	                jmp copyCharNotRecognised
9142	.eb36						+
9143							                .endif
9144	.eb36		fa		plx		                plx
9145	.eb37		18		clc		                clc
9146	.eb38						rtsEB31:
9147	.eb38		60		rts		                rts

9149							                .if version>=500||version==350
9150	.eb39						LEC99:
9151	.eb39		68		pla		                pla
9152	.eb3a		29 0f		and #$0f	                and #$0f
9153	.eb3c		a8		tay		                tay
9154	.eb3d		b0 03		bcs $eb42	                bcs LECA2
9155	.eb3f		4c 9b ea	jmp $ea9b	                jmp readFromInputBufferX

9157	.eb42						LECA2:
9158	.eb42		8d c9 02	sta $02c9	                sta currentSoftKey

9168							                .endif

9170	.eb45		a5 f4		lda $f4		                lda $F4
9171	.eb47		48		pha		                pha                           ;save old ROMSEL
9172	.eb48		20 62 e5	jsr $e562	                jsr selectTerminalROMAndANDY2
9173	.eb4b		20 61 eb	jsr $eb61	                jsr getSoftKeyStringLength
9174	.eb4e		8d 68 02	sta $0268	                sta softKeyStringLength
9175	.eb51		b9 00 80	lda $8000,y	                lda andy.softKeys.stringLSBs,y
9176	.eb54		85 f8		sta $f8		                sta softKeyExpansionPtr+0
9177	.eb56		b9 11 80	lda $8011,y	                lda andy.softKeys.stringMSBs,y
9178	.eb59		85 f9		sta $f9		                sta softKeyExpansionPtr+1
9179	.eb5b		68		pla		                pla
9180	.eb5c		20 5c e5	jsr $e55c	                jsr selectROMA               ;restore old ROMSEL
9181	.eb5f		80 96		bra $eaf7	                bra readFromEconetOrSoftKeyOrInputBufferA

9183							;-------------------------------------------------------------------------

9185	.eb61						getSoftKeyStringLength:
9186	.eb61		b9 01 80	lda $8001,y	                lda andy.softKeys.stringLSBs+1,y
9187	.eb64		38		sec		                sec
9188	.eb65		f9 00 80	sbc $8000,y	                sbc andy.softKeys.stringLSBs+0,y
9189	.eb68		60		rts		                rts

9191							;-------------------------------------------------------------------------
9192							;
9193							; Page HAZEL out, page MOS in, call handleCursorKey.
9194							;
9195	.eb69						handleCursorKeyThunk:
9196	.eb69		20 2d f3	jsr $f32d	                jsr withMOSROM
9197	.eb6c		4c 78 df	jmp $df78	                jmp handleCursorKey

9199							;-------------------------------------------------------------------------
9200							;
9201							; Page HAZEL out, page MOS in, call handleCopyKey.
9202							;
9203	.eb6f						handleCopyKeyThunk:
9204	.eb6f		20 2d f3	jsr $f32d	                jsr withMOSROM
9205	.eb72		4c 5e df	jmp $df5e	                jmp handleCopyKey

9207							;-------------------------------------------------------------------------

9209							                .if version==350&&!finmos329
9210	.eb75						LEB75:
9211	.eb75		20 b8 e9	jsr $e9b8	                jsr osbyte91
9212	.eb78		90 04		bcc $eb7e	                bcc LEB7E
9213	.eb7a		24 ff		bit $ff		                bit $ff
9214	.eb7c		10 f7		bpl $eb75	                bpl LEB75
9215	.eb7e						LEB7E:
9216	.eb7e		60		rts		                rts
9217							                .endif

9219							;-------------------------------------------------------------------------

9221							                .if version<500&&version!=350
9223							                .endif

9225							;-------------------------------------------------------------------------

9227	.eb7f						osbyte88: ;LEC37:
9228	.eb7f		a9 00		lda #$00	                lda #$00

9230	.eb81						callUSERV:
9231	.eb81		6c 00 02	jmp ($0200)	                jmp (USERV)

9233	.eb84						osbyte7E:                       ;ec3c
9234	.eb84		a2 00		ldx #$00	                ldx #$00
9235	.eb86		24 ff		bit $ff		                bit $FF
9236	.eb88		10 14		bpl $eb9e	                bpl osbyte7C
9237	.eb8a		ad 76 02	lda $0276	                lda escapeEffects
9238	.eb8d		d0 0d		bne $eb9c	                bne LEC54
9239	.eb8f		58		cli		                cli
9240	.eb90		9c 69 02	stz $0269	                stz pagedModeCounter
9241	.eb93		20 16 f3	jsr $f316	                jsr withTerminalROM
9242	.eb96		20 ab a5	jsr $a5ab	                jsr starEXEC
9243	.eb99		20 11 e9	jsr $e911	                jsr LE947
9244	.eb9c						LEC54:
9245	.eb9c		a2 ff		ldx #$ff	                ldx #$FF
9246	.eb9e						osbyte7C: ;EC56
9247	.eb9e		18		clc		                clc
9248	.eb9f						osbyte7D: ;EC57
9249							                .if includeTubeSupport
9250							                .if version==350
9251	.eb9f		08		php		                php
9252	.eba0		26 ff		rol $ff		                rol escapeFlag
9253	.eba2		28		plp		                plp
9254							                .endif
9255	.eba3		66 ff		ror $ff		                ror escapeFlag
9256	.eba5		2c 7a 02	bit $027a	                bit tubePresence
9257	.eba8		10 7b		bpl $ec25	                bpl LECD9
9258	.ebaa		4c 03 04	jmp $0403	                jmp tubeHost.copyEscapeStatus
9268							                .endif

9270							;-------------------------------------------------------------------------

9272							                .if version<400
9273	.ebad						osbyte89:
9274	.ebad		ad 82 02	lda $0282	                lda serialULARegister
9275	.ebb0		a8		tay		                tay
9276	.ebb1		2a		rol a		                rol a
9277	.ebb2		e0 01		cpx #$01	                cpx #$01
9278	.ebb4		6a		ror a		                ror a
9279	.ebb5		80 1e		bra $ebd5	                bra LEC89
9280							                .endif

9282							;-------------------------------------------------------------------------
9283							;
9284							; ;OSBYTE 8 (&08) Write RS423 transmit rate
9285							;
9286							; This call sets the RS423 baud rate for transmitting data. The actual format of
9287							; the data is set using OSBYTE 156/&9C (see below).
9288							;
9289							; Entry parameters :
9290							; X=0 selects 9600 baud
9291							; X=1 selects 75 baud
9292							; X=2 selects 150 baud
9293							; X=3 selects 300 baud
9294							; X=4 selects 1200 baud
9295							; X=5 selects 2400 baud
9296							; X=6 selects 4800 baud
9297							; X=7 selects 9600 baud
9298							; X=8 selects 19200 baud
9299							; Y=0
9300							;
9301							; On exit : X=Y=<old serial ACIA control register contents>

9303							                .if version!=400
9304	.ebb7						osbyte08:
9305	.ebb7		a9 38		lda #$38	                lda #$38
9306							                ; fall through to OSBYTE &07
9307							                .endif

9309							;-------------------------------------------------------------------------
9310							;
9311							; OSBYTE 7 (&07) Write RS423 receive rate
9312							;
9313							; This call sets the RS423 baud rate for receiving data. The actual
9314							; format of the data is set using OSBYTE 156/&9C (see below).
9315							;
9316							; Entry parameters :
9317							; X=0 selects 9600 baud
9318							; X=1 selects 75 baud
9319							; X=2 selects 150 baud
9320							; X=3 selects 300 baud
9321							; X=4 selects 1200 baud
9322							; X=5 selects 2400 baud
9323							; X=6 selects 4800 baud
9324							; X=7 selects 9600 baud
9325							; X=8 selects 19200 baud
9326							; Y=0
9327							;
9328							; On exit : X=Y=<old serial ACIA control register contents>

9330							                .if version!=400
9331	.ebb9						osbyte07:                                    ;ec6d
9332	.ebb9		49 3f		eor #$3f	                eor #$3F                     ;if OSBYTE 8,
9333							                                             ;A=%00000111, mask for
9334							                                             ;transmit rate; if OSBYTE
9335							                                             ;8, A=%000111000, mask
9336							                                             ;for receive rate.
9337	.ebbb		85 fa		sta $fa		                sta $FA                      ;save mask
9338	.ebbd		ac 82 02	ldy $0282	                ldy serialULARegister                    ;
9339	.ebc0		e0 09		cpx #$09	                cpx #$09                     ;check for invalid baud rate
9340	.ebc2		b0 17		bcs $ebdb	                bcs LEC8F                    ;branch taken if invalid
9341	.ebc4		3d 4f f0	and $f04f,x	                and serialBaudRatesTable,x   ;get setting in A
9342	.ebc7		85 fb		sta $fb		                sta $FB                      ;store setting
9343	.ebc9		98		tya		                tya                          ;
9344	.ebca		05 fa		ora $fa		                ora $FA
9345	.ebcc		45 fa		eor $fa		                eor $FA
9346	.ebce		05 fb		ora $fb		                ora $FB
9347	.ebd0		09 40		ora #$40	                ora #$40
9348	.ebd2		4d 5d 02	eor $025d	                eor rs423Destination ;mask in tape/serial flag set by OSBYTE 205ac
9349	.ebd5						LEC89:
9350	.ebd5		8d 82 02	sta $0282	                sta serialULARegister
9351	.ebd8		8d 10 fe	sta $fe10	                sta SERPROC+0
9352	.ebdb						LEC8F:
9353	.ebdb		98		tya		                tya
9354	.ebdc						LEC90:
9355	.ebdc		aa		tax		                tax
9356	.ebdd		60		rts		                rts
9357							                .endif

9359							                .if version==400
9364							                .endif

9366							;-------------------------------------------------------------------------

9368							; Y=0 on entry.

9370	.ebde						osbyte09:                       ;ec92
9371	.ebde		c8		iny		                iny
9372	.ebdf		18		clc		                clc
9373	.ebe0						osbyte0A:                                    ;ec94
9374	.ebe0		b9 52 02	lda $0252,y	                lda firstFlashColourDuration,y
9375	.ebe3		48		pha		                pha
9376	.ebe4		8a		txa		                txa
9377	.ebe5		99 52 02	sta $0252,y	                sta firstFlashColourDuration,y
9378	.ebe8		7a		ply		                ply
9379	.ebe9		ad 51 02	lda $0251	                lda flashCounter
9380	.ebec		d0 ed		bne $ebdb	                bne LEC8F
9381	.ebee		8e 51 02	stx $0251	                stx flashCounter
9382	.ebf1		ad 48 02	lda $0248	                lda vcontrolRegister
9383	.ebf4		08		php		                php
9384	.ebf5		6a		ror a		                ror a
9385	.ebf6		28		plp		                plp
9386	.ebf7		2a		rol a		                rol a
9387	.ebf8		8d 48 02	sta $0248	                sta vcontrolRegister
9388	.ebfb		8d 20 fe	sta $fe20	                sta VCONTROL
9389	.ebfe		80 db		bra $ebdb	                bra LEC8F

9391							;-------------------------------------------------------------------------
9392							;
9393							; OSBYTE 2 (&02) Specify input stream
9394							;
9395							; Input may be taken from either the keyboard (by default) or the
9396							; RS423 port. This call specifies the selection for all subsequent
9397							; input.
9398							;
9399							; Entry parameters :
9400							; X=0 selects keyboard input and disables RS423
9401							; X=1 selects and enables RS423 input
9402							; X=2 selects keyboard input and enables RS423
9403							; Y=0
9404							;
9405							; On exit : X=0 indicates previous input was from the keyboard
9406							;           X=1 indicates previous input was from RS423
9407							;           Y is undefined
9408							;
9409							; D.2-18
9410							                .if version!=400
9411	.ec00						osbyte02:                       ;ecb4
9412	.ec00		8a		txa		                txa
9413	.ec01		29 01		and #$01	                and #$01
9414	.ec03		48		pha		                pha
9415	.ec04		ad 50 02	lda $0250	                lda aciaControlRegister
9416	.ec07		2a		rol a		                rol a
9417	.ec08		e0 01		cpx #$01	                cpx #$01
9418	.ec0a		6a		ror a		                ror a
9419	.ec0b		cd 50 02	cmp $0250	                cmp aciaControlRegister
9420	.ec0e		08		php		                php
9421	.ec0f		8d 50 02	sta $0250	                sta aciaControlRegister
9422	.ec12		8d 08 fe	sta $fe08	                sta ACIA+0
9423	.ec15		20 d5 e8	jsr $e8d5	                jsr setRS423Active
9424	.ec18		28		plp		                plp
9425	.ec19		f0 03		beq $ec1e	                beq LECD2
9426	.ec1b		2c 09 fe	bit $fe09	                bit ACIA+1
9427	.ec1e						LECD2:
9428	.ec1e		ae 41 02	ldx $0241	                ldx inputSource
9429	.ec21		68		pla		                pla
9430	.ec22		8d 41 02	sta $0241	                sta inputSource
9431	.ec25						LECD9:
9432	.ec25		60		rts		                rts
9433							                .endif

9435							;-------------------------------------------------------------------------
9436							;
9437							; OSBYTE 13 (&0D) Disable event
9438							;
9439							; All events are assigned a unique number and this call provides a
9440							; means of disabling specific events.
9441							;
9442							; Entry parameters:
9443							; X = event number
9444							;
9445							; On exit: X = Y = <old enable state> (0=disabled)
9446	.ec26						osbyte0D:
9447	.ec26		98		tya		                tya             ;A=0

9449							;-------------------------------------------------------------------------
9450							;
9451							; OSBYTE 14 (&0E) Enable event
9452							;
9453							; This call provides a means of enabling specific events.
9454							;
9455							;
9456	.ec27						osbyte0E:
9457	.ec27		e0 0a		cpx #$0a	                cpx #eventMax+1
9458							                .if version!=400
9459	.ec29		b0 b1		bcs $ebdc	                bcs LEC90
9462							                .endif
9463	.ec2b		bc bf 02	ldy $02bf,x	                ldy eventEnabledFlags,x
9464	.ec2e		9d bf 02	sta $02bf,x	                sta eventEnabledFlags,x
9465							                .if version!=400
9466	.ec31		80 a8		bra $ebdb	                bra LEC8F
9475							                .endif

9477							;-------------------------------------------------------------------------
9478							;
9479							; OSBYTE 16 (&10) Write number of ADC channels
9480							;
9481							; By default, each of the four ADC channels is sampled and converted
9482							; in turn so that each reading is updated every 40 milliseconds. This
9483							; call enables the number of channels to be changed so that if, for
9484							; example, only two channels are required, each will be updated every
9485							; 20 milliseconds.
9486							;
9487							                .if version!=400
9488	.ec33						osbyte10:
9489							                .if version<500
9490	.ec33		f0 03		beq $ec38	                beq +                        ;taken if X=0
9491	.ec35		20 68 e7	jsr $e768	                jsr osbyte11
9492	.ec38						+
9493							                .endif
9494	.ec38		ad 4d 02	lda $024d	                lda maximumADCChannel
9495	.ec3b		8e 4d 02	stx $024d	                stx maximumADCChannel
9496	.ec3e		aa		tax		                tax
9497	.ec3f		60		rts		                rts
9498							                .endif

9500							;-------------------------------------------------------------------------
9501							;
9502							; OSBYTE 129 (&81) Read key with time limit
9503							;
9504							; This call may be used to read a key from the keyboard subject to a
9505							; specified time limit or to perform a keyboard scan for a specified
9506							; key depression.

9508	.ec40						osbyte81:
9509	.ec40		98		tya		                tya
9510	.ec41		30 0a		bmi $ec4d	                bmi LED01          ;taken if scanning for specific key
9511	.ec43		20 7d e7	jsr $e77d	                jsr osbyte81Timed
9512	.ec46		b0 03		bcs $ec4b	                bcs LECFF                 ;taken if timed out or error
9513	.ec48		aa		tax		                tax                       ;X = ASCII char
9514	.ec49						LECFD:
9515	.ec49		a9 00		lda #$00	                lda #$00
9516	.ec4b						LECFF:
9517	.ec4b		a8		tay		                tay
9518	.ec4c		60		rts		                rts

9520	.ec4d						LED01:
9521	.ec4d		8a		txa		                txa
9522	.ec4e		f0 10		beq $ec60	                beq LED14
9523	.ec50		49 7f		eor #$7f	                eor #$7F
9524	.ec52		aa		tax		                tax
9525	.ec53		20 20 f6	jsr $f620	                jsr callKEYV
9526	.ec56		2a		rol a		                rol a
9527							                ; fall through

9529							;-------------------------------------------------------------------------

9531	.ec57						osbyte82:
9532	.ec57		a2 ff		ldx #$ff	                ldx #$FF
9533	.ec59		a0 ff		ldy #$ff	                ldy #$FF
9534	.ec5b		b0 02		bcs $ec5f	                bcs LEB13                    ;if OSBYTE $82, done
9535	.ec5d		e8		inx		                inx
9536	.ec5e		c8		iny		                iny
9537	.ec5f						LEB13:
9538	.ec5f		60		rts		                rts

9540	.ec60						LED14:
9541							                .if version==320
9549							                .elsif version==350
9550	.ec60		a2 fd		ldx #$fd	                ldx #$fd
9551							                .endif
9552	.ec62		80 e5		bra $ec49	                bra LECFD

9554	.ec64						LED18:
9555							                .if version==400
9557							                .endif
9558	.ec64		8a		txa		                txa
9559	.ec65		49 ff		eor #$ff	                eor #$FF
9560	.ec67		aa		tax		                tax
9561	.ec68		e0 02		cpx #$02	                cpx #$02
9562							                ; fall through

9564							;-------------------------------------------------------------------------

9566	.ec6a						countBufferViaCNPV:
9567	.ec6a		b8		clv		                clv
9568	.ec6b		80 03		bra $ec70	                bra callCNPV

9570	.ec6d						purgeBufferViaCNPV:
9571	.ec6d		2c 5e e3	bit $e35e	                bit valueFF                  ;V=1
9572	.ec70						callCNPV:
9573	.ec70		6c 2e 02	jmp ($022e)	                jmp (CNPV)

9575							;-------------------------------------------------------------------------

9577							                .if version!=400
9578	.ec73						getRS423InputBufferFreeBytes:
9579	.ec73		38		sec		                sec
9580	.ec74		a2 01		ldx #$01	                ldx #bufferRS423Input
9581	.ec76		20 6a ec	jsr $ec6a	                jsr countBufferViaCNPV
9582	.ec79		c0 01		cpy #$01	                cpy #$01                     ;check MSB
9583	.ec7b		b0 03		bcs $ec80	                bcs +                        ;if >= 256 bytes, all good
9584	.ec7d		ec 5b 02	cpx $025b	                cpx rs423InputBufferMinimumSpace ;compare to min space
9585	.ec80						+
9586	.ec80		60		rts		                rts
9587							                .endif

9589							;-------------------------------------------------------------------------

9591							                .if version!=400
9592	.ec81						osbyte80:
9593	.ec81		30 e1		bmi $ec64	                bmi LED18
9594	.ec83		f0 0c		beq $ec91	                beq LED45
9595							                .if version<500
9596	.ec85		e0 05		cpx #$05	                cpx #$05
9597	.ec87		b0 ce		bcs $ec57	                bcs osbyte82                 ;return with X=$ff Y=$ff
9598	.ec89		bc b9 02	ldy $02b9,x	                ldy adcResultMSBs-1,x
9599	.ec8c		bd b5 02	lda $02b5,x	                lda adcResultLSBs-1,x
9600	.ec8f		aa		tax		                tax
9610							                .endif
9611	.ec90		60		rts		                rts
9612							                .endif

9614							;-------------------------------------------------------------------------

9616							                .if version!=400
9617	.ec91						LED45:
9618							                .if version<500
9619							                ; Put joystick buttons in bits 0/1.
9620	.ec91		ad 40 fe	lda $fe40	                lda systemVIA.irb
9621	.ec94		6a		ror a		                ror a
9622	.ec95		6a		ror a		                ror a
9623	.ec96		6a		ror a		                ror a
9624	.ec97		6a		ror a		                ror a
9625	.ec98		49 ff		eor #$ff	                eor #$FF
9626	.ec9a		29 03		and #$03	                and #$03
9627	.ec9c		ac be 02	ldy $02be	                ldy adcLastChannelRead
9628	.ec9f		8e be 02	stx $02be	                stx adcLastChannelRead
9629	.eca2		aa		tax		                tax
9633							                .endif
9634	.eca3		60		rts		                rts
9635							                .endif

9637							;-------------------------------------------------------------------------
9638							;
9639							; OSBYTE $70
9640							;
9641							; D.2-31
9642							;
9643	.eca4						osbyte70:                       ;ed58
9644	.eca4		20 bc ec	jsr $ecbc	                jsr osbyte7071
9645	.eca7		0a		asl a		                asl a
9646	.eca8		f0 04		beq $ecae	                beq clearACCCCONE
9647	.ecaa						LED5E:
9648	.ecaa		0c 34 fe	tsb $fe34	                tsb ACCCON
9649	.ecad		60		rts		                rts

9651	.ecae						clearACCCCONE:
9652	.ecae		a9 02		lda #$02	                lda #ACCCON.E
9653	.ecb0						LED64:
9654	.ecb0		1c 34 fe	trb $fe34	                trb ACCCON
9655	.ecb3		60		rts		                rts

9657							;-------------------------------------------------------------------------

9659	.ecb4						osbyte71:                       ;ed68
9660	.ecb4		20 bc ec	jsr $ecbc	                jsr osbyte7071
9661	.ecb7		d0 f1		bne $ecaa	                bne LED5E
9662	.ecb9		1a		inc a		                inc a
9663	.ecba		80 f4		bra $ecb0	                bra LED64

9665							;-------------------------------------------------------------------------
9666							;
9667							; Handle OSBYTE $70 or OSBYTE $71
9668							;
9669							; Entry: A=$70 or $71
9670							;
9671	.ecbc						osbyte7071:
9672	.ecbc		a8		tay		                tay
9673	.ecbd		8a		txa		                txa
9674							                .cerror vduDriverMemory+1!=displayMemory
9675	.ecbe		99 1a 02	sta $021a,y	                sta vduDriverMemory-$70,y
9676	.ecc1		d0 09		bne $eccc	                bne LED80
9677	.ecc3		a5 d0		lda $d0		                lda STATE
9678	.ecc5		29 10		and #$10	                and #STATE.isShadowMode
9679	.ecc7		f0 06		beq $eccf	                beq LED83
9680	.ecc9						LED7D:
9681	.ecc9		a9 01		lda #$01	                lda #$01
9682	.eccb		60		rts		                rts

9684	.eccc						LED80:
9685	.eccc		3a		dec a		                dec a
9686	.eccd		d0 fa		bne $ecc9	                bne LED7D
9687	.eccf						LED83:
9688	.eccf		60		rts		                rts

9690							;-------------------------------------------------------------------------

9692							; OSBYTE &6E (110), &6F (111)
9693							; ===========================
9694							; Pass to sideways ROMs
9695	.ecd0						osbyteUnused:                   ;ed84
9696	.ecd0		a2 07		ldx #$07	                ldx #romServiceCallUnrecognisedOSBYTE
9697	.ecd2		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
9698	.ecd5		a6 f0		ldx $f0		                ldx originalX
9699							                .if version!=400
9700	.ecd7		49 00		eor #$00	                eor #$00
9701							                .endif
9702	.ecd9		60		rts		                rts

9704							;-------------------------------------------------------------------------

9706							                .if version!=350
9710							                .endif

9712							;-------------------------------------------------------------------------

9714							                .if version!=350
9718							                .endif

9720							;-------------------------------------------------------------------------
9721							;
9722							; OSBYTE 140 (&8C) Select Cassette Filing System [MasRef D.2-43]
9723							; OSBYTE 141 (&8D) Select ROM Filing System [MasRef D.2-43]
9724							;
9725	.ecda						osbyte8C8D:
9726	.ecda		20 00 ed	jsr $ed00	                jsr selectROMOrTAPEByOSBYTE
9727	.ecdd		ad 34 fe	lda $fe34	                lda ACCCON                    ; Save ACCON register
9728	.ece0		48		pha		                pha
9729	.ece1		20 fa ec	jsr $ecfa	                jsr selectHAZEL         ; Page Hazel workspace in
9730	.ece4		ae 01 df	ldx $df01	                ldx hazel.activeFS
9731	.ece7		8e 00 df	stx $df00	                stx hazel.currentFS
9732	.ecea		a9 0f		lda #$0f	                lda #terminalROM
9733	.ecec		8d 03 df	sta $df03	                sta hazel.currentFSROM
9734	.ecef		68		pla		                pla                          ; Restore ACCON
9735	.ecf0						selectMOSOrHAZEL:                                       ;edb0
9736	.ecf0		29 08		and #$08	                and #ACCCON.Y   ;get just the HAZEL/MOS bit
9737	.ecf2		d0 08		bne $ecfc	                bne setACCCONBits      ;branch taken if HAZEL at $c000
9738	.ecf4						selectMOS:
9739	.ecf4		a9 08		lda #$08	                lda #ACCCON.Y
9740	.ecf6		1c 34 fe	trb $fe34	                trb ACCCON      ;page in MOS at $c000
9741	.ecf9		60		rts		                rts

9743	.ecfa						selectHAZEL:
9744	.ecfa		a9 08		lda #$08	                lda #ACCCON.Y
9745	.ecfc						setACCCONBits:
9746	.ecfc		0c 34 fe	tsb $fe34	                tsb ACCCON      ;page in HAZEL at $c000
9747	.ecff		60		rts		                rts

9749							;-------------------------------------------------------------------------

9751							                .if version==400
9755							                .endif

9757							;-------------------------------------------------------------------------
9758							;
9759							; Select ROM or TAPE.
9760							;
9761							; Two entry points: selectROMOrTAPEByOSBYTE picks FS by OSBYTE number
9762							; ($8c=TAPE, $8d=ROM), and selectROMOrTAPE picks FS by number (0=TAPE,
9763							; 1=ROM).
9764							;
9765							; entry:
9766							;
9767							; A = FS to select
9768							;
9769	.ed00						selectROMOrTAPEByOSBYTE:
9770							                .if version==400
9781							                .else

9783	.ed00		49 8c		eor #$8c	                eor #$8C                     ;A=0 if tape, A=1 if ROM
9784	.ed02						selectROMOrTAPE:
9785	.ed02		0a		asl a		                asl a           ; Set CFS/RFS switch to 0=CFS or 2=RFS
9786	.ed03		8d 47 02	sta $0247	                sta cfsRFSFSSwitch
9787	.ed06		d0 04		bne $ed0c	                bne LEDCC                    ;taken if ROM
9788	.ed08		a9 04		lda #$04	                lda #$04                     ; CFS, clear b2 of status
9789	.ed0a		14 e2		trb $e2		                trb $E2
9790	.ed0c						LEDCC:
9791	.ed0c		e0 03		cpx #$03	                cpx #$03                     ; EQ=TAPE 300, NE=TAPE 1200
9792	.ed0e		80 09		bra $ed19	                bra LEDD6

9794	.ed10						LEDD0:
9795							                .if version==350
9796	.ed10		20 5c f3	jsr $f35c	                jsr withTSTClear
9797							                .endif
9798	.ed13		20 a7 ed	jsr $eda7	                jsr LEE64
9799	.ed16		20 53 f1	jsr $f153	                jsr LF1EE
9800	.ed19						LEDD6:
9801	.ed19		08		php		                php                          ; Save baud flag in Carry
9802	.ed1a		a9 06		lda #$06	                lda #$06                     ; Vectors about to change
9803	.ed1c		20 50 f1	jsr $f150	                jsr callFSCV
9804	.ed1f		ad 47 02	lda $0247	                lda cfsRFSFSSwitch           ; Jump if RFS selected
9805	.ed22		d0 0d		bne $ed31	                bne LEDEE
9806	.ed24		a2 06		ldx #$06	                ldx #$06                     ; Prepare baud=6 for TAPE300
9807	.ed26		28		plp		                plp                          ; Skip past if TAPE300
9808	.ed27		f0 05		beq $ed2e	                beq LEDEB
9809	.ed29		a9 04		lda #$04	                lda #$04                     ; TAPE1200, set bit 2 of status
9810	.ed2b		04 e2		tsb $e2		                tsb $E2
9811	.ed2d		ca		dex		                dex                          ; Change to baud=5 for TAPE1200
9812	.ed2e						LEDEB:
9813	.ed2e		86 c6		stx $c6		                stx $C6                      ; Store baud rate setting
9814	.ed30		08		php		                php
9815	.ed31						LEDEE:
9816	.ed31		64 ce		stz $ce		                stz $CE                      ; Clear byte (unused on BBC)
9817	.ed33		28		plp		                plp
9818							                .endif

9820	.ed34		a2 0e		ldx #$0e	                ldx #defaultVectorTable.fsVectors.end-defaultVectorTable.fsVectors ; Prepare to set 7 vectors
9821	.ed36						LEDF3:
9822	.ed36		bd f8 e2	lda $e2f8,x	                lda defaultVectorTable.fsVectors-1,x ; Set filing
9823							                                                     ; system vectors
9824							                                                     ; to point to
9825							                                                     ; extended
9826							                                                     ; vectors
9827	.ed39		9d 11 02	sta $0211,x	                sta FILEV-1,x
9828	.ed3c		ca		dex		                dex
9829	.ed3d		d0 f7		bne $ed36	                bne LEDF3
9830	.ed3f		20 53 f1	jsr $f153	                jsr LF1EE                    ; Set extended vectors
9831	.ed42		64 c2		stz $c2		                stz $C2                      ; Set Progress=idle
9832	.ed44		a2 0f		ldx #$0f	                ldx #romServiceCallVectorsClaimed ; Send service call &0F - vectors changed

9834							;-------------------------------------------------------------------------
9835							;
9836							; OSBYTE 143 (&8F) Issue paged ROM service request [MasRef D.2-44]
9837							;
9838	.ed46						osbyte8F: .proc                    ;ee03
9839	.ed46		5a		phy		                phy
9840	.ed47		da		phx		                phx                          ; Send service call
9841	.ed48		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
9842	.ed4b		fa		plx		                plx
9843	.ed4c		e0 0f		cpx #$0f	                cpx #romServiceCallVectorsClaimed ; If VectorsClaimed,
9844							                                                  ; hook FileSwitch
9845							                                                  ; back in
9846	.ed4e		f0 36		beq $ed86	                beq handleVectorsClaimed
9847	.ed50		1a		inc a		                inc a       ; If claimed, check for
9848							                            ; InitialiseFilingSystem or
9849							                            ; UnrecognisedCommand
9850	.ed51		3a		dec a		                dec a       ;Z=1 if claimed
9851	.ed52		f0 03		beq $ed57	                beq wasClaimed  ;branch taken if claimed
9852	.ed54						done:
9853	.ed54		fa		plx		                plx             ; Return with result in X, EQ=Claimed
9854	.ed55		aa		tax		                tax
9855	.ed56		60		rts		                rts

9857	.ed57						wasClaimed:
9858	.ed57		e0 12		cpx #$12	                cpx #romServiceCallInitialiseFilingSystem
9859	.ed59		f0 04		beq $ed5f	                beq +
9860	.ed5b		e0 04		cpx #$04	                cpx #romServiceCallUnrecognisedCommand
9861	.ed5d		d0 f5		bne $ed54	                bne done
9862	.ed5f						+

9864							; handle InitialiseFilingSystem ($12) or UnrecognisedCommand ($04)

9866	.ed5f		7a		ply		                ply                     ;Y=service call arg
9867	.ed60		48		pha		                pha                     ;save A (though actually it's
9868							                                        ;always $00...)
9869	.ed61		ad 34 fe	lda $fe34	                lda ACCCON
9870	.ed64		48		pha		                pha                     ;save ACCCON
9871	.ed65		20 fa ec	jsr $ecfa	                jsr selectHAZEL
9872	.ed68		38		sec		                sec
9873	.ed69		6e 00 df	ror $df00	                ror hazel.currentFS ;set currentFS bit 7
9874	.ed6c						LEE29:
9875	.ed6c		5a		phy		                phy             ;save ROM service call argument
9876	.ed6d		a9 00		lda #$00	                lda #$00
9877	.ed6f		a8		tay		                tay
9878	.ed70		20 54 f7	jsr $f754	                jsr callARGSV   ;A=0, Y=0 - get active FS number
9879	.ed73		8d 01 df	sta $df01	                sta hazel.activeFS ;save active FS number
9880	.ed76		2c 00 df	bit $df00	                bit hazel.currentFS
9881	.ed79		10 03		bpl $ed7e	                bpl LEE3B
9882	.ed7b		20 74 f1	jsr $f174	                jsr osbyte6D
9883	.ed7e						LEE3B:
9884	.ed7e		7a		ply		                ply
9885	.ed7f		68		pla		                pla
9886	.ed80		20 f0 ec	jsr $ecf0	                jsr selectMOSOrHAZEL
9887	.ed83		68		pla		                pla
9888	.ed84		aa		tax		                tax
9889	.ed85		60		rts		                rts

9891	.ed86						handleVectorsClaimed:
9892	.ed86		7a		ply		                ply
9893	.ed87		48		pha		                pha
9894	.ed88		ad 34 fe	lda $fe34	                lda ACCCON
9895	.ed8b		48		pha		                pha
9896	.ed8c		20 fa ec	jsr $ecfa	                jsr selectHAZEL
9897	.ed8f		ad 1e 02	lda $021e	                lda FSCV+0
9898	.ed92		8d da df	sta $dfda	                sta hazel.activeFSCV+0
9899	.ed95		ad 1f 02	lda $021f	                lda FSCV+1
9900	.ed98		8d db df	sta $dfdb	                sta hazel.activeFSCV+1
9901	.ed9b		a9 a5		lda #$a5	                lda #<fileswitchFSCEntryPoint
9902	.ed9d		8d 1e 02	sta $021e	                sta FSCV+0
9903	.eda0		a9 f8		lda #$f8	                lda #>fileswitchFSCEntryPoint
9904	.eda2		8d 1f 02	sta $021f	                sta FSCV+1
9905	.eda5		80 c5		bra $ed6c	                bra LEE29
9906							                .pend

9908							;-------------------------------------------------------------------------

9910	.eda7						LEE64:
9911	.eda7		a9 a1		lda #$a1	                lda #$A1
9912	.eda9		85 e3		sta $e3		                sta $E3
9913	.edab		a9 19		lda #$19	                lda #$19
9914	.edad		8d d1 03	sta $03d1	                sta $03D1
9915	.edb0		a9 04		lda #$04	                lda #$04
9916	.edb2		04 e2		tsb $e2		                tsb $E2
9917	.edb4		60		rts		                rts

9919							;-------------------------------------------------------------------------
9920							;
9921							; Pass service call around sideways ROMs
9922							;
9923							; Entry:
9924							; X=service call number
9925							; Y=any parameters
9926							;
9927							; Exit:
9928							; X=0 or preserved
9929							; Y=any returned parameters
9930							; EQ=call claimed if called directly
9931							;
9932	.edb5						makeROMServiceCall: .proc                    ;ee72
9933	.edb5		a5 f4		lda $f4		                lda $F4         ; Save current ROM
9934	.edb7		48		pha		                pha
9935	.edb8		ad 34 fe	lda $fe34	                lda ACCCON      ; Save current paging state
9936	.edbb		48		pha		                pha
9937	.edbc		20 fa ec	jsr $ecfa	                jsr selectHAZEL ; Page in Hazel
9938	.edbf		8a		txa		                txa             ; Pass service call number to A
9939	.edc0		a2 0f		ldx #$0f	                ldx #$0F     ; Start at ROM 15, and always call ROM 15
9940	.edc2		80 05		bra $edc9	                bra callServiceEntry
9941	.edc4						callServiceEntriesLoop:
9942	.edc4		3c a1 02	bit $02a1,x	                bit romInformationTable,x ;check if ROM X has a service entry
9943	.edc7		10 0b		bpl $edd4	                bpl nextROM       ;branch taken if no service entry
9944	.edc9						callServiceEntry:
9945	.edc9		20 4b e5	jsr $e54b	                jsr selectROMX  ; Page in ROM X
9946	.edcc		20 03 80	jsr $8003	                jsr $8003       ; Call ROM service entry point
9947	.edcf		aa		tax		                tax             ; X = service call result
9948	.edd0		f0 05		beq $edd7	                beq done       ;branch taken if service call claimed
9949	.edd2		a6 f4		ldx $f4		                ldx $F4         ; Get ROM number
9950	.edd4						nextROM:
9951	.edd4		ca		dex		                dex       ; Step down to next ROM, loop until all done
9952	.edd5		10 ed		bpl $edc4	                bpl callServiceEntriesLoop

9954	.edd7						done:
9955	.edd7		68		pla		                pla                          ; Restore paging state
9956	.edd8		20 f0 ec	jsr $ecf0	                jsr selectMOSOrHAZEL
9957	.eddb		68		pla		                pla                          ; Restore current ROM
9958	.eddc		20 5c e5	jsr $e55c	                jsr selectROMA
9959	.eddf		8a		txa		                txa                          ; Pass claim/noclaim to A
9960	.ede0		60		rts		                rts
9961							                .pend

9963							;-------------------------------------------------------------------------

9965							; OSBYTE &6B (107) - Select memory for direct access
9966							; ==============================================
9967	.ede1						osbyte6B:                       ;ee9e
9968	.ede1		a0 20		ldy #$20	                ldy #$20                     ; Y=&20 to change 1MHz bit
9969	.ede3		80 02		bra $ede7	                bra LEEA4

9971							;-------------------------------------------------------------------------

9973							; OSBYTE &6C (108) - Select memory for direct access
9974							; ==============================================
9975	.ede5						osbyte6C:
9976	.ede5		a0 04		ldy #$04	                ldy #ACCCON.X                ; Y=&04 to change RAM bit
9977	.ede7						LEEA4:
9978	.ede7		98		tya		                tya                          ; Clear RAM or 1MHz bit
9979	.ede8		1c 34 fe	trb $fe34	                trb ACCCON
9980	.edeb		8a		txa		                txa                          ; If X=0, exit with normal RAM/1MHz selected
9981	.edec		f0 04		beq $edf2	                beq LEEB0
9982							                .if correctOSBYTE6B6C
9983	.edee		98		tya		                tya
9986							                .endif
9987	.edef		0c 34 fe	tsb $fe34	                tsb ACCCON                   ; Page in shadow RAM
9988	.edf2						LEEB0:
9989	.edf2		60		rts		                rts                          ; X preserved, Y=&04 or &20

9991							;-------------------------------------------------------------------------

9993							osword06Macro: .macro
10000							                .endmacro

10002							LEF1BMacro: .macro
10014							                .endmacro

10016							;-------------------------------------------------------------------------

10018							                .if version>=350
10019	.edf3						osword06:
9994	.edf3		20 c5 ee	jsr $eec5	                jsr getAddressFromOSWORDParameterBlock
9995	.edf6		b1 f0		lda ($f0),y	                lda (originalX),y
9996	.edf8		92 fa		sta ($fa)	                sta (SEIWKA)
9997	.edfa						ret:
9998	.edfa		a9 00		lda #$00	                lda #$00
9999	.edfc		60		rts		                rts
10020	.edfd						LEF1B:
10003	.edfd		a5 eb		lda $eb		                lda $EB
10004	.edff		30 f9		bmi $edfa	                bmi osword06.ret
10005	.ee01		ad 57 02	lda $0257	                lda spoolFileHandle
10006	.ee04		d0 f4		bne $edfa	                bne osword06.ret
10007	.ee06		a9 08		lda #$08	                lda #$08
10008	.ee08		25 e2		and $e2		                and $E2
10009	.ee0a		d0 04		bne $ee10	                bne LEF2E
10010	.ee0c		a9 88		lda #$88	                lda #$88
10011	.ee0e		25 bb		and $bb		                and $BB
10012	.ee10						LEF2E:
10013	.ee10		60		rts		                rts
10021							                .endif

10023							;-------------------------------------------------------------------------

10025							                .if version>=500
10055							                .endif

10057							;-------------------------------------------------------------------------

10059							                .if version>=350
10060	.ee11						selectTerminalROMAndOSWORD0E:
10061	.ee11		c9 03		cmp #$03	                cmp #3
10062	.ee13		b0 76		bcs $ee8b	                bcs handleUnrecognisedOSWORD
10063	.ee15		20 16 f3	jsr $f316	                jsr withTerminalROM
10064	.ee18		4c 97 95	jmp $9597	                jmp osword0E
10065							                .endif

10067							;-------------------------------------------------------------------------

10069							                .if version>=500||version==350
10070	.ee1b						LEF85:
10071	.ee1b		28		plp		                plp
10072	.ee1c		68		pla		                pla
10073	.ee1d		2c 5e e3	bit $e35e	                bit valueFF
10074	.ee20		60		rts		                rts
10075							                .endif

10077							;-------------------------------------------------------------------------


10080							; OSBYTE
10081							; ======
10082	.ee21						osbyteEntryPoint:
10083	.ee21		48		pha		                pha
10084	.ee22		08		php		                php
10085	.ee23		78		sei		                sei
10086	.ee24		85 ef		sta $ef		                sta originalA
10087	.ee26		86 f0		stx $f0		                stx originalX
10088	.ee28		84 f1		sty $f1		                sty originalY
10089	.ee2a		a2 07		ldx #$07	                ldx #romServiceCallUnrecognisedOSBYTE
10090	.ee2c		c9 6b		cmp #$6b	                cmp #$6B
10091	.ee2e		90 4b		bcc $ee7b	                bcc osbyte00To6A
10092	.ee30		c9 a6		cmp #$a6	                cmp #$A6
10093	.ee32		90 09		bcc $ee3d	                bcc osbyte6BToA5
10094	.ee34		c9 a6		cmp #$a6	                cmp #$A6
10095	.ee36		90 57		bcc $ee8f	                bcc handleUnrecognisedOSBYTEOrOSWORD       ;??? - wait... didn't we just do this?

10097	.ee38						osbyteA6ToFF:
10098	.ee38		18		clc		                clc
10099	.ee39						osbyteOrUSERV:      ;call OSBYTE A6+ routine if C=0; call USERV if C=1
10100	.ee39		a9 a6		lda #$a6	                lda #$A6
10101	.ee3b		69 00		adc #$00	                adc #$00
10102							                .if version<350
10105							                .elsif version>=350
10106	.ee3d						osbyte6BToA5:
10107							                ; map $6b-$a5 to $46-$80
10108	.ee3d		e9 24		sbc #$24	                sbc #$24
10109	.ee3f						osbyte44To45:
10110							                ; map $44-$80 $1a-$56
10111	.ee3f		e9 2a		sbc #$2a	                sbc #$2A
10112							                .endif
10113	.ee41						osbyteUseTable:
10114	.ee41		0a		asl a		                asl a           ;table is of words
10115	.ee42		38		sec		                sec
10116	.ee43						callOSBYTEOrOSWORDFromTable:
10117	.ee43		84 f1		sty $f1		                sty originalY
10118	.ee45		a8		tay		                tay             ;get table offset in Y
10119	.ee46		2c 5e 02	bit $025e	                bit econetInterceptionStatus
10120	.ee49		10 07		bpl $ee52	                bpl LEEE0             ;taken if no Econet interception
10121	.ee4b		8a		txa		                txa
10122							                .cerror (netOSBYTEAttempted!=romServiceCallUnrecognisedOSBYTE),"net/rom reason codes mismatch"
10123							                .cerror (netOSWORDAttempted!=romServiceCallUnrecognisedOSWORD),"net/rom reason codes mismatch"
10124	.ee4c		b8		clv		                clv
10125	.ee4d		20 fe ea	jsr $eafe	                jsr callNETV
10126	.ee50		70 23		bvs $ee75	                bvs LEEFA
10127	.ee52						LEEE0:
10128							                .if version>=500
10132							                .elsif version==350
10133	.ee52		a6 f4		ldx $f4		                ldx $f4
10134	.ee54		20 5a e5	jsr $e55a	                jsr selectTerminalROM
10135							                .endif
10136							                .if version==350
10137	.ee57		b9 b9 8d	lda $8db9,y	                lda osbyteAndOSWORDRoutineTable,y
10138	.ee5a		85 fa		sta $fa		                sta SEIWKA
10139	.ee5c		b9 ba 8d	lda $8dba,y	                lda osbyteAndOSWORDRoutineTable+1,y
10140	.ee5f		85 fb		sta $fb		                sta SEIWKB
10146							                .endif
10147							                .if version>=500
10150							                .elsif version==350
10151	.ee61		20 4b e5	jsr $e54b	                jsr selectROMX
10152	.ee64		29 40		and #$40	                and #$40
10153	.ee66		aa		tax		                tax
10154							                .endif
10155	.ee67		a5 ef		lda $ef		                lda originalA
10156	.ee69		a4 f1		ldy $f1		                ldy originalY
10157	.ee6b		b0 04		bcs $ee71	                bcs +
10158	.ee6d		a0 00		ldy #$00	                ldy #$00            ;??? - is this actually desirable?
10159	.ee6f		b2 f0		lda ($f0)	                lda ($F0)           ;fetch 0th byte of parameter block
10160	.ee71						+
10161	.ee71		38		sec		                sec
10162							                .if version==350
10163	.ee72		20 98 f1	jsr $f198	                jsr LF198
10170							                .endif
10171	.ee75						LEEFA:
10172	.ee75		6a		ror a		                ror a
10173	.ee76		28		plp		                plp
10174	.ee77		2a		rol a		                rol a
10175	.ee78		68		pla		                pla
10176	.ee79		b8		clv		                clv
10177	.ee7a		60		rts		                rts

10179	.ee7b						osbyte00To6A:
10180	.ee7b		a0 00		ldy #$00	                ldy #$00        ;Y=0 on entry for this lot
10181	.ee7d		c9 1a		cmp #$1a	                cmp #$1A        ;OSBYTE <=$19 is table-driven
10182	.ee7f		90 c0		bcc $ee41	                bcc osbyteUseTable ;taken if OSBYTE $00-$19
10183							                .if version>=350
10184	.ee81		c9 44		cmp #$44	                cmp #$44
10185	.ee83		f0 ba		beq $ee3f	                beq osbyte44To45
10186	.ee85		c9 45		cmp #$45	                cmp #$45
10187	.ee87		f0 b6		beq $ee3f	                beq osbyte44To45
10188							                .endif
10189	.ee89		80 04		bra $ee8f	                bra handleUnrecognisedOSBYTEOrOSWORD

10191	.ee8b						handleUnrecognisedOSWORD:
10192	.ee8b		a2 08		ldx #$08	                ldx #romServiceCallUnrecognisedOSWORD
10193	.ee8d		68		pla		                pla
10194	.ee8e		68		pla		                pla
10195	.ee8f						handleUnrecognisedOSBYTEOrOSWORD:
10196	.ee8f		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
10197							                .if version<500&&version!=350
10199							                .else
10200	.ee92		d0 87		bne $ee1b	                bne LEF85
10201							                .endif
10202	.ee94		a6 f0		ldx $f0		                ldx originalX
10203	.ee96		80 dd		bra $ee75	                bra LEEFA
10204							                .if version<500&&version!=350
10210							                .endif

10212							;-------------------------------------------------------------------------

10214							                .if version<350
10216							                .endif

10218							;-------------------------------------------------------------------------
10219							;
10220							; OSWORD 14 (&0E) Read CMOS clock [MasRef D.3-22]
10221							;
10222							                .if version<350
10228							                .endif

10230							;-------------------------------------------------------------------------
10231							;
10232							; Entry point for OSWORD.
10233							;
10234							; D.3-3
10235							;
10236							                .if version<500
10237	.ee98						oswordEntryPoint:
10238	.ee98		48		pha		                pha             ;save OSWORD request
10239	.ee99		08		php		                php
10240	.ee9a		78		sei		                sei
10241	.ee9b		85 ef		sta $ef		                sta originalA
10242	.ee9d		86 f0		stx $f0		                stx originalX
10243	.ee9f		84 f1		sty $f1		                sty originalY
10244	.eea1		a2 08		ldx #$08	                ldx #romServiceCallUnrecognisedOSWORD
10245	.eea3		c9 e0		cmp #$e0	                cmp #$E0
10246	.eea5		b0 92		bcs $ee39	                bcs osbyteOrUSERV ;taken if OSWORD $E0 or higher -
10247							                                  ;these go via USERV

10249							                .if version==320
10260							                .else

10262	.eea7		c9 10		cmp #$10	                cmp #$10
10263	.eea9		90 0d		bcc $eeb8	                bcc osword00To0F
10264	.eeab		c9 44		cmp #$44	                cmp #$44
10265	.eead		b0 e0		bcs $ee8f	                bcs handleUnrecognisedOSBYTEOrOSWORD
10266	.eeaf		c9 42		cmp #$42	                cmp #$42
10267	.eeb1		b0 03		bcs $eeb6	                bcs osword42To43
10268	.eeb3		38		sec		                sec
10269	.eeb4		80 d9		bra $ee8f	                bra handleUnrecognisedOSBYTEOrOSWORD

10271	.eeb6						osword42To43:
10272							                .cerror (osword42AndAboveRoutineTable-oswordRoutineTable)%2!=0
10273	.eeb6		e9 33		sbc #$33	                sbc #$42-((osword42AndAboveRoutineTable-oswordRoutineTable)/2-1)
10274	.eeb8						osword00To0F:
10275							                .cerror (oswordRoutineTable-osbyteAndOSWORDRoutineTable)%2!=0
10276	.eeb8		69 59		adc #$59	                adc #(oswordRoutineTable-osbyteAndOSWORDRoutineTable)/2
10277	.eeba		0a		asl a		                asl a
10278	.eebb		80 86		bra $ee43	                bra callOSBYTEOrOSWORDFromTable
10279							                .endif
10280							                .endif

10282							;-------------------------------------------------------------------------
10283							;
10284							; OSWORD 5 (&05) Read byte from I/O processor memory [MasRef D.3-9]
10285							;
10286	.eebd						osword05:
10287	.eebd		20 c5 ee	jsr $eec5	                jsr getAddressFromOSWORDParameterBlock
10288	.eec0		b2 fa		lda ($fa)	                lda (SEIWKA)                 ;read byte from the address
10289	.eec2		91 f0		sta ($f0),y	                sta (originalX),y                  ;update parameter block
10290	.eec4		60		rts		                rts

10292							;-------------------------------------------------------------------------
10293							;
10294							; OSWORD 6 (&06) Write byte to I/O processor memory [MasRef D.3-9]
10295							;

10297							                .if version<350
10299							                .endif

10301							;-------------------------------------------------------------------------
10302							;
10303							; Get address from OSWORD parameter block.
10304							;
10305							; entry:
10306							;
10307							; A = 0th byte of parameter block
10308							;
10309							; Y = 0
10310							;
10311							; (originalX) = parameter block
10312							;
10313							; exit:
10314							;
10315							; (SEIWKA) = address, first two bytes from parameter block
10316							;
10317							; Y = 4 (this is just convenient for both callers)
10318							;
10319	.eec5						getAddressFromOSWORDParameterBlock:
10320	.eec5		85 fa		sta $fa		                sta SEIWKA
10321	.eec7		c8		iny		                iny
10322	.eec8		b1 f0		lda ($f0),y	                lda (originalX),y
10323	.eeca		85 fb		sta $fb		                sta SEIWKA+1
10324	.eecc		a0 04		ldy #$04	                ldy #$04
10325	.eece						ldxim03_rts:
10326							                .if version<400
10327	.eece		a2 03		ldx #$03	                ldx #$03
10332							                .endif
10333	.eed0		60		rts		                rts

10335							;-------------------------------------------------------------------------
10336							;
10337							; OSBYTE 0 (&00) Display MOS version
10338							;
10339							; OSBYTE 0 has the effect of performing a BRK instruction and
10340							; displaying the MOS version number.
10341							;
10342							; Entry parameters :
10343							;
10344							; X=0 executes a BRK and displays the OS version
10345							;
10346							; X=1 executes an RTS and returns the Operating system version
10347							;
10348							; On exit : X=<OS version>
10349							;
10350							; D.2-18
10351							;
10352	.eed1						osbyte00:                       ;ef6f
10353	.eed1		d0 fb		bne $eece	                bne ldxim03_rts ;branch taken if X<>0 - return with
10354							                                 ;X=3

10356							; do a BRK and print MOS version number.

10358	.eed3		00		brk #		                brk
10359	>eed4		f7 4d 4f 53 20 33 2e 35		                .text $f7,versionString,0
	>eedc		30 00

10361							;-------------------------------------------------------------------------
10362							;
10363							; OSWORD 7 (&07) Generate a sound [MasRef D.3-10]
10364							;
10365	.eede						osword07:
10366	.eede		c8		iny		                iny
10367	.eedf		b1 f0		lda ($f0),y	                lda ($F0),y
10368	.eee1		c9 20		cmp #$20	                cmp #$20
10369	.eee3		b0 a6		bcs $ee8b	                bcs handleUnrecognisedOSWORD
10370	.eee5		88		dey		                dey
10371	.eee6		20 59 ef	jsr $ef59	                jsr LEFF6
10372	.eee9		09 04		ora #$04	                ora #$04
10373	.eeeb		aa		tax		                tax
10374	.eeec		90 05		bcc $eef3	                bcc LEF90
10375	.eeee		20 24 e9	jsr $e924	                jsr LE95A
10376	.eef1		a0 01		ldy #$01	                ldy #$01
10377	.eef3						LEF90:
10378	.eef3		20 59 ef	jsr $ef59	                jsr LEFF6
10379	.eef6		85 fa		sta $fa		                sta $FA
10380	.eef8		08		php		                php
10381	.eef9		a0 06		ldy #$06	                ldy #$06
10382	.eefb		b1 f0		lda ($f0),y	                lda ($F0),y
10383	.eefd		48		pha		                pha
10384	.eefe		a0 04		ldy #$04	                ldy #$04
10385	.ef00		b1 f0		lda ($f0),y	                lda ($F0),y
10386	.ef02		48		pha		                pha
10387	.ef03		a0 02		ldy #$02	                ldy #$02
10388	.ef05		b1 f0		lda ($f0),y	                lda ($F0),y
10389	.ef07		2a		rol a		                rol a
10390	.ef08		3a		dec a		                dec a
10391	.ef09		3a		dec a		                dec a
10392	.ef0a		0a		asl a		                asl a
10393	.ef0b		0a		asl a		                asl a
10394	.ef0c		05 fa		ora $fa		                ora $FA
10395	.ef0e		20 6d e9	jsr $e96d	                jsr LE9A3
10396	.ef11		90 1e		bcc $ef31	                bcc LEFCE
10397	.ef13		68		pla		                pla
10398	.ef14		68		pla		                pla
10399	.ef15		28		plp		                plp

10401							                ; WTF... fall through to OSBYTE $75!

10403							;-------------------------------------------------------------------------
10404							;
10405							; OSBYTE 117 (&75) Read VDU status [MasRef D.2-32]
10406							;
10407	.ef16						osbyte75:
10408	.ef16		a6 d0		ldx $d0		                ldx STATE
10409	.ef18		60		rts		                rts

10411							;-------------------------------------------------------------------------
10412							;
10413							; VDU 7 (&07) Produce BELL sound [MasRef E.3-4]
10414							;
10415	.ef19						vdu7EntryPoint:
10416	.ef19		08		php		                php
10417	.ef1a		78		sei		                sei
10418	.ef1b		ad 63 02	lda $0263	                lda bellChannel
10419	.ef1e		29 07		and #$07	                and #$07
10420	.ef20		09 04		ora #$04	                ora #$04
10421	.ef22		aa		tax		                tax
10422	.ef23		ad 64 02	lda $0264	                lda bellSound
10423	.ef26		20 04 ea	jsr $ea04	                jsr callINSV
10424	.ef29		ad 66 02	lda $0266	                lda bellDuration
10425	.ef2c		48		pha		                pha
10426	.ef2d		ad 65 02	lda $0265	                lda bellFrequency
10427	.ef30		48		pha		                pha
10428	.ef31						LEFCE:
10429	.ef31		38		sec		                sec
10430	.ef32		7e 00 08	ror $0800,x	                ror $0800,x
10431	.ef35		68		pla		                pla
10432	.ef36		20 04 ea	jsr $ea04	                jsr callINSV
10433	.ef39		68		pla		                pla
10434	.ef3a		20 04 ea	jsr $ea04	                jsr callINSV
10435	.ef3d		28		plp		                plp
10436	.ef3e		60		rts		                rts

10438							;-------------------------------------------------------------------------
10439							;
10440							; OSWORD 8 (&08) Define a sound envelope [MasRef D.3-14]
10441							;
10442	.ef3f						osword08:
10443	.ef3f		3a		dec a		                dec a                   ;get index of 1-based envelope
10444	.ef40		0a		asl a		                asl a
10445	.ef41		0a		asl a		                asl a
10446	.ef42		0a		asl a		                asl a
10447	.ef43		0a		asl a		                asl a                        ;index*16
10448	.ef44		09 0f		ora #$0f	                ora #$0F                     ;index*16+15
10449	.ef46		aa		tax		                tax                          ;
10450	.ef47		a9 00		lda #$00	                lda #$00                     ;
10451	.ef49		a0 10		ldy #$10	                ldy #16             ;16 bytes of envelope data get set
10452	.ef4b						-
10453	.ef4b		c0 0e		cpy #$0e	                cpy #$0E                     ;
10454	.ef4d		b0 02		bcs $ef51	                bcs + ;taken if last 2 bytes of data - they get initialized to $00
10455	.ef4f		b1 f0		lda ($f0),y	                lda (originalX),y        ;fetch byte from OSWORD block
10456	.ef51						+
10457	.ef51		9d c0 08	sta $08c0,x	                sta envelope1Data,x          ;set envelope data bytes
10458	.ef54		ca		dex		                dex
10459	.ef55		88		dey		                dey
10460	.ef56		d0 f3		bne $ef4b	                bne -
10461	.ef58		60		rts		                rts

10463							;-------------------------------------------------------------------------

10465	.ef59						LEFF6:
10466	.ef59		b1 f0		lda ($f0),y	                lda ($F0),y
10467	.ef5b		c9 10		cmp #$10	                cmp #$10
10468	.ef5d		29 03		and #$03	                and #$03
10469	.ef5f		c8		iny		                iny
10470	.ef60		60		rts		                rts

10472							;-------------------------------------------------------------------------
10473							;
10474							; OSWORD 3 (&03) Read interval timer [MasRef D.3-8]
10475							;
10476	.ef61						osword03:
10477	.ef61		a2 0f		ldx #$0f	                ldx #$0F
10478	.ef63		80 03		bra $ef68	                bra LF005

10480							;-------------------------------------------------------------------------
10481							;
10482							; OSWORD 1 (&01) Read system clock [MasRef D.3-7]
10483							;
10484	.ef65						osword01:
10485	.ef65		ae 83 02	ldx $0283	                ldx timerSwitchState
10486	.ef68						LF005:
10487	.ef68		a0 04		ldy #$04	                ldy #$04
10488	.ef6a						-
10489	.ef6a		bd 8d 02	lda $028d,x	                lda timer0-initialTimerSwitchState,x
10490	.ef6d		91 f0		sta ($f0),y	                sta (originalX),y
10491	.ef6f		e8		inx		                inx
10492	.ef70		88		dey		                dey
10493	.ef71		10 f7		bpl $ef6a	                bpl -
10494	.ef73						rtsF010:
10495	.ef73		60		rts		                rts

10497							;-------------------------------------------------------------------------
10498							;
10499							; OSWORD 4 (&04) Write interval timer [MasRef D.3-9]
10500							;
10501	.ef74						osword04:
10502	.ef74		a9 0f		lda #$0f	                lda #intervalTimer-(timer0-initialTimerSwitchState)
10503	.ef76		80 06		bra $ef7e	                bra copyTIMEValue

10505							;-------------------------------------------------------------------------
10506							;
10507							; OSWORD 2 (&02) Write system clock [MasRef D.3-8]
10508							;
10509	.ef78						osword02:
10510	.ef78		ad 83 02	lda $0283	                lda timerSwitchState
10511	.ef7b		49 0f		eor #$0f	                eor #$0F       ;select the timer that isn't being used
10512	.ef7d		18		clc		                clc
10513	.ef7e						copyTIMEValue:
10514	.ef7e		48		pha		                pha
10515	.ef7f		aa		tax		                tax
10516	.ef80		a0 04		ldy #$04	                ldy #$04
10517	.ef82						-
10518	.ef82		b1 f0		lda ($f0),y	                lda (originalX),y
10519	.ef84		9d 8d 02	sta $028d,x	                sta timer0-initialTimerSwitchState,x
10520	.ef87		e8		inx		                inx
10521	.ef88		88		dey		                dey
10522	.ef89		10 f7		bpl $ef82	                bpl -
10523	.ef8b		68		pla		                pla
10524	.ef8c		b0 e5		bcs $ef73	                bcs rtsF010
10525	.ef8e		8d 83 02	sta $0283	                sta timerSwitchState
10526	.ef91		60		rts		                rts

10528							;-------------------------------------------------------------------------
10529							;
10530							; OSWORD 0 (&00) Read line from input stream to memory [MasRef D.3-6]
10531							;
10532	.ef92						osword00:
10533	.ef92		a0 04		ldy #$04	                ldy #$04
10534	.ef94						LF031:
10535	.ef94		b1 f0		lda ($f0),y	                lda (originalX),y
10536							                .cerror osword0MaxLineLength+1!=osword0MinASCIICharacter
10537							                .cerror osword0MinASCIICharacter+1!=osword0MaxASCIICharacter
10538	.ef96		99 b1 02	sta $02b1,y	                sta osword0MaxLineLength-2,y
10539	.ef99		88		dey		                dey
10540	.ef9a		c0 02		cpy #$02	                cpy #$02
10541	.ef9c		b0 f6		bcs $ef94	                bcs LF031
10542	.ef9e		b1 f0		lda ($f0),y	                lda ($F0),y
10543	.efa0		85 e9		sta $e9		                sta $E9
10544	.efa2		88		dey		                dey
10545	.efa3		9c 69 02	stz $0269	                stz pagedModeCounter
10546	.efa6		b2 f0		lda ($f0)	                lda ($F0)
10547	.efa8		85 e8		sta $e8		                sta $E8
10548	.efaa		58		cli		                cli
10549	.efab		80 07		bra $efb4	                bra LF051

10551	.efad						LF04A:
10552	.efad		a9 07		lda #$07	                lda #$07
10553	.efaf						LF04C:
10554	.efaf		88		dey		                dey
10555	.efb0						LF04D:
10556	.efb0		c8		iny		                iny
10557	.efb1						LF04E:
10558	.efb1		20 ee ff	jsr $ffee	                jsr OSWRCH
10559	.efb4						LF051:
10560	.efb4		20 e0 ff	jsr $ffe0	                jsr OSRDCH
10561	.efb7		b0 49		bcs $f002	                bcs LF09F
10562	.efb9		aa		tax		                tax
10563	.efba		ad 7c 02	lda $027c	                lda characterDestinationStatus
10564	.efbd		6a		ror a		                ror a
10565	.efbe		6a		ror a		                ror a
10566	.efbf		8a		txa		                txa
10567	.efc0		b0 05		bcs $efc7	                bcs LF064
10568	.efc2		ae 6a 02	ldx $026a	                ldx vduQueueNegativeLength
10569	.efc5		d0 ea		bne $efb1	                bne LF04E
10570	.efc7						LF064:
10571	.efc7		c9 7f		cmp #$7f	                cmp #$7F
10572	.efc9		d0 07		bne $efd2	                bne LF06F
10573	.efcb		c0 00		cpy #$00	                cpy #$00
10574	.efcd		f0 e5		beq $efb4	                beq LF051
10575	.efcf		88		dey		                dey
10576	.efd0		80 df		bra $efb1	                bra LF04E

10578	.efd2						LF06F:
10579	.efd2		c9 15		cmp #$15	                cmp #$15
10580	.efd4		d0 0d		bne $efe3	                bne LF080
10581	.efd6		98		tya		                tya
10582	.efd7		f0 db		beq $efb4	                beq LF051
10583	.efd9		a9 7f		lda #$7f	                lda #$7F
10584	.efdb						LF078:
10585	.efdb		20 ee ff	jsr $ffee	                jsr OSWRCH
10586	.efde		88		dey		                dey
10587	.efdf		d0 fa		bne $efdb	                bne LF078
10588	.efe1		80 d1		bra $efb4	                bra LF051

10590	.efe3						LF080:
10591	.efe3		91 e8		sta ($e8),y	                sta ($E8),y
10592	.efe5		c9 0d		cmp #$0d	                cmp #$0D
10593	.efe7		f0 13		beq $effc	                beq LF099
10594	.efe9		cc b3 02	cpy $02b3	                cpy osword0MaxLineLength
10595	.efec		b0 bf		bcs $efad	                bcs LF04A
10596	.efee		cd b4 02	cmp $02b4	                cmp osword0MinASCIICharacter
10597	.eff1		90 bc		bcc $efaf	                bcc LF04C
10598	.eff3		cd b5 02	cmp $02b5	                cmp osword0MaxASCIICharacter
10599	.eff6		f0 b8		beq $efb0	                beq LF04D
10600	.eff8		90 b6		bcc $efb0	                bcc LF04D
10601	.effa		80 b3		bra $efaf	                bra LF04C

10603	.effc						LF099:
10604	.effc		20 e7 ff	jsr $ffe7	                jsr OSNEWL
10605	.efff		20 fe ea	jsr $eafe	                jsr callNETV
10606	.f002						LF09F:
10607	.f002		a5 ff		lda $ff		                lda $FF
10608	.f004		2a		rol a		                rol a
10609	.f005		60		rts		                rts

10611							;-------------------------------------------------------------------------
10612							;
10613							; OSBYTE 3 (&03) Specify output stream [MasRef D.2-19]
10614							;
10615	.f006						osbyte03:
10616	.f006		da		phx		                phx
10617	.f007		ae 7c 02	ldx $027c	                ldx characterDestinationStatus
10618	.f00a		a9 0a		lda #$0a	                lda #printerDriverFX3
10619	.f00c		20 06 e9	jsr $e906	                jsr callPrinterDriver
10620	.f00f		fa		plx		                plx
10621	.f010		a9 03		lda #$03	                lda #$03
10622	.f012		a0 00		ldy #$00	                ldy #$00
10623	.f014		80 23		bra $f039	                bra osbyte04

10625							;-------------------------------------------------------------------------
10626							;
10627							; OSBYTE 6 (&06) Write printer ignore character [MasRef D.2-21]
10628							;
10629	.f016						osbyte06:                       ;f0b3
10630	.f016		4e 46 02	lsr $0246	                lsr noignoreState
10631	.f019		80 16		bra $f031	                bra osbyte01

10633							;-------------------------------------------------------------------------
10634							;
10635							; OSBYTE 114 (&72) Write usage of shadow memory [MasRef D.2-32]
10636							;
10637	.f01b						osbyte72:                       ;f0b8
10638	.f01b		a9 1f		lda #$1f	                lda #$1F
10639	.f01d		80 10		bra $f02f	                bra LF0CC

10641							;-------------------------------------------------------------------------
10642							;
10643							; OSBYTE 5 (&05) Write printer driver type [MasRef D.2-20]
10644							;
10645	.f01f						osbyte05:
10646	.f01f						waitForPrinterDriverDormant:
10647	.f01f		58		cli		                cli
10648	.f020		78		sei		                sei
10649	.f021		24 ff		bit $ff		                bit $FF                      ;test for ESCAPE
10650	.f023		30 29		bmi $f04e	                bmi rtsF0EB                  ;taken if ESCAPE pressed
10651	.f025		2c d1 02	bit $02d1	                bit bufferEmptyFlags+bufferPrinter
10652	.f028		10 f5		bpl $f01f	                bpl waitForPrinterDriverDormant ;taken if printer driver active
10653	.f02a		20 06 e9	jsr $e906	                jsr callPrinterDriver    ;call with A=printerDriverFX5
10654	.f02d		a0 00		ldy #$00	                ldy #$00
10655	.f02f						LF0CC:
10656	.f02f		64 f1		stz $f1		                stz $F1

10658							                ; fall through to standard MOS variable handling,
10659							                ; affecting printerDriverType

10661							;-------------------------------------------------------------------------
10662							;
10663							; OSBYTE 1 (&01) Write user flag [MasRef D.2-18]
10664							;
10665	.f031						osbyte01:
10666	.f031		49 f0		eor #$f0	                eor #firstMOSVariableOSBYTE+(userFlag-mosVariables)-1 ;-1 because OSBYTE 1
10667	.f033		80 07		bra $f03c	                bra osbyteA6X  ;jump to standard MOS variable handling

10669							;-------------------------------------------------------------------------
10670							;
10671							; OSBYTE 12 (&0C) Write keyboard auto-repeat rate [MasRef D.2-23]
10672							;
10673	.f035						osbyte0C:
10674	.f035		f0 36		beq $f06d	                beq resetKeyRepeat    ;taken if X=0

10676							;-------------------------------------------------------------------------
10677							;
10678							; OSBYTE 11 (&0B) Write keyboard auto-repeat delay [MasRef D.2-22]
10679							;
10680	.f037						osbyte0B:
10681							                ; TODO - turn this constant into an expression
10682	.f037		69 cf		adc #$cf	                adc #$CF

10684							                ;if osbyte0C, A=$db
10685							                ;if osbyteOD, A=$dc

10687							;-------------------------------------------------------------------------
10688							;
10689							; OSBYTE 4 (&04) Enable/disable cursor editing [MasRef D.2-19]
10690							;
10691	.f039						osbyte04:
10692	.f039		18		clc		                clc
10693	.f03a		69 e9		adc #$e9	                adc #firstMOSVariableOSBYTE+(editKeysMode-mosVariables)-4 ;-4 because OSBYTE 4

10695							                ;if originally OSBYTE 4 (&04) Enable/disable cursor
10696							                ;editing [MasRef D.2-19], it's now OSBYTE 237 (&ED)
10697							                ;Read/write cursor editing status [MasRef D.2-77].
10698							                ;
10699							                ;if originally OSBYTE 12 (&0C) Write keyboard
10700							                ;auto-repeat rate [MasRef D.2-23], it's now OSBYTE 197
10701							                ;(&C5) Read/write keyboard auto-repeat rate [MasRef
10702							                ;D.2-60].
10703							                ;
10704							                ;if originally OSBYTE 11 (&0B) Write keyboard
10705							                ;auto-repeat delay [MasRef D.2-22], it's now OSBYTE
10706							                ;196 (&C4) Read/write keyboard auto-repeat delay
10707							                ;[MasRef D.2-60].

10709	.f03c						osbyteA6X:
10710	.f03c		86 f0		stx $f0		                stx originalX

10712							;-------------------------------------------------------------------------
10713							;
10714							; OSBYTE 166 (&A6) Read start address of MOS variables [MasRef D.2-50]
10715							;
10716	.f03e						osbyteA6:
10717	.f03e		a8		tay		                tay             ;
10718	.f03f		b9 90 01	lda $0190,y	                lda mosVariables-firstMOSVariableOSBYTE,y;
10719	.f042		aa		tax		                tax             ;save old value
10720	.f043		25 f1		and $f1		                and originalY   ;AND old value with Y
10721	.f045		45 f0		eor $f0		                eor originalX   ;EOR old value with X
10722	.f047		99 90 01	sta $0190,y	                sta mosVariables-firstMOSVariableOSBYTE,y     ;set new variable value
10723	.f04a		b9 91 01	lda $0191,y	                lda mosVariables-firstMOSVariableOSBYTE+1,y
10724	.f04d		a8		tay		                tay             ;Y=contents of next location
10725	.f04e						rtsF0EB:
10726	.f04e		60		rts		                rts

10728							;-------------------------------------------------------------------------
10729							;
10730							; This table is used to set the serial baud rate.
10731							;
10732							;   - bit 7 is not used (always clear)
10733							;   - bit 6 is not used (always set)
10734							;   - bits 3,4,5 indicate the serial receive baud rate
10735							;   - bits 0,1,2 indicate the serial transmit baud rate
10736							;
10737							;       111 =    75 baud
10738							;       011 =   150 baud
10739							;       101 =   300 baud
10740							;       001 =  1200 baud
10741							;       110 =  2400 baud
10742							;       010 =  4800 baud
10743							;       100 =  9600 baud
10744							;       000 = 19200 baud
10745							;
10746							                .if version!=400
10747	.f04f						serialBaudRatesTable:
10748	>f04f		64				                .byte %01100100;$64
10749	>f050		7f				                .byte %01111111;$7f
10750	>f051		5b				                .byte %01011011;$5b
10751	>f052		6d				                .byte %01101101;$6d
10752	>f053		49				                .byte %01001001;$49
10753	>f054		76				                .byte %01110110;$76
10754	>f055		52				                .byte %01010010;$52
10755	>f056		64				                .byte %01100100;$64
10756	>f057		40				                .byte %01000000;$40
10757							                .endif

10759							;-------------------------------------------------------------------------
10760							;
10761							; OSBYTE 19 (&13) Wait for vertical sync [MasRef D.2-26]
10762							;
10763	.f058						osbyte13:
10764	.f058		ad 40 02	lda $0240	                lda cfsTimeoutCounter
10765	.f05b						-
10766	.f05b		58		cli		                cli
10767	.f05c		78		sei		                sei
10768	.f05d		cd 40 02	cmp $0240	                cmp cfsTimeoutCounter
10769	.f060		f0 f9		beq $f05b	                beq -

10771							                ; fall through to OSBYTE $a0 (!!)

10773							;-------------------------------------------------------------------------
10774							;
10775							; OSBYTE 160 (&A0) Read VDU variable value [MasRef D.2-49]
10776							;
10777	.f062						osbyteA0:
10778	.f062		bc 01 03	ldy $0301,x	                ldy vduv+1,x
10779	.f065		bd 00 03	lda $0300,x	                lda vduv+0,x
10780	.f068		aa		tax		                tax
10781	.f069		60		rts		                rts

10783							;-------------------------------------------------------------------------
10784							;
10785							; Reset key auto repeat settings to the defaults set in CMOS.
10786							;
10787							                .if version==350
10788	.f06a						clearTSTAndResetKeyRepeat:
10789	.f06a		20 5c f3	jsr $f35c	                jsr withTSTClear
10790							                .endif
10791	.f06d						resetKeyRepeat:
10792	.f06d		20 16 f3	jsr $f316	                jsr withTerminalROM
10793							                .if useTableDrivenConfigure
10794	.f070		a2 1a		ldx #$1a	                ldx #CMOSBytes.keyboardAutoRepeatDelay+cmosBytesOffset
10795	.f072		20 a3 96	jsr $96a3	                jsr readRTCByte
10796	.f075		8d 54 02	sta $0254	                sta keyboardAutoRepeatDelay
10797	.f078		a2 1b		ldx #$1b	                ldx #CMOSBytes.keyboardAutoRepeatRate+cmosBytesOffset
10798	.f07a		20 a3 96	jsr $96a3	                jsr readRTCByte
10799	.f07d		a8		tay		                tay
10804							                .endif
10805	.f07e		ae 55 02	ldx $0255	                ldx keyboardAutoRepeatRate
10806	.f081		8c 55 02	sty $0255	                sty keyboardAutoRepeatRate
10807	.f084		60		rts		                rts

10809							;-------------------------------------------------------------------------
10810							;
10811							; OSBYTE 18 (&12) Reset soft keys [MasRef D.2-26]
10812							;
10813							; MasRef says X undefined on exit; in fact, X=0, and scanROMs
10814							; relies on this.
10815							;
10816	.f085						osbyte12:
10817	.f085		38		sec		                sec
10818	.f086		6e 84 02	ror $0284	                ror softKeyConsistencyFlag   ;mark soft keys inconsistent
10819	.f089		a5 f4		lda $f4		                lda $F4
10820	.f08b		48		pha		                pha                          ;push selected paged ROM
10821	.f08c		20 49 e5	jsr $e549	                jsr selectTerminalROMAndANDY

10823							                ; point each soft key at the 0th byte of the strings -
10824							                ; they all then have length 0.
10825	.f08f		a2 10		ldx #$10	                ldx #softKeyCount
10826	.f091						-
10827	.f091		a9 22		lda #$22	                lda #<andy.softKeys.strings
10828	.f093		9d 00 80	sta $8000,x	                sta andy.softKeys.stringLSBs,x
10829	.f096		a9 80		lda #$80	                lda #>andy.softKeys.strings
10830	.f098		9d 11 80	sta $8011,x	                sta andy.softKeys.stringMSBs,x
10831	.f09b		ca		dex		                dex
10832	.f09c		10 f3		bpl $f091	                bpl -

10834	.f09e		68		pla		                pla                 ;pop previously selected paged ROM
10835	.f09f		20 5c e5	jsr $e55c	                jsr selectROMA

10837	.f0a2		9c 68 02	stz $0268	                stz softKeyStringLength
10838	.f0a5		9c 84 02	stz $0284	                stz softKeyConsistencyFlag   ;mark soft keys consistent
10839	.f0a8		e8		inx		                inx
10840	.f0a9		60		rts		                rts

10842							;-------------------------------------------------------------------------
10843							;
10844							; OSWORD 11 (&0B) Read the palette [MasRef D.3-20]
10845							;
10846	.f0aa						osword0B:
10847	.f0aa		2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne
10848	.f0ad		aa		tax		                tax
10849	.f0ae		bd 6f 03	lda $036f,x	                lda vduv.currentPalette,x
10850	.f0b1						LF146:
10851	.f0b1		c8		iny		                iny
10852	.f0b2						LF147:
10853	.f0b2		91 f0		sta ($f0),y	                sta (originalX),y
10854	.f0b4		a9 00		lda #$00	                lda #$00                     ;fill last 3 bytes with 0
10855	.f0b6		c0 04		cpy #$04	                cpy #$04
10856	.f0b8		d0 f7		bne $f0b1	                bne LF146
10857	.f0ba		60		rts		                rts

10859							;-------------------------------------------------------------------------
10860							;
10861							; OSWORD 9 (&09) Read pixel logical colour [MasRef D.3-19]
10862							;
10863	.f0bb						osword09:                                    ;f150
10864	.f0bb		20 2d f3	jsr $f32d	                jsr withMOSROM               ; sF150= 20 AB F3     +s
10865	.f0be		a0 03		ldy #$03	                ldy #$03
10866	.f0c0						-
10867	.f0c0		b1 f0		lda ($f0),y	                lda (originalX),y
10868	.f0c2		99 28 03	sta $0328,y	                sta vduv.workspace._28,y
10869	.f0c5		b9 10 03	lda $0310,y	                lda $0310,y
10870	.f0c8		48		pha		                pha
10871	.f0c9		88		dey		                dey
10872	.f0ca		10 f4		bpl $f0c0	                bpl -
10873	.f0cc		a9 28		lda #$28	                lda #VDUVariables.workspace._28
10874	.f0ce		20 b6 dd	jsr $ddb6	                jsr readPixelColour
10875	.f0d1		aa		tax		                tax
10876	.f0d2		a0 00		ldy #$00	                ldy #$00
10877	.f0d4						LF169:
10878	.f0d4		68		pla		                pla
10879	.f0d5		99 10 03	sta $0310,y	                sta $0310,y
10880	.f0d8		c8		iny		                iny
10881	.f0d9		c0 04		cpy #$04	                cpy #$04
10882	.f0db		d0 f7		bne $f0d4	                bne LF169
10883	.f0dd		8a		txa		                txa
10884	.f0de		80 d2		bra $f0b2	                bra LF147

10886	.f0e0						osword0A:                                    ;f175
10887	.f0e0		20 2a e2	jsr $e22a	                jsr getSoftCharacterDefinitionAddress
10888	.f0e3		a0 00		ldy #$00	                ldy #$00
10889	.f0e5		a5 f4		lda $f4		                lda $F4
10890	.f0e7		48		pha		                pha
10891	.f0e8		20 49 e5	jsr $e549	                jsr selectTerminalROMAndANDY
10892	.f0eb						LF180:
10893	.f0eb		b1 de		lda ($de),y	                lda ($DE),y
10894	.f0ed		c8		iny		                iny
10895	.f0ee		91 f0		sta ($f0),y	                sta ($F0),y
10896	.f0f0		c0 08		cpy #$08	                cpy #$08
10897	.f0f2		d0 f7		bne $f0eb	                bne LF180
10898	.f0f4		fa		plx		                plx
10899	.f0f5		4c 4b e5	jmp $e54b	                jmp selectROMX

10901	.f0f8						osword0C:                                    ;f18d
10902	.f0f8		20 2d f3	jsr $f32d	                jsr withMOSROM
10903	.f0fb		08		php		                php
10904	.f0fc		2d 60 03	and $0360	                and $0360
10905	.f0ff		aa		tax		                tax
10906	.f100		c8		iny		                iny
10907	.f101		b1 f0		lda ($f0),y	                lda ($F0),y
10908	.f103		4c 38 c6	jmp $c638	                jmp LC639

10910	.f106						osword0D:                                    ;f19b
10911	.f106		20 2d f3	jsr $f32d	                jsr withMOSROM
10912	.f109		a9 03		lda #$03	                lda #$03
10913	.f10b		20 10 f1	jsr $f110	                jsr LF1A5
10914	.f10e		a9 07		lda #$07	                lda #$07
10915	.f110						LF1A5:
10916	.f110		48		pha		                pha
10917	.f111		20 b4 e2	jsr $e2b4	                jsr LE2B6
10918	.f114		20 de c4	jsr $c4de	                jsr LC4DF
10919	.f117		a2 03		ldx #$03	                ldx #$03
10920	.f119		68		pla		                pla
10921	.f11a		a8		tay		                tay
10922	.f11b						LF1B0:
10923	.f11b		bd 10 03	lda $0310,x	                lda $0310,x
10924	.f11e		91 f0		sta ($f0),y	                sta ($F0),y
10925	.f120		88		dey		                dey
10926	.f121		ca		dex		                dex
10927	.f122		10 f7		bpl $f11b	                bpl LF1B0
10928	.f124		60		rts		                rts

10930							; Read address of bottom of screen/top of user memory
10931							; ===================================================
10932	.f125						osbyte84:                     ;f1ba
10933	.f125		a5 d0		lda $d0		                lda STATE     ; Get VDU status
10934	.f127		89 10		bit #$10	                bit #STATE.isShadowMode ; If shadow screen, jump to return &8000
10935	.f129		d0 18		bne $f143	                bne LF1D8
10936	.f12b						LF1C0:
10937	.f12b		ad 55 03	lda $0355	                lda $0355                    ; Get current screen MODE

10939							; Return start of screen for non-shadow MODE in X
10940							; -----------------------------------------------
10941	.f12e						LF1C3:
10942	.f12e		29 07		and #$07	                and #$07
10943	.f130		a8		tay		                tay
10944	.f131		be 66 e1	ldx $e166,y	                ldx screenMODEGroupForMODE,y ; Get screen map for supplied MODE
10945	.f134		bd 7c e1	lda $e17c,x	                lda startScreenAddressHighByteForScreenMODEGroup,x ; Get address top byte for this screen map
10946	.f137						LF1CC:
10947	.f137		a2 00		ldx #$00	                ldx #$00                     ; Address=&xx00
10948	.f139		a8		tay		                tay
10949	.f13a		60		rts		                rts

10951							;-------------------------------------------------------------------------
10952							;
10953							; OSBYTE 133 (&85) Read top of user RAM for given mode [MasRef D.2-41]
10954							;
10955	.f13b						osbyte85:
10956	.f13b		8a		txa		                txa                          ; If MODE &80+n, return &8000
10957	.f13c		30 05		bmi $f143	                bmi LF1D8
10958	.f13e		ae 7f 02	ldx $027f	                ldx shadowRAMState ; If *SHADOW<>0, jump to return non-shadow address
10959	.f141		d0 eb		bne $f12e	                bne LF1C3
10960	.f143						LF1D8:
10961	.f143		a9 80		lda #$80	                lda #$80                     ; Return &8000
10962	.f145		80 f0		bra $f137	                bra LF1CC

10964							;-------------------------------------------------------------------------
10965							;
10966							; OSBYTE 135 (&87) Read screen mode and character at text cursor
10967							; position [MasRef D.2-42]
10968							;
10969	.f147						osbyte87: ;F1DC:
10970	.f147		20 2d f3	jsr $f32d	                jsr withMOSROM
10971	.f14a		4c f7 dd	jmp $ddf7	                jmp readCharacterAtTextCursor

10973							;-------------------------------------------------------------------------
10974							;
10975							; OSBYTE 139 (&8B) Write Filing System options [MasRef D.2-43]
10976							;
10977	.f14d						osbyte8B:
10978	.f14d		0a		asl a		                asl a

10980							;-------------------------------------------------------------------------
10981							;
10982							; OSBYTE 127 (&7F) Check for end of file on an opened file [MasRef D.2-37]
10983							;
10984	.f14e						osbyte7F:
10985	.f14e		29 01		and #$01	                and #$01

10987							;-------------------------------------------------------------------------
10988							;
10989							; Call OSFSC. There's no entry point for this.
10990							;
10991	.f150						callFSCV:
10992	.f150		6c 1e 02	jmp ($021e)	                jmp (FSCV)

10994							;-------------------------------------------------------------------------
10995							;
10996							; OSWORD 15 (&0F) Write CMOS clock [MasRef D.3-24]
10997							;
10998							                .if version!=350
11002							                .endif

11004							;-------------------------------------------------------------------------

11006							; Set TAPE/ROM extended vectors
11007							; =============================
11008	.f153						LF1EE:
11009	.f153		a2 15		ldx #$15	                ldx #$15
11010	.f155						LF1F0:
11011	.f155		bd 5e f1	lda $f15e,x	                lda LF1FA-1,x
11012	.f158		9d b9 0d	sta $0db9,x	                sta ExtendedVectorAddress(FILEV)-1,x
11013	.f15b		ca		dex		                dex
11014	.f15c		d0 f7		bne $f155	                bne LF1F0
11015	.f15e						LF1F9:
11016	.f15e		60		rts		                rts

11018							; TAPE/ROM extended vector values
11019							; -------------------------------
11020	.f15f						LF1FA:
11021	>f15f		a8 a0				                .word osfileTapeOrROM ; FILEV
11022	>f161		0f				                .byte terminalROM
11023	>f162		45 9f				                .word osargsTapeOrROM ; ARGSV
11024	>f164		0f				                .byte terminalROM
11025	>f165		06 a3				                .word bputTapeOrROM ; BPUTV
11026	>f167		0f				                .byte terminalROM
11027							                .if version==400
11029							                .else
11030	>f168		67 a3				                .word bgetTapeOrROM ; BGETV
11031							                .endif
11032	>f16a		0f				                .byte terminalROM
11033	>f16b		89 a3				                .word osgbpbTapeOrROM ; GBPBV
11034	>f16d		0f				                .byte terminalROM
11035	>f16e		15 a2				                .word osfindTapeOrROM ; FINDV
11036	>f170		0f				                .byte terminalROM
11037	>f171		a8 9f				                .word fscTapeOrROM  ; FSCV
11038	>f173		0f				                .byte terminalROM

11040							;-------------------------------------------------------------------------
11041							;
11042							; OSBYTE 109 (&6D) Make temporary Filing System permanent
11043							;
11044							; MasRef D.2-30
11045							;
11046	.f174						osbyte6D:;f20f
11047	.f174		ae 01 df	ldx $df01	                ldx hazel.activeFS; Copy active FS to current FS
11048	.f177		8e 00 df	stx $df00	                stx hazel.currentFS
11049	.f17a		ad bc 0d	lda $0dbc	                lda ExtendedVectorAddress(FILEV)+2 ; Copy XFILEV ROM to current FS ROM number
11050	.f17d		8d 03 df	sta $df03	                sta hazel.currentFSROM
11051	.f180						rtsF180:
11052	.f180		60		rts		                rts

11054							;-------------------------------------------------------------------------
11055							;
11056							; OSBYTE 20 (&14) Restore default font definitions
11057							;
11058							; MasRef D.2-24
11059							;
11060							                .if version!=350
11064							                .endif

11066							;-------------------------------------------------------------------------
11067							;
11068							; OSBYTE 25 (&19) Restore a group of font definitions
11069							;
11070							; MasRef D.2-28
11071							;
11072	.f181						selectTerminalROMAndOSBYTE19:                ;f222
11073							                .if version>=511||version==350
11074	.f181		a2 07		ldx #$07	                ldx #romServiceCallUnrecognisedOSBYTE
11075	.f183		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
11076							                .if version==350
11077	.f186		f0 f8		beq $f180	                beq rtsF180
11080							                .endif
11081	.f188		a6 f0		ldx $f0		                ldx originalX
11082							                .endif
11083	.f18a		20 16 f3	jsr $f316	                jsr withTerminalROM
11084	.f18d		4c 3c 97	jmp $973c	                jmp osbyte19

11086							;-------------------------------------------------------------------------

11088							; OSBYTE &16 - Increment ROM polling semaphore
11089							; ========================================
11090	.f190						osbyte16:                       ;f228
11091	.f190		ee 43 02	inc $0243	                inc romPollingSemaphore
11092	.f193						LF2EB:
11093	.f193		60		rts		                rts

11095							;-------------------------------------------------------------------------

11097							; OSBYTE &17 - Decrement ROM polling semaphore
11098	.f194						osbyte17:                       ;f22c
11099							; ========================================
11100	.f194		ce 43 02	dec $0243	                dec romPollingSemaphore
11101	.f197		60		rts		                rts

11103							;-------------------------------------------------------------------------

11105							                .if version==350
11106	.f198						LF198:
11107	.f198		ca		dex		                dex
11108	.f199		10 03		bpl $f19e	                bpl LF19E
11109	.f19b		20 16 f3	jsr $f316	                jsr withTerminalROM
11110	.f19e						LF19E:
11111	.f19e		a6 f0		ldx $f0		                ldx originalX
11112	.f1a0		6c fa 00	jmp ($00fa)	                jmp (SEIWKA)
11113							                .endif

11115							;-------------------------------------------------------------------------

11117							; OSBYTE &76 - Set LEDs to keyboard state
11118							; =======================================
11119	.f1a3						osbyte76:
11120	.f1a3		08		php		                php                          ; Disable IRQs
11121	.f1a4		78		sei		                sei
11122	.f1a5		a9 40		lda #$40	                lda #$40                     ; Turn on LEDs
11123	.f1a7		20 b4 f1	jsr $f1b4	                jsr LF241
11124	.f1aa		30 05		bmi $f1b1	                bmi LF23E                    ; Exit if Escape pending
11125	.f1ac		18		clc		                clc                          ; Call KEYV to read SHIFT and CTRL
11126	.f1ad		b8		clv		                clv
11127	.f1ae		20 20 f6	jsr $f620	                jsr callKEYV
11128							; Returns A.b7=CTRL, A.b6=SHIFT, MI=CTRL, VS=SHIFT
11129	.f1b1						LF23E:
11130	.f1b1		28		plp		                plp                          ; Restore IRQs
11131	.f1b2		2a		rol a		                rol a                        ; Set Carry from A bit 7 and return
11132	.f1b3		60		rts		                rts
11133							; Returns A.b7=SHIFT, CS=CTRL

11135							; Set keyboard LEDs
11136							; -----------------
11137	.f1b4						LF241:
11138	.f1b4		90 09		bcc $f1bf	                bcc LF24C                    ; Skip if not called from OSBYTE
11139	.f1b6		a0 07		ldy #$07	                ldy #$07                     ; Turn ShiftLock LED on
11140	.f1b8		8c 40 fe	sty $fe40	                sty systemVIA.orb
11141	.f1bb		88		dey		                dey                          ; Turn CapsLock LED on
11142	.f1bc		8c 40 fe	sty $fe40	                sty systemVIA.orb
11143	.f1bf						LF24C:
11144	.f1bf		24 ff		bit $ff		                bit $FF                      ; Test Escape and return
11145	.f1c1		60		rts		                rts

11147							;-------------------------------------------------------------------------

11149	.f1c2						osbyte9A:
11150	.f1c2		8a		txa		                txa
11151	.f1c3						setVCONTROL:
11152	.f1c3		08		php		                php
11153	.f1c4		78		sei		                sei
11154	.f1c5		8d 48 02	sta $0248	                sta vcontrolRegister
11155	.f1c8		8d 20 fe	sta $fe20	                sta VCONTROL
11156	.f1cb		ad 53 02	lda $0253	                lda secondFlashColourDuration
11157	.f1ce		8d 51 02	sta $0251	                sta flashCounter
11158	.f1d1		28		plp		                plp
11159	.f1d2		60		rts		                rts

11161							;-------------------------------------------------------------------------
11162							;
11163							; OSBYTE 155 (&9B) Write to video ULA palette register and copy
11164							;
11165	.f1d3						osbyte9B:
11166	.f1d3		8a		txa		                txa
11167	.f1d4						writeVPALETTE:
11168	.f1d4		49 07		eor #$07	                eor #$07
11169	.f1d6		08		php		                php
11170	.f1d7		78		sei		                sei
11171	.f1d8		8d 49 02	sta $0249	                sta vpaletteRegister
11172	.f1db		8d 21 fe	sta $fe21	                sta VPALETTE
11173	.f1de		28		plp		                plp
11174	.f1df		60		rts		                rts

11176							;-------------------------------------------------------------------------

11178	.f1e0						gsinitForFilenameParsing:
11179	.f1e0		18		clc		                clc


11182							;-------------------------------------------------------------------------
11183							;
11184							; GSINIT
11185							;
11186							; MasRef D.10-1
11187							;
11188	.f1e1						gsinitEntryPoint:
11189	.f1e1		66 e4		ror $e4		                ror stringInputOptions    ;put C into bit 7
11190	.f1e3		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
11191	.f1e6		c8		iny		                iny
11192	.f1e7		c9 22		cmp #$22	                cmp #'"'
11193	.f1e9		f0 02		beq $f1ed	                beq +                       ; C=1 if double quotes
11194	.f1eb		88		dey		                dey
11195	.f1ec		18		clc		                clc                         ; clear double quotes flag
11196	.f1ed						+
11197	.f1ed		66 e4		ror $e4		                ror stringInputOptions ; set doubleQuotes; move bit 7 into spaceNotATerminator
11198	.f1ef		c9 0d		cmp #$0d	                cmp #$0D                     ; set Z if initial CR
11199	.f1f1		60		rts		                rts

11201							;-------------------------------------------------------------------------
11202							;
11203							; GSREAD
11204							;
11205							; MasRef D.10-2
11206							; MasRef C.5-8 has the | syntax
11207							;
11208	.f1f2						gsreadEntryPoint:
11209	.f1f2		a9 01		lda #$01	                lda #stringInputOptions.goodString
11210	.f1f4		04 e4		tsb $e4		                tsb stringInputOptions
11211	.f1f6		20 0f f2	jsr $f20f	                jsr LF29C
11212	.f1f9		08		php		                php                          ; save flags
11213	.f1fa		46 e4		lsr $e4		                lsr stringInputOptions       ; move goodString into C
11214	.f1fc		90 04		bcc $f202	                bcc badStringError           ; branch taken if bad string
11215	.f1fe		26 e4		rol $e4		                rol stringInputOptions       ; reinstate goodString
11216	.f200		28		plp		                plp                          ; restore flags
11217	.f201		60		rts		                rts                          ;

11219	.f202						badStringError:
11220	.f202		00		brk #		                brk                          ;
11221	>f203		fd 42 61 64 20 73 74 72		                .text $fd,"Bad string",0
	>f20b		69 6e 67 00
11222	.f20f						LF29C:
11223	.f20f		18		clc		                clc                          ; last char not !
11224	.f210						LF29D:
11225							                ; C=1 at this point if |! was the last sequence seen.
11226	.f210		64 e5		stz $e5		                stz stringInputPlingFlag
11227	.f212		66 e5		ror $e5		                ror stringInputPlingFlag     ; set ! flag as required
11228	.f214		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11229	.f216		c9 0d		cmp #$0d	                cmp #13                      ;EOL?
11230	.f218		d0 09		bne $f223	                bne notRETURN                ;taken if not EOL
11231	.f21a		24 e4		bit $e4		                bit stringInputOptions
11232	.f21c		10 20		bpl $f23e	                bpl finishedString           ;taken if !doubleQuotes
11233	.f21e						badString:
11234	.f21e		a9 01		lda #$01	                lda #stringInputOptions.goodString
11235	.f220		14 e4		trb $e4		                trb stringInputOptions
11236	.f222		60		rts		                rts

11238	.f223						notRETURN:
11239	.f223		c9 20		cmp #$20	                cmp #' '
11240	.f225		90 f7		bcc $f21e	                bcc badString ;taken if unprintable control char
11241	.f227		d0 06		bne $f22f	                bne notSPACE
11242	.f229		24 e4		bit $e4		                bit stringInputOptions ;N=doubleQuotes, V=spaceNotATerminator
11243	.f22b		30 3e		bmi $f26b	                bmi finishUpReadClearV ;taken if quoted
11244	.f22d		50 0f		bvc $f23e	                bvc finishedString ;taken if space is a terminator
11245	.f22f						notSPACE:
11246	.f22f		c9 22		cmp #$22	                cmp #'"'
11247	.f231		d0 10		bne $f243	                bne notDOUBLEQUOTE         ;taken if not quotes
11248	.f233		24 e4		bit $e4		                bit stringInputOptions ;N=doubleQuotes, V=spaceNotATerminator
11249	.f235		10 34		bpl $f26b	                bpl finishUpReadClearV ;taken if not double quotes
11250	.f237		c8		iny		                iny
11251	.f238		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11252	.f23a		c9 22		cmp #$22	                cmp #'"'
11253	.f23c		f0 2d		beq $f26b	                beq finishUpReadClearV       ;taken if quotes
11254	.f23e						finishedString:
11255	.f23e		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
11256	.f241		38		sec		                sec
11257	.f242		60		rts		                rts

11259	.f243						notDOUBLEQUOTE:
11260	.f243		c9 7c		cmp #$7c	                cmp #'|'
11261	.f245		d0 24		bne $f26b	                bne finishUpReadClearV       ;taken if not |
11262	.f247		c8		iny		                iny                          ;skip |
11263	.f248		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11264	.f24a		c9 7c		cmp #$7c	                cmp #'|'
11265	.f24c		f0 1d		beq $f26b	                beq finishUpReadClearV ;branch taken if "||" - literal |
11266	.f24e		c9 22		cmp #$22	                cmp #'"'
11267	.f250		f0 19		beq $f26b	                beq finishUpReadClearV ;branch taken if "|\"" - literal "
11268	.f252		c9 21		cmp #$21	                cmp #'!'
11269	.f254		d0 03		bne $f259	                bne LF2E6                    ;taken if not "|!"

11271							                ; Handle |! - ASCII 128-255
11272	.f256		c8		iny		                iny                          ;skip !
11273	.f257		80 b7		bra $f210	                bra LF29D

11275	.f259						LF2E6:
11276	.f259		c9 20		cmp #$20	                cmp #' '
11277	.f25b		90 c1		bcc $f21e	                bcc badString ;taken if | followed by a non-printable char
11278	.f25d		c9 3f		cmp #$3f	                cmp #'?'
11279	.f25f		f0 08		beq $f269	                beq ascii127                 ;taken if "|?" - CHR$127
11280	.f261		20 b2 f2	jsr $f2b2	                jsr implementCTRLCodes
11281	.f264		2c 5e e3	bit $e35e	                bit valueFF
11282	.f267		80 03		bra $f26c	                bra LF2F9

11284	.f269						ascii127:
11285	.f269		a9 7f		lda #$7f	                lda #$7F
11286	.f26b						finishUpReadClearV:
11287	.f26b		b8		clv		                clv
11288	.f26c						LF2F9:
11289	.f26c		c8		iny		                iny
11290	.f26d		05 e5		ora $e5		                ora stringInputPlingFlag ;if it was a |! char, set bit 7
11291	.f26f		18		clc		                clc
11292	.f270		60		rts		                rts

11294							;-------------------------------------------------------------------------

11296	.f271						incAndSkipSpaces:
11297	.f271		c8		iny		                iny
11298	.f272						skipSpacesAndCheckForCRInStringInput:
11299	.f272		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11300	.f274		c9 20		cmp #$20	                cmp #' '
11301	.f276		f0 f9		beq $f271	                beq incAndSkipSpaces
11302	.f278						checkForCR:
11303	.f278		c9 0d		cmp #$0d	                cmp #13
11304	.f27a		60		rts		                rts

11306							;-------------------------------------------------------------------------

11308	.f27b						LF308:
11309	.f27b		90 f5		bcc $f272	                bcc skipSpacesAndCheckForCRInStringInput
11310	.f27d						LF30A:
11311	.f27d		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
11312	.f280		c9 2c		cmp #$2c	                cmp #','
11313	.f282		d0 f4		bne $f278	                bne checkForCR
11314	.f284		c8		iny		                iny
11315	.f285		60		rts		                rts

11317							;-------------------------------------------------------------------------

11319							                .if version==510&&olivetti
11408							                .endif

11410							;-------------------------------------------------------------------------
11411							;
11412							; Modify character in A as if the SHIFT key is being pressed.
11413							;

11415	.f286						implementShift:
11416							                .if version<500&&version!=350
11442							                .else

11444	.f286		a2 02		ldx #$02	                ldx #2
11445	.f288		50 00		bvc $f28a	                bvc LF3C5
11446	.f28a						LF3C5:
11447	.f28a		dd ad f2	cmp $f2ad,x	                cmp LF3E7-1,x
11448	.f28d		f0 1a		beq $f2a9	                beq LF3E2
11449	.f28f		ca		dex		                dex
11450	.f290		d0 f8		bne $f28a	                bne LF3C5
11451	.f292		50 14		bvc $f2a8	                bvc LF3E1
11452	.f294		c9 21		cmp #$21	                cmp #'!'
11453	.f296		90 10		bcc $f2a8	                bcc LF3E1
11454	.f298		c9 40		cmp #$40	                cmp #'@'
11455							                .if version==350
11456	.f29a		f0 0c		beq $f2a8	                beq LF3E1
11457							                .endif
11458	.f29c		90 08		bcc $f2a6	                bcc LF3DF
11459	.f29e		c9 7f		cmp #$7f	                cmp #$7f
11460	.f2a0		f0 06		beq $f2a8	                beq LF3E1
11461	.f2a2		b0 02		bcs $f2a6	                bcs LF3DF

11463	.f2a4						LF3DD:
11464	.f2a4		49 30		eor #$30	                eor #$30
11465	.f2a6						LF3DF:
11466	.f2a6		49 10		eor #$10	                eor #$10
11467	.f2a8						LF3E1:
11468	.f2a8		60		rts		                rts

11470	.f2a9						LF3E2:
11471	.f2a9		b8		clv		                clv
11472	.f2aa		bd af f2	lda $f2af,x	                lda LF3E9-1,x
11473	.f2ad		60		rts		                rts

11475	.f2ae						LF3E7:
11476	>f2ae		5f				                .byte '_'
11477	>f2af		30				                .byte '0'
11478	.f2b0						LF3E9:
11479	>f2b0		60				                .byte '`'
11480							                .if version==350
11481	>f2b1		30				                .byte '0'
11484							                .endif

11486							                .endif

11488							;-------------------------------------------------------------------------
11489							;
11490							; See MasRef C.5-8
11491							;
11492							;
11493	.f2b2						implementCTRLCodes:
11494							                .if version<500&&version!=350
11509							                .else

11511	.f2b2		da		phx		                phx
11512	.f2b3		a2 02		ldx #$02	                ldx #2
11513	.f2b5						LF3EE:
11514	.f2b5		dd d0 f2	cmp $f2d0,x	                cmp LF40A-1,x
11515	.f2b8		f0 11		beq $f2cb	                beq LF404
11516	.f2ba		ca		dex		                dex
11517	.f2bb		d0 f8		bne $f2b5	                bne LF3EE
11518	.f2bd		fa		plx		                plx
11519	.f2be		c9 3f		cmp #$3f	                cmp #'?'
11520	.f2c0		90 08		bcc $f2ca	                bcc LF403
11521	.f2c2		c9 7f		cmp #$7f	                cmp #$7f
11522	.f2c4		f0 04		beq $f2ca	                beq LF403
11523	.f2c6		b0 dc		bcs $f2a4	                bcs LF3DD
11524	.f2c8		29 1f		and #$1f	                and #$1f
11525	.f2ca						LF403:
11526	.f2ca		60		rts		                rts

11528	.f2cb						LF404:
11529	.f2cb		b8		clv		                clv
11530	.f2cc		bd d2 f2	lda $f2d2,x	                lda LF40C-1,x
11531	.f2cf		fa		plx		                plx
11532	.f2d0		60		rts		                rts

11534	.f2d1						LF40A:
11535	>f2d1		30 40				                .text '0','@'
11536	.f2d3						LF40C:
11537	>f2d3		00 00				                .text 0,0

11539							                .endif

11541							;-------------------------------------------------------------------------

11543							                .if version==350
11544	.f2d5						clearTSTAndOSBYTE247EntryPoint:
11545	.f2d5		20 5c f3	jsr $f35c	                jsr withTSTClear
11546							                .endif
11547	.f2d8						osbyte247EntryPoint:
11548	.f2d8		ad 87 02	lda $0287	                lda breakVectorByte0
11549	.f2db		49 4c		eor #$4c	                eor #$4C                     ; JMP abs
11550	.f2dd		d0 16		bne $f2f5	                bne rtsF363
11551							                .if version==350
11552	.f2df		20 87 02	jsr $0287	                jsr breakVectorByte0
11553	.f2e2		4c 5a e5	jmp $e55a	                jmp selectTerminalROM
11563							                .endif

11565							;-------------------------------------------------------------------------
11566							;
11567							; OSBYTE 144 (&90)
11568							; Set vertical screen shift and interlace
11569							;
11570							; MasRef D.2-44
11571							;
11572	.f2e5						osbyte90:
11573	.f2e5		ad 90 02	lda $0290	                lda tvOffset
11574	.f2e8		8e 90 02	stx $0290	                stx tvOffset
11575	.f2eb		aa		tax		                tax
11576	.f2ec		98		tya		                tya
11577	.f2ed		29 01		and #$01	                and #$01
11578	.f2ef		ac 91 02	ldy $0291	                ldy tvInterlace
11579	.f2f2		8d 91 02	sta $0291	                sta tvInterlace
11580	.f2f5						rtsF363:
11581	.f2f5		60		rts		                rts

11583							;-------------------------------------------------------------------------
11584							;
11585							; OSBYTE 149 (&95) - write to JIM
11586							;
11587							; MasRef D.2-45
11588							;
11589	.f2f6						osbyte95:
11590	.f2f6		98		tya		                tya
11591	.f2f7		9d 00 fd	sta $fd00,x	                sta $FD00,x
11592	.f2fa		60		rts		                rts

11594							;-------------------------------------------------------------------------
11595							;
11596							; OSBYTE 151 (&97) - write to SHEILA
11597							;
11598							; MasRef D.2-45
11599							;
11600	.f2fb						osbyte97:
11601	.f2fb		98		tya		                tya
11602	.f2fc		9d 00 fe	sta $fe00,x	                sta $FE00,x
11603	.f2ff		60		rts		                rts

11605							;-------------------------------------------------------------------------
11606							;
11607							; OSBYTE 147 (&93) - write to FRED
11608							;
11609							; MasRef D.2-45
11610							;
11611	.f300						osbyte93:
11612	.f300		98		tya		                tya
11613	.f301		9d 00 fc	sta $fc00,x	                sta $FC00,x
11614	.f304		60		rts		                rts

11616							;-------------------------------------------------------------------------
11617							;
11618							; *SHUT [MasRef G.5-10]
11619							;
11620	.f305						starSHUT:
11621	.f305		a2 26		ldx #$26	                ldx #romServiceCallCloseAllOpenFiles
11622	.f307		4c b5 ed	jmp $edb5	                jmp makeROMServiceCall

11624							;-------------------------------------------------------------------------
11625							;
11626							; Return thunk used by withTerminalROM.
11627							;
11628							; On entry here, the old value of $f4 is at the top of the stack.
11629							;
11630	.f30a						withTerminalROMReturnThunk:
11631	.f30a		08		php		                php                          ; S=[p; old ROMSEL]
11632	.f30b		48		pha		                pha                          ; S=[a; p; old ROMSEL]
11633	.f30c		da		phx		                phx                          ; S=[x; a; p; old ROMSEL]
11634	.f30d		ba		tsx		                tsx
11635	.f30e		bd 04 01	lda $0104,x	                lda $0104,x                  ; get old ROMSEL
11636	.f311		20 5c e5	jsr $e55c	                jsr selectROMA               ; re-select old ROM
11637	.f314		80 3b		bra $f351	                bra returnThunkSuffix

11639							;-------------------------------------------------------------------------
11640							;
11641							; Select the Terminal ROM. Rearrange the stack so that the original
11642							; ROM is re-selected when withTerminalROM's caller itself returns.
11643							;
11644	.f316						withTerminalROM:
11645							                .if version==350
11646	.f316		20 81 f3	jsr $f381	                jsr initWithRoutineStack
11647	.f319		a5 f4		lda $f4		                lda $f4
11648	.f31b		9d 09 01	sta $0109,x	                sta $109,x
11649	.f31e		a9 f3		lda #$f3	                lda #>(withTerminalROMReturnThunk-1)
11650	.f320		9d 08 01	sta $0108,x	                sta $108,x
11651	.f323		a9 09		lda #$09	                lda #<(withTerminalROMReturnThunk-1)
11652	.f325		9d 07 01	sta $0107,x	                sta $107,x
11673							                .endif
11674	.f328		20 5a e5	jsr $e55a	                jsr selectTerminalROM
11675	.f32b		80 16		bra $f343	                bra plx_pla_plp_rts

11677							;-------------------------------------------------------------------------
11678							;
11679							; Select the MOS ROM (i.e., no HAZEL). Rearrange the stack so that the
11680							; original HAZEL state is restored when withMOSROM's caller itself
11681							; returns.
11682							;
11683	.f32d						withMOSROM:
11684							                .if version==350
11685	.f32d		20 81 f3	jsr $f381	                jsr initWithRoutineStack
11686	.f330		a9 f3		lda #$f3	                lda #>(withMOSROMReturnThunk-1)
11687	.f332		9d 08 01	sta $0108,x	                sta $108,x
11688	.f335		a9 46		lda #$46	                lda #<(withMOSROMReturnThunk-1)
11689	.f337		9d 07 01	sta $0107,x	                sta $107,x
11690	.f33a		ad 34 fe	lda $fe34	                lda ACCCON
11691	.f33d		9d 09 01	sta $0109,x	                sta $109,x
11692	.f340		20 f4 ec	jsr $ecf4	                jsr selectMOS
11717							                .endif
11718	.f343						plx_pla_plp_rts:
11719							                ; S=[X; A; P; RL; RH; thunkRL; thunkRH; old ACCCON/ROMSEL]
11720	.f343		fa		plx		                plx
11721	.f344		68		pla		                pla
11722	.f345		28		plp		                plp
11723	.f346		60		rts		                rts

11725	.f347						withMOSROMReturnThunk:
11726	.f347		08		php		                php                          ; S=[P]
11727	.f348		48		pha		                pha                          ; S=[A; P]
11728	.f349		da		phx		                phx                          ; S=[X; A; P]
11729	.f34a		ba		tsx		                tsx                          ; S=[X; A; P; old ACCCON]
11730	.f34b		bd 04 01	lda $0104,x	                lda $0104,x                  ; get old ACCCON
11731	.f34e		20 f0 ec	jsr $ecf0	                jsr selectMOSOrHAZEL         ; re-select old HAZEL state
11732	.f351						returnThunkSuffix:
11733							                ; double up P, as that's the easiest way of ending up
11734							                ; discarding the TOS without affecting the flags.
11735	.f351		bd 03 01	lda $0103,x	                lda $0103,x
11736	.f354		9d 04 01	sta $0104,x	                sta $0104,x
11737	.f357		fa		plx		                plx
11738	.f358		68		pla		                pla
11739	.f359		28		plp		                plp
11740	.f35a		28		plp		                plp
11741	.f35b		60		rts		                rts

11743							;-------------------------------------------------------------------------
11744							;
11745							; Clear ACCCON TST bit (paging in I/O for reads, rather than ROM, at
11746							; $fc00...$feff), and restore it on exit from the current routine.
11747							;
11748							                .if version==350
11749							                ; Should be called something more like runWithTST
11750	.f35c						withTSTClear:
11751	.f35c		20 81 f3	jsr $f381	                jsr initWithRoutineStack
11752	.f35f		a5 fc		lda $fc		                lda TEMPA
11753	.f361		29 bf		and #$bf	                and #(~ACCCON.TST)&$ff       ; clear TST
11754	.f363		8d 34 fe	sta $fe34	                sta ACCCON
11755	.f366		a9 71		lda #$71	                lda #<(withTSTClearReturnThunk-1)
11756	.f368		9d 07 01	sta $0107,x	                sta $107,x
11757	.f36b		a9 f3		lda #$f3	                lda #>(withTSTClearReturnThunk-1)
11758	.f36d		9d 08 01	sta $0108,x	                sta $108,x
11759	.f370		80 d1		bra $f343	                bra plx_pla_plp_rts

11761	.f372						withTSTClearReturnThunk:
11762	.f372		08		php		                php
11763	.f373		48		pha		                pha
11764	.f374		da		phx		                phx
11765	.f375		ba		tsx		                tsx
11766	.f376		78		sei		                sei
11767	.f377		ad 34 fe	lda $fe34	                lda ACCCON
11768	.f37a		09 40		ora #$40	                ora #ACCCON.TST
11769	.f37c		20 92 e3	jsr $e392	                jsr staTEMPAAndACCCON
11770	.f37f		80 d0		bra $f351	                bra returnThunkSuffix
11771							                .endif

11773							;-------------------------------------------------------------------------
11774							;
11775							; Sort out stack for one of the withXXX routines, that set up some
11776							; state and then automatically restore the original state on exit from
11777							; the calling routine.
11778							;
11779							                .if version==350
11780	.f381						initWithRoutineStack:
11781	.f381		48		pha		                pha                          ; A RL RH R^L R^H
11782	.f382		08		php		                php                          ; P A RL RH R^L R^H
11783	.f383		48		pha		                pha                          ; A P A RL RH R^L R^H
11784	.f384		da		phx		                phx                          ; X A P A RL RH R^L R^H
11785	.f385		ba		tsx		                tsx                          ; | X A P A RL RH R^L R^H
11786	.f386		bd 06 01	lda $0106,x	                lda $106,x                   ; get RH
11787	.f389		48		pha		                pha                          ; RH | X A P A RL RH R^L R^H
11788	.f38a		bd 05 01	lda $0105,x	                lda $105,x                   ; get RL
11789	.f38d		48		pha		                pha                          ; RL RH | X A P A RL RH R^L R^H
11790	.f38e		20 92 f3	jsr $f392	                jsr LF392
11791	.f391		ca		dex		                dex
11792	.f392						LF392:
11793	.f392		bd 08 01	lda $0108,x	                lda $108,x                   ; get R^L or R^H
11794	.f395		9d 05 01	sta $0105,x	                sta $105,x                   ; replace RL or RH
11795	.f398		60		rts		                rts
11796							                .endif

11798							;-------------------------------------------------------------------------

11800	.f399						vduChrEntryPoint:
11801	.f399		20 2d f3	jsr $f32d	                jsr withMOSROM
11802	.f39c		a6 f4		ldx $f4		                ldx $F4
11803	.f39e		da		phx		                phx
11804	.f39f		20 49 e5	jsr $e549	                jsr selectTerminalROMAndANDY
11805	.f3a2		20 27 c0	jsr $c027	                jsr outputToVDU
11806	.f3a5		fa		plx		                plx
11807	.f3a6		4c 4b e5	jmp $e54b	                jmp selectROMX

11809							;-------------------------------------------------------------------------
11810							;
11811							; OSRDSC [MasRef D.6-1]
11812							;
11813	.f3a9						osrdscEntryPoint:
11814	.f3a9		20 2d f3	jsr $f32d	                jsr withMOSROM
11815	.f3ac		4c 18 c0	jmp $c018	                jmp LC018

11817							;-------------------------------------------------------------------------
11818							;
11819							; OSWRSC [MasRef D.8-1]
11820							;
11821	.f3af						oswrscEntryPoint:
11822	.f3af		20 2d f3	jsr $f32d	                jsr withMOSROM
11823	.f3b2		4c 5e db	jmp $db5e	                jmp oswrscCode

11825							;-------------------------------------------------------------------------

11827	.f3b5						starRunBOOT:
11828	>f3b5		2f 21 42 4f 4f 54 0d		                .text "/!BOOT",13

11830							;-------------------------------------------------------------------------

11832							                .if version<500&&version!=350
11834							                .endif

11836							;-------------------------------------------------------------------------

11838							                .if version>=500
11859							                .endif

11861							;-------------------------------------------------------------------------

11863							                .if version==350
11864	.f3bc						clearSoundChannelBuffer:
11865	.f3bc		20 d0 f3	jsr $f3d0	                jsr selectExtROM
11866	.f3bf		5a		phy		                phy
11867	.f3c0		20 4e b0	jsr $b04e	                jsr clearSoundChannelBufferInternal
11868	.f3c3		80 07		bra $f3cc	                bra selectOldROM
11869							                .endif

11871							;-------------------------------------------------------------------------

11873							                .if version==350
11874	.f3c5						LF3C5_350:
11875	.f3c5		20 d0 f3	jsr $f3d0	                jsr selectExtROM
11876	.f3c8		5a		phy		                phy
11877	.f3c9		20 07 af	jsr $af07	                jsr LF416
11878	.f3cc						selectOldROM:
11879	.f3cc		68		pla		                pla
11880	.f3cd		4c 5c e5	jmp $e55c	                jmp selectROMA
11881							                .endif

11883							;-------------------------------------------------------------------------

11885							                .if version==350
11886	.f3d0						selectExtROM:
11887	.f3d0		a4 f4		ldy $f4		                ldy $f4
11888	.f3d2		a9 09		lda #$09	                lda #extROM
11889	.f3d4		4c 5c e5	jmp $e55c	                jmp selectROMA
11890							                .endif

11892							;-------------------------------------------------------------------------

11894	.f3d7						LF6FC:
11895	.f3d7		a9 ff		lda #$ff	                lda #$FF
11896	.f3d9		85 f5		sta $f5		                sta $F5
11897	.f3db		60		rts		                rts

11899	.f3dc						LF701:
11900	.f3dc		e6 f5		inc $f5		                inc $F5
11901	.f3de		a4 f5		ldy $f5		                ldy $F5
11902	.f3e0		a2 0d		ldx #$0d	                ldx #romServiceCallROMFilingSystemInitialize
11903	.f3e2						LF707:
11904	.f3e2		08		php		                php
11905	.f3e3		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
11906	.f3e6		28		plp		                plp
11907	.f3e7		c9 01		cmp #$01	                cmp #$01
11908	.f3e9		98		tya		                tya
11909	.f3ea		60		rts		                rts

11911	.f3eb						LF710:
11912	.f3eb		a2 0e		ldx #$0e	                ldx #$0E
11913	.f3ed		a0 ff		ldy #$ff	                ldy #$FF
11914	.f3ef		4c e2 f3	jmp $f3e2	                jmp LF707

11916	.f3f2						LF717:
11917	.f3f2		ad cb 03	lda $03cb	                lda $03CB
11918	.f3f5		85 f6		sta $f6		                sta $F6
11919	.f3f7		ad cc 03	lda $03cc	                lda $03CC
11920	.f3fa		85 f7		sta $f7		                sta $F7
11921	.f3fc		a5 f5		lda $f5		                lda $F5
11922	.f3fe		60		rts		                rts

11924	.f3ff						tidyUpAfterKeyboardProcessing:
11925	.f3ff		a2 ff		ldx #$ff	                ldx #$FF
11926	.f401		a5 ec		lda $ec		                lda lastKeyPressedInternal
11927	.f403		05 ed		ora $ed		                ora firstKeyPressedInternal
11928	.f405		d0 06		bne $f40d	                bne +                    ;taken if any keys pressed
11929	.f407		a9 81		lda #$81	                lda #$81
11930	.f409		8d 4e fe	sta $fe4e	                sta systemVIA.ier            ;re-enable keyboard IRQ
11931	.f40c		e8		inx		                inx                          ;X=0
11932	.f40d						+
11933	.f40d		8e 42 02	stx $0242	                stx keyboardSemaphore
11934	.f410						updateKeyboardLEDs:
11935	.f410		08		php		                php
11936	.f411		ad 5a 02	lda $025a	                lda keyboardStatusByte
11937	.f414		4a		lsr a		                lsr a

11939							                ; bit 3 = caps lock off
11940							                ; bit 4 = shift lock off
11941	.f415		29 18		and #$18	                and #(keyboardStatusByte.capsLockDisengaged|keyboardStatusByte.shiftLockDisengaged)>>1
11942	.f417		09 06		ora #$06	                ora #$06                     ;latch B6 - caps lock
11943	.f419		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;update caps lock LED
11944	.f41c		4a		lsr a		                lsr a                        ;bit 3 = shift lock off
11945	.f41d		09 07		ora #$07	                ora #$07                     ;latch B7 - shift lock
11946	.f41f		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;update shift lock LED
11947	.f422		20 3d f6	jsr $f63d	                jsr enableKeyboardScanning
11948	.f425		68		pla		                pla
11949	.f426		60		rts		                rts

11951							; KEYV handler
11952							; ============
11953	.f427						keyEntryPoint:
11954	.f427		50 0a		bvc $f433	                bvc keyVClear
11955	.f429		a9 01		lda #$01	                lda #$01
11956	.f42b		8d 4e fe	sta $fe4e	                sta systemVIA.ier
11957	.f42e		b0 08		bcs $f438	                bcs keyboardTimerInterrupt
11958	.f430		4c 80 f5	jmp $f580	                jmp keyPressedInterrupt

11960	.f433						keyVClear:
11961	.f433		90 06		bcc $f43b	                bcc keyTestSHIFTAndCTRLOrTimerInterrupt
11962	.f435		4c 37 f6	jmp $f637	                jmp scanKeyboard

11964	.f438						keyboardTimerInterrupt:
11965	.f438		ee 42 02	inc $0242	                inc keyboardSemaphore

11967							;-------------------------------------------------------------------------
11968							;
11969							; Test Shift & Ctrl keys, or deal with timer interrupt.
11970							;
11971							; Entry: C=0 if KEYV V=0 C=0 - test SHIFT+CTRL keys
11972							;        C=1 if KEYV V=1 C=1 - keyboard timer interrupt
11973							;
11974	.f43b						keyTestSHIFTAndCTRLOrTimerInterrupt:
11975	.f43b		ad 5a 02	lda $025a	                lda keyboardStatusByte
11976	.f43e		29 b7		and #$b7	                and #~(keyboardStatusByte.shiftPressed|keyboardStatusByte.ctrlPressed)
11977	.f440		a2 00		ldx #$00	                ldx #key_shift
11978	.f442		20 9e f5	jsr $f59e	                jsr interrogateKeyboard      ;X=$80 if SHIFT pressed
11979	.f445		90 02		bcc $f449	                bcc +                        ;taken if testing
11980							                                             ;SHIFT+CTRL only
11981	.f447		86 fa		stx $fa		                stx SEIWKA                   ;b7 set if SHIFT pressed
11982	.f449						+
11983	.f449		b8		clv		                clv                        ;V=0
11984	.f44a		10 05		bpl $f451	                bpl testCTRL               ;taken if SHIFT not pressed
11985	.f44c		2c 5e e3	bit $e35e	                bit valueFF                ;V=1 N=1
11986	.f44f		09 08		ora #$08	                ora #keyboardStatusByte.shiftPressed
11987	.f451						testCTRL:
11988	.f451		e8		inx		                inx                          ;X=1 - key_ctrl
11989	.f452		20 9e f5	jsr $f59e	                jsr interrogateKeyboard
11990	.f455		90 b9		bcc $f410	                bcc updateKeyboardLEDs ;taken if testing SHIFT+CTRL only
11991	.f457		10 02		bpl $f45b	                bpl updateKeyboardStatusByte ;taken if CTRL not pressed
11992	.f459		09 40		ora #$40	                ora #keyboardStatusByte.ctrlPressed
11993	.f45b						updateKeyboardStatusByte:
11994	.f45b		8d 5a 02	sta $025a	                sta keyboardStatusByte
11995	.f45e		a6 ec		ldx $ec		                ldx lastKeyPressedInternal
11996	.f460		f0 4d		beq $f4af	                beq braRolloverChecks        ;taken if no key pressed
11997	.f462		20 9e f5	jsr $f59e	                jsr interrogateKeyboard      ;still pressed?
11998	.f465		30 0d		bmi $f474	                bmi checkForKeyAutoRepeat    ;taken if still pressed
11999	.f467		e4 ec		cpx $ec		                cpx lastKeyPressedInternal   ;X=0 at this point
12000	.f469						storeLastKeyPressed:
12001	.f469		86 ec		stx $ec		                stx lastKeyPressedInternal   ;update last key pressed
12002	.f46b		d0 42		bne $f4af	                bne braRolloverChecks  ;taken if still nothing pressed
12003	.f46d		64 ec		stz $ec		                stz lastKeyPressedInternal   ;reset last key pressed
12004	.f46f						resetAutoRepeatAndContinue:
12005	.f46f		20 90 f5	jsr $f590	                jsr resetAutoRepeatCounters
12006	.f472		80 3b		bra $f4af	                bra braRolloverChecks

12008	.f474						checkForKeyAutoRepeat:
12009	.f474		e4 ec		cpx $ec		                cpx lastKeyPressedInternal
12010	.f476		d0 f1		bne $f469	                bne storeLastKeyPressed      ;taken if new key pressed
12011	.f478		a5 e7		lda $e7		                lda autoRepeatCountdownTimer
12012	.f47a		f0 33		beq $f4af	                beq braRolloverChecks      ;taken if countdown timer 0
12013	.f47c		c6 e7		dec $e7		                dec autoRepeatCountdownTimer ;timer--
12014	.f47e		d0 2f		bne $f4af	                bne braRolloverChecks        ;taken if timer newly 0
12015	.f480		ad ca 02	lda $02ca	                lda keyboardFirstAutoRepeatCount
12016	.f483		85 e7		sta $e7		                sta autoRepeatCountdownTimer
12017	.f485		ad 55 02	lda $0255	                lda keyboardAutoRepeatRate
12018	.f488		8d ca 02	sta $02ca	                sta keyboardFirstAutoRepeatCount
12019	.f48b		ad 5a 02	lda $025a	                lda keyboardStatusByte
12020	.f48e		a6 ec		ldx $ec		                ldx lastKeyPressedInternal
12021	.f490		e0 d0		cpx #$d0	                cpx #$80|key_shift_lock
12022	.f492		f0 12		beq $f4a6	                beq shiftLockPressed
12023	.f494		e0 c0		cpx #$c0	                cpx #$80|key_caps_lock
12024							                .if version>=511||version==350
12025	.f496		d0 1a		bne $f4b2	                bne LF5E5_511
12028							                .endif
12029	.f498						capsLockPressed:
12030	.f498		09 a0		ora #$a0	                ora #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
12031	.f49a		24 fa		bit $fa		                bit SEIWKA                   ;test SHIFT status
12032	.f49c		10 04		bpl $f4a2	                bpl +                        ;taken if SHIFT not pressed
12033							                ; Do the SHIFT+CAPS LOCK thing
12034	.f49e		09 10		ora #$10	                ora #keyboardStatusByte.capsLockDisengaged
12035	.f4a0		49 80		eor #$80	                eor #keyboardStatusByte.shiftEnabled
12036	.f4a2						+
12037	.f4a2		49 90		eor #$90	                eor #keyboardStatusByte.shiftEnabled|keyboardStatusByte.capsLockDisengaged
12038	.f4a4		80 04		bra $f4aa	                bra resetKeyboardStatusAndTimer

12040	.f4a6						shiftLockPressed:
12041	.f4a6		09 90		ora #$90	                ora #keyboardStatusByte.shiftEnabled|keyboardStatusByte.capsLockDisengaged
12042	.f4a8		49 a0		eor #$a0	                eor #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
12043	.f4aa						resetKeyboardStatusAndTimer:
12044	.f4aa		8d 5a 02	sta $025a	                sta keyboardStatusByte
12045	.f4ad		64 e7		stz $e7		                stz autoRepeatCountdownTimer
12046	.f4af						braRolloverChecks:
12047							                .if version<500&&version!=350
12049							                .else
12050	.f4af		4c 60 f5	jmp $f560	                jmp keyboardRolloverChecks
12051							                .endif

12053							;-------------------------------------------------------------------------

12055							                .if version>=511||version==350
12056	.f4b2						LF5E5_511:
12057	.f4b2		2c 3d 02	bit $023d	                bit keyboardTranslationTableAddress+1
12058	.f4b5		30 1e		bmi $f4d5	                bmi getASCIICode
12059	.f4b7		da		phx		                phx
12060	.f4b8		da		phx		                phx
12061	.f4b9		7a		ply		                ply
12062	.f4ba		a2 30		ldx #$30	                ldx #romServiceCall30
12063	.f4bc		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
12064	.f4bf		d0 13		bne $f4d4	                bne LF607
12065	.f4c1		fa		plx		                plx
12066	.f4c2		98		tya		                tya
12067	.f4c3		6a		ror a		                ror a
12068	.f4c4		6a		ror a		                ror a
12069	.f4c5		90 02		bcc $f4c9	                bcc LF5FC
12070	.f4c7		64 e7		stz $e7		                stz autoRepeatCountdownTimer
12071	.f4c9						LF5FC:
12072	.f4c9		30 e4		bmi $f4af	                bmi braRolloverChecks
12073	.f4cb		ad 3c 02	lda $023c	                lda keyboardTranslationTableAddress+0
12074	.f4ce		2c 3d 02	bit $023d	                bit keyboardTranslationTableAddress+1
12075							                .if version==350
12076	.f4d1		4c 45 f5	jmp $f545	                jmp LF839
12079							                .endif

12081	.f4d4						LF607:
12082	.f4d4		fa		plx		                plx
12083							                .endif
12084							;-------------------------------------------------------------------------
12085							;
12086							; Convert internal key number (with bit 7 set) to ASCII code, taking
12087							; into account state of CTRL, SHIFT, CAPS LOCK and SHIFT LOCK.
12088							;
12089	.f4d5						getASCIICode:
12090							                ; -$80 to adjust for bit 7 set; -16 because
12091							                ; interesting keys start at 16
12092	.f4d5		bd 20 f5	lda $f520,x	                lda keyTranslationTable-$80-16,x
12093							                .if version>=500
12109							                .endif
12110	.f4d8		f0 08		beq $f4e2	                beq handleTAB                ;taken if TAB
12111	.f4da		c9 9d		cmp #$9d	                cmp #$9D                     ;was it key_numpad_return?
12112							                .if version<500&&version!=350
12114							                .else
12115	.f4dc		d0 07		bne $f4e5	                bne LF5FD
12116							                .endif

12118							                ;Transform $9d into $8d, aka 13|$80. ($8d is already
12119							                ; used in the table for right arrow.)
12120	.f4de		49 10		eor #$10	                eor #$10
12121	.f4e0		80 0f		bra $f4f1	                bra getNumpadASCIICode

12123	.f4e2						handleTAB:
12124	.f4e2		ad 6b 02	lda $026b	                lda tabKeyCode
12125							                .if version>=500
12152							                .elsif version==350
12153	.f4e5						LF5FD:
12154	.f4e5		2c 5e e3	bit $e35e	                bit valueFF
12155	.f4e8		c9 90		cmp #$90	                cmp #$90
12156	.f4ea		90 01		bcc $f4ed	                bcc handleKey
12157	.f4ec		b8		clv		                clv
12158							                .endif
12159	.f4ed						handleKey:
12160	.f4ed		c9 a0		cmp #$a0	                cmp #$A0                     ;numpad key?
12161	.f4ef		90 0e		bcc $f4ff	                bcc processModifiers         ;taken if not
12162	.f4f1						getNumpadASCIICode:
12163							                .if version>=500||version==350
12164	.f4f1		08		php		                php
12165							                .endif
12166							                ; C=1 at this point
12167	.f4f2		e9 31		sbc #$31	                sbc #'0'+1      ;+1 to compensate for C=1 in the next
12168							                                ;addition
12169	.f4f4		6d 7e 02	adc $027e	                adc numericKeypadInterpretation ;form actual ASCII value
12170							                .if version>=500||version==350
12171	.f4f7		28		plp		                plp
12172							                .endif
12173	.f4f8		49 80		eor #$80	                eor #$80                     ;clear bit 7
12174	.f4fa		ae 8e 02	ldx $028e	                ldx numericKeypadShiftEffect ;does SHIFT affect the
12175							                                             ;keypad?
12176	.f4fd		d0 46		bne $f545	                bne LF839                    ;taken if no
12177	.f4ff						processModifiers:
12178	.f4ff		ae 5a 02	ldx $025a	                ldx keyboardStatusByte
12179	.f502		86 fa		stx $fa		                stx SEIWKA
12180	.f504		26 fa		rol $fa		                rol SEIWKA                  ;b7 = ctrlPressed
12181	.f506		10 0a		bpl $f512	                bpl testShiftLock           ;taken if ctrl not pressed
12182	.f508		a6 ed		ldx $ed		                ldx firstKeyPressedInternal
12183	.f50a						localResetAutoRepeatAndContinue:
12184							                .if version<500&&version!=350
12187							                .else
12188	.f50a		f0 03		beq $f50f	                beq +
12189	.f50c		4c 6f f4	jmp $f46f	                jmp resetAutoRepeatAndContinue
12190	.f50f						+
12191	.f50f		20 b2 f2	jsr $f2b2	                jsr implementCTRLCodes
12192							                .endif
12193	.f512						testShiftLock:
12194	.f512		26 fa		rol $fa		                rol SEIWKA                   ;b7 = shiftLockDisengaged
12195	.f514		30 07		bmi $f51d	                bmi testCapsLock             ;taken if shift lock off
12196	.f516		20 86 f2	jsr $f286	                jsr implementShift           ;shift lock on - apply shift
12197	.f519		26 fa		rol $fa		                rol SEIWKA                   ;b7 = capsLockDisengaged
12198	.f51b		80 0c		bra $f529	                bra testShiftEnabled

12200	.f51d						testCapsLock:
12201	.f51d		26 fa		rol $fa		                rol SEIWKA                   ;b7 = capsLockDisengaged
12202	.f51f		30 0d		bmi $f52e	                bmi testShift                ;taken if caps lock off
12203	.f521		20 35 ea	jsr $ea35	                jsr isLetter
12204	.f524		b0 08		bcs $f52e	                bcs testShift                ;taken if not a letter
12205	.f526		20 86 f2	jsr $f286	                jsr implementShift ;letter + caps lock - make upper case
12206	.f529						testShiftEnabled:
12207	.f529		ae 5a 02	ldx $025a	                ldx keyboardStatusByte       ;b7 = shiftEnabled
12208	.f52c		10 0b		bpl $f539	                bpl testEscape               ;taken if not shiftEnabled
12209	.f52e						testShift:
12210	.f52e		26 fa		rol $fa		                rol SEIWKA                   ;b7 = shiftPressed
12211	.f530		10 07		bpl $f539	                bpl testEscape               ;taken if not shiftPressed
12212	.f532		a6 ed		ldx $ed		                ldx firstKeyPressedInternal
12213	.f534		d0 d4		bne $f50a	                bne localResetAutoRepeatAndContinue
12214	.f536		20 86 f2	jsr $f286	                jsr implementShift
12215	.f539						testEscape:
12216	.f539		cd 6c 02	cmp $026c	                cmp escapeCharacter
12217	.f53c		d0 07		bne $f545	                bne LF839
12218	.f53e		ae 75 02	ldx $0275	                ldx escapeKeyStatus
12219	.f541		d0 02		bne $f545	                bne LF839
12220	.f543		64 e7		stz $e7		                stz autoRepeatCountdownTimer

12222	.f545						LF839:

12224							                .if version==350

12226	.f545		a8		tay		                tay
12227	.f546		50 02		bvc $f54a	                bvc LF54A
12228	.f548		d0 0b		bne $f555	                bne LF555
12229	.f54a						LF54A:
12230	.f54a		98		tya		                tya
12231	.f54b		f0 02		beq $f54f	                beq LF54F
12232	.f54d		10 06		bpl $f555	                bpl LF555
12233	.f54f						LF54F:
12234	.f54f		20 d3 f6	jsr $f6d3	                jsr insertCharacterIntoKeyboardBufferIfPossible
12235	.f552		90 09		bcc $f55d	                bcc LF55D_350
12236	.f554		a8		tay		                tay
12237	.f555						LF555:
12238	.f555		ad 59 02	lda $0259	                lda keyboardStatus
12239	.f558		d0 03		bne $f55d	                bne LF55D_350
12240	.f55a		20 45 ea	jsr $ea45	                jsr insertCharacterIntoKeyboardBuffer
12241	.f55d						LF55D_350:
12242	.f55d		20 c7 f6	jsr $f6c7	                jsr enableKeyboardScanningFlippingInterrupts

12340							                .endif

12342	.f560						keyboardRolloverChecks:
12343	.f560		a6 ed		ldx $ed		                ldx firstKeyPressedInternal
12344	.f562		f0 09		beq $f56d	                beq LF852                    ;taken if 1 key down
12345	.f564		20 9e f5	jsr $f59e	                jsr interrogateKeyboard      ;test first key pressed
12346	.f567		86 ed		stx $ed		                stx firstKeyPressedInternal  ;save it
12347	.f569		30 18		bmi $f583	                bmi LF868                    ;taken if still pressed
12348	.f56b		64 ed		stz $ed		                stz firstKeyPressedInternal  ;reset first key
12349	.f56d						LF852:
12350	.f56d		a0 ec		ldy #$ec	                ldy #lastKeyPressedInternal
12351	.f56f		20 8d f6	jsr $f68d	                jsr scanKeyboardWithExclusion
12352	.f572		30 09		bmi $f57d	                bmi LF862
12353	.f574		a5 ec		lda $ec		                lda lastKeyPressedInternal
12354	.f576		85 ed		sta $ed		                sta firstKeyPressedInternal
12355	.f578						updateLastKeyPressedInternal:
12356	.f578		86 ec		stx $ec		                stx lastKeyPressedInternal
12357	.f57a		20 90 f5	jsr $f590	                jsr resetAutoRepeatCounters
12358	.f57d						LF862:
12359	.f57d		4c ff f3	jmp $f3ff	                jmp tidyUpAfterKeyboardProcessing

12361	.f580						keyPressedInterrupt:
12362	.f580		20 9e f5	jsr $f59e	                jsr interrogateKeyboard
12363	.f583						LF868:
12364	.f583		a5 ec		lda $ec		                lda lastKeyPressedInternal
12365	.f585		d0 f6		bne $f57d	                bne LF862
12366	.f587		a0 ed		ldy #$ed	                ldy #firstKeyPressedInternal
12367	.f589		20 8d f6	jsr $f68d	                jsr scanKeyboardWithExclusion
12368	.f58c		30 ef		bmi $f57d	                bmi LF862
12369	.f58e		80 e8		bra $f578	                bra updateLastKeyPressedInternal

12371	.f590						resetAutoRepeatCounters:
12372	.f590		a2 01		ldx #$01	                ldx #$01
12373	.f592		86 e7		stx $e7		                stx autoRepeatCountdownTimer
12374	.f594		ae 54 02	ldx $0254	                ldx keyboardAutoRepeatDelay
12375	.f597		8e ca 02	stx $02ca	                stx keyboardFirstAutoRepeatCount
12376	.f59a		60		rts		                rts

12378							;-------------------------------------------------------------------------
12379							;
12380							; Read a single key's state from the keyboard
12381							;
12382							; Entry:
12383							;
12384							; X = key to test
12385							;
12386							; Exit:
12387							;
12388							; X=$80, N=1 if key pressed; X=$00, N=0 if key not pressed
12389							;
12390							; Preserves: A/C
12391							;
12392							                .if version==350
12393	.f59b						clearTSTAndInterrogateKeyboard:
12394	.f59b		20 5c f3	jsr $f35c	                jsr withTSTClear
12395							                .endif
12396	.f59e						interrogateKeyboard:
12397	.f59e		a0 03		ldy #$03	                ldy #$03                     ;write to keyboard
12398	.f5a0		8c 40 fe	sty $fe40	                sty systemVIA.orb
12399	.f5a3		a0 7f		ldy #$7f	                ldy #$7F
12400	.f5a5		8c 43 fe	sty $fe43	                sty systemVIA.ddra           ;bit 7=input, bits 6-0=output
12401	.f5a8		8e 4f fe	stx $fe4f	                stx systemVIA.oraNoHandshake ;store key value
12402	.f5ab		ea		nop		                nop
12403	.f5ac		ae 4f fe	ldx $fe4f	                ldx systemVIA.iraNoHandshake ;read key state
12404	.f5af		60		rts		                rts

12406							; Default keyboard table
12407							; ======================

12409	.f5b0						keyTranslationTable:
12410	>f5b0		71				                .text "q"                    ;10 q
12411	>f5b1		33				                .byte "3"                    ;11 3
12412	>f5b2		34				                .byte "4"                    ;12 4
12413	>f5b3		35				                .byte "5"                    ;13 5
12414	>f5b4		84				                .byte $84                    ;14 f4
12415	>f5b5		38				                .text "8"                    ;15 8
12416	>f5b6		87				                .byte $87                    ;16 f7
12417	>f5b7		2d				                .text "-"                    ;17 minus
12418	>f5b8		5e				                .text "^"                    ;18 caret
12419	>f5b9		8c				                .byte $8C                    ;19 left
12420	>f5ba		b6				                .byte "6"|$80                ;1a numpad_6
12421	>f5bb		b7				                .byte "7"|$80                ;1b numpad_7
12422	.f5bc						osbyte92:
12423	.f5bc		bc 00 fc	ldy $fc00,x	                ldy $FC00,x                  ;1c 1d 1e
12424	.f5bf		60		rts		                rts                          ;1f

12426							                .cerror *-keyTranslationTable!=16,'oops'
12427	>f5c0		80				                .byte $80                    ;20 f0
12428	>f5c1		77				                .text "w"                    ;21 w
12429	>f5c2		65				                .text "e"                    ;22 e
12430	>f5c3		74				                .text "t"                    ;23 t
12431	>f5c4		37				                .text "7"                    ;24 7
12432	>f5c5		69				                .text "i"                    ;25 i
12433	>f5c6		39				                .text "9"                    ;26 9
12434	>f5c7		30				                .text "0"                    ;27 0
12435	>f5c8		5f				                .text "_"                    ;28 underline
12436	>f5c9		8e				                .byte $8E                    ;29 down
12437	>f5ca		b8				                .byte "8"|$80                ;2a numpad_8
12438	>f5cb		b9				                .byte "9"|$80                ;2b numpad_9
12439	.f5cc						osbyte94:
12440	.f5cc		bc 00 fd	ldy $fd00,x	                ldy $FD00,x                  ;2c 2d 2e
12441	.f5cf		60		rts		                rts                          ;2f

12443							                .cerror *-keyTranslationTable!=32,'oops'
12444	>f5d0		31				                .text "1"                    ;30 1
12445	>f5d1		32				                .text "2"                    ;31 2
12446	>f5d2		64				                .text "d"                    ;32 d
12447	>f5d3		72				                .text "r"                    ;33 r
12448	>f5d4		36				                .text "6"                    ;34 6
12449	>f5d5		75				                .text "u"                    ;35 u
12450	>f5d6		6f				                .text "o"                    ;36 o
12451	>f5d7		70				                .text "p"                    ;37 p
12452	>f5d8		5b				                .text "["                    ;38 left_square_bracket
12453	>f5d9		8f				                .byte $8F                    ;39 up
12454	>f5da		ab				                .byte "+"|$80                ;3a numpad_plus
12455	>f5db		ad				                .byte "-"|$80                ;3b numpad_minus
12456	>f5dc		9d				                .byte $9D                    ;3c numpad_return
12457	.f5dd						LF8BF:
12458	.f5dd		6c 20 02	jmp ($0220)	                jmp (EVENTV)                 ;3d 3e 3f
12459							                .cerror *-keyTranslationTable!=48,'oops'
12460	>f5e0		01				                .byte 1                      ;40 caps_lock
12461	>f5e1		61				                .text "a"                    ;41 a
12462	>f5e2		78				                .text "x"                    ;42 x
12463	>f5e3		66				                .text "f"                    ;43 f
12464	>f5e4		79				                .text "y"                    ;44 y
12465	>f5e5		6a				                .text "j"                    ;45 j
12466	>f5e6		6b				                .text "k"                    ;46 k
12467							                .if version<500
12468	>f5e7		40				                .text "@"                    ;47 at
12471							                .endif
12472	>f5e8		3a				                .text ":"                    ;48 colon
12473	>f5e9		0d				                .byte $0D                    ;49 return
12474	>f5ea		af				                .byte "/"|$80                ;4a numpad_divide
12475	>f5eb		ff				                .byte 127|$80                ;4b numpad_delete
12476	>f5ec		ae				                .byte "."|$80                ;4c numpad_stop
12477	.f5ed						call1MHzBusHook:
12478	.f5ed		6c fe fd	jmp ($fdfe)	                jmp ($FDFE)                  ;4d 4e 4f

12480							                .cerror *-keyTranslationTable!=64,'oops'
12481	>f5f0		02				                .byte 2                      ;50 shift_lock
12482	>f5f1		73				                .text "s"                    ;51 s
12483	>f5f2		63				                .text "c"                    ;52 c
12484	>f5f3		67				                .text "g"                    ;53 g
12485	>f5f4		68				                .text "h"                    ;54 h
12486	>f5f5		6e				                .text "n"                    ;55 n
12487	>f5f6		6c				                .text "l"                    ;56 l
12488	>f5f7		3b				                .text ";"                    ;57 semicolon
12489	>f5f8		5d				                .text "]"                    ;58 right_square_bracket
12490	>f5f9		7f				                .byte $7F                    ;59 delete
12491	>f5fa		a3				                .byte "#"|$80                ;5a numpad_hash
12492	>f5fb		aa				                .byte "*"|$80                ;5b numpad_multiply
12493	>f5fc		ac				                .byte ","|$80                ;5c numpad_comma
12494	.f5fd						callSEIWKA:
12495	.f5fd		6c fa 00	jmp ($00fa)	                jmp (SEIWKA)                 ;5d 5e 5f
12496							                .cerror *-keyTranslationTable!=80,'oops'
12497	>f600		00				                .byte 0                      ;60 tab
12498	>f601		7a				                .text "z"                    ;61 z
12499	>f602		20				                .text " "                    ;62 space
12500	>f603		76				                .text "v"                    ;63 v
12501	>f604		62				                .text "b"                    ;64 b
12502	>f605		6d				                .text "m"                    ;65 m
12503	>f606		2c				                .text ","                    ;66 comma
12504	>f607		2e				                .text "."                    ;67 stop
12505	>f608		2f				                .text "/"                    ;68 divide
12506	>f609		8b				                .byte $8B                    ;69 copy
12507	>f60a		b0				                .byte "0"|$80                ;6a numpad_0
12508	>f60b		b1				                .byte "1"|$80                ;6b numpad_1
12509	>f60c		b3				                .byte "3"|$80                ;6c numpad_3
12510	>f60d		00				                .byte 0                      ;6d
12511	>f60e		00				                .byte 0                      ;6e
12512	>f60f		00				                .byte 0                      ;6f
12513							                .cerror *-keyTranslationTable!=96,'oops'
12514	>f610		1b				                .byte 27                     ;70 escape
12515	>f611		81				                .byte $81                    ;71 f1
12516	>f612		82				                .byte $82                    ;72 f2
12517	>f613		83				                .byte $83                    ;73 f3
12518	>f614		85				                .byte $85                    ;74 f5
12519	>f615		86				                .byte $86                    ;75 f6
12520	>f616		88				                .byte $88                    ;76 f8
12521	>f617		89				                .byte $89                    ;77 f9
12522	>f618		5c				                .byte $5C                    ;78 backslash
12523	>f619		8d				                .byte $8D                    ;79 right
12524	>f61a		b4				                .byte "4"|$80                ;7a numpad_4
12525	>f61b		b5				                .byte "5"|$80                ;7b numpad_5
12526	>f61c		b2				                .byte "2"|$80                ;7c numpad_2
12527	.f61d						LF8FF:
12528	.f61d		2c 5e e3	bit $e35e	                bit valueFF                  ; Set V
12529	.f620						callKEYV:
12530	.f620		6c 28 02	jmp ($0228)	                jmp (KEYV)                   ; Jump to KEYV

12532							;-------------------------------------------------------------------------
12533							;
12534							; OSBYTE 131 (&83) - Read Operating System High Water Mark (OSHWM)
12535							;
12536							; MasRef D.2-40
12537							;
12538	.f623						osbyte83:
12539	.f623		ac 44 02	ldy $0244	                ldy oshwm
12540	.f626		a2 00		ldx #$00	                ldx #$00
12541	.f628		60		rts		                rts

12543							;-------------------------------------------------------------------------
12544							;
12545							; OSBYTE 120 ($78) - Write keys pressed information
12546							;
12547							; MasRef D.2-33
12548							;
12549	.f629						osbyte78:                          ;f90b
12550	.f629		84 ec		sty $ec		                sty lastKeyPressedInternal
12551	.f62b		86 ed		stx $ed		                stx firstKeyPressedInternal
12552	.f62d		60		rts		                rts

12554							;-------------------------------------------------------------------------
12555							;
12556							; OSBYTE 122 (&7A) Keyboard scan from 16 decimal
12557							;
12558							; MasRef D.2-36
12559							;
12560							                .if version==350
12561	.f62e						clearTSTAndOSBYTE7A:
12562	.f62e		20 5c f3	jsr $f35c	                jsr withTSTClear
12563							                .endif
12564	.f631						osbyte7A:
12565	.f631		a2 10		ldx #$10	                ldx #$10
12566	.f633		b8		clv		                clv
12567	.f634		38		sec		                sec
12568	.f635		80 e9		bra $f620	                bra callKEYV

12570							;-------------------------------------------------------------------------

12572	.f637						scanKeyboard:
12573	.f637		8a		txa		                txa
12574	.f638		10 0a		bpl $f644	                bpl LF923
12575	.f63a		20 9e f5	jsr $f59e	                jsr interrogateKeyboard
12576	.f63d						enableKeyboardScanning:
12577	.f63d		a9 0b		lda #$0b	                lda #8|3                     ;set latch B3 - auto scan mode
12578	.f63f		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;set auto scan mode
12579	.f642		8a		txa		                txa
12580	.f643		60		rts		                rts

12582	.f644						LF923:
12583	.f644		8e cb 02	stx $02cb	                stx previousKeyPressedWhenReadingLastKey
12584	.f647		a9 ff		lda #$ff	                lda #$FF
12585	.f649		8d cc 02	sta $02cc	                sta previousKeyPressedWhenReadingFirstKey
12586	.f64c		a2 0c		ldx #$0c	                ldx #$0C
12587	.f64e		a9 7f		lda #$7f	                lda #$7F
12588	.f650		8d 43 fe	sta $fe43	                sta systemVIA.ddra
12589	.f653		a9 03		lda #$03	                lda #0|3            ;reset latch B3 - manual scan mode
12590	.f655		8d 40 fe	sta $fe40	                sta systemVIA.orb
12591	.f658						loopKeyboardColumns:
12592	.f658		a9 0f		lda #$0f	                lda #$0F
12593	.f65a		8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;select a non-existent column
12594	.f65d		a9 01		lda #$01	                lda #$01
12595	.f65f		8d 4d fe	sta $fe4d	                sta systemVIA.ifr            ;cancel keyboard interrupts
12596	.f662		8e 4f fe	stx $fe4f	                stx systemVIA.oraNoHandshake ;select column
12597	.f665		2c 4d fe	bit $fe4d	                bit systemVIA.ifr            ;any key in this column
12598							                                             ;pressed?
12599	.f668		f0 1b		beq $f685	                beq tryNextKeyboardColumn    ;taken if no key
12600	.f66a		8a		txa		                txa                          ;A = first key in column
12601	.f66b						loopKeyboardRows:
12602	.f66b		18		clc		                clc
12603	.f66c		69 10		adc #$10	                adc #$10                     ;next row
12604	.f66e		30 15		bmi $f685	                bmi tryNextKeyboardColumn    ;taken if done
12605	.f670		8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;store key
12606	.f673		2c 4f fe	bit $fe4f	                bit systemVIA.iraNoHandshake ;pressed?
12607	.f676		10 f3		bpl $f66b	                bpl loopKeyboardRows         ;taken if not
12608	.f678		cd cb 02	cmp $02cb	                cmp previousKeyPressedWhenReadingLastKey
12609	.f67b		90 ee		bcc $f66b	                bcc loopKeyboardRows
12610	.f67d		cd cc 02	cmp $02cc	                cmp previousKeyPressedWhenReadingFirstKey
12611	.f680		b0 e9		bcs $f66b	                bcs loopKeyboardRows
12612	.f682		8d cc 02	sta $02cc	                sta previousKeyPressedWhenReadingFirstKey
12613	.f685						tryNextKeyboardColumn:
12614	.f685		ca		dex		                dex
12615	.f686		10 d0		bpl $f658	                bpl loopKeyboardColumns
12616	.f688		ae cc 02	ldx $02cc	                ldx previousKeyPressedWhenReadingFirstKey
12617	.f68b		80 b0		bra $f63d	                bra enableKeyboardScanning

12619	.f68d						scanKeyboardWithExclusion:
12620	.f68d		a2 0c		ldx #$0c	                ldx #$0c
12621	.f68f						LF96E:
12622	.f68f		20 c7 f6	jsr $f6c7	                jsr enableKeyboardScanningFlippingInterrupts
12623	.f692		a9 7f		lda #$7f	                lda #$7F
12624	.f694		8d 43 fe	sta $fe43	                sta systemVIA.ddra
12625	.f697		a9 03		lda #$03	                lda #0|3
12626	.f699		8d 40 fe	sta $fe40	                sta systemVIA.orb
12627	.f69c		a9 0f		lda #$0f	                lda #$0F
12628	.f69e		8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;select non-existent column
12629	.f6a1		a9 01		lda #$01	                lda #$01
12630	.f6a3		8d 4d fe	sta $fe4d	                sta systemVIA.ifr            ;cancel keyboard interrupts
12631	.f6a6		8e 4f fe	stx $fe4f	                stx systemVIA.oraNoHandshake
12632	.f6a9		2c 4d fe	bit $fe4d	                bit systemVIA.ifr
12633	.f6ac		f0 20		beq $f6ce	                beq LF9AD
12634	.f6ae		8a		txa		                txa
12635	.f6af						LF98E:
12636	.f6af		18		clc		                clc
12637	.f6b0		69 10		adc #$10	                adc #$10
12638	.f6b2		30 1a		bmi $f6ce	                bmi LF9AD                    ;taken if done
12639	.f6b4		8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;test key
12640	.f6b7		2c 4f fe	bit $fe4f	                bit systemVIA.iraNoHandshake ;pressed?
12641	.f6ba		10 f3		bpl $f6af	                bpl LF98E                    ;taken if not
12642	.f6bc		48		pha		                pha                          ;save key number
12643	.f6bd						LF99C:
12644	.f6bd		59 00 00	eor $0000,y	                eor $0000,y                  ;compare to value
12645	.f6c0		0a		asl a		                asl a                        ;discard irrelevant bit 7
12646	.f6c1		c9 01		cmp #$01	                cmp #$01                     ;C set if different
12647	.f6c3		68		pla		                pla                          ;restore key number
12648	.f6c4		90 e9		bcc $f6af	                bcc LF98E                    ;same key found - keep going
12649	.f6c6		aa		tax		                tax
12650	.f6c7						enableKeyboardScanningFlippingInterrupts:
12651	.f6c7		20 3d f6	jsr $f63d	                jsr enableKeyboardScanning
12652	.f6ca		58		cli		                cli
12653	.f6cb		78		sei		                sei
12654	.f6cc		8a		txa		                txa
12655	.f6cd		60		rts		                rts

12657	.f6ce						LF9AD:
12658	.f6ce		ca		dex		                dex
12659	.f6cf		10 be		bpl $f68f	                bpl LF96E
12660	.f6d1		80 f4		bra $f6c7	                bra enableKeyboardScanningFlippingInterrupts

12662							;-------------------------------------------------------------------------

12664							                .if version==400
12666							                .endif

12668							;-------------------------------------------------------------------------

12670							                .if version>=500
12672							                .endif

12674							;-------------------------------------------------------------------------

12676							                ; Ugly condition...
12677							                .if version>=500||(version==350&&!includeTubeSupport)
12698							                .endif

12700							;-------------------------------------------------------------------------

12702							                .if version>=400
12704							                .endif

12706							;-------------------------------------------------------------------------

12708							                .if version>=400
12733							                .endif

12735							;-------------------------------------------------------------------------

12737							                .if version>=500
12739							                .endif

12741							;-------------------------------------------------------------------------

12743							                .if version>=400
12747							                .endif

12749							;-------------------------------------------------------------------------

12751							                .if version>=400
12755							                .endif

12757							;-------------------------------------------------------------------------

12759							                .if version>=400
12763							                .endif

12765							;-------------------------------------------------------------------------

12767							                .if version>=400
12771							                .endif

12773							;-------------------------------------------------------------------------

12775							                .if version==350
12776							                .include "insertCharacterIntoKeyboardBufferIfPossible.s65"

:16	;******  Processing file: src/insertCharacterIntoKeyboardBufferIfPossible.s65

1							                ; dup of what's called LF82B in MOS 5.00+
2	.f6d3						insertCharacterIntoKeyboardBufferIfPossible:
3	.f6d3		48		pha		                pha
4	.f6d4		a2 00		ldx #$00	                ldx #bufferKeyboard          ; buffer number
5	.f6d6		b8		clv		                clv                          ; count buffer
6	.f6d7		38		sec		                sec                          ; return space remaining
7	.f6d8		20 6a ec	jsr $ec6a	                jsr countBufferViaCNPV       ; do the thing...
8	.f6db		98		tya		                tya                          ; A=MSB of space remaining
9	.f6dc		d0 04		bne $f6e2	                bne LF6E2              ; taken if >256 bytes remaining
10	.f6de		e0 02		cpx #$02	                cpx #2                 ; X=LSB of space remaining
11	.f6e0		90 0a		bcc $f6ec	                bcc LF6EC            ; taken if 1 or 0 bytes remaining
12	.f6e2						LF6E2:
13	.f6e2		ac 59 02	ldy $0259	                ldy keyboardStatus
14	.f6e5		18		clc		                clc                       ; assume char not inserted
15	.f6e6		d0 04		bne $f6ec	                bne LF6EC                 ; taken if keyboard disabled
16	.f6e8		20 45 ea	jsr $ea45	                jsr insertCharacterIntoKeyboardBuffer
17	.f6eb		38		sec		                sec                          ; indicate char inserted
18	.f6ec						LF6EC:
19	.f6ec		68		pla		                pla
20	.f6ed		60		rts		                rts


:15	;******  Return to file: src/mos.s65

12777							                .endif

12779							;-------------------------------------------------------------------------
12780							;
12781							; OSBPUT [AUG p339]
12782							;
12783	.f6ee						osbputEntryPoint:
12784	.f6ee		20 d3 f7	jsr $f7d3	                jsr selectFSForHandle
12785	.f6f1		6c 18 02	jmp ($0218)	                jmp (BPUTV)

12787							;-------------------------------------------------------------------------
12788							;
12789							; OSBGET [AUG p338]
12790							;
12791	.f6f4						osbgetEntryPoint:
12792	.f6f4		20 d3 f7	jsr $f7d3	                jsr selectFSForHandle
12793	.f6f7		6c 16 02	jmp ($0216)	                jmp (BGETV)

12795							;-------------------------------------------------------------------------
12796							;
12797							; OSGBPB [AUG p339]
12798							;
12799	.f6fa						osgbpbEntryPoint: .proc
12800	.f6fa		c9 05		cmp #$05	                cmp #gbpbGetMediaMetadata
12801	.f6fc		b0 15		bcs $f713	                bcs nonFileOperation
12802	.f6fe		c9 00		cmp #$00	                cmp #$00
12803	.f700		f0 11		beq $f713	                beq nonFileOperation

12805							                ; Handle OSGBPB call that's an operation on a file
12806							                ; handle. Select the appropriate FS, given the file
12807							                ; handle, and pass the request along.
12808	.f702		5a		phy		                phy                          ;save OSGBPB Y
12809	.f703		48		pha		                pha                          ;save OSGBPB A
12810	.f704		86 b0		stx $b0		                stx osgbpbWorkspace.ptr+0
12811	.f706		84 b1		sty $b1		                sty osgbpbWorkspace.ptr+1
12812	.f708		b2 b0		lda ($b0)	                lda (osgbpbWorkspace.ptr)    ;get file handle
12813	.f70a		a8		tay		                tay
12814	.f70b		68		pla		                pla                          ;restore OSGBPB A
12815	.f70c		20 d3 f7	jsr $f7d3	                jsr selectFSForHandle
12816	.f70f						passToCurrentFS:
12817	.f70f		7a		ply		                ply                          ;restore OSGBPB Y
12818	.f710		6c 1a 02	jmp ($021a)	                jmp (GBPBV)

12820							;-------------------------------------------------------------------------
12821							;
12822							; Handle OSGBPB call that isn't an operation on a file handle. Select
12823							; current FS and pass the request along.
12824							;
12825	.f713						nonFileOperation:
12826	.f713		5a		phy		                phy
12827	.f714		da		phx		                phx
12828	.f715		48		pha		                pha
12829	.f716		20 fa ec	jsr $ecfa	                jsr selectHAZEL
12830	.f719		ad 00 df	lda $df00	                lda hazel.currentFS
12831	.f71c		20 89 f8	jsr $f889	                jsr selectFS
12832	.f71f		68		pla		                pla
12833	.f720		fa		plx		                plx
12834	.f721		80 ec		bra $f70f	                bra passToCurrentFS
12835							                .endproc

12837							;-------------------------------------------------------------------------
12838							;
12839							; OSARGS [AUG p337[
12840							;
12841							;
12842	.f723						osargsEntryPoint: .proc
12843	.f723		c0 00		cpy #$00	                cpy #$00
12844	.f725		d0 2a		bne $f751	                bne fileOperation            ;taken if file operation
12845	.f727		c9 04		cmp #$04	                cmp #$04
12846	.f729		b0 26		bcs $f751	                bcs fileOperation ;taken if Y=0, A>=4 - honorary file operation
12847	.f72b		48		pha		                pha
12848	.f72c		20 fa ec	jsr $ecfa	                jsr selectHAZEL
12849	.f72f		68		pla		                pla
12850	.f730		d0 04		bne $f736	                bne notGetFS
12851	.f732						getFS:
12852							                ; OSARGS Y=0 A=0 - read current FS number
12853	.f732		ad 00 df	lda $df00	                lda hazel.currentFS
12854	.f735		60		rts		                rts

12856	.f736						notGetFS:
12857	.f736		3a		dec a		                dec a
12858	.f737		d0 10		bne $f749	                bne notGetCommandLine
12859	.f739						getCommandLine:
12860							                ; OSARGS Y=0 A=1 - read command line tail address
12861	.f739		3a		dec a		                dec a                        ;A=$ff
12862	.f73a		95 02		sta $02,x	                sta 2,x                    ;store full 32-bit address
12863	.f73c		95 03		sta $03,x	                sta 3,x                    ;store full 32-bit address
12864	.f73e		ad 04 df	lda $df04	                lda hazel.commandLinePointer+0
12865	.f741		95 00		sta $00,x	                sta 0,x                    ;
12866	.f743		ad 05 df	lda $df05	                lda hazel.commandLinePointer+1
12867	.f746		95 01		sta $01,x	                sta 1,x
12868	.f748		60		rts		                rts

12870	.f749						notGetCommandLine:
12871	.f749		c9 01		cmp #$01	                cmp #argsCheckANFS-1    ;-1 due to the dec a above
12872	.f74b		f0 03		beq $f750	                beq rtsFA14            ; OSARGS Y=0 A=2 - Read OldNFS flag
12873	.f74d						getLibFS:
12874	.f74d		ad 02 df	lda $df02	                lda hazel.libFS      ;OSARGS Y=0 A=3 - Read libfs filing system number
12875	.f750						rtsFA14:
12876	.f750		60		rts		                rts

12878	.f751						fileOperation:
12879							                ; Operating on a file. Select appropriate FS first.
12880	.f751		20 d3 f7	jsr $f7d3	                jsr selectFSForHandle
12881							                .endproc


12884							;-------------------------------------------------------------------------
12885							;
12886							; Call current FS's OSARGS routine, bypassing the FileSwitch stuff.
12887							;
12888	.f754						callARGSV:                      ;fa18
12889	.f754		6c 14 02	jmp ($0214)	                jmp (ARGSV)

12891							;-------------------------------------------------------------------------
12892							;
12893							; OSFIND [AUG p342]
12894							;
12895	.f757						osfindEntryPoint: .proc
12896	.f757		09 00		ora #$00	                ora #$00        ;A=$00 if a file is to be closed
12897	.f759		f0 05		beq $f760	                beq close       ;branch taken if closing a file
12898	.f75b		20 aa f7	jsr $f7aa	                jsr parseFileNameAndSelectFS       ;handle something other than a file close
12899	.f75e		80 03		bra $f763	                bra callFINDV

12901	.f760						close:
12902	.f760		20 d3 f7	jsr $f7d3	                jsr selectFSForHandle
12903	.f763						callFINDV:
12904	.f763		6c 1c 02	jmp ($021c)	                jmp (FINDV)
12905							                .pend

12907							;-------------------------------------------------------------------------
12908							;
12909							; OSFILE [AUG p335]
12910							;
12911	.f766						osfileEntryPoint:               ;fa2a
12912	.f766		da		phx		                phx
12913	.f767		5a		phy		                phy
12914	.f768		48		pha		                pha
12915	.f769		86 f2		stx $f2		                stx stringInputBufferAddress+0
12916	.f76b		84 f3		sty $f3		                sty stringInputBufferAddress+1
12917	.f76d		a0 11		ldy #$11	                ldy #size(OSFILEParameterBlock)-1
12918	.f76f						-
12919	.f76f		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
12920	.f771		99 ed 02	sta $02ed,y	                sta osfileParameterBlock,y
12921	.f774		88		dey		                dey
12922	.f775		10 f8		bpl $f76f	                bpl -
12923	.f777		ae ed 02	ldx $02ed	                ldx osfileParameterBlock+OSFILEParameterBlock.fileName+0
12924	.f77a		ac ee 02	ldy $02ee	                ldy osfileParameterBlock+OSFILEParameterBlock.fileName+1
12925	.f77d		20 aa f7	jsr $f7aa	                jsr parseFileNameAndSelectFS
12926	.f780		8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
12927	.f783		8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
12928	.f786		68		pla		                pla
12929	.f787		a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
12930	.f789		a0 02		ldy #$02	                ldy #>osfileParameterBlock
12931	.f78b		20 a7 f7	jsr $f7a7	                jsr callFILEV
12932	.f78e		7a		ply		                ply
12933	.f78f		84 f3		sty $f3		                sty stringInputBufferAddress+1
12934	.f791		fa		plx		                plx
12935	.f792		86 f2		stx $f2		                stx stringInputBufferAddress+0
12936	.f794		48		pha		                pha
12937	.f795		a0 11		ldy #$11	                ldy #size(OSFILEParameterBlock)-1
12938	.f797						-
12939	.f797		b9 ed 02	lda $02ed,y	                lda osfileParameterBlock,y
12940	.f79a		91 f2		sta ($f2),y	                sta (stringInputBufferAddress),y
12941	.f79c		88		dey		                dey
12942	.f79d		c0 02		cpy #$02	                cpy #$02                     ;don't overwrite file name
12943	.f79f		b0 f6		bcs $f797	                bcs -
12944	.f7a1		68		pla		                pla
12945	.f7a2		a6 f2		ldx $f2		                ldx stringInputBufferAddress+0
12946	.f7a4		a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
12947	.f7a6		60		rts		                rts

12949	.f7a7						callFILEV:
12950	.f7a7		6c 12 02	jmp ($0212)	                jmp (FILEV)

12952							;-------------------------------------------------------------------------
12953							;
12954							; Parse file name. Handle (and skip) any -FS- tempfs syntax, selecting
12955							; the FS specified if required.
12956							;
12957							; entry:
12958							;
12959							; Y (MSB)/X (LSB) = address of file name string
12960							;
12961							; exit:
12962							;
12963							; Y (MSB)/X (LSB) = address of file name part
12964							;
12965							; - New FS may have been selected
12966							;
12967	.f7aa						parseFileNameAndSelectFS:
12968	.f7aa		48		pha		                pha
12969	.f7ab		a5 f2		lda $f2		                lda stringInputBufferAddress+0
12970	.f7ad		48		pha		                pha
12971	.f7ae		a5 f3		lda $f3		                lda stringInputBufferAddress+1
12972	.f7b0		48		pha		                pha
12973	.f7b1		20 fa ec	jsr $ecfa	                jsr selectHAZEL
12974	.f7b4		86 f2		stx $f2		                stx stringInputBufferAddress+0
12975	.f7b6		84 f3		sty $f3		                sty stringInputBufferAddress+1
12976	.f7b8		a0 00		ldy #$00	                ldy #$00
12977	.f7ba		20 e2 f7	jsr $f7e2	                jsr parseFileNameFS      ;find -FS- prefix, if any
12978	.f7bd		5a		phy		                phy                      ;save offset
12979	.f7be		20 89 f8	jsr $f889	                jsr selectFS                 ;select desired FS
12980	.f7c1		68		pla		                pla
12981	.f7c2		18		clc		                clc
12982	.f7c3		65 f2		adc $f2		                adc stringInputBufferAddress+0
12983	.f7c5		aa		tax		                tax                          ;save string address LSB
12984	.f7c6		a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
12985	.f7c8		90 01		bcc $f7cb	                bcc +
12986	.f7ca		c8		iny		                iny
12987	.f7cb						+
12988	.f7cb		68		pla		                pla
12989	.f7cc		85 f3		sta $f3		                sta stringInputBufferAddress+1
12990	.f7ce		68		pla		                pla
12991	.f7cf		85 f2		sta $f2		                sta stringInputBufferAddress+0
12992	.f7d1		68		pla		                pla
12993	.f7d2		60		rts		                rts

12995							;-------------------------------------------------------------------------
12996							;
12997							; Select appropriate FS for the given file handle.
12998							;
12999							; entry:
13000							;
13001							; Y = file handle
13002							;
13003							; exit:
13004							;
13005							; - appropriate FS selected
13006							;
13007							; preserves: Y/X/A

13009	.f7d3						selectFSForHandle:
13010	.f7d3		da		phx		                phx
13011	.f7d4		48		pha		                pha
13012	.f7d5		20 fa ec	jsr $ecfa	                jsr selectHAZEL
13013	.f7d8		20 5f f8	jsr $f85f	                jsr findFSForHandle
13014	.f7db		8a		txa		                txa
13015	.f7dc		20 89 f8	jsr $f889	                jsr selectFS
13016	.f7df		68		pla		                pla
13017	.f7e0		fa		plx		                plx
13018	.f7e1		60		rts		                rts

13020							;-------------------------------------------------------------------------
13021							;
13022							; Parse the FS part of a file name, if any, and return the filing
13023							; system to use.
13024							;
13025							; Entry:
13026							;
13027							; (stringInputBufferAddress),y = the string
13028							;
13029							; Exit:
13030							;
13031							; A = FS number to use
13032							;
13033							; (stringInputBufferAddress),y = next char after any tempfs prefix has
13034							; been consumed
13035	.f7e2						parseFileNameFS: .proc

13037	.f7e2		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
13038	.f7e5		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput
13039	.f7e8		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
13040	.f7ea		c9 2d		cmp #$2d	                cmp #'-'
13041	.f7ec		f0 0c		beq $f7fa	                beq parseFSNamePrefix ; branch taken if tempfs syntax
13042	.f7ee		2c c6 df	bit $dfc6	                bit hazel.tempFSFlag
13043	.f7f1		ad 00 df	lda $df00	                lda hazel.currentFS
13044	.f7f4		50 03		bvc $f7f9	                bvc +
13045	.f7f6		ad 01 df	lda $df01	                lda hazel.activeFS
13046	.f7f9						+
13047	.f7f9		60		rts		                rts

13049	.f7fa						parseFSNamePrefix:
13050	.f7fa		c8		iny		                iny
13051	.f7fb		a2 00		ldx #$00	                ldx #$00
13052	.f7fd						LFAC1:
13053	.f7fd		bd 06 df	lda $df06,x	                lda hazel.fsInfoBlocks,x ;get FS name char
13054	.f800		f0 44		beq $f846	                beq badFilingSystemName
13055	.f802		8a		txa		                txa                      ;A=offset in info blocks
13056	.f803		18		clc		                clc
13057	.f804		69 08		adc #$08	                adc #size(fsInfoBlock.name)
13058	.f806		85 b0		sta $b0		                sta parseFileNameFSWorkspace.fsInfoOffset
13059	.f808		5a		phy		                phy
13060	.f809						compareFSNameLoop:
13061	.f809		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y

13063							; validate FS name char. Must be letter or digit.

13065	.f80b		20 35 ea	jsr $ea35	                jsr isLetter
13066	.f80e		90 08		bcc $f818	                bcc validFSNameChar           ;branch taken if letter
13067	.f810		c9 30		cmp #$30	                cmp #'0'
13068	.f812		90 1b		bcc $f82f	                bcc notValidFSNameChar       ;branch taken if not digit
13069	.f814		c9 3a		cmp #$3a	                cmp #'9'+1
13070	.f816		b0 17		bcs $f82f	                bcs notValidFSNameChar       ;branch taken if not digit
13071	.f818						validFSNameChar:
13072	.f818		e4 b0		cpx $b0		                cpx parseFileNameFSWorkspace.fsInfoOffset
13073	.f81a		b0 0b		bcs $f827	                bcs nextFSInfoBlock ;branch taken if end of FS
13074							                                         ;info block name was reached
13075	.f81c		5d 06 df	eor $df06,x	                eor hazel.fsInfoBlocks,x
13076	.f81f		29 df		and #$df	                and #$DF                 ;Z=1 if char matches FS name
13077	.f821		d0 04		bne $f827	                bne nextFSInfoBlock      ;branch taken if not a match
13078	.f823		e8		inx		                inx                      ;next fs info block byte
13079	.f824		c8		iny		                iny                      ;next input string byte
13080	.f825		80 e2		bra $f809	                bra compareFSNameLoop

13082	.f827						nextFSInfoBlock:
13083	.f827		7a		ply		                ply
13084	.f828		a6 b0		ldx $b0		                ldx parseFileNameFSWorkspace.fsInfoOffset ;offset of end of name
13085	.f82a		e8		inx		                inx
13086	.f82b		e8		inx		                inx
13087	.f82c		e8		inx		                inx             ;advance to next entry
13088	.f82d		80 ce		bra $f7fd	                bra LFAC1

13090	.f82f						notValidFSNameChar:

13092							; Matching FS name must be terminated with -. Otherwise, it's bad
13093							; syntax, or perhaps an overly long name.

13095	.f82f		c9 2d		cmp #$2d	                cmp #'-'
13096	.f831		d0 13		bne $f846	                bne badFilingSystemName
13097	.f833		c8		iny		                iny                       ;consume input '-'
13098	.f834		e4 b0		cpx $b0		                cpx parseFileNameFSWorkspace.fsInfoOffset
13099	.f836		f0 07		beq $f83f	                beq foundFSInfoBlock     ;branch taken if a match due
13100							                                         ;to being right at end of the
13101							                                         ;FS info block name
13102	.f838		bd 06 df	lda $df06,x	                lda hazel.fsInfoBlocks,x ;
13103	.f83b		c9 20		cmp #$20	                cmp #' '
13104	.f83d		d0 e8		bne $f827	                bne nextFSInfoBlock      ;branch taken if not a match
13105							                                         ;as tthe supplied name was a
13106							                                         ;prefix of this FS's name
13107	.f83f						foundFSInfoBlock:
13108	.f83f		68		pla		                pla
13109	.f840		a6 b0		ldx $b0		                ldx parseFileNameFSWorkspace.fsInfoOffset
13110	.f842		bd 08 df	lda $df08,x	                lda hazel.fsInfoBlocks+(fsInfoBlock.fsNumber-(fsInfoBlock.name+size(fsInfoBlock.name))),x
13111	.f845		60		rts		                rts

13113	.f846						badFilingSystemName:
13114	.f846		00		brk #		                brk
13115	>f847		f8 42 61 64 20 66 69 6c		                .text $f8,'Bad filing system name',0
	>f84f		69 6e 67 20 73 79 73 74 65 6d 20 6e 61 6d 65 00
13116							                .pend

13118							;-------------------------------------------------------------------------
13119							;
13120							; Find FS for the given handle
13121							;
13122							; entry:
13123							;
13124							; Y = file handle
13125							;
13126							; exit:
13127							;
13128							; X = FS number - will just use current FS if none suitable found
13129							;
13130	.f85f						findFSForHandle: .proc
13131	.f85f		48		pha		                pha                          ;
13132	.f860		5a		phy		                phy                          ;
13133	.f861		98		tya		                tya                          ;A = handle to search for
13134	.f862		a0 00		ldy #$00	                ldy #$00                     ;
13135	.f864						loop:
13136	.f864		be 06 df	ldx $df06,y	                ldx hazel.fsInfoBlocks.name+0,y
13137	.f867		f0 15		beq $f87e	                beq notFound                  ;taken if terminating entry
13138	.f869		d9 0e df	cmp $df0e,y	                cmp hazel.fsInfoBlocks.minHandle,y
13139	.f86c		90 07		bcc $f875	                bcc next                     ;taken if not this FS
13140	.f86e		d9 0f df	cmp $df0f,y	                cmp hazel.fsInfoBlocks.maxHandle,y
13141	.f871		90 10		bcc $f883	                bcc found                    ;taken if this FS
13142	.f873		f0 0e		beq $f883	                beq found                    ;taken if this FS

13144	.f875						next:
13145	.f875		48		pha		                pha
13146	.f876		98		tya		                tya
13147	.f877		18		clc		                clc
13148	.f878		69 0b		adc #$0b	                adc #size(fsInfoBlock)
13149	.f87a		a8		tay		                tay
13150	.f87b		68		pla		                pla
13151	.f87c		80 e6		bra $f864	                bra loop

13153	.f87e						notFound:
13154	.f87e		ae 00 df	ldx $df00	                ldx hazel.currentFS
13155	.f881		80 03		bra $f886	                bra done

13157	.f883						found:
13158	.f883		be 10 df	ldx $df10,y	                ldx hazel.fsInfoBlocks.fsNumber,y
13159	.f886						done:
13160	.f886		7a		ply		                ply
13161	.f887		68		pla		                pla
13162	.f888		60		rts		                rts
13163							                .endproc

13165							;-------------------------------------------------------------------------
13166							;
13167							; Select filing system in A.
13168							;
13169							; Entry:
13170							;
13171							; A = FS number
13172							;
13173	.f889						selectFS:                               ;fb4d
13174	.f889		cd 01 df	cmp $df01	                cmp hazel.activeFS      ; Check active fs
13175	.f88c		f0 16		beq $f8a4	                beq rtsFB68               ; Already active fs, return
13176	.f88e		5a		phy		                phy
13177	.f88f		da		phx		                phx
13178	.f890		a8		tay		                tay
13179	.f891		3a		dec a		                dec a
13180	.f892		d0 07		bne $f89b	                bne LFB5F       ;taken if not FS 1 (tape)

13182							; ??? - only if trying to select tape FS

13184	.f894		a9 04		lda #$04	                lda #$04
13185	.f896		24 e2		bit $e2		                bit $E2
13186	.f898		d0 01		bne $f89b	                bne LFB5F
13187	.f89a		c8		iny		                iny
13188	.f89b						LFB5F:
13189	.f89b		5a		phy		                phy
13190	.f89c		a2 12		ldx #$12	                ldx #romServiceCallInitialiseFilingSystem
13191	.f89e		20 b5 ed	jsr $edb5	                jsr makeROMServiceCall
13192	.f8a1		68		pla		                pla
13193	.f8a2		fa		plx		                plx
13194	.f8a3		7a		ply		                ply
13195	.f8a4						rtsFB68:
13196	.f8a4		60		rts		                rts

13198							;-------------------------------------------------------------------------
13199							;
13200							; FileSwitch FSC
13201							; ==============
13202							;
13203	.f8a5						fileswitchFSCEntryPoint:
13204	.f8a5		48		pha		                pha                          ;save request type
13205	.f8a6		20 fa ec	jsr $ecfa	                jsr selectHAZEL
13206	.f8a9		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
13207	.f8ac		68		pla		                pla                          ;restore request type
13208	.f8ad		48		pha		                pha                          ;save request type
13209	.f8ae		da		phx		                phx                          ;save request X
13210	.f8af		0a		asl a		                asl a
13211	.f8b0		aa		tax		                tax
13212	.f8b1		c9 17		cmp #$17	                cmp #11*2+1
13213	.f8b3		b0 03		bcs $f8b8	                bcs fileswitchPassFSCToCurrentFS ;taken if out of range
13214	.f8b5		7c bd f8	jmp ($f8bd,x)	                jmp (fileswitchFSCRoutinesTable,x)

13216							;-------------------------------------------------------------------------
13217							;
13218							; Pass to filing system's FSC
13219							;
13220							; There's 2 entry points - fileswitchPassFSCToCurrentFS, for
13221							; when X and A are both on the stack, and
13222							; fileswitchPassFSCToCurrentFS_X, for when only A is on the
13223							; stack.
13224							;
13225	.f8b8						fileswitchPassFSCToCurrentFS:
13226	.f8b8						fileswitchFSCNewFS:
13227	.f8b8						fileswitchFSCFileHandleRange:
13228	.f8b8						fileswitchFSCStarCommand:
13229	.f8b8		fa		plx		                plx                          ;restore request X
13230	.f8b9						fileswitchPassFSCToCurrentFS_X:
13231	.f8b9		68		pla		                pla                          ;restore request type
13232	.f8ba		6c da df	jmp ($dfda)	                jmp (hazel.activeFSCV) ;call active FS's real FSCV entry point

13234							;-------------------------------------------------------------------------
13235							;
13236							; FileSwitch FSC table
13237							;
13238	.f8bd						fileswitchFSCRoutinesTable:
13239	>f8bd		e2 f8				                .word fileswitchFSCOPT
13240	>f8bf		db f8				                .word fileswitchFSCCheckEOF
13241	>f8c1		ef f8				                .word fileswitchFSCStarSlash
13242	>f8c3		d5 f8				                .word fileswitchFSCUnknownCommand
13243	>f8c5		ef f8				                .word fileswitchFSCStarRUN
13244	>f8c7		f4 f8				                .word fileswitchFSCStarCAT
13245	>f8c9		b8 f8				                .word fileswitchFSCNewFS
13246	>f8cb		b8 f8				                .word fileswitchFSCFileHandleRange
13247	>f8cd		b8 f8				                .word fileswitchFSCStarCommand
13248	>f8cf		f4 f8				                .word fileswitchFSCStarEX
13249	>f8d1		f4 f8				                .word fileswitchFSCStarINFO
13250	>f8d3		24 f9				                .word fileswitchFSCRUNLibrary

13252							;-------------------------------------------------------------------------
13253							;
13254							; FSC 3 - *command [AUG p344]
13255							;
13256	.f8d5						fileswitchFSCUnknownCommand:
13257	.f8d5		fa		plx		                plx
13258	.f8d6		20 fd f8	jsr $f8fd	                jsr getCommandLinePointer
13259	.f8d9		80 de		bra $f8b9	                bra fileswitchPassFSCToCurrentFS_X

13261							;-------------------------------------------------------------------------
13262							;
13263							; FSC 1 - check EOF [AUG p343]
13264							;
13265	.f8db						fileswitchFSCCheckEOF:
13266	.f8db		7a		ply		                ply                         ;Y = file handle
13267	.f8dc		5a		phy		                phy                         ;restore stack arrangement
13268	.f8dd		20 d3 f7	jsr $f7d3	                jsr selectFSForHandle
13269	.f8e0		80 d6		bra $f8b8	                bra fileswitchPassFSCToCurrentFS

13271							;-------------------------------------------------------------------------
13272							;
13273							; FSC 0 - *OPT [AUG p343]
13274							;
13275	.f8e2						fileswitchFSCOPT:
13276	.f8e2		2c c6 df	bit $dfc6	                bit hazel.tempFSFlag   ; Check temporary fs flag
13277	.f8e5		70 d1		bvs $f8b8	                bvs fileswitchPassFSCToCurrentFS
13278	.f8e7		ad 00 df	lda $df00	                lda hazel.currentFS ; Get current filing system number

13280							;-------------------------------------------------------------------------
13281							;
13282							; Pass FSCV request through to a particular FS.
13283							;
13284							; entry:
13285							;
13286							; A = FS to select
13287							;
13288							; Y = FSCV Y
13289							;
13290							; S = [FSCV X; FSCV A]
13291							;
13292	.f8ea						fileswitchPassFSCToSpecificFS:
13293	.f8ea		20 89 f8	jsr $f889	                jsr selectFS        ; Select filing system
13294	.f8ed		80 c9		bra $f8b8	                bra fileswitchPassFSCToCurrentFS

13296							;-------------------------------------------------------------------------
13297							;
13298							; FSC 2 - */filename [AUG p343]
13299							; FSC 4 - *RUN filename [AUG p344]
13300							;
13301	.f8ef						fileswitchFSCStarSlash:
13302	.f8ef						fileswitchFSCStarRUN:
13303	.f8ef		fa		plx		                plx
13304	.f8f0		20 fd f8	jsr $f8fd	                jsr getCommandLinePointer ; Skip '*'s and spaces, set command line address
13305	.f8f3		da		phx		                phx             ; Continue on to pass to filing system


13308							;-------------------------------------------------------------------------
13309							;
13310							; FSC 5 - *CAT [AUG p344]
13311							; FSC 9 - *EX [NAUG p257]
13312							; FSC, 10 - *INFO [NAUG p257]
13313							;
13314	.f8f4						fileswitchFSCStarCAT:
13315	.f8f4						fileswitchFSCStarEX:
13316	.f8f4						fileswitchFSCStarINFO:
13317	.f8f4		fa		plx		                plx
13318	.f8f5		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
13319	.f8f8		20 aa f7	jsr $f7aa	                jsr parseFileNameAndSelectFS
13320	.f8fb		80 bc		bra $f8b9	                bra fileswitchPassFSCToCurrentFS_X

13322							;-------------------------------------------------------------------------
13323							;
13324							; Get command line pointer.
13325							;
13326							; Entry:
13327							;
13328							; X/Y - pointer to CR-terminated command line string
13329							;
13330							; Exit:
13331							;
13332							; X/Y, (hazel.commandLinePointer) - pointer to first non-space char in
13333							; command line string
13334	.f8fd						getCommandLinePointer: .proc ;fbc1
13335	.f8fd		86 f2		stx $f2		                stx stringInputBufferAddress+0
13336	.f8ff		84 f3		sty $f3		                sty stringInputBufferAddress+1

13338							; skip spaces. Stop if terminating CR encountered.

13340	.f901		a0 ff		ldy #$ff	                ldy #$FF
13341	.f903						-
13342	.f903		c8		iny		                iny
13343	.f904		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
13344	.f906		c9 0d		cmp #$0d	                cmp #$0D
13345	.f908		f0 04		beq $f90e	                beq +
13346	.f90a		c9 20		cmp #$20	                cmp #' '
13347	.f90c		d0 f5		bne $f903	                bne -

13349	.f90e						+

13351							; Hmm. Didn't we just do this bit already?

13353	.f90e		20 72 f2	jsr $f272	                jsr skipSpacesAndCheckForCRInStringInput

13355							; Store address of first non-space char in the HAZEL command line
13356							; pointer.

13358	.f911		98		tya		                tya
13359	.f912		18		clc		                clc
13360	.f913		65 f2		adc $f2		                adc stringInputBufferAddress+0
13361	.f915		8d 04 df	sta $df04	                sta hazel.commandLinePointer+0
13362	.f918		a5 f3		lda $f3		                lda stringInputBufferAddress+1
13363	.f91a		69 00		adc #$00	                adc #$00
13364	.f91c		8d 05 df	sta $df05	                sta hazel.commandLinePointer+1
13365	.f91f		a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
13366	.f921		a6 f2		ldx $f2		                ldx stringInputBufferAddress+0
13367	.f923		60		rts		                rts
13368							                .pend

13370							;-------------------------------------------------------------------------
13371							;
13372							; FSC 11 - RUN from libfs [NAUG p257]
13373							;
13374	.f924						fileswitchFSCRUNLibrary:
13375	.f924		ad 02 df	lda $df02	                lda hazel.libFS      ; Is a libfs set?
13376	.f927		10 c1		bpl $f8ea	                bpl fileswitchPassFSCToSpecificFS
13377	.f929						badCommandError:
13378	.f929		00		brk #		                brk
13379	>f92a		fe				                .byte 254
13380	>f92b		42 61 64 20 63 6f 6d 6d		                .text "Bad command"
	>f933		61 6e 64
13381	.f936		00		brk #		                brk

13383							;-------------------------------------------------------------------------

13385							                .if version==350
13386							                .if includeTubeSupport
13387							                .include "sram_access_helpers_tube.s65"

:23	;******  Processing file: src/sram_access_helpers_tube.s65

1							; There's a no-Tube version of transferBetweenSidewaysRAMAndRAM in
2							; mos.s65, that's worth using if Tube not supported as it doesn't do a
3							; jsr on every iteration.

5	.f937						transferBetweenSidewaysRAMAndRAM:
6	.f937		20 5c e5	jsr $e55c	                jsr selectROMA
7	.f93a						transferBetweenSidewaysRAMAndRAMLoop:
8	.f93a		b1 b0		lda ($b0),y	                lda (sramTransferPointers.src),y
9	.f93c		91 b2		sta ($b2),y	                sta (sramTransferPointers.dest),y
10	.f93e		20 86 f9	jsr $f986	                jsr transferSidewaysRAMLoopUpdate
11	.f941		d0 f7		bne $f93a	                bne transferBetweenSidewaysRAMAndRAMLoop
12	.f943		b5 01		lda $01,x	                lda 1,x
13	.f945		cd f0 02	cmp $02f0	                cmp sramWorkspace.length+1
14	.f948		d0 f0		bne $f93a	                bne transferBetweenSidewaysRAMAndRAMLoop
15	.f94a		4c 5a e5	jmp $e55a	                jmp selectTerminalROM

17							;-------------------------------------------------------------------------

19	.f94d						transferParasiteToSidewaysRAM:
20	.f94d		20 5c e5	jsr $e55c	                jsr selectROMA
21	.f950						transferParasiteToSidewaysRAMLoop:
22	.f950		ad e5 fe	lda $fee5	                lda tube.data3
23	.f953		91 b2		sta ($b2),y	                sta (sramTransferPointers.dest),y
24	.f955		20 96 f9	jsr $f996	                jsr LF800
25	.f958		20 86 f9	jsr $f986	                jsr transferSidewaysRAMLoopUpdate
26	.f95b		d0 f3		bne $f950	                bne transferParasiteToSidewaysRAMLoop
27	.f95d		b5 01		lda $01,x	                lda 1,x
28	.f95f		cd f0 02	cmp $02f0	                cmp sramWorkspace.length+1
29	.f962		d0 ec		bne $f950	                bne transferParasiteToSidewaysRAMLoop
30	.f964		4c 5a e5	jmp $e55a	                jmp selectTerminalROM

32							;-------------------------------------------------------------------------

34	.f967						transferSidewaysRAMOverTube:
35	.f967		2c ee 02	bit $02ee	                bit osfileParameterBlock+1
36	.f96a		30 e1		bmi $f94d	                bmi transferParasiteToSidewaysRAM
37	.f96c		20 5c e5	jsr $e55c	                jsr selectROMA  ; select ROM of interest
38	.f96f						transferSidewaysRAMToParasiteLoop:
39	.f96f		b1 b0		lda ($b0),y	                lda (sramTransferPointers.src),y ; load byte from sideways RAM
40	.f971		8d e5 fe	sta $fee5	                sta tube.data3  ; send byte to coprocessor
41	.f974		20 96 f9	jsr $f996	                jsr LF800       ;
42	.f977		20 86 f9	jsr $f986	                jsr transferSidewaysRAMLoopUpdate
43	.f97a		d0 f3		bne $f96f	                bne transferSidewaysRAMToParasiteLoop
44	.f97c		b5 01		lda $01,x	                lda 1,x
45	.f97e		cd f0 02	cmp $02f0	                cmp sramWorkspace.length+1
46	.f981		d0 ec		bne $f96f	                bne transferSidewaysRAMToParasiteLoop
47	.f983		4c 5a e5	jmp $e55a	                jmp selectTerminalROM

49							;-------------------------------------------------------------------------

51	.f986						transferSidewaysRAMLoopUpdate:
52	.f986		c8		iny		                iny
53	.f987		d0 0d		bne $f996	                bne LF800
54	.f989		e6 b1		inc $b1		                inc sramTransferPointers.src+1
55	.f98b		e6 b3		inc $b3		                inc sramTransferPointers.dest+1
56	.f98d		20 5a e5	jsr $e55a	                jsr selectTerminalROM
57	.f990		20 e5 8a	jsr $8ae5	                jsr L8D0F
58	.f993		20 5c e5	jsr $e55c	                jsr selectROMA
59	.f996						LF800:
60	.f996		cc ef 02	cpy $02ef	                cpy osfileParameterBlock+2
61							                ; the dummy ROM header's first byte is the RTS for
62							                ; this routine...
63							                .cerror *!=dummyROMHeader


:15	;******  Return to file: src/mos.s65

13388							                .endif
13389							                .include "sram_access_helpers_2.s65"

:17	;******  Processing file: src/sram_access_helpers_2.s65

1	.f999						dummyROMHeader: .block
2	.f999		60		rts		                rts
3	>f99a		00 00				                .byte 0,0
4	.f99c		60		rts		                rts
5	>f99d		00 00				                .byte 0,0
6	>f99f		02				                .byte romType6502
7	>f9a0		0c				                .byte copyright-dummyROMHeader
8	>f9a1		ff				                .byte $ff
9	>f9a2		52				                .text "R"
10	.f9a3						ram_or_rom_char:
11	>f9a3		41				                .text "A"
12	>f9a4		4d				                .text "M"
13	.f9a5						copyright:
14	>f9a5		00				                .byte 0
15	>f9a6		28 43 29			                .text "(C)"
16	=16						size=*-dummyROMHeader
17							                ; I doubt I've caught all the implied 16s...
18							                .cerror *-dummyROMHeader!=16

20							                ; in any event, this ROM header must be <=16 bytes, as
21							                ; the total pseudo-addressable area has a o documented
22							                ; size of 4*(16384-16)
23							                .cerror *-dummyROMHeader>16
24							                .endblock

26	=32784						dataBankStart=$8000+16
27	=16368						dataBankSize=16384-16

29							;-------------------------------------------------------------------------
30							;
31							;
32	.f9a9						initDummyROMHeader:
33	.f9a9		20 4b e5	jsr $e54b	                jsr selectROMX
34	.f9ac		a0 0f		ldy #$0f	                ldy #size(dummyROMHeader)-1
35	.f9ae						LF881:
36	.f9ae		b9 99 f9	lda $f999,y	                lda dummyROMHeader,y
37	.f9b1		99 00 80	sta $8000,y	                sta $8000,y
38	.f9b4		88		dey		                dey
39	.f9b5		10 f7		bpl $f9ae	                bpl LF881
40	.f9b7		2c ee 02	bit $02ee	                bit sramWorkspace.type
41	.f9ba		70 05		bvs $f9c1	                bvs LF894       ; taken if called by *SRDATA
42	.f9bc		a9 4f		lda #$4f	                lda #'O'
43	.f9be		8d 0a 80	sta $800a	                sta $8000+(dummyROMHeader.ram_or_rom_char-dummyROMHeader)
44	.f9c1						LF894:
45	.f9c1		8e 01 80	stx $8001	                stx $8001
46	.f9c4		4c 5a e5	jmp $e55a	                jmp selectTerminalROM

48							;-------------------------------------------------------------------------
49							;
50							; Check if a ROM bank is writeable.
51							;
52							; Entry:
53							;
54							; X = ROM bank of interest
55							;
56							; Exit:
57							;
58							; C=0 if ROM, C=1 if RAM
59							;
60							; Terminal ROM selected
61							;
62							; Preserves: X
63							;
64	.f9c7						isBankROM:
65	.f9c7		20 4b e5	jsr $e54b	                jsr selectROMX

67							                ; Modify the version number byte - if a valid
68							                ; writeable sideways ROM, don't leave it in a bad
69							                ; state if reset partway through (not much you can do
70							                ; for non-ROMs of course...)
71	.f9ca		ad 08 80	lda $8008	                lda $8008
72	.f9cd		a8		tay		                tay             ; Y = original value
73	.f9ce		49 ff		eor #$ff	                eor #$ff
74	.f9d0		78		sei		                sei
75	.f9d1		8d 08 80	sta $8008	                sta $8008       ; store modified value
76	.f9d4		cd 08 80	cmp $8008	                cmp $8008       ; did it take? Z=1 if RAM
77	.f9d7		8c 08 80	sty $8008	                sty $8008       ; restore original value
78	.f9da		58		cli		                cli
79	.f9db		f0 01		beq $f9de	                beq jmpSelectTerminalROM ; taken if RAM
80	.f9dd		18		clc		                clc
81	.f9de						jmpSelectTerminalROM:
82	.f9de		4c 5a e5	jmp $e55a	                jmp selectTerminalROM

84							;-------------------------------------------------------------------------



:15	;******  Return to file: src/mos.s65

13390							                .include "sram_access_helpers_3.s65"

:18	;******  Processing file: src/sram_access_helpers_3.s65

1	.f9e1						LF8D1:
2	.f9e1		ad ee 02	lda $02ee	                lda sramWorkspace.type
3	.f9e4		c9 a0		cmp #$a0	                cmp #$a0
4	.f9e6		d0 f6		bne $f9de	                bne jmpSelectTerminalROM
5	.f9e8		ac f1 02	ldy $02f1	                ldy sramWorkspace.bank
6	.f9eb		98		tya		                tya
7	.f9ec		aa		tax		                tax
8	.f9ed		20 9b e3	jsr $e39b	                jsr LE389
9	.f9f0		90 ec		bcc $f9de	                bcc jmpSelectTerminalROM
10	.f9f2		ad 06 80	lda $8006	                lda $8006
11	.f9f5		9d a1 02	sta $02a1,x	                sta romInformationTable,x
12	.f9f8		80 e4		bra $f9de	                bra jmpSelectTerminalROM


:15	;******  Return to file: src/mos.s65

13391							                .endif

13393							;-------------------------------------------------------------------------
13394							;
13395							; Tube 6502 language ROM relocation
13396							;

13398							                .if version==350&&includeTubeSupport

13400	.f9fa						relocateNextLanguageROMPage: .block
13401							                ; TODO - all the 0/1/2/3 references here are
13402							                ; presumably tubeLanguageHostAddr

13404	.f9fa		a0 00		ldy #$00	                ldy #0
13405	.f9fc		84 00		sty $00		                sty tubeLanguageHostAddr+0

13407	.f9fe						loop:
13408	.f9fe		b1 00		lda ($00),y	                lda (tubeLanguageHostAddr),y ; fetch byte from language ROM
13409	.fa00		ae f9 04	ldx $04f9	                ldx tubeRelocationPageOffset
13410	.fa03		f0 13		beq $fa18	                beq gotByte                  ; taken if not relocating
13411							                .if finmos329
13413							                .else
13414							                ; Presumably somebody found at least one ROMs that
13415							                ; does lda $7fff,X (or similar), and so references to
13416							                ; page $7f also need accounting for.
13417	.fa05		c9 7f		cmp #$7f	                cmp #$7F
13418							                .endif
13419	.fa07		90 0f		bcc $fa18	                bcc gotByte ; taken if not potentially-relocatable byte
13420	.fa09		c9 c0		cmp #$c0	                cmp #$C0
13421	.fa0b		b0 0b		bcs $fa18	                bcs gotByte ; taken if not potentially-relocatable byte
13422	.fa0d		48		pha		                pha
13423	.fa0e		20 ce fa	jsr $face	                jsr fetchTubeRelocationBitmapBit
13424	.fa11		68		pla		                pla
13425	.fa12		90 04		bcc $fa18	                bcc gotByte ; taken if byte isn't actually to be relocated
13426	.fa14		18		clc		                clc
13427	.fa15		6d f9 04	adc $04f9	                adc tubeRelocationPageOffset ; adjust for relocation offset
13428	.fa18						gotByte:
13429	.fa18		99 00 07	sta $0700,y	                sta tubeRelocationBuffer,y
13430	.fa1b		c8		iny		                iny
13431	.fa1c		d0 e0		bne $f9fe	                bne loop
13432	.fa1e		ee 01 00	inc $0001	                inc @w tubeLanguageHostAddr+1
13433	.fa21		60		rts		                rts
13434							                .endblock

13436							;-------------------------------------------------------------------------

13438	.fa22						checkForTubeRelocationBitmap:
13439	.fa22		8d 56 00	sta $0056	                sta @w tubeLanguageParasiteAddr+3 ; parasite address bits 24-31
13440	.fa25		8c 55 00	sty $0055	                sty @w tubeLanguageParasiteAddr+2 ; parasite address bits 16-23
13441	.fa28		24 f4		bit $f4		                bit $f4
13442	.fa2a		70 71		bvs $fa9d	                bvs setTubeLanguageParasiteAddr00008000 ; taken if don't-relocate bit set
13443	.fa2c		ad 06 80	lda $8006	                lda sidewaysROMType
13444	.fa2f		29 0d		and #$0d	                and #~%0010&$0f              ; Z=1 if 6502 code
13445	.fa31		d0 78		bne $faab	                bne noTubeRelocationBitmap                    ; taken if not 6502 code
13446	.fa33		ad 56 00	lda $0056	                lda @w tubeLanguageParasiteAddr+3 ; parasite address bits 24-31
13447	.fa36		8d 03 00	sta $0003	                sta @w tubeRelocationBitmapPtr+1
13448	.fa39		0d 55 00	ora $0055	                ora @w tubeLanguageParasiteAddr+2 ; parasite address bits 16-31
13449	.fa3c		f0 6d		beq $faab	                beq noTubeRelocationBitmap     ; taken if parasite address is $0000xxxx
13450	.fa3e		ad 55 00	lda $0055	                lda @w tubeLanguageParasiteAddr+2
13451	.fa41		8d 02 00	sta $0002	                sta @w tubeRelocationBitmapPtr+0
13452							                ; (2) is address of bitmap descriptor table
13453	.fa44		a0 02		ldy #$02	                ldy #2
13454	.fa46		b1 02		lda ($02),y	                lda (tubeRelocationBitmapPtr),y ; get bitmap ROM number
13455	.fa48		aa		tax		                tax                          ; X = bitmap ROM number
13456	.fa49		88		dey		                dey
13457	.fa4a		b1 02		lda ($02),y	                lda (tubeRelocationBitmapPtr),y ; get pointer to byte after bitmap, MSB
13458	.fa4c		a8		tay		                tay            ; Y = pointer to byte after bitmap, MSB
13459	.fa4d		b2 02		lda ($02)	                lda (tubeRelocationBitmapPtr) ; get pointer to byte after bitmap, LSB
13460							                ; (tubeRelocationBitmapPtr) = pointer to byte after bitmap
13461	.fa4f		8d 02 00	sta $0002	                sta @w tubeRelocationBitmapPtr+0
13462	.fa52		8c 03 00	sty $0003	                sty @w tubeRelocationBitmapPtr+1
13463	.fa55		ad 54 00	lda $0054	                lda @w tubeLanguageParasiteAddr+1
13464	.fa58		38		sec		                sec
13465	.fa59		e9 80		sbc #$80	                sbc #$80 ; $80 is of course the base page for a language ROM
13466	.fa5b		8d f9 04	sta $04f9	                sta tubeRelocationPageOffset
13467	.fa5e		9c 56 00	stz $0056	                stz @w tubeLanguageParasiteAddr+3
13468	.fa61		9c 55 00	stz $0055	                stz @w tubeLanguageParasiteAddr+2
13469	.fa64		8a		txa		                txa                     ; A = bitmap ROM number
13470	.fa65		10 03		bpl $fa6a	                bpl gotRelocationBitmapROMBank ; taken if absolute ROM number
13471	.fa67		18		clc		                clc
13472	.fa68		65 f4		adc $f4		                adc $f4     ; form ROM number from relative ROM number
13473	.fa6a						gotRelocationBitmapROMBank:
13474	.fa6a		29 0f		and #$0f	                and #$F                      ; ROM numbers are 4 bits
13475	.fa6c		8d f8 04	sta $04f8	                sta tubeRelocationBitmapROMBank ; store ROM number containing relocation bitmap
13476	.fa6f		a6 f4		ldx $f4		                ldx $f4
13477	.fa71		da		phx		                phx
13478	.fa72		20 5c e5	jsr $e55c	                jsr selectROMA          ; select ROM containing bitmap
13479	.fa75		20 af fa	jsr $faaf	                jsr fetchTubeRelocationBitmapByte ; fetch hopefully $DE
13480	.fa78		49 de		eor #$de	                eor #$DE                  ; check for $CODE identifier
13481	.fa7a		d0 1b		bne $fa97	                bne invalidTubeRelocationBitmap                 ; taken if $CODE not found
13482	.fa7c		20 af fa	jsr $faaf	                jsr fetchTubeRelocationBitmapByte ;fetch hopefully $C0
13483	.fa7f		49 c0		eor #$c0	                eor #$C0                  ; check for $CODE identifier
13484	.fa81		d0 14		bne $fa97	                bne invalidTubeRelocationBitmap ; taken if $CODE not found
13485	.fa83		8d f7 04	sta $04f7	                sta tubeRelocationBitmapByte    ; A=0
13486	.fa86		20 af fa	jsr $faaf	                jsr fetchTubeRelocationBitmapByte ; fetch bitmap size MSB
13487	.fa89		8d f6 04	sta $04f6	                sta tubeRelocationBitmapSizeBytes+1
13488	.fa8c		20 af fa	jsr $faaf	                jsr fetchTubeRelocationBitmapByte ; fetch bitmap size LSB
13489	.fa8f		8d f5 04	sta $04f5	                sta tubeRelocationBitmapSizeBytes+0
13490	.fa92		68		pla		                pla
13491	.fa93		20 5c e5	jsr $e55c	                jsr selectROMA
13492	.fa96		60		rts		                rts

13494							;-------------------------------------------------------------------------

13496	.fa97						invalidTubeRelocationBitmap:
13497	.fa97		68		pla		                pla
13498	.fa98		20 5c e5	jsr $e55c	                jsr selectROMA
13499	.fa9b		80 0e		bra $faab	                bra noTubeRelocationBitmap

13501							;-------------------------------------------------------------------------

13503	.fa9d						setTubeLanguageParasiteAddr00008000:
13504	.fa9d		a9 80		lda #$80	                lda #$80
13505	.fa9f		8d 54 00	sta $0054	                sta @w tubeLanguageParasiteAddr+1
13506	.faa2		9c 53 00	stz $0053	                stz @w tubeLanguageParasiteAddr+0
13507	.faa5		9c 55 00	stz $0055	                stz @w tubeLanguageParasiteAddr+2
13508	.faa8		9c 56 00	stz $0056	                stz @w tubeLanguageParasiteAddr+3
13509	.faab						noTubeRelocationBitmap:
13510	.faab		9c f9 04	stz $04f9	                stz tubeRelocationPageOffset
13511	.faae		60		rts		                rts

13513							;-------------------------------------------------------------------------

13515	.faaf						fetchTubeRelocationBitmapByte: .block
13516							                ; decrement (2)
13517	.faaf		ad 02 00	lda $0002	                lda @w tubeRelocationBitmapPtr+0
13518	.fab2		08		php		                php
13519	.fab3		ce 02 00	dec $0002	                dec @w tubeRelocationBitmapPtr+0
13520	.fab6		28		plp		                plp
13521	.fab7		d0 03		bne $fabc	                bne +
13522	.fab9		ce 03 00	dec $0003	                dec @w tubeRelocationBitmapPtr+1
13523	.fabc						+
13524	.fabc		a5 f4		lda $f4		                lda $f4
13525	.fabe		48		pha		                pha
13526	.fabf		ad f8 04	lda $04f8	                lda tubeRelocationBitmapROMBank ; get ROM number containing relocation bitmap
13527	.fac2		20 5c e5	jsr $e55c	                jsr selectROMA ; select ROM containing relocation bitmap
13528	.fac5		b2 02		lda ($02)	                lda (tubeRelocationBitmapPtr)        ; get bitmap byte
13529	.fac7		aa		tax		                tax            ; X = bitmap byte
13530	.fac8		68		pla		                pla            ;
13531	.fac9		20 5c e5	jsr $e55c	                jsr selectROMA ; restore old ROM
13532	.facc		8a		txa		                txa            ; A = bitmap byte
13533	.facd		60		rts		                rts
13534							                .endblock

13536							;-------------------------------------------------------------------------

13538	.face						fetchTubeRelocationBitmapBit: .block
13539	.face		0e f7 04	asl $04f7	                asl tubeRelocationBitmapByte ; put next bit in carry, possibly the terminator
13540	.fad1		d0 0a		bne $fadd	                bne +                        ; taken if bit was valid
13541							                ; the bit shifted out was the terminator, so fetch
13542							                ; next one.
13543	.fad3		20 de fa	jsr $fade	                jsr LFADE                   ; fetch next byte
13544	.fad6		18		clc		                clc                         ; report bit clear
13545	.fad7		f0 04		beq $fadd	                beq +                       ; taken if end of table??
13546							                ; fetch next bit into carry, and set shifted-in bit 0
13547							                ; by way of terminator.
13548	.fad9		38		sec		                sec
13549	.fada		2e f7 04	rol $04f7	                rol tubeRelocationBitmapByte
13550	.fadd						+
13551	.fadd		60		rts		                rts
13552							                .endblock

13554							;-------------------------------------------------------------------------

13556	.fade						LFADE:       .block
13557	.fade		20 af fa	jsr $faaf	                jsr fetchTubeRelocationBitmapByte ; fetch next byte from bitmap
13558	.fae1		8d f7 04	sta $04f7	                sta tubeRelocationBitmapByte      ; store it
13559							                ; decrement (tubeRelocationBitmapSizeBytes)
13560	.fae4		ad f5 04	lda $04f5	                lda tubeRelocationBitmapSizeBytes+0
13561	.fae7		08		php		                php
13562	.fae8		ce f5 04	dec $04f5	                dec tubeRelocationBitmapSizeBytes+0
13563	.faeb		28		plp		                plp
13564	.faec		d0 03		bne $faf1	                bne +
13565	.faee		ce f6 04	dec $04f6	                dec tubeRelocationBitmapSizeBytes+1
13566	.faf1						+
13567	.faf1		ad f6 04	lda $04f6	                lda tubeRelocationBitmapSizeBytes+1 ; ?
13568	.faf4		49 80		eor #$80	                eor #$80                            ; ?
13569	.faf6		29 80		and #$80	                and #$80                            ; ?
13570	.faf8		60		rts		                rts
13571							                .endblock

13573							;-------------------------------------------------------------------------

13575	.faf9						osbyte8EWithoutRelocation:
13576	.faf9		8a		txa		                txa
13577	.fafa		09 40		ora #$40	                ora #$40                  ; set the don't-relocate bit
13578	.fafc		aa		tax		                tax
13579	.fafd		a9 8e		lda #$8e	                lda #$8E                     ; enter language ROM
13580	.faff		4c f4 ff	jmp $fff4	                jmp OSBYTE

13582							;-------------------------------------------------------------------------

13584	.fb02						getLanguageParasiteAddrAndAssumeRelocatable:
13585	.fb02		20 c8 04	jsr $04c8	                jsr tubeHost.getLanguageParasiteAddr
13586	.fb05		a9 40		lda #$40	                lda #$40
13587	.fb07		14 f4		trb $f4		                trb $f4                 ; clear the don't-relocate bit
13588	.fb09		60		rts		                rts

13590							;-------------------------------------------------------------------------

13592							                .endif

13594							                .if version==350&&!finmos329

13596	.fb0a						LFB0A:       .block
13597	.fb0a		08		php		                php
13598	.fb0b		78		sei		                sei
13599	.fb0c		ad 5e 02	lda $025e	                lda econetInterceptionStatus
13600	.fb0f		48		pha		                pha
13601	.fb10		a9 80		lda #$80	                lda #$80        ; ''
13602	.fb12		1c 5e 02	trb $025e	                trb econetInterceptionStatus
13603	.fb15		a9 87		lda #$87	                lda #$87        ; ''
13604	.fb17		20 f4 ff	jsr $fff4	                jsr OSBYTE
13605	.fb1a		68		pla		                pla
13606	.fb1b		8d 5e 02	sta $025e	                sta econetInterceptionStatus
13607	.fb1e		28		plp		                plp
13608	.fb1f		8a		txa		                txa
13609	.fb20		60		rts		                rts
13610							                .endblock

13612							;-------------------------------------------------------------------------

13614							                .if CFA3000
13629							                .endif

13631							                .endif

13633							;-------------------------------------------------------------------------

13635	>fb21		ff ff ff ff ff ff ff ff		                .fill $fc00-*,$ff
	>fb29		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb39		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb49		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb59		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb69		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb79		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb89		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb99		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fba9		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbb9		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbc9		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbd9		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbe9		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbf9		ff ff ff ff ff ff ff

13637							                .if version==350

13639							;-------------------------------------------------------------------------
13640							;
13641							; Some init code - normally hidden by the I/O region

13643	.fc00						reset: .block
13644							                .include "reset.s65"

:19	;******  Processing file: src/reset.s65

1							                .if version==350
2	.fc00		20 5a e5	jsr $e55a	                jsr selectTerminalROM
3							                .endif
4							                .if version!=350
7							                .endif
8							                .if version<500
9	.fc03		9c dd df	stz $dfdd	                stz hazel.hasACCCONChanged
10							                .endif
11							                .if version!=350
13							                .endif
14	.fc06		d8		cld		                cld
15	.fc07		a2 ff		ldx #$ff	                ldx #$FF
16	.fc09		9a		txs		                txs              ;reset stack
17	.fc0a		8e 63 fe	stx $fe63	                stx userVIA.ddra ;port A all outputs
18	.fc0d		a9 cf		lda #$cf	                lda #%11001111
19	.fc0f		8d 42 fe	sta $fe42	                sta systemVIA.ddrb
20							                .if version==350
21	.fc12		20 3d f6	jsr $f63d	                jsr enableKeyboardScanning
22	.fc15		20 f5 fe	jsr $fef5	                jsr clearAllSoundChannelBuffers
23							                .endif
24							                .if version<500
25	.fc18		a0 20		ldy #$20	                ldy #RTC.a.dv32768Hz
26	.fc1a		a2 0a		ldx #$0a	                ldx #RTC.a
27	.fc1c		20 d0 96	jsr $96d0	                jsr writeRTCByte
28	.fc1f		20 0c 95	jsr $950c	                jsr finishRTCUpdate
29							                .endif
30							                .if version!=350
39							                .else
40	.fc22		ad e7 e2	lda $e2e7	                lda defaultVectorTable+0 ;what is this.
41	.fc25		ad e7 e2	lda $e2e7	                lda defaultVectorTable+0 ;what is this.
42							                .endif
43							                .if version==350
44	.fc28		20 2e 80	jsr $802e	                jsr ldaSystemVIAIER
47							                .endif
48	.fc2b		0a		asl a		                asl a
49	.fc2c		48		pha		                pha
50							                .if version==350
51	.fc2d		d0 4a		bne $fc79	                bne nonPowerOnReset
52	.fc2f		20 7f 80	jsr $807f	                jsr resetCRTC
53	.fc32		a2 07		ldx #$07	                ldx #7

55	.fc34						LFC34:
56	.fc34		20 4b e5	jsr $e54b	                jsr selectROMX
57	.fc37		a0 80		ldy #$80	                ldy #$80        ; ''
58	.fc39		84 01		sty $01		                sty 1
59	.fc3b		64 00		stz $00		                stz 0
60	.fc3d		a8		tay		                tay

62	.fc3e						LFC3E:
63	.fc3e		91 00		sta ($00),y	                sta (0),y
64	.fc40		c8		iny		                iny
65	.fc41		d0 fb		bne $fc3e	                bne LFC3E
66	.fc43		e6 01		inc $01		                inc 1
67	.fc45		24 01		bit $01		                bit 1
68	.fc47		50 f5		bvc $fc3e	                bvc LFC3E
69	.fc49		ca		dex		                dex
70	.fc4a		e0 04		cpx #$04	                cpx #4
71	.fc4c		b0 e6		bcs $fc34	                bcs LFC34
72	.fc4e		20 5a e5	jsr $e55a	                jsr selectTerminalROM
73	.fc51		98		tya		                tya

75	.fc52						startClearRAM:
76	.fc52		a8		tay		                tay

78	.fc53						LFC53:
79	.fc53		a6 fc		ldx $fc		                ldx TEMPA
80	.fc55		98		tya		                tya
81	.fc56		64 01		stz $01		                stz 1
82	.fc58		64 00		stz $00		                stz 0

84	.fc5a						LFC5A:
85	.fc5a		91 00		sta ($00),y	                sta (0),y
86	.fc5c		c8		iny		                iny
87	.fc5d		d0 fb		bne $fc5a	                bne LFC5A
88	.fc5f		e6 01		inc $01		                inc 1
89	.fc61		a0 40		ldy #$40	                ldy #$40        ; '@'
90	.fc63		8c 00 0d	sty $0d00	                sty $d00
91	.fc66		a4 01		ldy $01		                ldy 1
92	.fc68		c0 e0		cpy #$e0	                cpy #$E0        ; ''
93	.fc6a		a8		tay		                tay
94	.fc6b		90 ed		bcc $fc5a	                bcc LFC5A
95	.fc6d		86 fc		stx $fc		                stx TEMPA
96	.fc6f		a9 04		lda #$04	                lda #ACCCON.X
97	.fc71		20 20 80	jsr $8020	                jsr trbACCCON
98	.fc74		d0 dd		bne $fc53	                bne LFC53
99	.fc76		20 5a e5	jsr $e55a	                jsr selectTerminalROM
149							                .endif
150	.fc79						nonPowerOnReset:
151							                .if version>=350
152	.fc79		ad 58 02	lda $0258	                lda breakAndESCAPEEffect
153	.fc7c		4a		lsr a		                lsr a
154	.fc7d		3a		dec a		                dec a
155	.fc7e		f0 d2		beq $fc52	                beq startClearRAM
156							                .endif
157	.fc80		a9 dd		lda #$dd	                lda #<emptyCommandLine
158	.fc82		8d 04 df	sta $df04	                sta hazel.commandLinePointer+0
159	.fc85		a9 e7		lda #$e7	                lda #>emptyCommandLine
160	.fc87		8d 05 df	sta $df05	                sta hazel.commandLinePointer+1
161	.fc8a		a9 0c		lda #$0c	                lda #ACCCON.Y|ACCCON.X ; page in MOS ROM, page in main
162							                                       ; RAM
163							                .if version==350
164	.fc8c		20 20 80	jsr $8020	                jsr trbACCCON
167							                .endif
168	.fc8f		a9 0f		lda #$0f	                lda #$0F
169	.fc91		8d 8e 02	sta $028e	                sta numericKeypadShiftEffect
170							                .if version<500&&version!=350
176							                .endif
177	.fc94		a2 01		ldx #$01	                ldx #key_ctrl
178							                .if version==350
179	.fc96		20 9b f5	jsr $f59b	                jsr clearTSTAndInterrogateKeyboard
182							                .endif
183	.fc99		e0 80		cpx #$80	                cpx #$80        ;Z=0 C=1 if CTRL+BREAK
184	.fc9b		20 10 f4	jsr $f410	                jsr updateKeyboardLEDs
185	.fc9e		9c 8d 02	stz $028d	                stz lastBREAKType            ;softBREAK
186	.fca1		6a		ror a		                ror a
187	.fca2		a2 9c		ldx #$9c	                ldx #$9c                     ;what is this?
188	.fca4		a0 8d		ldy #$8d	                ldy #$8D                     ;what is this?
189	.fca6		68		pla		                pla
190	.fca7		f0 09		beq $fcb2	                beq L80AD
191	.fca9		a0 7e		ldy #$7e	                ldy #$7E                     ;what is this?
192	.fcab		90 39		bcc $fce6	                bcc L80DF
193	.fcad		a0 87		ldy #$87	                ldy #$87                     ;what is this?
194	.fcaf		ee 8d 02	inc $028d	                inc lastBREAKType
195	.fcb2						L80AD:
196	.fcb2		ee 8d 02	inc $028d	                inc lastBREAKType
197	.fcb5		5a		phy		                phy
198							                .if version==350&&CFA3000
204							                .endif

206							                .if useTableDrivenConfigure
207							                .if version>=500
209							                .endif
210	.fcb6		a2 6b		ldx #$6b	                ldx #configureTable.mode.metadata-configureTable
211							                .if version==350
212	.fcb8		20 31 88	jsr $8831	                jsr clearTSTAndReadConfigurationByte
215							                .endif
218							                .endif

220	.fcbb		09 08		ora #$08	                ora #CMOSBytes.defaults0.shadowMask
221	.fcbd		8d 8f 02	sta $028f	                sta startupOptions
222							                .if version==350
223	.fcc0		20 93 96	jsr $9693	                jsr clearTSTAndReadDefaults3
226							                .endif
227	.fcc3		29 10		and #$10	                and #CMOSBytes.defaults3.autoBootMask
228	.fcc5		4a		lsr a		                lsr a         ; Reset OSBYTE 255 boot bit (b3) if BOOT
229	.fcc6		1c 8f 02	trb $028f	                trb startupOptions
230							                .if version==350
231	.fcc9		20 a9 89	jsr $89a9	                jsr clearTSTAndReadDefaultTVSettings
234							                .endif
235	.fccc		8c 90 02	sty $0290	                sty tvOffset
236	.fccf		8e 91 02	stx $0291	                stx tvInterlace
237							                .if version==350
238	.fcd2		20 93 96	jsr $9693	                jsr clearTSTAndReadDefaults3
241							                .endif
242	.fcd5		29 08		and #$08	                and #CMOSBytes.defaults3.protectedScrollingMask
243	.fcd7		f0 02		beq $fcdb	                beq L80D4
244	.fcd9		a9 01		lda #$01	                lda #VDUVariables.cursorFlags.scrollProtect
245	.fcdb						L80D4:
246	.fcdb		8d 66 03	sta $0366	                sta vduv.cursorFlags
247	.fcde		20 0f 97	jsr $970f	                jsr restoreFont32To255
248	.fce1		7a		ply		                ply
249	.fce2		a2 92		ldx #$92	                ldx #$92
250	.fce4		80 18		bra $fcfe	                bra initializePage2Loop
251	.fce6						L80DF:
252							                .if version>=500
254							                .endif
255	.fce6		a9 87		lda #$87	                lda #$87             ; Clear MODE bits from OSBYTE 255
256	.fce8		1c 8f 02	trb $028f	                trb startupOptions
257	.fceb		ad 55 03	lda $0355	                lda vduv.currentScreenMODE ; Get current screen MODE b0-b2
258	.fcee		29 07		and #$07	                and #$07
259	.fcf0		0c 8f 02	tsb $028f	                tsb startupOptions           ; Copy to OSBYTE 255
260	.fcf3		a9 10		lda #$10	                lda #STATE.isShadowMode ; Test shadow screen bit in VDU flags
261	.fcf5		24 d0		bit $d0		                bit STATE                      ; Not shadow screen
262	.fcf7		f0 05		beq $fcfe	                beq initializePage2Loop
263	.fcf9		a9 80		lda #$80	                lda #$80                     ; Set shadow screen bit in OSBYTE 255
264	.fcfb		0c 8f 02	tsb $028f	                tsb startupOptions

266	.fcfe						initializePage2Loop:
267	.fcfe		ad 8d 02	lda $028d	                lda lastBREAKType
268	.fd01		d0 08		bne $fd0b	                bne clearPage2Byte           ;taken unless soft BREAK

270							                ; leave the ROM information table alone on a soft
271							                ; BREAK.
272	.fd03		e0 b1		cpx #$b1	                cpx #<romInformationTable+16
273	.fd05		b0 04		bcs $fd0b	                bcs clearPage2Byte
274	.fd07		e0 a1		cpx #$a1	                cpx #<romInformationTable
275	.fd09		b0 0a		bcs $fd15	                bcs nextPage2Byte
276	.fd0b						clearPage2Byte:
277	.fd0b		9e 00 02	stz $0200,x	                stz $0200,x
278	.fd0e		e0 cd		cpx #$cd	                cpx #$CD
279	.fd10		90 03		bcc $fd15	                bcc nextPage2Byte
280	.fd12		de 00 02	dec $0200,x	                dec $0200,x                  ;initialize later values to $ff
281	.fd15						nextPage2Byte:
282	.fd15		e8		inx		                inx
283	.fd16		d0 e6		bne $fcfe	                bne initializePage2Loop

285							                .if version==350
286	.fd18		a5 fc		lda $fc		                lda TEMPA
287							                .endif
288	.fd1a		a2 cf		ldx #$cf	                ldx #$CF
289	.fd1c						initializeZeroPageLoop:
290	.fd1c		74 00		stz $00,x	                stz $00,x
291	.fd1e		e8		inx		                inx
292	.fd1f		d0 fb		bne $fd1c	                bne initializeZeroPageLoop
293							                .if version==350
294	.fd21		85 fc		sta $fc		                sta TEMPA
295	.fd23		20 5a e5	jsr $e55a	                jsr selectTerminalROM
296							                .endif

298	.fd26		ad 8d 02	lda $028d	                lda lastBREAKType
299	.fd29		d0 20		bne $fd4b	                bne L813D                    ;taken if not soft BREAK

301							                .if version!=400
302	.fd2b		ad 46 02	lda $0246	                lda noignoreState
303	.fd2e		48		pha		                pha
304							                .endif
305	.fd2f		ad 4b 02	lda $024b	                lda basicROMNumber
306	.fd32		48		pha		                pha
307	.fd33		ad 44 02	lda $0244	                lda oshwm
308	.fd36		48		pha		                pha
309	.fd37		ad 57 02	lda $0257	                lda spoolFileHandle
310	.fd3a		48		pha		                pha
311	.fd3b		ae 56 02	ldx $0256	                ldx execFileHandle

313	.fd3e						L8130:
314	.fd3e		b9 e6 e2	lda $e2e6,y	                lda defaultVectorTable-1,y
315	.fd41		99 ff 01	sta $01ff,y	                sta vectors-1,y
316	.fd44		88		dey		                dey
317	.fd45		c0 21		cpy #$21	                cpy #EVENTV+1-vectors
318	.fd47		b0 f5		bcs $fd3e	                bcs L8130

320	.fd49		a0 12		ldy #$12	                ldy #FILEV-vectors

322	.fd4b						L813D:
323	.fd4b		b9 e6 e2	lda $e2e6,y	                lda defaultVectorTable-1,y
324	.fd4e		99 ff 01	sta $01ff,y	                sta vectors-1,y
325	.fd51		88		dey		                dey
326	.fd52		d0 f7		bne $fd4b	                bne L813D

328	.fd54		ad 8d 02	lda $028d	                lda lastBREAKType
329	.fd57		d0 18		bne $fd71	                bne L8164
330	.fd59		8e 56 02	stx $0256	                stx execFileHandle
331	.fd5c		68		pla		                pla                          ;restore *SPOOL file handle
332	.fd5d		c9 04		cmp #$04	                cmp #$04                     ;is it a TAPE or ROM handle?
333	.fd5f		b0 01		bcs $fd62	                bcs L8155                    ;taken if no - keep it

335							                .if version==350
336	.fd61		98		tya		                tya
339							                .endif
340	.fd62						L8155:
341	.fd62		8d 57 02	sta $0257	                sta spoolFileHandle
342	.fd65		68		pla		                pla
343	.fd66		8d 44 02	sta $0244	                sta oshwm
344	.fd69		68		pla		                pla
345	.fd6a		8d 4b 02	sta $024b	                sta basicROMNumber
346							                .if version!=400
347	.fd6d		68		pla		                pla
348	.fd6e		8d 46 02	sta $0246	                sta noignoreState
349							                .endif

351	.fd71						L8164:
352							                .if useTableDrivenConfigure
353	.fd71		a2 19		ldx #$19	                ldx #cmosBytesOffset+CMOSBytes.defaults1
354							                .if version==350
355	.fd73		20 a0 96	jsr $96a0	                jsr clearTSTAndReadRTCByte
358							                .endif
361							                .endif
362	.fd76		a2 20		ldx #$20	                ldx #keyboardStatusByte.shiftLockDisengaged
363	.fd78		0a		asl a		                asl a
364	.fd79		0a		asl a		                asl a                        ;N=defaultCapsLockMask
365	.fd7a		30 07		bmi $fd83	                bmi gotKeyboardStatusByte                    ;taken if defaultCapsLock
366	.fd7c		a2 30		ldx #$30	                ldx #keyboardStatusByte.shiftLockDisengaged|keyboardStatusByte.capsLockDisengaged
367	.fd7e		0a		asl a		                asl a                        ;N=defaultNoLockMask
368	.fd7f		30 02		bmi $fd83	                bmi gotKeyboardStatusByte
369	.fd81		a2 a0		ldx #$a0	                ldx #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
370	.fd83						gotKeyboardStatusByte:
371	.fd83		8e 5a 02	stx $025a	                stx keyboardStatusByte
372							                .if version==350
373	.fd86		20 6a f0	jsr $f06a	                jsr clearTSTAndResetKeyRepeat
377							                .endif
378	.fd89		ad 8d 02	lda $028d	                lda lastBREAKType
379	.fd8c		f0 16		beq $fda4	                beq L8196
380							                .if useTableDrivenConfigure
381	.fd8e		a2 1c		ldx #$1c	                ldx #cmosBytesOffset+CMOSBytes.printerIgnoreChar
382							                .if version==350
383	.fd90		20 a0 96	jsr $96a0	                jsr clearTSTAndReadRTCByte
386							                .endif
389							                .endif
390	.fd93		8d 86 02	sta $0286	                sta printerIgnoreChar
391							                .if version==350
392	.fd96		20 71 89	jsr $8971	                jsr clearTSTAndReadUsePrinterIgnoreChar
399							                .endif
400	.fd99		6e 46 02	ror $0246	                ror noignoreState

402							                .if useTableDrivenConfigure
403	.fd9c		a2 9b		ldx #$9b	                ldx #configureTable.print.metadata-configureTable
404							                .if version==350
405	.fd9e		20 31 88	jsr $8831	                jsr clearTSTAndReadConfigurationByte
408							                .endif
411							                .endif

413	.fda1		8d 85 02	sta $0285	                sta printerDriverType
414	.fda4						L8196:
415							                .if version==400
417							                .else

419							                .if useTableDrivenConfigure
420	.fda4		a2 19		ldx #$19	                ldx #configureTable.data.metadata-configureTable
421							                .if version==350
422	.fda6		20 31 88	jsr $8831	                jsr clearTSTAndReadConfigurationByte
425							                .endif
428							                .endif

430	.fda9		0a		asl a		                asl a                        ;
431	.fdaa		0a		asl a		                asl a       ;shift into the control registerword field
432	.fdab		09 42		ora #$42	                ora #ACIA.control.rtsHighTXInterruptDisabled|ACIA.control.counterDivide64
433	.fdad		8d 50 02	sta $0250	                sta aciaControlRegister

435							                .if version<500
436	.fdb0		20 18 aa	jsr $aa18	                jsr resetACIAThenRewriteControlRegister
437	.fdb3		a2 01		ldx #$01	                ldx #$01
467							                .endif
468							                .endif

470	.fdb5		a9 7f		lda #$7f	                lda #$7F
471	.fdb7						initializeVIAInterruptsLoop:
472	.fdb7		9d 4d fe	sta $fe4d,x	                sta systemVIA.ifr,x
473	.fdba		9d 6d fe	sta $fe6d,x	                sta userVIA.ifr,x
474	.fdbd		ca		dex		                dex
475	.fdbe		10 f7		bpl $fdb7	                bpl initializeVIAInterruptsLoop

477							                .if version!=350
488							                .endif

490							                .if version!=400
491	.fdc0		a2 d2		ldx #$d2	                ldx #$80|VIA.irq.t1|VIA.irq.cb1|VIA.irq.ca1
494							                .endif
495	.fdc2		8e 4e fe	stx $fe4e	                stx systemVIA.ier

497							                .if version>=500
500							                .endif

502	.fdc5		a2 04		ldx #$04	                ldx #VIA.pcr.cb2InputNegativeActiveEdge|VIA.pcr.cb1NegativeActiveEdge|VIA.pcr.ca2InputPositiveEdge|VIA.pcr.ca1NegativeActiveEdge
503	.fdc7		8e 4c fe	stx $fe4c	                stx systemVIA.pcr
504	.fdca		a9 40		lda #$40	                lda #VIA.acr.t1Continuous|VIA.acr.t2Timer|VIA.acr.srDisabled|VIA.acr.pbLatchDisabled|VIA.acr.paLatchDisabled
505	.fdcc		8d 4b fe	sta $fe4b	                sta systemVIA.acr
506	.fdcf		a9 0e		lda #$0e	                lda #$0E
507	.fdd1		8d 46 fe	sta $fe46	                sta systemVIA.t1lL
508	.fdd4		8d 6c fe	sta $fe6c	                sta userVIA.pcr              ;VIA.pcr.cb2InputNegativeActiveEdge|VIA.pcr.cb1NegativeActiveEdge|VIA.pcr.ca2HighOutput|VIA.pcr.ca1NegativeActiveEdge
509							                .if version==350
510	.fdd7		8d 18 fe	sta $fe18	                sta HADC.status
513							                .endif
514	.fdda		a9 27		lda #$27	                lda #$27
515	.fddc		8d 47 fe	sta $fe47	                sta systemVIA.t1lH
516	.fddf		8d 45 fe	sta $fe45	                sta systemVIA.t1cH

518							                .if version==350||version>=400
519	.fde2		20 f5 fe	jsr $fef5	                jsr clearAllSoundChannelBuffers
527							                .endif

529							                .if version==350
530	.fde5		20 2e f6	jsr $f62e	                jsr clearTSTAndOSBYTE7A
533							                .endif
534	.fde8		86 ed		stx $ed		                stx firstKeyPressedInternal
535	.fdea		a2 00		ldx #$00	                ldx #$00
536							                .if version>=500
538							                .endif
539	.fdec		20 47 e9	jsr $e947	                jsr purgeBuffer

541							                .if version!=400
542	.fdef		ad 82 02	lda $0282	                lda serialULARegister
543	.fdf2		29 7f		and #$7f	                and #$7F
544	.fdf4		20 d5 eb	jsr $ebd5	                jsr LEC89

546							                .if useTableDrivenConfigure
547	.fdf7		a2 07		ldx #$07	                ldx #configureTable.baud.metadata-configureTable
548							                .if version==350
549	.fdf9		20 31 88	jsr $8831	                jsr clearTSTAndReadConfigurationByte
552							                .endif
555							                .endif

557	.fdfc		48		pha		                pha
558	.fdfd		aa		tax		                tax
559	.fdfe		20 b7 eb	jsr $ebb7	                jsr osbyte08
560	.fe01		fa		plx		                plx
561	.fe02		a9 07		lda #$07	                lda #$07
562	.fe04		20 b9 eb	jsr $ebb9	                jsr osbyte07
563							                .endif

565							                .if version==350
566	.fe07		20 93 96	jsr $9693	                jsr clearTSTAndReadDefaults3
569							                .endif
570	.fe0a		89 02		bit #$02	                bit #CMOSBytes.defaults3.loudMask
571	.fe0c		d0 05		bne $fe13	                bne L8211
572	.fe0e		a9 f0		lda #$f0	                lda #$F0
573	.fe10		8d 64 02	sta $0264	                sta bellSound
574	.fe13						L8211:
575							                .if version!=350
577							                .endif

579	.fe13		ae 84 02	ldx $0284	                ldx softKeyConsistencyFlag
580	.fe16		f0 03		beq $fe1b	                beq checkResetType
581	.fe18		20 85 f0	jsr $f085	                jsr osbyte12
582	.fe1b						checkResetType:
583	.fe1b		ad 8d 02	lda $028d	                lda lastBREAKType
584	.fe1e		f0 53		beq $fe73	                beq romsScanned                    ;taken if soft BREAK

586							                .if version==350
587	.fe20						scanROMs:
588							                .include "scan_roms.s65"

:20	;******  Processing file: src/scan_roms.s65

1	.fe20		8a		txa		                txa               ;A = ROM of interest
2	.fe21		a8		tay		                tay               ;Y = ROM of interest
3							                .if version<500&&version!=350
6							                .endif
7	.fe22		20 aa e3	jsr $e3aa	                jsr isROMValid
8	.fe25		90 2c		bcc $fe53	                bcc currentROMInvalid        ;taken if ROM invalid
9	.fe27		a6 f4		ldx $f4		                ldx $F4                      ;start from current ROM
10	.fe29		a4 f4		ldy $f4		                ldy $F4                      ;start from current ROM
11	.fe2b						nextOtherROM:
12	.fe2b		c8		iny		                iny                          ;next other ROM
13	.fe2c		c0 10		cpy #$10	                cpy #$10                     ;out of other ROMs?
14	.fe2e		b0 27		bcs $fe57	                bcs currentROMValid       ;taken if no more other ROMs
15							                .if version<500&&version!=350
18							                .endif
19							                .if version==350
20	.fe30		64 fa		stz $fa		                stz SEIWKA
21	.fe32		a9 80		lda #$80	                lda #$80        ; ''
22	.fe34		85 fb		sta $fb		                sta SEIWKA+1
31							                .endif
32	.fe36						compareLoop:
33	.fe36		8c 30 fe	sty $fe30	                sty ROMSEL                   ;select other ROM
34							                .if version==350
35	.fe39		b2 fa		lda ($fa)	                lda (SEIWKA)
38							                .endif
39	.fe3b		8e 30 fe	stx $fe30	                stx ROMSEL                   ;select ROM
40							                .if version==350
41	.fe3e		d2 fa		cmp ($fa)	                cmp (SEIWKA)
44							                .endif
45	.fe40		d0 e9		bne $fe2b	                bne nextOtherROM             ;taken if other ROM is good
46	.fe42		e6 fa		inc $fa		                inc SEIWKA+0
47	.fe44		d0 f0		bne $fe36	                bne compareLoop
48	.fe46		e6 fb		inc $fb		                inc SEIWKA+1
49	.fe48		a5 fb		lda $fb		                lda SEIWKA+1
50							                .if version>=500
55							                .endif
56	.fe4a		c9 84		cmp #$84	                cmp #$84                  ;compare only the first 1 KB
57	.fe4c		90 e8		bcc $fe36	                bcc compareLoop
58							                ; The first 1 KB of the current ROM matches the first
59							                ; 1 KB of some higher-priority ROM, so the current ROM
60							                ; is invalid.
61							                .if version>=500||version==350
62	.fe4e		a9 01		lda #$01	                lda #1
63	.fe50		9d a1 02	sta $02a1,x	                sta romInformationTable,x
64							                .endif

66	.fe53						currentROMInvalid:
67	.fe53		a6 f4		ldx $f4		                ldx $F4
68	.fe55		80 14		bra $fe6b	                bra nextROM

70	.fe57						currentROMValid:
71							                .if version>=500||version==350
72	.fe57		8a		txa		                txa
73	.fe58		a8		tay		                tay
74							                .if version==350
75	.fe59		20 98 e3	jsr $e398	                jsr clearTSTAndLE389
78							                .endif
79	.fe5c		90 0d		bcc $fe6b	                bcc nextROM
80							                .endif
81	.fe5e		ad 06 80	lda $8006	                lda $8006
82	.fe61		9d a1 02	sta $02a1,x	                sta romInformationTable,x
83	.fe64		29 8f		and #$8f	                and #$8F
84	.fe66		d0 03		bne $fe6b	                bne nextROM       ;taken if any mandatory bits are set

86							                ; A bogus ROM type means this ROM is the BASIC ROM.
87							                .if version>=500&&version!=350
90							                .endif

92	.fe68		8e 4b 02	stx $024b	                stx basicROMNumber

94	.fe6b						nextROM:
95	.fe6b		e8		inx		                inx
96	.fe6c		e0 10		cpx #$10	                cpx #$10
97	.fe6e		90 b0		bcc $fe20	                bcc scanROMs
98	.fe70		20 5a e5	jsr $e55a	                jsr selectTerminalROM


:19	;******  Return to file: src/reset.s65

591							                .endif

593	.fe73						romsScanned:
594	.fe73		ad 8f 02	lda $028f	                lda startupOptions
595	.fe76		20 98 c7	jsr $c798	                jsr setStartupMODE
596	.fe79		ad 8d 02	lda $028d	                lda lastBREAKType
597	.fe7c		3a		dec a		                dec a
598							                .if version>=510
601							                .else
602	.fe7d		d0 33		bne $feb2	                bne softReset                    ;taken if not power-on reset
603							                .endif

605	.fe7f						powerOnReset:
606							                .if version>=500
622							                .endif
623	.fe7f						checkForNVRAMReset:

625							                .if version>=510
644							                .endif

646							                .if version<510
647	.fe7f		a5 ed		lda $ed		                lda firstKeyPressedInternal
648							                .endif
649	.fe81						checkForResetKey:
650	.fe81		c9 33		cmp #$33	                cmp #key_r
651	.fe83		d0 2d		bne $feb2	                bne softReset                    ;taken if R not pressed

653							                .if version<500
654							                .if CFA3000
656							                .else
657							                ; Reset CMOS RAM
658	.fe85						resetCMOSRAM:
659	.fe85		a2 31		ldx #$31	                ldx #size(RTC.ram)-1
660	.fe87						resetCMOSRAMLoop:
661	.fe87		da		phx		                phx
662	.fe88		a0 00		ldy #$00	                ldy #$00
663							                .if version==350
664	.fe8a		e0 11		cpx #$11	                cpx #size(CMOSBytes)
665	.fe8c		b0 03		bcs $fe91	                bcs LFE91
666	.fe8e		bc a1 fe	ldy $fea1,x	                ldy LFEA2-1,x
667	.fe91						LFE91:
668							                .endif
669	.fe91		20 c8 96	jsr $96c8	                jsr writeCMOSByte
670	.fe94		fa		plx		                plx
671	.fe95		ca		dex		                dex
672							                .if version==350
673	.fe96		d0 ef		bne $fe87	                bne resetCMOSRAMLoop
676							                .endif

678							                .if version!=350
685							                .endif

687							                .endif
699							                .endif

701							                .if version==350
702	.fe98		20 25 e5	jsr $e525	                jsr LE525
734							                .endif

736	.fe9b		a9 03		lda #$03	                lda #$03
737	.fe9d		8d 58 02	sta $0258	                sta breakAndESCAPEEffect
738	.fea0						hang:
739	.fea0		80 fe		bra $fea0	                bra hang

741							;-------------------------------------------------------------------------

743							                .if version==350
744	.fea2						LFEA2:
745	>fea2		fe				                .byte $fe       ; fileServerStationNumber
746	>fea3		00				                .byte $00       ; fileServerNetworkNumber
747	>fea4		eb				                .byte $eb       ; printerServerStationNumber
748	>fea5		00				                .byte $00       ; printerServerNetworkNumber
749							                .if CFA3000
751							                .else
752	>fea6		cd				                .byte 12<<CMOSBytes.defaultROMs.languageShift|13<<CMOSBytes.defaultROMs.fsShift
753							                .endif
754	>fea7		ff				                .byte $FF       ; insertedROMs 8-15
755	>fea8		ff				                .byte $FF       ; insertedROMs 0-7
756	>fea9		15				                .byte $15       ; editROMBytes
757	>feaa		00				                .byte 0         ; telecommsByte
758							                .cerror !(defaultMODE>=0&&defaultMODE<=7||defaultMODE>=128&&defaultMODE<=135)
759	>feab		17				                .byte (defaultMODE&7)<<CMOSBytes.defaults0.modeShift|((defaultMODE&$80)!=0?CMOSBytes.defaults0.shadowMask:0)|CMOSBytes.defaults0.interlaceMask|0<<CMOSBytes.defaults0.tvShift ; defaults0
760							                ;.byte $17
761	>feac		60				                .byte $60
762	>fead		32				                .byte $32       ; keyboardAutoRepeatDelay
763	>feae		08				                .byte 8         ; keyboardAutoRepeatRate
764	>feaf		0a				                .byte $A        ; printerIgnoreChar
765							                .if CFA3000
767							                .elsif includeTubeSupport
768	>feb0		2d				                .byte 1<<CMOSBytes.defaults2.fx5SettingShift|3<<CMOSBytes.defaults2.serialBaudRateIndexShift|CMOSBytes.defaults2.tubeOnMask ; defaults2
771							                .endif
772	>feb1		82				                .byte 4<<CMOSBytes.defaults3.serialDataFormatShift|CMOSBytes.defaults3.loudMask
773							                .cerror *-LFEA2!=size(CMOSBytes)-1

775							.endif

777							;-------------------------------------------------------------------------

779	.feb2						softReset:
780							                .if version==350
781	.feb2		a9 08		lda #$08	                lda #ACCCON.Y
782	.feb4		20 27 80	jsr $8027	                jsr tsbACCCON
785							                .endif
786	.feb7		9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
787	.feba		9c d5 df	stz $dfd5	                stz hazel.moveDestHandle
788	.febd		a0 ca		ldy #$ca	                ldy #$CA
789							                .if version==350
790	.febf		20 42 ea	jsr $ea42	                jsr clearTSTAndInsertCharacterIntoKeyboardBuffer
793							                .endif
794							                .if version==350
795	.fec2		20 d5 f2	jsr $f2d5	                jsr clearTSTAndOSBYTE247EntryPoint
798							                .endif
799	.fec5		ad 8d 02	lda $028d	                lda lastBREAKType
800	.fec8		f0 03		beq $fecd	                beq L829D
801							                .if version==400
803							                .else
804	.feca		20 10 ed	jsr $ed10	                jsr LEDD0
805							                .endif
806	.fecd						L829D:
807							                .if includeTubeSupport
808							                .if version==350
809	.fecd		20 8c 96	jsr $968c	                jsr clearTSTAndReadDefaults2
812							                .endif
813	.fed0		4a		lsr a		                lsr a
814	.fed1		90 1f		bcc $fef2	                bcc continueSoftReset

816							                .if version==350
817	.fed3		20 93 96	jsr $9693	                jsr clearTSTAndReadDefaults3
820							                .endif

822							                .if version==350
823	.fed6		4a		lsr a		                lsr a
824	.fed7		4a		lsr a		                lsr a
825	.fed8		4a		lsr a		                lsr a
826	.fed9		a9 10		lda #$10	                lda #ACCCON.ITU
827	.fedb		20 20 80	jsr $8020	                jsr trbACCCON
828	.fede		b0 03		bcs $fee3	                bcs L82B4
829	.fee0		20 27 80	jsr $8027	                jsr tsbACCCON
838							                .endif
839	.fee3						L82B4:
840	.fee3		20 68 80	jsr $8068	                jsr isSecondProcessorPresent
841	.fee6		b0 0a		bcs $fef2	                bcs foundTube

843							                .if version==350
844	.fee8		a5 fc		lda $fc		                lda TEMPA
847							                .endif
848	.feea		49 10		eor #$10	                eor #ACCCON.ITU
849							                .if version==350
850	.feec		20 92 e3	jsr $e392	                jsr staTEMPAAndACCCON
853							                .endif

855	.feef		20 68 80	jsr $8068	                jsr isSecondProcessorPresent

857							                .endif

:15	;******  Return to file: src/mos.s65

13645	.fef2						foundTube:
13646	.fef2						continueSoftReset:
13647	.fef2		4c 8d 80	jmp $808d	                jmp softResetPart2
13648							                .endblock

13650							;-------------------------------------------------------------------------

13652	.fef5						clearAllSoundChannelBuffers: .block
13653	.fef5		a2 08		ldx #$08	                ldx #8
13654	.fef7						loop:
13655	.fef7		ca		dex		                dex
13656	.fef8		20 bc f3	jsr $f3bc	                jsr clearSoundChannelBuffer
13657	.fefb		e0 04		cpx #$04	                cpx #4
13658	.fefd		d0 f8		bne $fef7	                bne loop
13659	.feff		60		rts		                rts
13660							                .endblock

13662	>ff00						                .fill $ff00-*

13664							;-------------------------------------------------------------------------

13838							                .endif

13840							;-------------------------------------------------------------------------

13842	.ff00						E_USERV: ; ff00
13843	.ff00		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13844	.ff03						E_BRKV: ; ff03
13845	.ff03		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13846	.ff06						E_IRQ1V: ; ff06
13847	.ff06		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13848	.ff09						E_IRQ2V: ; ff09
13849	.ff09		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13850	.ff0c						E_CLIV: ; ff0c
13851	.ff0c		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13852	.ff0f						E_BYTEV: ; ff0f
13853	.ff0f		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13854	.ff12						E_WORDV: ; ff12
13855	.ff12		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13856	.ff15						E_WRCHV: ; ff15
13857	.ff15		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13858	.ff18						E_RDCHV: ; ff18
13859	.ff18		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13860	.ff1b						E_FILEV: ; ff1b
13861	.ff1b		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13862	.ff1e						E_ARGSV: ; ff1e
13863	.ff1e		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13864	.ff21						E_BGETV: ; ff21
13865	.ff21		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13866	.ff24						E_BPUTV: ; ff24
13867	.ff24		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13868	.ff27						E_GBPBV: ; ff27
13869	.ff27		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13870	.ff2a						E_FINDV: ; ff2a
13871	.ff2a		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13872	.ff2d						E_FSCV: ; ff2d
13873	.ff2d		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13874	.ff30						E_EVENTV: ; ff30
13875	.ff30		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13876	.ff33						E_UPTV: ; ff33
13877	.ff33		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13878	.ff36						E_NETV: ; ff36
13879	.ff36		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13880	.ff39						E_VDUV: ; ff39
13881	.ff39		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13882	.ff3c						E_KEYV: ; ff3c
13883	.ff3c		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13884	.ff3f						E_INSV: ; ff3f
13885	.ff3f		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13886	.ff42						E_REMV: ; ff42
13887	.ff42		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13888	.ff45						E_CNPV: ; ff45
13889	.ff45		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13890	.ff48						E_IND1V: ; ff48
13891	.ff48		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13892	.ff4b						E_IND2V: ; ff4b
13893	.ff4b		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13894	.ff4e						E_IND3V: ; ff4e
13895	.ff4e		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint

13897							;-------------------------------------------------------------------------

13899	.ff51						extendedVectorEntryPoint:
13900							                ; .if CFA3000
13901							                ; ;...
13902							                ; .else
13903							                ; $10b,x = rL
13904	.ff51		48		pha		                pha                 ; $10a,x  (old ROMSEL)
13905	.ff52		48		pha		                pha                 ; $109,x  (old ACCCON)
13906	.ff53		48		pha		                pha                 ; $108,x  (thunk rH)
13907	.ff54		48		pha		                pha                 ; $107,x  (thunk rL)
13908	.ff55		48		pha		                pha                 ; $106,x  (jump dest MSB)
13909	.ff56		48		pha		                pha                 ; $105,x  (jump dest LSB)
13910	.ff57		08		php		                php                 ; $104,x  (P for RTI)
13911	.ff58		48		pha		                pha                 ; $103,x  (old A)
13912	.ff59		da		phx		                phx                 ; $102,x  (old X)
13913	.ff5a		5a		phy		                phy                 ; $101,x  (old Y)
13914	.ff5b		ba		tsx		                tsx
13915	.ff5c		a9 ff		lda #$ff	                lda #>extendedVectorReturnThunk-1
13916	.ff5e		9d 08 01	sta $0108,x	                sta $0108,x
13917	.ff61		a9 8c		lda #$8c	                lda #<extendedVectorReturnThunk-1
13918	.ff63		9d 07 01	sta $0107,x	                sta $0107,x

13920							                ; this routine is only ever called from $ff00, $ff03,
13921							                ; $ff06, etc. - so rL holds vectorIndex*3+2, suitable
13922							                ; for indexing into the extended vector space.
13923	.ff66		bc 0b 01	ldy $010b,x	                ldy $010B,x                  ;Y=vectorIndex*3+2
13924	.ff69		b9 9d 0d	lda $0d9d,y	                lda extendedVectorSpace-2,y  ;get vector LSB
13925	.ff6c		9d 05 01	sta $0105,x	                sta $0105,x                  ;
13926	.ff6f		b9 9e 0d	lda $0d9e,y	                lda extendedVectorSpace-1,y  ;get vector MSB
13927	.ff72		9d 06 01	sta $0106,x	                sta $0106,x
13928	.ff75		a5 f4		lda $f4		                lda $F4
13929	.ff77		9d 0a 01	sta $010a,x	                sta $010A,x
13930	.ff7a		ad 34 fe	lda $fe34	                lda ACCCON
13931	.ff7d		9d 09 01	sta $0109,x	                sta $0109,x

13933							                ; New stack layout:
13934							                ;
13935							                ; $10a,x - old ROMSEL
13936							                ; $109,x - old ACCCON
13937							                ; $108,x - thunk rH
13938							                ; $107,x - thunk rL
13939							                ; $106,x - jump dest MSB
13940							                ; $105,x - jump dest LSB
13941							                ; $104,x - P (for RTI)
13942							                ; $103,x - old A
13943							                ; $102,x - old X
13944							                ; $101,x - old Y

13946	.ff80		20 fa ec	jsr $ecfa	                jsr selectHAZEL
13947	.ff83		b9 9f 0d	lda $0d9f,y	                lda extendedVectorSpace,y    ;get vector ROM number
13948	.ff86		20 5c e5	jsr $e55c	                jsr selectROMA
13949	.ff89		7a		ply		                ply
13950	.ff8a		fa		plx		                plx
13951	.ff8b		68		pla		                pla
13952	.ff8c		40		rti		                rti
13953							;                .endif

13955							;-------------------------------------------------------------------------

13957	.ff8d						extendedVectorReturnThunk:
13958	.ff8d		08		php		                php
13959	.ff8e		48		pha		                pha
13960	.ff8f		da		phx		                phx
13961	.ff90		ba		tsx		                tsx
13962	.ff91		bd 02 01	lda $0102,x	                lda $0102,x
13963	.ff94		9d 06 01	sta $0106,x	                sta $0106,x
13964	.ff97		bd 03 01	lda $0103,x	                lda $0103,x
13965	.ff9a		9d 07 01	sta $0107,x	                sta $0107,x
13966	.ff9d		fa		plx		                plx
13967	.ff9e		68		pla		                pla
13968	.ff9f		68		pla		                pla
13969	.ffa0		68		pla		                pla
13970	.ffa1		20 f0 ec	jsr $ecf0	                jsr selectMOSOrHAZEL
13971	.ffa4		68		pla		                pla
13972	.ffa5		20 5c e5	jsr $e55c	                jsr selectROMA
13973	.ffa8		68		pla		                pla
13974	.ffa9		28		plp		                plp
13975	.ffaa						rtsFFAA:
13976	.ffaa		60		rts		                rts

13978							;-------------------------------------------------------------------------
13979							;
13980							; OSBYTE 150 (&96) Read from SHEILA (&FE00 - &FEFF) [MasRef D.2-45]
13981							;
13982	.ffab						osbyte96:
13983	.ffab		bc 00 fe	ldy $fe00,x	                ldy $fe00,x
13984	.ffae		60		rts		                rts

13986							;-------------------------------------------------------------------------
13987							;
13988							; OSBYTE 157 (&9D) Write byte across Tube [MasRef D.2-48]
13989							;
13990	.ffaf						osbyte9D:
13991	.ffaf		8a		txa		                txa
13992	.ffb0		80 22		bra $ffd4	                bra OSBPUT

13994	.ffb2		00		brk #		                brk

13996							;-------------------------------------------------------------------------
13997	.ffb3						OSWRSC:
13998	.ffb3		4c af f3	jmp $f3af	                jmp oswrscEntryPoint ; FFB3
13999	>ffb6		36				                .byte defaultVectorTable.end-defaultVectorTable ;
14000	>ffb7		e7 e2				                .word defaultVectorTable ;
14001	.ffb9						OSRDSC:
14002	.ffb9		4c a9 f3	jmp $f3a9	                jmp osrdscEntryPoint ; FFB9
14003	.ffbc						VDUCHR:
14004	.ffbc		4c 99 f3	jmp $f399	                jmp vduChrEntryPoint ; FFBC
14005	.ffbf						OSEVEN:
14006	.ffbf		4c ec e9	jmp $e9ec	                jmp eventEntryPoint ; FFBF
14007	.ffc2						GSINIT:
14008	.ffc2		4c e1 f1	jmp $f1e1	                jmp gsinitEntryPoint ; FFC2
14009	.ffc5						GSREAD:
14010	.ffc5		4c f2 f1	jmp $f1f2	                jmp gsreadEntryPoint ; FFC5
14011	.ffc8						NVRDCH:
14012	.ffc8		4c 88 e7	jmp $e788	                jmp osrdchEntryPoint                    ; FFC8
14013	.ffcb						NVWRCH:
14014	.ffcb		4c ee e7	jmp $e7ee	                jmp oswrchEntryPoint                    ; FFCB
14015	.ffce						OSFIND:
14016	.ffce		4c 57 f7	jmp $f757	                jmp osfindEntryPoint                    ; FFCE
14017	.ffd1						OSGBPB:
14018	.ffd1		4c fa f6	jmp $f6fa	                jmp osgbpbEntryPoint                    ; FFD1
14019	.ffd4						OSBPUT:
14020	.ffd4		4c ee f6	jmp $f6ee	                jmp osbputEntryPoint                    ; FFD4
14021	.ffd7						OSBGET:
14022	.ffd7		4c f4 f6	jmp $f6f4	                jmp osbgetEntryPoint                    ; FFD7
14023	.ffda						OSARGS:
14024	.ffda		4c 23 f7	jmp $f723	                jmp osargsEntryPoint ; FFDA
14025	.ffdd						OSFILE:
14026	.ffdd		4c 66 f7	jmp $f766	                jmp osfileEntryPoint ; FFDD
14027	.ffe0						OSRDCH:
14028	.ffe0		6c 10 02	jmp ($0210)	                jmp (RDCHV)                  ; FFE0
14029	.ffe3						OSASCI:
14030	.ffe3		c9 0d		cmp #$0d	                cmp #$0D                     ; FFE3
14031	.ffe5		d0 07		bne $ffee	                bne OSWRCH                   ; FFE5
14032	.ffe7						OSNEWL:
14033	.ffe7		a9 0a		lda #$0a	                lda #$0A                     ; FFE7
14034	.ffe9		20 ee ff	jsr $ffee	                jsr OSWRCH                   ; FFE9
14035	.ffec		a9 0d		lda #$0d	                lda #$0D                     ; FFEC
14036	.ffee						OSWRCH:
14037	.ffee		6c 0e 02	jmp ($020e)	                jmp (WRCHV)                  ; FFEE
14038	.fff1						OSWORD:
14039	.fff1		6c 0c 02	jmp ($020c)	                jmp (WORDV)                  ; FFF1
14040	.fff4						OSBYTE:
14041	.fff4		6c 0a 02	jmp ($020a)	                jmp (BYTEV)                  ; FFF4
14042	.fff7						OSCLI:
14043	.fff7		6c 08 02	jmp ($0208)	                jmp (CLIV)                  ; FFF7

14045	.fffa						LFFFA:                                       ; FFFA NMIV
14046	>fffa		00 0d				                .word nmiEntryPoint
14047	.fffc						LFFFC:                                       ; FFFB RESETV
14048	>fffc		74 e3				                .word resetEntryPoint
14049	.fffe						LFFFE:                                       ; FFFE IRQV
14050	>fffe		68 e5				                .word irqEntryPoint


:1	;******  Return to file: mos350.s65

37							                .endsection


;******  End of listing
