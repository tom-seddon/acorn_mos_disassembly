
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass.exe --m65c02 --nostart -Wall -q --case-sensitive --line-numbers --verbose-list -Lbuild/mos400.lst --output-section mos -o build/400/mos.rom --output-section utils -o build/400/utils.rom mos400.s65
; Tue Jan 02 20:24:18 2024

;Line	;Offset	;PC	;Hex		;Monitor	;Source

:1	;******  Processing input file: mos400.s65

1							                .include "src/hardware.s65"

:2	;******  Processing file: src/hardware.s65

1							;-------------------------------------------------------------------------

3							                .virtual $fe00

5	.fe00						CRTC: .block

7							                .virtual 8
8	.0008						R8: .block
9	=$00						normalSync=%00000000
10	=$01						interlaceSync=%00000001
11	=$02						normalSyncAlt=%00000010
12	=$03						interlaceSyncAndVideo=%00000011

14	=0						displayDelay0=0<<4
15	=16						displayDelay1=1<<4
16	=32						displayDelay2=2<<4
17	=48						displayDisable=3<<4

19	=0						cursorDelay0=0<<6
20	=64						cursorDelay1=1<<6
21	=128						cursorDelay2=2<<6
22	=192						cursorDisable=3<<6
23							                .endblock
24							                .endvirtual

26							                .virtual 10
27	.000a						R10: .block
28	=$40						blink=$40
29	=$20						slowBlink=$20
30							                .endblock
31							                .endvirtual

33							                .endblock

35							                .endvirtual

37							;-------------------------------------------------------------------------
38							; ACIA=$fe08
39	=$fe10						SERPROC=$fe10
40							;HADC=$fe18
41							                .if includeTubeSupport
42	=$fee0						TUBE=$fee0
43							                .endif
44	=$fe30						ROMSEL=$fe30
45							;ACCCON=$fe34
46							                .virtual $fe20
47	.fe20						VCONTROL: .block
48	=$01						flash=$01
49	=$02						isTeletext=$02
50	=$00						shift2MHz=$00
51	=$04						shift4MHz=$04
52	=$08						shift8MHz=$08
53	=$0c						shift16MHz=$0c
54	=$00						crtc1MHz=$00
55	=$10						crtc2MHz=$10
56	=$00						cursor____=$00
57	=$20						cursor__XX=$20
58	=$40						cursor_X__=$40
59	=$60						cursor_XXX=$60
60	=$80						cursorX___=$80
61	=$a0						cursorX_XX=$a0
62	=$c0						cursorXX__=$c0
63	=$e0						cursorXXXX=$e0
64							                .endblock
65							                .endvirtual
66	=$fe21						VPALETTE=$fe21

68							;-------------------------------------------------------------------------

70							                .virtual $fe08
71	.fe08						ACIA: .block

73	.fe08						control: .block
74	=0						counterDivide1=0<<0
75	=1						counterDivide16=1<<0
76	=2						counterDivide64=2<<0
77	=3						reset=3<<0

79	=0						word7DataEventParity2Stop=0<<2
80	=4						word7DataOddParity2Stop=1<<2
81	=8						word7DataEvenParity1Stop=2<<2
82	=12						word7DataOddParity1Stop=3<<2
83	=16						word8DataNoParity2Stop=4<<2
84	=20						word8DataNoParity1Stop=5<<2
85	=24						word8DataEvenParity1Stop=6<<2
86	=28						word8DataOddParity1Stop=7<<2

88	=0						rtsLowTXInterruptDisabled=0<<5
89	=32						rtsLowTXInterruptEnabled=1<<5
90	=64						rtsHighTXInterruptDisabled=2<<5
91	=96						rtsLowBreakTXInterruptDisabled=3<<5

93	=0						rtsRXInterruptDisabled=0<<7
94	=128						rtsRTSInterruptEnabled=1<<7

96							                .endblock
97	.fe08						status: .block
98							                .endblock

100	>fe08						                .fill 1
101	.fe09						tdr:
102	.fe09						rdr:
103	>fe09						                .fill 1
104							                .endblock
105							                .endvirtual

107							;-------------------------------------------------------------------------

109							                .virtual $fe18
110	.fe18						HADC: .block
111	.fe18						status: .block
112							                .endblock
113	.fe18						latch: .block
114							                .endblock
115	>fe18						                .fill 1

117							                .endblock
118							                .endvirtual

120							;-------------------------------------------------------------------------

122							                .virtual $fe34
123	.fe34						ACCCON: .block
124							;D=1 = display shadow RAM; D=0 = display main RAM
125	=$01						D=$01

127							;E=1 = VDU code ($c000-$dfff in MOS ROM) accesses shadow RAM; E=0 =
128							;VDU code accesses main RAM
129	=$02						E=$02

131							;X=1 = shadow RAM at $3000; X=0 = main RAM at $3000
132	=$04						X=$04

134							;Y=1 = HAZEL at $c000; Y=0 = MOS ROM at $c000
135	=$08						Y=$08

137							;ITU=1 = access internal Tube; ITU=0 = access external Tube
138	=$10						ITU=$10

140							;IFJ=1 = $fc00...$fdff accesses cartridge; IFJ=0 = $fc00...$fdff
141							;accesses 1MHz bus
142	=$20						IFJ=$20

144							; TST=1 = read MOS ROM at $fc00...$feff; TST=0 = read I/O at
145							; $fc00...$feff
146	=$40						TST=$40

148							;IRR=1 = IRQ to CPU
149	=$80						IRR=$80
150							                .bend
151							                .endv

153							                VIA: .struct                    ;
154	.0000						orb:
155	.0000						irb:
156	>0000						                .fill 1         ;0
157	.0001						ora:
158	.0001						ira:
159	>0001						                .fill 1         ;1
160	.0002						ddrb:
161	>0002						                .fill 1         ;2
162	.0003						ddra:
163	>0003						                .fill 1         ;3
164	.0004						t1cL:
165	>0004						                .fill 1         ;4
166	.0005						t1cH:
167	>0005						                .fill 1         ;5
168	.0006						t1lL:
169	>0006						                .fill 1         ;6
170	.0007						t1lH:
171	>0007						                .fill 1         ;7
172	.0008						t2cL:
173	>0008						                .fill 1         ;8
174	.0009						t2cH:
175	>0009						                .fill 1         ;9
176	.000a						sr:
177	>000a						                .fill 1         ;10
178	.000b						acr: .block
179	=0						t1OneShot=0<<6
180	=64						t1Continuous=1<<6
181	=128						t1OneShotPB7=2<<6
182	=192						t1ContinuousPB7=3<<6

184	=0						t2Timer=0<<5
185	=32						t2CountPB6=1<<5

187	=0						srDisabled=0<<2
188	=4						srShiftInT2=1<<2
189	=8						srShiftInVIAClock=2<<2
190	=12						srShiftInExtClock=3<<2
191	=16						srShiftOutT2FreeRun=4<<2
192	=20						srShiftOutT2=5<<2
193	=24						srShiftOutVIAClock=6<<2
194	=28						srShiftOutExtClock=7<<2

196	=0						pbLatchDisabled=0<<1
197	=2						pbLatchEnabled=1<<1

199	=0						paLatchDisabled=0<<0
200	=1						paLatchEnabled=1<<0

202	>000b						                .fill 1         ;11
203							                .endblock
204	.000c						pcr: .block

206	=0						cb2InputNegativeActiveEdge=0<<5
207	=32						cb2IndependentInterruptInputNegativeEdge=1<<5
208	=64						cb2InputPositiveEdge=2<<5
209	=96						cb2IndependentInterruptInputPositiveEdge=3<<5
210	=128						cb2HandshakeOutput=4<<5
211	=160						cb2PulseOutput=5<<5
212	=192						cb2LowOutput=6<<5
213	=224						cb2HighOutput=7<<5

215	=0						cb1NegativeActiveEdge=0<<4
216	=16						cb1PositiveActiveEdge=1<<4

218	=0						ca2InputNegativeActiveEdge=0<<1
219	=2						ca2IndependentInterruptInputNegativeEdge=1<<1
220	=4						ca2InputPositiveEdge=2<<1
221	=6						ca2IndependentInterruptInputPositiveEdge=3<<1
222	=8						ca2HandshakeOutput=4<<1
223	=10						ca2PulseOutput=5<<1
224	=12						ca2LowOutput=6<<1
225	=14						ca2HighOutput=7<<1

227	=0						ca1NegativeActiveEdge=0<<0
228	=1						ca1PositiveActiveEdge=1<<0

230	>000c						                .fill 1         ;12
231							                .endblock
232	.000d						ifr:
233	>000d						                .fill 1         ;13
234	.000e						ier:
235	>000e						                .fill 1         ;14
236	.000f						oraNoHandshake:
237	.000f						iraNoHandshake:
238	>000f						                .fill 1         ;15

240	.0010						irq: .block
241	=1						ca2=1
242	=2						ca1=2
243	=4						sr=4
244	=8						cb2=8
245	=16						cb1=16
246	=32						t2=32
247	=64						t1=64
248							                .endblock
249							                .ends

251							; System VIA port B bits for Master Compact
252	=$20						i2cClock=$20
253	=$10						i2cData=$10

255							; PCD8572 command codes

257							;   7   6   5   4   3   2   1   0
258							; +---+---+---+---+---+---+---+---+
259							; | 1 | 0 | 1 | 0 |A2 |A1 |A0 |RnW|
260							; +---+---+---+---+---+---+---+---+

262	=$a1						eepromRead=$a1
263	=$a0						eepromWrite=$a0
264							                                .virtual $fe40
265	.fe40						systemVIA: .dstruct VIA
154	.fe40						orb:
155	.fe40						irb:
156	>fe40						                .fill 1         ;0
157	.fe41						ora:
158	.fe41						ira:
159	>fe41						                .fill 1         ;1
160	.fe42						ddrb:
161	>fe42						                .fill 1         ;2
162	.fe43						ddra:
163	>fe43						                .fill 1         ;3
164	.fe44						t1cL:
165	>fe44						                .fill 1         ;4
166	.fe45						t1cH:
167	>fe45						                .fill 1         ;5
168	.fe46						t1lL:
169	>fe46						                .fill 1         ;6
170	.fe47						t1lH:
171	>fe47						                .fill 1         ;7
172	.fe48						t2cL:
173	>fe48						                .fill 1         ;8
174	.fe49						t2cH:
175	>fe49						                .fill 1         ;9
176	.fe4a						sr:
177	>fe4a						                .fill 1         ;10
178	.fe4b						acr: .block
179	=0						t1OneShot=0<<6
180	=64						t1Continuous=1<<6
181	=128						t1OneShotPB7=2<<6
182	=192						t1ContinuousPB7=3<<6

184	=0						t2Timer=0<<5
185	=32						t2CountPB6=1<<5

187	=0						srDisabled=0<<2
188	=4						srShiftInT2=1<<2
189	=8						srShiftInVIAClock=2<<2
190	=12						srShiftInExtClock=3<<2
191	=16						srShiftOutT2FreeRun=4<<2
192	=20						srShiftOutT2=5<<2
193	=24						srShiftOutVIAClock=6<<2
194	=28						srShiftOutExtClock=7<<2

196	=0						pbLatchDisabled=0<<1
197	=2						pbLatchEnabled=1<<1

199	=0						paLatchDisabled=0<<0
200	=1						paLatchEnabled=1<<0

202	>fe4b						                .fill 1         ;11
203							                .endblock
204	.fe4c						pcr: .block

206	=0						cb2InputNegativeActiveEdge=0<<5
207	=32						cb2IndependentInterruptInputNegativeEdge=1<<5
208	=64						cb2InputPositiveEdge=2<<5
209	=96						cb2IndependentInterruptInputPositiveEdge=3<<5
210	=128						cb2HandshakeOutput=4<<5
211	=160						cb2PulseOutput=5<<5
212	=192						cb2LowOutput=6<<5
213	=224						cb2HighOutput=7<<5

215	=0						cb1NegativeActiveEdge=0<<4
216	=16						cb1PositiveActiveEdge=1<<4

218	=0						ca2InputNegativeActiveEdge=0<<1
219	=2						ca2IndependentInterruptInputNegativeEdge=1<<1
220	=4						ca2InputPositiveEdge=2<<1
221	=6						ca2IndependentInterruptInputPositiveEdge=3<<1
222	=8						ca2HandshakeOutput=4<<1
223	=10						ca2PulseOutput=5<<1
224	=12						ca2LowOutput=6<<1
225	=14						ca2HighOutput=7<<1

227	=0						ca1NegativeActiveEdge=0<<0
228	=1						ca1PositiveActiveEdge=1<<0

230	>fe4c						                .fill 1         ;12
231							                .endblock
232	.fe4d						ifr:
233	>fe4d						                .fill 1         ;13
234	.fe4e						ier:
235	>fe4e						                .fill 1         ;14
236	.fe4f						oraNoHandshake:
237	.fe4f						iraNoHandshake:
238	>fe4f						                .fill 1         ;15

240	.fe50						irq: .block
241	=1						ca2=1
242	=2						ca1=2
243	=4						sr=4
244	=8						cb2=8
245	=16						cb1=16
246	=32						t2=32
247	=64						t1=64
248							                .endblock
249							                .ends
266							                .endv

268							                .virtual $fe60
269	.fe60						userVIA: .dstruct VIA
154	.fe60						orb:
155	.fe60						irb:
156	>fe60						                .fill 1         ;0
157	.fe61						ora:
158	.fe61						ira:
159	>fe61						                .fill 1         ;1
160	.fe62						ddrb:
161	>fe62						                .fill 1         ;2
162	.fe63						ddra:
163	>fe63						                .fill 1         ;3
164	.fe64						t1cL:
165	>fe64						                .fill 1         ;4
166	.fe65						t1cH:
167	>fe65						                .fill 1         ;5
168	.fe66						t1lL:
169	>fe66						                .fill 1         ;6
170	.fe67						t1lH:
171	>fe67						                .fill 1         ;7
172	.fe68						t2cL:
173	>fe68						                .fill 1         ;8
174	.fe69						t2cH:
175	>fe69						                .fill 1         ;9
176	.fe6a						sr:
177	>fe6a						                .fill 1         ;10
178	.fe6b						acr: .block
179	=0						t1OneShot=0<<6
180	=64						t1Continuous=1<<6
181	=128						t1OneShotPB7=2<<6
182	=192						t1ContinuousPB7=3<<6

184	=0						t2Timer=0<<5
185	=32						t2CountPB6=1<<5

187	=0						srDisabled=0<<2
188	=4						srShiftInT2=1<<2
189	=8						srShiftInVIAClock=2<<2
190	=12						srShiftInExtClock=3<<2
191	=16						srShiftOutT2FreeRun=4<<2
192	=20						srShiftOutT2=5<<2
193	=24						srShiftOutVIAClock=6<<2
194	=28						srShiftOutExtClock=7<<2

196	=0						pbLatchDisabled=0<<1
197	=2						pbLatchEnabled=1<<1

199	=0						paLatchDisabled=0<<0
200	=1						paLatchEnabled=1<<0

202	>fe6b						                .fill 1         ;11
203							                .endblock
204	.fe6c						pcr: .block

206	=0						cb2InputNegativeActiveEdge=0<<5
207	=32						cb2IndependentInterruptInputNegativeEdge=1<<5
208	=64						cb2InputPositiveEdge=2<<5
209	=96						cb2IndependentInterruptInputPositiveEdge=3<<5
210	=128						cb2HandshakeOutput=4<<5
211	=160						cb2PulseOutput=5<<5
212	=192						cb2LowOutput=6<<5
213	=224						cb2HighOutput=7<<5

215	=0						cb1NegativeActiveEdge=0<<4
216	=16						cb1PositiveActiveEdge=1<<4

218	=0						ca2InputNegativeActiveEdge=0<<1
219	=2						ca2IndependentInterruptInputNegativeEdge=1<<1
220	=4						ca2InputPositiveEdge=2<<1
221	=6						ca2IndependentInterruptInputPositiveEdge=3<<1
222	=8						ca2HandshakeOutput=4<<1
223	=10						ca2PulseOutput=5<<1
224	=12						ca2LowOutput=6<<1
225	=14						ca2HighOutput=7<<1

227	=0						ca1NegativeActiveEdge=0<<0
228	=1						ca1PositiveActiveEdge=1<<0

230	>fe6c						                .fill 1         ;12
231							                .endblock
232	.fe6d						ifr:
233	>fe6d						                .fill 1         ;13
234	.fe6e						ier:
235	>fe6e						                .fill 1         ;14
236	.fe6f						oraNoHandshake:
237	.fe6f						iraNoHandshake:
238	>fe6f						                .fill 1         ;15

240	.fe70						irq: .block
241	=1						ca2=1
242	=2						ca1=2
243	=4						sr=4
244	=8						cb2=8
245	=16						cb1=16
246	=32						t2=32
247	=64						t1=64
248							                .endblock
249							                .ends
270							                .endv

272							                .if includeTubeSupport
273							                .virtual $fee0
274	.fee0						tube: .block
275							; Parasite to Host: Carries the OSWRCH call. Data register is a FIFO
276							; that can handle a VDU command length (10 bytes).
277							;
278							; Host to Parasite: There is a 1 byte buffer. It is used to generate
279							; IRQ's in the parasite from events in the host.

281							; write/read (clears IRQ)
282	.fee0						status1: .block
283							; [Tube p13]
284	=$01						Q=$01                           ;enable HIRQ from R4
285	=$02						I=$02                           ;enable PIRQ from R1
286	=$04						J=$04                           ;enable PIRQ from R3
287	=$08						M=$08                           ;enable PNMI from R3
288	=$10						V=$10                           ;2-byte R3
289	=$20						P=$20                           ;activate PRST
290	=$40						T=$40                           ;clear all Tube registers
291	=$80						S=$80                           ;set/clear bits
292							                .bend
293	>fee0						                .fill 1

295							; bit 7 - data available/IRQ
296							; bit 6 - not full
297	.fee1						data1:
298	>fee1						                .fill 1

300							; Used to implement OS calls that take a long time or that cannot
301							; interrupt Host tasks. The parasite passes a byte describing the
302							; required task. The two processors then exchange data until the task
303							; is complete. OS calls handled through this register include: OSRDCH,
304							; OSCLI, OSBYTE, OSWORD, OSBPUT, OSBGET, OSFIND, OSARGS, OSFILE,
305							; OSGBPB.

307							; write/read
308	.fee2						status2:
309	>fee2						                .fill 1

311							; bit 7 - data available
312							; bit 6 - not full
313	.fee3						data2:
314	>fee3						                .fill 1

316							; Used for the background task of fast data transfer between the two
317							; processors.

319							; write/read
320	.fee4						status3:
321	>fee4						                .fill 1

323							; bit 7 - data available/NMI
324							; bit 6 - not full
325	.fee5						data3:
326	>fee5						                .fill 1

328							; Used as the control channel for block transfers going through
329							; Register 3, and also the transfer register for error strings from
330							; host to parasite. In both cases, the host interrupts the parasite by
331							; placing a byte into the Register. In the former case it is a byte
332							; describing the required action, in the latter it is an error code.

334							; write (sets IRQ)/read (clears IRQ)
335	.fee6						status4:
336	>fee6						                .fill 1

338							; bit 7 - data available/IRQ
339							; bit 6 - not full/IRQ
340	.fee7						data4:
341	>fee7						                .fill 1
342							                .bend
343							                .endvirtual
344							                .endif

346							RTC: .struct
347	>0000						seconds: .fill 1
348	>0001						secondsAlarm: .fill 1
349	>0002						minutes: .fill 1
350	>0003						minutesAlarm: .fill 1
351	>0004						hours: .fill 1
352	>0005						hoursAlarm: .fill 1
353	>0006						dayOfWeek: .fill 1
354	>0007						dayOfMonth: .fill 1
355	>0008						month: .fill 1
356	>0009						year: .fill 1
357	.000a						a: .block
358	=7						dvMask=7
359	=4						dvShift=4
360	=0						dv4194304Hz=0<<dvShift
361	=16						dv1048576Hz=1<<dvShift
362	=32						dv32768Hz=2<<dvShift
363	>000a						                .fill 1
364							                .endblock
365	.000b						b: .block
366	=$80						set=$80
367	=$02						_24h=$02
368	=$01						dse=$01
369	>000b						                .fill 1
370							                .endblock
371	.000c						c: .block
372	=$10						uf=$10
373	>000c						                .fill 1
374							                .endblock
375	.000d						d: .block
376	>000d						                .fill 1
377							                .endblock
378	=50						ram_size=50
379	>000e						ram: .fill ram_size
380							                .endstruct


:1	;******  Return to file: mos400.s65

2							                .include "src/mos_workspace.s65"

:3	;******  Processing file: src/mos_workspace.s65

1							;-------------------------------------------------------------------------
2							;
3							; Disorganized jumble of constants. They'll get tidied up at some
4							; point... promise...
5							;
6							;-------------------------------------------------------------------------

8							; The version constant is not very well named: it should really be
9							; something like "acornVersion". It refers to one of the official MOS
10							; versions released for Acorn-branded hardware, and can have one of
11							; the following 6 specific values:
12							;
13							; version=320 - MOS 3.20
14							; version=350 - MOS 3.50
15							; version=400 - MOS 4.00
16							; version=500 - MOS 5.00
17							; version=510 - MOS 5.10
18							; version=511 - MOS 5.11
19							;
20							; (Strictly speaking, these are not numeric, but there's a few
21							; instances of version>=n where this coincidentally makes sense. The
22							; 5.xx series follow on from one another, some of the 4.00 changes are
23							; in 5.xx too, and some of the 4.00 changes that are in 5.xx also made
24							; it into 3.50 as well.)

26							                .cerror !(version==320||version==350||version==400||version==500||version==510||version==511)

28							; All other versions are considered to be variants of one of the six
29							; official versions, as per the variant flags below. These variant
30							; flags are applicable to the stated versions only, and may or may not
31							; be separable from the various version-dependent .if/.endif
32							; constructs for that version. If they're changed from these defaults
33							; for any other version, the output may not make sense.
34							;
35							; Over time I intend to (try to) turn these into feature flags,
36							; according to the actual features they control.

38							                .weak
39							                ; Set if building Olivetti MOS, a variant of 5.10.
40	=false						olivetti=false

42							                ; Set if building CFA3000 MOS, a variant of 3.50.
43	=false						CFA3000=false

45							                ; Set if building Autocue 1500 MOS, a variant of 5.11.
46	=false						autocue=false

48							                ; Set if building MOS 3.29 (Acorn FinMOS), a variant
49							                ; of 3.50.
50	=false						finmos329=false

52							                ; Clear if stripping out the terminal ROM. Applicable
53							                ; to 3.20 or 3.50.
54	=true						includeTerminalROM=true

56							                ; Set if building any of the refresh versions.
57	=false						refreshVersion=false
58							                .endweak

60							;-------------------------------------------------------------------------

62							; These feature flags can be set freely by the main driver file.

64							                .weak

66							                ; If true, include *X. Not clear what this command
67							                ; actually, does, but it's in the original ROMs, so
68							                ; there has to be the option...
69	=true						includeStarX=version<500

71							                ; For some reason, *TAPE and *MOTOR have lower-case
72							                ; command name entries in MOS 4.00.
73	="tape"						tapeCommandString=version==400?"tape":"TAPE"
74	="motor"					motorCommandString=version==400?"motor":"MOTOR"

76							                ; If false, reproduce the OSBYTE $6B/$6C bug present
77							                ; in MOS versions prior to 3.50.
78	=false						correctOSBYTE6B6C=version==350

80							                ; Assumed century for RTC reading purposes.
81	=$19						assumedRTCCenturyBCD=$19

83							                .endweak

85							;-------------------------------------------------------------------------

87							; These feature flags are offered on a best-effort basis. They're more
88							; intended for readability than for use as toggles.

90							                .weak

92							                ; If true, include Tube support.
93							                .if version==320||version==350||version==400
94	=true						includeTubeSupport=true
97							                .endif

99							                .if version==350||version>=500
101							                .else
102	=false						useTableDrivenConfigure=false
103							                .endif

105							                .endweak

107							;-------------------------------------------------------------------------

109							; Some combinations are impossible. Sorry!
110							;
111							; (The code deliberately doesn't try to work around this. The driver
112							; files must avoid these cases.)

114							                .cerror includeStarX&&!includeTubeSupport
115							                .cerror version==400&&!includeTubeSupport

117							                ; Table-driven configuration takes up fewer bytes, so
118							                ; no point trying to switch it off for builds where it
119							                ; would be on.
120							                .cerror (version==350||version>=500)&&!useTableDrivenConfigure

122							;-------------------------------------------------------------------------

124							beword .macro value
127							                .endm


130							;-------------------------------------------------------------------------

132	=$400						tubeHostAddr=$400

134							                .if version==350
146							                .endif

148							;-------------------------------------------------------------------------

150							                .virtual $b0
151	.00b0						sramTransferPointers: .block
152	>00b0						src: .fill 2
153	>00b2						dest: .fill 2
154							                .endblock
155							                .endvirtual

157	=$a8						osargsBuffer=$a8                ;4-byte ZP buffer for use with OSARGS
158	=$b8						printMessageAddress=$b8

160							                .virtual $bb
161	.00bb						tapeCurrentOptionsByte: .block
162							                .endblock
163							                .endvirtual

165							                .virtual $f2
166	.00f2						fsStatusByte: .block
167	=$01						inputFileOpen=$01
168	=$02						outputFileOpen=$02
169	=$08						catStatus=$08
170	=$40						eofReached=$40
171	=$80						eofWarningGiven=$80
172							                .endblock
173							                .endvirtual

175							                .virtual $e4
176	.00e4						stringInputOptions: .block
177	=$80						doubleQuotes=$80
178	=$40						spaceNotATerminator=$40
179	=$01						goodString=$01
180							                .endblock
181							                .endvirtual
182	=$e5						stringInputPlingFlag=$e5        ;bit 7 set if last char was '!'
183	=$e6						readCharacterTimedFlag=$e6
184	=$e7						autoRepeatCountdownTimer=$e7
185	=$eb						tapeCritical=$eb
186	=$ec						lastKeyPressedInternal=$ec
187	=$ed						firstKeyPressedInternal=$ed
188	=$f2						stringInputBufferAddress=$f2    ;word

190							;-------------------------------------------------------------------------

192	=$80						romTypeHasServiceEntry=$80
193	=$40						romTypeHasLanguageEntry=$40
194	=$20						romTypeHasTubeRelocationAddress=$20
195	=$02						romType6502=$02

197							;-------------------------------------------------------------------------

199	=$01						romServiceCallAbsoluteWorkspaceClaim=$01 ; memory used only when ROM is paged in
200	=$02						romServiceCallPrivateWorkspaceClaim=$02 ; memory used even when ROM is not paged in
201	=$03						romServiceCallAutoBoot=$03              ;
202	=$04						romServiceCallUnrecognisedCommand=$04   ; star command not recognised
203	=$05						romServiceCallUnrecognisedInterrupt=$05 ;
204	=$06						romServiceCallBreakInstruction=$06      ;
205	=$07						romServiceCallUnrecognisedOSBYTE=$07    ;
206	=$08						romServiceCallUnrecognisedOSWORD=$08    ;
207	=$09						romServiceCallHelp=$09                  ;
208	=$0a						romServiceCallClaimStaticWorkspace=$0A ; (Issued by paged ROMs, not the OS)
209	=$0b						romServiceCallNMIRelease=$0B    ; (Issued by paged ROMs, not the OS)
210	=$0c						romServiceCallNMIClaim=$0C      ; (Issued by paged ROMs, not the OS)
211	=$0d						romServiceCallROMFilingSystemInitialize=$0D    ;
212	=$0e						romServiceCallROMFilingSystemByteGet=$0E    ;
213	=$0f						romServiceCallVectorsClaimed=$0F    ; Used when a filing system starts
214	=$10						romServiceCallSpoolExecClosureWarning=$10    ;
215							;romServiceCallFontImplosionExplosionWarning=$11    ;
216	=$12						romServiceCallInitialiseFilingSystem=$12    ; (Issued from paged ROMs, not the OS)
217	=$15						romServiceCallPollingInterrupt=$15
218	=$18						romServiceCallReserved=$18
219	=$21						romServiceCallAbsoluteHAZELWorkspaceClaim=$21
220	=$22						romServiceCallPrivateHAZELWorkspaceClam=$22
221	=$23						romServiceCallTopOfHAZELWorkspace=$23
222	=$24						romServiceCallCountDynamicHAZELWorkspace=$24
223	=$25						romServiceCallRequestFSInfo=$25
224	=$26						romServiceCallCloseAllOpenFiles=$26
225	=$27						romServiceCallInformReset=$27
226	=$28						romServiceCallUnknownCONFIG=$28
227	=$29						romServiceCallUnknownSTATUS=$29
228	=$2a						romServiceCallLanguageChange=$2a
229	=$2c						romServiceCallCompactJoystick=$2c
230	=$30						romServiceCall30=$30
231	=$fe						romServiceCallTubeSystemPostInitialisation=$FE    ;
232	=$ff						romServiceCallTubeMainInitialisation=$FF    ;

234							;-------------------------------------------------------------------------

236	=0						fsNone=0
237	=1						fs1200BaudTape=1
238	=2						fs300BaudTape=2
239	=3						fsROM=3

241							; max FS number for all tape/ROM FS types
242	=3						fsTapeOrROMMax=3

244							;-------------------------------------------------------------------------

246							; [MasRef D.2-24]

248	=0						eventOutputBufferEmpty=0
249	=1						eventInputBufferFull=1
250	=2						eventCharacterEnteringBuffer=2
251	=3						eventADCConversionComplete=3
252	=4						eventStartOfVerticalSync=4
253	=5						eventIntervalTimerCrossingZero=5
254	=6						eventESCAPEPressed=6
255	=7						eventRS423Error=7
256	=8						eventNetworkError=8
257	=9						eventUser=9
258	=9						eventMax=9

260							;-------------------------------------------------------------------------

262							; [MasRef D.2-27]

264							; Input buffers
265	=0						bufferKeyboard=0
266	=1						bufferRS423Input=1

268							; Output buffers
269	=2						bufferFirstOutput=2
270	=2						bufferRS423Output=2
271	=3						bufferPrinter=3
272	=4						bufferSoundChannel0=4
273	=5						bufferSoundChannel1=5
274	=6						bufferSoundChannel2=6
275	=7						bufferSoundChannel3=7
276							; What's buffer 8? Previously speech on OS 1.20. There's indices
277							; allocated for it...
278	=8						bufferMax=8


281	=$03e0						bufferKeyboardAddress=$03e0
282	=32						bufferKeyboardSize=32
283	=$0a00						bufferRS423InputAddress=$0a00
284	=256						bufferRS423InputSize=256
285	=$0900						bufferRS423OutputAddress=$0900
286	=192						bufferRS423OutputSize=192
287	=$0880						bufferPrinterAddress=$0880
288	=64						bufferPrinterSize=64
289	=$0840						bufferSoundChannel0Address=$0840
290	=16						bufferSoundChannel0Size=16
291	=$0850						bufferSoundChannel1Address=$0850
292	=16						bufferSoundChannel1Size=16
293	=$0860						bufferSoundChannel2Address=$0860
294	=16						bufferSoundChannel2Size=16
295	=$0870						bufferSoundChannel3Address=$0870
296	=16						bufferSoundChannel3Size=16
297	=$09c0						buffer8Address=$09c0
298	=64						buffer8Size=64



302							; BufferInfo: .function bufferAddress,bufferSizeByte
303							;                 .endfunction (bufferAddress,256-bufferSizeByte)

305							; ; buffer info is (base address,size)
306							;  _:=[]
307							; _..=[BufferInfo($0300,32)];bufferKeyboard=0
308							; _..=[BufferInfo($0a00,256)];bufferRS423Input=1
309							; _..=[BufferInfo($08c0,192)];bufferRS423Output=2
310							; _..=[BufferInfo($07c0,64)];bufferPrinter=3
311							; _..=[BufferInfo($0750,16)];bufferSoundChannel0=4
312							; _..=[BufferInfo($0760,16)];bufferSoundChannel1=5
313							; _..=[BufferInfo($0770,16)];bufferSoundChannel2=6
314							; _..=[BufferInfo($0780,16)];bufferSoundChannel3=7
315							; _..=[BufferInfo($0900,64)];What's buffer 8?

317							;-------------------------------------------------------------------------

319							; [MasRef C.5-5]

321	=0						printerDriverTypeSink=0
322	=1						printerDriverTypeParallel=1
323	=2						printerDriverTypeSerial=2
324	=3						printerDriverTypeUser=3
325	=4						printerDriverTypeNetwork=4

327							; AUG p259

329	=0						printerDriverPoll=0
330	=1						printerDriverActivate=1
331	=2						printerDriverVDU2=2
332	=3						printerDriverVDU3=3
333	=5						printerDriverFX5=5

335	=10						printerDriverFX3=10             ;undocumented???

337							;-------------------------------------------------------------------------

339							; AUG p261

341	=0						netPrinterRequest0=0
342	=1						netPrinterRequest1=1
343	=2						netPrinterRequest2=2
344	=3						netPrinterRequest3=3
345	=4						netWriteCharacterAttempted=4
346	=5						netPrinterRequest5=5
347	=6						netReadCharacterAttempted=6
348	=7						netOSBYTEAttempted=7
349	=8						netOSWORDAttempted=8
350	=13						netOSWORD0Complete=13

352							;-------------------------------------------------------------------------

354							; OSFIND open constants
355	=$40						findOpenForRead=$40
356	=$80						findOpenForWrite=$80

358	=0						fscOPT=0
359	=1						fscCheckEOF=1
360	=2						fscStarSlash=2
361	=3						fscUnknownCommand=3
362	=4						fscStarRUN=4
363	=5						fscStarCAT=5
364	=6						fscNewFS=6
365	=7						fscFileHandleRange=7
366	=8						fscStarCommand=8
367	=9						fscStarEX=9
368	=10						fscStarINFO=10
369	=11						fscRUNLibrary=11

371							; NAUG mentions this. But it doesn't appear to
372							; actually exist in the code.
373							;
374							; Maybe it's present in MOS 3.50 or later?
375	=12						fscRENAME=12

377	=1						gbpbPutBytesNewPTR=1            ;[AUG p340]
378	=2						gbpbPutBytesCurrentPTR=2        ;[AUG p340]
379	=3						gbpbGetBytesNewPTR=3            ;[AUG p341]
380	=4						gbpbGetBytesCurrentPTR=4        ;[AUG p341]
381	=5						gbpbGetMediaMetadata=5          ;[AUG p341]
382	=6						gbpbGetCurrentDevice=6          ;[AUG p341]
383	=7						gbpbGetLibraryDevice=7          ;[AUG p341]
384	=8						gbpbReadFileNames=8             ;[AUG p341]

386							OSGBPBParameterBlock: .struct
387	.0000						handle:
388	>0000						                .fill 1
389	.0001						address:
390	>0001						                .fill 4
391	.0005						count:
392	>0005						                .fill 4
393	.0009						ptr:
394	>0009						                .fill 4
395							                .endstruct

397	=0						argsGetFS=0                     ;[AUG p337]
398	=1						argsGetCommandLine=1            ;[AUG p338]
399	=2						argsCheckANFS=2                 ;https://beebwiki.mdfs.net/OSARGS
400	=3						argsGetLibFS=3                  ;
401	=$ff						argsFlushBuffers=$ff            ;[AUG p338]

403	=0						argsFileGetPTR=0
404	=1						argsFileSetPTR=1
405	=2						argsFileGetEXT=2
406	=$ff						argsFileFlush=$ff

408	=0						fileSave=0                      ;[AUG p336]
409	=1						fileWriteMetadata=1             ;[AUG p336]
410	=2						fileWriteLoadAddress=2          ;[AUG p336]
411	=3						fileWriteExecAddress=3          ;[AUG p336]
412	=4						fileWritettributes=4            ;[AUG p336]
413	=5						fileReadMetadata=5              ;[AUG p336]
414	=6						fileDelete=6                    ;[AUG p336]
415	=$ff						fileLoad=$ff                    ;[AUG p336]

417							OSFILEParameterBlock: .struct
418	.0000						fileName:
419	>0000						                .fill 2
420	.0002						addresses:
421	.0002						load:
422	>0002						                .fill 4
423	.0006						exec:
424	>0006						                .fill 4
425	.000a						length:
426	.000a						saveStart:
427	>000a						                .fill 4
428	.000e						attributes:
429	.000e						saveEnd:
430	>000e						                .fill 4
431							                .endstruct

433							;-------------------------------------------------------------------------

435	=0						bufferNumberKeyboard=0          ;
436	=1						bufferNumberRS423Input=1        ;
437	=2						bufferNumberRS423Output=2       ;
438	=3						bufferNumberPrinter=3           ;
439	=4						bufferNumberSound0=4            ; Noise channel
440	=5						bufferNumberSound1=5            ;
441	=6						bufferNumberSound2=6            ;
442	=7						bufferNumberSound3=7            ;
443							; bufferNumberSpeech=8            ;
444	=8						bufferNumberHighest=8           ;

446							;-------------------------------------------------------------------------

448							                .if includeTubeSupport
449	=0						tubeReasonMultiByteParasiteToHost=0
450	=1						tubeReasonMultiByteHostToParasite=1
451	=4						tubeReasonExecute=4
452	=$c0						tubeReasonClaimMask=$c0
453	=$80						tubeReasonReleaseMask=$80
454							                .endif

456							;-------------------------------------------------------------------------

458							; uservIndex=0
459							; brkvIndex=1
460							; irq1vIndex=2
461							; irq2vIndex=3
462							; clivIndex=4
463							; bytevIndex=5
464							; wordvIndex=6
465							; wrchvIndex=7
466							; rdchvIndex=8
467							; filevIndex=9
468							; argsvIndex=10
469							; bgetvIndex=11
470							; bputvIndex=12
471							; gbpbvIndex=13
472							; findvIndex=14
473							; fscvIndex=15
474							; eventvIndex=16
475							; uptvIndex=17
476							; netvIndex=18
477							; vduvIndex=19
478							; keyvIndex=20
479							; insvIndex=21
480							; remvIndex=22
481							; cnpvIndex=23
482							; ind1vIndex=24
483							; ind2vIndex=25
484							; ind3vIndex=26


487							                .virtual $200
488	.0200						vectors:
489	.0200						USERV:
490	>0200						                .fill 2
491	.0202						BRKV:
492	>0202						                .fill 2
493	.0204						IRQ1V:
494	>0204						                .fill 2
495	.0206						IRQ2V:
496	>0206						                .fill 2
497	.0208						CLIV:
498	>0208						                .fill 2
499	.020a						BYTEV:
500	>020a						                .fill 2
501	.020c						WORDV:
502	>020c						                .fill 2
503	.020e						WRCHV:
504	>020e						                .fill 2
505	.0210						RDCHV:
506	>0210						                .fill 2
507	.0212						FILEV:
508	>0212						                .fill 2
509	.0214						ARGSV:
510	>0214						                .fill 2
511	.0216						BGETV:
512	>0216						                .fill 2
513	.0218						BPUTV:
514	>0218						                .fill 2
515	.021a						GBPBV:
516	>021a						                .fill 2
517	.021c						FINDV:
518	>021c						                .fill 2
519	.021e						FSCV:
520	>021e						                .fill 2
521	.0220						EVENTV:
522	>0220						                .fill 2
523	.0222						UPTV:
524	>0222						                .fill 2
525	.0224						NETV:
526	>0224						                .fill 2
527	.0226						VDUV:
528	>0226						                .fill 2
529	.0228						KEYV:
530	>0228						                .fill 2
531	.022a						INSV:
532	>022a						                .fill 2
533	.022c						REMV:
534	>022c						                .fill 2
535	.022e						CNPV:
536	>022e						                .fill 2
537	.0230						IND1V:
538	>0230						                .fill 2
539	.0232						IND2V:
540	>0232						                .fill 2
541	.0234						IND3V:
542	>0234						                .fill 2
543	.0236						mosVariables:

545							; OSBYTE 166 (&A6) Read start address of MOS variables [MasRef D.2-50]
546							; OSBYTE 167 (&A7) Read start address of MOS variablespointer table  [MasRef D.2-50]
547	>0236						mosVariablesAddress: .fill 2

549							; OSBYTE 168 (&A8) Read address of ROM pointer table [MasRef D.2-51]
550							; OSBYTE 169 (&A9) Read address of ROM pointer table [MasRef D.2-51]
551	>0238						extendedVectorSpaceAddress: .fill 2

553							; OSBYTE 170 (&AA) Read address of ROM information table [MasRef D.2-51]
554							; OSBYTE 171 (&AB) Read address of ROM information table [MasRef D.2-51]
555	>023a						romInformationTableAddress: .fill 2

557							; OSBYTE 172 (&AC) Read address of keyboard translation table [MasRef D.2-52]
558							; OSBYTE 173 (&AD) Read address of keyboard translation table [MasRef D.2-52]
559	>023c						keyboardTranslationTableAddress: .fill 2

561							; OSBYTE 174 (&AE) Read address of VDU variables origin [MasRef D.2-52]
562							; OSBYTE 175 (&AF) Read address of VDU variables origin [MasRef D.2-52]
563	>023e						vduVariablesAddress: .fill 2

565							; OSBYTE 176 (&B0) Read/Write CFS timeout counter [MasRef D.2-52]
566	>0240						cfsTimeoutCounter: .fill 1

568							; OSBYTE 177 (&B1) Read/write input source [MasRef D.2-53]
569	>0241						inputSource: .fill 1

571							; OSBYTE 178 (&B2) Read/write keyboard semaphore [MasRef D.2-53]
572	>0242						keyboardSemaphore: .fill 1

574							; OSBYTE 179 (&B3) Read/write ROM polling semaphore [MasRef D.2-54]
575	>0243						romPollingSemaphore: .fill 1

577							; OSBYTE 180 (&B4) Read/write Operating System High [MasRef D.2-54]
578	>0244						oshwm: .fill 1

580							; OSBYTE 181 (&B5) Read/write RS243 input interpretation [MasRef D.2-54]
581	>0245						rs423InputInterpretationStatus: .fill 1


584							; OSBYTE 182 (&B6) Read NOIGNORE state [MasRef D.2-55]
585							;
586							; TODO - not a great name, no matter how official - should probably be usePrinterIgnoreChar or something
587	>0246						noignoreState: .fill 1

589							; OSBYTE 183 (&B7) Read/write cassette/ROM filing system [MasRef D.2-55]
590	>0247						cfsRFSFSSwitch: .fill 1

592							; OSBYTE 184 (&B8) Read OS copy of video ULA control [MasRef D.2-56]
593	>0248						vcontrolRegister: .fill 1

595							; OSBYTE 185 (&B9) Read OS copy of video ULA palette [MasRef D.2-56]
596	>0249						vpaletteRegister: .fill 1

598							; OSBYTE 186 (&BA) Read ROM number active at last BRK [MasRef D.2-56]
599	>024a						romActiveAtLastBRK: .fill 1

601							; OSBYTE 187 (&BB) Read ROM number of socket [MasRef D.2-57]
602	>024b						basicROMNumber: .fill 1

604							; OSBYTE 188 (&BC) Read current ADC channel number [MasRef D.2-57]
605	>024c						currentADCChannel: .fill 1

607							; OSBYTE 189 (&BD) Read maximum ADC channel number [MasRef D.2-57]
608	>024d						maximumADCChannel: .fill 1

610							; OSBYTE 190 (&BE) Read/write ADC conversion type [MasRef D.2-58]
611	>024e						adcConversionType: .fill 1

613							; OSBYTE 191 (&BF) Read/write RS423 busy flag [MasRef D.2-58]
614	>024f						rs423Busy: .fill 1

616							; OSBYTE 192 (&C0) Read serial ACIA control register [MasRef D.2-58]
617	>0250						aciaControlRegister: .fill 1

619							; OSBYTE 193 (&C1) Read/write flash counter [MasRef D.2-59]
620	>0251						flashCounter: .fill 1

622							; OSBYTE 194 (&C2) Read/write duration of first colour [MasRef D.2-59]
623	>0252						firstFlashColourDuration: .fill 1

625							; OSBYTE 195 (&C3) Read/write duration of second colour [MasRef D.2-60]
626	>0253						secondFlashColourDuration: .fill 1

628							; OSBYTE 196 (&C4) Read/write keyboard auto-repeat delay [MasRef D.2-60]
629	>0254						keyboardAutoRepeatDelay: .fill 1

631							; OSBYTE 197 (&C5) Read/write keyboard auto-repeat rate [MasRef D.2-60]
632	>0255						keyboardAutoRepeatRate: .fill 1

634							; OSBYTE 198 (&C6) Read/write *EXEC file handle [MasRef D.2-61]
635	>0256						execFileHandle: .fill 1

637							; OSBYTE 199 (&C7) Read/write *SPOOL file handle [MasRef D.2-62]
638	>0257						spoolFileHandle: .fill 1

640							; OSBYTE 200 (&C8) Read/write BREAK and ESCAPE effect [MasRef D.2-62]
641	>0258						breakAndESCAPEEffect: .fill 1

643							; OSBYTE 201 (&C9) Read/write keyboard status [MasRef D.2-63]
644	>0259						keyboardStatus: .fill 1

646							; OSBYTE 202 (&CA) Read/write keyboard status byte [MasRef D.2-63]
647	.025a						keyboardStatusByte: .block
648	=$8						shiftPressed=%1<<3
649	=%10000						capsLockDisengaged=%1<<4
650	=%100000					shiftLockDisengaged=%1<<5
651	=%1000000					ctrlPressed=%1<<6
652	=$80						shiftEnabled=%1<<7
653	>025a						                .fill 1
654							                .endblock

656							; OSBYTE 203 (&CB) Read/write RS423 input buffer [MasRef D.2-64]
657	>025b						rs423InputBufferMinimumSpace: .fill 1

659							; OSBYTE 204 (&CC) Read/write RS423 ignore flag [MasRef D.2-65]
660	>025c						rs423Ignore: .fill 1

662							; OSBYTE 205 (&CD) Read/write RS423 destination [MasRef D.2-65]
663	>025d						rs423Destination: .fill 1

665							; OSBYTE 206 (&CE) Read/write Econet OS call interception [MasRef D.2-66]
666	>025e						econetInterceptionStatus: .fill 1

668							; OSBYTE 207 (&CF) Read/write Econet input interpretation [MasRef D.2-66]
669	>025f						econetInputInterpretationStatus: .fill 1

671							; OSBYTE 208 (&D0) Read write Econet output [MasRef D.2-67]
672	>0260						econetOutputInterpretationStatus: .fill 1

674							; OSBYTE 209 (&D1) is reserved for the speech system [MasRef D.2-67]
675	>0261						speechSystemByte1:  .fill 1

677							; OSBYTE 210 (&D2) Read/write sound suppression status [MasRef D.2-67]
678	>0262						soundSuppressionStatus: .fill 1

680							; OSBYTE 211 (&D3) Read/write BELL channel [MasRef D.2-67]
681	>0263						bellChannel: .fill 1

683							; OSBYTE 212 (&D4) Read/write BELL sound information [MasRef D.2-68]
684	>0264						bellSound: .fill 1

686							; OSBYTE 213 (&D5) Read/write BELL frequency [MasRef D.2-69]
687	>0265						bellFrequency: .fill 1

689							; OSBYTE 214 (&D6) Read/write BELL duration [MasRef D.2-69]
690	>0266						bellDuration: .fill 1

692							; OSBYTE 215 (&D7) Read/write startup message [MasRef D.2-69]
693	>0267						startupMessageSuppressionStatus: .fill 1

695							; OSBYTE 216 (&D8) Read/write length of soft key string [MasRef D.2-70]
696	>0268						softKeyStringLength: .fill 1

698							; OSBYTE 217 (&D9) Read/write paged mode line count [MasRef D.2-71]
699	>0269						pagedModeCounter: .fill 1

701							; OSBYTE 218 (&DA) Read/write bytes in VDU queue [MasRef D.2-71]
702	>026a						vduQueueNegativeLength: .fill 1

704							; OSBYTE 219 (&DB) Read/write TAB key code [MasRef D.2-72]
705	>026b						tabKeyCode: .fill 1

707							; OSBYTE 220 (&DC) Read/write ESCAPE character [MasRef D.2-72]
708	>026c						escapeCharacter: .fill 1

710							; OSBYTE 221 (&DD) Read/write interpretation of input values 192-207 [MasRef D.2-73]
711	>026d						input192To207Interpretation: .fill 1

713							; OSBYTE 222 (&DE) Read/write interpretation of input values 208-223 [MasRef D.2-73]
714	>026e						input208To223Interpretation: .fill 1

716							; OSBYTE 223 (&DF) Read/write interpretation of input values 224-239 [MasRef D.2-73]
717	>026f						input224To239Interpretation: .fill 1

719							; OSBYTE 224 (&E0) Read/write interpretation of input values 240-255 [MasRef D.2-73]
720	>0270						input240To255Interpretation: .fill 1

722							; OSBYTE 225 (&E1) Read/write soft key interpretation [MasRef D.2-74]
723	>0271						softKeyInterpretation: .fill 1

725							; OSBYTE 226 (&E2) Read/write SHIFT+soft key interpretation [MasRef D.2-74]
726	>0272						shiftSoftKeyInterpretation: .fill 1

728							; OSBYTE 227 (&E3) Read/write CTRL+soft key interpretation [MasRef D.2-74]
729	>0273						ctrlSoftKeyInterpretation: .fill 1

731							; OSBYTE 228 (&E4) Read/write SHIFT+CTRL+soft key interpretation [MasRef D.2-74]
732	>0274						shiftCtrlSoftKeyInterpretation: .fill 1

734							; OSBYTE 229 (&E5) Read/write ESCAPE key status [MasRef D.2-75]
735	>0275						escapeKeyStatus: .fill 1

737							; OSBYTE 230 (&E6) Read/write ESCAPE effects [MasRef D.2-75]
738	>0276						escapeEffects: .fill 1

740							; OSBYTE 231 (&E7) Read/write IRQ bit mask for user 6522 [MasRef D.2-76]
741	>0277						userVIAInterruptMask: .fill 1

743							; OSBYTE 232 (&E8) Read/write IRQ bit mask for 6850 [MasRef D.2-76]
744	>0278						rs423InterruptMask: .fill 1

746							; OSBYTE 233 (&E9) Read write IRQ bit mask for system [MasRef D.2-76]
747	>0279						systemVIAInterruptMask: .fill 1

749							; OSBYTE 234 (&EA) Read flag indicating Tube presence [MasRef D.2-76]
750							                .if includeTubeSupport
751	>027a						tubePresence: .fill 1
754							                .endif

756							; OSBYTE 235 (&EB) is reserved for the speech system. [MasRef D.2-77]
757	>027b						speechSystemByte2: .fill 1

759							; OSBYTE 236 (&EC) Read/write character destination status [MasRef D.2-77]
760	.027c						characterDestinationStatus: .block
761	>027c						                .fill 1
762	=1						rs423_enable=1
763	=2						vdu_disable=2
764	=4						printer_disable=4               ;printer always off
765	=8						printer_enable=8                ;printer always on
766	=16						spool_disable=16
767	=64						printer_maybe=64                ;printer on when VDU 1 only
768							                .endblock

770							; OSBYTE 237 (&ED) Read/write cursor editing status [MasRef D.2-77]
771	.027d						editKeysMode: .block
772	=0						editKeys=0                      ;edit keys do editing
773	=1						asciiKeys=1                     ;edit keys are ASCII 135-139
774	=2						functionKeys=2                  ;edit keys are F keys 11-15
775	>027d						                .fill 1
776							                .endblock

778							; OSBYTE 238 (&EE) Read/write numeric keypad [MasRef D.2-78]
779	>027e						numericKeypadInterpretation: .fill 1

781							; OSBYTE 239 (&EF) Read/write *SHADOW state [MasRef D.2-78]
782	>027f						shadowRAMState: .fill 1

784							; OSBYTE 240 (&F0) Read country flag [MasRef D.2-79]
785	>0280						countryFlag: .fill 1

787							; OSBYTE 241 (&F1) Read/write user flag [MasRef D.2-79]
788	>0281						userFlag: .fill 1

790							; OSBYTE 242 (&F2) Read copy of serial processor ULA [MasRef D.2-80]
791	>0282						serialULARegister: .fill 1

793							; OSBYTE 243 (&F3) Read timer switch state [MasRef D.2-80]
794							;
795							; The location holds either 5 (initialTimerSwitchState) or 10
796							; (initialTimerSwitchState^15) - i.e., the offset of the byte after
797							; the last of the timer.
798							;
799							; Various offsets are applied to the timer addresses to make this
800							; work.
801	>0283						timerSwitchState: .fill 1

803							; OSBYTE 244 (&F4) Read/write soft key consistency flag [MasRef D.2-81]
804	>0284						softKeyConsistencyFlag: .fill 1

806							; OSBYTE 245 (&F5) Read printer driver type [MasRef D.2-81[
807	>0285						printerDriverType: .fill 1

809							; OSBYTE 246 (&F6) Read/write printer ignore character [MasRef D.2-81]
810	>0286						printerIgnoreChar: .fill 1

812							; OSBYTE 247 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
813	>0287						breakVectorByte0: .fill 1

815							; OSBYTE 248 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
816	>0288						breakVectorByte1: .fill 1

818							; OSBYTE 249 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
819	>0289						breakVectorByte2: .fill 1

821							; OSBYTE 250 (&FA) Read memory written by VDU driver [MasRef D.2-82]
822	>028a						vduDriverMemory: .fill 1

824							; OSBYTE 251 (&FB) Read memory displayed [MasRef D.2-83]
825	>028b						displayMemory: .fill 1

827							; OSBYTE 252 (&FC) Read/write current language ROM number [MasRef D.2-83]
828	>028c						currentLanguageROM: .fill 1

830							; OSBYTE 253 (&FD) Read last BREAK type [MasRef D.2-83]
831	.028d						lastBREAKType: .block
832	>028d						                .fill 1
833	=0						softBREAK=0
834	=1						powerOn=1
835	=2						hardBREAK=2
836							                .endblock
837							; OSBYTE 254 (&FE) Set effect of SHIFT on numeric keypad [MasRef D.2-84]
838	>028e						numericKeypadShiftEffect: .fill 1
839							; OSBYTE 255 (&FF) Read/write startup options [MasRef D.2-84]
840	>028f						startupOptions: .fill 1
841	=7						modeMask=7

843							                .endvirtual

845	=166						firstMOSVariableOSBYTE=166

847	=5						initialTimerSwitchState=5
848	=$290						tvOffset=$290
849	=$291						tvInterlace=$291
850	=$292						timer0=$292
851	=$297						timer1=$297
852	=$29c						intervalTimer=$29c
853	=$2a1						romInformationTable=$2a1
854	=$2b1						inkeyTimeoutCounter=$2b1
855	=$2b3						osword0MaxLineLength=$2b3
856	=$2b4						osword0MinASCIICharacter=$2b4
857	=$2b5						osword0MaxASCIICharacter=$2b5
858	=$2b6						adcResultLSBs=$2b6
859	=$2ba						adcResultMSBs=$2ba
860	=$2be						adcLastChannelRead=$2be         ;Two names for the same thing!
861	=$2be						adcLastConvertedChannel=$2be    ;Two names for the same thing!
862	=$2bf						eventEnabledFlags=$2bf
863	=$02c9						currentSoftKey=$02c9
864	=$02ca						keyboardFirstAutoRepeatCount=$02ca
865	=$2cb						previousKeyPressedWhenReadingLastKey=$2cb
866	=$2cc						previousKeyPressedWhenReadingFirstKey=$2cc
867	=$2cd						previousKeyPressedWhenReadingOSBYTE=$2cd
868							; soundIsUpdatingFlag=$2ce
869	=$2ce						bufferEmptyFlags=$2ce
870	=$2d7						bufferStartIndices=$2d7
871	=$2e0						bufferEndIndices=$2e0

873	=$2e9						tapeInputCurrentBlockSize=$2e9
874	=$2eb						blockFlagOfCurrentlyResidentBlock=$2eb
875	=$2ec						lastCharacterOfCurrentlyResidentBlock=$2ec

877							; Needs a better name, possibly more than one :(
878							;
879							; Used by various file routines to store OSGBPB and OSFILE parameter
880							; blocks.
881							;
882							; Used by the clock routines to hold a (possibly partial) mirror of
883							; the RTC time/date registers.
884							;
885							; Used when parsing hex addresses from the command line - obviously
886							; designed primarily for convenient use when building up the OSFILE
887							; parameter block for use with *LOAD and *SAVE.
888							;
889							; Used by the SRAM utilities to store working data.
890	=$2ed						osfileParameterBlock=$2ed

892							                .virtual osfileParameterBlock
893	.02ed						sramWorkspace: .block
894	>02ed						temp: .fill 1
895	>02ee						type: .fill 1
896	>02ef						length: .fill 2
897	>02f1						bank: .fill 1
898	>02f2						sramAddress: .fill 4
899	>02f6						dataAddress: .fill 4
900							                .endblock
901							                .endvirtual

903							; rtcTempData=$2ee

905							ExtendedVectorAddress: .function vectorAddress
907							                .endfunction extendedVectorSpace+(vectorAddress-vectors)/2*3

909							;-------------------------------------------------------------------------

911	=$d9f						extendedVectorSpace=$d9f

913	=$62						key_space=$62
914	=$66						key_comma=$66
915	=$17						key_minus=$17
916	=$67						key_stop=$67
917	=$68						key_slash=$68
918	=$27						key_0=$27
919	=$30						key_1=$30
920	=$31						key_2=$31
921	=$11						key_3=$11
922	=$12						key_4=$12
923	=$13						key_5=$13
924	=$34						key_6=$34
925	=$24						key_7=$24
926	=$15						key_8=$15
927	=$26						key_9=$26
928	=$48						key_colon=$48
929	=$57						key_semicolon=$57
930	=$47						key_at=$47
931	=$41						key_a=$41
932	=$64						key_b=$64
933	=$52						key_c=$52
934	=$32						key_d=$32
935	=$22						key_e=$22
936	=$43						key_f=$43
937	=$53						key_g=$53
938	=$54						key_h=$54
939	=$25						key_i=$25
940	=$45						key_j=$45
941	=$46						key_k=$46
942	=$56						key_l=$56
943	=$65						key_m=$65
944	=$55						key_n=$55
945	=$36						key_o=$36
946	=$37						key_p=$37
947	=$10						key_q=$10
948	=$33						key_r=$33
949	=$51						key_s=$51
950	=$23						key_t=$23
951	=$35						key_u=$35
952	=$63						key_v=$63
953	=$21						key_w=$21
954	=$42						key_x=$42
955	=$44						key_y=$44
956	=$61						key_z=$61
957	=$38						key_left_square_bracket=$38
958	=$78						key_backslash=$78
959	=$58						key_right_square_bracket=$58
960	=$18						key_caret=$18
961	=$28						key_underline=$28
962	=$70						key_escape=$70
963	=$60						key_tab=$60
964	=$40						key_caps_lock=$40
965	=$1						key_ctrl=$1
966	=$50						key_shift_lock=$50
967	=$0						key_shift=$0
968	=$59						key_delete=$59
969	=$69						key_copy=$69
970	=$49						key_return=$49
971	=$39						key_up=$39
972	=$29						key_down=$29
973	=$19						key_left=$19
974	=$79						key_right=$79
975	=$20						key_f0=$20
976	=$71						key_f1=$71
977	=$72						key_f2=$72
978	=$73						key_f3=$73
979	=$14						key_f4=$14
980	=$74						key_f5=$74
981	=$75						key_f6=$75
982	=$16						key_f7=$16
983	=$76						key_f8=$76
984	=$77						key_f9=$77
985	=$6a						key_numpad_0=$6a
986	=$6b						key_numpad_1=$6b
987	=$7c						key_numpad_2=$7c
988	=$6c						key_numpad_3=$6c
989	=$7a						key_numpad_4=$7a
990	=$7b						key_numpad_5=$7b
991	=$1a						key_numpad_6=$1a
992	=$1b						key_numpad_7=$1b
993	=$2a						key_numpad_8=$2a
994	=$2b						key_numpad_9=$2b
995	=$3a						key_numpad_plus=$3a
996	=$3b						key_numpad_minus=$3b
997	=$4a						key_numpad_divide=$4a
998	=$5a						key_numpad_hash=$5a
999	=$5b						key_numpad_multiply=$5b
1000	=$5c						key_numpad_comma=$5c
1001	=$3c						key_numpad_return=$3c
1002	=$4b						key_numpad_delete=$4b
1003	=$4c						key_numpad_stop=$4c

1005							fsInfoBlock: .struct
1006	>0000						name: .fill 8
1007	>0008						minHandle: .fill 1
1008	>0009						maxHandle: .fill 1
1009	>000a						fsNumber: .fill 1
1010							                .ends

1012							osgbpbBlock: .struct
1013	>0000						handle: .fill 1
1014	>0001						addr: .fill 4
1015	>0005						numBytes: .fill 4
1016	>0009						ptr: .fill 4
1017							                .ends

1019							                ; NAUG p260
1020							                .virtual $dc00
1021	.dc00						hazel: .block
1022	.dc00						commandLine:                    ;dc00
1023	>dc00						                .fill 256
1024	.dd00						ddxx:                           ;dd00
1025	>dd00						                .fill 256
1026	.de00						dexx:
1027	>de00						                .fill 256
1028	.df00						currentFS:                      ;df00
1029	>df00						                .fill 1
1030	.df01						activeFS:                       ;df01
1031	>df01						                .fill 1
1032	.df02						libFS:                          ;df02
1033	>df02						                .fill 1
1034	.df03						currentFSROM:                   ;df03
1035	>df03						                .fill 1
1036	.df04						commandLinePointer:             ;df04
1037	>df04						                .fill 2

1039							                ; 17 info blocks in total, but everything is relative
1040							                ; to the 0th, so there's only a need to instantiate a
1041							                ; struct for that one. Don't think 64tass handles
1042							                ; arrays of structs anyway.
1043	.df06						fsInfoBlocks:   .dstruct fsInfoBlock ;df06
1006	>df06						name: .fill 8
1007	>df0e						minHandle: .fill 1
1008	>df0f						maxHandle: .fill 1
1009	>df10						fsNumber: .fill 1
1010							                .ends
1044	>df11						                .fill 16*size(fsInfoBlock)
1045	.dfc1						fsInfoBlocksTerminator:         ;dfc1
1046							                ; space reserved for the 0 terminator when the full
1047							                ; set of info blocks are filled.
1048	>dfc1						                .fill 1
1049	.dfc2						fsFlags: .block                 ;dfc2
1050	>dfc2						                .fill 1
1051	=$80						useASCII=$80
1052	=$80						isAPPEND=$80
1053	=$40						noLineNumbers=$40
1054							                .bend
1055	.dfc3						lineNumberBCD:                  ;dfc3
1056	>dfc3						                .fill 2
1057	.dfc5						lastCharPrinted:                ;dfc5
1058	>dfc5						                .fill 1
1059	.dfc6						tempFSFlag:                     ;dfc6
1060	>dfc6						                .fill 1
1061	.dfc7						moveOSGBPB: .dstruct osgbpbBlock ;dfc7
1013	>dfc7						handle: .fill 1
1014	>dfc8						addr: .fill 4
1015	>dfcc						numBytes: .fill 4
1016	>dfd0						ptr: .fill 4
1017							                .ends
1062	.dfd4						moveSrcHandle:                  ;dfd4
1063	>dfd4						                .fill 1
1064	.dfd5						moveDestHandle:                 ;dfd5
1065	>dfd5						                .fill 1
1066	.dfd6						moveBufferMSB:                  ;dfd6
1067	>dfd6						                .fill 1
1068	.dfd7						moveNumPages:                   ;dfd7
1069	>dfd7						                .fill 1
1070	.dfd8						moveDestName:                   ;dfd8
1071	>dfd8						                .fill 2
1072	.dfda						activeFSCV:                     ;dfda
1073	>dfda						                .fill 2
1074	.dfdc						oldACCCON:                      ;dfdc
1075	>dfdc						                .fill 1
1076	.dfdd						hasACCCONChanged:                ;dfdd
1077	>dfdd						                .fill 1

1079							                .if version>=350
1080	.dfde						sramBankModes:
1081							                ; pseudo/absolute bank flags, as queried by OSBYTE $45
1084							                .endif
1085	>dfde						                .fill 1
1086							                .bend
1087							                .endv

1089							;-------------------------------------------------------------------------
1090							;
1091							; VDU variables
1092							;
1093							; MasRef E.4-1
1094							;
1095							VDUVariables: .struct
1096	.0000						graphicsWindow:
1097							;graphicsWindowLeftBottom:
1098							; &00 2 Graphics window left column. (p)
1099	>0000						graphicsWindowPixelsLeft: .fill 2
1100							; &02 2 Graphics window bottom row. (p)
1101	>0002						graphicsWindowPixelsBottom: .fill 2
1102							;graphicsWindowRightTop:
1103							; &04 2 Graphics window right column. (p)
1104	>0004						graphicsWindowPixelsRight: .fill 2
1105							; &06 2 Graphics window top row. (p)
1106	>0006						graphicsWindowPixelsTop: .fill 2
1107	.0008						textWindow:
1108							; &08 1 Text window left column.
1109	>0008						textWindowLeft: .fill 1
1110							; &09 1 Text window bottom row.
1111	>0009						textWindowBottom: .fill 1
1112							; &0A 1 Text window right column.
1113	>000a						textWindowRight: .fill 1
1114							; &0B 1 Text window top row.
1115	>000b						textWindowTop: .fill 1
1116							; &0C 2 Graphics origin X coordinate. (e)
1117	>000c						graphicsWindowOriginX: .fill 2
1118							; &0E 2 Graphics origin Y coordinate. (e)
1119	>000e						graphicsWindowOriginY: .fill 2
1120							; &10 2 Graphics cursor X coordinate. (e)
1121	>0010						graphicsCursorPositionX: .fill 2
1122							; &12 2 Graphics cursor Y coordinate. (e)
1123	>0012						graphicsCursorPositionY: .fill 2
1124							; &14 2 Previous graphics cursor X coordinate. (p)
1125	.0014						oldGraphicsCursorPixels:
1126	>0014						oldGraphicsCursorPixelsX: .fill 2
1127							; &16 2 Previous graphics cursor Y coordinate. (p)
1128	>0016						oldGraphicsCursorPixelsY: .fill 2
1129							; &18 1 Text cursor X coordinate (from left of screen) when not cursor editing. When cursor editing, normally the input cursor X coordinate, but the output cursor X coordinate within an "unknown PLOT codes" routine.
1130	>0018						textCursorXPosition: .fill 1
1131							; &19 1 Text cursor Y coordinate (from top of screen) when not cursor editing. When cursor editing, normally t.lsthe input cursor Y coordinate, but the output cursor Y coordinate within an "unknown PLOT codes" routine.
1132	>0019						textCursorYPosition: .fill 1
1133							; &1A 1 Y produced by GADDR (see next section) so that (ZMEMG),Y addresses the correct byte.
1134	>001a						graphicsAddressOffset: .fill 1
1135							; &1B-&23 VDU queue: &23 contains last byte of queue, other bytes immediately precede it.
1136	=9						queueSize=9
1137	>001b						queueBegin: .fill queueSize
1138	.0024						queueEnd:
1139	.0024						graphicsCursorPixels:
1140							; &24 2 Graphics cursor X coordinate. (p)
1141	>0024						graphicsCursorPixelsX: .fill 2
1142							; &26 2 Graphics cursor Y coordinate. (p)
1143	>0026						graphicsCursorPixelsY: .fill 2
1144							; &28-&49 Workspace. But variable &38 must not be used in a Teletext mode (mode 7 or 135).
1145							                .union
1146	.0028						ew: .dstruct EllipseWorkspaceVDUVariables
1344							                ; https://tobylobster.github.io/GXR-pages/gxr/S-s3.html#SP4
1345	.0028						aspectRatio:
1346	>0028						                .fill 3
1347	.002b						shear:
1348	>002b						                .fill 3
1349	.002e						halfHeightCounter:
1350	>002e						                .fill 2
1351	.0030						halfHeightSquared:
1352	>0030						                .fill 4
1353	.0034						pointC:
1354	>0034						                .fill 2
1355	.0036						pointD:
1356	>0036						                .fill 2
1357	.0038						leftPoint:
1358	>0038						                .fill 2
1359	.003a						rightPoint:
1360	>003a						                .fill 2
1361	.003c						pointA:
1362	>003c						                .fill 2
1363	.003e						pointB:
1364	>003e						                .fill 2
1365	.0040						pointE:
1366	>0040						                .fill 2
1367	.0042						currentOffsetX:
1368	>0042						                .fill 2
1369	.0044						plotPointX:
1370	.0044						pointF:
1371	>0044						                .fill 2
1372	.0046						plotPointY:
1373	>0046						                .fill 2
1374							                .endstruct
1147	.0028						hlfw: .dstruct HorizontalLineFillWorkspaceVDUVariables
1409	>0028						                .fill 6
1410	.002e						pixelsX:                        ;2e
1411	>002e						                .fill 2
1412	.0030						pixelsY:                        ;30
1413	>0030						                .fill 2
1414	.0032						pixelsRightEndX:
1415	>0032						                .fill 2         ;32
1416	.0034						pixelsLimitX:                   ;34
1417	>0034						                .fill 2
1418							                .endstruct
1148	.0028						mocr: .dstruct MoveOrCopyRectangleWorkspaceVDUVariables
1387	.0028						src: .dstruct VDUAABB
1268	.0028						min: .dstruct VDUCoordinate
1263	>0028						x: .fill 2
1264	>002a						y: .fill 2
1265							                .endstruct
1269	.002c						max: .dstruct VDUCoordinate
1263	>002c						x: .fill 2
1264	>002e						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1388	.0030						L30:
1389	>0030						                .fill 4
1390	.0034						dest: .dstruct VDUAABB
1268	.0034						min: .dstruct VDUCoordinate
1263	>0034						x: .fill 2
1264	>0036						y: .fill 2
1265							                .endstruct
1269	.0038						max: .dstruct VDUCoordinate
1263	>0038						x: .fill 2
1264	>003a						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1391	.003c						L3C:
1392	>003c						                .fill 4
1393	.0040						L40:
1394	>0040						                .fill 2
1395	.0042						shiftToNextByte:
1396	>0042						                .fill 2
1397	.0044						L44:
1398	>0044						                .fill 1
1399	.0045						copy:
1400	>0045						                .fill 1         ;0=move, 2=copy
1401	.0046						L46:
1402	>0046						                .fill 1
1403	.0047						L47:
1404	>0047						                .fill 1

1406							                .endstruct
1149	.0028						workspace: .dstruct GenericWorkspaceVDUVariables
1273	.0028						_28:
1274	>0028						                .fill 1
1275	.0029						_29:
1276	>0029						                .fill 1
1277	.002a						_2A:
1278	>002a						                .fill 1
1279	.002b						_2B:
1280	>002b						                .fill 1
1281	.002c						_2C:
1282	>002c						                .fill 1
1283	.002d						_2D:
1284	>002d						                .fill 1
1285	.002e						_2E:
1286	>002e						                .fill 1
1287	.002f						_2F:
1288	>002f						                .fill 1
1289	.0030						_30:
1290	>0030						                .fill 1
1291	.0031						_31:
1292	>0031						                .fill 1
1293	.0032						_32:
1294	>0032						                .fill 1
1295	.0033						_33:
1296	>0033						                .fill 1
1297	.0034						_34:
1298	>0034						                .fill 1
1299	.0035						_35:
1300	>0035						                .fill 1
1301	.0036						_36:
1302	>0036						                .fill 1
1303	.0037						_37:
1304	>0037						                .fill 1
1305	.0038						_38:
1306	>0038						                .fill 1
1307	.0039						_39:
1308	>0039						                .fill 1
1309	.003a						_3A:
1310	>003a						                .fill 1
1311	.003b						_3B:
1312	>003b						                .fill 1
1313	.003c						_3C:
1314	>003c						                .fill 1
1315	.003d						_3D:
1316	>003d						                .fill 1
1317	.003e						_3E:
1318	>003e						                .fill 1
1319	.003f						_3F:
1320	>003f						                .fill 1
1321	.0040						_40:
1322	>0040						                .fill 1
1323	.0041						_41:
1324	>0041						                .fill 1
1325	.0042						_42:
1326	>0042						                .fill 1
1327	.0043						_43:
1328	>0043						                .fill 1
1329	.0044						_44:
1330	>0044						                .fill 1
1331	.0045						_45:
1332	>0045						                .fill 1
1333	.0046						_46:
1334	>0046						                .fill 1
1335	.0047						_47:
1336	>0047						                .fill 1
1337	.0048						_48:
1338	>0048						                .fill 1
1339	.0049						_49:
1340	>0049						                .fill 1
1341							                .endstruct
1150							                .endunion
1151							; &4A 2 Address at which the 6845 is to display the text cursor.
1152	>004a						textCursorCRTCAddress: .fill 2
1153							; &4C 2 Number of bytes in a character row of the text window.
1154	>004c						textWindowWidthInBytes: .fill 2
1155							; &4E 1 Most significant byte of address of first byte of screen memory.
1156	>004e						startScreenAddressHighByte: .fill 1
1157							; &4F 1 Number of bytes in a character.
1158	>004f						bytesPerCharacter: .fill 1
1159							; &50 2 Address of byte in top left corner of screen display.
1160	>0050						screenTopLeftAddress: .fill 2
1161							; &52 2 Number of bytes in a character row of the whole screen.
1162	>0052						bytesPerCharacterRow: .fill 2
1163							; &54 1 Most significant byte of number of bytes of screen memory.
1164	>0054						screenSizeHighByte: .fill 1
1165							; &55 1 Current screen mode (in range 0-7, i.e. without regard to 'shadowing').
1166	>0055						currentScreenMODE: .fill 1
1167							; &56 1 Memory mode: 0 for 20K modes, 1 for 16K modes, 2 for 10K modes, 3 for 8K modes, 4 for 1K modes.
1168	>0056						currentScreenMODEGroup: .fill 1
1169							; &57 1 Foreground text colour mask.
1170	>0057						foregroundTextColour: .fill 1
1171							; &58 1 Background text colour mask.
1172	>0058						backgroundTextColour: .fill 1
1173							; &59 1 0 if plotting graphics foreground, 8 if plotting graphics background.
1174	>0059						graphicsPlotState: .fill 1
1175							; &5A 1 Current graphics plot mode (usually set to one of following two reduced mod 16).
1176	>005a						graphicsPlotMode: .fill 1
1177							; &5B 1 Current graphics foreground plot mode (as set by VDU 18).
1178	>005b						foregroundGCOLMode: .fill 1
1179							; &5C 1 Current graphics background plot mode (as set by VDU 18).
1180	>005c						backgroundGCOLMode: .fill 1
1181							; &5D 2 Address of routine to process current VDU sequence.
1182	>005d						jumpVector: .fill 2
1183							; &5F 1 Value for 6845 register 10 to revert to on leaving cursor editing.
1184	>005f						lastCursorStartRegisterValue: .fill 1
1185							; &60 1 (Number of logical colours)-1 (0 if Teletext).
1186	>0060						numberOfLogicalColoursMinusOne: .fill 1
1187							; &61 1 (Number of pixels/byte)-1 (0 if not graphics).
1188	>0061						pixelsPerByteMinusOne: .fill 1
1189							; &62 1 Mask for leftmost pixel in a byte.
1190	>0062						colourMaskLeft: .fill 1
1191							; &63 1 Mask for rightmost pixel in a byte.
1192	>0063						colourMaskRight: .fill 1
1193							; &64 1 Output cursor X coordinate when cursor editing, but input cursor X coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1194	>0064						editCursorXPosition: .fill 1
1195							; &65 1 Output cursor Y coordinate when cursor editing, but input cursor Y coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1196	>0065						editCursorYPosition: .fill 1
1197							; &66 1 Cursor control flags (as set by VDU 23 16).
1198	.0066						cursorFlags: .block
1199	>0066						                .fill 1
1200							; MasRef E.3-18
1201	=$40						noSpecialVDU5Actions=$40
1202	=$20						noMoveCursorAfterPrint=$20
1203	=$10						noVerticalScroll=$10
1204	=$08						swapAxes=$08                    ;if set, X=vert; if clear, X=horiz
1205	=$04						invertVertical=$04              ;if set, vert=up; if clear, vert=down
1206	=$02						invertHorizontal=$02            ;if set, horiz=left; if clear, horiz=right
1207	=$01						scrollProtect=$01
1208							                .endblock
1209							; &67 1 Dot pattern (as set by VDU 23 6).
1210	>0067						dotPattern: .fill 1
1211							; &68 1 Current state of dot pattern.
1212	>0068						dotPatternState: .fill 1
1213							; &69 1 0 if colour being plotted is solid, non-zero if colour is an ECF
1214	>0069						isColourECF: .fill 1
1215							; &6A 1 0 if graphics foreground colour is solid, non-zero if foreground colour is an ECF
1216	>006a						isForegroundECF: .fill 1
1217							; &6B 1 0 if graphics background colour is solid, non-zero if background colour is an ECF
1218	>006b						isBackgroundECF: .fill 1
1219							; &6C 1 Top bit set when cursor is in "column 81".
1220	>006c						column81: .fill 1
1221							; &6D 1 Current graphics foreground colour (as set by VDU 18).
1222	>006d						foregroundGraphicsColour: .fill 1
1223							; &6E 1 Current graphics background colour (as set by VDU 18)
1224	>006e						backgroundGraphicsColour: .fill 1
1225							; &6F-&7E Software copy of the current palette.
1226	>006f						currentPalette: .fill 16
1227							; &7F 1 Reserved.
1228	>007f						reserved: .fill 1
1229							                .endstruct

1231							                .virtual $300
1232	.0300						vduv: .dstruct VDUVariables
1096	.0300						graphicsWindow:
1097							;graphicsWindowLeftBottom:
1098							; &00 2 Graphics window left column. (p)
1099	>0300						graphicsWindowPixelsLeft: .fill 2
1100							; &02 2 Graphics window bottom row. (p)
1101	>0302						graphicsWindowPixelsBottom: .fill 2
1102							;graphicsWindowRightTop:
1103							; &04 2 Graphics window right column. (p)
1104	>0304						graphicsWindowPixelsRight: .fill 2
1105							; &06 2 Graphics window top row. (p)
1106	>0306						graphicsWindowPixelsTop: .fill 2
1107	.0308						textWindow:
1108							; &08 1 Text window left column.
1109	>0308						textWindowLeft: .fill 1
1110							; &09 1 Text window bottom row.
1111	>0309						textWindowBottom: .fill 1
1112							; &0A 1 Text window right column.
1113	>030a						textWindowRight: .fill 1
1114							; &0B 1 Text window top row.
1115	>030b						textWindowTop: .fill 1
1116							; &0C 2 Graphics origin X coordinate. (e)
1117	>030c						graphicsWindowOriginX: .fill 2
1118							; &0E 2 Graphics origin Y coordinate. (e)
1119	>030e						graphicsWindowOriginY: .fill 2
1120							; &10 2 Graphics cursor X coordinate. (e)
1121	>0310						graphicsCursorPositionX: .fill 2
1122							; &12 2 Graphics cursor Y coordinate. (e)
1123	>0312						graphicsCursorPositionY: .fill 2
1124							; &14 2 Previous graphics cursor X coordinate. (p)
1125	.0314						oldGraphicsCursorPixels:
1126	>0314						oldGraphicsCursorPixelsX: .fill 2
1127							; &16 2 Previous graphics cursor Y coordinate. (p)
1128	>0316						oldGraphicsCursorPixelsY: .fill 2
1129							; &18 1 Text cursor X coordinate (from left of screen) when not cursor editing. When cursor editing, normally the input cursor X coordinate, but the output cursor X coordinate within an "unknown PLOT codes" routine.
1130	>0318						textCursorXPosition: .fill 1
1131							; &19 1 Text cursor Y coordinate (from top of screen) when not cursor editing. When cursor editing, normally t.lsthe input cursor Y coordinate, but the output cursor Y coordinate within an "unknown PLOT codes" routine.
1132	>0319						textCursorYPosition: .fill 1
1133							; &1A 1 Y produced by GADDR (see next section) so that (ZMEMG),Y addresses the correct byte.
1134	>031a						graphicsAddressOffset: .fill 1
1135							; &1B-&23 VDU queue: &23 contains last byte of queue, other bytes immediately precede it.
1136	=9						queueSize=9
1137	>031b						queueBegin: .fill queueSize
1138	.0324						queueEnd:
1139	.0324						graphicsCursorPixels:
1140							; &24 2 Graphics cursor X coordinate. (p)
1141	>0324						graphicsCursorPixelsX: .fill 2
1142							; &26 2 Graphics cursor Y coordinate. (p)
1143	>0326						graphicsCursorPixelsY: .fill 2
1144							; &28-&49 Workspace. But variable &38 must not be used in a Teletext mode (mode 7 or 135).
1145							                .union
1146	.0328						ew: .dstruct EllipseWorkspaceVDUVariables
1344							                ; https://tobylobster.github.io/GXR-pages/gxr/S-s3.html#SP4
1345	.0328						aspectRatio:
1346	>0328						                .fill 3
1347	.032b						shear:
1348	>032b						                .fill 3
1349	.032e						halfHeightCounter:
1350	>032e						                .fill 2
1351	.0330						halfHeightSquared:
1352	>0330						                .fill 4
1353	.0334						pointC:
1354	>0334						                .fill 2
1355	.0336						pointD:
1356	>0336						                .fill 2
1357	.0338						leftPoint:
1358	>0338						                .fill 2
1359	.033a						rightPoint:
1360	>033a						                .fill 2
1361	.033c						pointA:
1362	>033c						                .fill 2
1363	.033e						pointB:
1364	>033e						                .fill 2
1365	.0340						pointE:
1366	>0340						                .fill 2
1367	.0342						currentOffsetX:
1368	>0342						                .fill 2
1369	.0344						plotPointX:
1370	.0344						pointF:
1371	>0344						                .fill 2
1372	.0346						plotPointY:
1373	>0346						                .fill 2
1374							                .endstruct
1147	.0328						hlfw: .dstruct HorizontalLineFillWorkspaceVDUVariables
1409	>0328						                .fill 6
1410	.032e						pixelsX:                        ;2e
1411	>032e						                .fill 2
1412	.0330						pixelsY:                        ;30
1413	>0330						                .fill 2
1414	.0332						pixelsRightEndX:
1415	>0332						                .fill 2         ;32
1416	.0334						pixelsLimitX:                   ;34
1417	>0334						                .fill 2
1418							                .endstruct
1148	.0328						mocr: .dstruct MoveOrCopyRectangleWorkspaceVDUVariables
1387	.0328						src: .dstruct VDUAABB
1268	.0328						min: .dstruct VDUCoordinate
1263	>0328						x: .fill 2
1264	>032a						y: .fill 2
1265							                .endstruct
1269	.032c						max: .dstruct VDUCoordinate
1263	>032c						x: .fill 2
1264	>032e						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1388	.0330						L30:
1389	>0330						                .fill 4
1390	.0334						dest: .dstruct VDUAABB
1268	.0334						min: .dstruct VDUCoordinate
1263	>0334						x: .fill 2
1264	>0336						y: .fill 2
1265							                .endstruct
1269	.0338						max: .dstruct VDUCoordinate
1263	>0338						x: .fill 2
1264	>033a						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1391	.033c						L3C:
1392	>033c						                .fill 4
1393	.0340						L40:
1394	>0340						                .fill 2
1395	.0342						shiftToNextByte:
1396	>0342						                .fill 2
1397	.0344						L44:
1398	>0344						                .fill 1
1399	.0345						copy:
1400	>0345						                .fill 1         ;0=move, 2=copy
1401	.0346						L46:
1402	>0346						                .fill 1
1403	.0347						L47:
1404	>0347						                .fill 1

1406							                .endstruct
1149	.0328						workspace: .dstruct GenericWorkspaceVDUVariables
1273	.0328						_28:
1274	>0328						                .fill 1
1275	.0329						_29:
1276	>0329						                .fill 1
1277	.032a						_2A:
1278	>032a						                .fill 1
1279	.032b						_2B:
1280	>032b						                .fill 1
1281	.032c						_2C:
1282	>032c						                .fill 1
1283	.032d						_2D:
1284	>032d						                .fill 1
1285	.032e						_2E:
1286	>032e						                .fill 1
1287	.032f						_2F:
1288	>032f						                .fill 1
1289	.0330						_30:
1290	>0330						                .fill 1
1291	.0331						_31:
1292	>0331						                .fill 1
1293	.0332						_32:
1294	>0332						                .fill 1
1295	.0333						_33:
1296	>0333						                .fill 1
1297	.0334						_34:
1298	>0334						                .fill 1
1299	.0335						_35:
1300	>0335						                .fill 1
1301	.0336						_36:
1302	>0336						                .fill 1
1303	.0337						_37:
1304	>0337						                .fill 1
1305	.0338						_38:
1306	>0338						                .fill 1
1307	.0339						_39:
1308	>0339						                .fill 1
1309	.033a						_3A:
1310	>033a						                .fill 1
1311	.033b						_3B:
1312	>033b						                .fill 1
1313	.033c						_3C:
1314	>033c						                .fill 1
1315	.033d						_3D:
1316	>033d						                .fill 1
1317	.033e						_3E:
1318	>033e						                .fill 1
1319	.033f						_3F:
1320	>033f						                .fill 1
1321	.0340						_40:
1322	>0340						                .fill 1
1323	.0341						_41:
1324	>0341						                .fill 1
1325	.0342						_42:
1326	>0342						                .fill 1
1327	.0343						_43:
1328	>0343						                .fill 1
1329	.0344						_44:
1330	>0344						                .fill 1
1331	.0345						_45:
1332	>0345						                .fill 1
1333	.0346						_46:
1334	>0346						                .fill 1
1335	.0347						_47:
1336	>0347						                .fill 1
1337	.0348						_48:
1338	>0348						                .fill 1
1339	.0349						_49:
1340	>0349						                .fill 1
1341							                .endstruct
1150							                .endunion
1151							; &4A 2 Address at which the 6845 is to display the text cursor.
1152	>034a						textCursorCRTCAddress: .fill 2
1153							; &4C 2 Number of bytes in a character row of the text window.
1154	>034c						textWindowWidthInBytes: .fill 2
1155							; &4E 1 Most significant byte of address of first byte of screen memory.
1156	>034e						startScreenAddressHighByte: .fill 1
1157							; &4F 1 Number of bytes in a character.
1158	>034f						bytesPerCharacter: .fill 1
1159							; &50 2 Address of byte in top left corner of screen display.
1160	>0350						screenTopLeftAddress: .fill 2
1161							; &52 2 Number of bytes in a character row of the whole screen.
1162	>0352						bytesPerCharacterRow: .fill 2
1163							; &54 1 Most significant byte of number of bytes of screen memory.
1164	>0354						screenSizeHighByte: .fill 1
1165							; &55 1 Current screen mode (in range 0-7, i.e. without regard to 'shadowing').
1166	>0355						currentScreenMODE: .fill 1
1167							; &56 1 Memory mode: 0 for 20K modes, 1 for 16K modes, 2 for 10K modes, 3 for 8K modes, 4 for 1K modes.
1168	>0356						currentScreenMODEGroup: .fill 1
1169							; &57 1 Foreground text colour mask.
1170	>0357						foregroundTextColour: .fill 1
1171							; &58 1 Background text colour mask.
1172	>0358						backgroundTextColour: .fill 1
1173							; &59 1 0 if plotting graphics foreground, 8 if plotting graphics background.
1174	>0359						graphicsPlotState: .fill 1
1175							; &5A 1 Current graphics plot mode (usually set to one of following two reduced mod 16).
1176	>035a						graphicsPlotMode: .fill 1
1177							; &5B 1 Current graphics foreground plot mode (as set by VDU 18).
1178	>035b						foregroundGCOLMode: .fill 1
1179							; &5C 1 Current graphics background plot mode (as set by VDU 18).
1180	>035c						backgroundGCOLMode: .fill 1
1181							; &5D 2 Address of routine to process current VDU sequence.
1182	>035d						jumpVector: .fill 2
1183							; &5F 1 Value for 6845 register 10 to revert to on leaving cursor editing.
1184	>035f						lastCursorStartRegisterValue: .fill 1
1185							; &60 1 (Number of logical colours)-1 (0 if Teletext).
1186	>0360						numberOfLogicalColoursMinusOne: .fill 1
1187							; &61 1 (Number of pixels/byte)-1 (0 if not graphics).
1188	>0361						pixelsPerByteMinusOne: .fill 1
1189							; &62 1 Mask for leftmost pixel in a byte.
1190	>0362						colourMaskLeft: .fill 1
1191							; &63 1 Mask for rightmost pixel in a byte.
1192	>0363						colourMaskRight: .fill 1
1193							; &64 1 Output cursor X coordinate when cursor editing, but input cursor X coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1194	>0364						editCursorXPosition: .fill 1
1195							; &65 1 Output cursor Y coordinate when cursor editing, but input cursor Y coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1196	>0365						editCursorYPosition: .fill 1
1197							; &66 1 Cursor control flags (as set by VDU 23 16).
1198	.0366						cursorFlags: .block
1199	>0366						                .fill 1
1200							; MasRef E.3-18
1201	=$40						noSpecialVDU5Actions=$40
1202	=$20						noMoveCursorAfterPrint=$20
1203	=$10						noVerticalScroll=$10
1204	=$08						swapAxes=$08                    ;if set, X=vert; if clear, X=horiz
1205	=$04						invertVertical=$04              ;if set, vert=up; if clear, vert=down
1206	=$02						invertHorizontal=$02            ;if set, horiz=left; if clear, horiz=right
1207	=$01						scrollProtect=$01
1208							                .endblock
1209							; &67 1 Dot pattern (as set by VDU 23 6).
1210	>0367						dotPattern: .fill 1
1211							; &68 1 Current state of dot pattern.
1212	>0368						dotPatternState: .fill 1
1213							; &69 1 0 if colour being plotted is solid, non-zero if colour is an ECF
1214	>0369						isColourECF: .fill 1
1215							; &6A 1 0 if graphics foreground colour is solid, non-zero if foreground colour is an ECF
1216	>036a						isForegroundECF: .fill 1
1217							; &6B 1 0 if graphics background colour is solid, non-zero if background colour is an ECF
1218	>036b						isBackgroundECF: .fill 1
1219							; &6C 1 Top bit set when cursor is in "column 81".
1220	>036c						column81: .fill 1
1221							; &6D 1 Current graphics foreground colour (as set by VDU 18).
1222	>036d						foregroundGraphicsColour: .fill 1
1223							; &6E 1 Current graphics background colour (as set by VDU 18)
1224	>036e						backgroundGraphicsColour: .fill 1
1225							; &6F-&7E Software copy of the current palette.
1226	>036f						currentPalette: .fill 16
1227							; &7F 1 Reserved.
1228	>037f						reserved: .fill 1
1229							                .endstruct
1233							                .endvirtual

1235							; vduQueueItemAddr: .function index
1236							;                 .cerror index<0||index>=vdu.queueSize,"bad VDU queue index"
1237							;                 .endfunction vdu.queue+vdu.queueSize-1-index

1239							; Presumed addresses in ANDY that don't happen to coincide with other
1240							; labels.
1241							;
1242							; MasRef E.4-5, MasRef F.6-10
1243							;
1244							; &8000-83FF  RAM  Soft key expansions buffer
1245							; &8400-87FF  RAM  VDU workspace.
1246							; &8800-07    RAM  ECF pattern 1 definition.
1247							; &8808-0F    RAM  ECF pattern 2 definition.
1248							; &8810-17    RAM  ECF pattern 3 definition.
1249							; &8818-1F    RAM  ECF pattern 4 definition.
1250							; &8820-27    RAM  Current foreground ECF pattern or solid colour.
1251							; &8828-2F    RAM  Current background ECF pattern or solid colour.
1252							; &8830-BF    RAM  VDU workspace.
1253							; &88C0-FF    RAM  Reserved for future expansion.
1254							; &8900-FF    RAM  Current definitions of characters &20-3F.
1255							; &8A00-FF    RAM  Current definitions of characters &40-5F.
1256							; &8B00-FF    RAM  Current definitions of characters &60-7F.
1257							; &8C00-FF    RAM  Current definitions of characters &80-9F.
1258							; &8D00-FF    RAM  Current definitions of characters &A0-BF.
1259							; &8E00-FF    RAM  Current definitions of characters &C0-DF.
1260							; &8F00-FF    RAM  Current definitions of characters &E0-FF.

1262							VDUCoordinate: .struct
1263	>0000						x: .fill 2
1264	>0002						y: .fill 2
1265							                .endstruct

1267							VDUAABB: .struct
1268	.0000						min: .dstruct VDUCoordinate
1263	>0000						x: .fill 2
1264	>0002						y: .fill 2
1265							                .endstruct
1269	.0004						max: .dstruct VDUCoordinate
1263	>0004						x: .fill 2
1264	>0006						y: .fill 2
1265							                .endstruct
1270							                .endstruct

1272							GenericWorkspaceVDUVariables: .struct
1273	.0000						_28:
1274	>0000						                .fill 1
1275	.0001						_29:
1276	>0001						                .fill 1
1277	.0002						_2A:
1278	>0002						                .fill 1
1279	.0003						_2B:
1280	>0003						                .fill 1
1281	.0004						_2C:
1282	>0004						                .fill 1
1283	.0005						_2D:
1284	>0005						                .fill 1
1285	.0006						_2E:
1286	>0006						                .fill 1
1287	.0007						_2F:
1288	>0007						                .fill 1
1289	.0008						_30:
1290	>0008						                .fill 1
1291	.0009						_31:
1292	>0009						                .fill 1
1293	.000a						_32:
1294	>000a						                .fill 1
1295	.000b						_33:
1296	>000b						                .fill 1
1297	.000c						_34:
1298	>000c						                .fill 1
1299	.000d						_35:
1300	>000d						                .fill 1
1301	.000e						_36:
1302	>000e						                .fill 1
1303	.000f						_37:
1304	>000f						                .fill 1
1305	.0010						_38:
1306	>0010						                .fill 1
1307	.0011						_39:
1308	>0011						                .fill 1
1309	.0012						_3A:
1310	>0012						                .fill 1
1311	.0013						_3B:
1312	>0013						                .fill 1
1313	.0014						_3C:
1314	>0014						                .fill 1
1315	.0015						_3D:
1316	>0015						                .fill 1
1317	.0016						_3E:
1318	>0016						                .fill 1
1319	.0017						_3F:
1320	>0017						                .fill 1
1321	.0018						_40:
1322	>0018						                .fill 1
1323	.0019						_41:
1324	>0019						                .fill 1
1325	.001a						_42:
1326	>001a						                .fill 1
1327	.001b						_43:
1328	>001b						                .fill 1
1329	.001c						_44:
1330	>001c						                .fill 1
1331	.001d						_45:
1332	>001d						                .fill 1
1333	.001e						_46:
1334	>001e						                .fill 1
1335	.001f						_47:
1336	>001f						                .fill 1
1337	.0020						_48:
1338	>0020						                .fill 1
1339	.0021						_49:
1340	>0021						                .fill 1
1341							                .endstruct

1343							EllipseWorkspaceVDUVariables: .struct
1344							                ; https://tobylobster.github.io/GXR-pages/gxr/S-s3.html#SP4
1345	.0000						aspectRatio:
1346	>0000						                .fill 3
1347	.0003						shear:
1348	>0003						                .fill 3
1349	.0006						halfHeightCounter:
1350	>0006						                .fill 2
1351	.0008						halfHeightSquared:
1352	>0008						                .fill 4
1353	.000c						pointC:
1354	>000c						                .fill 2
1355	.000e						pointD:
1356	>000e						                .fill 2
1357	.0010						leftPoint:
1358	>0010						                .fill 2
1359	.0012						rightPoint:
1360	>0012						                .fill 2
1361	.0014						pointA:
1362	>0014						                .fill 2
1363	.0016						pointB:
1364	>0016						                .fill 2
1365	.0018						pointE:
1366	>0018						                .fill 2
1367	.001a						currentOffsetX:
1368	>001a						                .fill 2
1369	.001c						plotPointX:
1370	.001c						pointF:
1371	>001c						                .fill 2
1372	.001e						plotPointY:
1373	>001e						                .fill 2
1374							                .endstruct

1376							HorizontalLineFillWorkspaceZP: .struct
1377	>0000						notByteMatch: .fill 1
1378	>0001						a: .fill 1
1379	>0002						b: .fill 2
1380							;c: .fill 2
1381	>0004						pixelsX: .fill 2
1382	>0006						d: .fill 1
1383	>0007						resultEOR: .fill 1
1384							                .endstruct

1386							MoveOrCopyRectangleWorkspaceVDUVariables: .struct
1387	.0000						src: .dstruct VDUAABB
1268	.0000						min: .dstruct VDUCoordinate
1263	>0000						x: .fill 2
1264	>0002						y: .fill 2
1265							                .endstruct
1269	.0004						max: .dstruct VDUCoordinate
1263	>0004						x: .fill 2
1264	>0006						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1388	.0008						L30:
1389	>0008						                .fill 4
1390	.000c						dest: .dstruct VDUAABB
1268	.000c						min: .dstruct VDUCoordinate
1263	>000c						x: .fill 2
1264	>000e						y: .fill 2
1265							                .endstruct
1269	.0010						max: .dstruct VDUCoordinate
1263	>0010						x: .fill 2
1264	>0012						y: .fill 2
1265							                .endstruct
1270							                .endstruct
1391	.0014						L3C:
1392	>0014						                .fill 4
1393	.0018						L40:
1394	>0018						                .fill 2
1395	.001a						shiftToNextByte:
1396	>001a						                .fill 2
1397	.001c						L44:
1398	>001c						                .fill 1
1399	.001d						copy:
1400	>001d						                .fill 1         ;0=move, 2=copy
1401	.001e						L46:
1402	>001e						                .fill 1
1403	.001f						L47:
1404	>001f						                .fill 1

1406							                .endstruct

1408							HorizontalLineFillWorkspaceVDUVariables: .struct
1409	>0000						                .fill 6
1410	.0006						pixelsX:                        ;2e
1411	>0006						                .fill 2
1412	.0008						pixelsY:                        ;30
1413	>0008						                .fill 2
1414	.000a						pixelsRightEndX:
1415	>000a						                .fill 2         ;32
1416	.000c						pixelsLimitX:                   ;34
1417	>000c						                .fill 2
1418							                .endstruct

1420							HorizontalLineFillWorkspaceANDY: .struct
1421	>0000						ecfPattern: .fill 8
1422							                .endstruct

1424	=16						softKeyCount=16
1425	=$400						softKeyDataTotalSize=$400

1427							                .virtual $8000
1428	.8000						andy: .block
1429	.8000						softKeys: .block
1430	>8000						stringLSBs: .fill softKeyCount
1431	>8010						endLSB: .fill 1
1432	>8011						stringMSBs: .fill softKeyCount
1433	>8021						endMSB: .fill 1
1434	.8022						strings:
1435	>8022						                .fill softKeys+$400-*
1436	.8400						end:
1437							                .endblock
1438	>8400						                .fill $8800-*;(softKeyCount*2+1)
1439	.8800						ecfPatterns:
1440	>8800						ecfPattern1: .fill 8
1441	>8808						ecfPattern2: .fill 8
1442	>8810						ecfPattern3: .fill 8
1443	>8818						ecfPattern4: .fill 8
1444	.8820						currentECFPatterns:
1445	>8820						fgECFPattern: .fill 8
1446	>8828						bgECFPattern: .fill 8
1447	.8830						workspace:
1448							                .union
1449	.8830						hlfw: .dstruct HorizontalLineFillWorkspaceANDY
1421	>8830						ecfPattern: .fill 8
1422							                .endstruct
1450	>8830						                .fill 208
1451							                .endunion
1452	.8900						softCharacterDefinitions:
1453	>8900						                .fill (256-32)*8
1454							                .cerror (<andy.softCharacterDefinitions)!=0,"Soft character definitions must be page aligned"
1455							                .cerror *!=$9000,"ANDY is the wrong size"
1456							                .endblock
1457							                .endvirtual


1460	=$8000						L8000=$8000
1461	=$8001						L8001=$8001
1462	=$8002						L8002=$8002
1463	=$8004						L8004=$8004
1464	=$8010						L8010=$8010
1465	=$8011						L8011=$8011
1466	=$8012						L8012=$8012
1467							                ;l8011=$8011
1468							                ;l8012=$8012
1469	=$8021						L8021=$8021

1471							; see $d40d, $d4ae
1472							;
1473							; (suspect these are actually references to $8840-$104 and $8848-$104)
1474	=$873c						L873C=$873c
1475	=$8744						L8744=$8744

1477	=$8400						L8400=$8400
1478	=$8500						L8500=$8500
1479	=$8600						L8600=$8600
1480	=$8700						L8700=$8700
1481	=$87f8						L87F8=$87f8
1482	=$87ff						L87FF=$87FF
1483	=$8800						L8800=$8800
1484	=$8803						L8803=$8803
1485	=$8804						L8804=$8804
1486	=$881e						L881E=$881E
1487	=$8820						L8820=$8820
1488	=$8830						multiplicand=$8830              ; 3 bytes
1489	=$8830						L8830=$8830
1490	=$8831						L8831=$8831
1491	=$8832						L8832=$8832
1492	=$8833						L8833=$8833
1493	=$8834						multiplier=$8834                ; 3 bytes
1494	=$8834						product=$8834                   ; 6 bytes
1495	=$8834						sqrtNumber=$8834                ; 6 bytes
1496	=$8834						L8834=$8834
1497	=$8835						L8835=$8835
1498	=$8836						L8836=$8836
1499	=$8837						L8837=$8837
1500	=$8838						L8838=$8838
1501	=$8839						L8839=$8839
1502							;dividend=$883a                  ; 3 bytes
1503	=$883a						L883A=$883a
1504	=$883b						L883B=$883b
1505	=$883c						L883C=$883C
1506	=$883d						L883D=$883D
1507							;divisor=$883e                   ; 3 bytes
1508	=$883e						L883E=$883e
1509	=$883f						L883F=$883f
1510	=$8840						L8840=$8840
1511	=$8841						ellipseSignFlag=$8841           ; 1 byte
1512	=$8841						L8841=$8841
1513	=$8842						ellipseAccumulatedShear=$8842   ; 3 bytes
1514	=$8842						L8842=$8842
1515	=$8843						L8843=$8843
1516	=$8844						L8844=$8844
1517	=$8845						ellipseCountOddNumbers=$8845    ; 4 bytes
1518	=$8845						L8845=$8845
1519	=$8846						L8846=$8846
1520	=$8847						L8847=$8847
1521	=$8848						L8848=$8848
1522	=$8849						ellipseCountSquares=$8849       ; 4 bytes
1523	=$8849						L8849=$8849
1524	=$884a						L884A=$884a
1525	=$884b						L884B=$884b
1526	=$884c						L884C=$884c
1527	=$884d						ellipseCountHeight=$884d

1529							                ; written to during startup
1530	=$fe8e						LFE8E=$fe8e

1532							;-------------------------------------------------------------------------

1534							                .if includeTubeSupport
1535							                .virtual $00
1536							                .union
1537	.0000						tubeOSFILEParameterBlock: .dstruct OSFILEParameterBlock
418	.0000						fileName:
419	>0000						                .fill 2
420	.0002						addresses:
421	.0002						load:
422	>0002						                .fill 4
423	.0006						exec:
424	>0006						                .fill 4
425	.000a						length:
426	.000a						saveStart:
427	>000a						                .fill 4
428	.000e						attributes:
429	.000e						saveEnd:
430	>000e						                .fill 4
431							                .endstruct
1538	.0000						tubeOSGBPBParameterBlock: .dstruct OSGBPBParameterBlock
387	.0000						handle:
388	>0000						                .fill 1
389	.0001						address:
390	>0001						                .fill 4
391	.0005						count:
392	>0005						                .fill 4
393	.0009						ptr:
394	>0009						                .fill 4
395							                .endstruct
1539	>0000						tubeLanguageHostAddr: .fill 2
1540							                .endunion
1541	>0012						tubeTransferAddr: .fill 2
1542	>0014						tubeNotClaimed: .fill 1            ;bit 7 clear if tube claimed
1543	>0015						tubeClaimantID: .fill 1
1544	.0016						tubeBrkHandlerAddr:
1545							                ; Tube BRK handler sits here.
1546							                .endv

1548	=$700						tubeStringBuffer=$700
1549	=$0128						tubeOSWORDBuffer=$0128

1551							                .virtual $53
1552	>0053						tubeLanguageParasiteAddr: .fill 4
1553							                .endv

1555							                .endif

1557							;-------------------------------------------------------------------------
1558							; MasRef E.4-4
1559							                .virtual $d0
1560	.00d0						STATE: .block
1561	>00d0						                .fill 1
1562							                ; D.2-32
1563	=$01						isPrinterEnabled=$01
1564	=$02						isScrollingDisabled=$02
1565	=$04						isPagedScrolling=$04
1566	=$08						isTextWindow=$08
1567	=$10						isShadowMode=$10
1568	=$20						isVDU5=$20
1569	=$40						isCursorEditing=$40
1570	=$80						isVDU21=$80
1571							                .bend

1573	>00d1						ZMASK: .fill 1                       ;Pixel mask
1574	>00d2						ZORA: .fill 1                        ;Text OR mask
1575	>00d3						ZEOR: .fill 1                        ;Text EOR mask
1576	>00d4						ZGORA: .fill 1                       ;Graphics OR mask
1577	>00d5						ZGEOR: .fill 1                       ;Graphics EOR mask
1578	>00d6						ZMEMG: .fill 2                       ;Graphics pointer
1579	>00d8						ZMEMT: .fill 2                       ;Text pointer
1580	>00da						ZTEMP: .fill 2                       ;Temporary space
1581	>00dc						ZTEMPB: .fill 2                      ;Temporary space
1582	>00de						ZTEMPC: .fill 2                      ;Temporary space
1583	>00e0						ZTEMPD: .fill 2                      ;Temporary space
1584							                .endv

1586							                .virtual ZTEMP
1587	.00da						zhlfw: .dstruct HorizontalLineFillWorkspaceZP
1377	>00da						notByteMatch: .fill 1
1378	>00db						a: .fill 1
1379	>00dc						b: .fill 2
1380							;c: .fill 2
1381	>00de						pixelsX: .fill 2
1382	>00e0						d: .fill 1
1383	>00e1						resultEOR: .fill 1
1384							                .endstruct
1588							                .endv


1591	=$f8						softKeyExpansionPtr=$f8       ;pointer to current char when expanding soft key.
1592	=$fa						SEIWKA=$fa
1593	=$fb						SEIWKB=$fb

1595	=$d8						vduWriteCursor=$d8

1597	=$d00						nmiEntryPoint=$d00

1599	=0						gcolModeOverwrite=0
1600	=1						gcolModeOR=1
1601	=2						gcolModeAND=2
1602	=3						gcolModeEOR=3
1603	=4						gcolModeInvert=4
1604	=5						gcolModeLeave=5

1606							;-------------------------------------------------------------------------

1608							StarKEYWorkspace: .struct
1609	>0000						newStringLength: .fill 1
1610	>0001						destPtr: .fill 2
1611	>0003						srcPtr: .fill 2
1612	>0005						counter: .fill 2
1613							                .endstruct

1615							OSGBPBWorkspace: .struct
1616	>0000						ptr: .fill 2
1617							                .endstruct

1619							ParseFileNameFSWorkspace: .struct
1620	>0000						fsInfoOffset: .fill 1
1621							                .endstruct

1623							OSCLIWorkspace: .struct
1624	>0000						tablePtr: .fill 2
1625							                .endstruct

1627							                ; TODO - could do being renamed, as it's used (in the
1628							                ; same way) by *UNPLUG and *INSERT.
1629							StarROMSWorkspace: .struct
1630	>0000						insertedFlagMask: .fill 1
1631							                .endstruct

1633							TerminalHELPWorkspace: .struct
1634	>0000						tablePtr: .fill 2
1635							                .endstruct

1637							                ; TODO - tediously verbose names. Acronyms work well
1638							                ; enough for the VDU variables. Do the same thing
1639							                ; here.
1640							                .virtual $b0
1641							                .union
1642	.00b0						starKEYWorkspace: .dstruct StarKEYWorkspace
1609	>00b0						newStringLength: .fill 1
1610	>00b1						destPtr: .fill 2
1611	>00b3						srcPtr: .fill 2
1612	>00b5						counter: .fill 2
1613							                .endstruct
1643	.00b0						osgbpbWorkspace: .dstruct OSGBPBWorkspace
1616	>00b0						ptr: .fill 2
1617							                .endstruct
1644	.00b0						parseFileNameFSWorkspace: .dstruct ParseFileNameFSWorkspace
1620	>00b0						fsInfoOffset: .fill 1
1621							                .endstruct
1645	.00b0						oscliWorkspace: .dstruct OSCLIWorkspace
1624	>00b0						tablePtr: .fill 2
1625							                .endstruct
1646	.00b0						starROMSWorkspace: .dstruct StarROMSWorkspace
1630	>00b0						insertedFlagMask: .fill 1
1631							                .endstruct
1647	.00b0						terminalHELPWorkspace: .dstruct TerminalHELPWorkspace
1634	>00b0						tablePtr: .fill 2
1635							                .endstruct
1648							                .endunion
1649							                .endvirtual

1651							;-------------------------------------------------------------------------

1653							; ROM number containing Terminal
1654	=15						terminalROM=15

1656							; ROM number containing the extXXXX entry points
1657							                .if !includeTerminalROM
1666							                .elsif version>=400
1667	=15						extROM=15
1668							                .endif

1670							; Base page for VDU routines
1671	=$c0						vduRoutinesPage=$c0

1673							                .if version<500
1674	=14						cmosBytesOffset=RTC.ram
1677							                .endif

1679							CMOSBytes: .struct
1680	>0000						econetStationNumber: .fill 1
1681	>0001						fileServerStationNumber: .fill 1
1682	>0002						fileServerNetworkNumber: .fill 1
1683	>0003						printerServerStationNumber: .fill 1
1684	>0004						printerServerNetworkNumber: .fill 1
1685	.0005						defaultROMs: .block
1686	>0005						                .fill 1
1687	=0						fsShift=0
1688	=4						languageShift=4
1689							                .endblock

1691	>0006						insertedROMs: .fill 2

1693	>0008						editROMByte: .fill 1
1694	>0009						telecommsByte: .fill 1

1696	.000a						defaults0: .block
1697	>000a						                .fill 1
1698	=0						modeShift=0
1699	=7						modeMask=7
1700	=8						shadowMask=8
1701	=16						interlaceMask=16
1702	=7						tvMask=7
1703	=5						tvShift=5
1704							                .endblock

1706	.000b						defaults1: .block
1707	>000b						                .fill 1
1708	=0						fdriveShift=0
1709	=7						fdriveMask=7
1710	=8						shiftLockMask=8
1711	=16						noLockMask=16
1712	=32						capsLockMask=32
1713	=64						adfsLoadDirMask=64
1714	=128						floppyDrive=128
1715							                .endblock

1717	>000c						keyboardAutoRepeatDelay: .fill 1
1718	>000d						keyboardAutoRepeatRate: .fill 1
1719	>000e						printerIgnoreChar: .fill 1

1721	.000f						defaults2: .block
1722	>000f						                .fill 1
1723							                .if includeTubeSupport
1724	=1						tubeOnMask=1
1725							                .endif
1726	=2						usePrinterIgnoreCharMask=2
1727	=7						serialBaudRateIndexMask=7
1728	=2						serialBaudRateIndexShift=2
1729	=7						fx5SettingMask=7
1730	=5						fx5SettingShift=5
1731							                .endblock

1733	.0010						defaults3: .block
1734	>0010						                .fill 1
1735	=2						loudMask=2
1736							                .if includeTubeSupport
1737	=4						extTubeMask=4
1738							                .endif
1739	=8						protectedScrollingMask=8
1740	=16						autoBootMask=16
1741	=7						serialDataFormatMask=7
1742	=5						serialDataFormatShift=5
1743							                .endblock

1745							                .if version>=500
1764							                .endif

1766							                .endstruct

1768	=$ef						originalA=$ef
1769	=$f0						originalX=$f0
1770	=$f1						originalY=$f1
1771	=$fc						TEMPA=$fc
1772	=$fd						errPtr=$fd                      ;REPTR in OS 1.20
1773	=$ff						escapeFlag=$ff

1775	=$8c0						envelope1Data=$8c0

1777	=$8000						sidewaysROMLanguageEntry=$8000
1778	=$8003						sidewaysROMServiceEntry=$8003
1779							                .virtual $8006
1780	.8006						sidewaysROMType: .block
1781	=32						hasRelocationAddress=32
1782	=64						hasLanguageEntry=64
1783	=128						hasServiceEntry=128
1784							                .endblock
1785							                .endvirtual
1786	=$8007						sidewaysROMCopyrightOffset=$8007
1787	=$8008						sidewaysROMVersion=$8008
1788	=$8009						sidewaysROMName=$8009

1790							;-------------------------------------------------------------------------

1792							                ; [MasRef D.3-22]
1793							ClockStringFormat: .struct
1794	.0000						ddd:
1795	>0000						                .fill 3
1796	>0003						                .fill 1                      ;','
1797	.0004						nn:
1798	>0004						                .fill 2
1799	>0006						                .fill 1                      ;' '
1800	.0007						mmm:
1801	>0007						                .fill 3
1802	>000a						                .fill 1                      ;' '
1803	.000b						yyyy:
1804	>000b						                .fill 4
1805	>000f						                .fill 1                      ;'.'
1806	.0010						hh:
1807	>0010						                .fill 2
1808	>0012						                .fill 1                      ;':'
1809	.0013						mm:
1810	>0013						                .fill 2
1811	>0015						                .fill 1                      ;':'
1812	.0016						ss:
1813	>0016						                .fill 2
1814	.0018						cr:
1815	>0018						                .fill 1                      ;'\n'
1816							                .endstruct

1818							;-------------------------------------------------------------------------


:1	;******  Return to file: mos400.s65


4	=400						version=400
5	="MOS 4.00"					versionString="MOS 4.00"

7							*=$8000
8							                .dsection utils
9							                .cwarn *>$c000,'utils ROM is too large'

11							*=$c000
12							                .dsection mos
13							                ; there's no need for a size check here - 64tass gives
14							                ; you an error if the code would go past the 64 K
15							                ; barrier.

17							;-------------------------------------------------------------------------

19							; MOS 4.00 seems to be able to skip the ext ROM selection step. Could
20							; this be more widely applicable?
21							;
22							; (Not that it'd make a huge difference to the speed, but it would
23							; save a few bytes.)
24	=$a4c4						selectExtROMAndPlotMoveOrCopyRectangle=plotMoveOrCopyRectangle
25	=$a006						selectExtROMAndPlotEllipseOutline=plotEllipseOutline
26	=$a06d						selectExtROMAndPlotEllipseFilled=plotEllipseFilled

28							;-------------------------------------------------------------------------

30							                .section utils
31							                .include "src/terminal.s65"

:4	;******  Processing file: src/terminal.s65

1							; -*- comment-column:45; -*-

3	.8000						utilsROMHeader: .block
4							                .if (version==320||version==350)&&includeTerminalROM
20							                .elsif version==400||!includeTerminalROM

22	.8000		00		brk #		                brk
23	.8001		00		brk #		                brk
24	.8002		00		brk #		                brk
25	.8003		4c fb a5	jmp $a5fb	                jmp utilsServiceEntryPoint
26	>8006		82				                .byte $82
27	>8007		0c				                .byte copyrightText-1-utilsROMHeader
28	>8008		00				                .byte $00
29	>8009		4d 4f 53			                .text "MOS"
30	>800c		00				                .byte 0
31	.800d						copyrightText:
32	>800d		28 43 29 31 39 38 34 20		                .text "(C)1984 Acorn"
	>8015		41 63 6f 72 6e
33	>801a		00				                .byte 0

65							                .endif
66							                .endblock

68							;-------------------------------------------------------------------------

70							                .if version==350
75							                .endif

77							;-------------------------------------------------------------------------

79							                .if version==350
84							                .endif

86							;-------------------------------------------------------------------------

88							                .if version==350
93							                .endif

95							;-------------------------------------------------------------------------

97							                .if version==350
106							                .endif

108							;-------------------------------------------------------------------------

110							                .if version==350
114							                .endif

116							;-------------------------------------------------------------------------

118							                .if version==350
128							                .endif

130							;-------------------------------------------------------------------------

132							; STARTUP
133							; =======

135							; This code is officially more than a bit gnarly, as it gets stitched
136							; together in several different ways.

138							                .if version==350             ;stripped_out_reset
144							                .else                        ;stripped_out_reset
145	.801b						reset:                          ;8020
146							                .include "reset.s65"

:5	;******  Processing file: src/reset.s65

1							                .if version==350
3							                .endif
4							                .if version!=350
5	.801b		a9 fe		lda #$fe	                lda #~ACCCON.D
6	.801d		1c 34 fe	trb $fe34	                trb ACCCON
7							                .endif
8							                .if version<500
9	.8020		9c dd df	stz $dfdd	                stz hazel.hasACCCONChanged
10							                .endif
11							                .if version!=350
12	.8023		1c 66 03	trb $0366	                trb $0366
13							                .endif
14	.8026		d8		cld		                cld
15	.8027		a2 ff		ldx #$ff	                ldx #$FF
16	.8029		9a		txs		                txs              ;reset stack
17	.802a		8e 63 fe	stx $fe63	                stx userVIA.ddra ;port A all outputs
18	.802d		a9 cf		lda #$cf	                lda #%11001111
19	.802f		8d 42 fe	sta $fe42	                sta systemVIA.ddrb
20							                .if version==350
23							                .endif
24							                .if version<500
25	.8032		a0 20		ldy #$20	                ldy #RTC.a.dv32768Hz
26	.8034		a2 0a		ldx #$0a	                ldx #RTC.a
27	.8036		20 78 9b	jsr $9b78	                jsr writeRTCByte
28	.8039		20 bd 99	jsr $99bd	                jsr finishRTCUpdate
29							                .endif
30							                .if version!=350
31	.803c		a9 0c		lda #$0c	                lda #ACCCON.Y|ACCCON.X       ; page in HAZEL+shadow
32	.803e		0c 34 fe	tsb $fe34	                tsb ACCCON
33							                .if version>=500
36							                .elsif version>=400
37	.8041		20 1d 83	jsr $831d	                jsr clearAllSoundChannelBuffers
38							                .endif
42							                .endif
43							                .if version==350
45							                .else
46	.8044		ad 4e fe	lda $fe4e	                lda systemVIA.ier
47							                .endif
48	.8047		0a		asl a		                asl a
49	.8048		48		pha		                pha
50							                .if version==350
100							                .else
101							                .if version<400
111							                .else
112	.8049		d0 2c		bne $8077	                bne nonPowerOnReset
113	.804b		a2 07		ldx #$07	                ldx #7
114	.804d		20 4b f8	jsr $f84b	                jsr LF8B4
115							                .if version==400
116	.8050		a9 00		lda #$00	                lda #0
119							                .endif
120							                .endif
121	.8052						startClearRAM:
122	.8052		a8		tay		                tay             ;Y=0
123	.8053						clearRAM:
124	.8053		98		tya		                tya             ;A=0
125	.8054		64 01		stz $01		                stz $01
126	.8056		64 00		stz $00		                stz $00         ;start at $0000
127	.8058						clearRAMPageLoop:
128	.8058		91 00		sta ($00),y	                sta ($00),y     ;clear RAM
129	.805a		c8		iny		                iny
130	.805b		d0 fb		bne $8058	                bne clearRAMPageLoop
131	.805d		e6 01		inc $01		                inc $01
132	.805f		a2 40		ldx #$40	                ldx #$40          ;$40=RTI
133	.8061		8e 00 0d	stx $0d00	                stx nmiEntryPoint ;restore the RTI previously written,
134							                                  ;as each iteration will potentially
135							                                  ;overwrite it
136	.8064		a6 01		ldx $01		                ldx $01
137	.8066		e0 e0		cpx #$e0	                cpx #$E0        ;hit the end of RAM?
138	.8068		90 ee		bcc $8058	                bcc clearRAMPageLoop ;branch taken if still more to go
139	.806a		a9 04		lda #$04	                lda #ACCCON.X   ;page out shadow RAM
140	.806c		1c 34 fe	trb $fe34	                trb ACCCON
141	.806f		d0 e2		bne $8053	                bne clearRAM    ;branch taken if shadow RAM bit
142							                             ;previously set - i.e., that was the
143							                             ;first iteration, and we need to go back
144							                             ;to do main RAM
145							                .if version>=400
146	.8071		ad 28 fe	lda $fe28	                lda $fe28
147	.8074		ad 2b fe	lda $fe2b	                lda $fe2b
148							                .endif
149							                .endif
150	.8077						nonPowerOnReset:
151							                .if version>=350
152	.8077		ad 58 02	lda $0258	                lda breakAndESCAPEEffect
153	.807a		4a		lsr a		                lsr a
154	.807b		3a		dec a		                dec a
155	.807c		f0 d4		beq $8052	                beq startClearRAM
156							                .endif
157	.807e		a9 27		lda #$27	                lda #<emptyCommandLine
158	.8080		8d 04 df	sta $df04	                sta hazel.commandLinePointer+0
159	.8083		a9 e7		lda #$e7	                lda #>emptyCommandLine
160	.8085		8d 05 df	sta $df05	                sta hazel.commandLinePointer+1
161	.8088		a9 0c		lda #$0c	                lda #ACCCON.Y|ACCCON.X ; page in MOS ROM, page in main
162							                                       ; RAM
163							                .if version==350
165							                .else
166	.808a		1c 34 fe	trb $fe34	                trb ACCCON
167							                .endif
168	.808d		a9 0f		lda #$0f	                lda #$0F
169	.808f		8d 8e 02	sta $028e	                sta numericKeypadShiftEffect
170							                .if version<500&&version!=350
171	.8092						-
172	.8092		3a		dec a		                dec a
173	.8093		8d 40 fe	sta $fe40	                sta systemVIA.orb
174	.8096		c9 09		cmp #$09	                cmp #$09
175	.8098		b0 f8		bcs $8092	                bcs -
176							                .endif
177	.809a		a2 01		ldx #$01	                ldx #key_ctrl
178							                .if version==350
180							                .else
181	.809c		20 6f f6	jsr $f66f	                jsr interrogateKeyboard
182							                .endif
183	.809f		e0 80		cpx #$80	                cpx #$80        ;Z=0 C=1 if CTRL+BREAK
184	.80a1		20 24 f5	jsr $f524	                jsr updateKeyboardLEDs
185	.80a4		9c 8d 02	stz $028d	                stz lastBREAKType            ;softBREAK
186	.80a7		6a		ror a		                ror a
187	.80a8		a2 9c		ldx #$9c	                ldx #$9c                     ;what is this?
188	.80aa		a0 8d		ldy #$8d	                ldy #$8D                     ;what is this?
189	.80ac		68		pla		                pla
190	.80ad		f0 09		beq $80b8	                beq L80AD
191	.80af		a0 7e		ldy #$7e	                ldy #$7E                     ;what is this?
192	.80b1		90 37		bcc $80ea	                bcc L80DF
193	.80b3		a0 87		ldy #$87	                ldy #$87                     ;what is this?
194	.80b5		ee 8d 02	inc $028d	                inc lastBREAKType
195	.80b8						L80AD:
196	.80b8		ee 8d 02	inc $028d	                inc lastBREAKType
197	.80bb		5a		phy		                phy
198							                .if version==350&&CFA3000
204							                .endif

206							                .if useTableDrivenConfigure
216							                .else
217	.80bc		20 18 91	jsr $9118	                jsr readDefaultMODE          ; Read configured MODE
218							                .endif

220	.80bf		09 08		ora #$08	                ora #CMOSBytes.defaults0.shadowMask
221	.80c1		8d 8f 02	sta $028f	                sta startupOptions
222							                .if version==350
224							                .else
225	.80c4		20 42 9b	jsr $9b42	                jsr readDefaults3 ; Read configured BOOT
226							                .endif
227	.80c7		29 10		and #$10	                and #CMOSBytes.defaults3.autoBootMask
228	.80c9		4a		lsr a		                lsr a         ; Reset OSBYTE 255 boot bit (b3) if BOOT
229	.80ca		1c 8f 02	trb $028f	                trb startupOptions
230							                .if version==350
232							                .else
233	.80cd		20 fc 90	jsr $90fc	                jsr readDefaultTVSettings
234							                .endif
235	.80d0		8c 90 02	sty $0290	                sty tvOffset
236	.80d3		8e 91 02	stx $0291	                stx tvInterlace
237							                .if version==350
239							                .else
240	.80d6		20 42 9b	jsr $9b42	                jsr readDefaults3
241							                .endif
242	.80d9		29 08		and #$08	                and #CMOSBytes.defaults3.protectedScrollingMask
243	.80db		f0 02		beq $80df	                beq L80D4
244	.80dd		a9 01		lda #$01	                lda #VDUVariables.cursorFlags.scrollProtect
245	.80df						L80D4:
246	.80df		8d 66 03	sta $0366	                sta vduv.cursorFlags
247	.80e2		20 0f 95	jsr $950f	                jsr restoreFont32To255
248	.80e5		7a		ply		                ply
249	.80e6		a2 92		ldx #$92	                ldx #$92
250	.80e8		80 18		bra $8102	                bra initializePage2Loop
251	.80ea						L80DF:
252							                .if version>=500
254							                .endif
255	.80ea		a9 87		lda #$87	                lda #$87             ; Clear MODE bits from OSBYTE 255
256	.80ec		1c 8f 02	trb $028f	                trb startupOptions
257	.80ef		ad 55 03	lda $0355	                lda vduv.currentScreenMODE ; Get current screen MODE b0-b2
258	.80f2		29 07		and #$07	                and #$07
259	.80f4		0c 8f 02	tsb $028f	                tsb startupOptions           ; Copy to OSBYTE 255
260	.80f7		a9 10		lda #$10	                lda #STATE.isShadowMode ; Test shadow screen bit in VDU flags
261	.80f9		24 d0		bit $d0		                bit STATE                      ; Not shadow screen
262	.80fb		f0 05		beq $8102	                beq initializePage2Loop
263	.80fd		a9 80		lda #$80	                lda #$80                     ; Set shadow screen bit in OSBYTE 255
264	.80ff		0c 8f 02	tsb $028f	                tsb startupOptions

266	.8102						initializePage2Loop:
267	.8102		ad 8d 02	lda $028d	                lda lastBREAKType
268	.8105		d0 08		bne $810f	                bne clearPage2Byte           ;taken unless soft BREAK

270							                ; leave the ROM information table alone on a soft
271							                ; BREAK.
272	.8107		e0 b1		cpx #$b1	                cpx #<romInformationTable+16
273	.8109		b0 04		bcs $810f	                bcs clearPage2Byte
274	.810b		e0 a1		cpx #$a1	                cpx #<romInformationTable
275	.810d		b0 0a		bcs $8119	                bcs nextPage2Byte
276	.810f						clearPage2Byte:
277	.810f		9e 00 02	stz $0200,x	                stz $0200,x
278	.8112		e0 cd		cpx #$cd	                cpx #$CD
279	.8114		90 03		bcc $8119	                bcc nextPage2Byte
280	.8116		de 00 02	dec $0200,x	                dec $0200,x                  ;initialize later values to $ff
281	.8119						nextPage2Byte:
282	.8119		e8		inx		                inx
283	.811a		d0 e6		bne $8102	                bne initializePage2Loop

285							                .if version==350
287							                .endif
288	.811c		a2 cf		ldx #$cf	                ldx #$CF
289	.811e						initializeZeroPageLoop:
290	.811e		74 00		stz $00,x	                stz $00,x
291	.8120		e8		inx		                inx
292	.8121		d0 fb		bne $811e	                bne initializeZeroPageLoop
293							                .if version==350
296							                .endif

298	.8123		ad 8d 02	lda $028d	                lda lastBREAKType
299	.8126		d0 1c		bne $8144	                bne L813D                    ;taken if not soft BREAK

301							                .if version!=400
304							                .endif
305	.8128		ad 4b 02	lda $024b	                lda basicROMNumber
306	.812b		48		pha		                pha
307	.812c		ad 44 02	lda $0244	                lda oshwm
308	.812f		48		pha		                pha
309	.8130		ad 57 02	lda $0257	                lda spoolFileHandle
310	.8133		48		pha		                pha
311	.8134		ae 56 02	ldx $0256	                ldx execFileHandle

313	.8137						L8130:
314	.8137		b9 e6 e2	lda $e2e6,y	                lda defaultVectorTable-1,y
315	.813a		99 ff 01	sta $01ff,y	                sta vectors-1,y
316	.813d		88		dey		                dey
317	.813e		c0 21		cpy #$21	                cpy #EVENTV+1-vectors
318	.8140		b0 f5		bcs $8137	                bcs L8130

320	.8142		a0 12		ldy #$12	                ldy #FILEV-vectors

322	.8144						L813D:
323	.8144		b9 e6 e2	lda $e2e6,y	                lda defaultVectorTable-1,y
324	.8147		99 ff 01	sta $01ff,y	                sta vectors-1,y
325	.814a		88		dey		                dey
326	.814b		d0 f7		bne $8144	                bne L813D

328	.814d		ad 8d 02	lda $028d	                lda lastBREAKType
329	.8150		d0 15		bne $8167	                bne L8164
330	.8152		8e 56 02	stx $0256	                stx execFileHandle
331	.8155		68		pla		                pla                          ;restore *SPOOL file handle
332	.8156		c9 04		cmp #$04	                cmp #$04                     ;is it a TAPE or ROM handle?
333	.8158		b0 02		bcs $815c	                bcs L8155                    ;taken if no - keep it

335							                .if version==350
337							                .else
338	.815a		a9 00		lda #$00	                lda #$00          ;auto-close it if TAPE or ROM handle
339							                .endif
340	.815c						L8155:
341	.815c		8d 57 02	sta $0257	                sta spoolFileHandle
342	.815f		68		pla		                pla
343	.8160		8d 44 02	sta $0244	                sta oshwm
344	.8163		68		pla		                pla
345	.8164		8d 4b 02	sta $024b	                sta basicROMNumber
346							                .if version!=400
349							                .endif

351	.8167						L8164:
352							                .if useTableDrivenConfigure
359							                .else
360	.8167		20 41 91	jsr $9141	                jsr readDefaults1
361							                .endif
362	.816a		a2 20		ldx #$20	                ldx #keyboardStatusByte.shiftLockDisengaged
363	.816c		0a		asl a		                asl a
364	.816d		0a		asl a		                asl a                        ;N=defaultCapsLockMask
365	.816e		30 07		bmi $8177	                bmi gotKeyboardStatusByte                    ;taken if defaultCapsLock
366	.8170		a2 30		ldx #$30	                ldx #keyboardStatusByte.shiftLockDisengaged|keyboardStatusByte.capsLockDisengaged
367	.8172		0a		asl a		                asl a                        ;N=defaultNoLockMask
368	.8173		30 02		bmi $8177	                bmi gotKeyboardStatusByte
369	.8175		a2 a0		ldx #$a0	                ldx #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
370	.8177						gotKeyboardStatusByte:
371	.8177		8e 5a 02	stx $025a	                stx keyboardStatusByte
372							                .if version==350
374							                .else
375	.817a		20 9d e5	jsr $e59d	                jsr selectTerminalROM
376	.817d		20 f6 ee	jsr $eef6	                jsr resetKeyRepeat
377							                .endif
378	.8180		ad 8d 02	lda $028d	                lda lastBREAKType
379	.8183		f0 14		beq $8199	                beq L8196
380							                .if useTableDrivenConfigure
387							                .else
388	.8185		20 3c 91	jsr $913c	                jsr readDefaultPrinterIgnoreChar
389							                .endif
390	.8188		8d 86 02	sta $0286	                sta printerIgnoreChar
391							                .if version==350
393							                .elsif version<500
394	.818b		20 3e 9b	jsr $9b3e	                jsr readDefaults2
395	.818e		4a		lsr a		                lsr a                        ;C=tubeOn
396	.818f		4a		lsr a		                lsr a                        ;C=usePrinterIgnoreChar
399							                .endif
400	.8190		6e 46 02	ror $0246	                ror noignoreState

402							                .if useTableDrivenConfigure
409							                .else
410	.8193		20 26 91	jsr $9126	                jsr readDefaultFX5Settings
411							                .endif

413	.8196		8d 85 02	sta $0285	                sta printerDriverType
414	.8199						L8196:
415							                .if version==400
416	.8199		a2 01		ldx #$01	                ldx #1
468							                .endif

470	.819b		a9 7f		lda #$7f	                lda #$7F
471	.819d						initializeVIAInterruptsLoop:
472	.819d		9d 4d fe	sta $fe4d,x	                sta systemVIA.ifr,x
473	.81a0		9d 6d fe	sta $fe6d,x	                sta userVIA.ifr,x
474	.81a3		ca		dex		                dex
475	.81a4		10 f7		bpl $819d	                bpl initializeVIAInterruptsLoop

477							                .if version!=350
478							                ; Let through 1 IRQ.
479	.81a6		58		cli		                cli
480	.81a7		78		sei		                sei

482							                ; TEMPA was cleared above, so if bit 6 is set, there
483							                ; must have been an IRQ (as A=$7f).
484	.81a8		24 fc		bit $fc		                bit TEMPA
485	.81aa		50 03		bvc $81af	                bvc +
486	.81ac		20 be f6	jsr $f6be	                jsr call1MHzBusHook
487	.81af						+
488							                .endif

490							                .if version!=400
492							                .else
493	.81af		a2 c2		ldx #$c2	                ldx #$80|VIA.irq.t1|VIA.irq.ca1
494							                .endif
495	.81b1		8e 4e fe	stx $fe4e	                stx systemVIA.ier

497							                .if version>=500
500							                .endif

502	.81b4		a2 04		ldx #$04	                ldx #VIA.pcr.cb2InputNegativeActiveEdge|VIA.pcr.cb1NegativeActiveEdge|VIA.pcr.ca2InputPositiveEdge|VIA.pcr.ca1NegativeActiveEdge
503	.81b6		8e 4c fe	stx $fe4c	                stx systemVIA.pcr
504	.81b9		a9 40		lda #$40	                lda #VIA.acr.t1Continuous|VIA.acr.t2Timer|VIA.acr.srDisabled|VIA.acr.pbLatchDisabled|VIA.acr.paLatchDisabled
505	.81bb		8d 4b fe	sta $fe4b	                sta systemVIA.acr
506	.81be		a9 0e		lda #$0e	                lda #$0E
507	.81c0		8d 46 fe	sta $fe46	                sta systemVIA.t1lL
508	.81c3		8d 6c fe	sta $fe6c	                sta userVIA.pcr              ;VIA.pcr.cb2InputNegativeActiveEdge|VIA.pcr.cb1NegativeActiveEdge|VIA.pcr.ca2HighOutput|VIA.pcr.ca1NegativeActiveEdge
509							                .if version==350
513							                .endif
514	.81c6		a9 27		lda #$27	                lda #$27
515	.81c8		8d 47 fe	sta $fe47	                sta systemVIA.t1lH
516	.81cb		8d 45 fe	sta $fe45	                sta systemVIA.t1cH

518							                .if version==350||version>=400
519	.81ce		20 1d 83	jsr $831d	                jsr clearAllSoundChannelBuffers
527							                .endif

529							                .if version==350
531							                .else
532	.81d1		20 ff f6	jsr $f6ff	                jsr osbyte7A
533							                .endif
534	.81d4		86 ed		stx $ed		                stx firstKeyPressedInternal
535	.81d6		a2 00		ldx #$00	                ldx #$00
536							                .if version>=500
538							                .endif
539	.81d8		20 25 e8	jsr $e825	                jsr purgeBuffer

541							                .if version!=400
563							                .endif

565							                .if version==350
567							                .else
568	.81db		20 42 9b	jsr $9b42	                jsr readDefaults3
569							                .endif
570	.81de		89 02		bit #$02	                bit #CMOSBytes.defaults3.loudMask
571	.81e0		d0 05		bne $81e7	                bne L8211
572	.81e2		a9 f0		lda #$f0	                lda #$F0
573	.81e4		8d 64 02	sta $0264	                sta bellSound
574	.81e7						L8211:
575							                .if version!=350
576	.81e7		20 9d e5	jsr $e59d	                jsr selectTerminalROM
577							                .endif

579	.81ea		ae 84 02	ldx $0284	                ldx softKeyConsistencyFlag
580	.81ed		f0 03		beq $81f2	                beq checkResetType
581	.81ef		20 09 ef	jsr $ef09	                jsr osbyte12
582	.81f2						checkResetType:
583	.81f2		ad 8d 02	lda $028d	                lda lastBREAKType
584	.81f5		f0 03		beq $81fa	                beq romsScanned                    ;taken if soft BREAK

586							                .if version==350
589							                .else
590	.81f7		4c b0 e3	jmp $e3b0	                jmp scanROMs
591							                .endif

593	.81fa						romsScanned:
594	.81fa		ad 8f 02	lda $028f	                lda startupOptions
595	.81fd		20 99 c7	jsr $c799	                jsr setStartupMODE
596	.8200		ad 8d 02	lda $028d	                lda lastBREAKType
597	.8203		3a		dec a		                dec a
598							                .if version>=510
601							                .else
602	.8204		d0 54		bne $825a	                bne softReset                    ;taken if not power-on reset
603							                .endif

605	.8206						powerOnReset:
606							                .if version>=500
622							                .endif
623	.8206						checkForNVRAMReset:

625							                .if version>=510
644							                .endif

646							                .if version<510
647	.8206		a5 ed		lda $ed		                lda firstKeyPressedInternal
648							                .endif
649	.8208						checkForResetKey:
650	.8208		c9 33		cmp #$33	                cmp #key_r
651	.820a		d0 4e		bne $825a	                bne softReset                    ;taken if R not pressed

653							                .if version<500
654							                .if CFA3000
656							                .else
657							                ; Reset CMOS RAM
658	.820c						resetCMOSRAM:
659	.820c		a2 31		ldx #$31	                ldx #size(RTC.ram)-1
660	.820e						resetCMOSRAMLoop:
661	.820e		da		phx		                phx
662	.820f		a0 00		ldy #$00	                ldy #$00
663							                .if version==350
668							                .endif
669	.8211		20 70 9b	jsr $9b70	                jsr writeCMOSByte
670	.8214		fa		plx		                plx
671	.8215		ca		dex		                dex
672							                .if version==350
674							                .else
675	.8216		10 f6		bpl $820e	                bpl resetCMOSRAMLoop
676							                .endif

678							                .if version!=350
679							                ; Initialize ROM insertion flags.
680	.8218		a0 ff		ldy #$ff	                ldy #$FF
681	.821a		a2 06		ldx #$06	                ldx #CMOSBytes.insertedROMs+0
682	.821c		20 70 9b	jsr $9b70	                jsr writeCMOSByte
683	.821f		a2 07		ldx #$07	                ldx #CMOSBytes.insertedROMs+1
684	.8221		20 70 9b	jsr $9b70	                jsr writeCMOSByte
685							                .endif

687							                .endif
699							                .endif

701							                .if version==350
703							                .else

705							                .if version>=500
720							                .endif

722	.8224		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
723							                .if version>=500
725							                .endif
726	>8227		0d 0a				                .text 13,10
727							                .if version<500
728	>8229		43 4d 4f 53 20 52 41 4d		                .text "CMOS RAM reset"
	>8231		20 72 65 73 65 74
731							                .endif
732	>8237		0d 0a 50 72 65 73 73 20		                .text 13,10,"Press break to continue"
	>823f		62 72 65 61 6b 20 74 6f 20 63 6f 6e 74 69 6e 75
	>824f		65
733	>8250		0d 0a 00			                .text 13,10,0
734							                .endif

736	.8253		a9 03		lda #$03	                lda #$03
737	.8255		8d 58 02	sta $0258	                sta breakAndESCAPEEffect
738	.8258						hang:
739	.8258		80 fe		bra $8258	                bra hang

741							;-------------------------------------------------------------------------

743							                .if version==350
775							.endif

777							;-------------------------------------------------------------------------

779	.825a						softReset:
780							                .if version==350
783							                .else
784	.825a		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
785							                .endif
786	.825d		9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
787	.8260		9c d5 df	stz $dfd5	                stz hazel.moveDestHandle
788	.8263		a0 ca		ldy #$ca	                ldy #$CA
789							                .if version==350
791							                .else
792	.8265		20 26 e9	jsr $e926	                jsr insertCharacterIntoKeyboardBuffer
793							                .endif
794							                .if version==350
796							                .else
797	.8268		20 38 f1	jsr $f138	                jsr osbyte247EntryPoint
798							                .endif
799	.826b		ad 8d 02	lda $028d	                lda lastBREAKType
800	.826e		f0 03		beq $8273	                beq L829D
801							                .if version==400
802	.8270		20 bf eb	jsr $ebbf	                jsr LEBBF
805							                .endif
806	.8273						L829D:
807							                .if includeTubeSupport
808							                .if version==350
810							                .else
811	.8273		20 3e 9b	jsr $9b3e	                jsr readDefaults2
812							                .endif
813	.8276		4a		lsr a		                lsr a
814	.8277		90 2d		bcc $82a6	                bcc continueSoftReset

816							                .if version==350
818							                .else
819	.8279		20 42 9b	jsr $9b42	                jsr readDefaults3
820							                .endif

822							                .if version==350
830							                .else
831	.827c		89 04		bit #$04	                bit #CMOSBytes.defaults3.extTubeMask
832	.827e		08		php		                php
833	.827f		a9 10		lda #$10	                lda #ACCCON.ITU
834	.8281		1c 34 fe	trb $fe34	                trb ACCCON
835	.8284		28		plp		                plp
836	.8285		d0 03		bne $828a	                bne L82B4
837	.8287		0c 34 fe	tsb $fe34	                tsb ACCCON
838							                .endif
839	.828a						L82B4:
840	.828a		20 85 e3	jsr $e385	                jsr isSecondProcessorPresent
841	.828d		b0 0d		bcs $829c	                bcs foundTube

843							                .if version==350
845							                .else
846	.828f		ad 34 fe	lda $fe34	                lda ACCCON                    ; Toggle Internal/External Tube
847							                .endif
848	.8292		49 10		eor #$10	                eor #ACCCON.ITU
849							                .if version==350
851							                .else
852	.8294		8d 34 fe	sta $fe34	                sta ACCCON
853							                .endif

855	.8297		20 85 e3	jsr $e385	                jsr isSecondProcessorPresent

857							                .endif

:4	;******  Return to file: src/terminal.s65

147							                .endif

149							                .if includeTubeSupport
150	.829a		90 0a		bcc $82a6	                bcc handleROMWorkspace        ;taken if Tube not found
151							                .if version!=350
152	.829c						foundTube:
153							                .endif
154	.829c		a2 ff		ldx #$ff	                ldx #romServiceCallTubeMainInitialisation
155	.829e		20 52 ec	jsr $ec52	                jsr makeROMServiceCall   ;
156	.82a1		d0 03		bne $82a6	                bne handleROMWorkspace        ; Not claimed, step past
157	.82a3		ce 7a 02	dec $027a	                dec tubePresence ; Tube PreInit claimed, set TubeFlag to &FF, Tube present
158							                .endif
159							                .if version!=350
160	.82a6						continueSoftReset:
161							                .endif
162	.82a6						handleROMWorkspace:
163	.82a6		ad 8d 02	lda $028d	                lda lastBREAKType ; Soft Break, don't ask about workspace
164	.82a9		f0 27		beq $82d2	                beq L82FC
165	.82ab		a0 dc		ldy #$dc	                ldy #$DC                     ; Start high workspace at &DC00 and work downwards
166	.82ad		a2 24		ldx #$24	                ldx #romServiceCallCountDynamicHAZELWorkspace ; Ask ROMs how much private high workspace required
167	.82af		20 52 ec	jsr $ec52	                jsr makeROMServiceCall   ;
168	.82b2		a2 21		ldx #$21	                ldx #romServiceCallAbsoluteHAZELWorkspaceClaim ; Ask ROMs for maximum shared high workspace required
169	.82b4		20 52 ec	jsr $ec52	                jsr makeROMServiceCall   ;
170	.82b7		5a		phy		                phy                          ; Save top of shared workspace
171	.82b8		a2 22		ldx #$22	                ldx #romServiceCallPrivateHAZELWorkspaceClam ; Ask ROMs for private high workspace required
172	.82ba		20 52 ec	jsr $ec52	                jsr makeROMServiceCall   ;
173	.82bd		a0 0e		ldy #$0e	                ldy #$0E                     ; Start low workspace at &0E00
174	.82bf		a2 01		ldx #$01	                ldx #romServiceCallAbsoluteWorkspaceClaim ; Ask ROMs for maximum shared workspace
175	.82c1		20 52 ec	jsr $ec52	                jsr makeROMServiceCall   ;
176	.82c4		a2 02		ldx #$02	                ldx #romServiceCallPrivateWorkspaceClaim ; Ask ROMs for private workspace
177	.82c6		20 52 ec	jsr $ec52	                jsr makeROMServiceCall   ;
178	.82c9		8c 44 02	sty $0244	                sty oshwm                    ; Set OSHWM - default PAGE
179	.82cc		7a		ply		                ply                          ; Get top of shared high workspace
180	.82cd		a2 23		ldx #$23	                ldx #romServiceCallTopOfHAZELWorkspace ; Tell ROMs top of shared high workspace
181	.82cf		20 52 ec	jsr $ec52	                jsr makeROMServiceCall   ;
182	.82d2						L82FC:
183	.82d2		a2 21		ldx #$21	                ldx #size(defaultFsInfoBlocks)
184	.82d4						L82FE:
185	.82d4		bd 27 83	lda $8327,x	                lda defaultFsInfoBlocks-1,x                ; Copy initial FS info blocks for CFS, TAPE, ROM
186	.82d7		9d 05 df	sta $df05,x	                sta hazel.fsInfoBlocks-1,x
187	.82da		ca		dex		                dex
188	.82db		d0 f7		bne $82d4	                bne L82FE
189	.82dd		64 f2		stz $f2		                stz $F2                      ; &F2/3=>FS Info Blocks
190	.82df		a9 df		lda #$df	                lda #>hazel.fsInfoBlocks
191	.82e1		85 f3		sta $f3		                sta $F3
192							                ; Y=>end of FS Info Blocks
193	.82e3		a0 27		ldy #$27	                ldy #<hazel.fsInfoBlocks+size(defaultFsInfoBlocks)
194	.82e5		a2 25		ldx #$25	                ldx #romServiceCallRequestFSInfo
195	.82e7		20 52 ec	jsr $ec52	                jsr makeROMServiceCall   ;
196	.82ea		a9 00		lda #$00	                lda #$00                     ; Terminate FS Info blocks
197	.82ec		91 f2		sta ($f2),y	                sta ($F2),y

199	.82ee		ad 57 02	lda $0257	                lda spoolFileHandle ; Save Spool handle and disable Spooling
200	.82f1		48		pha		                pha
201	.82f2		9c 57 02	stz $0257	                stz spoolFileHandle
202	.82f5		a2 fe		ldx #$fe	                ldx #romServiceCallTubeSystemPostInitialisation
203							                .if includeTubeSupport
204	.82f7		ac 7a 02	ldy $027a	                ldy tubePresence
207							                .endif
208	.82fa		20 52 ec	jsr $ec52	                jsr makeROMServiceCall   ; Tube PostInit
209	.82fd		2d 67 02	and $0267	                and startupMessageSuppressionStatus
210	.8300		10 14		bpl $8316	                bpl L8340

212							                ; use +$ff rather than -1 to avoid 64tass warning.
213							                ; Only the LSB is used.
214	.8302		a0 ff		ldy #$ff	                ldy #((startupMessages.acornMOS-(startupMessages&$ff00))+$ff)&$ff
215	.8304		20 ba e6	jsr $e6ba	                jsr printStartupMessage
216	.8307		ad 8d 02	lda $028d	                lda lastBREAKType            ; Skip past if Soft Break
217	.830a		f0 05		beq $8311	                beq L833B
218	.830c		a0 0b		ldy #$0b	                ldy #((startupMessages.beep-(startupMessages&$ff00))-1)&$ff
219	.830e		20 ba e6	jsr $e6ba	                jsr printStartupMessage
220	.8311						L833B:
221	.8311		a0 0d		ldy #$0d	                ldy #((startupMessages.twoNewlines-(startupMessages&$ff00))-1)&$ff
222	.8313		20 ba e6	jsr $e6ba	                jsr printStartupMessage
223	.8316						L8340:
224	.8316		68		pla		                pla                          ; Restore Spool handle
225	.8317		8d 57 02	sta $0257	                sta spoolFileHandle
226	.831a		4c 1e e4	jmp $e41e	                jmp LE40E                ;

228							;-------------------------------------------------------------------------

230							                .if version>=500
238							                .endif
239							                .if version>=400
240	.831d						clearAllSoundChannelBuffers:
241	.831d		a2 08		ldx #$08	                ldx #8
242	.831f						L836F:
243	.831f		ca		dex		                dex
244	.8320		20 4c f3	jsr $f34c	                jsr clearSoundChannelBuffer
245	.8323		e0 04		cpx #$04	                cpx #4
246	.8325		d0 f8		bne $831f	                bne L836F
247	.8327		60		rts		                rts
248							                .endif

250							;-------------------------------------------------------------------------

252							; Default FS Info Blocks
253							; ======================
254	.8328						defaultFsInfoBlocks: .block
255							                .if version<500
256	>8328		43 46 53 20 20 20 20 20		                .text "CFS     "
257	>8330		01				                .byte $01
258	>8331		02				                .byte $02
259	>8332		01				                .byte $01
260	>8333		54 41 50 45 20 20 20 20		                .text "TAPE    "
261	>833b		01				                .byte $01
262	>833c		02				                .byte $02
263	>833d		01				                .byte $01
264							                .endif
265	>833e		52 4f 4d 20 20 20 20 20		                .text "ROM     "
266	>8346		03				                .byte $03
267	>8347		03				                .byte $03
268	>8348		03				                .byte $03
269							                .endblock

271							;-------------------------------------------------------------------------
272							;
273							; MOS command table

275							mos_command .macro name,routine,byte1,byte2
292							                .endm

294	.8349						mosCommandTable:
276							                ; Name of command, compared case-insensitively.
277	>8349		43 41 54			                .text "CAT"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>834c		ef				                .byte >callFSCV
126	>834d		d4				                .byte <callFSCV

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>834e		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>834f		05				                .byte $05
296							                .if version!=400
298							                .endif
276							                ; Name of command, compared case-insensitively.
277	>8350		41 50 50 45 4e 44		                .text "APPEND"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8356		92				                .byte >starAPPEND
126	>8357		a8				                .byte <starAPPEND

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8358		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8359		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>835a		42 41 53 49 43			                .text "BASIC"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>835f		85				                .byte >starBASIC
126	>8360		bb				                .byte <starBASIC

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8361		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8362		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8363		42 55 49 4c 44			                .text "BUILD"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8368		92				                .byte >starBUILD
126	>8369		a3				                .byte <starBUILD

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>836a		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>836b		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>836c		43 4c 4f 53 45			                .text "CLOSE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8371		96				                .byte >starCLOSE
126	>8372		10				                .byte <starCLOSE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8373		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8374		ff				                .byte $FF
303							                .if useTableDrivenConfigure
305							                .else
276							                ; Name of command, compared case-insensitively.
277	>8375		43 4f 4e 46 49 47 55 52		                .text "CONFIGURE"
	>837d		45

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>837e		8c				                .byte >starCONFIGURE
126	>837f		1e				                .byte <starCONFIGURE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8380		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8381		ff				                .byte $FF
307							                .endif
276							                ; Name of command, compared case-insensitively.
277	>8382		43 4f 44 45			                .text "CODE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8386		96				                .byte >starCommandThroughOSBYTE
126	>8387		7f				                .byte <starCommandThroughOSBYTE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8388		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8389		88				                .byte $88
276							                ; Name of command, compared case-insensitively.
277	>838a		43 52 45 41 54 45		                .text "CREATE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8390		95				                .byte >starCommandThroughOSFILE
126	>8391		ac				                .byte <starCommandThroughOSFILE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8392		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8393		07				                .byte $07
276							                ; Name of command, compared case-insensitively.
277	>8394		44 55 4d 50			                .text "DUMP"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8398		91				                .byte >starDUMP
126	>8399		d6				                .byte <starDUMP

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>839a		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>839b		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>839c		44 45 4c 45 54 45		                .text "DELETE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83a2		96				                .byte >starDELETE
126	>83a3		fe				                .byte <starDELETE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83a4		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83a5		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>83a6		45 58 45 43			                .text "EXEC"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83aa		ac				                .byte >starEXEC
126	>83ab		49				                .byte <starEXEC

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83ac		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83ad		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>83ae		45 58				                .text "EX"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83b0		ef				                .byte >callFSCV
126	>83b1		d4				                .byte <callFSCV

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83b2		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83b3		09				                .byte $09
276							                ; Name of command, compared case-insensitively.
277	>83b4		46 58				                .text "FX"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83b6		96				                .byte >starFX
126	>83b7		79				                .byte <starFX

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83b8		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83b9		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>83ba		47 4f 49 4f			                .text "GOIO"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83be		95				                .byte >starGOIO
126	>83bf		91				                .byte <starGOIO

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83c0		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83c1		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>83c2		47 4f				                .text "GO"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83c4		95				                .byte >starGO
126	>83c5		89				                .byte <starGO

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83c6		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83c7		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>83c8		48 45 4c 50			                .text "HELP"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83cc		85				                .byte >starHELP
126	>83cd		df				                .byte <starHELP

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83ce		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83cf		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>83d0		49 4e 46 4f			                .text "INFO"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83d4		ef				                .byte >callFSCV
126	>83d5		d4				                .byte <callFSCV

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83d6		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83d7		0a				                .byte $0A
276							                ; Name of command, compared case-insensitively.
277	>83d8		49 47 4e 4f 52 45		                .text "IGNORE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83de		96				                .byte >starIGNORE
126	>83df		1b				                .byte <starIGNORE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83e0		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83e1		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>83e2		49 4e 53 45 52 54		                .text "INSERT"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83e8		87				                .byte >starINSERT
126	>83e9		42				                .byte <starINSERT

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83ea		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83eb		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>83ec		4b 45 59			                .text "KEY"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83ef		97				                .byte >starKEY
126	>83f0		5b				                .byte <starKEY

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83f1		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83f2		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>83f3		4c 4f 41 44			                .text "LOAD"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83f7		95				                .byte >starLOAD
126	>83f8		aa				                .byte <starLOAD

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>83f9		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>83fa		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>83fb		4c 49 53 54			                .text "LIST"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>83ff		91				                .byte >starLIST
126	>8400		54				                .byte <starLIST

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8401		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8402		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8403		4c 49 4e 45			                .text "LINE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8407		ea				                .byte >callUSERV
126	>8408		cc				                .byte <callUSERV

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8409		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>840a		01				                .byte $01
276							                ; Name of command, compared case-insensitively.
277	>840b		4c 49 42 46 53			                .text "LIBFS"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8410		e7				                .byte >starLIBFS
126	>8411		0c				                .byte <starLIBFS

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8412		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8413		00				                .byte $00
326							                .if version<500
276							                ; Name of command, compared case-insensitively.
277	>8414		6d 6f 74 6f 72			                .text motorCommandString

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8419		96				                .byte >starCommandThroughOSBYTE
126	>841a		7f				                .byte <starCommandThroughOSBYTE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>841b		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>841c		89				                .byte $89
330							                .endif
276							                ; Name of command, compared case-insensitively.
277	>841d		4d 4f 56 45			                .text "MOVE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8421		93				                .byte >starMOVE
126	>8422		4a				                .byte <starMOVE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8423		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8424		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8425		4f 50 54			                .text "OPT"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8428		96				                .byte >starCommandThroughOSBYTE
126	>8429		7f				                .byte <starCommandThroughOSBYTE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>842a		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>842b		8b				                .byte $8B
276							                ; Name of command, compared case-insensitively.
277	>842c		50 52 49 4e 54			                .text "PRINT"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8431		91				                .byte >starPRINT
126	>8432		4d				                .byte <starPRINT

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8433		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8434		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8435		52 55 4e			                .text "RUN"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8438		ef				                .byte >callFSCV
126	>8439		d4				                .byte <callFSCV

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>843a		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>843b		04				                .byte $04
276							                ; Name of command, compared case-insensitively.
277	>843c		52 45 4d 4f 56 45		                .text "REMOVE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8442		96				                .byte >starREMOVE
126	>8443		05				                .byte <starREMOVE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8444		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8445		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8446		52 4f 4d			                .text "ROM"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8449		96				                .byte >starCommandThroughOSBYTE
126	>844a		7f				                .byte <starCommandThroughOSBYTE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>844b		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>844c		8d				                .byte $8D
276							                ; Name of command, compared case-insensitively.
277	>844d		52 4f 4d 53			                .text "ROMS"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8451		86				                .byte >starROMS
126	>8452		bb				                .byte <starROMS

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8453		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8454		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>8455		53 41 56 45			                .text "SAVE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8459		95				                .byte >starCommandThroughOSFILE
126	>845a		ac				                .byte <starCommandThroughOSFILE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>845b		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>845c		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>845d		53 48 41 44 4f 57		                .text "SHADOW"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8463		96				                .byte >starSHADOW
126	>8464		fa				                .byte <starSHADOW

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8465		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8466		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>8467		53 48 4f 57			                .text "SHOW"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>846b		97				                .byte >starSHOW
126	>846c		1c				                .byte <starSHOW

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>846d		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>846e		ff				                .byte $FF
276							                ; Name of command, compared case-insensitively.
277	>846f		53 48 55 54			                .text "SHUT"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8473		f1				                .byte >starSHUT
126	>8474		62				                .byte <starSHUT

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8475		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8476		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8477		53 50 4f 4f 4c			                .text "SPOOL"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>847c		96				                .byte >starSPOOL
126	>847d		c7				                .byte <starSPOOL

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>847e		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>847f		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>8480		53 50 4f 4f 4c 4f 4e		                .text "SPOOLON"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8487		96				                .byte >starSPOOLON
126	>8488		b4				                .byte <starSPOOLON

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8489		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>848a		00				                .byte $00
344							                .if version>=350
276							                ; Name of command, compared case-insensitively.
277	>848b		53 52 44 41 54 41		                .text "SRDATA"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>8491		88				                .byte >starSRDATAOrStarSRROM
126	>8492		49				                .byte <starSRDATAOrStarSRROM

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8493		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8494		a0				                .byte $a0
276							                ; Name of command, compared case-insensitively.
277	>8495		53 52 4c 4f 41 44		                .text "SRLOAD"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>849b		89				                .byte >starSRLOADOrStarSRSAVE
126	>849c		77				                .byte <starSRLOADOrStarSRSAVE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>849d		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>849e		60				                .byte $60
276							                ; Name of command, compared case-insensitively.
277	>849f		53 52 52 45 41 44		                .text "SRREAD"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84a5		89				                .byte >starSRREADOrStarSRWRITE
126	>84a6		01				                .byte <starSRREADOrStarSRWRITE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>84a7		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>84a8		a0				                .byte $a0
276							                ; Name of command, compared case-insensitively.
277	>84a9		53 52 52 4f 4d			                .text "SRROM"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84ae		88				                .byte >starSRDATAOrStarSRROM
126	>84af		49				                .byte <starSRDATAOrStarSRROM

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>84b0		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>84b1		80				                .byte $80
276							                ; Name of command, compared case-insensitively.
277	>84b2		53 52 53 41 56 45		                .text "SRSAVE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84b8		89				                .byte >starSRLOADOrStarSRSAVE
126	>84b9		77				                .byte <starSRLOADOrStarSRSAVE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>84ba		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>84bb		20				                .byte $20
276							                ; Name of command, compared case-insensitively.
277	>84bc		53 52 57 52 49 54 45		                .text "SRWRITE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84c3		89				                .byte >starSRREADOrStarSRWRITE
126	>84c4		01				                .byte <starSRREADOrStarSRWRITE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>84c5		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>84c6		e0				                .byte $e0
351							                .endif
352							                .if useTableDrivenConfigure
354							                .else
276							                ; Name of command, compared case-insensitively.
277	>84c7		53 54 41 54 55 53		                .text "STATUS"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84cd		8c				                .byte >starSTATUS
126	>84ce		35				                .byte <starSTATUS

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>84cf		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>84d0		ff				                .byte $FF
356							                .endif
357							                .if version<500
276							                ; Name of command, compared case-insensitively.
277	>84d1		74 61 70 65			                .text tapeCommandString

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84d5		96				                .byte >starCommandThroughOSBYTE
126	>84d6		7f				                .byte <starCommandThroughOSBYTE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>84d7		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>84d8		8c				                .byte $8C
361							                .endif
276							                ; Name of command, compared case-insensitively.
277	>84d9		54 56				                .text "TV"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84db		96				                .byte >starCommandThroughOSBYTE
126	>84dc		7f				                .byte <starCommandThroughOSBYTE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>84dd		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>84de		90				                .byte $90
276							                ; Name of command, compared case-insensitively.
277	>84df		54 49 4d 45			                .text "TIME"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84e3		87				                .byte >starTIME
126	>84e4		67				                .byte <starTIME

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>84e5		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>84e6		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>84e7		54 59 50 45			                .text "TYPE"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84eb		91				                .byte >starTYPE
126	>84ec		5f				                .byte <starTYPE

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>84ed		80				                .byte $80

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>84ee		00				                .byte $00
276							                ; Name of command, compared case-insensitively.
277	>84ef		55 4e 50 4c 55 47		                .text "UNPLUG"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84f5		87				                .byte >starUNPLUG
126	>84f6		45				                .byte <starUNPLUG

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>84f7		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>84f8		ff				                .byte $FF
366							                .if includeStarX
276							                ; Name of command, compared case-insensitively.
277	>84f9		58				                .text "X"

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84fa		e7				                .byte >starX
126	>84fb		13				                .byte <starX

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>84fc		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>84fd		00				                .byte $00
368							                .endif
276							                ; Name of command, compared case-insensitively.
277	>84fe						                .text ""

279							                ; Address of command routine, big-endian so that the
280							                ; first byte always has bit 7 set.
125:3	>84fe		ef				                .byte >callFSCV
126	>84ff		d4				                .byte <callFSCV

283:4							                ; If bit 7 set, reset the tempFS flag before
284							                ; starting.
285	>8500		00				                .byte $00

287							                ; If bit 7 set, update string input buffer address
288							                ; before starting.
289							                ;
290							                ; A is set to this value on entry to the routine.
291	>8501		03				                .byte $03
370	>8502		00				                .byte $00

372							;-------------------------------------------------------------------------
373							;
374							; Get string input buffer address tail according to table byte.
375							;
376							; Entry:
377							;
378							; oscliWorkspace.tablePtr; = pointer to table byte
379							; (stringInputBufferAddress),y = pointer to input
380							;
381							; Exit:
382							;
383							; A = table byte
384							;
385							; if table byte bit 7 set: Y/X points to command line tail
386	.8503						maybeGetStringInputBufferAddress:
387	.8503		b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr)
388	.8505		30 0c		bmi $8513	                bmi rts84FE
389	.8507						getStringInputBufferAddressWithYOffset:
390	.8507		98		tya		                tya
391	.8508						getStringInputBufferAddressWithAOffset:
392	.8508		18		clc		                clc
393	.8509		65 f2		adc $f2		                adc stringInputBufferAddress+0
394	.850b		aa		tax		                tax
395	.850c		a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
396	.850e		90 01		bcc $8511	                bcc +
397	.8510		c8		iny		                iny
398	.8511						+
399	.8511		b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr)
400	.8513						rts84FE:
401	.8513		60		rts		                rts

403							; Prepare OSCLI command line
404							; ==========================
405	.8514						oscli:
406	.8514		86 f2		stx $f2		                stx stringInputBufferAddress+0
407	.8516		84 f3		sty $f3		                sty stringInputBufferAddress+1
408	.8518		ad 00 df	lda $df00	                lda hazel.currentFS
409	.851b		20 1d fa	jsr $fa1d	                jsr selectFS
410	.851e		a9 08		lda #$08	                lda #fscStarCommand
411	.8520		20 d4 ef	jsr $efd4	                jsr callFSCV
412	.8523		a0 ff		ldy #$ff	                ldy #$FF
413	.8525						L8510:
414	.8525		20 ed f0	jsr $f0ed	                jsr incAndSkipSpaces
415	.8528		f0 e9		beq $8513	                beq rts84FE
416	.852a		c9 2a		cmp #$2a	                cmp #'*'
417	.852c		f0 f7		beq $8525	                beq L8510
418	.852e		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
419	.8531		f0 e0		beq $8513	                beq rts84FE
420	.8533		c9 7c		cmp #$7c	                cmp #'|'
421	.8535		f0 dc		beq $8513	                beq rts84FE
422	.8537		9c c6 df	stz $dfc6	                stz hazel.tempFSFlag
423	.853a		c9 2d		cmp #$2d	                cmp #'-'
424	.853c		d0 0c		bne $854a	                bne L8535
425	.853e		20 76 f9	jsr $f976	                jsr parseFileNameFS
426	.8541		20 1d fa	jsr $fa1d	                jsr selectFS
427	.8544		38		sec		                sec
428	.8545		6e c6 df	ror $dfc6	                ror hazel.tempFSFlag
429	.8548		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
430	.854a						L8535:
431	.854a		c9 2f		cmp #$2f	                cmp #'/'
432	.854c		d0 09		bne $8557	                bne L8542
433	.854e		c8		iny		                iny
434	.854f		20 07 85	jsr $8507	                jsr getStringInputBufferAddressWithYOffset
435	.8552		a9 02		lda #$02	                lda #fscStarSlash
436	.8554		4c d4 ef	jmp $efd4	                jmp callFSCV

438	.8557						L8542:
439							                .if version<500&&version!=350
440	.8557		84 e6		sty $e6		                sty $E6
441							                .endif
442	.8559		a9 49		lda #$49	                lda #<mosCommandTable
443	.855b		85 b0		sta $b0		                sta oscliWorkspace.tablePtr+0
444	.855d		a9 83		lda #$83	                lda #>mosCommandTable
445	.855f		85 b1		sta $b1		                sta oscliWorkspace.tablePtr+1
446							                .if version<500&&version!=350
447	.8561		80 0a		bra $856d	                bra L8558
452							                .endif

454							                .if version<500&&version!=350
455	.8563						L854E:
456	.8563		52 b0		eor ($b0)	                eor (oscliWorkspace.tablePtr)
457	.8565		29 df		and #$df	                and #$DF
458	.8567		d0 15		bne $857e	                bne L8569
459	.8569		20 b0 85	jsr $85b0	                jsr fetchCommandTableByte
460	.856c		c8		iny		                iny
461	.856d						L8558:
462	.856d		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
463	.856f		20 19 e9	jsr $e919	                jsr isLetter
464	.8572		90 ef		bcc $8563	                bcc L854E                    ;taken if letter
465	.8574		b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr)
466	.8576		30 1f		bmi $8597	                bmi L8582                ;taken if end of command name
467	.8578		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
468	.857a		c9 2e		cmp #$2e	                cmp #'.'
469	.857c		f0 04		beq $8582	                beq L856D                    ;taken if input abbreviated
470	.857e						L8569:
471	.857e		18		clc		                clc
472	.857f		a4 e6		ldy $e6		                ldy $E6
473	.8581		88		dey		                dey
474	.8582						L856D:
475	.8582		c8		iny		                iny
476	.8583						L856E:
477	.8583		20 b0 85	jsr $85b0	                jsr fetchCommandTableByte ; Get byte from table, update pointer
478	.8586		f0 3c		beq $85c4	                beq passStarCommandThrough   ; Zero byte
479	.8588		10 f9		bpl $8583	                bpl L856E                    ; Loop until b7 set
480	.858a		b0 0e		bcs $859a	                bcs L8585
481	.858c		20 b0 85	jsr $85b0	                jsr fetchCommandTableByte
482	.858f		20 b0 85	jsr $85b0	                jsr fetchCommandTableByte
483	.8592		20 b0 85	jsr $85b0	                jsr fetchCommandTableByte
484	.8595		80 d6		bra $856d	                bra L8558

486	.8597						L8582:
487	.8597		20 b0 85	jsr $85b0	                jsr fetchCommandTableByte
488							                .endif
489	.859a						L8585:
490	.859a		48		pha		                pha
491	.859b		20 b0 85	jsr $85b0	                jsr fetchCommandTableByte
492	.859e		48		pha		                pha
493	.859f		20 b0 85	jsr $85b0	                jsr fetchCommandTableByte
494	.85a2		30 03		bmi $85a7	                bmi L8592
495	.85a4		9c c6 df	stz $dfc6	                stz hazel.tempFSFlag
496	.85a7						L8592:
497	.85a7		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
498	.85aa		18		clc		                clc
499	.85ab		08		php		                php
500	.85ac		20 03 85	jsr $8503	                jsr maybeGetStringInputBufferAddress
501	.85af		40		rti		                rti

503							                .if !useTableDrivenConfigure

505							                ; The useTableDrivenConfigure version of this does an
506							                ; INX on entry - but i don't think in practice this
507							                ; makes a difference if !useTableDrivenConfigure.

509	.85b0						fetchCommandTableByte:
510	.85b0		b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr)
511	.85b2		48		pha		                pha
512	.85b3		e6 b0		inc $b0		                inc oscliWorkspace.tablePtr+0
513	.85b5		d0 02		bne $85b9	                bne +
514	.85b7		e6 b1		inc $b1		                inc oscliWorkspace.tablePtr+1
515	.85b9						+
516	.85b9		68		pla		                pla
517	.85ba						rts85A5:
518	.85ba		60		rts		                rts
519							                .endif

521							;-------------------------------------------------------------------------

523							; *BASIC
524							; ======
525	.85bb						starBASIC:
526	.85bb		ae 4b 02	ldx $024b	                ldx basicROMNumber           ; Get BASIC ROM number
527	.85be		30 04		bmi $85c4	                bmi passStarCommandThrough ; If no BASIC ROM, jump to pass to ROMs and filing system
528							                .if version==350&&includeTubeSupport
530							                .elsif version<500
531	.85c0		38		sec		                sec                          ;
532	.85c1		4c d0 e4	jmp $e4d0	                jmp osbyte8E             ; Enter ROM as a language
536							                .endif

538							;-------------------------------------------------------------------------

540							; *ADFS - pass straight to ROMs/Filing System
541							; ===========================================
542	.85c4						passStarCommandThrough:
543	.85c4		2c c6 df	bit $dfc6	                bit hazel.tempFSFlag      ; Check filing system flag
544	.85c7		30 0c		bmi $85d5	                bmi L85C0                    ; If ... skip ROM service call
545	.85c9		9c c6 df	stz $dfc6	                stz hazel.tempFSFlag      ; Clear filing system flag
546	.85cc		a4 e6		ldy $e6		                ldy $E6
547	.85ce		a2 04		ldx #$04	                ldx #romServiceCallUnrecognisedCommand
548	.85d0		20 e3 eb	jsr $ebe3	                jsr osbyte8F    ; Service call 4 - Unknown command
549							                .if useTableDrivenConfigure
551							                .else
552	.85d3		f0 e5		beq $85ba	                beq rts85A5                    ; Claimed, return
553							                .endif
554	.85d5						L85C0:
555	.85d5		a5 e6		lda $e6		                lda $E6
556	.85d7		20 08 85	jsr $8508	                jsr getStringInputBufferAddressWithAOffset
557	.85da		a9 03		lda #$03	                lda #$03
558	.85dc		4c d4 ef	jmp $efd4	                jmp callFSCV ; Pass to FSCV,3 - Unknown command

560	.85df						starHELP:
561	.85df		a2 09		ldx #$09	                ldx #romServiceCallHelp      ;
562	.85e1		a5 d0		lda $d0		                lda STATE                    ;
563	.85e3		48		pha		                pha                          ;save STATE
564	.85e4		a9 0e		lda #$0e	                lda #14
565	.85e6		20 ee ff	jsr $ffee	                jsr OSWRCH                   ; paged mode ON
566	.85e9		20 52 ec	jsr $ec52	                jsr makeROMServiceCall   ;
567	.85ec		a2 18		ldx #$18	                ldx #romServiceCallReserved  ;???
568	.85ee		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
569	.85f1		68		pla		                pla                          ;restore STATE
570	.85f2		89 04		bit #$04	                bit #STATE.isPagedScrolling  ;was paged mode on originally?
571	.85f4		d0 2c		bne $8622	                bne parseDone   ;taken if paged mode was originally on
572							                                ;(branch target is an arbitrary nearby
573							                                ;RTS)
574	.85f6		a9 0f		lda #$0f	                lda #15         ;restore non-paged mode
575	.85f8		4c ee ff	jmp $ffee	                jmp OSWRCH

577							;-------------------------------------------------------------------------
578							;
579							; Read a byte value (0-255) from a string. If the number has a '&'
580							; prefix, interpret it as hex.
581							;
582							; entry:
583							;
584							; (stringInputBufferAddress),y - string
585							;
586							; exit:
587							;
588							; X = result
589							; ?$e6 = result
590							; C=0 if error
591							; Z=1 if CR encountered
592							;
593	.85fb						parseNumberFromString:
594	.85fb		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
595	.85fe		c9 26		cmp #$26	                cmp #'&'                     ; hex value incoming?
596	.8600		d0 21		bne $8623	                bne parseDecimal             ; taken if not hex value
597	.8602						parseHex:
598	.8602		c8		iny		                iny                          ; skip '&'
599	.8603		20 5d 86	jsr $865d	                jsr readHexDigit             ; read first hex digit
600	.8606		90 53		bcc $865b	                bcc errorReadingString
601	.8608		85 e6		sta $e6		                sta $E6                      ; save first hex digit
602	.860a		20 5d 86	jsr $865d	                jsr readHexDigit             ; read second hex digih
603	.860d		90 0e		bcc $861d	                bcc parsedValue         ; taken if not hex digit
604							                ; The first digit read was actually the high nybble,
605							                ; and the current digit read is therefore the low
606							                ; nybble.
607							                ;
608							                ; Shift saved digit 4 bits left.
609	.860f		a2 04		ldx #$04	                ldx #$04
610	.8611						-
611	.8611		06 e6		asl $e6		                asl $E6
612	.8613		ca		dex		                dex
613	.8614		d0 fb		bne $8611	                bne -
614	.8616		04 e6		tsb $e6		                tsb $E6                      ; insert low nybble
615	.8618		20 5d 86	jsr $865d	                jsr readHexDigit             ; read third hex digit
616	.861b		b0 29		bcs $8646	                bcs errorReadingString2 ; 3+-digit hex values are not valid
617	.861d						parsedValue:
618	.861d		a6 e6		ldx $e6		                ldx $E6
619	.861f		c9 0d		cmp #$0d	                cmp #$0D
620	.8621		38		sec		                sec
621	.8622						parseDone:
622	.8622		60		rts		                rts

624	.8623						parseDecimal:
625	.8623		20 49 86	jsr $8649	                jsr readDigitFromString
626	.8626		90 33		bcc $865b	                bcc errorReadingString      ;branch taken if not digit
627	.8628						parseDecimalDigit:
628	.8628		85 e6		sta $e6		                sta $E6                     ;save current value
629	.862a		20 48 86	jsr $8648	                jsr readNextDigitFromString
630	.862d		90 ee		bcc $861d	                bcc parsedValue ;branch taken if not digit, meaning number
631							                                     ;parsed successfully
632	.862f		aa		tax		                tax                         ;X=digit

634							                ; calculate (value*4+value)*2 - i.e., value*10. Carry
635							                ; at any point indicates the value was greater than
636							                ; 255, and therefore an error.
637	.8630		a5 e6		lda $e6		                lda $E6                     ;value
638	.8632		0a		asl a		                asl a                       ;value*2
639	.8633		b0 26		bcs $865b	                bcs errorReadingString
640	.8635		0a		asl a		                asl a                       ;value*4
641	.8636		b0 23		bcs $865b	                bcs errorReadingString
642	.8638		65 e6		adc $e6		                adc $E6                     ;value*5
643	.863a		b0 1f		bcs $865b	                bcs errorReadingString
644	.863c		0a		asl a		                asl a                       ;value*10
645	.863d		b0 1c		bcs $865b	                bcs errorReadingString
646	.863f		85 e6		sta $e6		                sta $E6                      ;save value*10
647	.8641		8a		txa		                txa                          ;A=digit
648	.8642		65 e6		adc $e6		                adc $E6                      ;value*10+digit
649	.8644		90 e2		bcc $8628	                bcc parseDecimalDigit
650	.8646						errorReadingString2:
651	.8646		18		clc		                clc
652	.8647		60		rts		                rts

654	.8648						readNextDigitFromString:
655	.8648		c8		iny		                iny

657							; check if current string input byte is a digit.
658							;
659							; exit: C=1 if digit; C=0 if not digit
660	.8649						readDigitFromString:
661	.8649		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
662	.864b		c9 3a		cmp #$3a	                cmp #'9'+1
663	.864d		b0 0c		bcs $865b	                bcs errorReadingString       ;taken if not ASCII decimal digit
664	.864f		c9 30		cmp #$30	                cmp #'0'
665	.8651		90 08		bcc $865b	                bcc errorReadingString       ;taken if not ASCII decimal digit
666	.8653		29 0f		and #$0f	                and #$0F         ;convert ASCII decimaldigit to number
667	.8655		60		rts		                rts

669	.8656						L8641:
670	.8656		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
671							                .if version!=350
672	.8659		c9 0d		cmp #$0d	                cmp #$0D
673							                .endif
674	.865b						errorReadingString:
675	.865b		18		clc		                clc
676	.865c		60		rts		                rts

678							;-------------------------------------------------------------------------
679							;
680							; Read a hex digit from a string
681							;
682							; entry:
683							;
684							; (stringInputBufferAddress),y = next byte to read
685							;
686							; exit:
687							;
688							; C=1 if ok: A = digit read
689							;
690							; C=0 if error: A = value read, Z=1 if CR encountered
691							;
692	.865d						readHexDigit:
693	.865d		20 49 86	jsr $8649	                jsr readDigitFromString
694	.8660		b0 0d		bcs $866f	                bcs +                        ; branch taken if digit
695	.8662		29 df		and #$df	                and #$DF                     ; convert to upper case
696	.8664		c9 47		cmp #$47	                cmp #'F'+1
697	.8666		b0 ee		bcs $8656	                bcs L8641    ; branch taken if not ASCII A-F hex digit
698	.8668		c9 41		cmp #$41	                cmp #'A'
699	.866a		90 ea		bcc $8656	                bcc L8641     ;branch taken if not ASCII A-F hex digit
700							                ; convert ASCII A-F hex digit to number.
701	.866c		49 48		eor #$48	                eor #$48
702	.866e		1a		inc a		                inc a
703	.866f						+
704	.866f		c8		iny		                iny
705	.8670		60		rts		                rts

707							;-------------------------------------------------------------------------
708							;
709							; OSWORD 0 control block for *commands
710							; ====================================
711	.8671						commandLineUIOSWORD0Parameters:
712	>8671		00 dc				                .word hazel.commandLine      ; address
713	>8673		f0				                .byte $F0			; max # chars
714	>8674		20				                .byte $20			; min ASCII char
715	>8675		7e				                .byte $7E			; max ASCII char

717							;-------------------------------------------------------------------------

719	.8676						commandLineUI:
720	.8676		a9 a2		lda #$a2	                lda #<commandLineUIBRKHandler
721	.8678		8d 02 02	sta $0202	                sta BRKV+0
722	.867b		a9 86		lda #$86	                lda #>commandLineUIBRKHandler
723	.867d		8d 03 02	sta $0203	                sta BRKV+1
724	.8680		a9 1f		lda #$1f	                lda #$10|terminalROM         ;????
725	.8682		8d 8c 02	sta $028c	                sta currentLanguageROM
726	.8685						commandLineUILoop:
727	.8685		a2 ff		ldx #$ff	                ldx #$FF
728	.8687		9a		txs		                txs
729	.8688		58		cli		                cli
730	.8689		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
731	.868c		a9 2a		lda #$2a	                lda #'*'
732	.868e		20 ee ff	jsr $ffee	                jsr OSWRCH
733	.8691		20 b2 86	jsr $86b2	                jsr readCommandLine
734	.8694		90 03		bcc $8699	                bcc +                     ;taken if ESCAPE not pressed
735	.8696		4c 41 ae	jmp $ae41	                jmp escapeError
736	.8699						+
737	.8699		a2 00		ldx #$00	                ldx #<hazel.commandLine
738	.869b		a0 dc		ldy #$dc	                ldy #>hazel.commandLine
739	.869d		20 f7 ff	jsr $fff7	                jsr OSCLI
740	.86a0		80 e3		bra $8685	                bra commandLineUILoop

742	.86a2						commandLineUIBRKHandler:
743	.86a2		20 e7 ff	jsr $ffe7	                jsr OSNEWL
744	.86a5		a0 00		ldy #$00	                ldy #$00
745	.86a7		20 c0 e6	jsr $e6c0	                jsr printBRKMessage
746	.86aa		20 e7 ff	jsr $ffe7	                jsr OSNEWL
747	.86ad		80 c7		bra $8676	                bra commandLineUI

749	.86af						badCommandError869A:
750	.86af		4c bd fa	jmp $fabd	                jmp badCommandError

752	.86b2						readCommandLine:
753	.86b2		a9 00		lda #$00	                lda #$00
754	.86b4		a2 71		ldx #$71	                ldx #<commandLineUIOSWORD0Parameters
755	.86b6		a0 86		ldy #$86	                ldy #>commandLineUIOSWORD0Parameters
756	.86b8		4c f1 ff	jmp $fff1	                jmp OSWORD

758							;-------------------------------------------------------------------------
759							;
760							; *ROMS [MasRef C.5-10]
761							;
762	.86bb						starROMS:
763	.86bb		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
764	.86be		d0 ef		bne $86af	                bne badCommandError869A
765	.86c0		a0 0f		ldy #$0f	                ldy #$0F
766	.86c2						printROMsLoop:
767							                .if version<400&&version!=350
774							                .else
775	.86c2		98		tya		                tya
776	.86c3		aa		tax		                tax
777	.86c4		5a		phy		                phy
778	.86c5		20 31 f8	jsr $f831	                jsr isBankROM
779	.86c8		b0 0a		bcs $86d4	                bcs L86D2
780	.86ca		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
781	>86cd		52 4f 4d 20 00			                .text "ROM ",0
782	.86d2		80 08		bra $86dc	                bra L86DA
783	.86d4						L86D2:
784	.86d4		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
785	>86d7		52 41 4d 20 00			                .text "RAM ",0
786	.86dc						L86DA:
787	.86dc		7a		ply		                ply
788	.86dd		98		tya		                tya
789							                .endif
790	.86de		20 23 ae	jsr $ae23	                jsr printHexDigit            ;print ROM slot
791	.86e1		20 6f a7	jsr $a76f	                jsr printSpace
792	.86e4		a9 09		lda #$09	                lda #<sidewaysROMName
793	.86e6		85 f6		sta $f6		                sta $F6
794	.86e8		a9 80		lda #$80	                lda #>sidewaysROMName
795	.86ea		85 f7		sta $f7		                sta $F7
796							                .if version<400&&version!=350
798							                .endif
799	.86ec		20 94 e5	jsr $e594	                jsr isROMValidThenSelectTerminalROM
800							                .if version<400&&version!=350
802							                .endif
803	.86ef		90 4a		bcc $873b	                bcc invalidROM
804							                .if version>=500||version==350
808							                .endif
809	.86f1						printROMNameLoop:
810	.86f1		20 eb f1	jsr $f1eb	                jsr osrdscEntryPoint     ;read name byte
811	.86f4		c9 20		cmp #$20	                cmp #' '
812	.86f6		90 0f		bcc $8707	                bcc printROMVersion ;taken if non-printable char, including the terminating 0
813	.86f8		c9 7f		cmp #$7f	                cmp #127
814	.86fa		b0 3f		bcs $873b	                bcs invalidROM  ;taken if bad (bit 7 set) char in name
815	.86fc		20 ee ff	jsr $ffee	                jsr OSWRCH
816	.86ff		e6 f6		inc $f6		                inc $F6
817	.8701		24 f6		bit $f6		                bit $F6
818	.8703		50 ec		bvc $86f1	                bvc printROMNameLoop         ;taken if address<$8040
819	.8705		80 34		bra $873b	                bra invalidROM               ;taken if name too long

821	.8707						printROMVersion:
822	.8707		aa		tax		                tax               ;Z=1 if final char was the expected 0
823	.8708		d0 31		bne $873b	                bne invalidROM    ;taken if bad (control) char in name
824	.870a		a9 08		lda #$08	                lda #<sidewaysROMVersion
825	.870c		85 f6		sta $f6		                sta $F6
826	.870e		a9 80		lda #$80	                lda #>sidewaysROMVersion
827	.8710		85 f7		sta $f7		                sta $F7
828	.8712		20 eb f1	jsr $f1eb	                jsr osrdscEntryPoint
829	.8715		20 15 ae	jsr $ae15	                jsr printSpaceThenPrintHexByte
830	.8718						printInsertionStatus:
831	.8718		5a		phy		                phy
832							                .if version<500&&version!=350
833	.8719		20 63 e8	jsr $e863	                jsr getROMInsertedFlagRTCAddressAndMask
834	.871c		85 b0		sta $b0		                sta starROMSWorkspace.insertedFlagMask
835	.871e		20 4b 9b	jsr $9b4b	                jsr readRTCByte
836	.8721		25 b0		and $b0		                and starROMSWorkspace.insertedFlagMask
839							                .endif
840	.8723		d0 0e		bne $8733	                bne +
841	.8725		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
842	>8728		20 75 6e 70 6c 75 67 67		                .text " unplugged",0
	>8730		65 64 00
843	.8733						+
844	.8733		7a		ply		                ply
845	.8734		20 e7 ff	jsr $ffe7	                jsr OSNEWL
846	.8737		88		dey		                dey
847	.8738		10 88		bpl $86c2	                bpl printROMsLoop
848	.873a		60		rts		                rts

850	.873b						invalidROM:
851	.873b		a9 3f		lda #$3f	                lda #'?'
852	.873d		20 ee ff	jsr $ffee	                jsr OSWRCH
853	.8740		80 d6		bra $8718	                bra printInsertionStatus

855							;-------------------------------------------------------------------------

857							                .if useTableDrivenConfigure
864							                .endif

866							;-------------------------------------------------------------------------
867							;
868							; *INSERT [MasRef C.5-8]
869							;
870	.8742						starINSERT:
871	.8742		38		sec		                sec
872	.8743		80 01		bra $8746	                bra starINSERTOrStarUNPLUG

874							;-------------------------------------------------------------------------
875							;
876							; *UNPLUG [MasRef C.5-13]
877							;
878	.8745						starUNPLUG:
879	.8745		18		clc		                clc
880	.8746						starINSERTOrStarUNPLUG:
881	.8746		08		php		                php
882	.8747		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
883							                .if useTableDrivenConfigure
885							                .else
886	.874a		20 f5 8c	jsr $8cf5	                jsr parseSingle4BitNumberFromCommandLine
887							                .endif
888	.874d		a8		tay		                tay                          ;Y=ROM number
889	.874e		20 63 e8	jsr $e863	                jsr getROMInsertedFlagRTCAddressAndMask
890	.8751		48		pha		                pha
891	.8752		20 4b 9b	jsr $9b4b	                jsr readRTCByte
892	.8755		84 b0		sty $b0		                sty starROMSWorkspace.insertedFlagMask
893	.8757		68		pla		                pla
894	.8758		28		plp		                plp
895	.8759		90 04		bcc $875f	                bcc unplug                   ;taken if it's *UNPLUG

897							                ; it's *INSERT
898	.875b		05 b0		ora $b0		                ora starROMSWorkspace.insertedFlagMask
899	.875d		80 04		bra $8763	                bra +
900	.875f						unplug:
901	.875f		49 ff		eor #$ff	                eor #$FF
902	.8761		25 b0		and $b0		                and starROMSWorkspace.insertedFlagMask
903	.8763						+
904	.8763		a8		tay		                tay
905	.8764		4c 78 9b	jmp $9b78	                jmp writeRTCByte

907							;-------------------------------------------------------------------------
908							;
909							; *TIME [MasRef C.5-12]
910							;
911	.8767						starTIME:
912	.8767		9c 00 dc	stz $dc00	                stz hazel.commandLine
913	.876a		a2 00		ldx #$00	                ldx #<hazel.commandLine
914	.876c		a0 dc		ldy #$dc	                ldy #>hazel.commandLine
915	.876e		a9 0e		lda #$0e	                lda #$0E
916	.8770		20 f1 ff	jsr $fff1	                jsr OSWORD
917	.8773		a2 e7		ldx #$e7	                ldx #256-size(ClockStringFormat)
918	.8775						L8752:
919	.8775		bd 19 db	lda $db19,x	                lda hazel.commandLine-(256-size(ClockStringFormat)),x
920	.8778		20 e3 ff	jsr $ffe3	                jsr OSASCI
921	.877b		e8		inx		                inx
922	.877c		d0 f7		bne $8775	                bne L8752
923	.877e		60		rts		                rts

925							;-------------------------------------------------------------------------

927							                .if version==350
937							                .elsif version<500
938							                .include "sram_utils.s65"

:6	;******  Processing file: src/sram_utils.s65

1							;-------------------------------------------------------------------------

3							; osword42SetupTable[i] is offset into sramWorkspace for OSWORD
4							; parameter block byte i

6	.877f						osword42SetupTable:
7							                .if version>=500||version==350
9							                .endif
10	>877f		09				                .byte sramWorkspace.dataAddress+0-sramWorkspace
11	>8780		0a				                .byte sramWorkspace.dataAddress+1-sramWorkspace
12	>8781		0b				                .byte sramWorkspace.dataAddress+2-sramWorkspace
13	>8782		0c				                .byte sramWorkspace.dataAddress+3-sramWorkspace
14	>8783		02				                .byte sramWorkspace.length+0-sramWorkspace
15	>8784		03				                .byte sramWorkspace.length+1-sramWorkspace
16	>8785		04				                .byte sramWorkspace.bank-sramWorkspace
17	>8786		05				                .byte sramWorkspace.sramAddress+0-sramWorkspace
18	>8787		06				                .byte sramWorkspace.sramAddress+1-sramWorkspace

20							;-------------------------------------------------------------------------
21							;
22							; OSWORD $42 - Sideways RAM Block Transfor (G.7-7)
23							;
24							; Entry: parameter block like this:
25							;
26							;    block?0 - bit 7 clear=sram->memory, set=memory->sram
27							;              bit 6 clear=absolute, set=pseudo
28							;    block!1 - data address
29							;    (block+5); - block length
30							;    block?7 - ROM ID 0-$0f, or $10-$13 for W/X/Y/Z
31							;    (block+8); - sideways RAM address
32							;
33	.8788						osword42: .proc
34							                .if version==400
35	.8788		b2 f0		lda ($f0)	                lda (originalX)
36	.878a		29 c0		and #$c0	                and #$c0
37	.878c		8d ee 02	sta $02ee	                sta sramWorkspace.type
38							                .endif
39	.878f		a0 09		ldy #$09	                ldy #9

41	.8791						copyFromParameterBlockLoop:
42	.8791		b1 f0		lda ($f0),y	                lda (originalX),y
43							                .if version==400
44	.8793		be 7e 87	ldx $877e,y	                ldx osword42SetupTable-1,y
47							                .endif
48	.8796		9d ed 02	sta $02ed,x	                sta sramWorkspace,x
49	.8799		88		dey		                dey
50							                .if version==400
51	.879a		d0 f5		bne $8791	                bne copyFromParameterBlockLoop
55							                .endif

57	.879c						saveTransferPointersLoop:
58	.879c		b9 b0 00	lda $00b0,y	                lda sramTransferPointers,y
59	.879f		48		pha		                pha
60	.87a0		c8		iny		                iny
61	.87a1		c0 04		cpy #$04	                cpy #size(sramTransferPointers)
62	.87a3		90 f7		bcc $879c	                bcc saveTransferPointersLoop

64	.87a5		20 35 89	jsr $8935	                jsr doSidewaysRAMBlockTransfer

66	.87a8		a0 03		ldy #$03	                ldy #size(sramTransferPointers)-1
67	.87aa						restoreTransferPointersLoop:
68	.87aa		68		pla		                pla
69	.87ab		99 b0 00	sta $00b0,y	                sta sramTransferPointers,y
70	.87ae		88		dey		                dey
71	.87af		10 f9		bpl $87aa	                bpl restoreTransferPointersLoop
72	.87b1		60		rts		                rts
73							                .endproc

75							;-------------------------------------------------------------------------

77	.87b2						convertSidewaysRAMPseudoAddress:
78	.87b2		2c ee 02	bit $02ee	                bit sramWorkspace.type
79	.87b5		50 30		bvc $87e7	                bvc checkROMID ;taken if absolute addressing - nothing to do

81							                ; Sort out pseudo address - see MasRef G.7-5
82	.87b7		a0 04		ldy #$04	                ldy #4          ; 4=first SRAM bank
83	.87b9		ad f2 02	lda $02f2	                lda sramWorkspace.sramAddress+0 ; pseudo address
84	.87bc		ae f3 02	ldx $02f3	                ldx sramWorkspace.sramAddress+1 ; pseudo address
85	.87bf						findStartBankLoop:
86	.87bf		e0 3f		cpx #$3f	                cpx #>dataBankSize
87	.87c1		90 16		bcc $87d9	                bcc foundStartBank ; taken if MSB $00-$3e
88	.87c3		d0 04		bne $87c9	                bne nextBank       ; taken if MSB >=$40

90							                ; Address is 16 KB-the dummy header size
91	.87c5		c9 f0		cmp #$f0	                cmp #<dataBankSize
92	.87c7		90 10		bcc $87d9	                bcc foundStartBank ; taken if address<$3ff0

94	.87c9						nextBank:
95	.87c9		e9 f0		sbc #$f0	                sbc #<dataBankSize
96	.87cb		48		pha		                pha
97	.87cc		8a		txa		                txa
98	.87cd		e9 3f		sbc #$3f	                sbc #>dataBankSize
99	.87cf		aa		tax		                tax
100	.87d0		68		pla		                pla
101	.87d1		c8		iny		                iny
102	.87d2		c0 08		cpy #$08	                cpy #8          ; 8=last SRAM bank
103	.87d4		90 e9		bcc $87bf	                bcc findStartBankLoop ; taken if more banks to go
104	.87d6		4c df 95	jmp $95df	                jmp badAddressError ; taken if pseudo address out of range

106	.87d9						foundStartBank:
107							                ; form actual address in sramAddress!5
108	.87d9		69 10		adc #$10	                adc #<dataBankStart
109	.87db		8d f2 02	sta $02f2	                sta sramWorkspace.sramAddress+0
110	.87de		8a		txa		                txa
111	.87df		69 80		adc #$80	                adc #>dataBankStart
112	.87e1		8d f3 02	sta $02f3	                sta sramWorkspace.sramAddress+1
113	.87e4		8c f1 02	sty $02f1	                sty sramWorkspace.bank ; save ROM number
114							                .cerror *!=checkROMID ; fall through to checkROMID

116							;-------------------------------------------------------------------------
117							;
118							; Check ROM ID (as read by readROMID) is valid.
119							;
120							; Entry:
121							;
122							; sramWorkspace.bank = ROM ID
123							;
124							; Exit:
125							;
126							; A=$40 Z=0 if operation addressing mode/bank addressing mode mismatch
127							;
128							; May also generate a "Bad id" error.

130	.87e7						checkROMID: .proc
131	.87e7		ad f1 02	lda $02f1	                lda sramWorkspace.bank
132	.87ea		c9 10		cmp #$10	                cmp #$10
133	.87ec		90 09		bcc $87f7	                bcc gotValidROMID       ; if <16, use as-is

135							                ; convert W/X/Y/Z to 4-7
136	.87ee		c9 14		cmp #$14	                cmp #$14
137	.87f0		b0 1e		bcs $8810	                bcs badIdError  ; bad id if >=$14
138	.87f2		49 14		eor #$14	                eor #$14        ; $10->$04, $11->$05, $12->$06, $13->$07
139	.87f4		8d f1 02	sta $02f1	                sta sramWorkspace.bank

141	.87f7						gotValidROMID:
142	.87f7		aa		tax		                tax
143	.87f8		20 31 f8	jsr $f831	                jsr isBankROM
144	.87fb		b0 07		bcs $8804	                bcs gotValidBank ; taken if RAM
145	.87fd		2c ee 02	bit $02ee	                bit sramWorkspace.type

147							                ; Don't understand the logic here?
148	.8800		10 0e		bpl $8810	                bpl badIdError  ; taken if read operation
149	.8802		70 0c		bvs $8810	                bvs badIdError  ; taken if pseudo addressing

151	.8804						gotValidBank:
152	.8804		20 35 8b	jsr $8b35	                jsr sramGetBankMode        ; A=$40 if pseudo
153	.8807		ae f1 02	ldx $02f1	                ldx sramWorkspace.bank
154	.880a		4d ee 02	eor $02ee	                eor sramWorkspace.type
155	.880d		29 40		and #$40	                and #$40
156	.880f		60		rts		                rts
157							                .endproc

159							;-------------------------------------------------------------------------

161	.8810						badIdError:
162	.8810		20 23 b0	jsr $b023	                jsr doFollowingError
163	>8813		80				                .byte $80
164	>8814		42 61 64 20 69 64		                .text "Bad id"
165	>881a		00				                .byte 0

167							;-------------------------------------------------------------------------
168							;
169							; Read ROM ID from command line.
170							;
171							; Entry:
172							;
173							; ($f2),y = command line input pointer
174							;
175							; Exit:
176							;
177							; V=1 if invalid
178							;
179							; V=0 if valid
180							;    osfileParameterBlock?1 bit 6 cleared
181							;    osfileParameterBlock?4 is ROM ID
182							;
183							; May also generate a "Bad id" error.
184							;
185	.881b						readROMID: .proc
186	.881b		20 5d 86	jsr $865d	                jsr readHexDigit ; get char, possibly hex
187	.881e		2c 5e e3	bit $e35e	                bit valueFF      ; V=1
188	.8821		b0 0d		bcs $8830	                bcs got1CharROMID  ; taken if hex digit encountered
189	.8823		29 df		and #$df	                and #$DF         ; redundantly convert to upper case
190	.8825		c9 5b		cmp #$5b	                cmp #'Z'+1
191	.8827		b0 1d		bcs $8846	                bcs done        ; taken if >'Z' - not valid
192	.8829		c9 57		cmp #$57	                cmp #'W'
193	.882b		90 19		bcc $8846	                bcc done        ; taken if <'W' - not valid
194	.882d		e9 53		sbc #$53	                sbc #'W'-4      ; adjust: W=4, X=5, Y=6, Z=7
195	.882f		c8		iny		                iny             ; consume command line char

197	.8830						got1CharROMID:
198							                ; Handle decimal numbers: if the bank was 1, it might
199							                ; be "1" or the first char of "10", "11", etc. Handle
200							                ; accordingly.
201							                ;
202							                ; (If using the W/X/Y/Z syntax, the banks are 4-7.)
203	.8830		c9 01		cmp #$01	                cmp #1
204	.8832		d0 09		bne $883d	                bne gotROMID
205	.8834		88		dey		                dey             ; go back to the got char
206	.8835		20 fb 85	jsr $85fb	                jsr parseNumberFromString ; read as number
207	.8838		8a		txa		                txa                       ; A = result
208	.8839		c9 10		cmp #$10	                cmp #$10
209	.883b		b0 d3		bcs $8810	                bcs badIdError  ; bad id if >15

211	.883d						gotROMID:
212							                ; +4 = romid
213	.883d		8d f1 02	sta $02f1	                sta sramWorkspace.bank

215							                ; clear +1 bit 6 - indicate valid rom id?
216	.8840		a9 40		lda #$40	                lda #$40
217	.8842		1c ee 02	trb $02ee	                trb sramWorkspace.type
218	.8845		b8		clv		                clv             ; V=0

220	.8846						done:
221	.8846		4c ee f0	jmp $f0ee	                jmp skipSpacesAndCheckForCRInStringInput
222							                .endproc

224							;-------------------------------------------------------------------------

226	.8849						starSRDATAOrStarSRROM:
227	.8849		48		pha		                pha
228	.884a		20 1b 88	jsr $881b	                jsr readROMID
229	.884d		70 22		bvs $8871	                bvs jmpBadCommandError8CD6 ; taken if invalid ROM ID
230	.884f		d0 20		bne $8871	                bne jmpBadCommandError8CD6 ; taken if bad command line
231							                                           ; contents
232	.8851		68		pla		                pla

234							                ; $80 if *SRDATA; $00 if *SRROM
235							                .if version==400
236	.8852		20 88 8a	jsr $8a88	                jsr sramInitType
240							                .endif
241	.8855		20 e7 87	jsr $87e7	                jsr checkROMID
242	.8858		b0 b6		bcs $8810	                bcs badIdError  ; taken if bank could never be used
243							                                ; with pseudo addressing
244	.885a		d0 06		bne $8862	                bne toggleModeAndInitBank ; taken if switching to other bank mode

246							                ; If bank mode didn't change, but there's nothing in
247							                ; the bank already, set up the dummy ROM header for
248							                ; it.
249	.885c		1d a1 02	ora $02a1,x	                ora romInformationTable,x
250	.885f		f0 0a		beq $886b	                beq initBank
251	.8861		60		rts		                rts

253	.8862						toggleModeAndInitBank:
254	.8862		ad de df	lda $dfde	                lda hazel.sramBankModes
255	.8865		5d fd 8a	eor $8afd,x	                eor sramBank4567ModeMasks-4,x
256	.8868		8d de df	sta $dfde	                sta hazel.sramBankModes

258	.886b						initBank:
259	.886b		20 fb 8a	jsr $8afb	                jsr setROMXType6502
260	.886e		4c 13 f8	jmp $f813	                jmp initDummyROMHeader

262							;-------------------------------------------------------------------------

264	.8871						jmpBadCommandError8CD6:
265	.8871		4c bd fa	jmp $fabd	                jmp badCommandError

267							;-------------------------------------------------------------------------

269	.8874						L8CD9:
270	.8874		20 85 88	jsr $8885	                jsr L8CEA
271	.8877		b0 0b		bcs $8884	                bcs locret_8CE9
272	.8879		20 a1 f7	jsr $f7a1	                jsr transferBetweenSidewaysRAMAndRAM
273	.887c		8c f2 02	sty $02f2	                sty sramWorkspace.sramAddress+0
274	.887f		b5 01		lda $01,x	                lda 1,x
275	.8881		8d f3 02	sta $02f3	                sta sramWorkspace.sramAddress+1

277	.8884						locret_8CE9:
278	.8884		60		rts		                rts


281							;-------------------------------------------------------------------------

283	.8885						L8CEA:
284							                ; get sram transfer sram pointer address in X - src if
285							                ; reading from sideways RAM, dest if writing to
286							                ; sideways RAM
287	.8885		a2 b0		ldx #$b0	                ldx #sramTransferPointers.src
288	.8887		2c ee 02	bit $02ee	                bit sramWorkspace.type
289	.888a		10 02		bpl $888e	                bpl +           ; taken if reading from sideways RAM
290	.888c		a2 b2		ldx #$b2	                ldx #sramTransferPointers.dest
291	.888e						+
292	.888e		74 00		stz $00,x	                stz 0,x
293	.8890		ac f2 02	ldy $02f2	                ldy sramWorkspace.sramAddress+0 ; sram address LSB
294	.8893		98		tya		                tya                        ; Y=sram address LSB
295	.8894		18		clc		                clc
296	.8895		6d ef 02	adc $02ef	                adc sramWorkspace.length+0 ; form end address LSB
297	.8898		8d ef 02	sta $02ef	                sta sramWorkspace.length+0
298	.889b		ad f3 02	lda $02f3	                lda sramWorkspace.sramAddress+1 ; sram address MSB
299	.889e		95 01		sta $01,x	                sta 1,x                    ;
300	.88a0		6d f0 02	adc $02f0	                adc sramWorkspace.length+1 ; form end address MSB
301	.88a3		8d f0 02	sta $02f0	                sta sramWorkspace.length+1
302	.88a6		38		sec		                sec
303	.88a7		20 13 8b	jsr $8b13	                jsr initSRAMTransferDataPointer
304	.88aa						L8D0F:
305	.88aa		cc ef 02	cpy $02ef	                cpy sramWorkspace.length+0
306	.88ad		d0 08		bne $88b7	                bne L8D1C
307	.88af		b5 01		lda $01,x	                lda 1,x
308	.88b1		cd f0 02	cmp $02f0	                cmp sramWorkspace.length+1
309	.88b4		d0 01		bne $88b7	                bne L8D1C
310	.88b6		60		rts		                rts

312	.88b7						L8D1C:
313	.88b7		2c ee 02	bit $02ee	                bit sramWorkspace.type
314	.88ba		50 32		bvc $88ee	                bvc L8D53       ; taken if absolute addressing
315	.88bc		b5 01		lda $01,x	                lda 1,x         ; get sideways RAM pointer
316	.88be		c9 c0		cmp #$c0	                cmp #>(dataBankStart+dataBankSize) ; gone past end of bank?
317	.88c0		90 2c		bcc $88ee	                bcc L8D53       ; taken if not past end of bank
318	.88c2		a9 80		lda #$80	                lda #>dataBankStart
319	.88c4		95 01		sta $01,x	                sta 1,x                    ; reset pointer MSB
320	.88c6		ee f1 02	inc $02f1	                inc sramWorkspace.bank ; move to next bank
321	.88c9		ad f1 02	lda $02f1	                lda sramWorkspace.bank
322	.88cc		c9 08		cmp #$08	                cmp #8
323	.88ce		b0 2e		bcs $88fe	                bcs jmpBadAddressError ; bad address error if definitely past end of pseudo-addressable area
324	.88d0		da		phx		                phx
325	.88d1		20 e7 87	jsr $87e7	                jsr checkROMID  ; perform other ROM ID checks
326	.88d4		d0 28		bne $88fe	                bne jmpBadAddressError ; bad address error if bad
327	.88d6		fa		plx		                plx
328	.88d7		a0 10		ldy #$10	                ldy #<dataBankStart

330							                ; Subtract dataBankSize from count of bytes remaining
331	.88d9		ad ef 02	lda $02ef	                lda sramWorkspace.length+0
332	.88dc		38		sec		                sec
333	.88dd		e9 f0		sbc #$f0	                sbc #<dataBankSize
334	.88df		8d ef 02	sta $02ef	                sta sramWorkspace.length+0
335	.88e2		ad f0 02	lda $02f0	                lda sramWorkspace.length+1
336	.88e5		e9 3f		sbc #$3f	                sbc #>dataBankSize
337	.88e7		8d f0 02	sta $02f0	                sta sramWorkspace.length+1
338	.88ea		18		clc		                clc
339	.88eb		20 13 8b	jsr $8b13	                jsr initSRAMTransferDataPointer

341	.88ee						L8D53:
342	.88ee		ad f1 02	lda $02f1	                lda sramWorkspace.bank
343	.88f1		18		clc		                clc

345	.88f2						locret_8D57:
346	.88f2		60		rts		                rts

348							;-------------------------------------------------------------------------

350	.88f3						parse16BitHexAddressFromCommandLine:
351	.88f3		20 ef 95	jsr $95ef	                jsr parseHexAddressFromCommandLine
352	.88f6						checkParameterBlockAddressIs16Bit:
353	.88f6		bd ef 02	lda $02ef,x	                lda sramWorkspace.length+0,x
354	.88f9		1d f0 02	ora $02f0,x	                ora sramWorkspace.length+1,x
355	.88fc		f0 f4		beq $88f2	                beq locret_8D57

357	.88fe						jmpBadAddressError:
358	.88fe		4c df 95	jmp $95df	                jmp badAddressError

360							;-------------------------------------------------------------------------
361							;
362							; Read I from command line. From Master Compact app note: ``A facility
363							; to load an SRAM image and update the MOS ROM type table has been
364							; added. An "I" should be added to the *SRLOAD command.''
365							;
366							                .if version==350||version>=500
381							                .endif

383							;-------------------------------------------------------------------------
384							;
385							; C=0 for *SRREAD
386							;
387	.8901						starSRREADOrStarSRWRITE:
388							                .if version==400
389	.8901		20 88 8a	jsr $8a88	                jsr sramInitType
393							                .endif

395	.8904		a2 09		ldx #$09	                ldx #sramWorkspace.dataAddress-osfileParameterBlock
396	.8906		20 ef 95	jsr $95ef	                jsr parseHexAddressFromCommandLine
397	.8909		20 05 8b	jsr $8b05	                jsr checkForPlusInCommandLine
398	.890c		a2 02		ldx #$02	                ldx #sramWorkspace.length-osfileParameterBlock
399	.890e		20 ef 95	jsr $95ef	                jsr parseHexAddressFromCommandLine
400	.8911		70 10		bvs $8923	                bvs L8DA2 ; taken if + encountered, so +2 is already the length

402							                ; sramWorkspace.length is actually the end address -
403							                ; substract start address to turn it into the length.
404	.8913		a2 fc		ldx #$fc	                ldx #$FC

406	.8915						L8D94:
407	.8915		bd f3 01	lda $01f3,x	                lda sramWorkspace.length-$FC,x
408	.8918		fd fa 01	sbc $01fa,x	                sbc sramWorkspace.dataAddress-$FC,x
409	.891b		9d f3 01	sta $01f3,x	                sta sramWorkspace.length-$FC,x
410	.891e		e8		inx		                inx
411	.891f		d0 f4		bne $8915	                bne L8D94
412	.8921		90 db		bcc $88fe	                bcc jmpBadAddressError ; taken if end<start

414	.8923						L8DA2:
415							                ; Check length is a 16 bit quantity
416	.8923		a2 02		ldx #$02	                ldx #sramWorkspace.length-osfileParameterBlock
417	.8925		20 f6 88	jsr $88f6	                jsr checkParameterBlockAddressIs16Bit

419							                ; Parse SRAM address
420	.8928		a2 05		ldx #$05	                ldx #sramWorkspace.sramAddress-osfileParameterBlock
421	.892a		20 f3 88	jsr $88f3	                jsr parse16BitHexAddressFromCommandLine

423							                ; Read ROM ID
424	.892d		20 1b 88	jsr $881b	                jsr readROMID

426							                .if version>=500||version==350
428							                .endif
429	.8930		f0 03		beq $8935	                beq doSidewaysRAMBlockTransfer

431	.8932						jmpBadCommandError8DB4:
432	.8932		4c bd fa	jmp $fabd	                jmp badCommandError

434	.8935						doSidewaysRAMBlockTransfer:
435	.8935		08		php		                php
436	.8936		20 b2 87	jsr $87b2	                jsr convertSidewaysRAMPseudoAddress
437	.8939		f0 03		beq $893e	                beq L8DC0
438	.893b		20 10 88	jsr $8810	                jsr badIdError  ; should be a jmp; will never return
439	.893e						L8DC0:
440	.893e		20 f1 8a	jsr $8af1	                jsr L8F40
441							                .if includeTubeSupport
442	.8941		ad f8 02	lda $02f8	                lda sramWorkspace.dataAddress+2
443	.8944		2d f9 02	and $02f9	                and sramWorkspace.dataAddress+3
444	.8947		1a		inc a		                inc a
445	.8948		2d 7a 02	and $027a	                and tubePresence
446	.894b		d0 05		bne $8952	                bne L8952
447							                .endif
448	.894d		20 74 88	jsr $8874	                jsr L8CD9
449	.8950		28		plp		                plp
450							                .if version==400
451	.8951		60		rts		                rts
454							                .endif

456							;-------------------------------------------------------------------------

458							                .if includeTubeSupport
459	.8952						L8952:
460	.8952		a9 c8		lda #$c8	                lda #$c8    ; 8 = claimant code for sideways RAM utils
461	.8954		20 06 04	jsr $0406	                jsr $0406   ; claim Tube
462	.8957		90 f9		bcc $8952	                bcc L8952       ; if it failed, try again
463	.8959		a9 00		lda #$00	                lda #0          ; multi byte parasite->host
464	.895b		2c ee 02	bit $02ee	                bit sramWorkspace.type
465	.895e		30 01		bmi $8961	                bmi +           ; taken if writing to sideways RAM
466	.8960		1a		inc a		                inc a           ; multi byte host->parasite
467	.8961						+
468	.8961		a2 f6		ldx #$f6	                ldx #<sramWorkspace.dataAddress
469	.8963		a0 02		ldy #$02	                ldy #>sramWorkspace.dataAddress
470	.8965		20 06 04	jsr $0406	                jsr $0406       ; begin transfer to/from data address
471	.8968		20 85 88	jsr $8885	                jsr L8CEA
472	.896b		b0 03		bcs $8970	                bcs L8970
473	.896d		20 d1 f7	jsr $f7d1	                jsr transferSidewaysRAMOverTube
474	.8970						L8970:
475	.8970		a9 88		lda #$88	                lda #$88
476	.8972		20 06 04	jsr $0406	                jsr $0406
477	.8975		28		plp		                plp
478	.8976		60		rts		                rts
479							                .endif

481							;-------------------------------------------------------------------------

483	.8977						starSRLOADOrStarSRSAVE:
484							                .if version==400
485	.8977		20 88 8a	jsr $8a88	                jsr sramInitType
489							                .endif
490	.897a		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
491	.897d		86 f2		stx $f2		                stx stringInputBufferAddress
492	.897f		84 f3		sty $f3		                sty stringInputBufferAddress+1
493	.8981		8e ef 02	stx $02ef	                stx sramWorkspace.length+0
494	.8984		8c f0 02	sty $02f0	                sty sramWorkspace.length+1
495	.8987		a0 00		ldy #$00	                ldy #0
496	.8989		20 5c f0	jsr $f05c	                jsr gsinitForFilenameParsing

498	.898c						L8DE0:
499	.898c		20 6e f0	jsr $f06e	                jsr gsreadEntryPoint
500	.898f		90 fb		bcc $898c	                bcc L8DE0
501	.8991		a2 05		ldx #$05	                ldx #5
502	.8993		20 f3 88	jsr $88f3	                jsr parse16BitHexAddressFromCommandLine
503	.8996		2c ee 02	bit $02ee	                bit sramWorkspace.type
504	.8999		30 1e		bmi $89b9	                bmi L8E0D
505	.899b		20 05 8b	jsr $8b05	                jsr checkForPlusInCommandLine
506	.899e		a2 07		ldx #$07	                ldx #7
507	.89a0		20 f3 88	jsr $88f3	                jsr parse16BitHexAddressFromCommandLine
508	.89a3		70 14		bvs $89b9	                bvs L8E0D
509	.89a5		38		sec		                sec
510	.89a6		a2 fe		ldx #$fe	                ldx #$FE

512	.89a8						L8DFC:
513	.89a8		bd f6 01	lda $01f6,x	                lda sramWorkspace.sramAddress+2-$FE,x
514	.89ab		fd f4 01	sbc $01f4,x	                sbc sramWorkspace.sramAddress+0-$FE,x
515	.89ae		9d f6 01	sta $01f6,x	                sta sramWorkspace.sramAddress+2-$FE,x
516	.89b1		e8		inx		                inx
517	.89b2		d0 f4		bne $89a8	                bne L8DFC
518	.89b4		b0 03		bcs $89b9	                bcs L8E0D
519	.89b6		4c fe 88	jmp $88fe	                jmp jmpBadAddressError

521							;-------------------------------------------------------------------------

523	.89b9						L8E0D:
524	.89b9		20 1b 88	jsr $881b	                jsr readROMID
525	.89bc		9c f8 02	stz $02f8	                stz sramWorkspace.dataAddress+2
526							                .if version==350
528							                .else
529	.89bf		a2 00		ldx #$00	                ldx #0
530							                .endif
531							                .if version>=500||version==350
533							                .endif
534	.89c1		29 df		and #$df	                and #$DF
535							                .if version==350
537							                .endif
538	.89c3		c9 51		cmp #$51	                cmp #'Q'
539							                .if version==350
541							                .else
542	.89c5		d0 02		bne $89c9	                bne L8E20
543							                .endif
544							                .if version==350
546							                .endif
547							                .if version==350
552							                .else
553	.89c7		ca		dex		                dex
554	.89c8		c8		iny		                iny
555							                .endif

557	.89c9						L8E20:
558	.89c9		8e f9 02	stx $02f9	                stx sramWorkspace.dataAddress+3
559	.89cc		ae 34 fe	ldx $fe34	                ldx ACCCON
560							                .if version==400
561	.89cf		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
564							                .endif
565	.89d2		f0 1b		beq $89ef	                beq L8E41
566	.89d4		4c 32 89	jmp $8932	                jmp jmpBadCommandError8DB4

568							;-------------------------------------------------------------------------

570	.89d7						osword43:
571	.89d7		ae 34 fe	ldx $fe34	                ldx ACCCON
572	.89da		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
573	.89dd		9c c6 df	stz $dfc6	                stz hazel.tempFSFlag
574	.89e0		a0 0b		ldy #$0b	                ldy #$B

576	.89e2						L8E39:
577	.89e2		b1 f0		lda ($f0),y	                lda (originalX),y
578	.89e4		99 ee 02	sta $02ee,y	                sta sramWorkspace.type,y
579	.89e7		88		dey		                dey
580	.89e8		10 f8		bpl $89e2	                bpl L8E39
581							                .if version==400
582	.89ea		a9 3f		lda #$3f	                lda #$3f
583	.89ec		1c ee 02	trb $02ee	                trb sramWorkspace.type
584							                .endif

586	.89ef						L8E41:
587	.89ef		08		php		                php
588	.89f0		da		phx		                phx
589	.89f1		20 b2 87	jsr $87b2	                jsr convertSidewaysRAMPseudoAddress
590	.89f4		f0 03		beq $89f9	                beq L8E4B
591	.89f6		4c 10 88	jmp $8810	                jmp badIdError
592	.89f9						L8E4B:
593	.89f9		ad f9 02	lda $02f9	                lda sramWorkspace.dataAddress+3
594	.89fc		30 0b		bmi $8a09	                bmi L8E5B
595	.89fe		0d f8 02	ora $02f8	                ora sramWorkspace.dataAddress+2
596	.8a01		d0 1d		bne $8a20	                bne L8E72
597	.8a03		a9 02		lda #$02	                lda #2
598	.8a05		a0 dd		ldy #$dd	                ldy #>hazel.ddxx
599	.8a07		80 0b		bra $8a14	                bra L8E66

601							;-------------------------------------------------------------------------

603	.8a09						L8E5B:
604	.8a09		20 a9 ef	jsr $efa9	                jsr osbyte84
605	.8a0c		98		tya		                tya
606	.8a0d		38		sec		                sec
607	.8a0e		ed 44 02	sbc $0244	                sbc oshwm
608	.8a11		ac 44 02	ldy $0244	                ldy oshwm

610	.8a14						L8E66:
611	.8a14		9c f6 02	stz $02f6	                stz sramWorkspace.dataAddress+0
612	.8a17		8c f7 02	sty $02f7	                sty sramWorkspace.dataAddress+1
613	.8a1a		9c f8 02	stz $02f8	                stz sramWorkspace.dataAddress+2
614	.8a1d		8d f9 02	sta $02f9	                sta sramWorkspace.dataAddress+3

616	.8a20						L8E72:
617	.8a20		2c ee 02	bit $02ee	                bit sramWorkspace.type
618	.8a23		10 36		bpl $8a5b	                bpl L8EAF
619	.8a25		a9 40		lda #$40	                lda #findOpenForRead
620	.8a27		20 cc 8a	jsr $8acc	                jsr sramOpenFile

622	.8a2a						L8E7C:
623	.8a2a		38		sec		                sec
624	.8a2b		20 9e 8a	jsr $8a9e	                jsr L8EED
625	.8a2e		a9 04		lda #$04	                lda #gbpbGetBytesCurrentPTR
626	.8a30		20 c5 8a	jsr $8ac5	                jsr sramOSGBPB
627	.8a33		08		php		                php
628	.8a34		90 0e		bcc $8a44	                bcc L8E96
629	.8a36		a2 fe		ldx #$fe	                ldx #$FE

631	.8a38						L8E8A:
632	.8a38		bd f1 01	lda $01f1,x	                lda sramWorkspace.length+0-$FE,x

634	.8a3b						L8E8D:
635	.8a3b		fd ce de	sbc $dece,x	                sbc hazel.moveOSGBPB+OSGBPBParameterBlock.count+0-$fe,x
636	.8a3e		9d f1 01	sta $01f1,x	                sta sramWorkspace.length+0-$FE,x
637	.8a41		e8		inx		                inx
638	.8a42		d0 f4		bne $8a38	                bne L8E8A

640	.8a44						L8E96:
641	.8a44		20 74 88	jsr $8874	                jsr L8CD9
642	.8a47		28		plp		                plp
643	.8a48		90 e0		bcc $8a2a	                bcc L8E7C

645	.8a4a						L8E9C:
646	.8a4a		ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle
647	.8a4d		9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
648	.8a50		a9 00		lda #$00	                lda #0
649	.8a52		20 ce ff	jsr $ffce	                jsr OSFIND
650	.8a55		68		pla		                pla
651	.8a56		8d 34 fe	sta $fe34	                sta ACCCON
652	.8a59		28		plp		                plp
653							                .if version==400
654	.8a5a		60		rts		                rts
657							                .endif

659							;-------------------------------------------------------------------------

661	.8a5b						L8EAF:
662	.8a5b		a9 80		lda #$80	                lda #findOpenForWrite
663	.8a5d		20 cc 8a	jsr $8acc	                jsr sramOpenFile

665	.8a60						L8EB4:
666	.8a60		38		sec		                sec
667	.8a61		a2 fe		ldx #$fe	                ldx #$FE

669	.8a63						L8EB7:
670	.8a63		bd f6 01	lda $01f6,x	                lda sramWorkspace.sramAddress+2-$FE,x
671	.8a66		9d b2 ff	sta $ffb2,x	                sta @w sramTransferPointers-$fe,x
672	.8a69		fd fa 01	sbc $01fa,x	                sbc sramWorkspace.dataAddress+2-$FE,x
673	.8a6c		9d f6 01	sta $01f6,x	                sta sramWorkspace.sramAddress+2-$FE,x
674	.8a6f		e8		inx		                inx
675	.8a70		d0 f1		bne $8a63	                bne L8EB7
676	.8a72		0d f4 02	ora $02f4	                ora sramWorkspace.sramAddress+2
677	.8a75		08		php		                php
678	.8a76		20 9e 8a	jsr $8a9e	                jsr L8EED
679	.8a79		20 74 88	jsr $8874	                jsr L8CD9
680	.8a7c		a9 02		lda #$02	                lda #gbpbPutBytesCurrentPTR
681	.8a7e		20 c5 8a	jsr $8ac5	                jsr sramOSGBPB
682	.8a81		28		plp		                plp
683	.8a82		90 c6		bcc $8a4a	                bcc L8E9C
684	.8a84		f0 c4		beq $8a4a	                beq L8E9C
685	.8a86		80 d8		bra $8a60	                bra L8EB4

687							;-------------------------------------------------------------------------

689							                .if version==400
690	.8a88						sramInitType:
691	.8a88		0a		asl a		                asl a
692	.8a89		8d ee 02	sta $02ee	                sta sramWorkspace.type
693	.8a8c		60		rts		                rts
694							                .endif

696							;-------------------------------------------------------------------------
697							;
698							; OSBYTE 68 (&44) - Test RAM presence [MasRef D.2-28]
699							;
700	.8a8d						osbyte44:
701	.8a8d		a9 00		lda #$00	                lda #0
702	.8a8f		a2 07		ldx #$07	                ldx #7
703	.8a91						osbyte44Loop:
704	.8a91		48		pha		                pha
705	.8a92		20 31 f8	jsr $f831	                jsr isBankROM
706	.8a95		68		pla		                pla
707	.8a96		2a		rol a		                rol a
708	.8a97		ca		dex		                dex
709	.8a98		e0 04		cpx #$04	                cpx #4
710	.8a9a		b0 f5		bcs $8a91	                bcs osbyte44Loop
711	.8a9c		aa		tax		                tax
712	.8a9d		60		rts		                rts

714							;-------------------------------------------------------------------------

716	.8a9e						L8EED:
717	.8a9e		ad d4 df	lda $dfd4	                lda hazel.moveSrcHandle
718	.8aa1		8d c7 df	sta $dfc7	                sta hazel.moveOSGBPB.handle
719	.8aa4		a2 01		ldx #$01	                ldx #1

721	.8aa6						L8EF5:
722	.8aa6		bd f6 02	lda $02f6,x	                lda sramWorkspace.dataAddress+0,x
723	.8aa9		9d c8 df	sta $dfc8,x	                sta hazel.moveOSGBPB.addr,x
724	.8aac		bd f8 02	lda $02f8,x	                lda sramWorkspace.dataAddress+2,x
725	.8aaf		b0 02		bcs $8ab3	                bcs L8F02
726	.8ab1		b5 b0		lda $b0,x	                lda sramTransferPointers.src,x

728	.8ab3						L8F02:
729	.8ab3		9d cc df	sta $dfcc,x	                sta hazel.moveOSGBPB.numBytes,x
730	.8ab6		9d ef 02	sta $02ef,x	                sta sramWorkspace.length+0,x
731	.8ab9		a9 ff		lda #$ff	                lda #$FF
732	.8abb		9d ca df	sta $dfca,x	                sta hazel.moveOSGBPB.addr+2,x ; address is in I/O processor
733	.8abe		9e ce df	stz $dfce,x	                stz hazel.moveOSGBPB.numBytes+2,x ; size is 16-bit quantity
734	.8ac1		ca		dex		                dex
735	.8ac2		10 e2		bpl $8aa6	                bpl L8EF5
736	.8ac4		60		rts		                rts


739							;-------------------------------------------------------------------------

741	.8ac5						sramOSGBPB:
742	.8ac5		a2 c7		ldx #$c7	                ldx #<hazel.moveOSGBPB
743	.8ac7		a0 df		ldy #$df	                ldy #>hazel.moveOSGBPB
744	.8ac9		4c d1 ff	jmp $ffd1	                jmp OSGBPB


747							;-------------------------------------------------------------------------

749	.8acc						sramOpenFile:
750	.8acc		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
751	.8acf		ae ef 02	ldx $02ef	                ldx sramWorkspace.length+0
752	.8ad2		ac f0 02	ldy $02f0	                ldy sramWorkspace.length+1
753	.8ad5		20 ce ff	jsr $ffce	                jsr OSFIND
754	.8ad8		aa		tax		                tax
755	.8ad9		d0 13		bne $8aee	                bne sramFileFound
756	.8adb		20 23 b0	jsr $b023	                jsr doFollowingError
757	>8ade		d6				                .byte $D6
758	>8adf		46 69 6c 65 20 6e 6f 74		                .text "File not found"
	>8ae7		20 66 6f 75 6e 64
759	>8aed		00				                .byte 0

761	.8aee						sramFileFound:
762	.8aee		8d d4 df	sta $dfd4	                sta hazel.moveSrcHandle
763	.8af1						L8F40:
764	.8af1		ae f1 02	ldx $02f1	                ldx sramWorkspace.bank ; ROM number of interest
765	.8af4		2c ee 02	bit $02ee	                bit sramWorkspace.type
766	.8af7		10 07		bpl $8b00	                bpl rts8F4F ; taken if reading
767	.8af9		70 05		bvs $8b00	                bvs rts8F4F ; taken if pseudo addressing

769							                ; writing, absolute addressing
770	.8afb						setROMXType6502:
771	.8afb		a9 02		lda #$02	                lda #romType6502
772	.8afd		9d a1 02	sta $02a1,x	                sta romInformationTable,x

774	.8b00						rts8F4F:
775	.8b00		60		rts		                rts


778							;-------------------------------------------------------------------------

780	.8b01						sramBank4567ModeMasks:
781	>8b01		01				                .byte 1         ; bank 4
782	>8b02		02				                .byte 2         ; bank 5
783	>8b03		04				                .byte 4         ; bank 6
784	>8b04		08				                .byte 8         ; bank 7

786							;-------------------------------------------------------------------------
787							;
788							; Check to see if next char on command line is +.
789							;
790							; Entry:
791							;
792							; (stringInputBufferAddress),y = next char on command line
793							;
794							; Exit:
795							;
796							; V=0 if not +
797							;
798							; V=1 if +. (stringInputBufferAddress),y = next non-space after the +

800	.8b05						checkForPlusInCommandLine:
801	.8b05		b8		clv		                clv
802	.8b06		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
803	.8b08		c9 2b		cmp #$2b	                cmp #'+'
804	.8b0a		d0 06		bne $8b12	                bne locret_8F61
805	.8b0c		2c 5e e3	bit $e35e	                bit valueFF
806	.8b0f		20 ed f0	jsr $f0ed	                jsr incAndSkipSpaces

808	.8b12						locret_8F61:
809	.8b12		60		rts		                rts


812							;-------------------------------------------------------------------------
813							;
814							; Adjust sram transfer data pointer so that the same Y register can be
815							; used for both sram pointer and data pointer.
816							;
817							; Entry:
818							;
819							; X = offset of sram transfer sram pointer (0=src, 2=dest)
820							; Y = value to subtract from sram transfer data pointer
821							;
822							; C=1 = initialise sram transfer data pointer from data address
823							;
824							; Exit:
825							;
826							; sram transfer data pointer has had Y subtracted
827							;
828	.8b13						initSRAMTransferDataPointer: .proc
829	.8b13		da		phx		                phx
830							                ; select the non-sram data pointer
831	.8b14		8a		txa		                txa
832	.8b15		49 02		eor #$02	                eor #sramTransferPointers.src^sramTransferPointers.dest
833	.8b17		aa		tax		                tax
834	.8b18		90 0a		bcc $8b24	                bcc subtractY

836							                ; store data address in the non-sram pointer
837	.8b1a		ad f6 02	lda $02f6	                lda sramWorkspace.dataAddress+0
838	.8b1d		95 00		sta $00,x	                sta 0,x
839	.8b1f		ad f7 02	lda $02f7	                lda sramWorkspace.dataAddress+1
840	.8b22		95 01		sta $01,x	                sta 1,x

842	.8b24						subtractY:
843	.8b24		8c ed 02	sty $02ed	                sty sramWorkspace.temp ; sram address LSB
844	.8b27		b5 00		lda $00,x	                lda 0,x
845	.8b29		38		sec		                sec
846	.8b2a		ed ed 02	sbc $02ed	                sbc sramWorkspace.temp
847	.8b2d		95 00		sta $00,x	                sta 0,x
848	.8b2f		b0 02		bcs $8b33	                bcs +
849	.8b31		d6 01		dec $01,x	                dec 1,x
850	.8b33						+
851	.8b33		fa		plx		                plx
852	.8b34		60		rts		                rts
853							                .endproc

855							;-------------------------------------------------------------------------
856							;
857							; Get bank mode: pseudo, or absolute.
858							;
859							; (Only banks 4-7 can be used with pseudo addressing, but you can test
860							; any.)
861							;
862							; Entry:
863							;
864							; X = bank of interest
865							;
866							; Exit:
867							;
868							; A=$00 if absolute (C=1 as well, if bank could only ever be absolute)
869							;
870							; A=$40 if pseudo

872	.8b35						sramGetBankMode:
873	.8b35		e0 04		cpx #$04	                cpx #4
874	.8b37		90 1c		bcc $8b55	                bcc bankModeIsInherentlyAbsolute ; taken if <4
875	.8b39		e0 08		cpx #$08	                cpx #8
876	.8b3b		b0 18		bcs $8b55	                bcs bankModeIsInherentlyAbsolute ; taken if >=8

878	.8b3d						osbyte45:
879							                ; When entered as OSBYTE $45, the X register is bogus,
880							                ; so the table lookup could read junk and the AND
881							                ; could end up meaningless. But that doesn't matter:
882							                ; it's only the value in X on exit that's important.
883	.8b3d		ac 34 fe	ldy $fe34	                ldy ACCCON
884	.8b40		20 b9 eb	jsr $ebb9	                jsr selectHAZEL ; engage HAZEL
885	.8b43		bd fd 8a	lda $8afd,x	                lda sramBank4567ModeMasks-4,x ; acquire mask: 1/2/4/8 for banks
886							                                 ; 4/5/6/7 respectively
887	.8b46		ae de df	ldx $dfde	                ldx hazel.sramBankModes ; load current settings into X, in case this is OSBYTE $45
888	.8b49		2d de df	and $dfde	                and hazel.sramBankModes
889	.8b4c		f0 02		beq $8b50	                beq +           ; taken with A=$00 if bank of interest
890							                                ; is absolute
891	.8b4e		a9 40		lda #$40	                lda #$40        ; indicate pseudo
892	.8b50						+
893	.8b50		8c 34 fe	sty $fe34	                sty ACCCON
894	.8b53		18		clc		                clc
895	.8b54		60		rts		                rts

897	.8b55						bankModeIsInherentlyAbsolute:
898	.8b55		38		sec		                sec
899	.8b56		a9 00		lda #$00	                lda #0
900	.8b58		60		rts		                rts


:4	;******  Return to file: src/terminal.s65

939							                .include "configure_code_driven.s65"

:7	;******  Processing file: src/configure_code_driven.s65

1	=[]						_:=[]
2	=[(".",$8f01,$9053)]				_..=[(".",printCONFIGUREHelp,printSTATUSHelp)]
3							                .if version<400
5							                .endif
6	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38)]	_..=[("BOOT",setDefaultAutoBoot,printDefaultAutoBoot)]
7	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd)]
							_..=[("CAPS",setDefaultsCapsLock,printDefaultCaps)]
8							                .if version<400
10							                .endif
11	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85)]
							_..=[("DELAY",setDefaultKeyboardAutoRepeatDelay,printDefaultKeyboardAutoRepeatDelay)]
12							                .if version<400
14							                .endif
15							                .if includeTubeSupport
16	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12)]
							_..=[("EXTUBE",setDefaultExtTube,printDefaultExtTube)]
17							                .endif
18							                .if version<400
20							                .endif
21	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67)]
							_..=[("FILE",setDefaultFSROM,printDefaultFSROM)]
22							                .if version<400
24							                .endif
25							                .if version<400
27							                .endif
28	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b)]
							_..=[("IGNORE",setDefaultPrinterIgnoreChar,printDefaultPrinterIgnoreChar)]
29							                .if includeTubeSupport
30	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12)]
							_..=[("INTUBE",setDefaultIntTube,printDefaultExtTube)]
31							                .endif
32	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f)]
							_..=[("LANG",setDefaultLanguageROM,printDefaultLanguageROM)]
33	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6)]
							_..=[("LOUD",setDefaultLoud,printDefaultLoud)]
34	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c)]
							_..=[("MODE",setDefaultMODE,printDefaultMODE)]
35	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38)]
							_..=[("NOBOOT",setDefaultNoAutoBoot,printDefaultAutoBoot)]
36	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38),("NOCAPS",$8c4e,$8dbd)]
							_..=[("NOCAPS",setDefaultNoLock,printDefaultCaps)]
37							                .if version<400
39							                .endif
40	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38),("NOCAPS",$8c4e,$8dbd),("NOSCROLL",$8d93,$8de0)]
							_..=[("NOSCROLL",setDefaultNoProtectedScrolling,printDefaultProtectedScrolling)]
41							                .if includeTubeSupport
42	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38),("NOCAPS",$8c4e,$8dbd),("NOSCROLL",$8d93,$8de0),("NOTUBE",$8d5c,$8e4c)]
							_..=[("NOTUBE",setDefaultTubeOff,printDefaultTubeOn)]
43							                .endif
44	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38),("NOCAPS",$8c4e,$8dbd),("NOSCROLL",$8d93,$8de0),("NOTUBE",$8d5c,$8e4c),("PRINT",$8d3f,$8ecf)]
							_..=[("PRINT",setDefaultFX5Settings,printDefaultFX5Settings)]
45	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38),("NOCAPS",$8c4e,$8dbd),("NOSCROLL",$8d93,$8de0),("NOTUBE",$8d5c,$8e4c),("PRINT",$8d3f,$8ecf),("QUIET",$8d6f,$8df6)]
							_..=[("QUIET",setDefaultQuiet,printDefaultLoud)]
46	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38),("NOCAPS",$8c4e,$8dbd),("NOSCROLL",$8d93,$8de0),("NOTUBE",$8d5c,$8e4c),("PRINT",$8d3f,$8ecf),("QUIET",$8d6f,$8df6),("REPEAT",$8d19,$8e8b)]
							_..=[("REPEAT",setDefaultKeyboardAutoRepeatRate,printDefaultKeyboardRepeatRate)]
47	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38),("NOCAPS",$8c4e,$8dbd),("NOSCROLL",$8d93,$8de0),("NOTUBE",$8d5c,$8e4c),("PRINT",$8d3f,$8ecf),("QUIET",$8d6f,$8df6),("REPEAT",$8d19,$8e8b),("SCROLL",$8d8d,$8de0)]
							_..=[("SCROLL",setDefaultProtectedScrolling,printDefaultProtectedScrolling)]
48	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38),("NOCAPS",$8c4e,$8dbd),("NOSCROLL",$8d93,$8de0),("NOTUBE",$8d5c,$8e4c),("PRINT",$8d3f,$8ecf),("QUIET",$8d6f,$8df6),("REPEAT",$8d19,$8e8b),("SCROLL",$8d8d,$8de0),("SHCAPS",$8c54,$8dbd)]
							_..=[("SHCAPS",setDefaultShiftLock,printDefaultCaps)]
49							                .if includeTubeSupport
50	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38),("NOCAPS",$8c4e,$8dbd),("NOSCROLL",$8d93,$8de0),("NOTUBE",$8d5c,$8e4c),("PRINT",$8d3f,$8ecf),("QUIET",$8d6f,$8df6),("REPEAT",$8d19,$8e8b),("SCROLL",$8d8d,$8de0),("SHCAPS",$8c54,$8dbd),("TUBE",$8d66,$8e4c)]
							_..=[("TUBE",setDefaultTubeOn,printDefaultTubeOn)]
51							                .endif
52	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38),("NOCAPS",$8c4e,$8dbd),("NOSCROLL",$8d93,$8de0),("NOTUBE",$8d5c,$8e4c),("PRINT",$8d3f,$8ecf),("QUIET",$8d6f,$8df6),("REPEAT",$8d19,$8e8b),("SCROLL",$8d8d,$8de0),("SHCAPS",$8c54,$8dbd),("TUBE",$8d66,$8e4c),("TV",$8c7a,$8e6e)]
							_..=[("TV",setDefaultTVSettings,printDefaultTVSettings)]
53	=[(".",$8f01,$9053),("BOOT",$8d7f,$8e38),("CAPS",$8c5a,$8dbd),("DELAY",$8d17,$8e85),("EXTUBE",$8d9b,$8e12),("FILE",$8db6,$8e67),("IGNORE",$8d2c,$8e9b),("INTUBE",$8da1,$8e12),("LANG",$8da9,$8e5f),("LOUD",$8d75,$8df6),("MODE",$8c64,$8e7c),("NOBOOT",$8d85,$8e38),("NOCAPS",$8c4e,$8dbd),("NOSCROLL",$8d93,$8de0),("NOTUBE",$8d5c,$8e4c),("PRINT",$8d3f,$8ecf),("QUIET",$8d6f,$8df6),("REPEAT",$8d19,$8e8b),("SCROLL",$8d8d,$8de0),("SHCAPS",$8c54,$8dbd),("TUBE",$8d66,$8e4c),("TV",$8c7a,$8e6e)]
							configureData=_

55							                .if version<400
68							                .else
69	.8b59						configureTable:
70							                .for i=0,i<len(configureData),i+=1
71	>8b59		2e				                .text configureData[i][0]
125:3	>8b5a		8f				                .byte >configureData[i][1]-1
126	>8b5b		00				                .byte <configureData[i][1]-1
125	>8b5c		90				                .byte >configureData[i][2]-1
126	>8b5d		52				                .byte <configureData[i][2]-1
71:7	>8b5e		42 4f 4f 54			                .text configureData[i][0]
125:3	>8b62		8d				                .byte >configureData[i][1]-1
126	>8b63		7e				                .byte <configureData[i][1]-1
125	>8b64		8e				                .byte >configureData[i][2]-1
126	>8b65		37				                .byte <configureData[i][2]-1
71:7	>8b66		43 41 50 53			                .text configureData[i][0]
125:3	>8b6a		8c				                .byte >configureData[i][1]-1
126	>8b6b		59				                .byte <configureData[i][1]-1
125	>8b6c		8d				                .byte >configureData[i][2]-1
126	>8b6d		bc				                .byte <configureData[i][2]-1
71:7	>8b6e		44 45 4c 41 59			                .text configureData[i][0]
125:3	>8b73		8d				                .byte >configureData[i][1]-1
126	>8b74		16				                .byte <configureData[i][1]-1
125	>8b75		8e				                .byte >configureData[i][2]-1
126	>8b76		84				                .byte <configureData[i][2]-1
71:7	>8b77		45 58 54 55 42 45		                .text configureData[i][0]
125:3	>8b7d		8d				                .byte >configureData[i][1]-1
126	>8b7e		9a				                .byte <configureData[i][1]-1
125	>8b7f		8e				                .byte >configureData[i][2]-1
126	>8b80		11				                .byte <configureData[i][2]-1
71:7	>8b81		46 49 4c 45			                .text configureData[i][0]
125:3	>8b85		8d				                .byte >configureData[i][1]-1
126	>8b86		b5				                .byte <configureData[i][1]-1
125	>8b87		8e				                .byte >configureData[i][2]-1
126	>8b88		66				                .byte <configureData[i][2]-1
71:7	>8b89		49 47 4e 4f 52 45		                .text configureData[i][0]
125:3	>8b8f		8d				                .byte >configureData[i][1]-1
126	>8b90		2b				                .byte <configureData[i][1]-1
125	>8b91		8e				                .byte >configureData[i][2]-1
126	>8b92		9a				                .byte <configureData[i][2]-1
71:7	>8b93		49 4e 54 55 42 45		                .text configureData[i][0]
125:3	>8b99		8d				                .byte >configureData[i][1]-1
126	>8b9a		a0				                .byte <configureData[i][1]-1
125	>8b9b		8e				                .byte >configureData[i][2]-1
126	>8b9c		11				                .byte <configureData[i][2]-1
71:7	>8b9d		4c 41 4e 47			                .text configureData[i][0]
125:3	>8ba1		8d				                .byte >configureData[i][1]-1
126	>8ba2		a8				                .byte <configureData[i][1]-1
125	>8ba3		8e				                .byte >configureData[i][2]-1
126	>8ba4		5e				                .byte <configureData[i][2]-1
71:7	>8ba5		4c 4f 55 44			                .text configureData[i][0]
125:3	>8ba9		8d				                .byte >configureData[i][1]-1
126	>8baa		74				                .byte <configureData[i][1]-1
125	>8bab		8d				                .byte >configureData[i][2]-1
126	>8bac		f5				                .byte <configureData[i][2]-1
71:7	>8bad		4d 4f 44 45			                .text configureData[i][0]
125:3	>8bb1		8c				                .byte >configureData[i][1]-1
126	>8bb2		63				                .byte <configureData[i][1]-1
125	>8bb3		8e				                .byte >configureData[i][2]-1
126	>8bb4		7b				                .byte <configureData[i][2]-1
71:7	>8bb5		4e 4f 42 4f 4f 54		                .text configureData[i][0]
125:3	>8bbb		8d				                .byte >configureData[i][1]-1
126	>8bbc		84				                .byte <configureData[i][1]-1
125	>8bbd		8e				                .byte >configureData[i][2]-1
126	>8bbe		37				                .byte <configureData[i][2]-1
71:7	>8bbf		4e 4f 43 41 50 53		                .text configureData[i][0]
125:3	>8bc5		8c				                .byte >configureData[i][1]-1
126	>8bc6		4d				                .byte <configureData[i][1]-1
125	>8bc7		8d				                .byte >configureData[i][2]-1
126	>8bc8		bc				                .byte <configureData[i][2]-1
71:7	>8bc9		4e 4f 53 43 52 4f 4c 4c		                .text configureData[i][0]
125:3	>8bd1		8d				                .byte >configureData[i][1]-1
126	>8bd2		92				                .byte <configureData[i][1]-1
125	>8bd3		8d				                .byte >configureData[i][2]-1
126	>8bd4		df				                .byte <configureData[i][2]-1
71:7	>8bd5		4e 4f 54 55 42 45		                .text configureData[i][0]
125:3	>8bdb		8d				                .byte >configureData[i][1]-1
126	>8bdc		5b				                .byte <configureData[i][1]-1
125	>8bdd		8e				                .byte >configureData[i][2]-1
126	>8bde		4b				                .byte <configureData[i][2]-1
71:7	>8bdf		50 52 49 4e 54			                .text configureData[i][0]
125:3	>8be4		8d				                .byte >configureData[i][1]-1
126	>8be5		3e				                .byte <configureData[i][1]-1
125	>8be6		8e				                .byte >configureData[i][2]-1
126	>8be7		ce				                .byte <configureData[i][2]-1
71:7	>8be8		51 55 49 45 54			                .text configureData[i][0]
125:3	>8bed		8d				                .byte >configureData[i][1]-1
126	>8bee		6e				                .byte <configureData[i][1]-1
125	>8bef		8d				                .byte >configureData[i][2]-1
126	>8bf0		f5				                .byte <configureData[i][2]-1
71:7	>8bf1		52 45 50 45 41 54		                .text configureData[i][0]
125:3	>8bf7		8d				                .byte >configureData[i][1]-1
126	>8bf8		18				                .byte <configureData[i][1]-1
125	>8bf9		8e				                .byte >configureData[i][2]-1
126	>8bfa		8a				                .byte <configureData[i][2]-1
71:7	>8bfb		53 43 52 4f 4c 4c		                .text configureData[i][0]
125:3	>8c01		8d				                .byte >configureData[i][1]-1
126	>8c02		8c				                .byte <configureData[i][1]-1
125	>8c03		8d				                .byte >configureData[i][2]-1
126	>8c04		df				                .byte <configureData[i][2]-1
71:7	>8c05		53 48 43 41 50 53		                .text configureData[i][0]
125:3	>8c0b		8c				                .byte >configureData[i][1]-1
126	>8c0c		53				                .byte <configureData[i][1]-1
125	>8c0d		8d				                .byte >configureData[i][2]-1
126	>8c0e		bc				                .byte <configureData[i][2]-1
71:7	>8c0f		54 55 42 45			                .text configureData[i][0]
125:3	>8c13		8d				                .byte >configureData[i][1]-1
126	>8c14		65				                .byte <configureData[i][1]-1
125	>8c15		8e				                .byte >configureData[i][2]-1
126	>8c16		4b				                .byte <configureData[i][2]-1
71:7	>8c17		54 56				                .text configureData[i][0]
125:3	>8c19		8c				                .byte >configureData[i][1]-1
126	>8c1a		79				                .byte <configureData[i][1]-1
125	>8c1b		8e				                .byte >configureData[i][2]-1
126	>8c1c		6d				                .byte <configureData[i][2]-1
74:7							                .next
75	>8c1d		00				                .byte 0
76							                .endif

78							;-------------------------------------------------------------------------
79							;
80							; *CONFIGURE [MasRef C.5-2]
81							;
82	.8c1e						starCONFIGURE:
83	.8c1e		20 a8 8c	jsr $8ca8	                jsr L8934                    ;get configure param
84	.8c21		b0 0a		bcs $8c2d	                bcs callSetRoutine           ;taken if known
85	.8c23		a2 28		ldx #$28	                ldx #romServiceCallUnknownCONFIG
86	.8c25						L8881:
87	.8c25		a4 e6		ldy $e6		                ldy $E6
88	.8c27		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
89	.8c2a		d0 1f		bne $8c4b	                bne badCommandError88AC
90	.8c2c		60		rts		                rts

92	.8c2d						callSetRoutine:
93							                .if version<400
99							                .else
100	.8c2d		48		pha		                pha
101	.8c2e		bd 5a 8b	lda $8b5a,x	                lda configureTable+1,x
102	.8c31		48		pha		                pha
103							                .endif
104	.8c32						L8892:
105	.8c32		4c ee f0	jmp $f0ee	                jmp skipSpacesAndCheckForCRInStringInput

107	.8c35						starSTATUS:
108	.8c35		20 a8 8c	jsr $8ca8	                jsr L8934
109	.8c38		b0 04		bcs $8c3e	                bcs L889E
110	.8c3a		a2 29		ldx #$29	                ldx #romServiceCallUnknownSTATUS
111	.8c3c		80 e7		bra $8c25	                bra L8881

113	.8c3e						L889E:
114							                .if version<400
120							                .else
121	.8c3e		bd 5b 8b	lda $8b5b,x	                lda configureTable+2,x
122	.8c41		48		pha		                pha
123	.8c42		bd 5c 8b	lda $8b5c,x	                lda configureTable+3,x
124	.8c45		48		pha		                pha
125							                .endif
126	.8c46		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
127	.8c49		f0 e7		beq $8c32	                beq L8892
128	.8c4b						badCommandError88AC:
129	.8c4b		4c ee 8c	jmp $8cee	                jmp badCommandError8976

131							;-------------------------------------------------------------------------

133							                .if version<400
138							                .endif

140							;-------------------------------------------------------------------------

142							                .if version<400
149							                .endif

151							;-------------------------------------------------------------------------

153							                .if version<400
158							                .endif

160							;-------------------------------------------------------------------------

162							                .if version<400
169							                .endif

171							;-------------------------------------------------------------------------

173							                .if version<400
184							                .endif

186							;-------------------------------------------------------------------------

188	.8c4e						setDefaultNoLock:
189	.8c4e		d0 fb		bne $8c4b	                bne badCommandError88AC
190	.8c50		a9 10		lda #$10	                lda #CMOSBytes.defaults1.noLockMask
191	.8c52		80 0a		bra $8c5e	                bra setDefaultLock

193							;-------------------------------------------------------------------------

195	.8c54						setDefaultShiftLock:
196	.8c54		d0 f5		bne $8c4b	                bne badCommandError88AC
197	.8c56		a9 08		lda #$08	                lda #CMOSBytes.defaults1.shiftLockMask
198	.8c58		80 04		bra $8c5e	                bra setDefaultLock

200							;-------------------------------------------------------------------------

202	.8c5a						setDefaultsCapsLock:
203	.8c5a		d0 ef		bne $8c4b	                bne badCommandError88AC
204	.8c5c		a9 20		lda #$20	                lda #CMOSBytes.defaults1.capsLockMask
205	.8c5e						setDefaultLock:
206	.8c5e		a0 c7		ldy #$c7	                ldy #~(CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.shiftLockMask)&$ff
207							                .if version<400
209							                .else
210	.8c60						writeDefaults1Bits:
211	.8c60		a2 19		ldx #$19	                ldx #CMOSBytes.defaults1+cmosBytesOffset
212	.8c62		80 3d		bra $8ca1	                bra jmpWriteRTCBits892D
213							                .endif

215							;-------------------------------------------------------------------------

217	.8c64						setDefaultMODE:
218	.8c64		20 e9 8c	jsr $8ce9	                jsr parseNumberFromCommandLine
219	.8c67		20 ff 8c	jsr $8cff	                jsr ensureCommandLineTailEmpty
220	.8c6a		8a		txa		                txa
221	.8c6b		29 7f		and #$7f	                and #$7F
222	.8c6d		c9 08		cmp #$08	                cmp #$08                     ;only 0-7 is valid
223	.8c6f		b0 14		bcs $8c85	                bcs bcsBadCommandError8911
224	.8c71		e8		inx		                inx    ;set N as per X value - bit 6 is never set, so the result is valid for the original value
225	.8c72		10 02		bpl $8c76	                bpl +
226	.8c74		09 08		ora #$08	                ora #CMOSBytes.defaults0.shadowMask
227	.8c76						+
228	.8c76		a0 f0		ldy #$f0	                ldy #~(CMOSBytes.defaults0.shadowMask|CMOSBytes.defaults0.modeMask)&$ff
229	.8c78		80 25		bra $8c9f	                bra writeDefaults0Bits

231							;-------------------------------------------------------------------------

233	.8c7a						setDefaultTVSettings:
234	.8c7a		f0 28		beq $8ca4	                beq resetDefaultTVSettings        ;reset to 0,0 if no values supplied
235	.8c7c		20 e9 8c	jsr $8ce9	                jsr parseNumberFromCommandLine
236							                ; valid range is 252-255 or 0-3
237	.8c7f		e0 fc		cpx #$fc	                cpx #252
238	.8c81		b0 04		bcs $8c87	                bcs +
239	.8c83		e0 04		cpx #$04	                cpx #$04
240	.8c85						bcsBadCommandError8911:
241	.8c85		b0 67		bcs $8cee	                bcs badCommandError8976
242	.8c87						+
243	.8c87		8a		txa		                txa
244	.8c88		0a		asl a		                asl a                   ;make space for interlace flag
245	.8c89		85 b1		sta $b1		                sta $B1
246	.8c8b		a2 00		ldx #$00	                ldx #$00
247	.8c8d		20 f9 f0	jsr $f0f9	                jsr LF30A
248	.8c90		f0 04		beq $8c96	                beq +                  ;taken if only 1 value supplied
249	.8c92		20 07 8d	jsr $8d07	                jsr parseSingle1BitNumberFromCommandLine ;get interlace flag
250	.8c95		aa		tax		                tax                          ;X=interlace flag
251	.8c96						+
252	.8c96		8a		txa		                txa                          ;
253	.8c97		05 b1		ora $b1		                ora $B1                      ;OR in the TV setting
254	.8c99		0a		asl a		                asl a
255	.8c9a		0a		asl a		                asl a
256	.8c9b		0a		asl a		                asl a
257	.8c9c		0a		asl a		                asl a                        ; shift into place
258	.8c9d						writeDefaultTVSettings:
259	.8c9d		a0 0f		ldy #$0f	                ldy #~(CMOSBytes.defaults0.tvMask<<CMOSBytes.defaults0.tvShift|CMOSBytes.defaults0.interlaceMask)&$ff
260	.8c9f						writeDefaults0Bits:
261	.8c9f		a2 18		ldx #$18	                ldx #CMOSBytes.defaults0+cmosBytesOffset
262	.8ca1						jmpWriteRTCBits892D:
263	.8ca1		4c 4e 8d	jmp $8d4e	                jmp writeRTCBits

265	.8ca4						resetDefaultTVSettings:
266	.8ca4		a9 00		lda #$00	                lda #$00
267	.8ca6		80 f5		bra $8c9d	                bra writeDefaultTVSettings

269							;-------------------------------------------------------------------------
270							;-------------------------------------------------------------------------
271							;
272							;
273	.8ca8						L8934:
274	.8ca8		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
275	.8cab		84 e6		sty $e6		                sty $E6
276	.8cad		f0 42		beq $8cf1	                beq L8979                    ;taken if input ends with CR
277	.8caf		a2 00		ldx #$00	                ldx #$00
278	.8cb1		80 0b		bra $8cbe	                bra L894A

280	.8cb3						L893F:
281							                .if version==400
282	.8cb3		5d 59 8b	eor $8b59,x	                eor configureTable,x
285							                .endif
286	.8cb6		29 df		and #$df	                and #$DF              ;case-insensitive
287	.8cb8		d0 16		bne $8cd0	                bne L895C             ;taken if no match
288	.8cba		c8		iny		                iny
289	.8cbb						L8947:
290	.8cbb		b0 24		bcs $8ce1	                bcs L896C
291	.8cbd		e8		inx		                inx
292	.8cbe						L894A:
293	.8cbe		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
294	.8cc0		20 19 e9	jsr $e919	                jsr isLetter
295	.8cc3		90 ee		bcc $8cb3	                bcc L893F                    ;taken if letter
296	.8cc5						L8951:
297							                .if version==400
298	.8cc5		bd 59 8b	lda $8b59,x	                lda configureTable,x
299	.8cc8		30 1a		bmi $8ce4	                bmi L8CE4
303							                .endif
304	.8cca		b1 f2		lda ($f2),y	                lda ($F2),y
305	.8ccc		c9 2e		cmp #$2e	                cmp #'.'
306	.8cce		f0 04		beq $8cd4	                beq L8960                    ;accept abbreviations
307	.8cd0						L895C:
308	.8cd0		18		clc		                clc
309	.8cd1		a4 e6		ldy $e6		                ldy $E6
310	.8cd3		88		dey		                dey
311	.8cd4						L8960:
312	.8cd4		c8		iny		                iny
313							                .if version==400
314	.8cd5		e8		inx		                inx
315	.8cd6		e8		inx		                inx
318							                .endif
319	.8cd7						L8962:
320	.8cd7		e8		inx		                inx
321							                .if version==400
322	.8cd8		bd 56 8b	lda $8b56,x	                lda configureTable-3,x
325							                .endif
326	.8cdb		f0 09		beq $8ce6	                beq L896E
327	.8cdd		10 f8		bpl $8cd7	                bpl L8962
328	.8cdf		80 da		bra $8cbb	                bra L8947

330	.8ce1						L896C:
331							                .if version==400
332	.8ce1		ca		dex		                dex
333	.8ce2		ca		dex		                dex
334	.8ce3		ca		dex		                dex
335							                .endif
336	.8ce4						L8CE4:
337	.8ce4		38		sec		                sec
338	.8ce5		60		rts		                rts

340	.8ce6						L896E:
341	.8ce6		b0 f9		bcs $8ce1	                bcs L896C
342	.8ce8						rts8970:
343	.8ce8		60		rts		                rts

345							;-------------------------------------------------------------------------

347	.8ce9						parseNumberFromCommandLine:
348	.8ce9		20 fb 85	jsr $85fb	                jsr parseNumberFromString
349	.8cec		b0 fa		bcs $8ce8	                bcs rts8970
350	.8cee						badCommandError8976:
351	.8cee		4c bd fa	jmp $fabd	                jmp badCommandError

353							;-------------------------------------------------------------------------

355	.8cf1						L8979:
356	.8cf1		a2 01		ldx #$01	                ldx #$01
357	.8cf3		80 d0		bra $8cc5	                bra L8951

359							;-------------------------------------------------------------------------

361	.8cf5						parseSingle4BitNumberFromCommandLine:
362	.8cf5		20 fb 85	jsr $85fb	                jsr parseNumberFromString
363	.8cf8		90 f4		bcc $8cee	                bcc badCommandError8976
364	.8cfa		8a		txa		                txa
365	.8cfb		c9 10		cmp #$10	                cmp #$10
366	.8cfd		b0 ef		bcs $8cee	                bcs badCommandError8976
367	.8cff						ensureCommandLineTailEmpty:
368	.8cff		48		pha		                pha                          ;save value parsed
369	.8d00		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
370	.8d03						bneBadCommandError898B:
371	.8d03		d0 e9		bne $8cee	                bne badCommandError8976      ;taken if followed up by anything other than CR
372	.8d05		68		pla		                pla                          ;restore value parsed
373	.8d06		60		rts		                rts

375							;-------------------------------------------------------------------------

377	.8d07						parseSingle1BitNumberFromCommandLine:
378	.8d07		20 0f 8d	jsr $8d0f	                jsr parseSingleNumberFromCommandLine
379	.8d0a		c9 02		cmp #$02	                cmp #$02
380	.8d0c		b0 e0		bcs $8cee	                bcs badCommandError8976
381	.8d0e		60		rts		                rts

383							;-------------------------------------------------------------------------
384							;
385							; Parse single number from command line. Produce Bad Command error if
386							; the number is invalid or if there's more than one number.
387							;
388							; exit:
389							;
390							; A = value
391							;
392							; N/Z set as per A
393							;
394	.8d0f						parseSingleNumberFromCommandLine:
395	.8d0f		20 fb 85	jsr $85fb	                jsr parseNumberFromString
396	.8d12		90 da		bcc $8cee	                bcc badCommandError8976      ;taken if error
397	.8d14		8a		txa		                txa                          ;A=value
398	.8d15		80 e8		bra $8cff	                bra ensureCommandLineTailEmpty

400							;-------------------------------------------------------------------------

402	.8d17						setDefaultKeyboardAutoRepeatDelay:
403	.8d17		18		clc		                clc
404	>8d18		24				                .byte $24                    ; BIT zp (make SEC mostly
405							                                             ; a NOP, in effect)
406	.8d19						setDefaultKeyboardAutoRepeatRate:
407	.8d19		38		sec		                sec
408	.8d1a		08		php		                php                          ;save C
409	.8d1b		20 e9 8c	jsr $8ce9	                jsr parseNumberFromCommandLine
410	.8d1e		20 ff 8c	jsr $8cff	                jsr ensureCommandLineTailEmpty
411	.8d21		28		plp		                plp                          ;restore C
412	.8d22		8a		txa		                txa
413	.8d23		a8		tay		                tay
414							                .cerror CMOSBytes.keyboardAutoRepeatDelay+1!=CMOSBytes.keyboardAutoRepeatRate,"keyboard auto repeat settings CMOS bytes must be adjacent"
415	.8d24		a9 1a		lda #$1a	                lda #CMOSBytes.keyboardAutoRepeatDelay+cmosBytesOffset
416	.8d26		69 00		adc #$00	                adc #$00             ;pick appropriate byte based on C
417	.8d28		aa		tax		                tax                  ;X=RTC address
418	.8d29						jmpWriteRTCByte:
419	.8d29		4c 78 9b	jmp $9b78	                jmp writeRTCByte

421							;-------------------------------------------------------------------------

423	.8d2c						setDefaultPrinterIgnoreChar:
424	.8d2c		f0 3b		beq $8d69	                beq writeDefaultUsePrinterIgnoreCharTrue
425	.8d2e		20 e9 8c	jsr $8ce9	                jsr parseNumberFromCommandLine
426	.8d31		da		phx		                phx
427	.8d32		20 ff 8c	jsr $8cff	                jsr ensureCommandLineTailEmpty
428	.8d35		a9 00		lda #$00	                lda #$00
429	.8d37		20 6b 8d	jsr $8d6b	                jsr writeDefaultUsePrinterIgnoreChar
430	.8d3a		7a		ply		                ply
431	.8d3b		a2 1c		ldx #$1c	                ldx #CMOSBytes.printerIgnoreChar+cmosBytesOffset
432	.8d3d		80 ea		bra $8d29	                bra jmpWriteRTCByte

434							;-------------------------------------------------------------------------

436	.8d3f						setDefaultFX5Settings:
437	.8d3f		20 0f 8d	jsr $8d0f	                jsr parseSingleNumberFromCommandLine
438	.8d42		c9 05		cmp #$05	                cmp #$05
439	.8d44						bcsBadCommandError:
440	.8d44		b0 a8		bcs $8cee	                bcs badCommandError8976
441	.8d46		a0 1f		ldy #$1f	                ldy #~(CMOSBytes.defaults2.fx5SettingMask<<CMOSBytes.defaults2.fx5SettingShift)&$ff
442	.8d48		4a		lsr a		                lsr a
443	.8d49		6a		ror a		                ror a
444	.8d4a		6a		ror a		                ror a
445	.8d4b		6a		ror a		                ror a
446	.8d4c						writeDefaults2Bits:
447	.8d4c		a2 1d		ldx #$1d	                ldx #CMOSBytes.defaults2+cmosBytesOffset
448	.8d4e						writeRTCBits:
449	.8d4e		85 b1		sta $b1		                sta $B1
450	.8d50		84 b2		sty $b2		                sty $B2
451	.8d52		20 4b 9b	jsr $9b4b	                jsr readRTCByte
452	.8d55		25 b2		and $b2		                and $B2
453	.8d57		05 b1		ora $b1		                ora $B1
454	.8d59		a8		tay		                tay
455	.8d5a		80 cd		bra $8d29	                bra jmpWriteRTCByte

457							;-------------------------------------------------------------------------

459							                .if includeTubeSupport
460	.8d5c						setDefaultTubeOff:
461	.8d5c		18		clc		                clc
462	.8d5d						bneBadCommandError89E5:
463	.8d5d		d0 a4		bne $8d03	                bne bneBadCommandError898B
464	.8d5f		a0 fe		ldy #$fe	                ldy #~(CMOSBytes.defaults2.tubeOnMask)&$ff
465	.8d61		a9 00		lda #$00	                lda #$00
466	.8d63		2a		rol a		                rol a
467	.8d64		80 e6		bra $8d4c	                bra writeDefaults2Bits
471							                .endif

473							;-------------------------------------------------------------------------

475							                .if includeTubeSupport
476	.8d66						setDefaultTubeOn:
477	.8d66		38		sec		                sec
478	.8d67		80 f4		bra $8d5d	                bra bneBadCommandError89E5
479							                .endif

481							;-------------------------------------------------------------------------

483							                .if version<400
496							                .endif

498							;-------------------------------------------------------------------------

500	.8d69						writeDefaultUsePrinterIgnoreCharTrue:
501	.8d69		a9 02		lda #$02	                lda #CMOSBytes.defaults2.usePrinterIgnoreCharMask
502	.8d6b						writeDefaultUsePrinterIgnoreChar:
503	.8d6b		a0 fd		ldy #$fd	                ldy #(~CMOSBytes.defaults2.usePrinterIgnoreCharMask)&$ff
504	.8d6d		80 dd		bra $8d4c	                bra writeDefaults2Bits

506							;-------------------------------------------------------------------------

508	.8d6f						setDefaultQuiet:
509	.8d6f		d0 ec		bne $8d5d	                bne bneBadCommandError89E5
510	.8d71		a9 00		lda #$00	                lda #$00
511	.8d73		80 04		bra $8d79	                bra writeDefaultLoud

513							;-------------------------------------------------------------------------

515	.8d75						setDefaultLoud:
516	.8d75		d0 e6		bne $8d5d	                bne bneBadCommandError89E5
517	.8d77		a9 02		lda #$02	                lda #CMOSBytes.defaults3.loudMask
518	.8d79						writeDefaultLoud:
519	.8d79		a0 fd		ldy #$fd	                ldy #~(CMOSBytes.defaults3.loudMask)&$ff
520							                .if version<400
522							                .else
523	.8d7b						writeDefaults3Bits:
524	.8d7b		a2 1e		ldx #$1e	                ldx #CMOSBytes.defaults3+cmosBytesOffset
525	.8d7d						jmpWriteRTCBits8A26:
526	.8d7d		80 cf		bra $8d4e	                bra writeRTCBits
527							                .endif

529							;-------------------------------------------------------------------------

531							                .if version<400
545							                .endif

547							;-------------------------------------------------------------------------

549	.8d7f						setDefaultAutoBoot:
550	.8d7f		d0 dc		bne $8d5d	                bne bneBadCommandError89E5
551	.8d81		a9 10		lda #$10	                lda #CMOSBytes.defaults3.autoBootMask
552	.8d83		80 04		bra $8d89	                bra writeDefaultAutoBoot

554							;-------------------------------------------------------------------------

556	.8d85						setDefaultNoAutoBoot:
557	.8d85		d0 d6		bne $8d5d	                bne bneBadCommandError89E5
558	.8d87		a9 00		lda #$00	                lda #$00                     ;no boot
559	.8d89						writeDefaultAutoBoot:
560	.8d89		a0 ef		ldy #$ef	                ldy #(~CMOSBytes.defaults3.autoBootMask)&$ff
561	.8d8b		80 ee		bra $8d7b	                bra writeDefaults3Bits

563							;-------------------------------------------------------------------------

565	.8d8d						setDefaultProtectedScrolling:
566	.8d8d		d0 ce		bne $8d5d	                bne bneBadCommandError89E5
567	.8d8f		a9 00		lda #$00	                lda #$00
568	.8d91		80 04		bra $8d97	                bra writeDefaultProtectedScrolling

570							;-------------------------------------------------------------------------

572	.8d93						setDefaultNoProtectedScrolling:
573	.8d93		d0 c8		bne $8d5d	                bne bneBadCommandError89E5
574	.8d95		a9 08		lda #$08	                lda #CMOSBytes.defaults3.protectedScrollingMask
575	.8d97						writeDefaultProtectedScrolling:
576	.8d97		a0 f7		ldy #$f7	                ldy #~(CMOSBytes.defaults3.protectedScrollingMask)&$ff
577	.8d99		80 e0		bra $8d7b	                bra writeDefaults3Bits

579							;-------------------------------------------------------------------------

581							                .if includeTubeSupport
582	.8d9b						setDefaultExtTube:
583	.8d9b		d0 a7		bne $8d44	                bne bcsBadCommandError
584	.8d9d		a9 04		lda #$04	                lda #CMOSBytes.defaults3.extTubeMask
585	.8d9f		80 04		bra $8da5	                bra writeDefaultExtTube
586							                .endif

588							;-------------------------------------------------------------------------

590							                .if includeTubeSupport
591	.8da1						setDefaultIntTube:
592	.8da1		d0 a1		bne $8d44	                bne bcsBadCommandError
593	.8da3		a9 00		lda #$00	                lda #$00
594	.8da5						writeDefaultExtTube:
595	.8da5		a0 fb		ldy #$fb	                ldy #~(CMOSBytes.defaults3.extTubeMask)&$ff
596	.8da7		80 d2		bra $8d7b	                bra writeDefaults3Bits
597							                .endif

599							;-------------------------------------------------------------------------

601	.8da9						setDefaultLanguageROM:
602	.8da9		20 f5 8c	jsr $8cf5	                jsr parseSingle4BitNumberFromCommandLine
603	.8dac		0a		asl a		                asl a
604	.8dad		0a		asl a		                asl a
605	.8dae		0a		asl a		                asl a
606	.8daf		0a		asl a		                asl a
607	.8db0		a0 0f		ldy #$0f	                ldy #~(15<<CMOSBytes.defaultROMs.languageShift)&$ff
608	.8db2						writeDefaultROM:
609	.8db2		a2 13		ldx #$13	                ldx #CMOSBytes.defaultROMs+cmosBytesOffset
610	.8db4		80 c7		bra $8d7d	                bra jmpWriteRTCBits8A26

612							;-------------------------------------------------------------------------

614	.8db6						setDefaultFSROM:
615	.8db6		20 f5 8c	jsr $8cf5	                jsr parseSingle4BitNumberFromCommandLine
616	.8db9		a0 f0		ldy #$f0	                ldy #~(15<<CMOSBytes.defaultROMs.fsShift)&$ff
617	.8dbb		80 f5		bra $8db2	                bra writeDefaultROM

619							;-------------------------------------------------------------------------

621	.8dbd						printDefaultCaps:
622	.8dbd		20 41 91	jsr $9141	                jsr readDefaults1            ;%fdCNSfff
623	.8dc0		0a		asl a		                asl a                        ;%dCNSfff0
624	.8dc1		0a		asl a		                asl a                        ;%CNSfff00
625	.8dc2		30 0d		bmi $8dd1	                bmi printCaps
626	.8dc4		0a		asl a		                asl a                        ;%NSfff000
627	.8dc5		30 14		bmi $8ddb	                bmi printNoCaps
628	.8dc7		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
629	>8dca		53 68 69 66 74 20 00		                .text "Shift ",0
630	.8dd1						printCaps:
631	.8dd1		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
632	>8dd4		43 61 70 73 0d 00		                .text "Caps",13,0
633	.8dda		60		rts		                rts
634	.8ddb						printNoCaps:
635	.8ddb		20 45 91	jsr $9145	                jsr printNo_
636	.8dde		80 f1		bra $8dd1	                bra printCaps

638							;-------------------------------------------------------------------------

640	.8de0						printDefaultProtectedScrolling:
641	.8de0		20 42 9b	jsr $9b42	                jsr readDefaults3
642	.8de3		89 08		bit #$08	                bit #CMOSBytes.defaults3.protectedScrollingMask
643	.8de5		f0 03		beq $8dea	                beq +
644	.8de7		20 45 91	jsr $9145	                jsr printNo_
645	.8dea						+
646	.8dea		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
647	>8ded		53 63 72 6f 6c 6c 0d 00		                .text "Scroll",13,0
648	.8df5		60		rts		                rts

650							;-------------------------------------------------------------------------

652	.8df6						printDefaultLoud:
653	.8df6		20 42 9b	jsr $9b42	                jsr readDefaults3
654	.8df9		89 02		bit #$02	                bit #CMOSBytes.defaults3.loudMask
655	.8dfb		d0 0b		bne $8e08	                bne printLoud
656	.8dfd		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
657	>8e00		51 75 69 65 74 0d 00		                .text "Quiet",13,0
658	.8e07		60		rts		                rts

660	.8e08						printLoud:
661	.8e08		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
662	>8e0b		4c 6f 75 64 0d 00		                .text "Loud",13,0
663	.8e11		60		rts		                rts

665							;-------------------------------------------------------------------------

667							                .if includeTubeSupport
668	.8e12						printDefaultExtTube:
669	.8e12		20 42 9b	jsr $9b42	                jsr readDefaults3
670	.8e15		89 04		bit #$04	                bit #CMOSBytes.defaults3.extTubeMask
671	.8e17		d0 08		bne $8e21	                bne printExternalTube
672	.8e19		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
673	>8e1c		49 6e 00			                .text "In",0
674	.8e1f		80 06		bra $8e27	                bra printTernalTube

676	.8e21						printExternalTube:
677	.8e21		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
678	>8e24		45 78 00			                .text "Ex",0
679	.8e27						printTernalTube:
680	.8e27		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
681	>8e2a		74 65 72 6e 61 6c 20 54		                .text "ternal Tube",13,0
	>8e32		75 62 65 0d 00
682	.8e37		60		rts		                rts
683							                .endif

685							;-------------------------------------------------------------------------

687	.8e38						printDefaultAutoBoot:
688	.8e38		20 42 9b	jsr $9b42	                jsr readDefaults3
689	.8e3b		89 10		bit #$10	                bit #CMOSBytes.defaults3.autoBootMask
690	.8e3d		d0 03		bne $8e42	                bne +
691	.8e3f		20 45 91	jsr $9145	                jsr printNo_
692	.8e42						+
693	.8e42		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
694	>8e45		42 6f 6f 74 0d 00		                .text "Boot",13,0
695	.8e4b		60		rts		                rts

697							;-------------------------------------------------------------------------

699							                .if includeTubeSupport
700	.8e4c						printDefaultTubeOn:
701	.8e4c		20 3e 9b	jsr $9b3e	                jsr readDefaults2
702	.8e4f		4a		lsr a		                lsr a                        ;C=tubeOn
703	.8e50		b0 03		bcs $8e55	                bcs +
704	.8e52		20 45 91	jsr $9145	                jsr printNo_
705	.8e55						+
706	.8e55		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
707	>8e58		54 75 62 65 0d 00		                .text "Tube",13,0
708	.8e5e		60		rts		                rts
709							                .endif

711							;-------------------------------------------------------------------------

713	.8e5f						printDefaultLanguageROM:
714	.8e5f		20 30 91	jsr $9130	                jsr readDefaultLanguageROM
715	.8e62						printROMNumber:
716	.8e62		20 d5 8e	jsr $8ed5	                jsr printDecimalByte
717	.8e65		80 1b		bra $8e82	                bra printNewLine8B2B

719							;-------------------------------------------------------------------------

721	.8e67						printDefaultFSROM:
722	.8e67		20 38 91	jsr $9138	                jsr readDefaultROMs
723	.8e6a		29 0f		and #$0f	                and #$0F
724	.8e6c		80 f4		bra $8e62	                bra printROMNumber

726							;-------------------------------------------------------------------------

728	.8e6e						printDefaultTVSettings:
729	.8e6e		20 fc 90	jsr $90fc	                jsr readDefaultTVSettings
730	.8e71		20 d4 8e	jsr $8ed4	                jsr printDecimalByteY
731	.8e74		a9 2c		lda #$2c	                lda #','
732	.8e76		20 ee ff	jsr $ffee	                jsr OSWRCH
733	.8e79		8a		txa		                txa
734	.8e7a		80 03		bra $8e7f	                bra printDecimalByteThenNewLine

736							;-------------------------------------------------------------------------

738	.8e7c						printDefaultMODE:
739	.8e7c		20 18 91	jsr $9118	                jsr readDefaultMODE
740	.8e7f						printDecimalByteThenNewLine:
741	.8e7f		20 d5 8e	jsr $8ed5	                jsr printDecimalByte
742	.8e82						printNewLine8B2B:
743	.8e82		4c e7 ff	jmp $ffe7	                jmp OSNEWL

745							;-------------------------------------------------------------------------

747	.8e85						printDefaultKeyboardAutoRepeatDelay:
748	.8e85		20 91 8e	jsr $8e91	                jsr getDefaultKeyboardAutoRepeatDelay
749	.8e88		98		tya		                tya
750	.8e89		80 f4		bra $8e7f	                bra printDecimalByteThenNewLine

752							;-------------------------------------------------------------------------

754	.8e8b						printDefaultKeyboardRepeatRate:
755	.8e8b		20 96 8e	jsr $8e96	                jsr getDefaultKeyboardAutoRepeatRate
756	.8e8e		98		tya		                tya
757	.8e8f		80 ee		bra $8e7f	                bra printDecimalByteThenNewLine

759							;-------------------------------------------------------------------------
760							;
761							; Read default keyboard auto repeat delay from CMOS RAM.
762							;
763							; exit:
764							;
765							; Y = default keyboard auto repeat delay
766							;
767	.8e91						getDefaultKeyboardAutoRepeatDelay:
768	.8e91		a2 1a		ldx #$1a	                ldx #CMOSBytes.keyboardAutoRepeatDelay+cmosBytesOffset
769	.8e93		4c 4b 9b	jmp $9b4b	                jmp readRTCByte

771							;-------------------------------------------------------------------------
772							;
773							; Read default keyboard auto repeat rate from CMOS RAM.
774							;
775							; exit:
776							;
777							; Y = default keyboard auto repeat rate
778							;
779	.8e96						getDefaultKeyboardAutoRepeatRate:
780	.8e96		a2 1b		ldx #$1b	                ldx #CMOSBytes.keyboardAutoRepeatRate+cmosBytesOffset
781	.8e98		4c 4b 9b	jmp $9b4b	                jmp readRTCByte

783							;-------------------------------------------------------------------------

785	.8e9b						printDefaultPrinterIgnoreChar:
786	.8e9b		20 3e 9b	jsr $9b3e	                jsr readDefaults2
787	.8e9e		89 02		bit #$02	                bit #CMOSBytes.defaults2.usePrinterIgnoreCharMask
788	.8ea0		f0 0f		beq $8eb1	                beq showDefaultPrinterIgnoreChar
789	.8ea2						printNoIgnore:
790	.8ea2		20 45 91	jsr $9145	                jsr printNo_
791	.8ea5		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
792	>8ea8		49 67 6e 6f 72 65 0d 00		                .text "Ignore",13,0
793	.8eb0		60		rts		                rts

795	.8eb1						showDefaultPrinterIgnoreChar:
796	.8eb1		20 3c 91	jsr $913c	                jsr readDefaultPrinterIgnoreChar
797	.8eb4		20 d5 8e	jsr $8ed5	                jsr printDecimalByte
798	.8eb7		80 c9		bra $8e82	                bra printNewLine8B2B

800	.8eb9						printDefaultPrinterIgnoreChar2:
801	.8eb9		20 3e 9b	jsr $9b3e	                jsr readDefaults2
802	.8ebc		89 02		bit #$02	                bit #CMOSBytes.defaults2.usePrinterIgnoreCharMask
803	.8ebe		d0 e2		bne $8ea2	                bne printNoIgnore
804	.8ec0		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
805	>8ec3		49 67 6e 6f 72 65 20 20		                .text "Ignore   ",0
	>8ecb		20 00
806	.8ecd		80 e2		bra $8eb1	                bra showDefaultPrinterIgnoreChar

808							;-------------------------------------------------------------------------

810	.8ecf						printDefaultFX5Settings:
811	.8ecf		20 26 91	jsr $9126	                jsr readDefaultFX5Settings
812	.8ed2		80 ab		bra $8e7f	                bra printDecimalByteThenNewLine

814							;-------------------------------------------------------------------------

816							                .if version<400
820							                .endif

822							;-------------------------------------------------------------------------

824							                .if version<400
828							                .endif

830							;-------------------------------------------------------------------------

832							                .if version<400
837							                .endif

839							;-------------------------------------------------------------------------

841							                .if version<400
854							                .endif

856							;-------------------------------------------------------------------------

858							                .if version<400
869							                .endif

871							;-------------------------------------------------------------------------
872							;
873							;
874							;
875	.8ed4						printDecimalByteY:
876	.8ed4		98		tya		                tya
877	.8ed5						printDecimalByte:
878	.8ed5		38		sec		                sec                          ;in leading 0s state
879	.8ed6		a0 ff		ldy #$ff	                ldy #$FF                     ;digit = -1
880	.8ed8		08		php		                php                          ;save leading 0s state
881	.8ed9						hundredsLoop:
882	.8ed9		c8		iny		                iny
883	.8eda		e9 64		sbc #$64	                sbc #100
884	.8edc		b0 fb		bcs $8ed9	                bcs hundredsLoop
885	.8ede		69 64		adc #$64	                adc #100                     ;undo the step too far
886	.8ee0		28		plp		                plp                        ;restore leading 0s state
887	.8ee1		20 f5 8e	jsr $8ef5	                jsr printDecimalDigit
888	.8ee4		a0 ff		ldy #$ff	                ldy #$FF
889	.8ee6		08		php		                php
890	.8ee7		38		sec		                sec
891	.8ee8						tensLoop:
892	.8ee8		c8		iny		                iny
893	.8ee9		e9 0a		sbc #$0a	                sbc #10
894	.8eeb		b0 fb		bcs $8ee8	                bcs tensLoop
895	.8eed		69 0a		adc #$0a	                adc #10                      ;undo the step too far
896	.8eef		28		plp		                plp                          ;restore leading 0s state
897	.8ef0		20 f5 8e	jsr $8ef5	                jsr printDecimalDigit
898	.8ef3		18		clc		                clc                      ;definitely not leading 0 now
899	.8ef4		a8		tay		                tay
900	.8ef5						printDecimalDigit:
901	.8ef5		48		pha		                pha
902	.8ef6		98		tya		                tya                          ;A=digit index
903	.8ef7		d0 02		bne $8efb	                bne +             ;taken if definitely not a leading 0
904	.8ef9		b0 04		bcs $8eff	                bcs ++            ;skip the print if a leading 0
905	.8efb						+
906	.8efb		20 23 ae	jsr $ae23	                jsr printHexDigit
907	.8efe		18		clc		                clc                          ;clear leading 0 flag
908	.8eff						+
909	.8eff		68		pla		                pla
910	.8f00		60		rts		                rts

912							;-------------------------------------------------------------------------
913							;
914							; Print *CONFIGURE help
915							;
916	.8f01						printCONFIGUREHelp:
917	.8f01		20 ff 8c	jsr $8cff	                jsr ensureCommandLineTailEmpty
918	.8f04		5a		phy		                phy
919	.8f05		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
920	>8f08		43 6f 6e 66 69 67 75 72		                .text "Configuration options:",13
	>8f10		61 74 69 6f 6e 20 6f 70 74 69 6f 6e 73 3a 0d
921							                .if version<400
923							                .endif
924	>8f1f		42 6f 6f 74 0d			                .text "Boot",13
925	>8f24		43 61 70 73 0d			                .text "Caps",13
926							                .if version<400
928							                .endif
929	>8f29		44 65 6c 61 79 20 20 20		                .text "Delay    <D>",13
	>8f31		20 3c 44 3e 0d
930							                .if version<400
932							                .endif
933	>8f36		45 78 54 75 62 65 0d		                .text "ExTube",13
934							                .if version<400
936							                .endif
937	>8f3d		46 69 6c 65 20 20 20 20		                .text "File     <D>",13
	>8f45		20 3c 44 3e 0d
938							                .if version<400
940							                .endif
941							                .if version<400
943							                .endif
944	>8f4a		49 67 6e 6f 72 65 20 20		                .text "Ignore   [<D>]",13
	>8f52		20 5b 3c 44 3e 5d 0d
945	>8f59		49 6e 54 75 62 65 0d		                .text "InTube",13
946	>8f60		4c 61 6e 67 20 20 20 20		                .text "Lang     <D>",13
	>8f68		20 3c 44 3e 0d
947	>8f6d		4c 6f 75 64 0d			                .text "Loud",13
948	>8f72		4d 6f 64 65 20 20 20 20		                .text "Mode     <D>",13
	>8f7a		20 3c 44 3e 0d
949	>8f7f		4e 6f 42 6f 6f 74 0d		                .text "NoBoot",13
950	>8f86		4e 6f 43 61 70 73 0d		                .text "NoCaps",13
951							                .if version<400
953							                .endif
954	>8f8d		4e 6f 53 63 72 6f 6c 6c		                .text "NoScroll",13
	>8f95		0d
955	>8f96		4e 6f 54 75 62 65 0d		                .text "NoTube",13
956	>8f9d		50 72 69 6e 74 20 20 20		                .text "Print    <D>",13
	>8fa5		20 3c 44 3e 0d
957	>8faa		51 75 69 65 74 0d		                .text "Quiet",13
958	>8fb0		52 65 70 65 61 74 20 20		                .text "Repeat   <D>",13
	>8fb8		20 3c 44 3e 0d
959	>8fbd		53 63 72 6f 6c 6c 0d		                .text "Scroll",13
960	>8fc4		53 68 43 61 70 73 0d		                .text "ShCaps",13
961	>8fcb		54 75 62 65 0d			                .text "Tube",13
962	>8fd0		54 56 20 20 20 20 20 20		                .text "TV       [<D>[,<D>]]",13
	>8fd8		20 5b 3c 44 3e 5b 2c 3c 44 3e 5d 5d 0d
963	>8fe5		00				                .byte 0
964	.8fe6		7a		ply		                ply
965	.8fe7		a2 28		ldx #$28	                ldx #romServiceCallUnknownCONFIG
966	.8fe9		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
967	.8fec		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
968	>8fef		57 68 65 72 65 3a 0d		                .text "Where:",13
969	>8ff6		44 20 69 73 20 61 20 64		                .text "D is a decimal number, or",13
	>8ffe		65 63 69 6d 61 6c 20 6e 75 6d 62 65 72 2c 20 6f
	>900e		72 0d
970	>9010		61 20 68 65 78 61 64 65		                .text "a hexadecimal number preceded by &",13
	>9018		63 69 6d 61 6c 20 6e 75 6d 62 65 72 20 70 72 65
	>9028		63 65 64 65 64 20 62 79 20 26 0d
971	>9033		49 74 65 6d 73 20 77 69		                .text "Items within [ ] are optional",13
	>903b		74 68 69 6e 20 5b 20 5d 20 61 72 65 20 6f 70 74
	>904b		69 6f 6e 61 6c 0d
972	>9051		00				                .byte $00
973	.9052		60		rts		                rts

975							;-------------------------------------------------------------------------
976							;
977							;
978	.9053						printSTATUSHelp:
979	.9053		20 ff 8c	jsr $8cff	                jsr ensureCommandLineTailEmpty
980	.9056		5a		phy		                phy

982	.9057		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
983	>905a		43 6f 6e 66 69 67 75 72		                .text "Configuration status:",13
	>9062		61 74 69 6f 6e 20 73 74 61 74 75 73 3a 0d
984							                .if version<400
987							                .else
988	>9070		00				                .byte 0
989							                .endif

991	.9071		20 38 8e	jsr $8e38	                jsr printDefaultAutoBoot

993	.9074		20 bd 8d	jsr $8dbd	                jsr printDefaultCaps

995							                .if version<400
999							                .endif

1001	.9077		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
1002	>907a		44 65 6c 61 79 20 20 20		                .text "Delay    ",0
	>9082		20 00
1003	.9084		20 85 8e	jsr $8e85	                jsr printDefaultKeyboardAutoRepeatDelay

1005							                .if version<400
1007							                .endif

1009							                .if includeTubeSupport
1010	.9087		20 12 8e	jsr $8e12	                jsr printDefaultExtTube
1011							                .endif

1013							                .if version<400
1017							                .endif

1019	.908a		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
1020	>908d		46 69 6c 65 20 20 20 20		                .text "File     ",0
	>9095		20 00
1021	.9097		20 67 8e	jsr $8e67	                jsr printDefaultFSROM

1023							                .if version<400
1025							                .endif

1027	.909a		20 b9 8e	jsr $8eb9	                jsr printDefaultPrinterIgnoreChar2

1029	.909d		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
1030	>90a0		4c 61 6e 67 20 20 20 20		                .text "Lang     ",0
	>90a8		20 00
1031	.90aa		20 5f 8e	jsr $8e5f	                jsr printDefaultLanguageROM

1033	.90ad		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
1034	>90b0		4d 6f 64 65 20 20 20 20		                .text "Mode     ",0
	>90b8		20 00
1035	.90ba		20 7c 8e	jsr $8e7c	                jsr printDefaultMODE

1037							                .if includeTubeSupport
1038	.90bd		20 4c 8e	jsr $8e4c	                jsr printDefaultTubeOn
1039							                .endif

1041	.90c0		20 f6 8d	jsr $8df6	                jsr printDefaultLoud

1043	.90c3		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
1044	>90c6		50 72 69 6e 74 20 20 20		                .text "Print    "
	>90ce		20
1045	>90cf		00				                .byte 0
1046	.90d0		20 cf 8e	jsr $8ecf	                jsr printDefaultFX5Settings

1048	.90d3		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
1049	>90d6		52 65 70 65 61 74 20 20		                .text "Repeat   ",0
	>90de		20 00
1050	.90e0		20 8b 8e	jsr $8e8b	                jsr printDefaultKeyboardRepeatRate

1052	.90e3		20 e0 8d	jsr $8de0	                jsr printDefaultProtectedScrolling

1054	.90e6		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
1055	>90e9		54 56 20 20 20 20 20 20		                .text "TV       ",0
	>90f1		20 00
1056	.90f3		20 6e 8e	jsr $8e6e	                jsr printDefaultTVSettings

1058	.90f6		7a		ply		                ply
1059	.90f7		a2 29		ldx #$29	                ldx #romServiceCallUnknownSTATUS
1060	.90f9		4c 52 ec	jmp $ec52	                jmp makeROMServiceCall



:4	;******  Return to file: src/terminal.s65

944							                .endif

946							;-------------------------------------------------------------------------

948							                .if version>=500
956							                .endif

958							;-------------------------------------------------------------------------

960							                .if !useTableDrivenConfigure
961							;-------------------------------------------------------------------------
962							;
963							; Read default *TV settings.
964							;
965							; exit:
966							;
967							; X = interlace flag (0=off, 1=on)
968							;
969							; Y = *TV offset
970	.90fc						readDefaultTVSettings:
971	.90fc		a2 18		ldx #$18	                ldx #CMOSBytes.defaults0+cmosBytesOffset
972	.90fe		20 4b 9b	jsr $9b4b	                jsr readRTCByte
973	.9101		5a		phy		                phy
974	.9102		29 e0		and #$e0	                and #%11100000
975	.9104		0a		asl a		                asl a
976	.9105		2a		rol a		                rol a
977	.9106		2a		rol a		                rol a
978	.9107		2a		rol a		                rol a                        ;move into bottom 3 bits
979	.9108		89 04		bit #$04	                bit #$04                     ;sign bit?
980	.910a		f0 02		beq $910e	                beq +                        ;taken if positive
981	.910c		09 fc		ora #$fc	                ora #%11111100               ;sign extent from bit 2
982	.910e						+
983	.910e		a8		tay		                tay
984	.910f		68		pla		                pla
985	.9110		a2 00		ldx #$00	                ldx #$00                     ;X=0 - interlace off
986	.9112		89 10		bit #$10	                bit #CMOSBytes.defaults0.interlaceMask
987	.9114		f0 01		beq $9117	                beq +
988	.9116		e8		inx		                inx                          ;X=1 - interlace on
989	.9117						+
990	.9117		60		rts		                rts

992							;-------------------------------------------------------------------------
993							;
994							; Read configured MODE
995							; --------------------
996	.9118						readDefaultMODE:
997	.9118		a2 18		ldx #$18	                ldx #CMOSBytes.defaults0+cmosBytesOffset
998	.911a		20 4b 9b	jsr $9b4b	                jsr readRTCByte
999	.911d		29 0f		and #$0f	                and #CMOSBytes.defaults0.modeMask|CMOSBytes.defaults0.shadowMask
1000	.911f		89 08		bit #$08	                bit #CMOSBytes.defaults0.shadowMask
1001	.9121		f0 02		beq $9125	                beq +
1002	.9123		49 88		eor #$88	                eor #$80|CMOSBytes.defaults0.shadowMask ;reset defaultSHADOWMask bit, set bit 7
1003	.9125						+
1004	.9125		60		rts		                rts

1006							;-------------------------------------------------------------------------
1007							;
1008							;
1009							                .if version!=400
1017							                .endif

1019							;-------------------------------------------------------------------------

1021	.9126						readDefaultFX5Settings:
1022	.9126		20 3e 9b	jsr $9b3e	                jsr readDefaults2
1023	.9129						getTop3Bits:
1024	.9129		29 e0		and #$e0	                and #%11100000               ;? %abc00000
1025	.912b		0a		asl a		                asl a                        ;a %bc000000
1026	.912c		2a		rol a		                rol a                        ;b %c000000a
1027	.912d		2a		rol a		                rol a                        ;c %000000ab
1028	.912e		2a		rol a		                rol a                        ;0 %00000abc
1029	.912f		60		rts		                rts

1031							;-------------------------------------------------------------------------
1032							;
1033							;
1034							                .if version!=400
1038							                .endif

1040							;-------------------------------------------------------------------------

1042	.9130						readDefaultLanguageROM:
1043	.9130		20 38 91	jsr $9138	                jsr readDefaultROMs
1044	.9133		4a		lsr a		                lsr a
1045	.9134		4a		lsr a		                lsr a
1046	.9135		4a		lsr a		                lsr a
1047	.9136		4a		lsr a		                lsr a
1048	.9137		60		rts		                rts

1050							;-------------------------------------------------------------------------
1051							;
1052							;
1053	.9138						readDefaultROMs:
1054	.9138		a2 13		ldx #$13	                ldx #CMOSBytes.defaultROMs+cmosBytesOffset;
1055	.913a		80 02		bra $913e	                bra jmpReadRTCByte

1057							;-------------------------------------------------------------------------

1059	.913c						readDefaultPrinterIgnoreChar:
1060	.913c		a2 1c		ldx #$1c	                ldx #CMOSBytes.printerIgnoreChar+cmosBytesOffset
1061	.913e						jmpReadRTCByte:
1062	.913e		4c 4b 9b	jmp $9b4b	                jmp readRTCByte

1064							;-------------------------------------------------------------------------

1066	.9141						readDefaults1:
1067	.9141		a2 19		ldx #$19	                ldx #CMOSBytes.defaults1+cmosBytesOffset
1068	.9143		80 f9		bra $913e	                bra jmpReadRTCByte

1070							;-------------------------------------------------------------------------

1072	.9145						printNo_:
1073	.9145		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
1074	>9148		4e 6f 20 00			                .text "No ",0
1075	.914c		60		rts		                rts

1077							;-------------------------------------------------------------------------
1078							                .endif

1080							;-------------------------------------------------------------------------
1081							;
1082							; [MasRef G.5-8]
1083							;
1084	.914d						starPRINT:
1085	.914d		a9 c0		lda #$c0	                lda #$C0
1086	.914f		8d c2 df	sta $dfc2	                sta hazel.fsFlags
1087	.9152		80 12		bra $9166	                bra L8ED2

1089							;-------------------------------------------------------------------------

1091	.9154						starLIST:
1092	.9154		4e c2 df	lsr $dfc2	                lsr hazel.fsFlags
1093	.9157		9c c3 df	stz $dfc3	                stz hazel.lineNumberBCD+0
1094	.915a		9c c4 df	stz $dfc4	                stz hazel.lineNumberBCD+1
1095	.915d		80 04		bra $9163	                bra L8ECF

1097							;-------------------------------------------------------------------------

1099	.915f						starTYPE:
1100	.915f		38		sec		                sec
1101	.9160		6e c2 df	ror $dfc2	                ror hazel.fsFlags
1102	.9163						L8ECF:
1103	.9163		4e c2 df	lsr $dfc2	                lsr hazel.fsFlags
1104	.9166						L8ED2:
1105	.9166		9c c5 df	stz $dfc5	                stz hazel.lastCharPrinted
1106	.9169		20 fd ab	jsr $abfd	                jsr openFileForReading
1107	.916c						L8ED8:
1108	.916c		24 ff		bit $ff		                bit $FF
1109	.916e		30 52		bmi $91c2	                bmi handleESCAPEWithFileOpen
1110	.9170		20 d7 ff	jsr $ffd7	                jsr OSBGET
1111	.9173		b0 2e		bcs $91a3	                bcs closeFile
1112	.9175		2c c2 df	bit $dfc2	                bit hazel.fsFlags
1113	.9178		70 05		bvs $917f	                bvs L8EEB
1114	.917a		48		pha		                pha
1115	.917b		20 7f 94	jsr $947f	                jsr printLineNumber
1116	.917e		68		pla		                pla
1117	.917f						L8EEB:
1118	.917f		2c c2 df	bit $dfc2	                bit hazel.fsFlags
1119	.9182		30 14		bmi $9198	                bmi L8F04
1120	.9184		c9 0d		cmp #$0d	                cmp #$0D
1121	.9186		f0 20		beq $91a8	                beq L8F14
1122	.9188		c9 0a		cmp #$0a	                cmp #$0A
1123	.918a		f0 1c		beq $91a8	                beq L8F14
1124	.918c		8d c5 df	sta $dfc5	                sta hazel.lastCharPrinted
1125	.918f		c9 22		cmp #$22	                cmp #'"'
1126	.9191		f0 05		beq $9198	                beq L8F04
1127	.9193		20 9a 98	jsr $989a	                jsr printGSREADChar
1128	.9196		80 03		bra $919b	                bra L8F07

1130	.9198						L8F04:
1131	.9198		20 ee ff	jsr $ffee	                jsr OSWRCH
1132	.919b						L8F07:
1133	.919b		20 ce 91	jsr $91ce	                jsr bgetAndCheckForESCAPE
1134	.919e		90 df		bcc $917f	                bcc L8EEB
1135	.91a0						printNewLineThenCloseFile:
1136	.91a0		20 e7 ff	jsr $ffe7	                jsr OSNEWL
1137	.91a3						closeFile:
1138	.91a3		a9 00		lda #$00	                lda #$00
1139	.91a5		4c ce ff	jmp $ffce	                jmp OSFIND

1141	.91a8						L8F14:
1142	.91a8		cd c5 df	cmp $dfc5	                cmp hazel.lastCharPrinted
1143	.91ab		f0 10		beq $91bd	                beq L8F29
1144	.91ad		48		pha		                pha
1145	.91ae		ad c5 df	lda $dfc5	                lda hazel.lastCharPrinted
1146	.91b1		c9 0d		cmp #$0d	                cmp #$0D
1147	.91b3		f0 13		beq $91c8	                beq L8F34
1148	.91b5		c9 0a		cmp #$0a	                cmp #$0A
1149	.91b7		f0 0f		beq $91c8	                beq L8F34
1150	.91b9		68		pla		                pla
1151	.91ba		8d c5 df	sta $dfc5	                sta hazel.lastCharPrinted
1152	.91bd						L8F29:
1153	.91bd		20 e7 ff	jsr $ffe7	                jsr OSNEWL
1154	.91c0		80 aa		bra $916c	                bra L8ED8

1156							;-------------------------------------------------------------------------
1157							;
1158							; Tidily handle ESCAPE when a file is open during *DUMP or whatever.
1159							; Prints a new line, closes the file, then does an Escape error.
1160							;
1161							; entry:
1162							;
1163							; Y = file handle
1164							;
1165	.91c2						handleESCAPEWithFileOpen:
1166	.91c2		20 a0 91	jsr $91a0	                jsr printNewLineThenCloseFile
1167	.91c5		4c 41 ae	jmp $ae41	                jmp escapeError

1169							;-------------------------------------------------------------------------

1171	.91c8						L8F34:
1172	.91c8		68		pla		                pla
1173	.91c9		9c c5 df	stz $dfc5	                stz hazel.lastCharPrinted
1174	.91cc		80 cd		bra $919b	                bra L8F07

1176							;-------------------------------------------------------------------------
1177							;
1178							; Does an OSBGET and handles ESCAPE.
1179							;
1180							; entry:
1181							;
1182							; Y = file handle
1183							;
1184							; exit:
1185							;
1186							; A = byte read
1187							; C=1 if EOF
1188							; (as per OSBGET)
1189							;
1190	.91ce						bgetAndCheckForESCAPE:
1191	.91ce		20 d7 ff	jsr $ffd7	                jsr OSBGET
1192	.91d1		24 ff		bit $ff		                bit $FF
1193	.91d3		30 ed		bmi $91c2	                bmi handleESCAPEWithFileOpen
1194	.91d5		60		rts		                rts

1196							;-------------------------------------------------------------------------
1197							;
1198							; *DUMP [MasRef G.5-4]
1199							;
1200	.91d6						starDUMP:
1201	.91d6		86 f2		stx $f2		                stx stringInputBufferAddress+0
1202	.91d8		84 f3		sty $f3		                sty stringInputBufferAddress+1
1203	.91da		a2 00		ldx #$00	                ldx #$00
1204	.91dc		20 50 95	jsr $9550	                jsr clearOSFILEParameterBlockDWORD
1205	.91df		a2 04		ldx #$04	                ldx #$04
1206	.91e1		20 50 95	jsr $9550	                jsr clearOSFILEParameterBlockDWORD
1207	.91e4		a0 00		ldy #$00	                ldy #$00
1208	.91e6		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
1209	.91e9		20 5c f0	jsr $f05c	                jsr gsinitForFilenameParsing
1210	.91ec						L8F58:
1211	.91ec		20 6e f0	jsr $f06e	                jsr gsreadEntryPoint
1212	.91ef		90 fb		bcc $91ec	                bcc L8F58
1213	.91f1		f0 1a		beq $920d	                beq L8F79
1214	.91f3		a2 00		ldx #$00	                ldx #$00
1215	.91f5		20 ef 95	jsr $95ef	                jsr parseHexAddressFromCommandLine

1217	.91f8		a2 03		ldx #$03	                ldx #$03
1218	.91fa						-
1219	.91fa		bd ed 02	lda $02ed,x	                lda osfileParameterBlock+0,x
1220	.91fd		9d f1 02	sta $02f1,x	                sta osfileParameterBlock+4,x
1221	.9200		ca		dex		                dex
1222	.9201		10 f7		bpl $91fa	                bpl -

1224	.9203		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
1225	.9206		f0 05		beq $920d	                beq L8F79
1226	.9208		a2 04		ldx #$04	                ldx #$04
1227	.920a		20 ef 95	jsr $95ef	                jsr parseHexAddressFromCommandLine
1228	.920d						L8F79:
1229	.920d		a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
1230	.920f		a6 f2		ldx $f2		                ldx stringInputBufferAddress+0
1231	.9211		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
1232	.9214		20 fd ab	jsr $abfd	                jsr openFileForReading

1234	.9217		a9 02		lda #$02	                lda #argsFileGetEXT
1235	.9219		20 f5 96	jsr $96f5	                jsr callOSARGSWithBuffer

1237	.921c		a2 03		ldx #$03	                ldx #$03
1238	.921e						L8F8A:
1239	.921e		b5 a8		lda $a8,x	                lda osargsBuffer,x
1240	.9220		dd ed 02	cmp $02ed,x	                cmp osfileParameterBlock+0,x
1241	.9223		90 6a		bcc $928f	                bcc L8FFB
1242	.9225		d0 03		bne $922a	                bne L8F96
1243	.9227		ca		dex		                dex
1244	.9228		10 f4		bpl $921e	                bpl L8F8A
1245	.922a						L8F96:
1246	.922a		a2 03		ldx #$03	                ldx #$03
1247	.922c						-
1248	.922c		bd ed 02	lda $02ed,x	                lda osfileParameterBlock+0,x
1249	.922f		95 a8		sta $a8,x	                sta osargsBuffer,x
1250	.9231		ca		dex		                dex
1251	.9232		10 f8		bpl $922c	                bpl -
1252	.9234		20 f3 96	jsr $96f3	                jsr setFilePointerFromOSARGSBuffer
1253	.9237						L8FA3:
1254	.9237		a2 00		ldx #$00	                ldx #$00
1255	.9239		20 d7 ff	jsr $ffd7	                jsr OSBGET
1256	.923c		b0 46		bcs $9284	                bcs L8FF0
1257	.923e		20 cd 94	jsr $94cd	                jsr L9239
1258	.9241		48		pha		                pha
1259	.9242		ad f1 02	lda $02f1	                lda osfileParameterBlock+4
1260	.9245		29 07		and #$07	                and #$07
1261	.9247		f0 15		beq $925e	                beq L8FCA
1262	.9249		5a		phy		                phy
1263	.924a		a8		tay		                tay
1264	.924b						L8FB7:
1265	.924b		5a		phy		                phy
1266	.924c		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
1267	>924f		20 20 20 00			                .text "   ",0
1268	.9253		7a		ply		                ply
1269	.9254		a9 20		lda #$20	                lda #$20
1270	.9256		9d f5 02	sta $02f5,x	                sta osfileParameterBlock+8,x
1271	.9259		e8		inx		                inx
1272	.925a		88		dey		                dey
1273	.925b		d0 ee		bne $924b	                bne L8FB7
1274	.925d		7a		ply		                ply
1275	.925e						L8FCA:
1276	.925e		68		pla		                pla
1277	.925f						L8FCB:
1278	.925f		48		pha		                pha
1279	.9260		c9 20		cmp #$20	                cmp #32
1280	.9262		90 04		bcc $9268	                bcc nonPrintable
1281	.9264		c9 7f		cmp #$7f	                cmp #127
1282	.9266		90 02		bcc $926a	                bcc L8FD6                    ;taken if printable
1283	.9268						nonPrintable:
1284	.9268		a9 2e		lda #$2e	                lda #'.'          ;placeholder for non-printable chars
1285	.926a						L8FD6:
1286	.926a		9d f5 02	sta $02f5,x	                sta osfileParameterBlock+8,x
1287	.926d		68		pla		                pla
1288	.926e		20 15 ae	jsr $ae15	                jsr printSpaceThenPrintHexByte
1289	.9271		e8		inx		                inx
1290	.9272		20 dc 94	jsr $94dc	                jsr L9248
1291	.9275		ad f1 02	lda $02f1	                lda osfileParameterBlock+4
1292	.9278		29 07		and #$07	                and #$07
1293	.927a		f0 0b		beq $9287	                beq L8FF3
1294	.927c		20 ce 91	jsr $91ce	                jsr bgetAndCheckForESCAPE
1295	.927f		90 de		bcc $925f	                bcc L8FCB
1296	.9281		20 eb 94	jsr $94eb	                jsr L9257
1297	.9284						L8FF0:
1298	.9284		4c a3 91	jmp $91a3	                jmp closeFile

1300	.9287						L8FF3:
1301	.9287		20 eb 94	jsr $94eb	                jsr L9257
1302	.928a		80 ab		bra $9237	                bra L8FA3

1304	.928c						L8FF8:
1305	.928c		4c 05 ac	jmp $ac05	                jmp notFoundError

1307	.928f						L8FFB:
1308	.928f		20 a3 91	jsr $91a3	                jsr closeFile
1309	.9292		20 23 b0	jsr $b023	                jsr doFollowingError
1310	>9295		b7 4f 75 74 73 69 64 65		                .text $b7,"Outside file",0
	>929d		20 66 69 6c 65 00

1312							;-------------------------------------------------------------------------
1313							;
1314							; *BUILD
1315							;
1316	.92a3						starBUILD:
1317	.92a3		4e c2 df	lsr $dfc2	                lsr hazel.fsFlags            ;clear bit 7 of fsFlags
1318	.92a6		80 04		bra $92ac	                bra starBUILDOrAPPEND

1320							;-------------------------------------------------------------------------
1321							;
1322							; *APPEND
1323							;
1324	.92a8						starAPPEND:
1325	.92a8		38		sec		                sec
1326	.92a9		6e c2 df	ror $dfc2	                ror hazel.fsFlags            ;set bit 7 of fsFlags
1327	.92ac						starBUILDOrAPPEND:
1328							                ; bit 7 of fsFlags indicates *BUILD (clear) or *APPEND
1329							                ; (set).
1330	.92ac		9c c3 df	stz $dfc3	                stz hazel.lineNumberBCD+0    ;reset line number
1331	.92af		9c c4 df	stz $dfc4	                stz hazel.lineNumberBCD+1    ;reset line number
1332	.92b2		a9 80		lda #$80	                lda #$80                     ;open for output. Assume *BUILD
1333	.92b4		2c c2 df	bit $dfc2	                bit hazel.fsFlags            ;test *BUILD/*APPEND
1334	.92b7		10 02		bpl $92bb	                bpl +                        ;branch taken if *BUILD
1335	.92b9		a9 c0		lda #$c0	                lda #$C0                     ;*APPEND, so open for update
1336	.92bb						+
1337	.92bb		20 ce ff	jsr $ffce	                jsr OSFIND                   ;open the file
1338	.92be		a8		tay		                tay                          ;Y=file handle
1339	.92bf		f0 cb		beq $928c	                beq L8FF8                    ;branch taken if open failed
1340	.92c1		8c ed 02	sty $02ed	                sty osfileParameterBlock+0   ;save file handle
1341	.92c4		20 ee 96	jsr $96ee	                jsr setPTRToEOF ;move to EOF (effective no-op when *BUILD)
1342	.92c7						L9033:
1343	.92c7		20 7f 94	jsr $947f	                jsr printLineNumber
1344	.92ca						L9036:
1345							                .if version<500&&version!=350
1346	.92ca		20 b2 86	jsr $86b2	                jsr readCommandLine
1352							                .endif
1353	.92cd		08		php		                php
1354	.92ce		90 0f		bcc $92df	                bcc L904B
1355							                ; Handle ESCAPE
1356	.92d0		20 e7 ff	jsr $ffe7	                jsr OSNEWL
1357	.92d3		a9 0d		lda #$0d	                lda #$0D
1358	.92d5		99 00 dc	sta $dc00,y	                sta hazel.commandLine,y      ;terminate current line
1359	.92d8						L9044:
1360	.92d8		5a		phy		                phy                          ;save line length
1361	.92d9		a9 7e		lda #$7e	                lda #$7E
1362	.92db		20 f4 ff	jsr $fff4	                jsr OSBYTE                   ;acknowledge ESCAPE
1363	.92de		7a		ply		                ply                          ;restore line length
1364	.92df						L904B:
1365	.92df		98		tya		                tya                          ;A=line length
1366	.92e0		f0 50		beq $9332	                beq L909E                    ;taken if line empty
1367	.92e2		20 3f 93	jsr $933f	                jsr setStringInputBufferToCommandLine
1368	.92e5		a0 00		ldy #$00	                ldy #$00
1369	.92e7		a2 00		ldx #$00	                ldx #$00
1370	.92e9						L9055:
1371	.92e9		20 8b f0	jsr $f08b	                jsr LF29C
1372	.92ec		9d 00 dc	sta $dc00,x	                sta hazel.commandLine,x
1373	.92ef		a9 01		lda #$01	                lda #stringInputOptions.goodString
1374	.92f1		24 e4		bit $e4		                bit stringInputOptions
1375	.92f3		d0 0b		bne $9300	                bne L906C
1376	.92f5		a9 07		lda #$07	                lda #7
1377	.92f7		20 ee ff	jsr $ffee	                jsr OSWRCH                   ;beep
1378	.92fa		20 89 94	jsr $9489	                jsr L91F5
1379	.92fd		28		plp		                plp
1380	.92fe		80 ca		bra $92ca	                bra L9036

1382	.9300						L906C:
1383	.9300		e8		inx		                inx
1384	.9301		90 e6		bcc $92e9	                bcc L9055
1385	.9303		28		plp		                plp
1386	.9304		90 01		bcc $9307	                bcc L9073
1387	.9306		ca		dex		                dex
1388	.9307						L9073:
1389	.9307		08		php		                php
1390	.9308		da		phx		                phx
1391	.9309		a2 0b		ldx #$0b	                ldx #size(OSGBPBParameterBlock)-2
1392	.930b						L9077:
1393	.930b		9e ee 02	stz $02ee,x	                stz osfileParameterBlock+1,x
1394	.930e		ca		dex		                dex
1395	.930f		10 fa		bpl $930b	                bpl L9077
1396	.9311		fa		plx		                plx
1397	.9312		8e f2 02	stx $02f2	                stx osfileParameterBlock+OSGBPBParameterBlock.count+0
1398							                .cerror (<hazel.commandLine)!=0,"hazel.commandLine must be page aligned"
1399	.9315		a9 dc		lda #$dc	                lda #>hazel.commandLine
1400	.9317		8d ef 02	sta $02ef	                sta osfileParameterBlock+OSGBPBParameterBlock.address+1
1401	.931a		ce f0 02	dec $02f0	                dec osfileParameterBlock+OSGBPBParameterBlock.address+2
1402	.931d		ce f1 02	dec $02f1	                dec osfileParameterBlock+OSGBPBParameterBlock.address+3
1403	.9320		a9 02		lda #$02	                lda #gbpbPutBytesCurrentPTR
1404	.9322		a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
1405	.9324		a0 02		ldy #$02	                ldy #>osfileParameterBlock
1406	.9326		20 d1 ff	jsr $ffd1	                jsr OSGBPB
1407	.9329		28		plp		                plp
1408	.932a		90 9b		bcc $92c7	                bcc L9033
1409	.932c						L9098:
1410	.932c		ac ed 02	ldy $02ed	                ldy osfileParameterBlock+0
1411	.932f		4c a3 91	jmp $91a3	                jmp closeFile

1413	.9332						L909E:
1414	.9332		28		plp		                plp
1415	.9333		b0 f7		bcs $932c	                bcs L9098
1416	.9335		a9 0d		lda #$0d	                lda #13
1417	.9337		ac ed 02	ldy $02ed	                ldy osfileParameterBlock
1418	.933a		20 d4 ff	jsr $ffd4	                jsr OSBPUT
1419	.933d		80 88		bra $92c7	                bra L9033

1421	.933f						setStringInputBufferToCommandLine:
1422	.933f		a9 41		lda #$41	                lda #$41
1423	.9341		85 e4		sta $e4		                sta $E4
1424							                .cerror (<hazel.commandLine)!=0,"hazel.commandLine must be page aligned"
1425	.9343		64 f2		stz $f2		                stz stringInputBufferAddress+0
1426	.9345		a9 dc		lda #$dc	                lda #>hazel.commandLine
1427	.9347		85 f3		sta $f3		                sta stringInputBufferAddress+1
1428	.9349		60		rts		                rts

1430							;-------------------------------------------------------------------------

1432							                .if version>=500||version==350
1438							                .endif

1440							;-------------------------------------------------------------------------
1441							;
1442							; *MOVE
1443							;
1444	.934a						starMOVE:
1445	.934a		ad 34 fe	lda $fe34	                lda ACCCON                    ; Save ACCCON
1446	.934d		8d dc df	sta $dfdc	                sta hazel.oldACCCON
1447	.9350		48		pha		                pha                          ; Save ACCCON and command line pointer
1448	.9351		da		phx		                phx
1449	.9352		5a		phy		                phy
1450	.9353		a0 80		ldy #$80	                ldy #$80                     ; Top of available shadow memory at &8000
1451	.9355		a5 d0		lda $d0		                lda STATE                      ; Get VDU status
1452	.9357		89 10		bit #$10	                bit #$10                     ; Jump if not shadow screen, spare up to &8000
1453	.9359		f0 07		beq $9362	                beq L90CE
1454							; Shadow screen selected
1455	.935b		20 af ef	jsr $efaf	                jsr LF1C0                ; Get screen bottom to XY
1456	.935e		c0 30		cpy #$30	                cpy #$30                     ; Screen at &3000, no spare memory, jump to use Hazel
1457	.9360		f0 14		beq $9376	                beq L90E2

1459							; Non-shadow or small shadow screen selected
1460							; Y=top of available memory in shadow memory
1461	.9362						L90CE:
1462	.9362		a9 30		lda #$30	                lda #$30                     ; &3000=start of shadow memory
1463	.9364		8d d6 df	sta $dfd6	                sta hazel.moveBufferMSB
1464	.9367		a9 04		lda #$04	                lda #ACCCON.X
1465	.9369		0c 34 fe	tsb $fe34	                tsb ACCCON
1466	.936c		8d dd df	sta $dfdd	                sta hazel.hasACCCONChanged      ; set 'ACCCON changed'
1467	.936f		98		tya		                tya                          ; A=length of space in shadow memory
1468	.9370		38		sec		                sec
1469	.9371		ed d6 df	sbc $dfd6	                sbc hazel.moveBufferMSB
1470	.9374		80 07		bra $937d	                bra L90E9

1472							; No shadow memory available, use Hazel
1473	.9376						L90E2:
1474	.9376		a9 dd		lda #$dd	                lda #$DD                     ; Buffer at &DD00
1475	.9378		8d d6 df	sta $dfd6	                sta hazel.moveBufferMSB
1476	.937b		a9 02		lda #$02	                lda #$02                     ; Buffer length=&200

1478							; &DFD6=high byte of buffer address
1479							; A=high byte of buffer length
1480	.937d						L90E9:
1481	.937d		8d d7 df	sta $dfd7	                sta hazel.moveNumPages      ; Store buffer length
1482	.9380		7a		ply		                ply                          ; Get command line pointer
1483	.9381		fa		plx		                plx
1484	.9382		da		phx		                phx
1485	.9383		5a		phy		                phy
1486	.9384		a9 40		lda #$40	                lda #$40                     ; Open source file
1487	.9386		20 ce ff	jsr $ffce	                jsr OSFIND
1488	.9389		a8		tay		                tay                          ; Store source handle, jump if not found
1489	.938a		8c d4 df	sty $dfd4	                sty hazel.moveSrcHandle
1490	.938d		f0 39		beq $93c8	                beq L9134
1491	.938f		7a		ply		                ply                          ; Get command line back again
1492	.9390		fa		plx		                plx
1493	.9391		86 f2		stx $f2		                stx $F2
1494	.9393		84 f3		sty $f3		                sty $F3
1495	.9395		da		phx		                phx                          ; And save it again
1496	.9396		5a		phy		                phy
1497	.9397		a0 00		ldy #$00	                ldy #$00                     ; Step past first parameter
1498	.9399		20 5c f0	jsr $f05c	                jsr gsinitForFilenameParsing
1499	.939c						L9108:
1500	.939c		20 6e f0	jsr $f06e	                jsr gsreadEntryPoint     ;
1501	.939f		90 fb		bcc $939c	                bcc L9108
1502	.93a1		98		tya		                tya                          ; Save address of dest filename
1503	.93a2		18		clc		                clc
1504	.93a3		65 f2		adc $f2		                adc $F2
1505	.93a5		8d d8 df	sta $dfd8	                sta hazel.moveDestName+0
1506	.93a8		aa		tax		                tax
1507	.93a9		a5 f3		lda $f3		                lda $F3
1508	.93ab		69 00		adc #$00	                adc #$00
1509	.93ad		8d d9 df	sta $dfd9	                sta hazel.moveDestName+1
1510	.93b0		a8		tay		                tay                          ; Temporary filing system flag
1511	.93b1		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
1512	.93b4		a9 80		lda #$80	                lda #$80                     ; Open destination file
1513	.93b6		20 ce ff	jsr $ffce	                jsr OSFIND
1514	.93b9		a8		tay		                tay                          ; Store dest handle, jump if opened
1515	.93ba		8c d5 df	sty $dfd5	                sty hazel.moveDestHandle
1516	.93bd		d0 0c		bne $93cb	                bne L9137

1518							; Couldn't open destination
1519	.93bf		ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle      ; Get source handle and clear it
1520	.93c2		9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
1521	.93c5		20 ce ff	jsr $ffce	                jsr OSFIND                   ; Close source file
1522	.93c8						L9134:
1523	.93c8		4c 05 ac	jmp $ac05	                jmp notFoundError                    ; Jump to 'Not found' error

1525							; Source and dest opened
1526							; ----------------------
1527							; Build OSGBPB source file control block at &02ED
1528							; and destination control block at &DFC7
1529	.93cb						L9137:
1530	.93cb		a2 07		ldx #$07	                ldx #$07
1531	.93cd						L9139:
1532	.93cd		9e ee 02	stz $02ee,x	                stz @w osfileParameterBlock+OSGBPBParameterBlock.address,x ; Addr=0, Num=0
1533	.93d0		9e c8 df	stz $dfc8,x	                stz hazel.moveOSGBPB+1,x
1534	.93d3		ca		dex		                dex
1535	.93d4		10 f7		bpl $93cd	                bpl L9139
1536	.93d6		ad d4 df	lda $dfd4	                lda hazel.moveSrcHandle      ; Source handle
1537	.93d9		8d ed 02	sta $02ed	                sta osfileParameterBlock+OSGBPBParameterBlock.handle
1538	.93dc		ad d6 df	lda $dfd6	                lda hazel.moveBufferMSB      ; Buffer address
1539	.93df		8d ef 02	sta $02ef	                sta osfileParameterBlock+OSGBPBParameterBlock.address+1
1540	.93e2		8d c9 df	sta $dfc9	                sta hazel.moveOSGBPB.addr+1
1541	.93e5		ad d7 df	lda $dfd7	                lda hazel.moveNumPages
1542	.93e8		8d f3 02	sta $02f3	                sta osfileParameterBlock+OSGBPBParameterBlock.count+1
1543	.93eb		8d cd df	sta $dfcd	                sta hazel.moveOSGBPB.numBytes+1
1544	.93ee		ce f0 02	dec $02f0	                dec osfileParameterBlock+OSGBPBParameterBlock.address+2 ; Source addr=&FFFFxxxx
1545	.93f1		ce f1 02	dec $02f1	                dec osfileParameterBlock+OSGBPBParameterBlock.address+3
1546	.93f4		ce ca df	dec $dfca	                dec hazel.moveOSGBPB.addr+2
1547	.93f7		ce cb df	dec $dfcb	                dec hazel.moveOSGBPB.addr+3

1549							; Should use &FFFExxxx and let filing system select correct memory
1550							; Unfortunately, CFS/RFS and DFS do not recognise &FFFExxxx, so
1551							; *MOVE has to do it itself, causing problems for filing systems
1552							; that /do/ recognise &FFFExxxx where they have to remember to
1553							; *do* *nothing* for &FFFFxxxx instead of select main memory as
1554							; &FFFFxxxx implies.

1556	.93fa		a2 ed		ldx #$ed	                ldx #<osfileParameterBlock                     ; XY=>source OSGBPB block
1557	.93fc		a0 02		ldy #$02	                ldy #>osfileParameterBlock
1558	.93fe		a9 04		lda #$04	                lda #$04                     ; Read data from source
1559	.9400		20 d1 ff	jsr $ffd1	                jsr OSGBPB
1560	.9403		08		php		                php                          ; Jump if not at end of file
1561	.9404		90 11		bcc $9417	                bcc L9183
1562							; End of file, adjust destination buffer length for final part
1563	.9406		a9 00		lda #$00	                lda #$00
1564	.9408		ed f2 02	sbc $02f2	                sbc osfileParameterBlock+OSGBPBParameterBlock.count+0
1565	.940b		8d cc df	sta $dfcc	                sta hazel.moveOSGBPB.numBytes+0
1566	.940e		ad cd df	lda $dfcd	                lda hazel.moveOSGBPB.numBytes+1
1567	.9411		ed f3 02	sbc $02f3	                sbc osfileParameterBlock+OSGBPBParameterBlock.count+1
1568	.9414		8d cd df	sta $dfcd	                sta hazel.moveOSGBPB.numBytes+1
1569	.9417						L9183:
1570	.9417		ad d5 df	lda $dfd5	                lda hazel.moveDestHandle      ; Destination handle
1571	.941a		8d c7 df	sta $dfc7	                sta hazel.moveOSGBPB.handle
1572	.941d		a9 02		lda #$02	                lda #$02                     ; XY=>control block, A=write
1573	.941f		a2 c7		ldx #$c7	                ldx #<hazel.moveOSGBPB
1574	.9421		a0 df		ldy #$df	                ldy #>hazel.moveOSGBPB
1575	.9423		20 d1 ff	jsr $ffd1	                jsr OSGBPB
1576	.9426		28		plp		                plp                          ; Loop until end of file
1577	.9427		90 a2		bcc $93cb	                bcc L9137
1578	.9429		a9 00		lda #$00	                lda #$00
1579	.942b		ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle      ; Get and clear source handle
1580	.942e		9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
1581	.9431		5a		phy		                phy                          ; Close source file
1582	.9432		20 ce ff	jsr $ffce	                jsr OSFIND
1583	.9435		a9 00		lda #$00	                lda #$00                     ; Get dest handle
1584	.9437		ac d5 df	ldy $dfd5	                ldy hazel.moveDestHandle
1585	.943a		5a		phy		                phy                          ; Clear dest handle and close file
1586	.943b		9c d5 df	stz $dfd5	                stz hazel.moveDestHandle
1587	.943e		20 ce ff	jsr $ffce	                jsr OSFIND
1588	.9441		7a		ply		                ply                          ; Dest not CFS/RFS, jump to...
1589	.9442		c0 04		cpy #$04	                cpy #$04
1590	.9444		b0 0b		bcs $9451	                bcs L91BD
1591	.9446		7a		ply		                ply                          ; Pop source handle
1592	.9447						L91B3:
1593	.9447		7a		ply		                ply                          ; Restore XY
1594	.9448		fa		plx		                plx
1595	.9449						L91B5:
1596	.9449		68		pla		                pla                          ; Clear 'ACCCON changed', restore ACCCON
1597	.944a		9c dd df	stz $dfdd	                stz hazel.hasACCCONChanged
1598	.944d		8d 34 fe	sta $fe34	                sta ACCCON
1599	.9450		60		rts		                rts

1601	.9451						L91BD:
1602	.9451		7a		ply		                ply                          ; Source was CFS/RFS, jump to exit
1603	.9452		c0 04		cpy #$04	                cpy #$04
1604	.9454		90 f1		bcc $9447	                bcc L91B3
1605	.9456		7a		ply		                ply                          ; Point to first parameter
1606	.9457		8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
1607	.945a		fa		plx		                plx
1608	.945b		8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
1609	.945e		a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
1610	.9460		a0 02		ldy #$02	                ldy #>osfileParameterBlock
1611	.9462		a9 05		lda #$05	                lda #$05                     ; Read info on source file
1612	.9464		20 dd ff	jsr $ffdd	                jsr OSFILE
1613	.9467		ad d8 df	lda $dfd8	                lda hazel.moveDestName+0      ; Get address of dest filename
1614	.946a		8d ed 02	sta $02ed	                sta osfileParameterBlock+OSFILEParameterBlock.fileName+0
1615	.946d		ad d9 df	lda $dfd9	                lda hazel.moveDestName+1      ;  and put in control block
1616	.9470		8d ee 02	sta $02ee	                sta osfileParameterBlock+OSFILEParameterBlock.fileName+1
1617	.9473		a9 f0		lda #$f0	                lda #$F0                     ; Mask out 'public' access bits
1618	.9475		1c fb 02	trb $02fb	                trb osfileParameterBlock+OSFILEParameterBlock.attributes+0
1619	.9478		a9 01		lda #$01	                lda #$01                     ; Write info on dest file
1620	.947a		20 dd ff	jsr $ffdd	                jsr OSFILE
1621	.947d		80 ca		bra $9449	                bra L91B5                    ; Jump to restore ACCCON and exit

1623	.947f						printLineNumber:
1624	.947f		a2 00		ldx #$00	                ldx #$00
1625	.9481		38		sec		                sec
1626	.9482		20 c2 94	jsr $94c2	                jsr adcLineNumberBCDX        ;increment line number LSB
1627	.9485		e8		inx		                inx
1628	.9486		20 c2 94	jsr $94c2	                jsr adcLineNumberBCDX        ;carry into line number MSB
1629	.9489						L91F5:
1630	.9489		38		sec		                sec                          ;printing leading 0s
1631	.948a		ad c4 df	lda $dfc4	                lda hazel.lineNumberBCD+1    ;get line number MSB
1632	.948d		20 a5 94	jsr $94a5	                jsr printPossiblyLeading0s
1633	.9490		ad c3 df	lda $dfc3	                lda hazel.lineNumberBCD+0    ;get line number LSB
1634	.9493		48		pha		                pha                          ;save line number LSB
1635	.9494		08		php		                php                          ;save C
1636							                .if version==350
1638							                .else
1639	.9495		4a		lsr a		                lsr a
1640	.9496		4a		lsr a		                lsr a
1641	.9497		4a		lsr a		                lsr a
1642	.9498		4a		lsr a		                lsr a
1643							                .endif
1644	.9499		28		plp		                plp                          ;restore  C
1645	.949a		20 b0 94	jsr $94b0	                jsr printPossiblyLeading0    ;print line number 3rd digit
1646	.949d		68		pla		                pla                          ;restore line number LSB
1647	.949e		18		clc		                clc                ;always print line number 4th digit
1648	.949f		20 b0 94	jsr $94b0	                jsr printPossiblyLeading0    ;
1649	.94a2		4c 6f a7	jmp $a76f	                jmp printSpace                    ;

1651	.94a5						printPossiblyLeading0s:
1652	.94a5		48		pha		                pha                          ;save value
1653	.94a6		08		php		                php                          ;save C
1654							                .if version==350
1656							                .else
1657	.94a7		4a		lsr a		                lsr a
1658	.94a8		4a		lsr a		                lsr a
1659	.94a9		4a		lsr a		                lsr a
1660	.94aa		4a		lsr a		                lsr a
1661							                .endif
1662	.94ab		28		plp		                plp                          ;restore C
1663	.94ac		20 b0 94	jsr $94b0	                jsr printPossiblyLeading0    ;print 1st digit
1664	.94af		68		pla		                pla                          ;restore value
1665	.94b0						printPossiblyLeading0:
1666	.94b0		29 0f		and #$0f	                and #$0F                     ;get digit to print
1667	.94b2		d0 09		bne $94bd	                bne printNonLeading0         ;always print if non-0
1668	.94b4		90 07		bcc $94bd	                bcc printNonLeading0 ;branch taken if not leading 0
1669	.94b6		a9 20		lda #$20	                lda #$20             ;print space instead of leading 0
1670	.94b8		20 ee ff	jsr $ffee	                jsr OSWRCH
1671	.94bb		38		sec		                sec                ;indicate still in leading 0s state
1672	.94bc		60		rts		                rts

1674	.94bd						printNonLeading0:
1675	.94bd		20 23 ae	jsr $ae23	                jsr printHexDigit            ;print digit
1676	.94c0		18		clc		                clc                          ;no longer in leading 0s state
1677	.94c1		60		rts		                rts                          ;

1679	.94c2						adcLineNumberBCDX:
1680	.94c2		a9 00		lda #$00	                lda #$00
1681	.94c4		f8		sed		                sed
1682	.94c5		7d c3 df	adc $dfc3,x	                adc hazel.lineNumberBCD,x
1683	.94c8		9d c3 df	sta $dfc3,x	                sta hazel.lineNumberBCD,x
1684	.94cb		d8		cld		                cld
1685	.94cc						rts9238:
1686	.94cc		60		rts		                rts

1688							;-------------------------------------------------------------------------

1690	.94cd						L9239:
1691	.94cd		da		phx		                phx
1692	.94ce		48		pha		                pha
1693	.94cf		a2 02		ldx #$02	                ldx #$02
1694	.94d1						L923D:
1695	.94d1		bd f1 02	lda $02f1,x	                lda osfileParameterBlock+4,x
1696	.94d4		20 1a ae	jsr $ae1a	                jsr printHexByte
1697	.94d7		ca		dex		                dex
1698	.94d8		10 f7		bpl $94d1	                bpl L923D
1699	.94da		80 0c		bra $94e8	                bra L9254

1701							;-------------------------------------------------------------------------

1703	.94dc						L9248:
1704	.94dc		da		phx		                phx
1705	.94dd		48		pha		                pha
1706	.94de		a2 fc		ldx #$fc	                ldx #256-4
1707	.94e0						L924C:
1708	.94e0		fe f5 01	inc $01f5,x	                inc osfileParameterBlock+4-(256-4),x
1709	.94e3		d0 03		bne $94e8	                bne L9254
1710	.94e5		e8		inx		                inx
1711	.94e6		d0 f8		bne $94e0	                bne L924C
1712	.94e8						L9254:
1713	.94e8		68		pla		                pla
1714	.94e9		fa		plx		                plx
1715	.94ea		60		rts		                rts

1717	.94eb						L9257:
1718	.94eb		5a		phy		                phy
1719	.94ec		da		phx		                phx
1720	.94ed						L9259:
1721	.94ed		e0 08		cpx #$08	                cpx #$08
1722	.94ef		f0 0a		beq $94fb	                beq L9267
1723	.94f1		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
1724	>94f4		20 20 20 00			                .text "   ",0
1725	.94f8		e8		inx		                inx
1726	.94f9		80 f2		bra $94ed	                bra L9259

1728	.94fb						L9267:
1729	.94fb		fa		plx		                plx
1730	.94fc		20 6f a7	jsr $a76f	                jsr printSpace
1731	.94ff		a0 00		ldy #$00	                ldy #$00
1732	.9501						L926D:
1733	.9501		b9 f5 02	lda $02f5,y	                lda osfileParameterBlock+8,y
1734	.9504		20 ee ff	jsr $ffee	                jsr OSWRCH
1735	.9507		c8		iny		                iny
1736	.9508		ca		dex		                dex
1737	.9509		d0 f6		bne $9501	                bne L926D
1738	.950b		7a		ply		                ply
1739	.950c		4c e7 ff	jmp $ffe7	                jmp OSNEWL

1741							;-------------------------------------------------------------------------

1743							                .if version==320||version==400
1744	=$94cc						osbyte19Done=rts9238
1745							                .include "restore_font.s65"

:8	;******  Processing file: src/restore_font.s65

1							;-------------------------------------------------------------------------
2							;
3							; restore entire font.
4							;
5	.950f						restoreFont32To255:
6	.950f		a2 07		ldx #$07	                ldx #$07                     ;224 chars - 32-255
7							                .cerror *!=restoreFont32ToN
8							                ; fall through to restoreFont32ToN

10							;-------------------------------------------------------------------------
11							;
12							; Restore part of the font, starting from char 32.
13							;
14							; entry:
15							;
16							; X = number of pages of font data to restore - X*32 chars will be
17							; restored
18							;
19	.9511						restoreFont32ToN:
20	.9511		08		php		                php
21	.9512		78		sei		                sei
22	.9513		a9 b9		lda #$b9	                lda #>LB900                ;start at beginning of font
23	.9515		85 f1		sta $f1		                sta $F1
24	.9517		a9 89		lda #$89	                lda #>andy.softCharacterDefinitions ;write to beginning of soft character definitions
25							                .cerror *!=restoreFontPart
26							                ; fall through to restoreFontPart

28							;-------------------------------------------------------------------------
29							;
30							; Restore part of the font.
31							;
32							; entry:
33							;
34							; ?$f1 = MSB of font data
35							;
36							; A = MSB of dest page in ANDY - should be part of the soft character
37							; definitions!
38							;
39							; X = number of pages of font data to restore - X*32 chars will be
40							; restored
41							;
42							; preserves: Y

44	.9519						restoreFontPart:
45	.9519		85 fb		sta $fb		                sta $FB                      ;save MSB of dest
46	.951b		20 a5 e5	jsr $e5a5	                jsr selectTerminalROMAndANDY2
47							                .cwarn *<$9000,format("Code inside ANDY at: $%04x",*) ; following code can't be inside the ANDY region!
48	.951e		5a		phy		                phy                          ;
49	.951f		a0 00		ldy #$00	                ldy #$00                     ;
50	.9521		64 fa		stz $fa		                stz $FA                      ;initialize LSB of src
51	.9523		64 f0		stz $f0		                stz $F0                      ;initialize LSB of dest
52	.9525						-
53	.9525		b1 f0		lda ($f0),y	                lda ($F0),y
54	.9527		91 fa		sta ($fa),y	                sta ($FA),y
55	.9529		c8		iny		                iny
56	.952a		d0 f9		bne $9525	                bne -
57	.952c		e6 f1		inc $f1		                inc $F1
58	.952e		e6 fb		inc $fb		                inc $FB
59	.9530		ca		dex		                dex
60	.9531		d0 f2		bne $9525	                bne -
61	.9533		7a		ply		                ply
62	.9534		28		plp		                plp
63	.9535		4c 9d e5	jmp $e59d	                jmp selectTerminalROM

65							;-------------------------------------------------------------------------

67							                .if version==350
69							                .endif
70	.9538						restoreFont32To126:
71	.9538		a2 03		ldx #$03	                ldx #$03                     ;96 chars - 32-126
72	.953a		80 d5		bra $9511	                bra restoreFont32ToN

74							;-------------------------------------------------------------------------
75							;
76							; OSBYTE 25 (&19) Restore a group of font definitions
77							;
78							; MasRef D.2-28
79							;
80	.953c						osbyte19:
81	.953c		8a		txa		                txa                          ;A=group identifier
82	.953d		f0 d0		beq $950f	                beq restoreFont32To255   ;taken if group 0 - all chars
83							                .if version>=500
85							                .else
86	.953f		c9 08		cmp #$08	                cmp #$08
87							                .endif
88	.9541		b0 89		bcs $94cc	                bcs osbyte19Done
89							                .if version>=500
92							                .endif
93	.9543		08		php		                php
94	.9544		78		sei		                sei
95	.9545		69 b8		adc #$b8	                adc #(>LB900)-1 ;form address of ROM font data for group
96	.9547		85 f1		sta $f1		                sta $F1
97	.9549		8a		txa		                txa
98	.954a		a2 01		ldx #$01	                ldx #$01                   ;copy 1 page, 32 chars
99	.954c		69 88		adc #$88	                adc #(>andy.softCharacterDefinitions)-1 ;get page in ANDY for group
100	.954e		80 c9		bra $9519	                bra restoreFontPart



:4	;******  Return to file: src/terminal.s65

1749							                .endif

1751							;-------------------------------------------------------------------------
1752							;
1753							; Clear 4 bytes in the OSFILE parameter block.
1754							;
1755							; entry:
1756							;
1757							; X = offset of the 4 bytes to clear
1758							;
1759	.9550						clearOSFILEParameterBlockDWORD:
1760	.9550		9e ed 02	stz $02ed,x	                stz osfileParameterBlock+0,x
1761	.9553		9e ee 02	stz $02ee,x	                stz osfileParameterBlock+1,x
1762	.9556		9e ef 02	stz $02ef,x	                stz osfileParameterBlock+2,x
1763	.9559		9e f0 02	stz $02f0,x	                stz osfileParameterBlock+3,x
1764	.955c						rts94A4:
1765	.955c		60		rts		                rts

1767							;-------------------------------------------------------------------------
1768							;
1769							; Read a 32-bit hex value from a string.
1770							;
1771							; entry:
1772							;
1773							; X = offset into osfileParameterBlock to store the value
1774							;
1775							; exit:
1776							;
1777							; C=0 if error
1778							;
1779							; preserves: V
1780							;
1781	.955d						parseHexAddressFromString:
1782	.955d		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
1783	.9560		20 5d 86	jsr $865d	                jsr readHexDigit
1784	.9563		90 23		bcc $9588	                bcc rts92F4
1785	.9565		20 50 95	jsr $9550	                jsr clearOSFILEParameterBlockDWORD
1786	.9568						readDigitsLoop:
1787	.9568		5a		phy		                phy
1788	.9569		2a		rol a		                rol a
1789	.956a		2a		rol a		                rol a
1790	.956b		2a		rol a		                rol a
1791	.956c		2a		rol a		                rol a                        ;put digit in top 4 bits
1792	.956d		a0 04		ldy #$04	                ldy #$04
1793	.956f						shiftIn1DigitLoop:
1794	.956f		2a		rol a		                rol a
1795	.9570		3e ed 02	rol $02ed,x	                rol osfileParameterBlock+0,x
1796	.9573		3e ee 02	rol $02ee,x	                rol osfileParameterBlock+1,x
1797	.9576		3e ef 02	rol $02ef,x	                rol osfileParameterBlock+2,x
1798	.9579		3e f0 02	rol $02f0,x	                rol osfileParameterBlock+3,x
1799	.957c		b0 61		bcs $95df	                bcs badAddressError ;carry out of bit 31 implies too many digits
1800	.957e		88		dey		                dey
1801	.957f		d0 ee		bne $956f	                bne shiftIn1DigitLoop
1802	.9581		7a		ply		                ply
1803	.9582		20 5d 86	jsr $865d	                jsr readHexDigit
1804	.9585		b0 e1		bcs $9568	                bcs readDigitsLoop   ;keep going until hex digits stop
1805	.9587		38		sec		                sec       ;got at least 1 hex digit, so result is good
1806	.9588						rts92F4:
1807	.9588		60		rts		                rts

1809							;-------------------------------------------------------------------------
1810							;
1811							; *GO (<addr>) [MasRef C.5-6]
1812							;
1813	.9589						starGO:
1814	.9589		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
1815	.958c		d0 03		bne $9591	                bne starGOIO             ; Jump to read parameters
1816	.958e		4c 76 86	jmp $8676	                jmp commandLineUI        ; No parameters, enter CLICOM

1818							;-------------------------------------------------------------------------
1819							;
1820							; *GOIO <addr> [MasRef C.5-7]
1821							;
1822	.9591						starGOIO:
1823	.9591		a2 00		ldx #$00	                ldx #$00
1824	.9593		20 ef 95	jsr $95ef	                jsr parseHexAddressFromCommandLine ; Read hex address
1825	.9596		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
1826	.9599		08		php		                php  ; Update &F2/3 to point to any further parameters
1827	.959a		98		tya		                tya
1828	.959b		18		clc		                clc
1829	.959c		65 f2		adc $f2		                adc stringInputBufferAddress+0
1830	.959e		85 f2		sta $f2		                sta stringInputBufferAddress+0
1831	.95a0		90 02		bcc $95a4	                bcc +
1832	.95a2		e6 f3		inc $f3		                inc stringInputBufferAddress+1
1833	.95a4						+
1834	.95a4		a0 00		ldy #$00	                ldy #$00    ; (&F2),y=>parameters, EQ if no parameters
1835	.95a6		28		plp		                plp
1836	.95a7		6c ed 02	jmp ($02ed)	                jmp (osfileParameterBlock+0) ; Jump to address

1838							;-------------------------------------------------------------------------

1840	.95aa						starLOAD:
1841	.95aa		a9 ff		lda #$ff	                lda #fileLoad
1842	.95ac						starCommandThroughOSFILE:
1843	.95ac		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
1844	.95af						L931B:
1845	.95af		86 f2		stx $f2		                stx stringInputBufferAddress+0
1846	.95b1		84 f3		sty $f3		                sty stringInputBufferAddress+1
1847	.95b3		8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
1848	.95b6		8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
1849	.95b9		48		pha		                pha                          ;save OSFILE reason
1850	.95ba		a2 02		ldx #$02	                ldx #OSFILEParameterBlock.load
1851	.95bc		20 50 95	jsr $9550	                jsr clearOSFILEParameterBlockDWORD
1852	.95bf		a2 0a		ldx #$0a	                ldx #OSFILEParameterBlock.length
1853	.95c1		20 50 95	jsr $9550	                jsr clearOSFILEParameterBlockDWORD
1854	.95c4		a0 ff		ldy #$ff	                ldy #$FF
1855	.95c6		8c f3 02	sty $02f3	                sty osfileParameterBlock+OSFILEParameterBlock.exec+0 ;by default, load to file's load address
1856	.95c9		c8		iny		                iny                                                  ;Y=0
1857	.95ca		20 5c f0	jsr $f05c	                jsr gsinitForFilenameParsing
1858	.95cd						L9339:
1859	.95cd		20 6e f0	jsr $f06e	                jsr gsreadEntryPoint
1860	.95d0		90 fb		bcc $95cd	                bcc L9339
1861	.95d2		68		pla		                pla                          ;restore OSFILE reason
1862	.95d3		48		pha		                pha                          ;save OSFILE reason
1863	.95d4		10 50		bpl $9626	                bpl finishStarSAVE                    ;taken if *SAVE
1864	.95d6		a2 02		ldx #$02	                ldx #OSFILEParameterBlock.load
1865	.95d8		20 5d 95	jsr $955d	                jsr parseHexAddressFromString ;parse *LOAD address
1866	.95db		b0 18		bcs $95f5	                bcs doStarLOADWithExplicitAddress ;taken if good address
1867	.95dd		f0 1b		beq $95fa	                beq L9366        ;taken if CR encountered (this is ok)
1868	.95df						badAddressError:
1869	.95df		20 23 b0	jsr $b023	                jsr doFollowingError
1870	>95e2		fc 42 61 64 20 61 64 64		                .text $fc,"Bad address",0
	>95ea		72 65 73 73 00

1872							;-------------------------------------------------------------------------
1873							;
1874							; Parse hex address from command line.
1875							;
1876	.95ef						parseHexAddressFromCommandLine:
1877	.95ef		20 5d 95	jsr $955d	                jsr parseHexAddressFromString ; Read hex address
1878	.95f2		90 eb		bcc $95df	                bcc badAddressError           ; Jump with bad address
1879	.95f4		60		rts		                rts

1881							;-------------------------------------------------------------------------

1883	.95f5						doStarLOADWithExplicitAddress:
1884	.95f5		d0 7f		bne $9676	                bne badCommandError93E2
1885	.95f7		ee f3 02	inc $02f3	                inc osfileParameterBlock+OSFILEParameterBlock.exec+0 ;load to parameter block load address
1886	.95fa						L9366:
1887	.95fa		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
1888	.95fd						callOSFILEWithOSFILEParameterBlock:
1889	.95fd		a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
1890	.95ff		a0 02		ldy #$02	                ldy #>osfileParameterBlock
1891	.9601		68		pla		                pla
1892	.9602		4c dd ff	jmp $ffdd	                jmp OSFILE

1894							;-------------------------------------------------------------------------
1895							;
1896							; *REMOVE [MasRef G.5-9]
1897							;
1898	.9605						starREMOVE:
1899	.9605		8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
1900	.9608		8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
1901							                .if version>=510||version==350
1912							                .endif
1913	.960b		a9 06		lda #$06	                lda #fileDelete
1914	.960d		48		pha		                pha
1915	.960e		80 ed		bra $95fd	                bra callOSFILEWithOSFILEParameterBlock

1917							;-------------------------------------------------------------------------
1918							                .if version<510&&version!=350
1919							;
1920							; *CLOSE [MasRef G.5-3]
1921							;
1922	.9610						starCLOSE:
1923	.9610		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
1924	.9613		d0 61		bne $9676	                bne badCommandError93E2
1925	.9615		a9 00		lda #$00	                lda #$00
1926	.9617		a8		tay		                tay
1927	.9618		6c 1c 02	jmp ($021c)	                jmp (FINDV)                  ;OSFIND A=0 Y=0
1928							                .endif
1929							;-------------------------------------------------------------------------
1930							                .if version<510&&version!=350
1931							;
1932							; *IGNORE [MasRef C.5-7]
1933							;
1934	.961b						starIGNORE:
1935	.961b		d0 05		bne $9622	                bne L938E
1936	.961d		38		sec		                sec
1937	.961e		6e 46 02	ror $0246	                ror noignoreState
1938	.9621		60		rts		                rts

1940	.9622						L938E:
1941	.9622		a9 06		lda #$06	                lda #$06
1942	.9624		80 59		bra $967f	                bra starCommandThroughOSBYTE
1943							                .endif
1944							;-------------------------------------------------------------------------

1946	.9626						finishStarSAVE:
1947	.9626		d0 07		bne $962f	                bne L939B
1948	.9628		a2 0a		ldx #$0a	                ldx #OSFILEParameterBlock.saveStart
1949	.962a		20 5d 95	jsr $955d	                jsr parseHexAddressFromString
1950	.962d		90 47		bcc $9676	                bcc badCommandError93E2
1951	.962f						L939B:
1952	.962f		b8		clv		                clv
1953	.9630		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
1954	.9632		c9 2b		cmp #$2b	                cmp #'+'
1955	.9634		d0 04		bne $963a	                bne L93A6                    ;taken if "*SAVE START END..."
1956	.9636		2c 5e e3	bit $e35e	                bit valueFF              ;V=1
1957	.9639		c8		iny		                iny
1958	.963a						L93A6:
1959	.963a		a2 0e		ldx #$0e	                ldx #OSFILEParameterBlock.saveEnd
1960	.963c		20 5d 95	jsr $955d	                jsr parseHexAddressFromString
1961	.963f		90 35		bcc $9676	                bcc badCommandError93E2
1962	.9641		08		php		                php
1963	.9642		50 0f		bvc $9653	                bvc L93BF                    ;taken if "*SAVE START END"

1965							                ; Get the save end address.
1966	.9644		a2 fc		ldx #$fc	                ldx #256-4
1967	.9646		18		clc		                clc
1968	.9647						-
1969							                ; TODO - not sure why the @w notation is required here?
1970	.9647		bd fb 01	lda $01fb,x	                lda@w osfileParameterBlock+OSFILEParameterBlock.saveStart-(256-4),x
1971	.964a		7d ff 01	adc $01ff,x	                adc@w osfileParameterBlock+OSFILEParameterBlock.saveEnd-(256-4),x
1972	.964d		9d ff 01	sta $01ff,x	                sta@w osfileParameterBlock+OSFILEParameterBlock.saveEnd-(256-4),x
1973	.9650		e8		inx		                inx
1974	.9651		d0 f4		bne $9647	                bne -
1975	.9653						L93BF:

1977							                ; Initialize load and exec addresses to save start
1978							                ; address.
1979	.9653		a2 03		ldx #$03	                ldx #$03
1980	.9655						-
1981	.9655		bd f7 02	lda $02f7,x	                lda@w osfileParameterBlock+OSFILEParameterBlock.saveStart,x
1982	.9658		9d f3 02	sta $02f3,x	                sta@w osfileParameterBlock+OSFILEParameterBlock.exec,x
1983	.965b		9d ef 02	sta $02ef,x	                sta@w osfileParameterBlock+OSFILEParameterBlock.load,x
1984	.965e		ca		dex		                dex
1985	.965f		10 f4		bpl $9655	                bpl -

1987	.9661		28		plp		                plp
1988	.9662		f0 96		beq $95fa	                beq L9366

1990	.9664		a2 06		ldx #$06	                ldx #OSFILEParameterBlock.exec
1991	.9666		20 5d 95	jsr $955d	                jsr parseHexAddressFromString
1992	.9669		90 0b		bcc $9676	                bcc badCommandError93E2
1993	.966b		f0 8d		beq $95fa	                beq L9366

1995	.966d		a2 02		ldx #$02	                ldx #OSFILEParameterBlock.load
1996	.966f		20 5d 95	jsr $955d	                jsr parseHexAddressFromString
1997	.9672		90 02		bcc $9676	                bcc badCommandError93E2
1998	.9674		f0 84		beq $95fa	                beq L9366

2000	.9676						badCommandError93E2:
2001	.9676		4c bd fa	jmp $fabd	                jmp badCommandError

2003							;-------------------------------------------------------------------------

2005	.9679						starFX:
2006	.9679		20 fb 85	jsr $85fb	                jsr parseNumberFromString
2007	.967c		90 f8		bcc $9676	                bcc badCommandError93E2
2008	.967e		8a		txa		                txa
2009	.967f						starCommandThroughOSBYTE:
2010	.967f		08		php		                php
2011	.9680		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
2012	.9683		28		plp		                plp
2013	.9684		48		pha		                pha
2014	.9685		64 e5		stz $e5		                stz $E5
2015	.9687		64 e4		stz $e4		                stz $E4
2016	.9689		20 f7 f0	jsr $f0f7	                jsr LF308
2017	.968c		f0 18		beq $96a6	                beq L9412
2018	.968e		20 fb 85	jsr $85fb	                jsr parseNumberFromString
2019	.9691		90 e3		bcc $9676	                bcc badCommandError93E2
2020	.9693		86 e5		stx $e5		                stx $E5
2021	.9695		20 f9 f0	jsr $f0f9	                jsr LF30A
2022	.9698		f0 0c		beq $96a6	                beq L9412
2023	.969a		20 fb 85	jsr $85fb	                jsr parseNumberFromString
2024	.969d		90 d7		bcc $9676	                bcc badCommandError93E2
2025	.969f		86 e4		stx $e4		                stx $E4
2026	.96a1		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
2027	.96a4						L9625:
2028	.96a4		d0 d0		bne $9676	                bne badCommandError93E2
2029	.96a6						L9412:
2030	.96a6		a4 e4		ldy $e4		                ldy $E4
2031	.96a8		a6 e5		ldx $e5		                ldx $E5
2032	.96aa		68		pla		                pla
2033	.96ab		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
2034	.96ae		20 f4 ff	jsr $fff4	                jsr OSBYTE
2035	.96b1		70 c3		bvs $9676	                bvs badCommandError93E2
2036	.96b3						rts941F:
2037	.96b3		60		rts		                rts

2039							;-------------------------------------------------------------------------

2041	.96b4						starSPOOLON:
2042	.96b4		38		sec		                sec
2043	.96b5		80 10		bra $96c7	                bra starSPOOL

2045							;-------------------------------------------------------------------------

2047							                .if version>=510||version==350
2052							                .endif

2054							;-------------------------------------------------------------------------

2056	.96b7						osbyte77:
2057	.96b7		a2 10		ldx #$10	                ldx #romServiceCallSpoolExecClosureWarning
2058	.96b9		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
2059	.96bc		f0 f5		beq $96b3	                beq rts941F
2060	.96be		20 43 ac	jsr $ac43	                jsr LA58B
2061	.96c1		ad 57 02	lda $0257	                lda spoolFileHandle
2062	.96c4		20 23 ac	jsr $ac23	                jsr LA56B
2063	.96c7						starSPOOL:
2064	.96c7		08		php		                php
2065	.96c8		5a		phy		                phy
2066	.96c9		ac 57 02	ldy $0257	                ldy spoolFileHandle
2067	.96cc		8d 57 02	sta $0257	                sta spoolFileHandle
2068	.96cf		f0 03		beq $96d4	                beq L9440
2069	.96d1		20 ce ff	jsr $ffce	                jsr OSFIND
2070	.96d4						L9440:
2071	.96d4		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
2072	.96d7		7a		ply		                ply
2073	.96d8		28		plp		                plp
2074	.96d9		f0 d8		beq $96b3	                beq rts941F
2075	.96db		a9 80		lda #$80	                lda #$80
2076	.96dd		90 02		bcc $96e1	                bcc L944D
2077	.96df		a9 c0		lda #$c0	                lda #$C0
2078	.96e1						L944D:
2079	.96e1		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
2080	.96e4		20 ce ff	jsr $ffce	                jsr OSFIND
2081	.96e7		a8		tay		                tay
2082	.96e8		f0 8c		beq $9676	                beq badCommandError93E2
2083	.96ea		8d 57 02	sta $0257	                sta spoolFileHandle
2084	.96ed		a8		tay		                tay
2085	.96ee						setPTRToEOF:
2086	.96ee		a9 02		lda #$02	                lda #argsFileGetEXT
2087	.96f0		20 f5 96	jsr $96f5	                jsr callOSARGSWithBuffer
2088	.96f3						setFilePointerFromOSARGSBuffer:
2089	.96f3		a9 01		lda #$01	                lda #argsFileSetPTR
2090	.96f5						callOSARGSWithBuffer:
2091	.96f5		a2 a8		ldx #$a8	                ldx #osargsBuffer
2092	.96f7		4c da ff	jmp $ffda	                jmp OSARGS

2094							;-------------------------------------------------------------------------

2096							                .if version<510&&version!=350
2097	.96fa						starSHADOW:
2098	.96fa		a9 72		lda #$72	                lda #$72
2099	.96fc		80 81		bra $967f	                bra starCommandThroughOSBYTE
2100							                .endif

2102							;-------------------------------------------------------------------------

2104							                .if version>=510||version==350
2111							                .endif

2113							;-------------------------------------------------------------------------

2115							                .if version>=510||version==350
2125							                .endif

2127							;-------------------------------------------------------------------------
2128							;
2129	.96fe						starDELETE:
2130	.96fe		20 05 96	jsr $9605	                jsr starREMOVE
2131	.9701		a8		tay		                tay
2132	.9702		d0 af		bne $96b3	                bne rts941F
2133	.9704		4c 05 ac	jmp $ac05	                jmp notFoundError

2135							;-------------------------------------------------------------------------

2137							                .if version==350
2141							                .endif

2143							;-------------------------------------------------------------------------

2145							                .if version==350
2160							                .endif

2162							;-------------------------------------------------------------------------

2164							                .if version>=510||version==350
2191							                .endif

2193							;-------------------------------------------------------------------------

2195							                .if version<510&&version!=350
2196	.9707						parseSoftKeyNumberFromCommandLine:
2197	.9707		20 fb 85	jsr $85fb	                jsr parseNumberFromString
2198	.970a		90 04		bcc $9710	                bcc badKeyError
2199	.970c		e0 10		cpx #$10	                cpx #softKeyCount
2200	.970e		90 a3		bcc $96b3	                bcc rts941F
2201	.9710						badKeyError:
2202	.9710		20 23 b0	jsr $b023	                jsr doFollowingError
2203	>9713		fb				                .byte $FB
2204	>9714		42 61 64 20 6b 65 79		                .text "Bad key"
2205	>971b		00				                .byte 0
2206							                .endif

2208							;-------------------------------------------------------------------------
2209							;
2210							; [MasRef C.5-11]
2211							;

2213							                .if version<510&&version!=350
2214	.971c						starSHOW:
2215	.971c		20 07 97	jsr $9707	                jsr parseSoftKeyNumberFromCommandLine
2216	.971f		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
2217	.9722		d0 ec		bne $9710	                bne badKeyError
2220							                .endif
2221	.9724		a9 22		lda #$22	                lda #'"'
2222	.9726		20 ee ff	jsr $ffee	                jsr OSWRCH
2223	.9729		a5 f4		lda $f4		                lda $F4
2224	.972b		48		pha		                pha
2225	.972c		20 a5 e5	jsr $e5a5	                jsr selectTerminalROMAndANDY2
2226							                .cwarn *<$9000,format("Code inside ANDY at: $%04x",*)
2227	.972f		bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2228	.9732		85 f2		sta $f2		                sta stringInputBufferAddress+0
2229	.9734		bd 11 80	lda $8011,x	                lda andy.softKeys.stringMSBs,x
2230	.9737		85 f3		sta $f3		                sta stringInputBufferAddress+1
2231							                .if version<510&&version!=350
2232	.9739		a4 e6		ldy $e6		                ldy $E6
2236							                .endif
2237	.973b		20 e0 e9	jsr $e9e0	                jsr getSoftKeyStringLength
2238	.973e		a8		tay		                tay                          ;Y = string length
2239	.973f		f0 0e		beq $974f	                beq starSHOWDone                    ;done if length=0
2240	.9741						-
2241	.9741		b2 f2		lda ($f2)	                lda (stringInputBufferAddress)
2242	.9743		20 9a 98	jsr $989a	                jsr printGSREADChar
2243	.9746		e6 f2		inc $f2		                inc stringInputBufferAddress+0
2244	.9748		d0 02		bne $974c	                bne +
2245	.974a		e6 f3		inc $f3		                inc stringInputBufferAddress+1
2246	.974c						+
2247	.974c		88		dey		                dey
2248	.974d		d0 f2		bne $9741	                bne -
2249	.974f						starSHOWDone:
2250	.974f		68		pla		                pla
2251	.9750		20 9f e5	jsr $e59f	                jsr selectROMA
2252	.9753		a9 22		lda #$22	                lda #'"'
2253	.9755		20 ee ff	jsr $ffee	                jsr OSWRCH
2254	.9758		4c e7 ff	jmp $ffe7	                jmp OSNEWL

2256							;-------------------------------------------------------------------------

2258							                .if version>=510
2269							                .endif

2271							;-------------------------------------------------------------------------
2272							;
2273							; [MasRef C.5-8]
2274							;
2275	.975b						starKEY: .proc
2276	.975b		20 07 97	jsr $9707	                jsr parseSoftKeyNumberFromCommandLine
2277	.975e		a5 f4		lda $f4		                lda $F4
2278	.9760		48		pha		                pha
2279	.9761		20 8c e5	jsr $e58c	                jsr selectTerminalROMAndANDY
2280	.9764		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
2281	.9767		64 b0		stz $b0		                stz starKEYWorkspace.newStringLength
2282	.9769		f0 15		beq $9780	                beq commandLineTailEmpty
2283	.976b		a2 00		ldx #$00	                ldx #$00
2284	.976d		38		sec		                sec
2285	.976e		20 5d f0	jsr $f05d	                jsr gsinitEntryPoint
2286	.9771						-
2287	.9771		20 6e f0	jsr $f06e	                jsr gsreadEntryPoint
2288	.9774		b0 06		bcs $977c	                bcs bneBadKeyError
2289	.9776		9d 00 dc	sta $dc00,x	                sta hazel.commandLine,x
2290	.9779		e8		inx		                inx
2291	.977a		80 f5		bra $9771	                bra -

2293	.977c						bneBadKeyError:
2294							                .if version==350
2296							                .else
2297	.977c		d0 92		bne $9710	                bne badKeyError
2298							                .endif
2299	.977e		86 b0		stx $b0		                stx starKEYWorkspace.newStringLength
2300	.9780						commandLineTailEmpty:
2301	.9780		a4 e6		ldy $e6		                ldy $E6                        ;Y = soft key number
2302	.9782		20 e0 e9	jsr $e9e0	                jsr getSoftKeyStringLength
2303	.9785		85 b5		sta $b5		                sta starKEYWorkspace.counter+0
2304	.9787		38		sec		                sec
2305	.9788		e5 b0		sbc $b0		                sbc starKEYWorkspace.newStringLength ;A=existing len-new len
2306	.978a		b0 16		bcs $97a2	                bcs newStringWillFit            ;taken if new string shorter, meaning it'll definitely fit

2308	.978c		49 ff		eor #$ff	                eor #$FF
2309	.978e		69 01		adc #$01	                adc #$01                     ;A=new len-existing len
2310	.9790		6d 10 80	adc $8010	                adc andy.softKeys.endLSB
2311	.9793		aa		tax		                tax
2312	.9794		ad 21 80	lda $8021	                lda andy.softKeys.endMSB
2313	.9797		69 00		adc #$00	                adc #$00
2314	.9799		c9 84		cmp #$84	                cmp #>(andy.softKeys.end)
2315	.979b		90 05		bcc $97a2	                bcc newStringWillFit

2317							                ; Produce slightly cryptic "Bad key" if string won't
2318							                ; fit.
2319	.979d		d0 dd		bne $977c	                bne bneBadKeyError
2320	.979f		8a		txa		                txa
2321	.97a0		d0 da		bne $977c	                bne bneBadKeyError
2322	.97a2						newStringWillFit:
2323	.97a2		ad 68 02	lda $0268	                lda softKeyStringLength
2324	.97a5		f0 32		beq $97d9	                beq storeNewString          ;taken if new string empty
2325	.97a7		ad c9 02	lda $02c9	                lda currentSoftKey
2326	.97aa		c5 e6		cmp $e6		                cmp $E6
2327	.97ac		90 2b		bcc $97d9	                bcc storeNewString ;taken if current soft key<key - expansion will not need to relocate
2328	.97ae		d0 0f		bne $97bf	                bne relocateCurrentSoftKeyExpansion ;taken if current soft key>key - expansion must relocate
2329	.97b0		20 23 b0	jsr $b023	                jsr doFollowingError
2330	>97b3		fa 4b 65 79 20 69 6e 20		                .text $fa,"Key in use",0
	>97bb		75 73 65 00
2331	.97bf						relocateCurrentSoftKeyExpansion:
2332	.97bf		64 b2		stz $b2		                stz starKEYWorkspace.destPtr+1
2333	.97c1		38		sec		                sec
2334	.97c2		a5 b0		lda $b0		                lda starKEYWorkspace.newStringLength
2335	.97c4		e5 b5		sbc $b5		                sbc starKEYWorkspace.counter+0
2336	.97c6		85 b1		sta $b1		                sta starKEYWorkspace.destPtr+0
2337	.97c8		b0 02		bcs $97cc	                bcs +
2338	.97ca		c6 b2		dec $b2		                dec starKEYWorkspace.destPtr+1
2339	.97cc						+
2340	.97cc		18		clc		                clc
2341	.97cd		a5 f8		lda $f8		                lda softKeyExpansionPtr+0
2342	.97cf		65 b1		adc $b1		                adc starKEYWorkspace.destPtr+0
2343	.97d1		85 f8		sta $f8		                sta softKeyExpansionPtr+0
2344	.97d3		a5 f9		lda $f9		                lda softKeyExpansionPtr+1
2345	.97d5		65 b2		adc $b2		                adc starKEYWorkspace.destPtr+1
2346	.97d7		85 f9		sta $f9		                sta softKeyExpansionPtr+1
2347	.97d9						storeNewString:
2348	.97d9		ce 84 02	dec $0284	                dec softKeyConsistencyFlag   ;mark soft keys inconsistent
2349	.97dc		a6 e6		ldx $e6		                ldx $E6                      ;X=key number
2350	.97de		a5 b5		lda $b5		                lda starKEYWorkspace.counter+0
2351	.97e0		f0 45		beq $9827	                beq makeSpaceForNewString ;taken if no existing string for this soft key

2353							                ; delete existing string
2354	.97e2		bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2355	.97e5		85 b1		sta $b1		                sta starKEYWorkspace.destPtr+0
2356	.97e7		bd 11 80	lda $8011,x	                lda andy.softKeys.stringMSBs,x
2357	.97ea		85 b2		sta $b2		                sta starKEYWorkspace.destPtr+1
2358	.97ec		bd 01 80	lda $8001,x	                lda andy.softKeys.stringLSBs+1,x
2359	.97ef		85 b3		sta $b3		                sta starKEYWorkspace.srcPtr+0
2360	.97f1		bd 12 80	lda $8012,x	                lda andy.softKeys.stringMSBs+1,x
2361	.97f4		85 b4		sta $b4		                sta starKEYWorkspace.srcPtr+1
2362	.97f6						deleteExistingStringLoop:
2363							                ; copy byte (with postincrement)
2364	.97f6		b2 b3		lda ($b3)	                lda (starKEYWorkspace.srcPtr)
2365	.97f8		92 b1		sta ($b1)	                sta (starKEYWorkspace.destPtr)

2367							                ; increment destPtr
2368	.97fa		e6 b1		inc $b1		                inc starKEYWorkspace.destPtr+0
2369	.97fc		d0 02		bne $9800	                bne +
2370	.97fe		e6 b2		inc $b2		                inc starKEYWorkspace.destPtr+1
2371	.9800						+

2373							                ; increment srcPtr
2374	.9800		e6 b3		inc $b3		                inc starKEYWorkspace.srcPtr+0
2375	.9802		d0 02		bne $9806	                bne +
2376	.9804		e6 b4		inc $b4		                inc starKEYWorkspace.srcPtr+1
2377	.9806						+

2379							                ; keep copying until end of buffer reached.
2380	.9806		a5 b3		lda $b3		                lda starKEYWorkspace.srcPtr+0
2381	.9808		cd 10 80	cmp $8010	                cmp andy.softKeys.endLSB
2382	.980b		a5 b4		lda $b4		                lda starKEYWorkspace.srcPtr+1
2383	.980d		ed 21 80	sbc $8021	                sbc andy.softKeys.endMSB
2384	.9810		90 e4		bcc $97f6	                bcc deleteExistingStringLoop

2386							                ; update following strings' start addresses, which all
2387							                ; move down by the old string's length.
2388	.9812						updateAddressesLoop:
2389	.9812		e8		inx		                inx
2390	.9813		e0 11		cpx #$11	                cpx #softKeyCount+1
2391	.9815		b0 10		bcs $9827	                bcs makeSpaceForNewString
2392	.9817		38		sec		                sec
2393	.9818		bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2394	.981b		e5 b5		sbc $b5		                sbc starKEYWorkspace.counter+0
2395	.981d		9d 00 80	sta $8000,x	                sta andy.softKeys.stringLSBs,x
2396	.9820		b0 f0		bcs $9812	                bcs updateAddressesLoop
2397	.9822		de 11 80	dec $8011,x	                dec andy.softKeys.stringMSBs,x
2398	.9825		80 eb		bra $9812	                bra updateAddressesLoop

2400	.9827						makeSpaceForNewString:
2401	.9827		a6 e6		ldx $e6		                ldx $E6
2402	.9829		a5 b0		lda $b0		                lda starKEYWorkspace.newStringLength
2403	.982b		f0 66		beq $9893	                beq done
2404	.982d		ad 10 80	lda $8010	                lda andy.softKeys.endLSB
2405	.9830		85 b3		sta $b3		                sta starKEYWorkspace.srcPtr+0
2406	.9832		18		clc		                clc
2407	.9833		65 b0		adc $b0		                adc starKEYWorkspace.newStringLength
2408	.9835		85 b1		sta $b1		                sta starKEYWorkspace.destPtr+0 ;new end ptr LSB
2409	.9837		ad 21 80	lda $8021	                lda andy.softKeys.endMSB
2410	.983a		85 b4		sta $b4		                sta starKEYWorkspace.srcPtr+1
2411	.983c		69 00		adc #$00	                adc #$00
2412	.983e		85 b2		sta $b2		                sta starKEYWorkspace.destPtr+1 ;new end ptr MSB
2413	.9840		a5 b3		lda $b3		                lda starKEYWorkspace.srcPtr+0
2414	.9842		38		sec		                sec
2415	.9843		fd 00 80	sbc $8000,x	                sbc andy.softKeys.stringLSBs,x
2416	.9846		85 b5		sta $b5		                sta starKEYWorkspace.counter+0
2417	.9848		a5 b4		lda $b4		                lda starKEYWorkspace.srcPtr+1
2418	.984a		fd 11 80	sbc $8011,x	                sbc andy.softKeys.stringMSBs,x
2419	.984d		85 b6		sta $b6		                sta starKEYWorkspace.counter+1
2420	.984f						makeSpaceForNewStringLoop:
2421							                ; loop while counter>0
2422	.984f		a5 b5		lda $b5		                lda starKEYWorkspace.counter+0
2423	.9851		05 b6		ora $b6		                ora starKEYWorkspace.counter+1
2424	.9853		f0 1e		beq $9873	                beq updateAddressesLoop2

2426							                ; decrement destPtr
2427	.9855		a5 b1		lda $b1		                lda starKEYWorkspace.destPtr+0
2428	.9857		d0 02		bne $985b	                bne +
2429	.9859		c6 b2		dec $b2		                dec starKEYWorkspace.destPtr+1
2430	.985b						+
2431	.985b		c6 b1		dec $b1		                dec starKEYWorkspace.destPtr+0

2433							                ; decrement srcPtr
2434	.985d		a5 b3		lda $b3		                lda starKEYWorkspace.srcPtr+0
2435	.985f		d0 02		bne $9863	                bne +
2436	.9861		c6 b4		dec $b4		                dec starKEYWorkspace.srcPtr+1
2437	.9863						+
2438	.9863		c6 b3		dec $b3		                dec starKEYWorkspace.srcPtr+0

2440							                ; copy byte (with predecrement)
2441	.9865		b2 b3		lda ($b3)	                lda (starKEYWorkspace.srcPtr)
2442	.9867		92 b1		sta ($b1)	                sta (starKEYWorkspace.destPtr)

2444							                ; decrement counter
2445	.9869		a5 b5		lda $b5		                lda starKEYWorkspace.counter+0
2446	.986b		d0 02		bne $986f	                bne +
2447	.986d		c6 b6		dec $b6		                dec starKEYWorkspace.counter+1
2448	.986f						+
2449	.986f		c6 b5		dec $b5		                dec starKEYWorkspace.counter+0

2451	.9871		80 dc		bra $984f	                bra makeSpaceForNewStringLoop

2453							                ; update following strings' start addresses, which all
2454							                ; move up by the new string's length.
2455	.9873						updateAddressesLoop2:
2456	.9873		e8		inx		                inx
2457	.9874		e0 11		cpx #$11	                cpx #softKeyCount+1
2458	.9876		b0 0f		bcs $9887	                bcs copyNewString
2459	.9878		bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2460	.987b		65 b0		adc $b0		                adc starKEYWorkspace.newStringLength
2461	.987d		9d 00 80	sta $8000,x	                sta andy.softKeys.stringLSBs,x
2462	.9880		90 f1		bcc $9873	                bcc updateAddressesLoop2
2463	.9882		fe 11 80	inc $8011,x	                inc andy.softKeys.stringMSBs,x
2464	.9885		80 ec		bra $9873	                bra updateAddressesLoop2

2466	.9887						copyNewString:
2467	.9887		a0 00		ldy #$00	                ldy #$00
2468	.9889						copyNewStringLoop:
2469	.9889		b9 00 dc	lda $dc00,y	                lda hazel.commandLine,y
2470	.988c		91 b3		sta ($b3),y	                sta (starKEYWorkspace.srcPtr),y
2471	.988e		c8		iny		                iny
2472	.988f		c6 b0		dec $b0		                dec starKEYWorkspace.newStringLength
2473	.9891		d0 f6		bne $9889	                bne copyNewStringLoop
2474	.9893						done:
2475	.9893		ee 84 02	inc $0284	                inc softKeyConsistencyFlag   ;mark soft keys consistent
2476	.9896		68		pla		                pla
2477	.9897		4c 9f e5	jmp $e59f	                jmp selectROMA
2478							                .endproc

2480							;-------------------------------------------------------------------------
2481							;
2482							; Print char, printing control codes using the string reader escape
2483							; syntax. [MasRef C.5-8]
2484							;
2485	.989a						printGSREADChar: .proc
2486	.989a		aa		tax		                tax                          ;X=char
2487	.989b		30 28		bmi $98c5	                bmi printHighBitChar
2488	.989d		c9 20		cmp #$20	                cmp #$20
2489	.989f		90 1f		bcc $98c0	                bcc printControlChar
2490	.98a1		e8		inx		                inx
2491	.98a2		30 0f		bmi $98b3	                bmi vdu127
2492	.98a4		ca		dex		                dex                          ;restore old char
2493	.98a5		c9 22		cmp #$22	                cmp #'"'
2494	.98a7		f0 11		beq $98ba	                beq printEscapedX
2495	.98a9		c9 7c		cmp #$7c	                cmp #'|'
2496	.98ab		d0 03		bne $98b0	                bne printA
2497							                ; print "||"
2498	.98ad		20 ee ff	jsr $ffee	                jsr OSWRCH
2499	.98b0						printA:
2500	.98b0		4c ee ff	jmp $ffee	                jmp OSWRCH

2502	.98b3						vdu127:
2503							                ; print "|?"
2504	.98b3		20 d0 98	jsr $98d0	                jsr printEscapeChar
2505	.98b6		a9 3f		lda #$3f	                lda #'?'
2506	.98b8		80 f6		bra $98b0	                bra printA

2508	.98ba						printEscapedX:
2509	.98ba		20 d0 98	jsr $98d0	                jsr printEscapeChar
2510	.98bd		8a		txa		                txa
2511	.98be		80 f0		bra $98b0	                bra printA

2513	.98c0						printControlChar:
2514	.98c0		09 40		ora #$40	                ora #$40
2515	.98c2		aa		tax		                tax
2516	.98c3		80 f5		bra $98ba	                bra printEscapedX

2518	.98c5						printHighBitChar:
2519	.98c5		48		pha		                pha
2520	.98c6		a2 21		ldx #$21	                ldx #'!'
2521	.98c8		20 ba 98	jsr $98ba	                jsr printEscapedX
2522	.98cb		68		pla		                pla
2523	.98cc		29 7f		and #$7f	                and #$7F
2524	.98ce		80 ca		bra $989a	                bra printGSREADChar

2526	.98d0						printEscapeChar:
2527	.98d0		a9 7c		lda #$7c	                lda #'|'
2528	.98d2		80 dc		bra $98b0	                bra printA
2529							                .endproc

2531							;-------------------------------------------------------------------------

2533							                .if version!=350
2534							                .include "rtc.s65"

:9	;******  Processing file: src/rtc.s65

1							                .if version<500
2							; Day string not matched
3							; ----------------------
4	.98d4						nextDayString:
5	.98d4		68		pla		                pla                          ; Drop number of characters matched
6	.98d5		68		pla		                pla                          ; Get offset to string table
7	.98d6		7a		ply		                ply                          ; Get start of supplied string
8	.98d7		18		clc		                clc                          ; Step to next string table entry
9	.98d8		69 04		adc #$04	                adc #$04
10	.98da		c9 1c		cmp #$1c	                cmp #size(dayOfWeekStrings) ; If not checked 28/4=7 entries, keep looking
11	.98dc		90 1c		bcc $98fa	                bcc checkDayString
12	.98de		60		rts		                rts                          ; Otherwise exit silently

14							; Month string not matched
15							; ------------------------
16	.98df						nextMonthString:
17	.98df		68		pla		                pla                          ; Drop number of characters matched
18	.98e0		68		pla		                pla                          ; Get offset to string table
19	.98e1		7a		ply		                ply                          ; Get start of supplied string
20	.98e2		18		clc		                clc                          ; Step to next string table entry
21	.98e3		69 04		adc #$04	                adc #$04
22	.98e5		c9 30		cmp #$30	                cmp #size(monthStrings) ; If not checked 48/4=12 entries, keep looking
23	.98e7		90 43		bcc $992c	                bcc checkMonthString
24	.98e9						rts9655:
25	.98e9		60		rts		                rts                          ; Otherwise exit silently

27							;-------------------------------------------------------------------------
28							;
29							; OSWORD 15 (&0F) Write CMOS clock [MasRef D.3-24]
30							;
31	.98ea						osword0F:
32	.98ea		9c ed 02	stz $02ed	                stz osfileParameterBlock     ;got no time, got no date
33	.98ed		49 0f		eor #$0f	                eor #15                     ; len=15, set date
34	.98ef		f0 08		beq $98f9	                beq setDate
35	.98f1		49 07		eor #$07	                eor #15^8
36	.98f3		f0 76		beq $996b	                beq setTime
37	.98f5		49 10		eor #$10	                eor #(15^8)^23
38	.98f7		d0 f0		bne $98e9	                bne rts9655

40							; Set date and set date+time
41							; --------------------------
42							; (&F0),1=>"Day,00 Mon 0000"
43							; (&F0),1=>"Day,00 Mon 0000.00:00:00"
44							; A=0, Y=0
45	.98f9						setDate:
46	.98f9		c8		iny		                iny                          ; Point to supplied data
47							; Translate day string into day number
48	.98fa						checkDayString:
49	.98fa		5a		phy		                phy                          ; Push pointer to data string
50	.98fb		48		pha		                pha                          ; Push offset to match strings
51	.98fc		aa		tax		                tax                          ; X=>match strings
52	.98fd		a9 03		lda #$03	                lda #$03                     ; A=3 characters to match
53	.98ff						checkDayStringLoop:
54	.98ff		48		pha		                pha                          ; Save number of characters to match
55	.9900		b1 f0		lda ($f0),y	                lda (originalX),y      ; Get character from string
56	.9902		5d fc 99	eor $99fc,x	                eor dayOfWeekStrings,x ; Compare with day string table
57	.9905		29 df		and #$df	                and #$DF                     ; Force to upper case
58	.9907		d0 cb		bne $98d4	                bne nextDayString  ; No match step to check next entry
59	.9909		e8		inx		                inx                          ; Step to next character to match
60	.990a		c8		iny		                iny                          ; Step to next data character
61	.990b		68		pla		                pla                          ; Get character count back
62	.990c		3a		dec a		                dec a                        ; Decrement and loop until 3 characters matched
63	.990d		d0 f0		bne $98ff	                bne checkDayStringLoop
64	.990f		bd fc 99	lda $99fc,x	                lda dayOfWeekStrings,x ; Get translation byte from string table
65	.9912		8d f4 02	sta $02f4	                sta osfileParameterBlock+1+RTC.dayOfWeek ; Store it in workspace
66							; Translates Sun,Mon,Tue,etc to &01,&02,&03,etc
67	.9915		fa		plx		                plx                          ; Drop char count and table offset
68	.9916		fa		plx		                plx
69	.9917		b1 f0		lda ($f0),y	                lda ($F0),y                  ; Get next character
70	.9919		c9 2c		cmp #$2c	                cmp #','                     ; Not followed by a comma, so exit silently
71	.991b		d0 cc		bne $98e9	                bne rts9655
72	.991d		a2 07		ldx #$07	                ldx #$07                     ; Get day of month
73	.991f		20 c4 99	jsr $99c4	                jsr readDecimalBCDByte
74	.9922		90 c5		bcc $98e9	                bcc rts9655                    ; Bad number, exit silently
75	.9924		c8		iny		                iny                          ; Get next character
76	.9925		b1 f0		lda ($f0),y	                lda ($F0),y
77	.9927		49 20		eor #$20	                eor #' '                     ; Not space, exit silently
78	.9929		d0 be		bne $98e9	                bne rts9655
79	.992b		c8		iny		                iny                          ; Step to first character of month
80							; Translate month string into month number
81							; This could use the same code as the Day translation
82	.992c						checkMonthString:
83	.992c		5a		phy		                phy                          ; Push pointer to data string
84	.992d		48		pha		                pha                          ; Push offset to match strings
85	.992e		aa		tax		                tax                          ; X=>match strings
86	.992f		a9 03		lda #$03	                lda #$03                     ; A=3 characters to match
87	.9931						checkMonthStringLoop:
88	.9931		48		pha		                pha
89	.9932		b1 f0		lda ($f0),y	                lda (originalX),y
90	.9934		5d 18 9a	eor $9a18,x	                eor monthStrings,x
91	.9937		29 df		and #$df	                and #$DF
92	.9939		d0 a4		bne $98df	                bne nextMonthString
93	.993b		e8		inx		                inx
94	.993c		c8		iny		                iny
95	.993d		68		pla		                pla
96	.993e		3a		dec a		                dec a
97	.993f		d0 f0		bne $9931	                bne checkMonthStringLoop
98	.9941		bd 18 9a	lda $9a18,x	                lda monthStrings,x
99	.9944		8d f6 02	sta $02f6	                sta osfileParameterBlock+1+RTC.month
100							; Translates Jan,Feb,Mar,etc to &01,&02,&03,etc..&09,&10,&11,&12
101	.9947		fa		plx		                plx                          ; Drop char count and table offset
102	.9948		fa		plx		                plx
103	.9949		b1 f0		lda ($f0),y	                lda ($F0),y                  ; Get next character
104	.994b		c9 20		cmp #$20	                cmp #' '                     ; Not followed by space, exit silently
105	.994d		d0 9a		bne $98e9	                bne rts9655
106	.994f		a2 09		ldx #$09	                ldx #RTC.year
107	.9951		20 c4 99	jsr $99c4	                jsr readDecimalBCDByte
108	.9954		90 93		bcc $98e9	                bcc rts9655                    ; Bad number, exit silently
109	.9956		20 c4 99	jsr $99c4	                jsr readDecimalBCDByte                    ; Get year number
110	.9959		90 8e		bcc $98e9	                bcc rts9655                    ; Bad number, exit silently
111	.995b		6e ed 02	ror $02ed	                ror osfileParameterBlock+0     ;got date
112	.995e		b2 f0		lda ($f0)	                lda (originalX)        ; Get data length
113	.9960		c9 0f		cmp #$0f	                cmp #$0F                     ; len=15, jump to just set date
114	.9962		f0 2f		beq $9993	                beq setRTCDate
115							; Must be len=24 to set date+time
116	.9964		c8		iny		                iny                          ; Get next character
117	.9965		b1 f0		lda ($f0),y	                lda (originalX),y
118	.9967		c9 2e		cmp #$2e	                cmp #'.'                     ; If not full stop, exit silently
119	.9969		d0 7c		bne $99e7	                bne rts9753

121	.996b						setTime:
122	.996b		a2 04		ldx #$04	                ldx #RTC.hours
123	.996d		20 c4 99	jsr $99c4	                jsr readDecimalBCDByte
124	.9970		90 75		bcc $99e7	                bcc rts9753
125	.9972		c8		iny		                iny
126	.9973		b1 f0		lda ($f0),y	                lda (originalX),y
127	.9975		c9 3a		cmp #$3a	                cmp #':'
128	.9977		d0 6e		bne $99e7	                bne rts9753
129	.9979		a2 02		ldx #$02	                ldx #RTC.minutes
130	.997b		20 c4 99	jsr $99c4	                jsr readDecimalBCDByte
131	.997e		90 67		bcc $99e7	                bcc rts9753
132	.9980		c8		iny		                iny
133	.9981		b1 f0		lda ($f0),y	                lda (originalX),y
134	.9983		c9 3a		cmp #$3a	                cmp #':'
135	.9985		d0 60		bne $99e7	                bne rts9753
136	.9987		a2 00		ldx #$00	                ldx #RTC.seconds
137	.9989		20 c4 99	jsr $99c4	                jsr readDecimalBCDByte
138	.998c		90 59		bcc $99e7	                bcc rts9753
139	.998e		a9 40		lda #$40	                lda #$40
140	.9990		0c ed 02	tsb $02ed	                tsb osfileParameterBlock+0   ;got time
141	.9993						setRTCDate:
142	.9993		58		cli		                cli
143	.9994		78		sei		                sei
144	.9995		a0 83		ldy #$83	                ldy #RTC.b.set|RTC.b._24h|RTC.b.dse
145	.9997		a2 0b		ldx #$0b	                ldx #RTC.b
146	.9999		20 78 9b	jsr $9b78	                jsr writeRTCByte
147	.999c		2c ed 02	bit $02ed	                bit osfileParameterBlock+0 ;N=1 if got date; V=1 if got time
148	.999f		10 0f		bpl $99b0	                bpl setRTCTime ;taken if not got date - must then have time
149	.99a1		a2 06		ldx #$06	                ldx #$06
150	.99a3						-
151	.99a3		bc ee 02	ldy $02ee,x	                ldy osfileParameterBlock+1,x
152	.99a6		20 78 9b	jsr $9b78	                jsr writeRTCByte
153	.99a9		e8		inx		                inx
154	.99aa		e0 0a		cpx #$0a	                cpx #RTC.a
155	.99ac		90 f5		bcc $99a3	                bcc -
156	.99ae		50 0d		bvc $99bd	                bvc finishRTCUpdate                    ;taken if not got date
157	.99b0						setRTCTime:
158	.99b0		a2 00		ldx #$00	                ldx #RTC.seconds
159	.99b2						-
160	.99b2		bc ee 02	ldy $02ee,x	                ldy osfileParameterBlock+1,x
161	.99b5		20 78 9b	jsr $9b78	                jsr writeRTCByte
162	.99b8		e8		inx		                inx
163	.99b9		e0 06		cpx #$06	                cpx #RTC.dayOfWeek
164	.99bb		90 f5		bcc $99b2	                bcc -
165	.99bd						finishRTCUpdate:
166	.99bd		a2 0b		ldx #$0b	                ldx #RTC.b
167	.99bf		a0 02		ldy #$02	                ldy #RTC.b._24h
168	.99c1		4c 78 9b	jmp $9b78	                jmp writeRTCByte

170	.99c4						readDecimalBCDByte:
171	.99c4		20 e8 99	jsr $99e8	                jsr readDecimalDigit
172	.99c7		49 20		eor #$20	                eor #$20         ;check for ' '
173	.99c9		f0 04		beq $99cf	                beq +        ;taken if leading space - that's fine
174	.99cb		49 20		eor #$20	                eor #$20         ;reinstate old value
175	.99cd		90 18		bcc $99e7	                bcc rts9753      ;taken if non-space non-digits
176	.99cf						+
177	.99cf		9d ee 02	sta $02ee,x	                sta osfileParameterBlock+1,x
178	.99d2		20 e8 99	jsr $99e8	                jsr readDecimalDigit
179	.99d5		90 10		bcc $99e7	                bcc rts9753                  ;taken if invalid digit

181							                ; rotate new digit into place
182	.99d7		5a		phy		                phy
183	.99d8		a0 04		ldy #$04	                ldy #$04
184	.99da		0a		asl a		                asl a
185	.99db		0a		asl a		                asl a
186	.99dc		0a		asl a		                asl a
187	.99dd		0a		asl a		                asl a
188	.99de						-
189	.99de		0a		asl a		                asl a
190	.99df		3e ee 02	rol $02ee,x	                rol osfileParameterBlock+1,x
191	.99e2		88		dey		                dey
192	.99e3		d0 f9		bne $99de	                bne -
193	.99e5		7a		ply		                ply
194	.99e6		38		sec		                sec
195	.99e7						rts9753:
196	.99e7		60		rts		                rts

198	.99e8						readDecimalDigit:
199	.99e8		c8		iny		                iny
200	.99e9		b1 f0		lda ($f0),y	                lda (originalX),y
201	.99eb		c9 3a		cmp #$3a	                cmp #'9'+1
202	.99ed		b0 07		bcs $99f6	                bcs notDecimalDigit
203	.99ef		c9 30		cmp #$30	                cmp #'0'
204	.99f1		90 03		bcc $99f6	                bcc notDecimalDigit
205	.99f3		29 0f		and #$0f	                and #$0F
206	.99f5		60		rts		                rts

208	.99f6						notDecimalDigit:
209	.99f6		18		clc		                clc
210	.99f7		60		rts		                rts
211							                .endif

213							;-------------------------------------------------------------------------

215							; TODO - is this necessary?
216							;
217							; There's a reference to dayOfWeekStrings-4, but that seems to be
218							; because days are 1-based. The data here is presumably never
219							; accesssed.
220	>99f8		20 20 20 00			                .text "   ",0

222							;-------------------------------------------------------------------------

224	.99fc						dayOfWeekStrings: .block
225	>99fc		53 75 6e 01			                .text "Sun",$01
226	>9a00		4d 6f 6e 02			                .text "Mon",$02
227	>9a04		54 75 65 03			                .text "Tue",$03
228	>9a08		57 65 64 04			                .text "Wed",$04
229	>9a0c		54 68 75 05			                .text "Thu",$05
230	>9a10		46 72 69 06			                .text "Fri",$06
231	>9a14		53 61 74 07			                .text "Sat",$07
232							                .endblock

234							;-------------------------------------------------------------------------

236	.9a18						monthStrings: .block
237	>9a18		4a 61 6e 01			                .text "Jan",$01
238	>9a1c		46 65 62 02			                .text "Feb",$02
239	>9a20		4d 61 72 03			                .text "Mar",$03
240	>9a24		41 70 72 04			                .text "Apr",$04
241	>9a28		4d 61 79 05			                .text "May",$05
242	>9a2c		4a 75 6e 06			                .text "Jun",$06
243	>9a30		4a 75 6c 07			                .text "Jul",$07
244	>9a34		41 75 67 08			                .text "Aug",$08
245	>9a38		53 65 70 09			                .text "Sep",$09
246	>9a3c		4f 63 74 10			                .text "Oct",$10
247	>9a40		4e 6f 76 11			                .text "Nov",$11
248	>9a44		44 65 63 12			                .text "Dec",$12
249							                .endblock

251							;-------------------------------------------------------------------------

253							                .if version>=500
262							                .endif

264							;-------------------------------------------------------------------------

266							                .if version>=500
270							                .endif

272							;-------------------------------------------------------------------------
273							;
274							; OSWORD 14 (&0E) Read CMOS clock [MasRef D.3-22]
275							;

277	.9a48						osword0E:
278							                .if version<500
279	.9a48		48		pha		                pha                          ;save reason code
280	.9a49		49 02		eor #$02	                eor #$02                     ;
281	.9a4b		d0 1b		bne $9a68	                bne readClock
325							                .endif

327							                ; Convert given time to string. Fill out the RTC temp
328							                ; data with the info from the parameter block, then
329							                ; pass on to the common code.
330	.9a4d		a0 07		ldy #$07	                ldy #$07

332							                ; Copy hours, mins, secs.
333	.9a4f		a2 00		ldx #$00	                ldx #$00
334	.9a51						-
335	.9a51		b1 f0		lda ($f0),y	                lda ($F0),y
336	.9a53		9d ee 02	sta $02ee,x	                sta osfileParameterBlock+1,x
337	.9a56		88		dey		                dey
338	.9a57		e8		inx		                inx
339	.9a58		e8		inx		                inx
340	.9a59		e0 06		cpx #$06	                cpx #$06
341	.9a5b		90 f4		bcc $9a51	                bcc -

343							                ; Copy day of week, day of month, month, year.
344	.9a5d						-
345	.9a5d		b1 f0		lda ($f0),y	                lda (originalX),y
346	.9a5f		9d ee 02	sta $02ee,x	                sta osfileParameterBlock+1,x
347	.9a62		e8		inx		                inx
348	.9a63		88		dey		                dey
349	.9a64		d0 f7		bne $9a5d	                bne -

351							                .if version<500
352	.9a66		80 30		bra $9a98	                bra maybeConvertToString ; (called from here, there's no maybe about it)

354	.9a68						readClock:
355	.9a68		a5 f0		lda $f0		                lda originalX
356	.9a6a		48		pha		                pha
357	.9a6b		a5 f1		lda $f1		                lda originalY
358	.9a6d		48		pha		                pha
359	.9a6e						readRTCClock:
360	.9a6e		a2 0c		ldx #$0c	                ldx #RTC.c
361	.9a70		20 4b 9b	jsr $9b4b	                jsr readRTCByte ;clear the various IRQ flags with a read of register C
362	.9a73		a2 09		ldx #$09	                ldx #RTC.year
363	.9a75						-
364	.9a75		20 4b 9b	jsr $9b4b	                jsr readRTCByte
365	.9a78		9d ee 02	sta $02ee,x	                sta osfileParameterBlock+1,x
366	.9a7b		ca		dex		                dex
367	.9a7c		10 f7		bpl $9a75	                bpl -
368	.9a7e		a2 0a		ldx #$0a	                ldx #RTC.a
369	.9a80		20 4b 9b	jsr $9b4b	                jsr readRTCByte
370	.9a83		10 04		bpl $9a89	                bpl L97F5 ;taken if update not in progress - result is good
371	.9a85						retryReadRTCClock:
372	.9a85		58		cli		                cli
373	.9a86		78		sei		                sei
374	.9a87		80 e5		bra $9a6e	                bra readRTCClock

376	.9a89						L97F5:
377	.9a89		a2 0c		ldx #$0c	                ldx #RTC.c
378	.9a8b		20 4b 9b	jsr $9b4b	                jsr readRTCByte
379	.9a8e		29 10		and #$10	                and #RTC.c.uf
380	.9a90		d0 f3		bne $9a85	                bne retryReadRTCClock
381	.9a92		68		pla		                pla
382	.9a93		85 f1		sta $f1		                sta originalY
383	.9a95		68		pla		                pla
384	.9a96		85 f0		sta $f0		                sta originalX
385	.9a98						maybeConvertToString:
386	.9a98		68		pla		                pla                          ;get reason code
387	.9a99		3a		dec a		                dec a
388	.9a9a		d0 1a		bne $9ab6	                bne convertTimeToString                    ;taken if 0 or 2

390							                ; Copy year, month, day of month, day of week.
391	.9a9c		a0 00		ldy #$00	                ldy #$00
392	.9a9e		a2 09		ldx #$09	                ldx #RTC.year
393	.9aa0						-
394	.9aa0		bd ee 02	lda $02ee,x	                lda osfileParameterBlock+1,x
395	.9aa3		91 f0		sta ($f0),y	                sta (originalX),y
396	.9aa5		c8		iny		                iny
397	.9aa6		ca		dex		                dex
398	.9aa7		e0 06		cpx #$06	                cpx #RTC.dayOfWeek
399	.9aa9		b0 f5		bcs $9aa0	                bcs -

401							                ; Copy hours, minutes, seconds.
402	.9aab						-
403	.9aab		bd ed 02	lda $02ed,x	                lda osfileParameterBlock,x
404	.9aae		91 f0		sta ($f0),y	                sta (originalX),y
405	.9ab0		c8		iny		                iny
406	.9ab1		ca		dex		                dex
407	.9ab2		ca		dex		                dex
408	.9ab3		10 f6		bpl $9aab	                bpl -
409	.9ab5		60		rts		                rts

411							                .endif

413	.9ab6						convertTimeToString:
414							                ; Store terminating CR.
415	.9ab6		a0 18		ldy #$18	                ldy #ClockStringFormat.cr
416	.9ab8		a9 0d		lda #$0d	                lda #13
417	.9aba		91 f0		sta ($f0),y	                sta (originalX),y
418	.9abc		a2 00		ldx #$00	                ldx #$00
419	.9abe		88		dey		                dey
420	.9abf		20 24 9b	jsr $9b24	                jsr storeRTCDataByteString
421	.9ac2		a9 3a		lda #$3a	                lda #':'
422	.9ac4		91 f0		sta ($f0),y	                sta (originalX),y
423	.9ac6		a0 12		ldy #$12	                ldy #ClockStringFormat.hh+2
424	.9ac8		91 f0		sta ($f0),y	                sta (originalX),y
425	.9aca		a2 02		ldx #$02	                ldx #RTC.minutes
426	.9acc		a0 14		ldy #$14	                ldy #ClockStringFormat.mm+1
427	.9ace		20 24 9b	jsr $9b24	                jsr storeRTCDataByteString
428	.9ad1		a2 04		ldx #$04	                ldx #RTC.hours
429	.9ad3		a0 11		ldy #$11	                ldy #ClockStringFormat.hh+1
430	.9ad5		20 24 9b	jsr $9b24	                jsr storeRTCDataByteString
431	.9ad8		a9 2e		lda #$2e	                lda #'.'
432	.9ada		91 f0		sta ($f0),y	                sta (originalX),y
433	.9adc		ad f4 02	lda $02f4	                lda osfileParameterBlock+1+RTC.dayOfWeek;
434	.9adf		0a		asl a		                asl a
435	.9ae0		0a		asl a		                asl a
436	.9ae1		a0 00		ldy #$00	                ldy #$00
437	.9ae3		aa		tax		                tax
438	.9ae4						-
439	.9ae4		bd f8 99	lda $99f8,x	                lda dayOfWeekStrings-4,x     ;-4 as 1=Sunday
440	.9ae7		91 f0		sta ($f0),y	                sta (originalX),y
441	.9ae9		e8		inx		                inx
442	.9aea		c8		iny		                iny
443	.9aeb		c0 03		cpy #$03	                cpy #$03
444	.9aed		90 f5		bcc $9ae4	                bcc -
445	.9aef		a9 2c		lda #$2c	                lda #','
446	.9af1		91 f0		sta ($f0),y	                sta (originalX),y
447	.9af3		ad f6 02	lda $02f6	                lda osfileParameterBlock+1+RTC.month
448	.9af6		c9 10		cmp #$10	                cmp #$10
449	.9af8		90 02		bcc $9afc	                bcc +
450	.9afa		e9 06		sbc #$06	                sbc #$06            ;convert $10, $11 and $12 from BCD
451	.9afc						+
452	.9afc		3a		dec a		                dec a                        ;make month 0-based
453	.9afd		0a		asl a		                asl a
454	.9afe		0a		asl a		                asl a
455	.9aff		aa		tax		                tax
456	.9b00		a0 07		ldy #$07	                ldy #ClockStringFormat.mmm
457	.9b02						-
458	.9b02		bd 18 9a	lda $9a18,x	                lda monthStrings,x
459	.9b05		91 f0		sta ($f0),y	                sta ($F0),y
460	.9b07		e8		inx		                inx
461	.9b08		c8		iny		                iny
462	.9b09		c0 0a		cpy #$0a	                cpy #ClockStringFormat.mmm+3
463	.9b0b		90 f5		bcc $9b02	                bcc -
464	.9b0d		a2 09		ldx #$09	                ldx #RTC.year
465	.9b0f		a0 0e		ldy #$0e	                ldy #ClockStringFormat.yyyy+3
466	.9b11		20 24 9b	jsr $9b24	                jsr storeRTCDataByteString
467	.9b14		a9 19		lda #$19	                lda #assumedRTCCenturyBCD
468	.9b16		20 27 9b	jsr $9b27	                jsr storeBCDByteString
469	.9b19		a9 20		lda #$20	                lda #$20
470	.9b1b		91 f0		sta ($f0),y	                sta ($F0),y
471	.9b1d		a0 06		ldy #$06	                ldy #ClockStringFormat.nn+2
472	.9b1f		91 f0		sta ($f0),y	                sta ($F0),y
473	.9b21		88		dey		                dey
474	.9b22		a2 07		ldx #$07	                ldx #RTC.dayOfMonth
475	.9b24						storeRTCDataByteString:
476	.9b24		bd ee 02	lda $02ee,x	                lda osfileParameterBlock+1,x
477	.9b27						storeBCDByteString:
478	.9b27		48		pha		                pha
479	.9b28		20 30 9b	jsr $9b30	                jsr storeNybbleString
480	.9b2b		68		pla		                pla
481							                .if version==350
483							                .else
484	.9b2c		4a		lsr a		                lsr a
485	.9b2d		4a		lsr a		                lsr a
486	.9b2e		4a		lsr a		                lsr a
487	.9b2f		4a		lsr a		                lsr a
488							                .endif
489	.9b30						storeNybbleString:
490	.9b30		29 0f		and #$0f	                and #$0F
491	.9b32		09 30		ora #$30	                ora #'0'
492	.9b34		c9 3a		cmp #$3a	                cmp #'9'+1
493	.9b36		90 02		bcc $9b3a	                bcc +
494	.9b38		69 06		adc #$06	                adc #('A'-'9'-1)-1           ;(-1 because C set)
495	.9b3a						+
496	.9b3a		91 f0		sta ($f0),y	                sta (originalX),y
497	.9b3c		88		dey		                dey
498	.9b3d		60		rts		                rts

500							;-------------------------------------------------------------------------

502							                .if version<500
503							                .if version==350
506							                .endif
507	.9b3e						readDefaults2:
508	.9b3e		a2 1d		ldx #$1d	                ldx #CMOSBytes.defaults2+cmosBytesOffset
509	.9b40		80 09		bra $9b4b	                bra readRTCByte
510							                .endif

512							;-------------------------------------------------------------------------

514							                .if version<500
515							                .if version==350
518							                .endif
519	.9b42						readDefaults3:
520	.9b42		a2 1e		ldx #$1e	                ldx #CMOSBytes.defaults3+cmosBytesOffset
521	.9b44		80 05		bra $9b4b	                bra readRTCByte
522							                .endif

524							;-------------------------------------------------------------------------
525							;
526							; Read byte from RTC, either by 0-based CMOS RAM offset (readCMOSByte)
527							; or by RTC register index (readRTCByte).
528							;
529							; entry:
530							;
531							; X = address to read from
532							;
533							; exit:
534							;
535							; A = byte read
536							;
537							; N,Z = set as per byte read
538							;
539							                .if version<500
540	.9b46						readCMOSByte:
541	.9b46		20 91 9b	jsr $9b91	                jsr getRTCAddressForCMOSByte
542							                .if version==350
545							                .else
546	.9b49		b0 24		bcs $9b6f	                bcs rts98DB                  ;taken if invalid address
547							                .endif
548							                .if version==350
551							                .endif
552	.9b4b						readRTCByte:
553	.9b4b		08		php		                php
554	.9b4c		78		sei		                sei
555	.9b4d		20 9a 9b	jsr $9b9a	                jsr setRTCAddress
556	.9b50		a9 49		lda #$49	                lda #$49
557	.9b52		8d 40 fe	sta $fe40	                sta systemVIA.orb
558	.9b55		9c 43 fe	stz $fe43	                stz systemVIA.ddra
559	.9b58		a9 4a		lda #$4a	                lda #$4A
560	.9b5a		8d 40 fe	sta $fe40	                sta systemVIA.orb
561	.9b5d		ac 4f fe	ldy $fe4f	                ldy systemVIA.iraNoHandshake ;read value
562	.9b60						deselectRTC:
563	.9b60		a9 42		lda #$42	                lda #$42
564	.9b62		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=0
565	.9b65		a9 02		lda #$02	                lda #$02
566	.9b67		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=0 DS=0 R=0
567	.9b6a		9c 43 fe	stz $fe43	                stz systemVIA.ddra           ;all bits inputs
568	.9b6d		28		plp		                plp
569	.9b6e		98		tya		                tya
570	.9b6f						rts98DB:
571	.9b6f		60		rts		                rts
572							                .endif

574							;-------------------------------------------------------------------------
575							;
576							; Write byte to RTC, either by 0-based CMOS RAM offset (writeCMOSByte)
577							; or by RTC register index (writeRTCByte).
578							;
579							; (For some reason, writeCMOSByte can't be used to write to CMOS RAM
580							; offset 0.)
581							;
582							; entry:
583							;
584							; X = address to write to
585							;
586							; Y = value to write
587							;
588							                .if version<500
589	.9b70						writeCMOSByte:
590	.9b70		8a		txa		                txa
591	.9b71		f0 fc		beq $9b6f	                beq rts98DB
592	.9b73		20 91 9b	jsr $9b91	                jsr getRTCAddressForCMOSByte
593	.9b76		b0 f7		bcs $9b6f	                bcs rts98DB
594	.9b78						writeRTCByte:
595	.9b78		08		php		                php
596	.9b79		78		sei		                sei
597	.9b7a		20 9a 9b	jsr $9b9a	                jsr setRTCAddress            ;X=address
598	.9b7d		a9 41		lda #$41	                lda #$41
599	.9b7f		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=0
600	.9b82		a9 ff		lda #$ff	                lda #$FF
601	.9b84		8d 43 fe	sta $fe43	                sta systemVIA.ddra           ;all bits outputs
602	.9b87		a9 4a		lda #$4a	                lda #$4A
603	.9b89		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=1
604	.9b8c		8c 4f fe	sty $fe4f	                sty systemVIA.oraNoHandshake ;store value
605	.9b8f		80 cf		bra $9b60	                bra deselectRTC
606							                .endif

608							;-------------------------------------------------------------------------
609							;
610							; Convert CMOS byte offset to actual RTC address.
611							;
612							; entry:
613							;
614							; X = CMOS byte offset - 0-49
615							;
616							; exit:
617							;
618							; C=1 = invalid address
619							;
620							; C=0 = valid address: X = register index
621							;
622							                .if version<500
623	.9b91						getRTCAddressForCMOSByte:
624	.9b91		e0 32		cpx #$32	                cpx #size(RTC.ram)
625	.9b93		b0 04		bcs $9b99	                bcs rts9905
626	.9b95		8a		txa		                txa
627	.9b96		69 0e		adc #$0e	                adc #RTC.ram
628	.9b98		aa		tax		                tax
629	.9b99						rts9905:
630	.9b99		60		rts		                rts
631							                .endif

633							;-------------------------------------------------------------------------
634							;
635							; set RTC address for future read/write operation.
636							;
637							; entry:
638							;
639							; X = address to set
640							;
641							; preserves: Y
642							;
643							                .if version<500
644	.9b9a						setRTCAddress:
645	.9b9a		a9 02		lda #$02	                lda #$02
646	.9b9c		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=0 DS=0 R=0
647	.9b9f		a9 82		lda #$82	                lda #$82
648	.9ba1		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=1 CS=0 DS=0 R=0
649	.9ba4		a9 ff		lda #$ff	                lda #$FF
650	.9ba6		8d 43 fe	sta $fe43	                sta systemVIA.ddra           ;all bits outputs
651	.9ba9		8e 4f fe	stx $fe4f	                stx systemVIA.oraNoHandshake ;write RTC address
652	.9bac		a9 c2		lda #$c2	                lda #$c2
653	.9bae		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=1 CS=1 DS=0 R=0
654	.9bb1		a9 42		lda #$42	                lda #$42
655	.9bb3		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=0
656	.9bb6						rts9922:
657	.9bb6		60		rts		                rts
658							                .endif


:4	;******  Return to file: src/terminal.s65

2535							                .endif

2537							;-------------------------------------------------------------------------

2539	.9bb7						L9923:
2540	.9bb7		a9 03		lda #$03	                lda #$03
2541	.9bb9		20 96 d2	jsr $d296	                jsr LD298
2542	.9bbc		90 12		bcc $9bd0	                bcc L993C
2543	.9bbe		20 c4 9b	jsr $9bc4	                jsr L9930
2544	.9bc1		20 a7 d8	jsr $d8a7	                jsr LD8A9
2545	.9bc4						L9930:
2546	.9bc4		a2 20		ldx #$20	                ldx #$20
2547	.9bc6		4c b6 e2	jmp $e2b6	                jmp LE2B8

2549	.9bc9						L9935:
2550	.9bc9		a9 02		lda #$02	                lda #$02
2551	.9bcb		20 96 d2	jsr $d296	                jsr LD298
2552	.9bce		b0 64		bcs $9c34	                bcs L99A0
2553	.9bd0						L993C:
2554	.9bd0		20 d0 d3	jsr $d3d0	                jsr LD3D2
2555	.9bd3		20 53 9d	jsr $9d53	                jsr L9ABF
2556	.9bd6		80 08		bra $9be0	                bra L994C

2558	.9bd8						L9944:
2559	.9bd8		20 18 d4	jsr $d418	                jsr LD41A
2560	.9bdb		f0 57		beq $9c34	                beq L99A0
2561	.9bdd		20 d0 d3	jsr $d3d0	                jsr LD3D2
2562	.9be0						L994C:
2563	.9be0		a5 e1		lda $e1		                lda $E1
2564	.9be2		89 20		bit #$20	                bit #$20
2565	.9be4		f0 05		beq $9beb	                beq L9957
2566	.9be6		48		pha		                pha
2567	.9be7		20 a1 d6	jsr $d6a1	                jsr LD6A3
2568	.9bea		68		pla		                pla
2569	.9beb						L9957:
2570	.9beb		89 10		bit #$10	                bit #$10
2571	.9bed		f0 03		beq $9bf2	                beq L995E
2572	.9bef		20 96 d6	jsr $d696	                jsr LD698
2573	.9bf2						L995E:
2574	.9bf2		20 90 9c	jsr $9c90	                jsr L99FC
2575	.9bf5		08		php		                php
2576	.9bf6		20 ee 9c	jsr $9cee	                jsr L9A5A
2577	.9bf9		a2 42		ldx #$42	                ldx #$42
2578	.9bfb		a0 46		ldy #$46	                ldy #$46
2579	.9bfd		a9 20		lda #$20	                lda #$20
2580	.9bff		2c 49 88	bit $8849	                bit L8849
2581	.9c02		f0 1c		beq $9c20	                beq L998C
2582	.9c04		30 18		bmi $9c1e	                bmi L998A
2583	.9c06		ad 2c 03	lda $032c	                lda $032C
2584	.9c09		cd 37 03	cmp $0337	                cmp $0337
2585	.9c0c		d0 08		bne $9c16	                bne L9982
2586	.9c0e		ad 2d 03	lda $032d	                lda $032D
2587	.9c11		cd 38 03	cmp $0338	                cmp $0338
2588	.9c14		f0 10		beq $9c26	                beq L9992
2589	.9c16						L9982:
2590	.9c16		a2 37		ldx #$37	                ldx #$37
2591	.9c18		20 4b d2	jsr $d24b	                jsr LD24D
2592	.9c1b		a2 42		ldx #$42	                ldx #$42
2593	.9c1d		b8		clv		                clv
2594	.9c1e						L998A:
2595	.9c1e		a0 2c		ldy #$2c	                ldy #$2C
2596	.9c20						L998C:
2597	.9c20		30 07		bmi $9c29	                bmi L9995
2598	.9c22		50 02		bvc $9c26	                bvc L9992
2599	.9c24		a2 37		ldx #$37	                ldx #$37
2600	.9c26						L9992:
2601	.9c26		20 4b d2	jsr $d24b	                jsr LD24D
2602	.9c29						L9995:
2603	.9c29		28		plp		                plp
2604	.9c2a		90 b4		bcc $9be0	                bcc L994C
2605	.9c2c		60		rts		                rts

2607	.9c2d						L9999:
2608	.9c2d		a9 01		lda #$01	                lda #$01
2609	.9c2f		20 96 d2	jsr $d296	                jsr LD298
2610	.9c32		90 09		bcc $9c3d	                bcc L99A9
2611	.9c34						L99A0:
2612	.9c34		a2 24		ldx #$24	                ldx #$24
2613	.9c36		80 37		bra $9c6f	                bra L99DB

2615	.9c38						L99A4:
2616	.9c38		20 18 d4	jsr $d418	                jsr LD41A
2617	.9c3b		f0 f7		beq $9c34	                beq L99A0
2618	.9c3d						L99A9:
2619	.9c3d		20 d0 d3	jsr $d3d0	                jsr LD3D2
2620	.9c40		20 5d 9c	jsr $9c5d	                jsr L99C9
2621	.9c43						L99AF:
2622	.9c43		20 e4 d5	jsr $d5e4	                jsr LD5E6
2623	.9c46		20 5d 9c	jsr $9c5d	                jsr L99C9
2624	.9c49		ad 30 88	lda $8830	                lda L8830
2625	.9c4c		0d 31 88	ora $8831	                ora L8831
2626	.9c4f		f0 3e		beq $9c8f	                beq L99FB
2627	.9c51		2c 48 88	bit $8848	                bit L8848
2628	.9c54		70 ed		bvs $9c43	                bvs L99AF
2629	.9c56		a2 42		ldx #$42	                ldx #$42
2630	.9c58		20 6a 9c	jsr $9c6a	                jsr L99D6
2631	.9c5b		80 e6		bra $9c43	                bra L99AF

2633	.9c5d						L99C9:
2634	.9c5d		20 32 d3	jsr $d332	                jsr LD334
2635	.9c60		20 72 9c	jsr $9c72	                jsr L99DE
2636	.9c63		2c 48 88	bit $8848	                bit L8848
2637	.9c66		30 27		bmi $9c8f	                bmi L99FB
2638	.9c68		a2 46		ldx #$46	                ldx #$46
2639	.9c6a						L99D6:
2640	.9c6a		da		phx		                phx
2641	.9c6b		20 7e d2	jsr $d27e	                jsr LD280
2642	.9c6e		fa		plx		                plx
2643	.9c6f						L99DB:
2644	.9c6f		4c 4a db	jmp $db4a	                jmp plotPointInternal

2646	.9c72						L99DE:
2647	.9c72		a2 03		ldx #$03	                ldx #$03
2648	.9c74						L99E0:
2649	.9c74		bd 30 88	lda $8830,x	                lda L8830,x
2650	.9c77		9d 42 03	sta $0342,x	                sta $0342,x
2651	.9c7a		9d 46 03	sta $0346,x	                sta $0346,x
2652	.9c7d		ca		dex		                dex
2653	.9c7e		10 f4		bpl $9c74	                bpl L99E0
2654	.9c80						L99EC:
2655	.9c80		ac 42 03	ldy $0342	                ldy $0342
2656	.9c83		ad 43 03	lda $0343	                lda $0343
2657	.9c86		20 2c c9	jsr $c92c	                jsr negateAY
2658	.9c89		8c 42 03	sty $0342	                sty $0342
2659	.9c8c		8d 43 03	sta $0343	                sta $0343
2660	.9c8f						L99FB:
2661	.9c8f		60		rts		                rts

2663	.9c90						L99FC:
2664	.9c90		a5 e1		lda $e1		                lda $E1
2665	.9c92		8d 49 88	sta $8849	                sta L8849
2666	.9c95		20 72 9c	jsr $9c72	                jsr L99DE
2667	.9c98		a2 01		ldx #$01	                ldx #$01
2668	.9c9a						L9A06:
2669	.9c9a		9e 42 03	stz $0342,x	                stz $0342,x
2670	.9c9d		9e 46 03	stz $0346,x	                stz $0346,x
2671	.9ca0		ca		dex		                dex
2672	.9ca1		10 f7		bpl $9c9a	                bpl L9A06
2673	.9ca3						L9A0F:
2674	.9ca3		20 c2 9c	jsr $9cc2	                jsr L9A2E
2675	.9ca6		ad 30 88	lda $8830	                lda L8830
2676	.9ca9		0d 31 88	ora $8831	                ora L8831
2677	.9cac		d0 06		bne $9cb4	                bne L9A20
2678	.9cae		38		sec		                sec
2679	.9caf		ad 47 88	lda $8847	                lda L8847
2680	.9cb2		d0 cc		bne $9c80	                bne L99EC
2681	.9cb4						L9A20:
2682	.9cb4		20 e4 d5	jsr $d5e4	                jsr LD5E6
2683	.9cb7		ad 32 88	lda $8832	                lda L8832
2684	.9cba		cd 44 03	cmp $0344	                cmp $0344
2685	.9cbd		f0 e4		beq $9ca3	                beq L9A0F
2686	.9cbf		18		clc		                clc
2687	.9cc0		80 be		bra $9c80	                bra L99EC

2689	.9cc2						L9A2E:
2690	.9cc2		20 32 d3	jsr $d332	                jsr LD334
2691	.9cc5		2c 48 88	bit $8848	                bit L8848
2692	.9cc8		30 07		bmi $9cd1	                bmi L9A3D
2693	.9cca		08		php		                php
2694	.9ccb		a2 46		ldx #$46	                ldx #$46
2695	.9ccd		20 d5 9c	jsr $9cd5	                jsr L9A41
2696	.9cd0		28		plp		                plp
2697	.9cd1						L9A3D:
2698	.9cd1		70 1a		bvs $9ced	                bvs L9A59
2699	.9cd3		a2 42		ldx #$42	                ldx #$42
2700	.9cd5						L9A41:
2701	.9cd5		ad 30 88	lda $8830	                lda L8830
2702	.9cd8		a8		tay		                tay
2703	.9cd9		dd 00 03	cmp $0300,x	                cmp $0300,x
2704	.9cdc		ad 31 88	lda $8831	                lda L8831
2705	.9cdf		48		pha		                pha
2706	.9ce0		fd 01 03	sbc $0301,x	                sbc $0301,x
2707	.9ce3		68		pla		                pla
2708	.9ce4		90 07		bcc $9ced	                bcc L9A59
2709	.9ce6		9d 01 03	sta $0301,x	                sta $0301,x
2710	.9ce9		98		tya		                tya
2711	.9cea		9d 00 03	sta $0300,x	                sta $0300,x
2712	.9ced						L9A59:
2713	.9ced		60		rts		                rts

2715	.9cee						L9A5A:
2716	.9cee		ad 44 03	lda $0344	                lda $0344
2717	.9cf1		0d 45 03	ora $0345	                ora $0345
2718	.9cf4		d0 5c		bne $9d52	                bne L9ABE
2719	.9cf6		a5 e1		lda $e1		                lda $E1
2720	.9cf8		1a		inc a		                inc a
2721	.9cf9		29 03		and #$03	                and #$03
2722	.9cfb		d0 55		bne $9d52	                bne L9ABE
2723	.9cfd		a9 20		lda #$20	                lda #$20
2724	.9cff		2c 49 88	bit $8849	                bit L8849
2725	.9d02		10 09		bpl $9d0d	                bpl L9A79
2726	.9d04		f0 07		beq $9d0d	                beq L9A79
2727	.9d06		a2 2c		ldx #$2c	                ldx #$2C
2728	.9d08		a0 46		ldy #$46	                ldy #$46
2729	.9d0a		20 1c c9	jsr $c91c	                jsr copyFourBytesWithinVDUVariables
2730	.9d0d						L9A79:
2731	.9d0d		a9 10		lda #$10	                lda #$10
2732	.9d0f		2c 49 88	bit $8849	                bit L8849
2733	.9d12		50 09		bvc $9d1d	                bvc L9A89
2734	.9d14		f0 07		beq $9d1d	                beq L9A89
2735	.9d16		a2 37		ldx #$37	                ldx #$37
2736	.9d18		a0 42		ldy #$42	                ldy #$42
2737	.9d1a		20 1c c9	jsr $c91c	                jsr copyFourBytesWithinVDUVariables
2738	.9d1d						L9A89:
2739	.9d1d		20 53 9d	jsr $9d53	                jsr L9ABF
2740	.9d20		a5 e1		lda $e1		                lda $E1
2741	.9d22		49 3c		eor #$3c	                eor #$3C
2742	.9d24		2a		rol a		                rol a
2743	.9d25		20 6f c6	jsr $c66f	                jsr fixUpVPALETTEFor4Colours
2744	.9d28		6a		ror a		                ror a
2745	.9d29		85 e1		sta $e1		                sta $E1
2746	.9d2b		89 20		bit #$20	                bit #$20
2747	.9d2d		f0 10		beq $9d3f	                beq L9AAB
2748	.9d2f		48		pha		                pha
2749	.9d30		a2 2c		ldx #$2c	                ldx #$2C
2750	.9d32		a0 46		ldy #$46	                ldy #$46
2751	.9d34		20 ca d5	jsr $d5ca	                jsr sortVDUVariableWords
2752	.9d37		98		tya		                tya
2753	.9d38		aa		tax		                tax
2754	.9d39		a0 46		ldy #$46	                ldy #$46
2755	.9d3b		20 1c c9	jsr $c91c	                jsr copyFourBytesWithinVDUVariables
2756	.9d3e		68		pla		                pla
2757	.9d3f						L9AAB:
2758	.9d3f		89 10		bit #$10	                bit #$10
2759	.9d41		f0 0c		beq $9d4f	                beq L9ABB
2760	.9d43		a2 37		ldx #$37	                ldx #$37
2761	.9d45		a0 42		ldy #$42	                ldy #$42
2762	.9d47		20 ca d5	jsr $d5ca	                jsr sortVDUVariableWords
2763	.9d4a		a0 42		ldy #$42	                ldy #$42
2764	.9d4c		20 1c c9	jsr $c91c	                jsr copyFourBytesWithinVDUVariables
2765	.9d4f						L9ABB:
2766	.9d4f		9c 49 88	stz $8849	                stz L8849
2767	.9d52						L9ABE:
2768	.9d52		60		rts		                rts

2770	.9d53						L9ABF:
2771	.9d53		a2 03		ldx #$03	                ldx #$03
2772	.9d55						L9AC1:
2773	.9d55		9e 3b 03	stz $033b,x	                stz $033B,x
2774	.9d58		ca		dex		                dex
2775	.9d59		10 fa		bpl $9d55	                bpl L9AC1
2776	.9d5b		a0 28		ldy #$28	                ldy #$28
2777	.9d5d		a2 1b		ldx #$1b	                ldx #$1B
2778	.9d5f		a9 2c		lda #$2c	                lda #$2C
2779	.9d61		20 73 9d	jsr $9d73	                jsr L9ADF
2780	.9d64		20 a6 d6	jsr $d6a6	                jsr LD6A8
2781	.9d67		a0 1b		ldy #$1b	                ldy #$1B
2782	.9d69		a2 28		ldx #$28	                ldx #$28
2783	.9d6b		a9 37		lda #$37	                lda #$37
2784	.9d6d		20 73 9d	jsr $9d73	                jsr L9ADF
2785	.9d70		4c 9b d6	jmp $d69b	                jmp LD69D

2787	.9d73						L9ADF:
2788	.9d73		48		pha		                pha
2789	.9d74		a5 e1		lda $e1		                lda $E1
2790	.9d76		4a		lsr a		                lsr a
2791	.9d77		90 0b		bcc $9d84	                bcc L9AF0
2792	.9d79		ad 47 88	lda $8847	                lda L8847
2793	.9d7c		d0 04		bne $9d82	                bne L9AEE
2794	.9d7e		a2 3b		ldx #$3b	                ldx #$3B
2795	.9d80		80 02		bra $9d84	                bra L9AF0

2797	.9d82						L9AEE:
2798	.9d82		a0 3b		ldy #$3b	                ldy #$3B
2799	.9d84						L9AF0:
2800	.9d84		8a		txa		                txa
2801	.9d85		fa		plx		                plx
2802	.9d86		da		phx		                phx
2803	.9d87		48		pha		                pha
2804	.9d88		5a		phy		                phy
2805	.9d89		a8		tay		                tay
2806	.9d8a		a9 03		lda #$03	                lda #$03
2807	.9d8c		85 da		sta $da		                sta $DA
2808	.9d8e						L9AFA:
2809	.9d8e		b9 00 03	lda $0300,y	                lda $0300,y
2810	.9d91		9d 1e 88	sta $881e,x	                sta L881E,x
2811	.9d94		c8		iny		                iny
2812	.9d95		e8		inx		                inx
2813	.9d96		c6 da		dec $da		                dec $DA
2814	.9d98		10 f4		bpl $9d8e	                bpl L9AFA
2815	.9d9a		7a		ply		                ply
2816	.9d9b		68		pla		                pla
2817	.9d9c		fa		plx		                plx
2818	.9d9d						L9B09:
2819	.9d9d		48		pha		                pha
2820	.9d9e		5a		phy		                phy
2821	.9d9f		20 f5 9d	jsr $9df5	                jsr L9B61
2822	.9da2		ca		dex		                dex
2823	.9da3		7a		ply		                ply
2824	.9da4		68		pla		                pla
2825	.9da5		da		phx		                phx
2826	.9da6		c8		iny		                iny
2827	.9da7		c8		iny		                iny
2828	.9da8		1a		inc a		                inc a
2829	.9da9		1a		inc a		                inc a
2830	.9daa		e8		inx		                inx
2831	.9dab		e8		inx		                inx
2832	.9dac		20 f5 9d	jsr $9df5	                jsr L9B61
2833	.9daf		fa		plx		                plx
2834	.9db0		20 24 9e	jsr $9e24	                jsr L9B90
2835	.9db3		08		php		                php
2836	.9db4		48		pha		                pha
2837	.9db5		bd 05 03	lda $0305,x	                lda $0305,x
2838	.9db8		0a		asl a		                asl a
2839	.9db9		7e 0a 03	ror $030a,x	                ror $030A,x
2840	.9dbc		10 03		bpl $9dc1	                bpl L9B2D
2841	.9dbe		20 13 9e	jsr $9e13	                jsr L9B7F
2842	.9dc1						L9B2D:
2843	.9dc1		68		pla		                pla
2844	.9dc2		0a		asl a		                asl a
2845	.9dc3		7e 0a 03	ror $030a,x	                ror $030A,x
2846	.9dc6		10 07		bpl $9dcf	                bpl L9B3B
2847	.9dc8		e8		inx		                inx
2848	.9dc9		e8		inx		                inx
2849	.9dca		20 13 9e	jsr $9e13	                jsr L9B7F
2850	.9dcd		ca		dex		                dex
2851	.9dce		ca		dex		                dex
2852	.9dcf						L9B3B:
2853	.9dcf		20 24 9e	jsr $9e24	                jsr L9B90
2854	.9dd2		10 06		bpl $9dda	                bpl L9B46
2855	.9dd4		bd 05 03	lda $0305,x	                lda $0305,x
2856	.9dd7		bc 04 03	ldy $0304,x	                ldy $0304,x
2857	.9dda						L9B46:
2858	.9dda		28		plp		                plp
2859	.9ddb		30 06		bmi $9de3	                bmi L9B4F
2860	.9ddd		c0 00		cpy #$00	                cpy #$00
2861	.9ddf		d0 01		bne $9de2	                bne L9B4E
2862	.9de1		3a		dec a		                dec a
2863	.9de2						L9B4E:
2864	.9de2		88		dey		                dey
2865	.9de3						L9B4F:
2866	.9de3		4a		lsr a		                lsr a
2867	.9de4		48		pha		                pha
2868	.9de5		98		tya		                tya
2869	.9de6		6a		ror a		                ror a
2870	.9de7		38		sec		                sec
2871	.9de8		ca		dex		                dex
2872	.9de9		20 ee 9d	jsr $9dee	                jsr L9B5A
2873	.9dec		e8		inx		                inx
2874	.9ded		68		pla		                pla
2875	.9dee						L9B5A:
2876	.9dee		fd 07 03	sbc $0307,x	                sbc $0307,x
2877	.9df1		9d 09 03	sta $0309,x	                sta $0309,x
2878	.9df4		60		rts		                rts

2880	.9df5						L9B61:
2881	.9df5		48		pha		                pha
2882	.9df6		b9 00 03	lda $0300,y	                lda $0300,y
2883	.9df9		9d 00 03	sta $0300,x	                sta $0300,x
2884	.9dfc		b9 01 03	lda $0301,y	                lda $0301,y
2885	.9dff		9d 01 03	sta $0301,x	                sta $0301,x
2886	.9e02		7a		ply		                ply
2887	.9e03		38		sec		                sec
2888	.9e04		20 09 9e	jsr $9e09	                jsr L9B75
2889	.9e07		e8		inx		                inx
2890	.9e08		c8		iny		                iny
2891	.9e09						L9B75:
2892	.9e09		b9 00 03	lda $0300,y	                lda $0300,y
2893	.9e0c		fd 00 03	sbc $0300,x	                sbc $0300,x
2894	.9e0f		9d 04 03	sta $0304,x	                sta $0304,x
2895	.9e12		60		rts		                rts

2897	.9e13						L9B7F:
2898	.9e13		bd 05 03	lda $0305,x	                lda $0305,x
2899	.9e16		bc 04 03	ldy $0304,x	                ldy $0304,x
2900	.9e19		20 2c c9	jsr $c92c	                jsr negateAY
2901	.9e1c		9d 05 03	sta $0305,x	                sta $0305,x
2902	.9e1f		98		tya		                tya
2903	.9e20		9d 04 03	sta $0304,x	                sta $0304,x
2904	.9e23		60		rts		                rts

2906	.9e24						L9B90:
2907	.9e24		bd 06 03	lda $0306,x	                lda $0306,x
2908	.9e27		a8		tay		                tay
2909	.9e28		dd 04 03	cmp $0304,x	                cmp $0304,x
2910	.9e2b		bd 07 03	lda $0307,x	                lda $0307,x
2911	.9e2e		fd 05 03	sbc $0305,x	                sbc $0305,x
2912	.9e31		08		php		                php
2913	.9e32		bd 07 03	lda $0307,x	                lda $0307,x
2914	.9e35		28		plp		                plp
2915	.9e36		60		rts		                rts

2917							;-------------------------------------------------------------------------
2918							;
2919							; 112-119 = Plot parallelogram [MasRef E.3-27]
2920							;
2921	.9e37						plotParallelogram:
2922	.9e37		a2 28		ldx #$28	                ldx #$28
2923	.9e39		86 da		stx $da		                stx $DA
2924	.9e3b		a2 14		ldx #$14	                ldx #$14
2925	.9e3d		a0 20		ldy #$20	                ldy #$20
2926	.9e3f		a9 24		lda #$24	                lda #$24
2927	.9e41		20 7e d5	jsr $d57e	                jsr addRegionDimensionsToVDUVariableCoordinates
2928	.9e44		a0 14		ldy #$14	                ldy #$14
2929	.9e46		a2 24		ldx #$24	                ldx #$24
2930	.9e48		20 b5 d5	jsr $d5b5	                jsr sortVDUVariableCoordinates
2931	.9e4b		8e 30 88	stx $8830	                stx L8830
2932	.9e4e		a2 20		ldx #$20	                ldx #$20
2933	.9e50		20 b5 d5	jsr $d5b5	                jsr sortVDUVariableCoordinates
2934	.9e53		8e 31 88	stx $8831	                stx L8831
2935	.9e56		a2 28		ldx #$28	                ldx #$28
2936	.9e58		20 b5 d5	jsr $d5b5	                jsr sortVDUVariableCoordinates
2937	.9e5b		8c 33 88	sty $8833	                sty L8833
2938	.9e5e		ac 31 88	ldy $8831	                ldy L8831
2939	.9e61		20 b5 d5	jsr $d5b5	                jsr sortVDUVariableCoordinates
2940	.9e64		8c 32 88	sty $8832	                sty L8832
2941	.9e67		ac 30 88	ldy $8830	                ldy L8830
2942	.9e6a		20 a3 9e	jsr $9ea3	                jsr L9C0F
2943	.9e6d		ad 33 88	lda $8833	                lda L8833
2944	.9e70		85 e0		sta $e0		                sta $E0
2945	.9e72		a2 2c		ldx #$2c	                ldx #$2C
2946	.9e74		20 9d 9d	jsr $9d9d	                jsr L9B09
2947	.9e77		a4 e1		ldy $e1		                ldy $E1
2948	.9e79		20 ea 9e	jsr $9eea	                jsr L9C56
2949	.9e7c		ac 32 88	ldy $8832	                ldy L8832
2950	.9e7f		ad 33 88	lda $8833	                lda L8833
2951	.9e82		85 e1		sta $e1		                sta $E1
2952	.9e84		a2 37		ldx #$37	                ldx #$37
2953	.9e86		20 e5 9e	jsr $9ee5	                jsr L9C51
2954	.9e89		80 15		bra $9ea0	                bra L9C0C

2956	.9e8b						L9BF7;
2957	.9e8b		a0 14		ldy #$14	                ldy #$14
2958	.9e8d		a2 24		ldx #$24	                ldx #$24
2959	.9e8f		20 b5 d5	jsr $d5b5	                jsr sortVDUVariableCoordinates
2960	.9e92		8c 32 88	sty $8832	                sty L8832
2961	.9e95		a0 20		ldy #$20	                ldy #$20
2962	.9e97		20 a3 9e	jsr $9ea3	                jsr L9C0F
2963	.9e9a		ad 32 88	lda $8832	                lda L8832
2964	.9e9d		20 e1 9e	jsr $9ee1	                jsr L9C4D
2965	.9ea0						L9C0C:
2966	.9ea0		4c e2 da	jmp $dae2	                jmp LDAE4

2968	.9ea3						L9C0F:
2969	.9ea3		20 b5 d5	jsr $d5b5	                jsr sortVDUVariableCoordinates
2970	.9ea6		8e 30 88	stx $8830	                stx L8830
2971	.9ea9		ae 32 88	ldx $8832	                ldx L8832
2972	.9eac		20 b5 d5	jsr $d5b5	                jsr sortVDUVariableCoordinates
2973	.9eaf		8c 32 88	sty $8832	                sty L8832
2974	.9eb2		8e 31 88	stx $8831	                stx L8831
2975	.9eb5		ac 30 88	ldy $8830	                ldy L8830
2976	.9eb8		a2 fc		ldx #$fc	                ldx #$FC
2977	.9eba						L9C26:
2978	.9eba		b9 00 03	lda $0300,y	                lda $0300,y
2979	.9ebd		9d 46 02	sta $0246,x	                sta vduv.workspace._42-$fc,x
2980	.9ec0		9d 4a 02	sta $024a,x	                sta vduv.workspace._46-$fc,x
2981	.9ec3		c8		iny		                iny
2982	.9ec4		e8		inx		                inx
2983	.9ec5		d0 f3		bne $9eba	                bne L9C26
2984	.9ec7		ac 30 88	ldy $8830	                ldy L8830
2985	.9eca		ad 32 88	lda $8832	                lda L8832
2986	.9ecd		85 e1		sta $e1		                sta $E1
2987	.9ecf		a2 37		ldx #$37	                ldx #$37
2988	.9ed1		20 9d 9d	jsr $9d9d	                jsr L9B09
2989	.9ed4		ac 30 88	ldy $8830	                ldy L8830
2990	.9ed7		ad 31 88	lda $8831	                lda L8831
2991	.9eda		20 e1 9e	jsr $9ee1	                jsr L9C4D
2992	.9edd		ac 31 88	ldy $8831	                ldy L8831
2993	.9ee0		60		rts		                rts

2995	.9ee1						L9C4D:
2996	.9ee1		85 e0		sta $e0		                sta $E0
2997	.9ee3		a2 2c		ldx #$2c	                ldx #$2C
2998	.9ee5						L9C51:
2999	.9ee5		20 9d 9d	jsr $9d9d	                jsr L9B09
3000	.9ee8		a4 e0		ldy $e0		                ldy $E0
3001	.9eea						L9C56:
3002	.9eea		5a		phy		                phy
3003	.9eeb		b9 02 03	lda $0302,y	                lda $0302,y
3004	.9eee		cd 44 03	cmp $0344	                cmp $0344
3005	.9ef1		d0 08		bne $9efb	                bne L9C67
3006	.9ef3		b9 03 03	lda $0303,y	                lda $0303,y
3007	.9ef6		cd 45 03	cmp $0345	                cmp $0345
3008	.9ef9		f0 39		beq $9f34	                beq L9CA0
3009	.9efb						L9C67:
3010	.9efb		a2 2c		ldx #$2c	                ldx #$2C
3011	.9efd		20 54 9f	jsr $9f54	                jsr L9CC0
3012	.9f00		a2 37		ldx #$37	                ldx #$37
3013	.9f02		20 54 9f	jsr $9f54	                jsr L9CC0
3014	.9f05		20 e2 da	jsr $dae2	                jsr LDAE4
3015	.9f08		a2 37		ldx #$37	                ldx #$37
3016	.9f0a		20 24 d7	jsr $d724	                jsr LD726
3017	.9f0d		a2 2c		ldx #$2c	                ldx #$2C
3018	.9f0f		20 24 d7	jsr $d724	                jsr LD726
3019	.9f12		a0 37		ldy #$37	                ldy #$37
3020	.9f14		20 ca d5	jsr $d5ca	                jsr sortVDUVariableWords
3021	.9f17		da		phx		                phx
3022	.9f18		a2 fc		ldx #$fc	                ldx #$FC
3023	.9f1a						L9C86:
3024	.9f1a		b9 00 03	lda $0300,y	                lda $0300,y
3025	.9f1d		9d 4a 02	sta $024a,x	                sta vduv.workspace._46-$fc,x
3026	.9f20		c8		iny		                iny
3027	.9f21		e8		inx		                inx
3028	.9f22		d0 f6		bne $9f1a	                bne L9C86
3029	.9f24		fa		plx		                plx
3030	.9f25		a0 fc		ldy #$fc	                ldy #$FC
3031	.9f27						L9C93:
3032	.9f27		bd 00 03	lda $0300,x	                lda $0300,x
3033	.9f2a		99 46 02	sta $0246,y	                sta vduv.workspace._42-$fc,y
3034	.9f2d		e8		inx		                inx
3035	.9f2e		c8		iny		                iny
3036	.9f2f		d0 f6		bne $9f27	                bne L9C93
3037	.9f31		7a		ply		                ply
3038	.9f32		80 b6		bra $9eea	                bra L9C56

3040	.9f34						L9CA0:
3041	.9f34		a9 2c		lda #$2c	                lda #$2C
3042	.9f36		a6 e0		ldx $e0		                ldx $E0
3043	.9f38		20 40 9f	jsr $9f40	                jsr L9CAC
3044	.9f3b		7a		ply		                ply
3045	.9f3c		a9 37		lda #$37	                lda #$37
3046	.9f3e		a6 e1		ldx $e1		                ldx $E1
3047	.9f40						L9CAC:
3048	.9f40		85 de		sta $de		                sta $DE
3049	.9f42		bd 02 03	lda $0302,x	                lda vduv.graphicsWindowPixelsBottom+0,x
3050	.9f45		d9 02 03	cmp $0302,y	                cmp vduv.graphicsWindowPixelsBottom+0,y
3051	.9f48		d0 08		bne $9f52	                bne L9CBE
3052	.9f4a		bd 03 03	lda $0303,x	                lda vduv.graphicsWindowPixelsBottom+1,x
3053	.9f4d		d9 03 03	cmp $0303,y	                cmp vduv.graphicsWindowPixelsBottom+1,y
3054	.9f50		f0 05		beq $9f57	                beq L9CC3
3055	.9f52						L9CBE:
3056	.9f52		a6 de		ldx $de		                ldx $DE
3057	.9f54						L9CC0:
3058	.9f54		20 1b d7	jsr $d71b	                jsr LD71D
3059	.9f57						L9CC3:
3060	.9f57		bd 00 03	lda $0300,x	                lda $0300,x
3061	.9f5a		cd 42 03	cmp $0342	                cmp $0342
3062	.9f5d		bd 01 03	lda $0301,x	                lda $0301,x
3063	.9f60		ed 43 03	sbc $0343	                sbc $0343
3064	.9f63		10 0d		bpl $9f72	                bpl L9CDE
3065	.9f65		bd 00 03	lda $0300,x	                lda $0300,x
3066	.9f68		8d 42 03	sta $0342	                sta $0342
3067	.9f6b		bd 01 03	lda $0301,x	                lda $0301,x
3068	.9f6e		8d 43 03	sta $0343	                sta $0343
3069	.9f71		60		rts		                rts

3071	.9f72						L9CDE:
3072	.9f72		ad 46 03	lda $0346	                lda $0346
3073	.9f75		dd 00 03	cmp $0300,x	                cmp $0300,x
3074	.9f78		ad 47 03	lda $0347	                lda $0347
3075	.9f7b		fd 01 03	sbc $0301,x	                sbc $0301,x
3076	.9f7e		10 0c		bpl $9f8c	                bpl L9CF8
3077	.9f80		bd 00 03	lda $0300,x	                lda $0300,x
3078	.9f83		8d 46 03	sta $0346	                sta $0346
3079	.9f86		bd 01 03	lda $0301,x	                lda $0301,x
3080	.9f89		8d 47 03	sta $0347	                sta $0347
3081	.9f8c						L9CF8:
3082	.9f8c		60		rts		                rts

3084	.9f8d						L9CF9:
3085	.9f8d		20 9f dd	jsr $dd9f	                jsr LDDA1
3086	.9f90		9c 36 03	stz $0336	                stz $0336
3087	.9f93		9c 37 03	stz $0337	                stz $0337
3088	.9f96		20 ae dc	jsr $dcae	                jsr LDCB0
3089	.9f99		d0 4f		bne $9fea	                bne L9D56
3090	.9f9b		20 1a dc	jsr $dc1a	                jsr LDC1C
3091	.9f9e						L9D0A:
3092	.9f9e		24 ff		bit $ff		                bit $FF
3093	.9fa0		30 48		bmi $9fea	                bmi L9D56
3094	.9fa2		ad 36 03	lda $0336	                lda $0336
3095	.9fa5		cd 37 03	cmp $0337	                cmp $0337
3096	.9fa8		f0 40		beq $9fea	                beq L9D56
3097	.9faa		1a		inc a		                inc a
3098	.9fab		8d 36 03	sta $0336	                sta $0336
3099	.9fae		aa		tax		                tax
3100	.9faf		bd 00 84	lda $8400,x	                lda L8400,x
3101	.9fb2		8d 28 03	sta $0328	                sta $0328
3102	.9fb5		bd 00 85	lda $8500,x	                lda L8500,x
3103	.9fb8		8d 2c 03	sta $032c	                sta $032C
3104	.9fbb		bd 00 86	lda $8600,x	                lda L8600,x
3105	.9fbe		48		pha		                pha
3106	.9fbf		4a		lsr a		                lsr a
3107	.9fc0		4a		lsr a		                lsr a
3108	.9fc1		8d 29 03	sta $0329	                sta $0329
3109	.9fc4		68		pla		                pla
3110	.9fc5		29 03		and #$03	                and #$03
3111	.9fc7		8d 2d 03	sta $032d	                sta $032D
3112	.9fca		bd 00 87	lda $8700,x	                lda L8700,x
3113	.9fcd		9c 2b 03	stz $032b	                stz $032B
3114	.9fd0		cd 06 03	cmp $0306	                cmp $0306
3115	.9fd3		f0 0a		beq $9fdf	                beq L9D4B
3116	.9fd5		85 e0		sta $e0		                sta $E0
3117	.9fd7		1a		inc a		                inc a
3118	.9fd8		20 46 dc	jsr $dc46	                jsr LDC48
3119	.9fdb		b0 0d		bcs $9fea	                bcs L9D56
3120	.9fdd		a5 e0		lda $e0		                lda $E0
3121	.9fdf						L9D4B:
3122	.9fdf		cd 02 03	cmp $0302	                cmp $0302
3123	.9fe2		f0 ba		beq $9f9e	                beq L9D0A
3124	.9fe4		3a		dec a		                dec a
3125	.9fe5		20 46 dc	jsr $dc46	                jsr LDC48
3126	.9fe8		90 b4		bcc $9f9e	                bcc L9D0A
3127	.9fea						L9D56:
3128	.9fea		60		rts		                rts

3130	.9feb						L9D57:
3131	.9feb		ad 32 03	lda $0332	                lda $0332
3132	.9fee		a8		tay		                tay
3133	.9fef		cd 2c 03	cmp $032c	                cmp $032C
3134	.9ff2		ad 33 03	lda $0333	                lda $0333
3135	.9ff5		aa		tax		                tax
3136	.9ff6		ed 2d 03	sbc $032d	                sbc $032D
3137	.9ff9		b0 0a		bcs $a005	                bcs L9D71
3138	.9ffb		c8		iny		                iny
3139	.9ffc		d0 01		bne $9fff	                bne L9D6B
3140	.9ffe		e8		inx		                inx
3141	.9fff						L9D6B:
3142	.9fff		8c 2e 03	sty $032e	                sty $032E
3143	.a002		8e 2f 03	stx $032f	                stx $032F
3144	.a005						L9D71:
3145	.a005		60		rts		                rts

3147							;-------------------------------------------------------------------------

3149							                .if version>=500
3153							                .endif

3155							;-------------------------------------------------------------------------

3157							                .if version>=500
3161							                .endif

3163							;-------------------------------------------------------------------------
3164							;
3165							; Read byte from EEPROM by 0-based CMOS RAM offset (readCMOSByte) or
3166							; RTC register index (readRTCByte).
3167							;
3168							; (The number of RTC registers on the Compact is 0, so readRTCByte and
3169							; readCMOSByte use the same indexes. Nevertheless, the two routines
3170							; behave differently... presumably I still haven't quite got this bit
3171							; right.)
3172							;
3173							; entry:
3174							;
3175							; X = address to read from
3176							;
3177							; exit:
3178							;
3179							; Y = byte read

3181							                .if version>=500
3208							                .endif

3210							                .if version>=500
3264							                .endif

3266							;-------------------------------------------------------------------------

3268							                .if version>=500
3292							                .endif

3294							;-------------------------------------------------------------------------
3295							;
3296							; Transmit 1 bit over the I2C bus.
3297							;
3298							; preserves: P
3299							;
3300							                .if version>=500
3310							                .endif

3312							;-------------------------------------------------------------------------
3313							;
3314							; Set the I2C clock line high.
3315							;
3316							; preserves: A/C
3317							;
3318							                .if version>=500
3327							                .endif

3329							;-------------------------------------------------------------------------
3330							;
3331							; Set the I2C clock line low.
3332							;
3333							; preserves: A/C
3334							;
3335							                .if version>=500
3343							                .endif

3345							;-------------------------------------------------------------------------
3346							;
3347							; "A change in the state of the data line, from HIGH to LOW, while the
3348							; clock is HIGH, defines the START condition."
3349							;
3350							; preserves: P
3351							                .if version>=500
3365							                .endif

3367							;-------------------------------------------------------------------------
3368							;
3369							; Set the I2C data line low.
3370							;
3371							; preserves: A/C
3372							;
3373							                .if version>=500
3381							                .endif

3383							;-------------------------------------------------------------------------

3385							                .if version>=500
3412							                .endif

3414							;-------------------------------------------------------------------------
3415							;
3416							; Set the I2C data line to a particular value.
3417							;
3418							; entry:
3419							;
3420							; C = state of signal: 1 = high, 0 = low
3421							;
3422							; preserves: C

3424							                .if version>=500
3428							                .endif

3430							;-------------------------------------------------------------------------
3431							;
3432							; Set the I2C data line high.
3433							;
3434							; preserves: A/C
3435							;
3436							                .if version>=500
3444							                .endif

3446							;-------------------------------------------------------------------------
3447							;
3448							; Transmits 1 byte/8 bits over the I2C bus.
3449							;
3450							; entry: A = byte to transmit

3452							                .if version>=500
3465							                .endif

3467							;-------------------------------------------------------------------------

3469							                .if version>=500
3572							                .endif

3574							;-------------------------------------------------------------------------

3576							                .if version>=500
3587							                .endif

3589							;-------------------------------------------------------------------------

3591							                .if version>=500
3620							                .endif

3622							;-------------------------------------------------------------------------

3624							                .if version>=500
3626							                .endif

3628							;-------------------------------------------------------------------------

3630							                .if version==400
3631							                .include "ext.s65"

:10	;******  Processing file: src/ext.s65

1							; -*- comment-column:45; -*-

3	.a006						plotEllipseOutline:
4							                ; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP1
5	.a006		20 35 a1	jsr $a135	                jsr     ellipseInitialisation
6							                .if version<500
7	.a009		80 03		bra $a00e	                bra     startEllipseOutline
10							                .endif

12	.a00b						ellipseOutlineLoop:
13	.a00b		20 ef a1	jsr $a1ef	                jsr     updateEllipseIncrementally

15	.a00e						startEllipseOutline:
16	.a00e		a2 34		ldx #$34	                ldx     #VDUVariables.ew.pointC
17	.a010		a0 3c		ldy #$3c	                ldy     #VDUVariables.ew.pointA
18	.a012		20 ca d5	jsr $d5ca	                jsr     sortVDUVariableWords
19							                .if version!=350
20	.a015		a2 38		ldx #$38	                ldx     #VDUVariables.ew.leftPoint
21							                .endif
22							                .if version<500&&version!=350
23	.a017		bd 01 03	lda $0301,x	                lda     vduv+1,x
26							                .endif
27	.a01a		8d 43 03	sta $0343	                sta     vduv.ew.currentOffsetX+1
28							                .if version<500&&version!=350
29	.a01d		bd 00 03	lda $0300,x	                lda     vduv+0,x
30	.a020		aa		tax		                tax
33							                .endif

35	.a021						ellipseOutlineContinueRowLoop:
36	.a021		8e 42 03	stx $0342	                stx     vduv.ew.currentOffsetX+0
37	.a024		20 26 a3	jsr $a326	                jsr     outlineEllipsePlotOnePointAndReflection
38	.a027		e8		inx		                inx
39	.a028		d0 03		bne $a02d	                bne     +
40	.a02a		ee 43 03	inc $0343	                inc     vduv.ew.currentOffsetX+1
41	.a02d						+
42	.a02d		8a		txa		                txa
43	.a02e		d9 00 03	cmp $0300,y	                cmp     vduv+0,y
44	.a031		ad 43 03	lda $0343	                lda     vduv.ew.currentOffsetX+1
45	.a034		f9 01 03	sbc $0301,y	                sbc     vduv+1,y
46	.a037		30 e8		bmi $a021	                bmi     ellipseOutlineContinueRowLoop

48							                .if version<500&&version!=350
49	.a039		a2 36		ldx #$36	                ldx     #VDUVariables.ew.pointD
50	.a03b		a0 3e		ldy #$3e	                ldy     #VDUVariables.ew.pointB
51	.a03d		20 ca d5	jsr $d5ca	                jsr     sortVDUVariableWords
52	.a040		a0 3a		ldy #$3a	                ldy     #VDUVariables.ew.rightPoint
53	.a042		b9 01 03	lda $0301,y	                lda     vduv+1,y
54	.a045		8d 43 03	sta $0343	                sta     vduv.ew.currentOffsetX+1
55	.a048		b9 00 03	lda $0300,y	                lda     vduv+0,y
56	.a04b		a8		tay		                tay

58	.a04c						LBA46:
59	.a04c		8c 42 03	sty $0342	                sty     vduv.ew.currentOffsetX+0
60	.a04f		20 26 a3	jsr $a326	                jsr     outlineEllipsePlotOnePointAndReflection
61	.a052		98		tya		                tya
62	.a053		d0 03		bne $a058	                bne     +
63	.a055		ce 43 03	dec $0343	                dec     vduv.ew.currentOffsetX+1
64	.a058						+
65	.a058		88		dey		                dey
66	.a059		18		clc		                clc
67	.a05a		98		tya		                tya
68	.a05b		fd 00 03	sbc $0300,x	                sbc     vduv+0,x
69	.a05e		ad 43 03	lda $0343	                lda     vduv.ew.currentOffsetX+1
70	.a061		fd 01 03	sbc $0301,x	                sbc     vduv+1,x
71	.a064		10 e6		bpl $a04c	                bpl     LBA46
72	.a066		ad 2f 03	lda $032f	                lda     vduv.workspace._2F
73	.a069		10 a0		bpl $a00b	                bpl     ellipseOutlineLoop
74	.a06b		80 14		bra $a081	                bra     LBA7B

125							                .endif

127							;-------------------------------------------------------------------------

129	.a06d						plotEllipseFilled:
130	.a06d		20 35 a1	jsr $a135	                jsr     ellipseInitialisation
131	.a070		80 03		bra $a075	                bra     startFilledEllipse


134	.a072						filledEllipseLoop:
135	.a072		20 ef a1	jsr $a1ef	                jsr     updateEllipseIncrementally

137	.a075						startFilledEllipse:
138	.a075		a2 3a		ldx #$3a	                ldx     #VDUVariables.ew.rightPoint
139	.a077		a0 38		ldy #$38	                ldy     #VDUVariables.ew.leftPoint
140	.a079		20 8d a0	jsr $a08d	                jsr     fillEllipseOneRowAndReflection
141	.a07c		ad 2f 03	lda $032f	                lda     vduv.workspace._2F
142	.a07f		10 f1		bpl $a072	                bpl     filledEllipseLoop

144	.a081						LBA7B:
145	.a081		ee 4d 88	inc $884d	                inc     ellipseCountHeight+0
146	.a084		d0 03		bne $a089	                bne     LBA83
147	.a086		ee 4e 88	inc $884e	                inc     ellipseCountHeight+1

149	.a089						LBA83:
150	.a089		a2 3e		ldx #$3e	                ldx     #VDUVariables.ew.pointB
151	.a08b		a0 3c		ldy #$3c	                ldy     #VDUVariables.ew.pointA

153	.a08d						fillEllipseOneRowAndReflection:
154	.a08d		da		phx		                phx
155	.a08e		5a		phy		                phy
156	.a08f		18		clc		                clc
157	.a090		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
158	.a093		79 00 03	adc $0300,y	                adc     vduv+0,y
159	.a096		8d 40 03	sta $0340	                sta     vduv.workspace._40
160	.a099		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
161	.a09c		79 01 03	adc $0301,y	                adc     vduv+1,y
162	.a09f		8d 41 03	sta $0341	                sta     vduv.workspace._41
163	.a0a2		18		clc		                clc
164	.a0a3		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
165	.a0a6		7d 00 03	adc $0300,x	                adc     vduv+0,x
166	.a0a9		8d 44 03	sta $0344	                sta     vduv.workspace._44
167	.a0ac		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
168	.a0af		7d 01 03	adc $0301,x	                adc     vduv+1,x
169	.a0b2		8d 45 03	sta $0345	                sta     vduv.workspace._45
170	.a0b5		18		clc		                clc
171	.a0b6		ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
172	.a0b9		6d 4d 88	adc $884d	                adc     ellipseCountHeight+0
173	.a0bc		a8		tay		                tay
174	.a0bd		ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
175	.a0c0		6d 4e 88	adc $884e	                adc     ellipseCountHeight+1
176	.a0c3		20 04 a1	jsr $a104	                jsr     LBAFE
177	.a0c6		7a		ply		                ply
178	.a0c7		fa		plx		                plx
179	.a0c8		ad 4d 88	lda $884d	                lda     ellipseCountHeight+0
180	.a0cb		0d 4e 88	ora $884e	                ora     ellipseCountHeight+1
181	.a0ce		f0 47		beq $a117	                beq     rtsBB11
182	.a0d0		38		sec		                sec
183	.a0d1		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
184	.a0d4		fd 00 03	sbc $0300,x	                sbc     vduv+0,x
185	.a0d7		8d 40 03	sta $0340	                sta     vduv.workspace._40
186	.a0da		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
187	.a0dd		fd 01 03	sbc $0301,x	                sbc     vduv+1,x
188	.a0e0		8d 41 03	sta $0341	                sta     vduv.workspace._41
189	.a0e3		38		sec		                sec
190	.a0e4		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
191	.a0e7		f9 00 03	sbc $0300,y	                sbc     vduv+0,y
192	.a0ea		8d 44 03	sta $0344	                sta     vduv.workspace._44
193	.a0ed		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
194	.a0f0		f9 01 03	sbc $0301,y	                sbc     vduv+1,y
195	.a0f3		8d 45 03	sta $0345	                sta     vduv.workspace._45
196	.a0f6		38		sec		                sec
197	.a0f7		ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
198	.a0fa		ed 4d 88	sbc $884d	                sbc     ellipseCountHeight+0
199	.a0fd		a8		tay		                tay
200	.a0fe		ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
201	.a101		ed 4e 88	sbc $884e	                sbc     ellipseCountHeight+1

203	.a104						LBAFE:
204	.a104		8c 46 03	sty $0346	                sty     vduv.workspace._46
205	.a107		8c 42 03	sty $0342	                sty     vduv.ew.currentOffsetX+0
206	.a10a		8d 47 03	sta $0347	                sta     vduv.workspace._47
207	.a10d		8d 43 03	sta $0343	                sta     vduv.ew.currentOffsetX+1
208	.a110		a2 44		ldx #$44	                ldx     #VDUVariables.ew.pointF
209	.a112		a0 40		ldy #$40	                ldy     #VDUVariables.ew.pointE
210	.a114		4c e6 da	jmp $dae6	                jmp     LDAE8





216	.a117						rtsBB11:
217	.a117		60		rts		                rts




222	.a118						LBB12:
223	.a118		68		pla		                pla
224	.a119		68		pla		                pla
225	.a11a		9c 4d 88	stz $884d	                stz     ellipseCountHeight+0
226	.a11d		9c 4e 88	stz $884e	                stz     ellipseCountHeight+1
227	.a120		a2 29		ldx #$29	                ldx     #VDUVariables.workspace._29
228	.a122		a0 40		ldy #$40	                ldy     #VDUVariables.ew.pointE
229	.a124		20 00 a4	jsr $a400	                jsr     negateVDUVariableXIntoY
230	.a127		a2 29		ldx #$29	                ldx     #VDUVariables.workspace._29
231	.a129		a0 44		ldy #$44	                ldy     #VDUVariables.ew.pointF
232	.a12b		20 0a c9	jsr $c90a	                jsr     copyTwoBytesWithinVDUVariables
233	.a12e		a2 44		ldx #$44	                ldx     #VDUVariables.ew.pointF
234	.a130		a0 40		ldy #$40	                ldy     #VDUVariables.ew.pointE
235	.a132		4c 8d a0	jmp $a08d	                jmp     fillEllipseOneRowAndReflection

237	.a135						ellipseInitialisation:
238							                ; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP5
239	.a135		a0 24		ldy #$24	                ldy     #VDUVariables.graphicsCursorPixelsX
240	.a137		a2 14		ldx #$14	                ldx     #VDUVariables.oldGraphicsCursorPixelsX
241	.a139		a9 29		lda #$29	                lda     #VDUVariables.workspace._29
242	.a13b		20 76 d6	jsr $d676	                jsr     LD678
243	.a13e		9c 28 03	stz $0328	                stz     vduv.ew.aspectRatio+0
244	.a141		a0 22		ldy #$22	                ldy     #VDUVariables.queueEnd-2
245	.a143		a2 16		ldx #$16	                ldx     #VDUVariables.oldGraphicsCursorPixelsY
246	.a145		a9 2e		lda #$2e	                lda     #VDUVariables.ew.halfHeightCounter
247	.a147		20 76 d6	jsr $d676	                jsr     LD678
248	.a14a		ad 2e 03	lda $032e	                lda     vduv.ew.halfHeightCounter+0
249	.a14d		0d 2f 03	ora $032f	                ora     vduv.ew.halfHeightCounter+1
250	.a150		f0 c6		beq $a118	                beq     LBB12
251	.a152		2a		rol a		                rol     a
252	.a153		8d 41 88	sta $8841	                sta     L8841
253	.a156		a0 20		ldy #$20	                ldy     #VDUVariables.queueEnd-4
254	.a158		a2 14		ldx #$14	                ldx     #VDUVariables.oldGraphicsCursorPixelsX
255	.a15a		a9 2c		lda #$2c	                lda     #VDUVariables.ew.shear+1
256	.a15c		20 76 d6	jsr $d676	                jsr     LD678
257	.a15f		9c 2b 03	stz $032b	                stz     vduv.ew.shear+0
258	.a162		2a		rol a		                rol     a
259	.a163		4d 41 88	eor $8841	                eor     ellipseSignFlag
260	.a166		29 01		and #$01	                and     #1
261	.a168		8d 41 88	sta $8841	                sta     ellipseSignFlag
262	.a16b		a2 28		ldx #$28	                ldx     #VDUVariables.ew.aspectRatio
263	.a16d		a0 2e		ldy #$2e	                ldy     #VDUVariables.ew.halfHeightCounter
264	.a16f		20 89 a3	jsr $a389	                jsr     LBD83
265	.a172		a2 2b		ldx #$2b	                ldx     #VDUVariables.ew.shear
266	.a174		a0 2e		ldy #$2e	                ldy     #VDUVariables.ew.halfHeightCounter
267	.a176		20 89 a3	jsr $a389	                jsr     LBD83
268	.a179		ad 41 88	lda $8841	                lda     L8841
269	.a17c		f0 0e		beq $a18c	                beq     LBB86
270	.a17e		38		sec		                sec
271	.a17f		a0 fd		ldy #$fd	                ldy     #$fd

273	.a181						LBB7B:
274	.a181		a9 00		lda #$00	                lda     #0
275	.a183		f9 2e 02	sbc $022e,y	                sbc     vduv.workspace._2B-$fd,y
276	.a186		99 2e 02	sta $022e,y	                sta     vduv.workspace._2B-$fd,y
277	.a189		c8		iny		                iny
278	.a18a		d0 f5		bne $a181	                bne     LBB7B

280	.a18c						LBB86:
281	.a18c		ad 2e 03	lda $032e	                lda     vduv.workspace._2E
282	.a18f		8d 3c 88	sta $883c	                sta     L883C
283	.a192		ad 2f 03	lda $032f	                lda     vduv.workspace._2F
284	.a195		20 cc d4	jsr $d4cc	                jsr     LD4CE
285	.a198		a0 03		ldy #$03	                ldy     #3

287	.a19a						LBB94:
288	.a19a		b9 40 88	lda $8840,y	                lda     $8840,y
289	.a19d		99 30 03	sta $0330,y	                sta     vduv.workspace._30,y
290	.a1a0		88		dey		                dey
291	.a1a1		10 f7		bpl $a19a	                bpl     LBB94
292	.a1a3		a2 0a		ldx #$0a	                ldx     #$a

294	.a1a5						LBB9F:
295	.a1a5		9e 42 88	stz $8842,x	                stz     $8842,x
296	.a1a8		ca		dex		                dex
297	.a1a9		10 fa		bpl $a1a5	                bpl     LBB9F
298	.a1ab		ee 45 88	inc $8845	                inc     L8845
299	.a1ae		20 1e a2	jsr $a21e	                jsr     updateEllipse
300	.a1b1		20 1e a2	jsr $a21e	                jsr     updateEllipse
301	.a1b4		9c 4d 88	stz $884d	                stz     ellipseCountHeight+0
302	.a1b7		9c 4e 88	stz $884e	                stz     ellipseCountHeight+1
303	.a1ba		a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
304	.a1bc		a0 36		ldy #$36	                ldy     #VDUVariables.ew.pointD
305	.a1be		20 00 a4	jsr $a400	                jsr     negateVDUVariableXIntoY
306	.a1c1		a2 3e		ldx #$3e	                ldx     #VDUVariables.ew.pointB
307	.a1c3		a0 34		ldy #$34	                ldy     #VDUVariables.ew.pointC
308	.a1c5		20 00 a4	jsr $a400	                jsr     negateVDUVariableXIntoY
309	.a1c8		a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
310	.a1ca		a0 3a		ldy #$3a	                ldy     #VDUVariables.ew.rightPoint
311	.a1cc		20 d4 d5	jsr $d5d4	                jsr     compareVDUVariableWords
312	.a1cf		10 07		bpl $a1d8	                bpl     LBBD2
313	.a1d1		20 0a c9	jsr $c90a	                jsr     copyTwoBytesWithinVDUVariables
314	.a1d4		a2 36		ldx #$36	                ldx     #VDUVariables.ew.pointD
315	.a1d6		80 12		bra $a1ea	                bra     LBBE4


318	.a1d8						LBBD2:
319	.a1d8		a2 38		ldx #$38	                ldx     #VDUVariables.ew.leftPoint
320	.a1da		a0 3e		ldy #$3e	                ldy     #VDUVariables.ew.pointB
321	.a1dc		20 d4 d5	jsr $d5d4	                jsr     compareVDUVariableWords
322	.a1df		10 3c		bpl $a21d	                bpl     rtsBC17
323	.a1e1		a2 34		ldx #$34	                ldx     #VDUVariables.ew.pointC
324	.a1e3		a0 3a		ldy #$3a	                ldy     #VDUVariables.ew.rightPoint
325	.a1e5		20 0a c9	jsr $c90a	                jsr     copyTwoBytesWithinVDUVariables
326	.a1e8		a2 3e		ldx #$3e	                ldx     #VDUVariables.ew.pointB

328	.a1ea						LBBE4:
329	.a1ea		a0 38		ldy #$38	                ldy     #VDUVariables.ew.leftPoint
330	.a1ec		4c 0a c9	jmp $c90a	                jmp     copyTwoBytesWithinVDUVariables

332							;-------------------------------------------------------------------------
333							;
334							; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP6
335							;

337	.a1ef						updateEllipseIncrementally:
338	.a1ef		20 1e a2	jsr $a21e	                jsr     updateEllipse
339	.a1f2		a0 3a		ldy #$3a	                ldy     #VDUVariables.ew.rightPoint
340	.a1f4		a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
341	.a1f6		20 d4 d5	jsr $d5d4	                jsr     compareVDUVariableWords
342	.a1f9		10 0d		bpl $a208	                bpl     LBC02
343	.a1fb		ad 3c 03	lda $033c	                lda     vduv.ew.pointA+0
344	.a1fe		8d 3a 03	sta $033a	                sta     vduv.ew.rightPoint+0
345	.a201		ad 3d 03	lda $033d	                lda     vduv.ew.pointA+1
346	.a204		8d 3b 03	sta $033b	                sta     vduv.ew.rightPoint+1
347	.a207		60		rts		                rts

349	.a208						LBC02:
350	.a208		a2 38		ldx #$38	                ldx     #VDUVariables.ew.leftPoint
351	.a20a		a0 3e		ldy #$3e	                ldy     #VDUVariables.ew.pointB
352	.a20c		20 d4 d5	jsr $d5d4	                jsr     compareVDUVariableWords
353	.a20f		10 0c		bpl $a21d	                bpl     rtsBC17
354	.a211		ad 3e 03	lda $033e	                lda     vduv.ew.pointB+0
355	.a214		8d 38 03	sta $0338	                sta     vduv.ew.leftPoint+0
356	.a217		ad 3f 03	lda $033f	                lda     vduv.ew.pointB+1
357	.a21a		8d 39 03	sta $0339	                sta     vduv.ew.leftPoint+1

359	.a21d						rtsBC17:
360	.a21d		60		rts		                rts

362							;-------------------------------------------------------------------------
363							;
364							; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP7
365							;

367	.a21e						updateEllipse:
368	.a21e		a2 38		ldx #$38	                ldx     #VDUVariables.ew.leftPoint
369	.a220		a0 34		ldy #$34	                ldy     #VDUVariables.ew.pointC
370	.a222		20 1c c9	jsr $c91c	                jsr     copyFourBytesWithinVDUVariables
371	.a225		a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
372	.a227		a0 38		ldy #$38	                ldy     #VDUVariables.ew.leftPoint
373	.a229		20 1c c9	jsr $c91c	                jsr     copyFourBytesWithinVDUVariables

375	.a22c		38		sec		                sec
376	.a22d		ad 30 03	lda $0330	                lda     vduv.ew.halfHeightSquared+0
377	.a230		ed 49 88	sbc $8849	                sbc     ellipseCountSquares+0
378	.a233		8d 36 88	sta $8836	                sta     sqrtNumber+2
379	.a236		ad 31 03	lda $0331	                lda     vduv.ew.halfHeightSquared+1
380	.a239		ed 4a 88	sbc $884a	                sbc     ellipseCountSquares+1
381	.a23c		8d 37 88	sta $8837	                sta     sqrtNumber+3
382	.a23f		ad 32 03	lda $0332	                lda     vduv.ew.halfHeightSquared+2
383	.a242		ed 4b 88	sbc $884b	                sbc     ellipseCountSquares+2
384	.a245		8d 38 88	sta $8838	                sta     sqrtNumber+4
385	.a248		ad 33 03	lda $0333	                lda     vduv.ew.halfHeightSquared+3
386	.a24b		ed 4c 88	sbc $884c	                sbc     ellipseCountSquares+3
387	.a24e		8d 39 88	sta $8839	                sta     sqrtNumber+5
388	.a251		9c 35 88	stz $8835	                stz     sqrtNumber+1
389	.a254		9c 34 88	stz $8834	                stz     sqrtNumber+0
390	.a257		20 51 a4	jsr $a451	                jsr     LBE4B

392	.a25a		ad 28 03	lda $0328	                lda     vduv.ew.aspectRatio+0
393	.a25d		8d 34 88	sta $8834	                sta     multiplier+0
394	.a260		ad 29 03	lda $0329	                lda     vduv.ew.aspectRatio+1
395	.a263		8d 35 88	sta $8835	                sta     multiplier+1
396	.a266		ad 2a 03	lda $032a	                lda     vduv.ew.aspectRatio+2
397	.a269		8d 36 88	sta $8836	                sta     multiplier+2
398	.a26c		20 12 a4	jsr $a412	                jsr     multiply24x24

400	.a26f		18		clc		                clc
401	.a270		ad 42 88	lda $8842	                lda     ellipseAccumulatedShear+0
402	.a273		6d 35 88	adc $8835	                adc     product+1
403	.a276		08		php		                php
404	.a277		ad 43 88	lda $8843	                lda     ellipseAccumulatedShear+1
405	.a27a		6d 36 88	adc $8836	                adc     product+2
406	.a27d		8d 3e 03	sta $033e	                sta     vduv.ew.pointB+0
407	.a280		ad 44 88	lda $8844	                lda     ellipseAccumulatedShear+2
408	.a283		6d 37 88	adc $8837	                adc     product+3
409	.a286		8d 3f 03	sta $033f	                sta     vduv.ew.pointB+1
410	.a289		28		plp		                plp
411	.a28a		10 08		bpl $a294	                bpl     +
412	.a28c		ee 3e 03	inc $033e	                inc     vduv.ew.pointB+0
413	.a28f		d0 03		bne $a294	                bne     +
414	.a291		ee 3f 03	inc $033f	                inc     vduv.ew.pointB+1
415	.a294						+
416	.a294		38		sec		                sec
417	.a295		ad 42 88	lda $8842	                lda     ellipseAccumulatedShear+0
418	.a298		ed 35 88	sbc $8835	                sbc     product+1
419	.a29b		08		php		                php
420	.a29c		ad 43 88	lda $8843	                lda     ellipseAccumulatedShear+1
421	.a29f		ed 36 88	sbc $8836	                sbc     product+2
422	.a2a2		8d 3c 03	sta $033c	                sta     vduv.ew.pointA+0
423	.a2a5		ad 44 88	lda $8844	                lda     ellipseAccumulatedShear+2
424	.a2a8		ed 37 88	sbc $8837	                sbc     product+3
425	.a2ab		8d 3d 03	sta $033d	                sta     vduv.ew.pointA+1
426	.a2ae		28		plp		                plp
427	.a2af		10 08		bpl $a2b9	                bpl     +
428	.a2b1		ee 3c 03	inc $033c	                inc     vduv.ew.pointA+0
429	.a2b4		d0 03		bne $a2b9	                bne     +
430	.a2b6		ee 3d 03	inc $033d	                inc     vduv.ew.pointA+1
431	.a2b9						+

433	.a2b9		18		clc		                clc
434	.a2ba		ad 45 88	lda $8845	                lda     ellipseCountOddNumbers+0
435	.a2bd		6d 49 88	adc $8849	                adc     ellipseCountSquares+0
436	.a2c0		8d 49 88	sta $8849	                sta     ellipseCountSquares+0
437	.a2c3		ad 46 88	lda $8846	                lda     ellipseCountOddNumbers+1
438	.a2c6		6d 4a 88	adc $884a	                adc     ellipseCountSquares+1
439	.a2c9		8d 4a 88	sta $884a	                sta     ellipseCountSquares+1
440	.a2cc		ad 47 88	lda $8847	                lda     ellipseCountOddNumbers+2
441	.a2cf		6d 4b 88	adc $884b	                adc     ellipseCountSquares+2
442	.a2d2		8d 4b 88	sta $884b	                sta     ellipseCountSquares+2
443	.a2d5		ad 48 88	lda $8848	                lda     ellipseCountOddNumbers+3
444	.a2d8		6d 4c 88	adc $884c	                adc     ellipseCountSquares+3
445	.a2db		8d 4c 88	sta $884c	                sta     ellipseCountSquares+3
446	.a2de		18		clc		                clc
447	.a2df		a9 02		lda #$02	                lda     #2
448	.a2e1		6d 45 88	adc $8845	                adc     ellipseCountOddNumbers+0
449	.a2e4		8d 45 88	sta $8845	                sta     ellipseCountOddNumbers+0
450	.a2e7		90 0d		bcc $a2f6	                bcc     +
451	.a2e9		ee 46 88	inc $8846	                inc     ellipseCountOddNumbers+1
452	.a2ec		d0 08		bne $a2f6	                bne     +
453	.a2ee		ee 47 88	inc $8847	                inc     ellipseCountOddNumbers+2
454	.a2f1		d0 03		bne $a2f6	                bne     +
455	.a2f3		ee 48 88	inc $8848	                inc     ellipseCountOddNumbers+3
456	.a2f6						+
457	.a2f6		18		clc		                clc
458	.a2f7		ad 42 88	lda $8842	                lda     ellipseAccumulatedShear+0
459	.a2fa		6d 2b 03	adc $032b	                adc     vduv.ew.shear+0
460	.a2fd		8d 42 88	sta $8842	                sta     ellipseAccumulatedShear+0
461	.a300		ad 43 88	lda $8843	                lda     ellipseAccumulatedShear+1
462	.a303		6d 2c 03	adc $032c	                adc     vduv.ew.shear+1
463	.a306		8d 43 88	sta $8843	                sta     ellipseAccumulatedShear+1
464	.a309		ad 44 88	lda $8844	                lda     ellipseAccumulatedShear+2
465	.a30c		6d 2d 03	adc $032d	                adc     vduv.ew.shear+2
466	.a30f		8d 44 88	sta $8844	                sta     ellipseAccumulatedShear+2
467	.a312		ee 4d 88	inc $884d	                inc     ellipseCountHeight+0
468	.a315		d0 03		bne $a31a	                bne     +
469	.a317		ee 4e 88	inc $884e	                inc     ellipseCountHeight+1
470	.a31a						+
471	.a31a		ad 2e 03	lda $032e	                lda     vduv.workspace._2E
472	.a31d		d0 03		bne $a322	                bne     +
473	.a31f		ce 2f 03	dec $032f	                dec     vduv.workspace._2F
474	.a322						+
475	.a322		ce 2e 03	dec $032e	                dec     vduv.workspace._2E
476	.a325		60		rts		                rts

478							;-------------------------------------------------------------------------
479							;
480							; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP8
481							;
482	.a326						outlineEllipsePlotOnePointAndReflection: .block
483	.a326		da		phx		                phx
484	.a327		5a		phy		                phy

486	.a328		18		clc		                clc
487	.a329		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
488	.a32c		6d 42 03	adc $0342	                adc     vduv.ew.currentOffsetX+0
489	.a32f		8d 44 03	sta $0344	                sta     vduv.ew.plotPointX+0
490	.a332		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
491	.a335		6d 43 03	adc $0343	                adc     vduv.ew.currentOffsetX+1
492	.a338		8d 45 03	sta $0345	                sta     vduv.ew.plotPointX+1

494	.a33b		18		clc		                clc
495	.a33c		ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
496	.a33f		6d 4d 88	adc $884d	                adc     ellipseCountHeight+0
497	.a342		8d 46 03	sta $0346	                sta     vduv.ew.plotPointY+0
498	.a345		ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
499	.a348		6d 4e 88	adc $884e	                adc     ellipseCountHeight+1
500	.a34b		8d 47 03	sta $0347	                sta     vduv.ew.plotPointY+1

502	.a34e		a2 44		ldx #$44	                ldx     #VDUVariables.ew.plotPointX
503	.a350		20 4a db	jsr $db4a	                jsr     plotPointInternal

505	.a353		ad 4d 88	lda $884d	                lda     ellipseCountHeight+0
506	.a356		0d 4e 88	ora $884e	                ora     ellipseCountHeight+1
507	.a359		f0 2b		beq $a386	                beq     done

509	.a35b		38		sec		                sec
510	.a35c		ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
511	.a35f		ed 42 03	sbc $0342	                sbc     vduv.ew.currentOffsetX+0
512	.a362		8d 44 03	sta $0344	                sta     vduv.ew.plotPointX+0
513	.a365		ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
514	.a368		ed 43 03	sbc $0343	                sbc     vduv.ew.currentOffsetX+1
515	.a36b		8d 45 03	sta $0345	                sta     vduv.ew.plotPointX+1

517	.a36e		38		sec		                sec
518	.a36f		ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
519	.a372		ed 4d 88	sbc $884d	                sbc     ellipseCountHeight+0
520	.a375		8d 46 03	sta $0346	                sta     vduv.ew.plotPointY+0
521	.a378		ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
522	.a37b		ed 4e 88	sbc $884e	                sbc     ellipseCountHeight+1
523	.a37e		8d 47 03	sta $0347	                sta     vduv.ew.plotPointY+1

525	.a381		a2 44		ldx #$44	                ldx     #VDUVariables.ew.plotPointX
526	.a383		20 4a db	jsr $db4a	                jsr     plotPointInternal
527	.a386						done:
528	.a386		7a		ply		                ply
529	.a387		fa		plx		                plx
530	.a388		60		rts		                rts
531							                .endblock

533							;-------------------------------------------------------------------------

535	.a389						LBD83:
536	.a389		da		phx		                phx
537	.a38a		b9 00 03	lda $0300,y	                lda     vduv+0,y
538	.a38d		8d 3f 88	sta $883f	                sta     L883F
539	.a390		b9 01 03	lda $0301,y	                lda     vduv+1,y
540	.a393		8d 40 88	sta $8840	                sta     L8840
541	.a396		a0 18		ldy #$18	                ldy     #$18 ;not VDUVariables.textCursorXPosition?
542	.a398		bd 00 03	lda $0300,x	                lda     vduv+0,x
543	.a39b		8d 3a 88	sta $883a	                sta     L883A
544	.a39e		bd 01 03	lda $0301,x	                lda     vduv+1,x
545	.a3a1		8d 3b 88	sta $883b	                sta     L883B
546	.a3a4		bd 02 03	lda $0302,x	                lda     vduv+2,x
547	.a3a7		30 0c		bmi $a3b5	                bmi     LBDAF

549	.a3a9						LBDA3:
550	.a3a9		88		dey		                dey
551	.a3aa		f0 52		beq $a3fe	                beq     LBDF8
552	.a3ac		0e 3a 88	asl $883a	                asl     L883A
553	.a3af		2e 3b 88	rol $883b	                rol     L883B
554	.a3b2		2a		rol a		                rol     a
555	.a3b3		10 f4		bpl $a3a9	                bpl     LBDA3

557	.a3b5						LBDAF:
558	.a3b5		8d 3c 88	sta $883c	                sta     L883C
559	.a3b8		9c 3d 88	stz $883d	                stz     L883D
560	.a3bb		9c 3e 88	stz $883e	                stz     L883E
561	.a3be		18		clc		                clc

563	.a3bf						LBDB9:
564	.a3bf		2e 3a 88	rol $883a	                rol     L883A
565	.a3c2		2e 3b 88	rol $883b	                rol     L883B
566	.a3c5		2e 3c 88	rol $883c	                rol     L883C
567	.a3c8		2e 3d 88	rol $883d	                rol     L883D
568	.a3cb		2e 3e 88	rol $883e	                rol     L883E
569	.a3ce		38		sec		                sec
570	.a3cf		ad 3d 88	lda $883d	                lda     L883D
571	.a3d2		ed 3f 88	sbc $883f	                sbc     L883F
572	.a3d5		aa		tax		                tax
573	.a3d6		ad 3e 88	lda $883e	                lda     L883E
574	.a3d9		ed 40 88	sbc $8840	                sbc     L8840
575	.a3dc		90 06		bcc $a3e4	                bcc     LBDDE
576	.a3de		8e 3d 88	stx $883d	                stx     L883D
577	.a3e1		8d 3e 88	sta $883e	                sta     L883E

579	.a3e4						LBDDE:
580	.a3e4		88		dey		                dey
581	.a3e5		d0 d8		bne $a3bf	                bne     LBDB9
582	.a3e7		fa		plx		                plx
583	.a3e8		ad 3a 88	lda $883a	                lda     L883A
584	.a3eb		2a		rol a		                rol     a
585	.a3ec		9d 00 03	sta $0300,x	                sta     vduv+0,x
586	.a3ef		ad 3b 88	lda $883b	                lda     L883B
587	.a3f2		2a		rol a		                rol     a
588	.a3f3		9d 01 03	sta $0301,x	                sta     vduv+1,x
589	.a3f6		ad 3c 88	lda $883c	                lda     L883C
590	.a3f9		2a		rol a		                rol     a
591	.a3fa		9d 02 03	sta $0302,x	                sta     vduv+2,x
592	.a3fd		60		rts		                rts


595	.a3fe						LBDF8:
596	.a3fe		fa		plx		                plx
597	.a3ff		60		rts		                rts




602							;-------------------------------------------------------------------------
603							;
604							; https://tobylobster.github.io/GXR-pages/gxr/S-s24.html#SP3
605							;

607	.a400						negateVDUVariableXIntoY:
608	.a400		38		sec		                sec
609	.a401		a9 00		lda #$00	                lda     #0
610	.a403		fd 00 03	sbc $0300,x	                sbc     vduv+0,x
611	.a406		99 00 03	sta $0300,y	                sta     vduv+0,y
612	.a409		a9 00		lda #$00	                lda     #0
613	.a40b		fd 01 03	sbc $0301,x	                sbc     vduv+1,x
614	.a40e		99 01 03	sta $0301,y	                sta     vduv+1,y
615	.a411		60		rts		                rts

617							;-------------------------------------------------------------------------

619	.a412						multiply24x24:
620	.a412		a0 17		ldy #$17	                ldy     #23
621	.a414		9c 39 88	stz $8839	                stz     product+5
622	.a417		9c 38 88	stz $8838	                stz     product+4
623	.a41a		9c 37 88	stz $8837	                stz     product+3
624	.a41d		4e 36 88	lsr $8836	                lsr     multiplier+2
625	.a420		6e 35 88	ror $8835	                ror     multiplier+1
626	.a423		6e 34 88	ror $8834	                ror     multiplier+0

628	.a426						LBE20:
629	.a426		90 1c		bcc $a444	                bcc     LBE3E
630	.a428		18		clc		                clc
631	.a429		ad 30 88	lda $8830	                lda     multiplicand+0
632	.a42c		6d 37 88	adc $8837	                adc     product+3
633	.a42f		8d 37 88	sta $8837	                sta     product+3
634	.a432		ad 31 88	lda $8831	                lda     multiplicand+1
635	.a435		6d 38 88	adc $8838	                adc     product+4
636	.a438		8d 38 88	sta $8838	                sta     product+4
637	.a43b		ad 32 88	lda $8832	                lda     multiplicand+2
638	.a43e		6d 39 88	adc $8839	                adc     product+5
639	.a441		8d 39 88	sta $8839	                sta     product+5

641	.a444						LBE3E:
642	.a444		18		clc		                clc
643	.a445		a2 05		ldx #$05	                ldx     #5

645	.a447						LBE41:
646	.a447		7e 34 88	ror $8834,x	                ror     product,x
647	.a44a		ca		dex		                dex
648	.a44b		10 fa		bpl $a447	                bpl     LBE41
649	.a44d		88		dey		                dey
650	.a44e		10 d6		bpl $a426	                bpl     LBE20
651	.a450		60		rts		                rts

653							;-------------------------------------------------------------------------

655	.a451						LBE4B:
656	.a451		a2 03		ldx #$03	                ldx     #3

658	.a453						LBE4D:
659	.a453		9e 30 88	stz $8830,x	                stz     $8830,x
660	.a456		74 dc		stz $dc,x	                stz     ZTEMPB,x
661	.a458		ca		dex		                dex
662	.a459		10 f8		bpl $a453	                bpl     LBE4D
663	.a45b		a0 05		ldy #$05	                ldy     #5

665	.a45d						LBE57:
666	.a45d		b9 34 88	lda $8834,y	                lda     $8834,y
667	.a460		85 da		sta $da		                sta     ZTEMP+0
668	.a462		5a		phy		                phy
669	.a463		a0 03		ldy #$03	                ldy     #3

671	.a465						LBE5F:
672	.a465		5a		phy		                phy
673	.a466		38		sec		                sec
674	.a467		2e 30 88	rol $8830	                rol     L8830
675	.a46a		2e 31 88	rol $8831	                rol     L8831
676	.a46d		2e 32 88	rol $8832	                rol     L8832
677	.a470		2e 33 88	rol $8833	                rol     L8833
678	.a473		a2 01		ldx #$01	                ldx     #1
679	.a475		a5 dc		lda $dc		                lda     ZTEMPB+0

681	.a477						LBE71:
682	.a477		06 da		asl $da		                asl     ZTEMP+0
683	.a479		2a		rol a		                rol     a
684	.a47a		26 dd		rol $dd		                rol     ZTEMPB+1
685	.a47c		26 de		rol $de		                rol     ZTEMPC+0
686	.a47e		26 df		rol $df		                rol     ZTEMPC+1
687	.a480		ca		dex		                dex
688	.a481		10 f4		bpl $a477	                bpl     LBE71
689	.a483		85 dc		sta $dc		                sta     ZTEMPB+0
690	.a485		38		sec		                sec
691	.a486		ed 30 88	sbc $8830	                sbc     L8830
692	.a489		48		pha		                pha
693	.a48a		a5 dd		lda $dd		                lda     ZTEMPB+1
694	.a48c		ed 31 88	sbc $8831	                sbc     L8831
695	.a48f		aa		tax		                tax
696	.a490		a5 de		lda $de		                lda     ZTEMPC+0
697	.a492		ed 32 88	sbc $8832	                sbc     L8832
698	.a495		a8		tay		                tay
699	.a496		a5 df		lda $df		                lda     ZTEMPC+1
700	.a498		ed 33 88	sbc $8833	                sbc     L8833
701	.a49b		90 0e		bcc $a4ab	                bcc     LBEA5
702	.a49d		85 df		sta $df		                sta     ZTEMPC+1
703	.a49f		84 de		sty $de		                sty     ZTEMPC+0
704	.a4a1		86 dd		stx $dd		                stx     ZTEMPB+1
705	.a4a3		68		pla		                pla
706	.a4a4		85 dc		sta $dc		                sta     ZTEMPB+0
707	.a4a6		ee 30 88	inc $8830	                inc     L8830
708	.a4a9		80 04		bra $a4af	                bra     LBEA9


711	.a4ab						LBEA5:
712	.a4ab		68		pla		                pla
713	.a4ac		ce 30 88	dec $8830	                dec     L8830

715	.a4af						LBEA9:
716	.a4af		7a		ply		                ply
717	.a4b0		88		dey		                dey
718	.a4b1		10 b2		bpl $a465	                bpl     LBE5F
719	.a4b3		7a		ply		                ply
720	.a4b4		88		dey		                dey
721	.a4b5		10 a6		bpl $a45d	                bpl     LBE57
722	.a4b7		4e 33 88	lsr $8833	                lsr     L8833
723	.a4ba		6e 32 88	ror $8832	                ror     L8832
724	.a4bd		6e 31 88	ror $8831	                ror     L8831
725	.a4c0		6e 30 88	ror $8830	                ror     L8830
726	.a4c3		60		rts		                rts

728							;-------------------------------------------------------------------------
729							;
730							; 184-191 = Move/copy rectangle [MasRef E.3-31]
731							;
732							; The normal interpretation of <p> does not apply in this group of
733							; plot codes and the meanings are as follows:
734							;
735							; 184, 185 - %1011100x - Move rectangle, relative
736							; 186, 187 - %1011101x - Copy rectangle, relative
737							; 188, 189 - %1011110x - Move rectangle, absolute
738							; 190, 191 - %1011111x - Copy rectangle, absolute
739							;
740	.a4c4						plotMoveOrCopyRectangle:
741	.a4c4		29 02		and #$02	                and     #2
742	.a4c6		8d 45 03	sta $0345	                sta     vduv.mocr.copy

744	.a4c9		20 4f c9	jsr $c94f	                jsr     prepareForPlotBackground

746	.a4cc		a2 14		ldx #$14	                ldx     #VDUVariables.oldGraphicsCursorPixels
747	.a4ce		20 e4 c8	jsr $c8e4	                jsr     prepareAABB

749							                ; mocr.dest.min = PLOT coordinate
750	.a4d1		a0 34		ldy #$34	                ldy     #VDUVariables.mocr.dest.min
751	.a4d3		20 14 c9	jsr $c914	                jsr     copyLastFourVDUQueueBytes
752	.a4d6		84 da		sty $da		                sty     ZTEMP+0              ;Y=VDUVariables.mocr.dest.max

754							                ; dest.max = dest.min + (src.max - src.min)
755	.a4d8		a2 34		ldx #$34	                ldx     #VDUVariables.mocr.dest.min
756	.a4da		a0 2c		ldy #$2c	                ldy     #VDUVariables.mocr.src.max
757	.a4dc		a9 28		lda #$28	                lda     #VDUVariables.mocr.src.min
758	.a4de		20 7e d5	jsr $d57e	                jsr     addRegionDimensionsToVDUVariableCoordinates

760							                ;
761	.a4e1		a2 28		ldx #$28	                ldx     #VDUVariables.mocr.src.min
762	.a4e3		a0 34		ldy #$34	                ldy     #VDUVariables.mocr.dest
763	.a4e5		20 ca d5	jsr $d5ca	                jsr     sortVDUVariableWords

765	.a4e8		5a		phy		                phy
766	.a4e9		da		phx		                phx
767	.a4ea		a0 00		ldy #$00	                ldy     #0                   ;get outcode for X axis
768	.a4ec		20 b5 d1	jsr $d1b5	                jsr     getOutcodeForAxis
769	.a4ef		f0 08		beq $a4f9	                beq     LBEF3                ;taken if
770	.a4f1		4a		lsr a		                lsr     a
771	.a4f2		f0 03		beq $a4f7	                beq     LBEF1
772	.a4f4		68		pla		                pla

774	.a4f5						LBEEF:
775	.a4f5		68		pla		                pla
776	.a4f6		60		rts		                rts


779	.a4f7						LBEF1:
780	.a4f7		a2 00		ldx #$00	                ldx     #0

782	.a4f9						LBEF3:
783	.a4f9		68		pla		                pla

785	.a4fa		a0 30		ldy #$30	                ldy     #VDUVariables.mocr.L30
786	.a4fc		84 da		sty $da		                sty     ZTEMP+0
787	.a4fe		a0 28		ldy #$28	                ldy     #VDUVariables.mocr.src.min
788	.a500		20 8b d5	jsr $d58b	                jsr     addRegionDimensionToVDUVariableCoordinate

790	.a503		a0 3c		ldy #$3c	                ldy     #VDUVariables.ew.pointA
791	.a505		84 da		sty $da		                sty     ZTEMP+0

793	.a507		a0 34		ldy #$34	                ldy     #VDUVariables.mocr.dest.min
794	.a509		20 8b d5	jsr $d58b	                jsr     addRegionDimensionToVDUVariableCoordinate

796	.a50c		68		pla		                pla
797	.a50d		18		clc		                clc
798	.a50e		69 04		adc #$04	                adc     #4
799	.a510		aa		tax		                tax
800	.a511		da		phx		                phx
801	.a512		a0 00		ldy #$00	                ldy     #0
802	.a514		20 b5 d1	jsr $d1b5	                jsr     getOutcodeForAxis
803	.a517		f0 05		beq $a51e	                beq     LBF18
804	.a519		4a		lsr a		                lsr     a
805	.a51a		f0 d9		beq $a4f5	                beq     LBEEF
806	.a51c		a2 04		ldx #$04	                ldx     #4

808	.a51e						LBF18:
809	.a51e		68		pla		                pla
810	.a51f		a0 40		ldy #$40	                ldy     #VDUVariables.mocr.L40
811	.a521		84 da		sty $da		                sty     ZTEMP+0
812	.a523		a0 38		ldy #$38	                ldy     #VDUVariables.mocr.dest.max.x
813	.a525		20 8b d5	jsr $d58b	                jsr     addRegionDimensionToVDUVariableCoordinate
814	.a528		ad 40 03	lda $0340	                lda     vduv.mocr.L40
815	.a52b		cd 3c 03	cmp $033c	                cmp     vduv.mocr.L3C
816	.a52e		ad 41 03	lda $0341	                lda     vduv.mocr.L40+1
817	.a531		ed 3d 03	sbc $033d	                sbc     vduv.mocr.L3C+1
818	.a534		10 10		bpl $a546	                bpl     LBF40
819	.a536		ad 45 03	lda $0345	                lda     vduv.mocr.copy
820	.a539		d0 03		bne $a53e	                bne     LBF38
821	.a53b		20 20 c4	jsr $c420	                jsr     LC420

823	.a53e						LBF38:
824	.a53e		a2 34		ldx #$34	                ldx     #VDUVariables.mocr.dest
825	.a540		20 00 c9	jsr $c900	                jsr     copyEightBytesToWorkspace28
826	.a543		4c 20 c4	jmp $c420	                jmp     LC420


829	.a546						LBF40:
830	.a546		9c 47 03	stz $0347	                stz     vduv.mocr.L47
831	.a549		ad 30 03	lda $0330	                lda     vduv.mocr.L30
832	.a54c		2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne
833	.a54f		85 da		sta $da		                sta     ZTEMP+0
834	.a551		ad 3c 03	lda $033c	                lda     vduv.mocr.L3C
835	.a554		2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne
836	.a557		38		sec		                sec
837	.a558		e5 da		sbc $da		                sbc     ZTEMP+0
838	.a55a		10 06		bpl $a562	                bpl     LBF5C
839	.a55c		ce 47 03	dec $0347	                dec     vduv.mocr.L47
840	.a55f		2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne

842	.a562						LBF5C:
843	.a562		8d 43 03	sta $0343	                sta     vduv.ew.currentOffsetX+1
844	.a565		48		pha		                pha
845	.a566		49 ff		eor #$ff	                eor     #$ff
846	.a568		1a		inc a		                inc     a
847	.a569		2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne
848	.a56c		8d 42 03	sta $0342	                sta     vduv.mocr.shiftToNextByte
849	.a56f		68		pla		                pla
850	.a570		18		clc		                clc
851	.a571		6d 61 03	adc $0361	                adc     vduv.pixelsPerByteMinusOne
852	.a574		aa		tax		                tax
853	.a575		bd 1e e1	lda $e11e,x	                lda     LE120,x
854	.a578		85 e1		sta $e1		                sta     ZTEMPD+1
855	.a57a		a2 3c		ldx #$3c	                ldx     #VDUVariables.mocr.L3C
856	.a57c		a0 40		ldy #$40	                ldy     #VDUVariables.mocr.L40
857	.a57e		20 9a da	jsr $da9a	                jsr     LDA9C
858	.a581		8d 44 03	sta $0344	                sta     vduv.mocr.L44
859	.a584		a5 d1		lda $d1		                lda     ZMASK
860	.a586		8d 46 03	sta $0346	                sta     vduv.mocr.L46
861	.a589		a5 dc		lda $dc		                lda     ZTEMPB+0
862	.a58b		85 e0		sta $e0		                sta     ZTEMPD+0
863	.a58d		a2 00		ldx #$00	                ldx     #0
864	.a58f		20 ec a5	jsr $a5ec	                jsr     LBFE6
865	.a592		f0 40		beq $a5d4	                beq     LBFCE
866	.a594		ad 2a 03	lda $032a	                lda     vduv.mocr.src.min.y+0
867	.a597		cd 36 03	cmp $0336	                cmp     vduv.mocr.dest.min.y+0
868	.a59a		ad 2b 03	lda $032b	                lda     vduv.mocr.src.min.y+1
869	.a59d		ed 37 03	sbc $0337	                sbc     vduv.mocr.dest.min.y+1
870	.a5a0		50 02		bvc $a5a4	                bvc     LBF9E
871	.a5a2		49 80		eor #$80	                eor     #$80

873	.a5a4						LBF9E:
874	.a5a4		30 11		bmi $a5b7	                bmi     LBFB1

876	.a5a6						LBFA0:
877	.a5a6		20 60 db	jsr $db60	                jsr     LDB62
878	.a5a9		a2 00		ldx #$00	                ldx     #0
879	.a5ab		20 d7 a5	jsr $a5d7	                jsr     LBFD1
880	.a5ae		a2 0c		ldx #$0c	                ldx     #$c
881	.a5b0		20 d7 a5	jsr $a5d7	                jsr     LBFD1
882	.a5b3		d0 f1		bne $a5a6	                bne     LBFA0
883	.a5b5		80 1d		bra $a5d4	                bra     LBFCE


886	.a5b7						LBFB1:
887	.a5b7		a2 2a		ldx #$2a	                ldx     #VDUVariables.mocr.src.min.y
888	.a5b9		a0 2e		ldy #$2e	                ldy     #VDUVariables.mocr.src.max.y
889	.a5bb		20 b0 e2	jsr $e2b0	                jsr     exchangeTwoVDUBytes
890	.a5be		a2 36		ldx #$36	                ldx     #VDUVariables.mocr.dest.min.y
891	.a5c0		a0 3a		ldy #$3a	                ldy     #VDUVariables.mocr.dest.max.y
892	.a5c2		20 b0 e2	jsr $e2b0	                jsr     exchangeTwoVDUBytes

894	.a5c5						LBFBF:
895	.a5c5		20 60 db	jsr $db60	                jsr     LDB62
896	.a5c8		a2 00		ldx #$00	                ldx     #0
897	.a5ca		20 e1 a5	jsr $a5e1	                jsr     LBFDB
898	.a5cd		a2 0c		ldx #$0c	                ldx     #$c
899	.a5cf		20 e1 a5	jsr $a5e1	                jsr     LBFDB
900	.a5d2		d0 f1		bne $a5c5	                bne     LBFBF

902	.a5d4						LBFCE:
903	.a5d4		4c 60 db	jmp $db60	                jmp     LDB62

905	.a5d7						LBFD1:
906	.a5d7		fe 2a 03	inc $032a,x	                inc     vduv.mocr.src.min.y+0,x
907	.a5da		d0 10		bne $a5ec	                bne     LBFE6
908	.a5dc		fe 2b 03	inc $032b,x	                inc     vduv.mocr.src.min.y+1,x
909	.a5df		80 0b		bra $a5ec	                bra     LBFE6

911	.a5e1						LBFDB:
912	.a5e1		bd 2a 03	lda $032a,x	                lda     vduv.mocr.src.min.y+0,x
913	.a5e4		d0 03		bne $a5e9	                bne     LBFE3
914	.a5e6		de 2b 03	dec $032b,x	                dec     vduv.mocr.src.min.y+1,x

916	.a5e9						LBFE3:
917	.a5e9		de 2a 03	dec $032a,x	                dec     vduv.mocr.src.min.y+0,x
918	.a5ec						LBFE6:
919	.a5ec		bd 2a 03	lda $032a,x	                lda     vduv.mocr.src.min.y+0,x
920	.a5ef		dd 2e 03	cmp $032e,x	                cmp     vduv.mocr.src.max.y+0,x
921	.a5f2		d0 06		bne $a5fa	                bne     rtsBFF4
922	.a5f4		bd 2b 03	lda $032b,x	                lda     vduv.mocr.src.min.y+1,x
923	.a5f7		dd 2f 03	cmp $032f,x	                cmp     vduv.mocr.src.max.y+1,x

925	.a5fa						rtsBFF4:
926	.a5fa		60		rts		                rts

928							                .if version!=400&&version!=350
941							                .endif


:4	;******  Return to file: src/terminal.s65

3632							                .endif

3634							;-------------------------------------------------------------------------
3635							;
3636							; Utils/Terminal ROM service entry point.
3637							;
3638	.a5fb						utilsServiceEntryPoint:
3639							                .if version==400
3640							                ; this is the same as the MOS 5.00 code, but I didn't
3641							                ; get the if arrangement right. This needs improving.
3642	.a5fb		e0 0f		cpx #$0f	                cpx #terminalROM
3643	.a5fd		f0 01		beq $a600	                beq utilsInCorrectBank
3644	.a5ff		60		rts		                rts
3645	.a600						utilsInCorrectBank:
3646							                .endif
3647							                .if includeTubeSupport
3648	.a600		c9 fe		cmp #$fe	                cmp #romServiceCallTubeSystemPostInitialisation
3649	.a602		90 56		bcc $a65a	                bcc handleNonTube
3650	.a604		d0 14		bne $a61a	                bne handleTubeMainInitialisation
3651	.a606						handleTubeSystemPostInitialisation:
3652	.a606		c0 00		cpy #$00	                cpy #$00
3653	.a608		f0 50		beq $a65a	                beq handleNonTube

3655							                ; [Tube p28] - write out the startup message that the
3656							                ; second processor has been stuck trying to write out.
3657	.a60a						writeSecondProcessorStartupMessageLoop:
3658	.a60a		2c e0 fe	bit $fee0	                bit tube.status1
3659	.a60d		10 fb		bpl $a60a	                bpl writeSecondProcessorStartupMessageLoop
3660	.a60f		ad e1 fe	lda $fee1	                lda tube.data1
3661	.a612		f0 44		beq $a658	                beq L9DCA
3662	.a614		20 ee ff	jsr $ffee	                jsr OSWRCH
3663	.a617		4c 0a a6	jmp $a60a	                jmp writeSecondProcessorStartupMessageLoop

3665	.a61a						handleTubeMainInitialisation:
3666	.a61a		a9 7b		lda #$7b	                lda #<tubeHost.eventHandler
3667	.a61c		8d 20 02	sta $0220	                sta EVENTV+0
3668	.a61f		a9 06		lda #$06	                lda #>tubeHost.eventHandler
3669	.a621		8d 21 02	sta $0221	                sta EVENTV+1
3670	.a624		a9 16		lda #$16	                lda #<tubeBrkHandlerAddr
3671	.a626		8d 02 02	sta $0202	                sta BRKV+0
3672	.a629		a9 00		lda #$00	                lda #>tubeBrkHandlerAddr
3673	.a62b		8d 03 02	sta $0203	                sta BRKV+1
3674	.a62e		a9 8e		lda #$8e	                lda #tube.status1.S|tube.status1.M|tube.status1.J|tube.status1.I;
3675	.a630		8d e0 fe	sta $fee0	                sta tube.status1

3677							                ; Copy Tube host code into main RAM.
3678	.a633		a0 00		ldy #$00	                ldy #$00
3679	.a635						-
3680	.a635		b9 a4 b0	lda $b0a4,y	                lda tubeHost.codePage0,y
3681	.a638		99 00 04	sta $0400,y	                sta tubeHostAddr+0*256,y
3682	.a63b		b9 9b b1	lda $b19b,y	                lda tubeHost.codePages12,y
3683	.a63e		99 00 05	sta $0500,y	                sta tubeHostAddr+1*256,y
3684	.a641		b9 9b b2	lda $b29b,y	                lda tubeHost.codePages12+256,y
3685	.a644		99 00 06	sta $0600,y	                sta tubeHostAddr+2*256,y
3686	.a647		88		dey		                dey
3687	.a648		d0 eb		bne $a635	                bne -

3689	.a64a		20 1f 04	jsr $041f	                jsr tubeHost.resetTubeClaim

3691							                ; Copy BRK handler into zero page.
3692	.a64d		a2 41		ldx #$41	                ldx #size(tubeHost.brkHandler)
3693	.a64f						-
3694	.a64f		bd 63 b0	lda $b063,x	                lda tubeHost.brkHandler,x
3695	.a652		9d 16 00	sta $0016,x	                sta @w tubeBrkHandlerAddr,x
3696	.a655		ca		dex		                dex
3697	.a656		10 f7		bpl $a64f	                bpl -

3699	.a658						L9DCA:
3700	.a658		a9 00		lda #$00	                lda #$00                     ; Claim call and return

3702	.a65a						handleNonTube:
3712							                .endif
3713	.a65a		c9 12		cmp #$12	                cmp #romServiceCallInitialiseFilingSystem
3714	.a65c		d0 09		bne $a667	                bne handleBreakInstruction
3715							                .if version==400
3716	.a65e		c0 03		cpy #$03	                cpy #fsROM
3717	.a660		d0 31		bne $a693	                bne L9E16
3732							                .endif
3733	.a662		20 c5 eb	jsr $ebc5	                jsr selectROMOrTAPEByOSBYTE
3734	.a665		80 f1		bra $a658	                bra L9DCA                    ; Jump to claim and return

3736	.a667						handleBreakInstruction:
3737	.a667		c9 06		cmp #$06	                cmp #romServiceCallBreakInstruction
3738	.a669		d0 29		bne $a694	                bne handleCloseAllOpenFiles
3739	.a66b		ad dd df	lda $dfdd	                lda hazel.hasACCCONChanged ; Skip if ACCCON not changed
3740	.a66e		f0 09		beq $a679	                beq closeMoveSrcHandle
3741	.a670		9c dd df	stz $dfdd	                stz hazel.hasACCCONChanged ; Clear ACCCON changed flag
3742	.a673		ad dc df	lda $dfdc	                lda hazel.oldACCCON        ; Restore ACCCON
3743	.a676		8d 34 fe	sta $fe34	                sta ACCCON
3744	.a679						closeMoveSrcHandle:
3745	.a679		5a		phy		                phy
3746	.a67a		ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle
3747	.a67d		f0 06		beq $a685	                beq closeMoveDestHandle
3748	.a67f		9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
3749	.a682		20 a3 91	jsr $91a3	                jsr closeFile
3750	.a685						closeMoveDestHandle:
3751	.a685		ac d5 df	ldy $dfd5	                ldy hazel.moveDestHandle
3752	.a688		f0 06		beq $a690	                beq L9E13
3753	.a68a		9c d5 df	stz $dfd5	                stz hazel.moveDestHandle
3754	.a68d		20 a3 91	jsr $91a3	                jsr closeFile
3755	.a690						L9E13:
3756	.a690		7a		ply		                ply
3757	.a691		a9 06		lda #$06	                lda #romServiceCallBreakInstruction ; restore A
3758	.a693						L9E16:
3759	.a693		60		rts		                rts
3760	.a694						handleCloseAllOpenFiles:
3761	.a694		c9 26		cmp #$26	                cmp #romServiceCallCloseAllOpenFiles
3762	.a696		d0 0c		bne $a6a4	                bne handleHelp
3763							                .if version!=400
3774							                .endif
3775	.a698		20 c5 eb	jsr $ebc5	                jsr selectROMOrTAPEByOSBYTE
3776	.a69b		a9 00		lda #$00	                lda #$00
3777	.a69d		a8		tay		                tay
3778	.a69e		20 db a9	jsr $a9db	                jsr osfindTapeOrROM
3779	.a6a1		a9 26		lda #$26	                lda #$26
3780	.a6a3		60		rts		                rts

3782	.a6a4						handleHelp
3783	.a6a4		c9 09		cmp #$09	                cmp #romServiceCallHelp
3784							                .if version<400&&includeTerminalROM
3786							                .else
3787	.a6a6		d0 43		bne $a6eb	                bne LA304
3788							                .endif
3789	.a6a8		5a		phy		                phy
3790	.a6a9		b1 f2		lda ($f2),y	                lda ($F2),y
3791	.a6ab		c9 0d		cmp #$0d	                cmp #$0D
3792	.a6ad		d0 0f		bne $a6be	                bne L9E61
3793	.a6af		20 5e a7	jsr $a75e	                jsr L9EFC
3794	.a6b2		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
3795	>a6b5		20 20 4d 4f 53 0d		                .text "  MOS",13
3796							                .if version<400&&includeTerminalROM
3808							                .endif
3809	>a6bb		00				                .text 0
3810	.a6bc		80 2a		bra $a6e8	                bra L9E8B
3811	.a6be						L9E61:
3812	.a6be		a2 02		ldx #$02	                ldx #size(mosHelpSubject)-1
3813	.a6c0						L9E63:
3814	.a6c0		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
3815	.a6c2		c9 2e		cmp #$2e	                cmp #'.'
3816	.a6c4		f0 29		beq $a6ef	                beq L9E95
3817	.a6c6		29 df		and #$df	                and #$DF
3818	.a6c8		dd ec a6	cmp $a6ec,x	                cmp mosHelpSubject,x
3819	.a6cb		d0 0b		bne $a6d8	                bne L9E7B
3820	.a6cd		c8		iny		                iny
3821	.a6ce		ca		dex		                dex
3822	.a6cf		10 ef		bpl $a6c0	                bpl L9E63
3823	.a6d1		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
3824	.a6d3		20 19 e9	jsr $e919	                jsr isLetter
3825	.a6d6		b0 17		bcs $a6ef	                bcs L9E95
3826	.a6d8						L9E7B:
3827	.a6d8		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
3828	.a6da		c9 0d		cmp #$0d	                cmp #13
3829	.a6dc		f0 0a		beq $a6e8	                beq L9E8B
3830	.a6de		c8		iny		                iny
3831	.a6df		c9 20		cmp #$20	                cmp #' '
3832	.a6e1		d0 f5		bne $a6d8	                bne L9E7B
3833	.a6e3		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
3834	.a6e6		d0 d6		bne $a6be	                bne L9E61
3835	.a6e8						L9E8B:
3836	.a6e8		7a		ply		                ply
3837	.a6e9		a9 09		lda #$09	                lda #romServiceCallHelp
3838	.a6eb						LA304:
3839	.a6eb		60		rts		                rts

3841							                .if version<400&&includeTerminalROM
3844							                .endif

3846	>a6ec		53 4f 4d			mosHelpSubject: .text "SOM"

3848	.a6ef						L9E95:
3849	.a6ef		20 5e a7	jsr $a75e	                jsr L9EFC
3850	.a6f2		a9 49		lda #$49	                lda #<mosCommandTable
3851	.a6f4		85 b0		sta $b0		                sta terminalHELPWorkspace.tablePtr+0
3852	.a6f6		a9 83		lda #$83	                lda #>mosCommandTable
3853	.a6f8		85 b1		sta $b1		                sta terminalHELPWorkspace.tablePtr+1
3854	.a6fa						L9EA0:
3855	.a6fa		b2 b0		lda ($b0)	                lda (terminalHELPWorkspace.tablePtr)
3856	.a6fc		30 58		bmi $a756	                bmi L9EF4
3857							                .if version==400
3858	.a6fe		c9 61		cmp #$61	                cmp #'a'
3859	.a700		b0 0f		bcs $a711	                bcs LA711
3860							                .endif
3861	.a702		20 6f a7	jsr $a76f	                jsr printSpace
3862	.a705		20 6f a7	jsr $a76f	                jsr printSpace
3863	.a708		b2 b0		lda ($b0)	                lda (terminalHELPWorkspace.tablePtr)
3864	.a70a						L9EAC:
3865							                .if version==400
3866	.a70a		c9 61		cmp #$61	                cmp #'a'
3867	.a70c		b0 03		bcs $a711	                bcs LA711
3868							                .endif
3869	.a70e		20 71 a7	jsr $a771	                jsr L9F0E
3870	.a711						LA711:
3871	.a711		e6 b0		inc $b0		                inc terminalHELPWorkspace.tablePtr+0
3872	.a713		d0 02		bne $a717	                bne L9EB5
3873	.a715		e6 b1		inc $b1		                inc terminalHELPWorkspace.tablePtr+1
3874	.a717						L9EB5:
3875	.a717		b2 b0		lda ($b0)	                lda (terminalHELPWorkspace.tablePtr)
3876	.a719		10 ef		bpl $a70a	                bpl L9EAC

3878							                ; add 4 to tablePtr
3879	.a71b		a9 04		lda #$04	                lda #$04
3880	.a71d		18		clc		                clc
3881	.a71e		65 b0		adc $b0		                adc terminalHELPWorkspace.tablePtr+0
3882	.a720		85 b0		sta $b0		                sta terminalHELPWorkspace.tablePtr+0
3883	.a722		90 02		bcc $a726	                bcc +
3884	.a724		e6 b1		inc $b1		                inc terminalHELPWorkspace.tablePtr+1
3885	.a726						+
3886	.a726		20 5a e2	jsr $e25a	                jsr LE25C
3887	.a729		e0 13		cpx #$13	                cpx #19
3888	.a72b		f0 24		beq $a751	                beq L9EEF
3889	.a72d						L9ECB:
3890	.a72d		20 50 e2	jsr $e250	                jsr getTextCursorPositionWithColumn81
3891	.a730		8a		txa		                txa
3892	.a731		f0 c7		beq $a6fa	                beq L9EA0
3893	.a733		e0 14		cpx #$14	                cpx #20
3894	.a735		f0 c3		beq $a6fa	                beq L9EA0
3895	.a737		90 0d		bcc $a746	                bcc L9EE4
3896	.a739		e0 28		cpx #$28	                cpx #40
3897	.a73b		f0 bd		beq $a6fa	                beq L9EA0
3898	.a73d		b0 0c		bcs $a74b	                bcs L9EE9
3899	.a73f		20 5a e2	jsr $e25a	                jsr LE25C
3900	.a742		e0 27		cpx #$27	                cpx #39
3901	.a744		f0 0b		beq $a751	                beq L9EEF
3902	.a746						L9EE4:
3903	.a746		20 6f a7	jsr $a76f	                jsr printSpace
3904	.a749		80 e2		bra $a72d	                bra L9ECB

3906	.a74b						L9EE9:
3907	.a74b		e0 3c		cpx #$3c	                cpx #60
3908	.a74d		90 f7		bcc $a746	                bcc L9EE4
3909	.a74f		f0 a9		beq $a6fa	                beq L9EA0
3910	.a751						L9EEF:
3911	.a751		20 81 a7	jsr $a781	                jsr printNewLine
3912	.a754		80 a4		bra $a6fa	                bra L9EA0

3914	.a756						L9EF4:
3915	.a756		20 50 e2	jsr $e250	                jsr getTextCursorPositionWithColumn81
3916	.a759		8a		txa		                txa
3917	.a75a		f0 8c		beq $a6e8	                beq L9E8B
3918	.a75c		80 f3		bra $a751	                bra L9EEF

3920	.a75e						L9EFC:
3921	.a75e		5a		phy		                phy
3922	.a75f		20 05 af	jsr $af05	                jsr alwaysPrintFollowingMessage
3923	>a762		0d 4d 4f 53 20 34 2e 30		                .text 13,versionString,13,0
	>a76a		30 0d 00
3924	.a76d		7a		ply		                ply
3925	.a76e		60		rts		                rts

3927							;-------------------------------------------------------------------------
3928							;
3929	.a76f						printSpace:
3930	.a76f		a9 20		lda #$20	                lda #$20
3931	.a771						L9F0E:
3932	.a771		da		phx		                phx
3933	.a772		a6 b0		ldx $b0		                ldx $B0
3934	.a774		da		phx		                phx
3935	.a775		a6 b1		ldx $b1		                ldx $B1
3936	.a777		20 ee ff	jsr $ffee	                jsr OSWRCH
3937	.a77a						restoreB1AndB0:
3938	.a77a		86 b1		stx $b1		                stx $B1
3939	.a77c		fa		plx		                plx
3940	.a77d		86 b0		stx $b0		                stx $B0
3941	.a77f		fa		plx		                plx
3942	.a780		60		rts		                rts

3944							;-------------------------------------------------------------------------

3946	.a781						printNewLine:
3947	.a781		da		phx		                phx
3948	.a782		a6 b0		ldx $b0		                ldx $B0
3949	.a784		da		phx		                phx
3950	.a785		a6 b1		ldx $b1		                ldx $B1
3951	.a787		20 e7 ff	jsr $ffe7	                jsr OSNEWL
3952	.a78a		80 ee		bra $a77a	                bra restoreB1AndB0

3954							;-------------------------------------------------------------------------

3956							; TAPE/ROM OSARGS handler
3957							; =======================
3958	.a78c						osargsTapeOrROM:
3959	.a78c		c0 00		cpy #$00	                cpy #$00       ; Handle<>0 - read/write open file info
3960	.a78e		d0 07		bne $a797	                bne L9F3B
3961	.a790		09 00		ora #$00	                ora #$00 ; A<>0 - read/write filing system info - exit
3962	.a792		d0 02		bne $a796	                bne L9F3A

3964							; A=0, Y=0 - read current filing system
3965							; -------------------------------------
3966	.a794		a9 03		lda #$03	                lda #$03                     ; Prepare A=ROMFS
3967							                .if version!=400
3971							                .endif

3973							; TAPE/ROM FSC 6 - shut down FS
3974							; TAPE/ROM FSC 8 - OS command
3975							; TAPE/ROM FSC 10 - *INFO
3976							; -----------------------------
3977	.a796						L9F3A:
3978	.a796		60		rts		                rts

3980							; OSARGS handle<>0 - red/write open file info
3981							; -------------------------------------------
3982	.a797						L9F3B:
3983	.a797		c9 00		cmp #$00	                cmp #$00                     ; Not =PTR, exit unsupported
3984	.a799		d0 fb		bne $a796	                bne L9F3A
3985	.a79b		c0 02		cpy #$02	                cpy #$02                     ; =PTR#2 - read PTR on output handle
3986	.a79d		f0 1d		beq $a7bc	                beq L9F60

3988							; Read PTR on CFS/RFS input file
3989							; ------------------------------
3990	.a79f		a9 01		lda #$01	                lda #$01                     ; Check if this is input channel and is open
3991	.a7a1		20 a3 af	jsr $afa3	                jsr LAA68
3992	.a7a4		ad 9e 03	lda $039e	                lda $039E
3993	.a7a7		95 00		sta $00,x	                sta $00,x
3994	.a7a9		5a		phy		                phy
3995	.a7aa		ad de 03	lda $03de	                lda $03DE
3996	.a7ad		ac dd 03	ldy $03dd	                ldy $03DD
3997	.a7b0		d0 01		bne $a7b3	                bne L9F57
3998	.a7b2		3a		dec a		                dec a
3999	.a7b3						L9F57:
4000	.a7b3		88		dey		                dey
4001	.a7b4		94 01		sty $01,x	                sty $01,x
4002	.a7b6		7a		ply		                ply
4003	.a7b7						L9F5B:
4004	.a7b7		95 02		sta $02,x	                sta $02,x
4005	.a7b9		74 03		stz $03,x	                stz $03,x
4006	.a7bb		60		rts		                rts

4008							; Read PTR on TAPE output file
4009							; ----------------------------
4010	.a7bc						L9F60:
4011	.a7bc		a9 02		lda #$02	                lda #$02                     ; Check if this is output channel and is open
4012	.a7be		20 a3 af	jsr $afa3	                jsr LAA68
4013	.a7c1		ad 9d 03	lda $039d	                lda $039D                    ; Copy PTR to control block
4014	.a7c4		95 00		sta $00,x	                sta $00,x
4015	.a7c6		ad 94 03	lda $0394	                lda $0394
4016	.a7c9		95 01		sta $01,x	                sta $01,x
4017	.a7cb		ad 95 03	lda $0395	                lda $0395
4018	.a7ce		80 e7		bra $a7b7	                bra L9F5B

4020							;-------------------------------------------------------------------------

4022							; TAPE/ROM FSC dispatch table
4023							; ---------------------------

4025							tapeAndROMFSCRoutine: .macro addr,shift
4027							                .endmacro

4029							tapeAndROMFSCRoutinesTable: .macro shift
4042							                .endmacro

4044	.a7d0						L9F74:
4026	>a7d0		1a				                .byte ((LA422)-1)>>(0)&$ff
4026	>a7d1		b0				                .byte ((LA4F1)-1)>>(0)&$ff
4026	>a7d2		0b				                .byte ((LA110)-1)>>(0)&$ff
4026	>a7d3		21				                .byte ((LA129)-1)>>(0)&$ff
4026	>a7d4		0b				                .byte ((LA110)-1)>>(0)&$ff
4026	>a7d5		60				                .byte ((LA168)-1)>>(0)&$ff
4026	>a7d6		95				                .byte ((L9F3A)-1)>>(0)&$ff
4026	>a7d7		f9				                .byte ((L9F9E)-1)>>(0)&$ff
4026	>a7d8		95				                .byte ((L9F3A)-1)>>(0)&$ff
4026	>a7d9		4d				                .byte ((LA155)-1)>>(0)&$ff
4026	>a7da		95				                .byte ((L9F3A)-1)>>(0)&$ff
4026	>a7db		0e				                .byte ((LA113)-1)>>(0)&$ff
4046	.a7dc						L9F80:
4026	>a7dc		ab				                .byte ((LA422)-1)>>(8)&$ff
4026	>a7dd		ab				                .byte ((LA4F1)-1)>>(8)&$ff
4026	>a7de		a9				                .byte ((LA110)-1)>>(8)&$ff
4026	>a7df		a9				                .byte ((LA129)-1)>>(8)&$ff
4026	>a7e0		a9				                .byte ((LA110)-1)>>(8)&$ff
4026	>a7e1		a9				                .byte ((LA168)-1)>>(8)&$ff
4026	>a7e2		a7				                .byte ((L9F3A)-1)>>(8)&$ff
4026	>a7e3		a7				                .byte ((L9F9E)-1)>>(8)&$ff
4026	>a7e4		a7				                .byte ((L9F3A)-1)>>(8)&$ff
4026	>a7e5		a9				                .byte ((LA155)-1)>>(8)&$ff
4026	>a7e6		a7				                .byte ((L9F3A)-1)>>(8)&$ff
4026	>a7e7		a9				                .byte ((LA113)-1)>>(8)&$ff

4049							;-------------------------------------------------------------------------

4051							; TAPE/ROM FSC
4052							; ============
4053	.a7e8						fscTapeOrROM:
4054	.a7e8		c9 0c		cmp #$0c	                cmp #$0C                     ; function<12 - exit unchanged
4055	.a7ea		b0 aa		bcs $a796	                bcs L9F3A
4056	.a7ec		86 bc		stx $bc		                stx $BC                      ; Index into dispatch table
4057	.a7ee		aa		tax		                tax
4058	.a7ef		bd dc a7	lda $a7dc,x	                lda L9F80,x
4059	.a7f2		48		pha		                pha
4060	.a7f3		bd d0 a7	lda $a7d0,x	                lda L9F74,x
4061	.a7f6		48		pha		                pha
4062	.a7f7		a6 bc		ldx $bc		                ldx $BC
4063	.a7f9		60		rts		                rts

4065							; TAPE/ROM FSC 7 - obtain file handle range
4066							; -----------------------------------------
4067	.a7fa						L9F9E:
4068	.a7fa		a2 03		ldx #$03	                ldx #$03
4069	.a7fc		a0 03		ldy #$03	                ldy #$03
4070							                .if version!=400
4075							                .endif
4076	.a7fe		60		rts		                rts

4078	.a7ff						L9FAB:
4079	.a7ff		68		pla		                pla
4080	.a800		28		plp		                plp
4081	.a801		38		sec		                sec
4082	.a802		60		rts		                rts

4084	.a803						L9FAF:
4085	.a803		08		php		                php
4086	.a804		48		pha		                pha
4087	.a805		20 74 af	jsr $af74	                jsr LA9F3
4088	.a808		ad c2 03	lda $03c2	                lda $03C2
4089	.a80b		48		pha		                pha
4090	.a80c		20 c2 ab	jsr $abc2	                jsr LA502
4091	.a80f		68		pla		                pla
4092	.a810		b0 ed		bcs $a7ff	                bcs L9FAB
4093	.a812		f0 19		beq $a82d	                beq L9FD9
4094	.a814		a2 03		ldx #$03	                ldx #$03
4095	.a816		a9 ff		lda #$ff	                lda #$FF
4096	.a818						L9FC4:
4097	.a818		48		pha		                pha
4098	.a819		bd be 03	lda $03be,x	                lda $03BE,x
4099	.a81c		95 b0		sta $b0,x	                sta $B0,x
4100	.a81e		68		pla		                pla
4101	.a81f		35 b0		and $b0,x	                and $B0,x
4102	.a821		ca		dex		                dex
4103	.a822		10 f4		bpl $a818	                bpl L9FC4
4104	.a824		1a		inc a		                inc a
4105	.a825		d0 06		bne $a82d	                bne L9FD9
4106	.a827		20 56 af	jsr $af56	                jsr LA9B1
4107	.a82a		4c df 95	jmp $95df	                jmp badAddressError

4109	.a82d						L9FD9:
4110	.a82d		ad ca 03	lda $03ca	                lda $03CA
4111	.a830		4a		lsr a		                lsr a
4112	.a831		68		pla		                pla
4113	.a832		48		pha		                pha
4114	.a833		f0 10		beq $a845	                beq L9FF1
4115	.a835		90 15		bcc $a84c	                bcc L9FF8
4116	.a837						L9FE3:
4117	.a837		20 60 af	jsr $af60	                jsr LA9BB
4118	.a83a		20 23 b0	jsr $b023	                jsr doFollowingError
4119	>a83d		d5 4c 6f 63 6b 65 64 00		                .text $d5,"Locked",0
4120	.a845						L9FF1:
4121	.a845		90 05		bcc $a84c	                bcc L9FF8
4122	.a847		a9 03		lda #$03	                lda #$03
4123	.a849		8d 58 02	sta $0258	                sta breakAndESCAPEEffect
4124	.a84c						L9FF8:
4125	.a84c		a9 30		lda #$30	                lda #$30
4126	.a84e		25 bb		and $bb		                and $BB
4127	.a850		f0 04		beq $a856	                beq LA002
4128	.a852		a5 c1		lda $c1		                lda $C1
4129	.a854						LA000:
4130	.a854		d0 08		bne $a85e	                bne LA00A
4131	.a856						LA002:
4132							                .if includeTubeSupport
4133	.a856		5a		phy		                phy
4134	.a857		20 da af	jsr $afda	                jsr initiateCFSRFSHostToParasiteTransfer
4135	.a85a		7a		ply		                ply
4136							                .endif
4137	.a85b		20 66 ad	jsr $ad66	                jsr LA6D2
4138	.a85e						LA00A:
4139	.a85e		20 51 ae	jsr $ae51	                jsr LA8A1
4140	.a861		d0 57		bne $a8ba	                bne LA066
4141	.a863		20 7e af	jsr $af7e	                jsr LAA35
4142	.a866		2c ca 03	bit $03ca	                bit $03CA
4143	.a869		30 08		bmi $a873	                bmi LA01F
4144	.a86b		20 0b ae	jsr $ae0b	                jsr LA85B
4145	.a86e		20 1b ad	jsr $ad1b	                jsr LA678
4146	.a871		80 d9		bra $a84c	                bra L9FF8

4148	.a873						LA01F:
4149	.a873		68		pla		                pla                          ; RUN, no control block to update
4150	.a874		f0 33		beq $a8a9	                beq LA055
4151	.a876		a0 02		ldy #$02	                ldy #$02
4152	.a878						LA024:
4153	.a878		b9 bc 03	lda $03bc,y	                lda $03BC,y                  ; Copy load/exec to control block
4154	.a87b		91 c8		sta ($c8),y	                sta ($C8),y
4155	.a87d		c8		iny		                iny
4156	.a87e		c0 0a		cpy #$0a	                cpy #$0A
4157	.a880		d0 f6		bne $a878	                bne LA024
4158	.a882		ad c8 03	lda $03c8	                lda $03C8                    ; Length b0-b7=Block Length b0-b7
4159	.a885		91 c8		sta ($c8),y	                sta ($C8),y
4160	.a887		c8		iny		                iny
4161	.a888		ad c9 03	lda $03c9	                lda $03C9
4162	.a88b		18		clc		                clc
4163	.a88c		6d c6 03	adc $03c6	                adc $03C6                    ; Length b8-b15=Block Number+Block Length b8-b15
4164	.a88f		91 c8		sta ($c8),y	                sta ($C8),y
4165	.a891		c8		iny		                iny
4166	.a892		a9 00		lda #$00	                lda #$00
4167	.a894		6d c7 03	adc $03c7	                adc $03C7                    ; Length b16-b23=overflow
4168	.a897		91 c8		sta ($c8),y	                sta ($C8),y
4169	.a899		c8		iny		                iny                          ; Length b24-b31=&00
4170	.a89a		a9 00		lda #$00	                lda #$00
4171	.a89c		91 c8		sta ($c8),y	                sta ($C8),y
4172	.a89e		c8		iny		                iny
4173	.a89f						LA04B:
4174	.a89f		b9 bd 03	lda $03bd,y	                lda $03BD,y                  ; Attrs=&00000000
4175	.a8a2		91 c8		sta ($c8),y	                sta ($C8),y
4176	.a8a4		c8		iny		                iny
4177	.a8a5		c0 12		cpy #$12	                cpy #$12
4178	.a8a7		d0 f6		bne $a89f	                bne LA04B
4179	.a8a9						LA055:
4180	.a8a9		28		plp		                plp
4181	.a8aa						LA056:
4182	.a8aa		20 56 af	jsr $af56	                jsr LA9B1
4183	.a8ad						LA059:
4184	.a8ad		24 ba		bit $ba		                bit $BA                      ; If flag set, skip printing newline
4185	.a8af		30 07		bmi $a8b8	                bmi LA064
4186	.a8b1						LA05D:
4187	.a8b1		08		php		                php                          ; Print inline text
4188	.a8b2		20 d0 ae	jsr $aed0	                jsr LA923
4189	>a8b5		0d				                .byte 13                     ; Could just do JSR OSNEWL
4190	>a8b6		00				                .byte 0
4191	.a8b7		28		plp		                plp
4192	.a8b8						LA064:
4193	.a8b8		18		clc		                clc
4194	.a8b9		60		rts		                rts

4196	.a8ba						LA066:
4197	.a8ba		20 c6 ab	jsr $abc6	                jsr LA506
4198	.a8bd		d0 8d		bne $a84c	                bne L9FF8
4199	.a8bf						LA06B:
4200	.a8bf		86 f2		stx $f2		                stx $F2
4201	.a8c1		84 f3		sty $f3		                sty $F3
4202	.a8c3		a0 00		ldy #$00	                ldy #$00
4203	.a8c5		20 5c f0	jsr $f05c	                jsr gsinitForFilenameParsing
4204	.a8c8		a2 00		ldx #$00	                ldx #$00
4205	.a8ca						LA076:
4206	.a8ca		20 6e f0	jsr $f06e	                jsr gsreadEntryPoint
4207	.a8cd		b0 0d		bcs $a8dc	                bcs LA088
4208	.a8cf		f0 08		beq $a8d9	                beq LA085
4209	.a8d1		9d d2 03	sta $03d2,x	                sta $03D2,x
4210	.a8d4		e8		inx		                inx
4211	.a8d5		e0 0b		cpx #$0b	                cpx #$0B
4212	.a8d7		d0 f1		bne $a8ca	                bne LA076
4213	.a8d9						LA085:
4214	.a8d9		4c 7e f0	jmp $f07e	                jmp badStringError

4216	.a8dc						LA088:
4217	.a8dc		9e d2 03	stz $03d2,x	                stz $03D2,x
4218	.a8df		60		rts		                rts

4220							; CFS/RFS OSFILE
4221							; ==============
4222	.a8e0						osfileTapeOrROM:
4223	.a8e0		48		pha		                pha
4224	.a8e1		86 c8		stx $c8		                stx $C8                      ; C8/9=>control block
4225	.a8e3		84 c9		sty $c9		                sty $C9
4226	.a8e5		b2 c8		lda ($c8)	                lda ($C8)                    ; Get XY=>filename
4227	.a8e7		aa		tax		                tax
4228	.a8e8		a0 01		ldy #$01	                ldy #$01
4229	.a8ea		b1 c8		lda ($c8),y	                lda ($C8),y
4230	.a8ec		a8		tay		                tay
4231	.a8ed		20 bf a8	jsr $a8bf	                jsr LA06B                    ; Parse filename
4232	.a8f0		a0 02		ldy #$02	                ldy #$02
4233	.a8f2						LA09E:
4234	.a8f2		b1 c8		lda ($c8),y	                lda ($C8),y
4235	.a8f4		99 bc 03	sta $03bc,y	                sta $03BC,y
4236	.a8f7		99 ae 00	sta $00ae,y	                sta $00AE,y
4237	.a8fa		c8		iny		                iny
4238	.a8fb		c0 0a		cpy #$0a	                cpy #$0A
4239	.a8fd		d0 f3		bne $a8f2	                bne LA09E
4240	.a8ff		68		pla		                pla
4241	.a900		f0 07		beq $a909	                beq LA0B5
4242	.a902		c9 ff		cmp #$ff	                cmp #$FF
4243	.a904		d0 b2		bne $a8b8	                bne LA064
4244	.a906		4c 03 a8	jmp $a803	                jmp L9FAF

4246	.a909						LA0B5:
4247							                .if version==400
4248	.a909		4c bd fa	jmp $fabd	                jmp badCommandError
4297							                .endif

4299							; TAPE/ROM FSC 2 - */
4300							; TAPE/ROM FSC 4 - *RUN
4301							; ---------------------
4302	.a90c						LA110:
4303	.a90c		38		sec		                sec
4304	.a90d		66 ce		ror $ce		                ror $CE
4305							; TAPE/ROM FSC 11 - *RUN command for library
4306							; ------------------------------------------
4307	.a90f						LA113:
4308	.a90f		da		phx		                phx
4309	.a910		5a		phy		                phy
4310	.a911		20 bf a8	jsr $a8bf	                jsr LA06B
4311	.a914		a9 00		lda #$00	                lda #$00
4312	.a916		a2 ff		ldx #$ff	                ldx #$FF
4313	.a918		8e c2 03	stx $03c2	                stx $03C2
4314	.a91b		20 03 a8	jsr $a803	                jsr L9FAF
4315	.a91e		7a		ply		                ply
4316	.a91f		fa		plx		                plx
4317	.a920		90 05		bcc $a927	                bcc LA12E
4318							                .if version!=400
4320							                .endif

4322							; TAPE/ROM FSC 3 - unknown * command
4323							; ----------------------------------
4324	.a922						LA129:
4325	.a922		a9 0b		lda #$0b	                lda #$0B
4326	.a924		6c 1e 02	jmp ($021e)	                jmp (FSCV)

4328	.a927						LA12E:
4329							                .if includeTubeSupport
4330	.a927		2c 7a 02	bit $027a	                bit tubePresence
4331	.a92a		10 09		bpl $a935	                bpl LA13C                    ; taken if no Tube
4332	.a92c		ad c4 03	lda $03c4	                lda $03C4
4333	.a92f		2d c5 03	and $03c5	                and $03C5
4334	.a932		1a		inc a		                inc a                     ; A=$00 if !&03c2=&FFFFxxxx
4335	.a933		d0 10		bne $a945	                bne LA14C                 ; taken if copro address
4336	.a935						LA13C:
4337							                .endif

4339	.a935		ae c2 03	ldx $03c2	                ldx $03C2
4340	.a938		ac c3 03	ldy $03c3	                ldy $03C3
4341	.a93b		a9 a4		lda #$a4	                lda #$A4
4342	.a93d		20 f4 ff	jsr $fff4	                jsr OSBYTE
4343	.a940		a9 01		lda #$01	                lda #$01
4344	.a942		6c c2 03	jmp ($03c2)	                jmp ($03C2)

4346							                .if includeTubeSupport
4347	.a945						LA14C:
4348	.a945		a2 c2		ldx #$c2	                ldx #$C2
4349	.a947		a0 03		ldy #$03	                ldy #$03
4350	.a949		a9 04		lda #$04	                lda #tubeReasonExecute
4351	.a94b		4c e6 af	jmp $afe6	                jmp initiateCFSRFSTubeTransfer
4352							                .endif

4354							; TAPE/ROM FSC 9 - *EX
4355							; --------------------
4356	.a94e						LA155:
4357	.a94e		a9 08		lda #$08	                lda #$08
4358	.a950		04 e2		tsb $e2		                tsb $E2
4359	.a952		a5 e3		lda $e3		                lda $E3
4360	.a954		48		pha		                pha
4361	.a955		09 cc		ora #$cc	                ora #$CC
4362	.a957		85 e3		sta $e3		                sta $E3
4363	.a959		20 74 af	jsr $af74	                jsr LA9F3
4364	.a95c		68		pla		                pla
4365	.a95d		85 e3		sta $e3		                sta $E3
4366	.a95f		80 07		bra $a968	                bra LA16F

4368							; TAPE/ROM FSC 5 - *CAT
4369							; ---------------------
4370	.a961						LA168:
4371	.a961		a9 08		lda #$08	                lda #$08
4372	.a963		04 e2		tsb $e2		                tsb $E2
4373	.a965		20 74 af	jsr $af74	                jsr LA9F3
4374	.a968						LA16F:
4375	.a968		a9 00		lda #$00	                lda #$00
4376	.a96a		20 72 a9	jsr $a972	                jsr LA17C
4377							                .if version!=400
4379							                .endif
4380	.a96d						LA177:
4381	.a96d		a9 08		lda #$08	                lda #$08
4382	.a96f		14 e2		trb $e2		                trb $E2
4383	.a971						LA17B:
4384	.a971		60		rts		                rts

4386	.a972						LA17C:
4387	.a972		48		pha		                pha
4388							                .if version!=400
4391							                .endif
4392	.a973		20 eb f4	jsr $f4eb	                jsr LF6FC
4393	.a976		20 f0 f4	jsr $f4f0	                jsr LF701
4394	.a979		b8		clv		                clv
4395	.a97a		b0 46		bcs $a9c2	                bcs LA1DB
4396	.a97c						LA18B:
4397	.a97c		20 1b ad	jsr $ad1b	                jsr LA678
4398	.a97f		ad c6 03	lda $03c6	                lda $03C6
4399	.a982		85 b4		sta $b4		                sta $B4
4400	.a984		ad c7 03	lda $03c7	                lda $03C7
4401	.a987		85 b5		sta $b5		                sta $B5
4402	.a989		a2 ff		ldx #$ff	                ldx #$FF
4403	.a98b		8e df 03	stx $03df	                stx $03DF
4404	.a98e		64 ba		stz $ba		                stz $BA
4405	.a990		80 11		bra $a9a3	                bra LA1B7

4407	.a992						LA1A1:
4408							                .if version!=400
4411							                .endif
4412	.a992						LA1A6:
4413	.a992		20 06 f5	jsr $f506	                jsr LF717
4414	.a995						LA1A9:
4415	.a995		a9 ff		lda #$ff	                lda #$FF
4416	.a997		8d c6 03	sta $03c6	                sta $03C6
4417	.a99a		8d c7 03	sta $03c7	                sta $03C7
4418	.a99d						LA1B1:
4419	.a99d		20 7e af	jsr $af7e	                jsr LAA35
4420	.a9a0		20 1b ad	jsr $ad1b	                jsr LA678
4421	.a9a3						LA1B7:
4422							                .if version!=400
4425							                .endif
4426	.a9a3		50 1d		bvc $a9c2	                bvc LA1DB
4427	.a9a5						LA1BE:
4428	.a9a5		68		pla		                pla
4429	.a9a6		48		pha		                pha
4430	.a9a7		f0 1b		beq $a9c4	                beq LA1DD
4431	.a9a9		20 09 af	jsr $af09	                jsr LA95C
4432	.a9ac		d0 e4		bne $a992	                bne LA1A1
4433	.a9ae		a9 30		lda #$30	                lda #$30
4434	.a9b0		25 bb		and $bb		                and $BB
4435	.a9b2		f0 0e		beq $a9c2	                beq LA1DB
4436	.a9b4		ad c6 03	lda $03c6	                lda $03C6
4437	.a9b7		c5 b6		cmp $b6		                cmp $B6
4438	.a9b9		d0 d7		bne $a992	                bne LA1A1
4439	.a9bb		ad c7 03	lda $03c7	                lda $03C7
4440	.a9be		c5 b7		cmp $b7		                cmp $B7
4441	.a9c0		d0 d0		bne $a992	                bne LA1A1
4442	.a9c2						LA1DB:
4443	.a9c2		68		pla		                pla
4444	.a9c3		60		rts		                rts

4446	.a9c4						LA1DD:
4447	.a9c4		50 05		bvc $a9cb	                bvc LA1E4
4448	.a9c6		a9 ff		lda #$ff	                lda #$FF
4449	.a9c8		20 68 ad	jsr $ad68	                jsr LA6D4
4450	.a9cb						LA1E4:
4451	.a9cb		a2 00		ldx #$00	                ldx #$00
4452	.a9cd		20 74 ae	jsr $ae74	                jsr LA8C4
4453							                .if version!=400
4456							                .endif
4457	.a9d0		24 bb		bit $bb		                bit $BB
4458	.a9d2		50 be		bvc $a992	                bvc LA1A6
4459	.a9d4						LA1F2:
4460	.a9d4		2c ca 03	bit $03ca	                bit $03CA
4461	.a9d7		30 bc		bmi $a995	                bmi LA1A9
4462	.a9d9		80 c2		bra $a99d	                bra LA1B1

4464							; CFS/RFS OSFIND HANDLER
4465							; ======================
4466	.a9db						osfindTapeOrROM:
4467	.a9db		85 bc		sta $bc		                sta $BC
4468	.a9dd		da		phx		                phx
4469	.a9de		5a		phy		                phy
4470	.a9df		09 00		ora #$00	                ora #$00
4471	.a9e1		d0 0f		bne $a9f2	                bne LA220
4472	.a9e3		98		tya		                tya
4473	.a9e4		d0 06		bne $a9ec	                bne LA212
4474							                .if version!=400
4478							                .endif
4479	.a9e6						LA20C:
4480	.a9e6		a9 01		lda #$01	                lda #$01
4481	.a9e8		14 e2		trb $e2		                trb $E2
4482							                .if version==400
4483	.a9ea		80 48		bra $aa34	                bra LA297
4486							                .endif
4487	.a9ec						LA212:
4488	.a9ec		4a		lsr a		                lsr a
4489	.a9ed		b0 f7		bcs $a9e6	                bcs LA20C
4490							                .if version!=400
4493							                .endif
4494	.a9ef		4c bc af	jmp $afbc	                jmp LAA81

4496							                .if version!=400
4501							                .endif

4503	.a9f2						LA220:
4504	.a9f2		20 bf a8	jsr $a8bf	                jsr LA06B
4505	.a9f5		24 bc		bit $bc		                bit $BC
4506	.a9f7		50 36		bvc $aa2f	                bvc LA260
4507	.a9f9		9c 9e 03	stz $039e	                stz $039E
4508	.a9fc		9c dd 03	stz $03dd	                stz $03DD
4509	.a9ff		9c de 03	stz $03de	                stz $03DE
4510	.aa02		a9 c1		lda #$c1	                lda #$C1
4511	.aa04		14 e2		trb $e2		                trb $E2
4512	.aa06		20 6b af	jsr $af6b	                jsr LA9E6
4513	.aa09		08		php		                php
4514	.aa0a		20 c2 ab	jsr $abc2	                jsr LA502
4515	.aa0d		20 6f ac	jsr $ac6f	                jsr LA5B7
4516	.aa10		28		plp		                plp
4517	.aa11		a2 ff		ldx #$ff	                ldx #$FF
4518	.aa13						LA241:
4519	.aa13		e8		inx		                inx
4520	.aa14		bd b2 03	lda $03b2,x	                lda $03B2,x
4521	.aa17		9d a7 03	sta $03a7,x	                sta $03A7,x
4522	.aa1a		d0 f7		bne $aa13	                bne LA241
4523	.aa1c		1a		inc a		                inc a
4524	.aa1d		04 e2		tsb $e2		                tsb $E2
4525	.aa1f		ad e9 02	lda $02e9	                lda tapeInputCurrentBlockSize+0
4526	.aa22		0d ea 02	ora $02ea	                ora tapeInputCurrentBlockSize+1
4527	.aa25		d0 04		bne $aa2b	                bne LA259
4528	.aa27		a9 40		lda #$40	                lda #$40
4529	.aa29		04 e2		tsb $e2		                tsb $E2
4530	.aa2b						LA259:
4531							                .if version==400
4532	.aa2b		a9 03		lda #$03	                lda #3
4533	.aa2d		d0 03		bne $aa32	                bne LA295
4534	.aa2f						LA260:
4535	.aa2f		4c bd fa	jmp $fabd	                jmp badCommandError
4571							                .endif
4572	.aa32						LA295:
4573	.aa32		85 bc		sta $bc		                sta $BC
4574	.aa34						LA297:
4575	.aa34		7a		ply		                ply
4576	.aa35		fa		plx		                plx
4577	.aa36		a5 bc		lda $bc		                lda $BC
4578	.aa38						LA29B:
4579	.aa38		60		rts		                rts

4581							                .if version!=400
4620							                .endif

4622	.aa39						bputTapeOrROM:
4623	.aa39		da		phx		                phx
4624	.aa3a		5a		phy		                phy
4625	.aa3b		a9 01		lda #$01	                lda #$01
4626	.aa3d						LA2EE:
4627	.aa3d		20 a3 af	jsr $afa3	                jsr LAA68
4628	.aa40		a5 e2		lda $e2		                lda $E2
4629	.aa42		0a		asl a		                asl a
4630	.aa43		b0 4d		bcs $aa92	                bcs LA343
4631	.aa45		0a		asl a		                asl a
4632	.aa46		90 08		bcc $aa50	                bcc LA301
4633	.aa48		a9 80		lda #$80	                lda #$80
4634	.aa4a		04 e2		tsb $e2		                tsb $E2
4635	.aa4c		a9 fe		lda #$fe	                lda #$FE
4636	.aa4e		b0 3a		bcs $aa8a	                bcs LA33B
4637	.aa50						LA301:
4638	.aa50		ae 9e 03	ldx $039e	                ldx $039E
4639	.aa53		e8		inx		                inx
4640	.aa54		ec e9 02	cpx $02e9	                cpx tapeInputCurrentBlockSize+0
4641	.aa57		d0 2c		bne $aa85	                bne LA336
4642	.aa59		2c eb 02	bit $02eb	                bit blockFlagOfCurrentlyResidentBlock
4643	.aa5c		30 23		bmi $aa81	                bmi LA332
4644	.aa5e		ad ec 02	lda $02ec	                lda lastCharacterOfCurrentlyResidentBlock
4645	.aa61		48		pha		                pha
4646	.aa62		20 6b af	jsr $af6b	                jsr LA9E6
4647	.aa65		08		php		                php
4648	.aa66		20 67 ac	jsr $ac67	                jsr LA5AF
4649	.aa69		28		plp		                plp
4650	.aa6a		68		pla		                pla
4651	.aa6b		85 bc		sta $bc		                sta $BC
4652	.aa6d		18		clc		                clc
4653	.aa6e		2c eb 02	bit $02eb	                bit blockFlagOfCurrentlyResidentBlock
4654	.aa71		10 19		bpl $aa8c	                bpl LA33D
4655	.aa73		ad e9 02	lda $02e9	                lda tapeInputCurrentBlockSize+0
4656	.aa76		0d ea 02	ora $02ea	                ora tapeInputCurrentBlockSize+1
4657	.aa79		d0 11		bne $aa8c	                bne LA33D
4658	.aa7b		a9 40		lda #$40	                lda #$40
4659	.aa7d		04 e2		tsb $e2		                tsb $E2
4660	.aa7f		80 0b		bra $aa8c	                bra LA33D

4662	.aa81						LA332:
4663	.aa81		a9 40		lda #$40	                lda #$40
4664	.aa83		04 e2		tsb $e2		                tsb $E2
4665	.aa85						LA336:
4666	.aa85		ca		dex		                dex
4667	.aa86		18		clc		                clc
4668	.aa87		bd 00 0a	lda $0a00,x	                lda $0A00,x
4669	.aa8a						LA33B:
4670	.aa8a		85 bc		sta $bc		                sta $BC
4671	.aa8c						LA33D:
4672	.aa8c		ee 9e 03	inc $039e	                inc $039E
4673	.aa8f		4c 34 aa	jmp $aa34	                jmp LA297

4675	.aa92						LA343:
4676	.aa92		20 23 b0	jsr $b023	                jsr doFollowingError
4677	>aa95		df 45 4f 46 00			                .text $df,"EOF",0

4679							                .if version==400
4680	.aa9a						osgbpbTapeOrROM:
4681	.aa9a						bgetTapeOrROM:
4682	.aa9a						LAA9A:
4683	.aa9a		c9 04		cmp #$04	                cmp #4
4684	.aa9c		f0 02		beq $aaa0	                beq LA378
4685	.aa9e		38		sec		                sec
4686	.aa9f		60		rts		                rts
4687							                .endif

4689							                .if version!=400
4707							                .endif

4709							                .if version!=400
4721							                .endif

4723							; Call Return
4724							;  0    A=0   SEC                        - unsupported
4725							;  1    A=0   SEC  Write using new PTR   - unsupported
4726							;  2    A=         Write with current PTR
4727							;  3    A=1   SEC  Read with new PTR     - unsupported
4728							;  4    A=         Read with current PTR
4729							;  5+   A=A/2 SEC                        - unsupported

4731							; TAPE/ROM OSGBPB 2 and 4 - read/write with current PTR
4732							; -----------------------------------------------------
4733	.aaa0						LA378:
4734							                .if version!=400
4736							                .endif
4737	.aaa0		86 cc		stx $cc		                stx $CC
4738	.aaa2		84 cd		sty $cd		                sty $CD
4739	.aaa4		a0 01		ldy #$01	                ldy #$01
4740	.aaa6		b1 cc		lda ($cc),y	                lda ($CC),y
4741	.aaa8		85 c8		sta $c8		                sta $C8                      ; address LSB
4742	.aaaa		c8		iny		                iny
4743	.aaab		b1 cc		lda ($cc),y	                lda ($CC),y
4744	.aaad		85 c9		sta $c9		                sta $C9                      ; address MSB
4745							                .if includeTubeSupport
4746	.aaaf		c8		iny		                iny
4747	.aab0		b1 cc		lda ($cc),y	                lda ($CC),y
4748	.aab2		c8		iny		                iny
4749	.aab3		31 cc		and ($cc),y	                and ($CC),y            ; A=$ff if bits 16-31 are $ffff
4750	.aab5		1a		inc a		                inc a              ; A!=$00 if bits 16-31 aren't $ffff
4751	.aab6		2d 7a 02	and $027a	                and tubePresence ; A!=$00 if copro address and copro present
4752	.aab9		48		pha		                pha              ; save copro usage flag
4753							                .if version!=400
4755							                .endif
4756	.aaba		f0 0d		beq $aac9	                beq LA3A7
4757	.aabc		a6 cc		ldx $cc		                ldx $CC
4758	.aabe		a4 cd		ldy $cd		                ldy $CD
4759	.aac0		e8		inx		                inx
4760	.aac1		d0 01		bne $aac4	                bne LA39E
4761	.aac3		c8		iny		                iny
4762	.aac4						LA39E:
4763							                .if version==400
4764							                ; no tape, so always host->parasite
4765	.aac4		a9 01		lda #$01	                lda #tubeReasonMultiByteHostToParasite
4776							                .endif                       ; includeTubeSupport
4777	.aac6		20 e6 af	jsr $afe6	                jsr initiateCFSRFSTubeTransfer
4778	.aac9						LA3A7:
4779							                .endif
4780	.aac9		b2 cc		lda ($cc)	                lda ($CC)                    ; A=handle
4781	.aacb		a8		tay		                tay                          ; Y=handle
4782	.aacc		a9 01		lda #$01	                lda #$01
4783							                .if version!=400
4789							                .endif
4790	.aace		20 c8 af	jsr $afc8	                jsr LAA8D
4791	.aad1		b0 0b		bcs $aade	                bcs LA3C1
4792							                .if version!=400
4794							                .endif
4795							                .if includeTubeSupport
4796	.aad3		68		pla		                pla                          ; restore copro usage flag
4797	.aad4		f0 05		beq $aadb	                beq LA3BE                    ; taken if not copro
4798	.aad6		a9 80		lda #$80	                lda #$80
4799	.aad8		20 06 04	jsr $0406	                jsr tubeHost.entryPoint
4800	.aadb						LA3BE:
4801							                .endif
4802	.aadb		4c bc af	jmp $afbc	                jmp LAA81

4804	.aade						LA3C1:
4805							                .if version!=400
4808							                .endif
4809	.aade		24 e2		bit $e2		                bit $E2
4810	.aae0		10 0b		bpl $aaed	                bpl LA3D3
4811							                .if includeTubeSupport
4812	.aae2		68		pla		                pla                          ; restore copro usage flag
4813	.aae3		f0 05		beq $aaea	                beq LA3D0                    ; taken if no copro usage
4814	.aae5		a9 80		lda #$80	                lda #$80                     ; $80 = RFS/CFS release Tube
4815	.aae7		20 06 04	jsr $0406	                jsr tubeHost.entryPoint
4816	.aaea						LA3D0:
4817							                .endif
4818	.aaea		4c 92 aa	jmp $aa92	                jmp LA343

4820	.aaed						LA3D3:
4821	.aaed		20 16 b0	jsr $b016	                jsr LAAE0
4822	.aaf0		f0 1e		beq $ab10	                beq LA3F6
4823	.aaf2		b2 cc		lda ($cc)	                lda ($CC)
4824	.aaf4		a8		tay		                tay
4825	.aaf5		20 39 aa	jsr $aa39	                jsr bputTapeOrROM
4826	.aaf8		b0 16		bcs $ab10	                bcs LA3F6
4827							                .if includeTubeSupport
4828	.aafa		fa		plx		                plx                          ; restore copro usage flag
4829	.aafb		da		phx		                phx                          ; save copro usage flag
4830	.aafc		f0 05		beq $ab03	                beq LA3E9                    ; taken if no copro usage
4831	.aafe		8d e5 fe	sta $fee5	                sta tube.data3               ; send byte to Tube
4832	.ab01		80 08		bra $ab0b	                bra LA3F1

4834	.ab03						LA3E9:
4835							                .endif
4836	.ab03		92 c8		sta ($c8)	                sta ($C8)                    ; store the byte to I/O RAM
4837	.ab05		e6 c8		inc $c8		                inc $C8                      ; next address...
4838	.ab07		d0 02		bne $ab0b	                bne LA3F1
4839	.ab09		e6 c9		inc $c9		                inc $C9
4840	.ab0b						LA3F1:
4841	.ab0b		20 00 b0	jsr $b000	                jsr LAACA
4842	.ab0e		80 dd		bra $aaed	                bra LA3D3

4844	.ab10						LA3F6:
4845							                .if includeTubeSupport
4846	.ab10		68		pla		                pla                          ; restore copro usage flag
4847	.ab11		08		php		                php
4848	.ab12		f0 05		beq $ab19	                beq LA3FF                    ; taken if not copro usage
4849	.ab14		a9 80		lda #$80	                lda #$80                     ; $80 = RFS/CFS release Tube
4850	.ab16		20 06 04	jsr $0406	                jsr tubeHost.entryPoint
4851	.ab19						LA3FF:
4852	.ab19		28		plp		                plp
4853							                .endif
4854	.ab1a		60		rts		                rts

4856							                .if version!=400
4879							                .endif

4881							; TAPE/ROM FSC 0 - *OPT
4882							; ---------------------
4883	.ab1b						LA422:
4884	.ab1b		8a		txa		                txa                          ; *OPT 0
4885	.ab1c		f0 2e		beq $ab4c	                beq LA453
4886	.ab1e		e0 03		cpx #$03	                cpx #$03                     ; *OPT 3
4887	.ab20		f0 1f		beq $ab41	                beq LA448
4888	.ab22		c0 03		cpy #$03	                cpy #$03                     ; *OPT n,3+ - error Bad command (*BUG* should be Bad option)
4889	.ab24		b0 06		bcs $ab2c	                bcs LA433
4890	.ab26		ca		dex		                dex                          ; *OPT 1
4891	.ab27		f0 06		beq $ab2f	                beq LA436
4892	.ab29		ca		dex		                dex                          ; *OPT 2
4893	.ab2a		f0 0a		beq $ab36	                beq LA43D
4894	.ab2c						LA433:
4895	.ab2c		4c bd fa	jmp $fabd	                jmp badCommandError ; *OPT 4+ - error Bad command (*BUG* should be Bad option)

4897							; *OPT 1 - set message level
4898							; --------------------------
4899	.ab2f						LA436:
4900	.ab2f		a9 33		lda #$33	                lda #$33
4901	.ab31		c8		iny		                iny
4902	.ab32		c8		iny		                iny
4903	.ab33		c8		iny		                iny
4904	.ab34		80 02		bra $ab38	                bra LA43F

4906							; *OPT 2 - set error response level
4907							; ---------------------------------
4908	.ab36						LA43D:
4909	.ab36		a9 cc		lda #$cc	                lda #$CC
4910	.ab38						LA43F:
4911	.ab38		c8		iny		                iny
4912	.ab39		25 e3		and $e3		                and $E3
4913	.ab3b						LA442:
4914	.ab3b		19 4f ab	ora $ab4f,y	                ora LA456,y
4915	.ab3e		85 e3		sta $e3		                sta $E3
4916	.ab40		60		rts		                rts

4918							; *OPT 3 - set interblock gap
4919							; ---------------------------
4920	.ab41						LA448:
4921	.ab41		98		tya		                tya                          ; *OPT 3,128+ - set to default
4922	.ab42		30 02		bmi $ab46	                bmi LA44D    ;
4923	.ab44		d0 02		bne $ab48	                bne LA44F                    ; *OPT 3,<>0 - use setting
4924	.ab46						LA44D:
4925	.ab46		a9 19		lda #$19	                lda #$19                     ; *OPT 3,0 or *OPT 3,128+ - use default of 2.5 sec
4926	.ab48						LA44F:
4927	.ab48		8d d1 03	sta $03d1	                sta $03D1                    ; Set inter-block gap
4928	.ab4b		60		rts		                rts

4930	.ab4c						LA453:
4931	.ab4c		a8		tay		                tay
4932	.ab4d		80 ec		bra $ab3b	                bra LA442

4934	.ab4f						LA456:
4935							                ; LDA ($00,x)
4936							                ; EQUB $22
4937							                ; ORA ($00),y
4938							                ; DEY
4939							                ; CPY LC0C6
4940	>ab4f		a1				                .byte $A1
4941	>ab50		00				                .byte $00
4942	>ab51		22				                .byte $22
4943	>ab52		11				                .byte $11
4944	>ab53		00				                .byte $00
4945	>ab54		88				                .byte $88
4946	>ab55		cc				                .byte $CC

4948							                .if version!=400
4984							                .endif

4986	.ab56						LA492:
4987							                .if version==400
4988	.ab56		20 ff f4	jsr $f4ff	                jsr LF710
4989	.ab59		a8		tay		                tay
4990	.ab5a		18		clc		                clc
4991	.ab5b		a6 c2		ldx $c2		                ldx $c2
4992	.ab5d		ca		dex		                dex
4993	.ab5e		f0 50		beq $abb0	                beq LA4F0
4994	.ab60		ca		dex		                dex
4995	.ab61		d0 11		bne $ab74	                bne LA4A8
5000							                .endif
5001	.ab63		98		tya		                tya
5002	.ab64		20 8d af	jsr $af8d	                jsr LAA44
5003	.ab67		a0 03		ldy #$03	                ldy #$03
5004	.ab69		c9 2a		cmp #$2a	                cmp #$2A
5005	.ab6b		f0 41		beq $abae	                beq LA4EE
5006	.ab6d		20 7b af	jsr $af7b	                jsr LAA1C
5007	.ab70		a0 01		ldy #$01	                ldy #$01
5008	.ab72		80 3a		bra $abae	                bra LA4EE

5010	.ab74						LA4A8:
5011	.ab74		ca		dex		                dex
5012	.ab75		d0 03		bne $ab7a	                bne LA4B5
5013							                .if version!=400
5015							                .endif
5016	.ab77		84 bd		sty $bd		                sty $BD
5017	.ab79		60		rts		                rts

5019							                .if version!=400
5024							                .endif

5026	.ab7a						LA4B5:
5027	.ab7a		ca		dex		                dex
5028	.ab7b		d0 27		bne $aba4	                bne LA4E1
5029							                .if version!=400
5031							                .endif
5032	.ab7d		98		tya		                tya
5033	.ab7e		20 42 ad	jsr $ad42	                jsr LA6A9
5034	.ab81		a4 bc		ldy $bc		                ldy $BC
5035	.ab83		e6 bc		inc $bc		                inc $BC
5036	.ab85		24 bd		bit $bd		                bit $BD
5037	.ab87		30 0d		bmi $ab96	                bmi LA4D3
5038							                .if includeTubeSupport
5039	.ab89		20 f2 af	jsr $aff2	                jsr isTubeAddress
5040	.ab8c		f0 05		beq $ab93	                beq LA4D0                    ; taken if not Tube address
5041	.ab8e		8e e5 fe	stx $fee5	                stx tube.data3
5042	.ab91		80 03		bra $ab96	                bra LA4D3

5044	.ab93						LA4D0:
5045	.ab93		8a		txa		                txa                          ; A=byte to write
5046							                .endif
5047	.ab94		91 b0		sta ($b0),y	                sta ($B0),y                  ; store byte to I/O RAM
5048	.ab96						LA4D3:
5049	.ab96		c8		iny		                iny
5050	.ab97		cc c8 03	cpy $03c8	                cpy $03C8
5051	.ab9a		d0 14		bne $abb0	                bne LA4F0
5052	.ab9c		a9 01		lda #$01	                lda #$01
5053	.ab9e		85 bc		sta $bc		                sta $BC
5054	.aba0		a0 05		ldy #$05	                ldy #$05
5055	.aba2		80 0a		bra $abae	                bra LA4EE

5057	.aba4						LA4E1:
5058	.aba4		98		tya		                tya
5059	.aba5		20 42 ad	jsr $ad42	                jsr LA6A9
5060	.aba8		c6 bc		dec $bc		                dec $BC
5061	.abaa		10 04		bpl $abb0	                bpl LA4F0
5062							                .if version!=400
5065							                .endif
5066	.abac		a0 00		ldy #$00	                ldy #$00
5067	.abae						LA4EE:
5068	.abae		84 c2		sty $c2		                sty $C2
5069	.abb0						LA4F0:
5070	.abb0		60		rts		                rts

5072							; TAPE/ROM FSC 1 - =EOF
5073							; ---------------------
5074	.abb1						LA4F1:
5075	.abb1		48		pha		                pha
5076	.abb2		5a		phy		                phy
5077	.abb3		8a		txa		                txa
5078	.abb4		a8		tay		                tay
5079	.abb5		a9 03		lda #$03	                lda #$03                     ; Check if this channel is open for anything
5080	.abb7		20 a3 af	jsr $afa3	                jsr LAA68
5081	.abba		a5 e2		lda $e2		                lda $E2                      ; Get EOF flag
5082	.abbc		29 40		and #$40	                and #$40
5083	.abbe		aa		tax		                tax                          ; Return in X
5084	.abbf		7a		ply		                ply
5085	.abc0		68		pla		                pla
5086	.abc1		60		rts		                rts

5088	.abc2						LA502:
5089	.abc2		64 b4		stz $b4		                stz $B4
5090	.abc4		64 b5		stz $b5		                stz $B5
5091	.abc6						LA506:
5092	.abc6		46 ce		lsr $ce		                lsr $CE
5093	.abc8		a5 b4		lda $b4		                lda $B4
5094	.abca		48		pha		                pha
5095	.abcb		85 b6		sta $b6		                sta $B6
5096	.abcd		a5 b5		lda $b5		                lda $B5
5097	.abcf		48		pha		                pha
5098	.abd0		85 b7		sta $b7		                sta $B7
5099	.abd2		20 d0 ae	jsr $aed0	                jsr LA923
5100	>abd5		53 65 61 72 63 68 69 6e		                .text "Searching",13,0
	>abdd		67 0d 00
5101	.abe0		a9 ff		lda #$ff	                lda #$ff
5102	.abe2		20 72 a9	jsr $a972	                jsr LA17C
5103	.abe5		68		pla		                pla
5104	.abe6		85 b5		sta $b5		                sta $B5
5105	.abe8		68		pla		                pla
5106	.abe9		85 b4		sta $b4		                sta $B4
5107	.abeb		a5 b6		lda $b6		                lda $B6
5108	.abed		05 b7		ora $b7		                ora $B7
5109	.abef		d0 2b		bne $ac1c	                bne LA564
5110	.abf1		64 b4		stz $b4		                stz $B4
5111	.abf3		64 b5		stz $b5		                stz $B5
5112							                .if version!=400
5115							                .endif
5116	.abf5		70 1c		bvs $ac13	                bvs LA55B
5117							                .if version!=400
5119							                .endif
5120	.abf7		24 ce		bit $ce		                bit $CE
5121	.abf9		50 0a		bvc $ac05	                bvc notFoundError
5122	.abfb		38		sec		                sec
5123	.abfc						rtsA544:
5124	.abfc		60		rts		                rts

5126							;-------------------------------------------------------------------------

5128	.abfd						openFileForReading:
5129	.abfd		a9 40		lda #$40	                lda #$40                     ;open for reading
5130	.abff		20 ce ff	jsr $ffce	                jsr OSFIND
5131	.ac02		a8		tay		                tay
5132	.ac03		d0 f7		bne $abfc	                bne rtsA544
5133	.ac05						notFoundError:
5134	.ac05		20 23 b0	jsr $b023	                jsr doFollowingError
5135	>ac08		d6 4e 6f 74 20 66 6f 75		                .text $d6,"Not found",0
	>ac10		6e 64 00

5137							;-------------------------------------------------------------------------

5139	.ac13						LA55B:
5140	.ac13		a5 c1		lda $c1		                lda $C1
5141	.ac15		d0 05		bne $ac1c	                bne LA564
5142	.ac17		a2 b1		ldx #$b1	                ldx #$B1
5143	.ac19		20 96 af	jsr $af96	                jsr LAA4D
5144	.ac1c						LA564:
5145	.ac1c		a0 ff		ldy #$ff	                ldy #$FF
5146	.ac1e		8c df 03	sty $03df	                sty $03DF
5147	.ac21		18		clc		                clc
5148	.ac22		60		rts		                rts

5150	.ac23						LA56B:
5151	.ac23		f0 17		beq $ac3c	                beq LA584
5152	.ac25		48		pha		                pha
5153	.ac26		a9 07		lda #$07	                lda #fscFileHandleRange
5154	.ac28		20 d4 ef	jsr $efd4	                jsr callFSCV
5155	.ac2b		68		pla		                pla
5156	.ac2c		18		clc		                clc
5157	.ac2d		08		php		                php
5158	.ac2e		78		sei		                sei
5159	.ac2f		85 fa		sta $fa		                sta $FA
5160	.ac31		c4 fa		cpy $fa		                cpy $FA
5161	.ac33		90 06		bcc $ac3b	                bcc LA583
5162	.ac35		e4 fa		cpx $fa		                cpx $FA
5163	.ac37		90 06		bcc $ac3f	                bcc LA587
5164	.ac39		f0 04		beq $ac3f	                beq LA587
5165	.ac3b						LA583:
5166	.ac3b		28		plp		                plp
5167	.ac3c						LA584:
5168	.ac3c		68		pla		                pla
5169	.ac3d		68		pla		                pla
5170	.ac3e		60		rts		                rts

5172	.ac3f						LA587:
5173	.ac3f		28		plp		                plp
5174	.ac40		a9 00		lda #$00	                lda #$00
5175	.ac42		60		rts		                rts

5177	.ac43						LA58B:
5178	.ac43		ad 56 02	lda $0256	                lda execFileHandle
5179	.ac46		20 23 ac	jsr $ac23	                jsr LA56B
5180	.ac49						starEXEC:
5181	.ac49		08		php		                php
5182	.ac4a		5a		phy		                phy
5183	.ac4b		ac 56 02	ldy $0256	                ldy execFileHandle
5184	.ac4e		8d 56 02	sta $0256	                sta execFileHandle
5185	.ac51		f0 03		beq $ac56	                beq LA59E
5186	.ac53		20 ce ff	jsr $ffce	                jsr OSFIND
5187	.ac56						LA59E:
5188	.ac56		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
5189	.ac59		7a		ply		                ply
5190	.ac5a		28		plp		                plp
5191	.ac5b		f0 09		beq $ac66	                beq LA5AE
5192	.ac5d		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
5193	.ac60		20 fd ab	jsr $abfd	                jsr openFileForReading
5194	.ac63		8d 56 02	sta $0256	                sta execFileHandle
5195	.ac66						LA5AE:
5196	.ac66		60		rts		                rts

5198	.ac67						LA5AF:
5199	.ac67		a2 a6		ldx #$a6	                ldx #$A6
5200	.ac69		20 96 af	jsr $af96	                jsr LAA4D
5201	.ac6c		20 1b ad	jsr $ad1b	                jsr LA678
5202	.ac6f						LA5B7:
5203	.ac6f		ad ca 03	lda $03ca	                lda $03CA
5204	.ac72		4a		lsr a		                lsr a
5205	.ac73		90 03		bcc $ac78	                bcc LA5C0
5206	.ac75		4c 37 a8	jmp $a837	                jmp L9FE3

5208	.ac78						LA5C0:
5209	.ac78		ad dd 03	lda $03dd	                lda $03DD
5210	.ac7b		85 b4		sta $b4		                sta $B4
5211	.ac7d		ad de 03	lda $03de	                lda $03DE
5212	.ac80		85 b5		sta $b5		                sta $B5
5213	.ac82		64 b0		stz $b0		                stz $B0
5214	.ac84		a9 0a		lda #$0a	                lda #$0A
5215	.ac86		85 b1		sta $b1		                sta $B1
5216	.ac88		a9 ff		lda #$ff	                lda #$FF
5217	.ac8a		85 b2		sta $b2		                sta $B2
5218	.ac8c		85 b3		sta $b3		                sta $B3
5219	.ac8e		20 66 ad	jsr $ad66	                jsr LA6D2
5220	.ac91		20 51 ae	jsr $ae51	                jsr LA8A1
5221	.ac94		d0 25		bne $acbb	                bne LA603
5222	.ac96		ad ff 0a	lda $0aff	                lda $0AFF
5223	.ac99		8d ec 02	sta $02ec	                sta lastCharacterOfCurrentlyResidentBlock
5224	.ac9c		20 7e af	jsr $af7e	                jsr LAA35
5225	.ac9f		8e dd 03	stx $03dd	                stx $03DD
5226	.aca2		8c de 03	sty $03de	                sty $03DE
5227	.aca5		a2 02		ldx #$02	                ldx #$02
5228	.aca7						LA5EF:
5229	.aca7		bd c8 03	lda $03c8,x	                lda $03C8,x
5230	.acaa		9d e9 02	sta $02e9,x	                sta tapeInputCurrentBlockSize+0,x
5231	.acad		ca		dex		                dex
5232	.acae		10 f7		bpl $aca7	                bpl LA5EF
5233	.acb0		2c eb 02	bit $02eb	                bit blockFlagOfCurrentlyResidentBlock
5234	.acb3		10 03		bpl $acb8	                bpl LA600
5235	.acb5		20 ad a8	jsr $a8ad	                jsr LA059
5236	.acb8						LA600:
5237	.acb8		4c 6a af	jmp $af6a	                jmp LA9C5

5239	.acbb						LA603:
5240	.acbb		20 c6 ab	jsr $abc6	                jsr LA506
5241	.acbe		80 af		bra $ac6f	                bra LA5B7

5243	.acc0						LA608:
5244	.acc0		c9 2a		cmp #$2a	                cmp #'*'
5245	.acc2		f0 22		beq $ace6	                beq LA643
5246	.acc4		c9 23		cmp #$23	                cmp #'#'
5247	.acc6		d0 0f		bne $acd7	                bne LA61F
5248	.acc8		ee c6 03	inc $03c6	                inc $03C6
5249	.accb		d0 03		bne $acd0	                bne LA618
5250	.accd		ee c7 03	inc $03c7	                inc $03C7
5251	.acd0						LA618:
5252	.acd0		a2 ff		ldx #$ff	                ldx #$FF
5253	.acd2		2c 5e e3	bit $e35e	                bit valueFF
5254	.acd5		80 3c		bra $ad13	                bra LA670

5256	.acd7						LA61F:
5257	.acd7		20 6d a9	jsr $a96d	                jsr LA177
5258	.acda		20 23 b0	jsr $b023	                jsr doFollowingError
5259	>acdd		d7				                .byte $D7
5260	>acde		42 61 64 20 52 4f 4d		                .text "Bad ROM"
5261	>ace5		00				                .byte 0

5263	.ace6						LA62E:
5264							                .if version!=400
5275							                .endif
5276	.ace6						LA643:
5277	.ace6		20 8f af	jsr $af8f	                jsr LAA46
5278	.ace9						LA646:
5279	.ace9		20 32 ad	jsr $ad32	                jsr LA694
5280	.acec		50 1a		bvc $ad08	                bvc LA665
5281	.acee		99 b2 03	sta $03b2,y	                sta $03B2,y
5282	.acf1		f0 06		beq $acf9	                beq LA656
5283	.acf3		c8		iny		                iny
5284	.acf4		c0 0b		cpy #$0b	                cpy #$0B
5285	.acf6		d0 f1		bne $ace9	                bne LA646
5286	.acf8		88		dey		                dey
5287	.acf9						LA656:
5288	.acf9		a2 0c		ldx #$0c	                ldx #$0C
5289	.acfb						LA658:
5290	.acfb		20 32 ad	jsr $ad32	                jsr LA694
5291	.acfe		50 08		bvc $ad08	                bvc LA665
5292	.ad00		9d b2 03	sta $03b2,x	                sta $03B2,x
5293	.ad03		e8		inx		                inx
5294	.ad04		e0 1f		cpx #$1f	                cpx #$1F
5295	.ad06		d0 f3		bne $acfb	                bne LA658
5296	.ad08						LA665:
5297	.ad08		98		tya		                tya
5298	.ad09		aa		tax		                tax
5299	.ad0a		9e b2 03	stz $03b2,x	                stz $03B2,x
5300	.ad0d		a5 be		lda $be		                lda $BE
5301	.ad0f		05 bf		ora $bf		                ora $BF
5302	.ad11		85 c1		sta $c1		                sta $C1
5303	.ad13						LA670:
5304	.ad13		20 8d af	jsr $af8d	                jsr LAA44
5305	.ad16		84 c2		sty $c2		                sty $C2
5306	.ad18		8a		txa		                txa
5307							                .if version<500
5308	.ad19		d0 4a		bne $ad65	                bne LA6CC
5311							                .endif
5312	.ad1b						LA678:
5313							                .if version!=400
5316							                .endif
5317	.ad1b						LA67D:
5318	.ad1b		20 ff f4	jsr $f4ff	                jsr LF710
5319	.ad1e		c9 2b		cmp #$2b	                cmp #$2B
5320	.ad20		d0 9e		bne $acc0	                bne LA608
5321	.ad22		a9 08		lda #$08	                lda #$08
5322	.ad24		25 e2		and $e2		                and $E2
5323	.ad26		f0 03		beq $ad2b	                beq LA68D
5324	.ad28		20 b1 a8	jsr $a8b1	                jsr LA05D
5325	.ad2b						LA68D:
5326	.ad2b		20 f0 f4	jsr $f4f0	                jsr LF701
5327	.ad2e		90 eb		bcc $ad1b	                bcc LA67D
5328	.ad30		b8		clv		                clv
5329	.ad31		60		rts		                rts

5331	.ad32						LA694:
5332							                .if version!=400
5335							                .endif
5336	.ad32		da		phx		                phx
5337	.ad33		5a		phy		                phy
5338	.ad34		20 ff f4	jsr $f4ff	                jsr LF710
5339	.ad37		85 bd		sta $bd		                sta $BD
5340	.ad39		a9 ff		lda #$ff	                lda #$FF
5341	.ad3b		85 c0		sta $c0		                sta $C0
5342	.ad3d		7a		ply		                ply
5343	.ad3e		fa		plx		                plx
5344	.ad3f						LA6A6:
5345	.ad3f		20 7d ad	jsr $ad7d	                jsr LA778
5346	.ad42						LA6A9:
5347							                .if version<500
5348	.ad42		08		php		                php
5349	.ad43		48		pha		                pha
5350	.ad44		38		sec		                sec
5351	.ad45		66 cb		ror $cb		                ror $CB
5352	.ad47		45 bf		eor $bf		                eor $BF
5353	.ad49		85 bf		sta $bf		                sta $BF
5354	.ad4b						LA6B2:
5355	.ad4b		a5 bf		lda $bf		                lda $BF
5356	.ad4d		18		clc		                clc
5357	.ad4e		10 0b		bpl $ad5b	                bpl LA6C2
5358	.ad50		49 08		eor #$08	                eor #$08
5359	.ad52		85 bf		sta $bf		                sta $BF
5360	.ad54		a5 be		lda $be		                lda $BE
5361	.ad56		49 10		eor #$10	                eor #$10
5362	.ad58		85 be		sta $be		                sta $BE
5363	.ad5a		38		sec		                sec
5364	.ad5b						LA6C2:
5365	.ad5b		26 be		rol $be		                rol $BE
5366	.ad5d		26 bf		rol $bf		                rol $BF
5367	.ad5f		46 cb		lsr $cb		                lsr $CB
5368	.ad61		d0 e8		bne $ad4b	                bne LA6B2
5369	.ad63		68		pla		                pla
5370	.ad64		28		plp		                plp
5371							                .endif
5372	.ad65						LA6CC:
5373	.ad65		60		rts		                rts

5375							                .if version!=400
5379							                .endif

5381	.ad66						LA6D2:                                       ;AAAB in MOS 5.00
5382	.ad66		a9 00		lda #$00	                lda #$00
5383	.ad68						LA6D4:
5384	.ad68		85 bd		sta $bd		                sta $BD
5385	.ad6a		a2 00		ldx #$00	                ldx #$00
5386	.ad6c		64 bc		stz $bc		                stz $BC
5387	.ad6e		50 0a		bvc $ad7a	                bvc LA6E6
5388	.ad70		ad c8 03	lda $03c8	                lda $03C8
5389	.ad73		0d c9 03	ora $03c9	                ora $03C9
5390	.ad76		f0 02		beq $ad7a	                beq LA6E6
5391	.ad78		a2 04		ldx #$04	                ldx #$04
5392	.ad7a						LA6E6:
5393	.ad7a		86 c2		stx $c2		                stx $C2
5394	.ad7c						rtsAAC1:
5395	.ad7c		60		rts		                rts

5397							                .if version!=400
5484							                .endif

5486	.ad7d						LA778:
5487	.ad7d		20 30 ae	jsr $ae30	                jsr LA880
5488	.ad80		24 c0		bit $c0		                bit $C0
5489	.ad82		10 f9		bpl $ad7d	                bpl LA778
5490	.ad84		64 c0		stz $c0		                stz $C0
5491	.ad86		a5 bd		lda $bd		                lda $BD
5492	.ad88		60		rts		                rts

5494							                .if version!=400
5512							                .endif

5514	.ad89						LA79B:
5515	.ad89		ad c6 03	lda $03c6	                lda $03C6
5516	.ad8c		0d c7 03	ora $03c7	                ora $03C7
5517	.ad8f		f0 05		beq $ad96	                beq LA7A8
5518	.ad91		2c df 03	bit $03df	                bit $03DF
5519	.ad94		10 03		bpl $ad99	                bpl LA7AB
5520	.ad96						LA7A8:
5521	.ad96		20 ad a8	jsr $a8ad	                jsr LA059
5522	.ad99						LA7AB:
5523	.ad99		a0 00		ldy #$00	                ldy #$00
5524	.ad9b		64 ba		stz $ba		                stz $BA
5525	.ad9d		ad ca 03	lda $03ca	                lda $03CA
5526	.ada0		8d df 03	sta $03df	                sta $03DF
5527	.ada3		20 9b ec	jsr $ec9b	                jsr LEF1B
5528	.ada6		f0 62		beq $ae0a	                beq LA821
5529	.ada8		a9 0d		lda #$0d	                lda #$0D
5530	.adaa		20 ee ff	jsr $ffee	                jsr OSWRCH
5531	.adad						LA7BF:
5532	.adad		b9 b2 03	lda $03b2,y	                lda $03B2,y
5533	.adb0		f0 10		beq $adc2	                beq LA7D4
5534	.adb2		c9 20		cmp #$20	                cmp #$20
5535	.adb4		90 04		bcc $adba	                bcc LA7CC
5536	.adb6		c9 7f		cmp #$7f	                cmp #$7F
5537	.adb8		90 02		bcc $adbc	                bcc LA7CE
5538	.adba						LA7CC:
5539	.adba		a9 3f		lda #$3f	                lda #$3F
5540	.adbc						LA7CE:
5541	.adbc		20 ee ff	jsr $ffee	                jsr OSWRCH
5542	.adbf		c8		iny		                iny
5543	.adc0		d0 eb		bne $adad	                bne LA7BF

5545	.adc2						LA7D4:
5546							                .if version!=400
5549							                .endif
5550	.adc2		24 bb		bit $bb		                bit $BB
5551	.adc4		50 44		bvc $ae0a	                bvc LA821
5552	.adc6						LA7DD:
5553	.adc6		20 6f a7	jsr $a76f	                jsr printSpace
5554	.adc9		c8		iny		                iny
5555	.adca		c0 0b		cpy #$0b	                cpy #$0B
5556	.adcc		90 f4		bcc $adc2	                bcc LA7D4
5557	.adce		ad c6 03	lda $03c6	                lda $03C6
5558	.add1		aa		tax		                tax
5559	.add2		20 1a ae	jsr $ae1a	                jsr printHexByte
5560	.add5		2c ca 03	bit $03ca	                bit $03CA
5561	.add8		10 30		bpl $ae0a	                bpl LA821
5562	.adda		8a		txa		                txa
5563	.addb		18		clc		                clc
5564	.addc		6d c9 03	adc $03c9	                adc $03C9
5565	.addf		20 15 ae	jsr $ae15	                jsr printSpaceThenPrintHexByte
5566	.ade2						LA7F9:
5567	.ade2		ad c8 03	lda $03c8	                lda $03C8
5568	.ade5		20 1a ae	jsr $ae1a	                jsr printHexByte
5569	.ade8		24 bb		bit $bb		                bit $BB
5570	.adea		50 1e		bvc $ae0a	                bvc LA821
5571	.adec		a2 04		ldx #$04	                ldx #$04
5572	.adee						LA805:
5573	.adee		20 6f a7	jsr $a76f	                jsr printSpace
5574	.adf1		ca		dex		                dex
5575	.adf2		d0 fa		bne $adee	                bne LA805
5576	.adf4		a2 0f		ldx #$0f	                ldx #$0F
5577	.adf6		20 fe ad	jsr $adfe	                jsr LA815
5578	.adf9		20 6f a7	jsr $a76f	                jsr printSpace
5579	.adfc		a2 13		ldx #$13	                ldx #$13
5580	.adfe						LA815:
5581	.adfe		a0 04		ldy #$04	                ldy #$04
5582	.ae00						LA817:
5583	.ae00		bd b2 03	lda $03b2,x	                lda $03B2,x
5584	.ae03		20 1a ae	jsr $ae1a	                jsr printHexByte
5585	.ae06		ca		dex		                dex
5586	.ae07		88		dey		                dey
5587	.ae08		d0 f6		bne $ae00	                bne LA817
5588	.ae0a						LA821:
5589	.ae0a		60		rts		                rts

5591							                .if version!=400
5613							                .endif

5615							;-------------------------------------------------------------------------

5617							                .if version==350
5619							                .endif

5621							;-------------------------------------------------------------------------


5624	.ae0b						LA85B:
5625	.ae0b		a2 fd		ldx #$fd	                ldx #$FD
5626	.ae0d						LA85D:
5627	.ae0d		f6 b4		inc $b4,x	                inc $B4,x
5628	.ae0f		d0 03		bne $ae14	                bne LA864
5629	.ae11		e8		inx		                inx
5630	.ae12		d0 f9		bne $ae0d	                bne LA85D
5631	.ae14						LA864:
5632	.ae14		60		rts		                rts

5634							;-------------------------------------------------------------------------

5636	.ae15						printSpaceThenPrintHexByte:
5637	.ae15		48		pha		                pha
5638	.ae16		20 6f a7	jsr $a76f	                jsr printSpace
5639	.ae19		68		pla		                pla
5640	.ae1a						printHexByte:
5641	.ae1a		48		pha		                pha
5642							                .if version==350
5644							                .else
5645	.ae1b		4a		lsr a		                lsr a
5646	.ae1c		4a		lsr a		                lsr a
5647	.ae1d		4a		lsr a		                lsr a
5648	.ae1e		4a		lsr a		                lsr a
5649							                .endif
5650	.ae1f		20 23 ae	jsr $ae23	                jsr printHexDigit
5651	.ae22		68		pla		                pla
5652	.ae23						printHexDigit:
5653	.ae23		29 0f		and #$0f	                and #$0F
5654	.ae25		09 30		ora #$30	                ora #'0'                     ;+'0'
5655	.ae27		c9 3a		cmp #$3a	                cmp #'9'+1
5656	.ae29		90 02		bcc $ae2d	                bcc LA87D                    ;taken if <='9'
5657	.ae2b		69 06		adc #$06	                adc #'A'-('9'+1)-1           ;adjust - -1 because C set
5658	.ae2d						LA87D:
5659	.ae2d		4c ee ff	jmp $ffee	                jmp OSWRCH

5661							;-------------------------------------------------------------------------

5663	.ae30						LA880:
5664	.ae30		08		php		                php
5665	.ae31		24 eb		bit $eb		                bit $EB
5666	.ae33		30 04		bmi $ae39	                bmi LA889
5667	.ae35		24 ff		bit $ff		                bit $FF
5668	.ae37		30 02		bmi $ae3b	                bmi LA88B
5669	.ae39						LA889:
5670	.ae39		28		plp		                plp
5671	.ae3a		60		rts		                rts

5673	.ae3b						LA88B:
5674	.ae3b		20 6d a9	jsr $a96d	                jsr LA177
5675	.ae3e		20 60 af	jsr $af60	                jsr LA9BB
5676	.ae41						escapeError:
5677	.ae41		a9 7e		lda #$7e	                lda #$7E
5678	.ae43		20 f4 ff	jsr $fff4	                jsr OSBYTE
5679	.ae46		20 23 b0	jsr $b023	                jsr doFollowingError
5680	>ae49		11				                .byte $11
5681	>ae4a		45 73 63 61 70 65		                .text "Escape"
5682	>ae50		00				                .byte $00

5684							;-------------------------------------------------------------------------

5686	.ae51						LA8A1:
5687	.ae51		98		tya		                tya
5688	.ae52		f0 0d		beq $ae61	                beq LA8B1
5689	.ae54		20 d0 ae	jsr $aed0	                jsr LA923
5690	>ae57		0d				                .byte $0D
5691	>ae58		4c 6f 61 64 69 6e 67		                .text "Loading"
5692	>ae5f		0d				                .byte $0D
5693	>ae60		00				                .byte $00
5694	.ae61						LA8B1:
5695	.ae61		64 ba		stz $ba		                stz $BA                      ; :
5696	.ae63		a2 ff		ldx #$ff	                ldx #$FF
5697	.ae65		a5 c1		lda $c1		                lda $C1
5698	.ae67		d0 0b		bne $ae74	                bne LA8C4
5699	.ae69		20 09 af	jsr $af09	                jsr LA95C
5700	.ae6c		08		php		                php
5701	.ae6d		a2 ff		ldx #$ff	                ldx #$FF
5702	.ae6f		a0 47		ldy #$47	                ldy #<fileError
5703							                .cwarn (>fileError)!=(>dataError),"must be on same page"
5704	.ae71		28		plp		                plp
5705	.ae72		d0 16		bne $ae8a	                bne LA8DA
5706	.ae74						LA8C4:
5707	.ae74		a0 3a		ldy #$3a	                ldy #<dataError
5708	.ae76		a5 c1		lda $c1		                lda $C1
5709	.ae78		d0 10		bne $ae8a	                bne LA8DA
5710	.ae7a		ad c6 03	lda $03c6	                lda $03C6
5711	.ae7d		c5 b4		cmp $b4		                cmp $B4
5712	.ae7f		d0 07		bne $ae88	                bne LA8D8
5713	.ae81		ad c7 03	lda $03c7	                lda $03C7
5714	.ae84		c5 b5		cmp $b5		                cmp $B5
5715	.ae86		f0 0b		beq $ae93	                beq LA8E3
5716	.ae88						LA8D8:
5717	.ae88		a0 54		ldy #$54	                ldy #<blockError
5718							                .cwarn (>blockError)!=(>dataError),"must be on same page"
5719	.ae8a						LA8DA:
5720	.ae8a		5a		phy		                phy
5721	.ae8b		da		phx		                phx
5722	.ae8c		20 96 ad	jsr $ad96	                jsr LA7A8
5723	.ae8f		fa		plx		                plx
5724	.ae90		7a		ply		                ply
5725	.ae91		80 10		bra $aea3	                bra LA8F3

5727	.ae93						LA8E3:
5728	.ae93		da		phx		                phx
5729	.ae94		20 89 ad	jsr $ad89	                jsr LA79B
5730	.ae97		20 4a af	jsr $af4a	                jsr LA9A0
5731	.ae9a		fa		plx		                plx
5732	.ae9b		a5 be		lda $be		                lda $BE
5733	.ae9d		05 bf		ora $bf		                ora $BF
5734	.ae9f		f0 76		beq $af17	                beq LA96A
5735	.aea1		a0 3a		ldy #$3a	                ldy #<dataError
5736	.aea3						LA8F3:
5737	.aea3		a9 b0		lda #$b0	                lda #>dataError
5738	.aea5		c6 ba		dec $ba		                dec $BA
5739	.aea7		48		pha		                pha
5740	.aea8		24 eb		bit $eb		                bit $EB
5741	.aeaa		30 0a		bmi $aeb6	                bmi LA909
5742	.aeac		8a		txa		                txa
5743							                .if version!=400
5746							                .endif
5747	.aead		d0 07		bne $aeb6	                bne LA909
5748	.aeaf		8a		txa		                txa
5749	.aeb0		29 11		and #$11	                and #$11
5750	.aeb2		25 bb		and $bb		                and $BB
5751	.aeb4		f0 0f		beq $aec5	                beq LA918
5752	.aeb6						LA909:
5753	.aeb6		68		pla		                pla
5754	.aeb7		85 b9		sta $b9		                sta $B9
5755	.aeb9		84 b8		sty $b8		                sty $B8
5756	.aebb		20 43 ac	jsr $ac43	                jsr LA58B
5757	.aebe		46 eb		lsr $eb		                lsr $EB
5758	.aec0		20 56 af	jsr $af56	                jsr LA9B1
5759	.aec3		80 3d		bra $af02	                bra LA955

5761	.aec5						LA918:
5762	.aec5		98		tya		                tya
5763	.aec6		18		clc		                clc
5764	.aec7		69 03		adc #$03	                adc #$03
5765	.aec9		a8		tay		                tay
5766	.aeca		90 03		bcc $aecf	                bcc LA922
5767	.aecc		68		pla		                pla
5768	.aecd		1a		inc a		                inc a
5769	.aece		48		pha		                pha
5770	.aecf						LA922:
5771	.aecf		5a		phy		                phy
5772	.aed0						LA923:
5773	.aed0		20 9b ec	jsr $ec9b	                jsr LEF1B
5774	.aed3		a8		tay		                tay

5776							;-------------------------------------------------------------------------
5777							;
5778							; Print 0-terminated message using address from stack.
5779							;
5780							; entry:
5781							;
5782							; S=[StrL; StrH] - where Str = (address of string)-1
5783							; Y = 0 to print message; otherwise, don't print message
5784							;
5785	.aed4						printFollowingMessage:                       ;
5786	.aed4		68		pla		                pla
5787	.aed5		85 b8		sta $b8		                sta printMessageAddress+0
5788	.aed7		68		pla		                pla
5789	.aed8		85 b9		sta $b9		                sta printMessageAddress+1
5790	.aeda		5a		phy		                phy                          ;save initial Y
5791	.aedb		98		tya		                tya                          ;Z=1 if Y=0
5792	.aedc		08		php		                php                          ;save Y=0 state
5793	.aedd						fetchNextChar:
5794	.aedd		e6 b8		inc $b8		                inc printMessageAddress+0
5795	.aedf		d0 02		bne $aee3	                bne +
5796	.aee1		e6 b9		inc $b9		                inc printMessageAddress+1
5797	.aee3						+
5798	.aee3		b2 b8		lda ($b8)	                lda (printMessageAddress)   ;fetch next char to print
5799	.aee5		f0 13		beq $aefa	                beq printingFinished        ;branch taken if last char
5800	.aee7		28		plp		                plp                         ;restore Y=0 state
5801	.aee8		08		php		                php                         ;save Y=0 state
5802	.aee9		f0 f2		beq $aedd	                beq fetchNextChar ;branch taken if Y=0 - i.e., skip the
5803							                                  ;printing

5805							                ; printMessageAddress is in the $b0-$bf area, so it
5806							                ; needs saving in case there's a *SPOOL going on.
5807	.aeeb		a4 b8		ldy $b8		                ldy printMessageAddress+0
5808	.aeed		5a		phy		                phy
5809	.aeee		a4 b9		ldy $b9		                ldy printMessageAddress+1
5810	.aef0		20 e3 ff	jsr $ffe3	                jsr OSASCI
5811	.aef3		84 b9		sty $b9		                sty printMessageAddress+1
5812	.aef5		7a		ply		                ply
5813	.aef6		84 b8		sty $b8		                sty printMessageAddress+0

5815	.aef8		80 e3		bra $aedd	                bra fetchNextChar

5817	.aefa						printingFinished:
5818	.aefa		28		plp		                plp                          ;discard Y=0 state
5819	.aefb		e6 b8		inc $b8		                inc printMessageAddress+0
5820	.aefd		d0 02		bne $af01	                bne +
5821	.aeff		e6 b9		inc $b9		                inc printMessageAddress+1
5822	.af01						+
5823	.af01		7a		ply		                ply                          ;restore initial Y
5824	.af02						LA955:
5825	.af02		6c b8 00	jmp ($00b8)	                jmp (printMessageAddress)

5827	.af05						alwaysPrintFollowingMessage:
5828	.af05		a0 01		ldy #$01	                ldy #$01
5829	.af07		80 cb		bra $aed4	                bra printFollowingMessage

5831							;-------------------------------------------------------------------------

5833	.af09						LA95C:
5834	.af09		a2 ff		ldx #$ff	                ldx #$FF
5835	.af0b						LA95E:
5836	.af0b		e8		inx		                inx
5837	.af0c		bd d2 03	lda $03d2,x	                lda $03D2,x
5838	.af0f		d0 07		bne $af18	                bne LA96B
5839	.af11		8a		txa		                txa
5840	.af12		f0 03		beq $af17	                beq LA96A
5841	.af14		bd b2 03	lda $03b2,x	                lda $03B2,x
5842	.af17						LA96A:
5843	.af17		60		rts		                rts

5845	.af18						LA96B:
5846	.af18		20 19 e9	jsr $e919	                jsr isLetter
5847	.af1b		5d b2 03	eor $03b2,x	                eor $03B2,x
5848	.af1e		b0 02		bcs $af22	                bcs LA975
5849	.af20		29 df		and #$df	                and #$DF
5850	.af22						LA975:
5851	.af22		f0 e7		beq $af0b	                beq LA95E
5852	.af24						LA977:
5853	.af24		60		rts		                rts

5855	.af25						LA978:
5856	.af25		a5 ba		lda $ba		                lda $BA
5857	.af27		f0 1e		beq $af47	                beq LA99D
5858	.af29		8a		txa		                txa
5859	.af2a		f0 1b		beq $af47	                beq LA99D
5860	.af2c		a9 22		lda #$22	                lda #$22
5861	.af2e		24 bb		bit $bb		                bit $BB
5862	.af30		f0 15		beq $af47	                beq LA99D
5863							                .if version!=400
5865							                .endif
5866	.af32		a8		tay		                tay
5867	.af33		20 d4 ae	jsr $aed4	                jsr printFollowingMessage
5868	>af36		0d				                .byte $0D
5869	>af37		07				                .byte $07
5870	>af38		52 65 77 69 6e 64 20 74		                .text "Rewind tape"
	>af40		61 70 65
5871	>af43		0d				                .byte $0D
5872	>af44		0d				                .byte $0D
5873	>af45		00				                .byte $00
5874	.af46		60		rts		                rts

5876	.af47						LA99D:
5877	.af47		20 b1 a8	jsr $a8b1	                jsr LA05D
5878	.af4a						LA9A0:
5879	.af4a		a5 c2		lda $c2		                lda $C2
5880	.af4c		f0 d6		beq $af24	                beq LA977
5881	.af4e		20 30 ae	jsr $ae30	                jsr LA880
5882							                .if version!=400
5885							                .endif
5886							                .if version==400
5887	.af51		20 56 ab	jsr $ab56	                jsr LA492
5890							                .endif
5891	.af54		80 f4		bra $af4a	                bra LA9A0

5893	.af56						LA9B1:
5894	.af56		20 9b ec	jsr $ec9b	                jsr LEF1B
5895	.af59		f0 05		beq $af60	                beq LA9BB
5896	.af5b						LA9B6:
5897	.af5b		a9 07		lda #$07	                lda #$07
5898	.af5d		20 ee ff	jsr $ffee	                jsr OSWRCH
5899	.af60						LA9BB:
5900							                .if includeTubeSupport
5901	.af60		ad 7a 02	lda $027a	                lda tubePresence
5902	.af63		f0 05		beq $af6a	                beq LA9C5                  ; taken if copro not present
5903	.af65		a9 80		lda #$80	                lda #$80                   ; $80 = CFS/RFS release Tube
5904	.af67		20 06 04	jsr $0406	                jsr tubeHost.entryPoint
5905							                .endif
5906	.af6a						LA9C5:
5907							                .if version!=400
5933							                .endif
5934	.af6a		60		rts		                rts

5936	.af6b						LA9E6:
5937	.af6b		a5 e3		lda $e3		                lda $E3
5938	.af6d		0a		asl a		                asl a
5939	.af6e		0a		asl a		                asl a
5940	.af6f		0a		asl a		                asl a
5941	.af70		0a		asl a		                asl a
5942	.af71		85 bb		sta $bb		                sta $BB
5943							                .if version==400
5944	.af73		60		rts		                rts
5948							                .endif

5950	.af74						LA9F3:
5951	.af74		a5 e3		lda $e3		                lda $E3
5952	.af76		29 f0		and #$f0	                and #$F0
5953	.af78		85 bb		sta $bb		                sta $BB
5954							                .if version!=400
5972							                .endif
5973	.af7a		60		rts		                rts

5975							;-------------------------------------------------------------------------

5977							                .if version!=400
5981							                .endif

5983							;-------------------------------------------------------------------------

5985	.af7b						LAA16:
5986							                .if version!=400
5990							                .endif
5991	.af7b						LAA1C:
5992							                .if version!=400
5999							                .endif
6000	.af7b		64 ca		stz $ca		                stz $CA
6001							                .if version!=400
6010							                .endif
6011	.af7d		60		rts		                rts

6013							;-------------------------------------------------------------------------

6015	.af7e						LAA35:
6016	.af7e		ae c6 03	ldx $03c6	                ldx $03C6
6017	.af81		ac c7 03	ldy $03c7	                ldy $03C7
6018	.af84		e8		inx		                inx
6019	.af85		86 b4		stx $b4		                stx $B4
6020	.af87		d0 01		bne $af8a	                bne LAA41
6021	.af89		c8		iny		                iny
6022	.af8a						LAA41:
6023	.af8a		84 b5		sty $b5		                sty $B5
6024	.af8c		60		rts		                rts

6026	.af8d						LAA44:
6027	.af8d		64 c0		stz $c0		                stz $C0
6028	.af8f						LAA46:
6029	.af8f		a0 00		ldy #$00	                ldy #$00
6030	.af91		64 be		stz $be		                stz $BE
6031	.af93		64 bf		stz $bf		                stz $BF
6032	.af95		60		rts		                rts

6034	.af96						LAA4D:
6035	.af96		a0 ff		ldy #$ff	                ldy #$FF
6036	.af98						LAA4F:
6037	.af98		c8		iny		                iny
6038	.af99		e8		inx		                inx
6039	.af9a		bd 00 03	lda $0300,x	                lda $0300,x
6040	.af9d		99 d2 03	sta $03d2,y	                sta $03D2,y
6041	.afa0		d0 f6		bne $af98	                bne LAA4F
6042	.afa2		60		rts		                rts

6044							                .if version!=400
6055							                .endif

6057							; Check if TAPE/ROM channel is open
6058							; ---------------------------------
6059							; Y=handle to check, A=status mask to use
6060	.afa3						LAA68:
6061	.afa3		5a		phy		                phy
6062	.afa4		20 c8 af	jsr $afc8	                jsr LAA8D
6063	.afa7		7a		ply		                ply
6064							                .if includeTubeSupport
6065	.afa8		b0 55		bcs $afff	                bcs rtsAAC9                    ; Channel open, exit
6068							                .endif
6069	.afaa		cc 57 02	cpy $0257	                cpy spoolFileHandle                    ; Not SPOOL handle
6070	.afad		d0 05		bne $afb4	                bne LAA79
6071	.afaf		9c 57 02	stz $0257	                stz spoolFileHandle                    ; Clear the SPOOL handle
6072	.afb2		80 08		bra $afbc	                bra LAA81
6073	.afb4						LAA79:
6074	.afb4		cc 56 02	cpy $0256	                cpy execFileHandle                    ; Not EXEC handle
6075	.afb7		d0 03		bne $afbc	                bne LAA81
6076	.afb9		9c 56 02	stz $0256	                stz execFileHandle                    ; Clear the EXEC handle
6077	.afbc						LAA81:
6078	.afbc		20 23 b0	jsr $b023	                jsr doFollowingError                    ; Generate error
6079	>afbf		de				                .byte $DE
6080	>afc0		43 68 61 6e 6e 65 6c		                .text "Channel"
6081	.afc7		00		brk #		                brk

6083	.afc8						LAA8D:
6084	.afc8		48		pha		                pha                          ; Toggle channel with CFS/RFS switch
6085	.afc9		98		tya		                tya
6086							                .if version==400
6087	.afca		49 02		eor #$02	                eor #2
6090							                .endif
6091	.afcc		a8		tay		                tay                          ; If CFS=unchanged, if RFS 1/2/3->3/0/1
6092	.afcd		68		pla		                pla
6093	.afce		25 e2		and $e2		                and $E2                      ; Mask with open channels bitmask
6094	.afd0		4a		lsr a		                lsr a                        ; Move 'input open if tested' into Carry
6095	.afd1		88		dey		                dey                          ; Exit if testing CFS#1 or RFS#3
6096	.afd2		f0 05		beq $afd9	                beq rtsAA9F
6097	.afd4		4a		lsr a		                lsr a                        ; Move 'output open if tested' into Carry
6098	.afd5		88		dey		                dey                          ; Exit if testing CFS#2
6099	.afd6		f0 01		beq $afd9	                beq rtsAA9F
6100	.afd8		18		clc		                clc                          ; Otherwise, Carry=Not Open
6101	.afd9						rtsAA9F:
6102	.afd9		60		rts		                rts

6104							                .if version!=400
6108							                .endif

6110							                .if includeTubeSupport
6111	.afda						initiateCFSRFSHostToParasiteTransfer:
6112	.afda		a9 01		lda #$01	                lda #tubeReasonMultiByteHostToParasite
6113	.afdc						LAAA6:
6114	.afdc		20 f2 af	jsr $aff2	                jsr isTubeAddress
6115	.afdf		f0 1e		beq $afff	                beq rtsAAC9
6116	.afe1		8a		txa		                txa                          ; restore transfer type
6117	.afe2		a2 b0		ldx #$b0	                ldx #$B0
6118	.afe4		a0 00		ldy #$00	                ldy #$00
6119	.afe6						initiateCFSRFSTubeTransfer:
6120	.afe6		48		pha		                pha                         ; save transfer type
6121	.afe7		a9 c0		lda #$c0	                lda #$C0                    ; $c0 = CFS/RFS claim Tube
6122	.afe9						-
6123	.afe9		20 06 04	jsr $0406	                jsr tubeHost.entryPoint
6124	.afec		90 fb		bcc $afe9	                bcc -
6125	.afee		68		pla		                pla                          ; restore transfer type
6126	.afef		4c 06 04	jmp $0406	                jmp tubeHost.entryPoint      ; initiate transfer

6128	.aff2						isTubeAddress:
6129	.aff2		aa		tax		                tax
6130	.aff3		a5 b2		lda $b2		                lda $B2
6131	.aff5		25 b3		and $b3		                and $B3                 ; $ff if address is $FFFFxxxx
6132	.aff7		1a		inc a		                inc a                   ; $00 if address is $FFFFxxxx
6133	.aff8		f0 05		beq $afff	                beq rtsAAC9               ; taken if not Tube address
6134	.affa		ad 7a 02	lda $027a	                lda tubePresence
6135	.affd		29 80		and #$80	                and #$80            ; $80 if $FFFFxxxx and Tube active
6136	.afff						rtsAAC9:
6137	.afff		60		rts		                rts
6138							                .endif

6140	.b000						LAACA:
6141	.b000		a0 05		ldy #$05	                ldy #$05
6142	.b002						LAACC:
6143	.b002		b1 cc		lda ($cc),y	                lda ($CC),y
6144	.b004		d0 07		bne $b00d	                bne LAAD7
6145	.b006		c8		iny		                iny
6146	.b007		c0 08		cpy #$08	                cpy #$08
6147	.b009		90 f7		bcc $b002	                bcc LAACC
6148	.b00b						LAAD5:
6149	.b00b		b1 cc		lda ($cc),y	                lda ($CC),y
6150	.b00d						LAAD7:
6151	.b00d		3a		dec a		                dec a
6152	.b00e		91 cc		sta ($cc),y	                sta ($CC),y
6153	.b010		88		dey		                dey
6154	.b011		c0 05		cpy #$05	                cpy #$05
6155	.b013		b0 f6		bcs $b00b	                bcs LAAD5
6156	.b015		60		rts		                rts

6158	.b016						LAAE0:
6159	.b016		a0 08		ldy #$08	                ldy #$08
6160	.b018		a9 00		lda #$00	                lda #$00
6161	.b01a						LAAE4:
6162	.b01a		11 cc		ora ($cc),y	                ora ($CC),y
6163	.b01c		88		dey		                dey
6164	.b01d		c0 05		cpy #$05	                cpy #$05
6165	.b01f		b0 f9		bcs $b01a	                bcs LAAE4
6166	.b021		aa		tax		                tax
6167	.b022		60		rts		                rts

6169	.b023						doFollowingError:
6170	.b023		78		sei		                sei
6171	.b024		68		pla		                pla
6172	.b025		85 fa		sta $fa		                sta SEIWKA+0
6173	.b027		68		pla		                pla
6174	.b028		85 fb		sta $fb		                sta SEIWKA+1
6175	.b02a		9c 00 01	stz $0100	                stz $0100
6176	.b02d		a0 00		ldy #$00	                ldy #$00
6177	.b02f						-
6178	.b02f		c8		iny		                iny
6179	.b030		b1 fa		lda ($fa),y	                lda (SEIWKA),y
6180	.b032		99 00 01	sta $0100,y	                sta $0100,y
6181	.b035		d0 f8		bne $b02f	                bne -
6182	.b037		4c 00 01	jmp $0100	                jmp $0100


6185							                .if version!=350
6186							                .include "cfs_errors.s65"

:11	;******  Processing file: src/cfs_errors.s65

1							                ; The MOS code assumes all these error routines have
2							                ; the same MSB of their start address. (There's a
3							                ; .cerror that checks for this.) They all just fit
4							                ; into 32 bytes, so 32-byte alignment will do the
5							                ; trick.
6							                ;
7							                ; (The alignment directive doesn't take effect in any
8							                ; of the default MOS builds. It springs into action to
9							                ; accommodate modifications to other parts of the
10							                ; code.)
11							                .if (>*)!=(>blockError)
13							                .endif

15	.b03a						dataError:
16	.b03a		20 23 b0	jsr $b023	                jsr doFollowingError
17	>b03d		d8 0d 44 61 74 61 3f 00		                .text $d8,13,"Data?",0
18	.b045		80 19		bra $b060	                bra LAB2A

20	.b047						fileError:
21	.b047		20 23 b0	jsr $b023	                jsr doFollowingError
22	>b04a		db 0d 46 69 6c 65 3f 00		                .text $db,13,"File?",0
23	.b052		80 0c		bra $b060	                bra LAB2A

25	.b054						blockError:
26	.b054		20 23 b0	jsr $b023	                jsr doFollowingError
27	>b057		da 0d 42 6c 6f 63 6b 3f		                .text $da,13,"Block?",0
	>b05f		00
28	.b060						LAB2A:
29	.b060		4c 25 af	jmp $af25	                jmp LA978


:4	;******  Return to file: src/terminal.s65

6187							                .endif

6189							                .if includeTubeSupport
6190							;-------------------------------------------------------------------------
6191							;
6192							; Tube host code
6193							;
6194							; See http://mdfs.net/Software/Tube/M128/Host320.lst
6195							;
6196							; I mostly just copied JGH's comments here.

6198	.b063						tubeHost: .block          ;tube code

6200	.b063						brkHandler: .block
6201							                .logical tubeBrkHandlerAddr
6202	.b063	0016	a9 ff		lda #$ff	                lda #$FF
6203	.b065	0018	20 6c 06	jsr $066c	                jsr sendR4       ;send $ff via R4 to interrupt copro
6204	.b068	001b	ad e3 fe	lda $fee3	                lda tube.data2   ;get ACK byte from copro
6205	.b06b	001e	a9 00		lda #$00	                lda #$00
6206	.b06d	0020	20 61 06	jsr $0661	                jsr sendR2A       ;send $00 via R2 to specify ERROR
6207	.b070	0023	a8		tay		                tay               ;Y=0
6208	.b071	0024	b1 fd		lda ($fd),y	                lda ($FD),y       ;get error number
6209	.b073	0026	20 61 06	jsr $0661	                jsr sendR2A       ;send error number via R2
6210	.b076	0029					-
6211	.b076	0029	c8		iny		                iny             ;next char
6212	.b077	002a	b1 fd		lda ($fd),y	                lda ($FD),y     ;fetch error string char
6213	.b079	002c	20 61 06	jsr $0661	                jsr sendR2A     ;send via R2
6214	.b07c	002f	aa		tax		                tax             ;set N/Z as per error string char
6215	.b07d	0030	d0 f7		bne $0029	                bne -           ;repeat until terminating $00 sent
6216	.b07f	0032					idleStartup:
6217	.b07f	0032	a2 ff		ldx #$ff	                ldx #$FF
6218	.b081	0034	9a		txs		                txs             ;clear stack
6219	.b082	0035	58		cli		                cli
6220	.b083	0036					idleLoop:
6221	.b083	0036	2c e0 fe	bit $fee0	                bit tube.status1 ;is there a char in R1?
6222	.b086	0039	10 06		bpl $0041	                bpl LAB58        ;branch taken if no char in R1
6223	.b088	003b					handleOSWRCH:
6224	.b088	003b	ad e1 fe	lda $fee1	                lda tube.data1  ;get char from R1
6225	.b08b	003e	20 ee ff	jsr $ffee	                jsr OSWRCH      ;pass to OSWRCH
6226	.b08e	0041					LAB58:
6227	.b08e	0041	2c e2 fe	bit $fee2	                bit tube.status2 ;is there a command in R2?
6228	.b091	0044	10 f0		bpl $0036	                bpl idleLoop     ;branch taken if no command in R2
6229	.b093	0046	2c e0 fe	bit $fee0	                bit tube.status1 ;is there a char in R1?
6230	.b096	0049	30 f0		bmi $003b	                bmi handleOSWRCH ;branch taken if char in R1
6231	.b098	004b	ae e3 fe	ldx $fee3	                ldx tube.data2   ;get command from R2
6232	.b09b	004e	86 51		stx $51		                stx callCommandRoutine+1 ;use as index into command
6233							                                         ;table
6234	.b09d	0050					callCommandRoutine:
6235							                ; not sure why this can't be jmp
6236							                ; (tubeHost.commandRoutines,x)? - and then the table
6237							                ; wouldn't have to be page-aligned.
6238	.b09d	0050	6c 00 05	jmp ($0500)	                jmp (tubeHost.commandRoutines)

6240							                ; ???
6241	>b0a0	0053	00 80 00 00			                .dword $8000
6242							                .here
6243							                .endblock

6245							; Slightly ugly aliases for inner symbol :(
6246	=$32						idleStartup=brkHandler.idleStartup
6247	=$36						idleLoop=brkHandler.idleLoop

6249	.b0a4						codePage0:
6250							                .logical tubeHostAddr
6251	.b0a4	0400					copyLanguage:
6252	.b0a4	0400	4c c2 04	jmp $04c2	                jmp LAC30

6254	.b0a7	0403					copyEscapeStatus:
6255	.b0a7	0403	4c 75 06	jmp $0675	                jmp LADDA

6257							; Tube transfer/claim/release
6258	.b0aa	0406					entryPoint:
6259	.b0aa	0406	c9 80		cmp #$80	                cmp #$80
6260	.b0ac	0408	90 29		bcc $0433	                bcc dataTransfer
6261	.b0ae	040a	c9 c0		cmp #$c0	                cmp #$C0
6262	.b0b0	040c	b0 18		bcs $0426	                bcs claim
6263	.b0b2	040e	09 40		ora #$40	                ora #$40
6264	.b0b4	0410	c5 15		cmp $15		                cmp $15
6265	.b0b6	0412	d0 1e		bne $0432	                bne done
6266	.b0b8	0414					release:
6267	.b0b8	0414	08		php		                php
6268	.b0b9	0415	78		sei		                sei
6269	.b0ba	0416	a9 05		lda #$05	                lda #$05
6270	.b0bc	0418	20 6c 06	jsr $066c	                jsr sendR4
6271	.b0bf	041b	20 6a 06	jsr $066a	                jsr sendR4TubeClaimantID
6272	.b0c2	041e	28		plp		                plp
6273	.b0c3	041f					resetTubeClaim:
6274	.b0c3	041f	a9 80		lda #$80	                lda #$80
6275	.b0c5	0421	85 15		sta $15		                sta tubeClaimantID
6276	.b0c7	0423	85 14		sta $14		                sta tubeNotClaimed
6277	.b0c9	0425	60		rts		                rts

6279	.b0ca	0426					claim:
6280	.b0ca	0426	06 14		asl $14		                asl tubeNotClaimed    ;test if Tube free
6281	.b0cc	0428	b0 06		bcs $0430	                bcs claim2         ;taken if Tube free - with C=1 and
6282							                                   ;tube marked as claimed
6283	.b0ce	042a	c5 15		cmp $15		                cmp tubeClaimantID
6284	.b0d0	042c	f0 04		beq $0432	                beq done       ;taken with C=1 if already claimed
6285	.b0d2	042e	18		clc		                clc            ;signal claim failure
6286	.b0d3	042f	60		rts		                rts

6288	.b0d4	0430					claim2:
6289	.b0d4	0430	85 15		sta $15		                sta tubeClaimantID ; store claimant ID
6290	.b0d6	0432					done:
6291	.b0d6	0432	60		rts		                rts

6293	.b0d7	0433					dataTransfer:
6294	.b0d7	0433	08		php		                php
6295	.b0d8	0434	78		sei		                sei
6296	.b0d9	0435	84 13		sty $13		                sty tubeTransferAddr+1
6297	.b0db	0437	86 12		stx $12		                stx tubeTransferAddr+0
6298	.b0dd	0439	20 6c 06	jsr $066c	                jsr sendR4      ;send reason code to interrupt copro
6299	.b0e0	043c	aa		tax		                tax             ;save reason code
6300	.b0e1	043d	a0 03		ldy #$03	                ldy #$03        ;will send 4 bytes
6301	.b0e3	043f	20 6a 06	jsr $066a	                jsr sendR4TubeClaimantID ;send Tube claimant ID
6302	.b0e6	0442					-
6303	.b0e6	0442	b1 12		lda ($12),y	                lda (tubeTransferAddr),y
6304	.b0e8	0444	20 6c 06	jsr $066c	                jsr sendR4
6305	.b0eb	0447	88		dey		                dey
6306	.b0ec	0448	10 f8		bpl $0442	                bpl -

6308							                ; disable R3 FIFO, disable R3 NMI
6309	.b0ee	044a	a0 18		ldy #$18	                ldy #tube.status1.V|tube.status1.M
6310	.b0f0	044c	8c e0 fe	sty $fee0	                sty tube.status1

6312							                ; disable/enable other per-transfer type flags as
6313							                ; appropriate.
6314	.b0f3	044f	bd 18 05	lda $0518,x	                lda dataTransferFlags,x
6315	.b0f6	0452	8d e0 fe	sta $fee0	                sta tube.status1 ;STPVMJIQ

6317	.b0f9	0455	4a		lsr a		                lsr a           ;0STPVMJI Q
6318	.b0fa	0456	4a		lsr a		                lsr a           ;00STPVMJ I
6319	.b0fb	0457	90 06		bcc $045f	                bcc +           ;branch taken if CoPro->I/O transfer

6321							                ; Read R3 twice to delay and empty FIFO
6322	.b0fd	0459	2c e5 fe	bit $fee5	                bit tube.data3
6323	.b100	045c	2c e5 fe	bit $fee5	                bit tube.data3
6324	.b103	045f					+
6325	.b103	045f	20 6c 06	jsr $066c	                jsr sendR4      ;send value to synchronize
6326	.b106	0462					-
6327	.b106	0462	2c e6 fe	bit $fee6	                bit tube.status4
6328	.b109	0465	50 fb		bvc $0462	                bvc -
6329	.b10b	0467	b0 0d		bcs $0476	                bcs LABE4       ;branch taken if I/O->CoPro transfer
6330	.b10d	0469	e0 04		cpx #$04	                cpx #$04        ;$04 = execute in CoPro
6331	.b10f	046b	d0 11		bne $047e	                bne LABEC       ;taken if not execute in CoPro
6332	.b111	046d					LABDB:
6333	.b111	046d	20 14 04	jsr $0414	                jsr release
6334	.b114	0470	20 61 06	jsr $0661	                jsr sendR2A
6335	.b117	0473	4c 32 00	jmp $0032	                jmp idleStartup

6337	.b11a	0476					LABE4:
6338	.b11a	0476	4a		lsr a		                lsr a            ;000STPVM J
6339	.b11b	0477	90 05		bcc $047e	                bcc LABEC        ;branch taken if J=0
6340	.b11d	0479	a0 88		ldy #$88	                ldy #tube.status1.S|tube.status1.M
6341	.b11f	047b	8c e0 fe	sty $fee0	                sty tube.status1
6342	.b122	047e					LABEC:
6343	.b122	047e	28		plp		                plp
6344	.b123	047f	60		rts		                rts

6346	.b124	0480					LABEE:
6347	.b124	0480	ae 8d 02	ldx $028d	                ldx lastBREAKType            ;get last BREAK type
6348	.b127	0483	f0 e8		beq $046d	                beq LABDB   ;if soft break, release Tube, send $80 via
6349							                            ;R2, and enter idle loop.

6351							; The current language is not copied across the Tube on soft Break,
6352							; only on Power-On Break and Hard Break, or when entered explicitly
6353							; with OSBYTE 142.

6355	.b129	0485					enterNewLanguage: .proc
6356	.b129	0485	a9 ff		lda #$ff	                lda #$FF
6357	.b12b	0487	20 06 04	jsr $0406	                jsr tubeHost.entryPoint ;claim with ID=$3f
6358	.b12e	048a	90 f9		bcc $0485	                bcc enterNewLanguage    ;repeat until claimed
6359	.b130	048c	20 c9 04	jsr $04c9	                jsr getLanguageParasiteAddr ;sort out addresses

6361	.b133	048f					transferPage:
6362							                .if version==350
6364							                .endif
6365	.b133	048f	08		php		                php
6366	.b134	0490	78		sei		                sei

6368							                ; initiate I/O->CoPro 256 bytes, then transfer the
6369							                ; next 256 bytes of the language ROM.
6370	.b135	0491	a9 07		lda #$07	                lda #$07
6371	.b137	0493	20 bb 04	jsr $04bb	                jsr doTube

6373	.b13a	0496	a0 00		ldy #$00	                ldy #$00
6374							                .if version==350
6380							                .else
6381	.b13c	0498	64 00		stz $00		                stz tubeLanguageHostAddr+0
6382	.b13e	049a					transferPageLoop:
6383	.b13e	049a	b1 00		lda ($00),y	                lda (tubeLanguageHostAddr),y
6384	.b140	049c	8d e5 fe	sta $fee5	                sta tube.data3
6385	.b143	049f	ea		nop		                nop
6386	.b144	04a0	ea		nop		                nop
6387	.b145	04a1	ea		nop		                nop
6388							                .endif
6389	.b146	04a2	c8		iny		                iny
6390	.b147	04a3	d0 f5		bne $049a	                bne transferPageLoop
6391	.b149	04a5	28		plp		                plp

6393							                ; advance to next dest page.
6394	.b14a	04a6	e6 54		inc $54		                inc tubeLanguageParasiteAddr+1
6395	.b14c	04a8	d0 06		bne $04b0	                bne +
6396	.b14e	04aa	e6 55		inc $55		                inc tubeLanguageParasiteAddr+2
6397	.b150	04ac	d0 02		bne $04b0	                bne +
6398	.b152	04ae	e6 56		inc $56		                inc tubeLanguageParasiteAddr+3
6399	.b154	04b0					+

6401							                .if version!=350
6402	.b154	04b0	e6 01		inc $01		                inc tubeLanguageHostAddr+1 ;next source page
6403							                .endif
6404	.b156	04b2	24 01		bit $01		                bit tubeLanguageHostAddr+1
6405	.b158	04b4	50 d9		bvc $048f	                bvc transferPage ;branch taken if source page $c0 not
6406							                                 ;reached yet

6408							                ; copy done - execute language in parasite
6409							                .if version==350
6411							                .else
6412	.b15a	04b6	20 c9 04	jsr $04c9	                jsr getLanguageParasiteAddr
6413							                .endif
6414	.b15d	04b9	a9 04		lda #$04	                lda #$04        ;execute in copro

6416							                ; call Tube entry point with whatever reason code,
6417							                ; supplying language parasite address as the parasite
6418							                ; address.
6419	.b15f	04bb					doTube:
6420	.b15f	04bb	a0 00		ldy #$00	                ldy #>tubeLanguageParasiteAddr
6421	.b161	04bd	a2 53		ldx #$53	                ldx #<tubeLanguageParasiteAddr
6422	.b163	04bf	4c 06 04	jmp $0406	                jmp tubeHost.entryPoint
6423							                .pend

6425	.b166	04c2					LAC30:
6426	.b166	04c2	58		cli		                cli
6427	.b167	04c3	b0 c0		bcs $0485	                bcs enterNewLanguage
6428	.b169	04c5	d0 b9		bne $0480	                bne LABEE
6429	.b16b	04c7	80 61		bra $052a	                bra LAC8F

6431	.b16d	04c9					getLanguageParasiteAddr: .proc
6432	.b16d	04c9	a9 80		lda #$80	                lda #$80
6433	.b16f	04cb	85 54		sta $54		                sta tubeLanguageParasiteAddr+1 ;$xxxx80xx
6434	.b171	04cd	85 01		sta $01		                sta tubeLanguageHostAddr+1     ;$80xx
6435	.b173	04cf	a9 20		lda #$20	                lda #$20
6436	.b175	04d1	2d 06 80	and $8006	                and $8006  ;test parasite address flag
6437	.b178	04d4	a8		tay		                tay        ;Y=0 if $8000, Y=$20 if parasite address
6438							                .if version==350
6440							                .else
6441	.b179	04d5	84 53		sty $53		                sty tubeLanguageParasiteAddr+0
6442							                .endif
6443	.b17b	04d7	f0 19		beq $04f2	                beq LAC60       ;branch taken if good to go with A=0
6444							                                ;and Y=0

6446	.b17d	04d9	ae 07 80	ldx $8007	                ldx $8007       ;get copyright offset
6447							                ; skip copyright message
6448	.b180	04dc					-
6449	.b180	04dc	e8		inx		                inx
6450	.b181	04dd	bd 00 80	lda $8000,x	                lda $8000,x
6451	.b184	04e0	d0 fa		bne $04dc	                bne -

6453	.b186	04e2	bd 01 80	lda $8001,x	                lda $8000+1,x
6454	.b189	04e5	85 53		sta $53		                sta tubeLanguageParasiteAddr+0
6455	.b18b	04e7	bd 02 80	lda $8002,x	                lda $8000+2,x
6456	.b18e	04ea	85 54		sta $54		                sta tubeLanguageParasiteAddr+1
6457	.b190	04ec	bc 03 80	ldy $8003,x	                ldy $8000+3,x
6458	.b193	04ef	bd 04 80	lda $8004,x	                lda $8000+4,x
6459	.b196	04f2					LAC60:
6460							                ; Y = parasite address bits 16-23
6461							                ; A = parasite address bits 24-31
6462							                .if version==350
6464							                .else
6465	.b196	04f2	85 56		sta $56		                sta tubeLanguageParasiteAddr+3
6466	.b198	04f4	84 55		sty $55		                sty tubeLanguageParasiteAddr+2
6467	.b19a	04f6	60		rts		                rts

6469							                .endif
6470							                .pend
6471							                .here

6473	.b19b						codePages12:
6474							                .logical tubeHostAddr+256

6476							; names of the indexes here come from app note 004
6477	.b19b	0500					commandRoutines:
6478							                .cerror (*&$ff)!=0,"commandRoutines must be paged aligned"
6479	>b19b	0500	35 05				                .word doRDCH    ;RDCHNO = $00
6480	>b19d	0502	88 05				                .word doCLI     ;CLINO = $02
6481	>b19f	0504	da 05				                .word doSBYT    ;SBYTNO = $04
6482	>b1a1	0506	eb 05				                .word doBYTE    ;BYTENO = $06
6483	>b1a3	0508	07 06				                .word doWORD    ;WORDNO = $08
6484	>b1a5	050a	36 06				                .word doRDLN    ;RDLNNO = $0a
6485	>b1a7	050c	59 05				                .word doARGS     ;ARGSNO = $0c
6486	>b1a9	050e	2c 05				                .word doBGET     ;BGETNO = $0e
6487	>b1ab	0510	20 05				                .word doBPUT     ;BPUTNO = $10
6488	>b1ad	0512	3f 05				                .word doFIND     ;FINDNO = $12
6489	>b1af	0514	b2 05				                .word doFILE    ;FILENO = $14
6490	>b1b1	0516	9a 05				                .word doGBPB     ;GBPBNO = $16

6492							                ; Tube data transfer flags
6493	.b1b3	0518					dataTransferFlags:
6494							                ; 0 - CoPro->I/O bytes
6495							                ;
6496							                ; Enable: PIRQ from R3, PIRQ from R1
6497	>b1b3	0518	86				                .byte tube.status1.S|tube.status1.J|tube.status1.I

6499							                ; 1 - I/O->CoPro bytes
6500							                ;
6501							                ; Enable: PNMI from R3
6502	>b1b4	0519	88				                .byte tube.status1.S|tube.status1.M

6504							                ; 2 - CoPro->I/O words
6505							                ;
6506							                ; Enable: 2-byte R3, PIRQ from R2, PIRQ from R1
6507	>b1b5	051a	96				                .byte tube.status1.S|tube.status1.V|tube.status1.J|tube.status1.I

6509							                ; 3 - I/O->CoPro words
6510							                ;
6511							                ; Enable: 2-byte R3, PNMI from R3
6512	>b1b6	051b	98				                .byte tube.status1.S|tube.status1.V|tube.status1.M

6514							                ; 4 - Execute in CoPro
6515							                ;
6516							                ; Disable: 2-byte R3, PNMI from R3
6517	>b1b7	051c	18				                .byte tube.status1.V|tube.status1.M

6519							                ; 5 - Reserved
6520							                ;
6521							                ; Disable: 2-byte R3, PNMI from R3
6522	>b1b8	051d	18				                .byte tube.status1.V|tube.status1.M

6524							                ; 6 - CoPro->I/O 256 bytes
6525							                ;
6526							                ; Enable: PIRQ from R1
6527	>b1b9	051e	82				                .byte tube.status1.S|tube.status1.I

6529							                ; 7 - I/O->CoPro 256 bytes
6530							                ;
6531							                ; Disable: 2-byte R3, PNMI from R3
6532	>b1ba	051f	18				                .byte tube.status1.V|tube.status1.M

6534	.b1bb	0520					doBPUT:
6535	.b1bb	0520	20 a1 06	jsr $06a1	                jsr recvR2      ;Receive file handle
6536	.b1be	0523	a8		tay		                tay             ;Y = file handle
6537	.b1bf	0524	20 a1 06	jsr $06a1	                jsr recvR2      ;Receive byte
6538	.b1c2	0527	20 d4 ff	jsr $ffd4	                jsr OSBPUT      ;Do OSBPUT
6539	.b1c5	052a					LAC8F:
6540	.b1c5	052a	80 62		bra $058e	                bra sendR27FThenGoIdle

6542	.b1c7	052c					doBGET:
6543	.b1c7	052c	20 a1 06	jsr $06a1	                jsr recvR2      ;Receive file handle
6544	.b1ca	052f	a8		tay		                tay             ;Y = file handle
6545	.b1cb	0530	20 d7 ff	jsr $ffd7	                jsr OSBGET      ;Do OSBGET
6546	.b1ce	0533					LAC98:
6547	.b1ce	0533	80 03		bra $0538	                bra sendR2CAThenGoIdle

6549	.b1d0	0535					doRDCH:
6550	.b1d0	0535	20 e0 ff	jsr $ffe0	                jsr OSRDCH      ;Do OSRDCH
6551	.b1d3	0538					sendR2CAThenGoIdle:
6552	.b1d3	0538	6a		ror a		                ror a           ;set A bit 7 as per carry
6553	.b1d4	0539	20 61 06	jsr $0661	                jsr sendR2A     ;send via R2
6554	.b1d7	053c	2a		rol a		                rol a           ;restore A
6555	.b1d8	053d	80 51		bra $0590	                bra sendR2AThenGoIdle

6557	.b1da	053f					doFIND: .proc
6558	.b1da	053f	20 a1 06	jsr $06a1	                jsr recvR2            ;Receive reason code
6559	.b1dd	0542	f0 0a		beq $054e	                beq close             ;taken if A=$00 - CLOSE#
6560	.b1df	0544	48		pha		                pha                   ;save reason code
6561	.b1e0	0545	20 74 05	jsr $0574	                jsr recvR2String      ;receive file name
6562	.b1e3	0548	68		pla		                pla                   ;restore reason code
6563	.b1e4	0549	20 ce ff	jsr $ffce	                jsr OSFIND            ;call OSFIND
6564	.b1e7	054c	80 42		bra $0590	                bra sendR2AThenGoIdle

6566	.b1e9	054e					close:
6567	.b1e9	054e	20 a1 06	jsr $06a1	                jsr recvR2      ;Receive file handle
6568	.b1ec	0551	a8		tay		                tay             ;Y = file handle
6569	.b1ed	0552	a9 00		lda #$00	                lda #$00        ;A = $00 - CLOSE#
6570	.b1ef	0554	20 ce ff	jsr $ffce	                jsr OSFIND      ;call OSFIND
6571	.b1f2	0557	80 35		bra $058e	                bra sendR27FThenGoIdle
6572							                .pend

6574							;-------------------------------------------------------------------------
6575							;
6576							; Handle a Tube OSARGS request.
6577							;
6578							; [Tube p24]
6579							;
6580	.b1f4	0559					doARGS:
6581	.b1f4	0559	20 a1 06	jsr $06a1	                jsr recvR2                   ;receive file handle
6582	.b1f7	055c	a8		tay		                tay                          ;Y = file handle
6583	.b1f8	055d	a2 04		ldx #$04	                ldx #$04
6584	.b1fa	055f	20 93 06	jsr $0693	                jsr recvR2N ;receive 4 bytes OSARGS data, + operation code
6585	.b1fd	0562	20 da ff	jsr $ffda	                jsr OSARGS  ;call OSARGS
6586	.b200	0565	20 61 06	jsr $0661	                jsr sendR2A ;send OSARGS result

6588							                ; send 4 bytes OSARGS data
6589	.b203	0568	a2 03		ldx #$03	                ldx #$03
6590	.b205	056a					-
6591							                .if version==350
6593							                .else
6594	.b205	056a	b5 00		lda $00,x	                lda $00,x
6595							                .endif
6596	.b207	056c	20 61 06	jsr $0661	                jsr sendR2A
6597	.b20a	056f	ca		dex		                dex
6598	.b20b	0570	10 f8		bpl $056a	                bpl -

6600	.b20d	0572	80 24		bra $0598	                bra goIdle_0

6602							;-------------------------------------------------------------------------
6603							;
6604							; Receive a CR-terminated string over the Tube via R2.
6605							;
6606							; exit:
6607							; YX = pointer to received string (here, always $0700)
6608							;
6609	.b20f	0574					recvR2String: .proc
6610	.b20f	0574	a2 00		ldx #$00	                ldx #$00
6611	.b211	0576	a0 00		ldy #$00	                ldy #$00        ;index
6612	.b213	0578					-
6613	.b213	0578	20 a1 06	jsr $06a1	                jsr recvR2      ;get next string char
6614	.b216	057b	99 00 07	sta $0700,y	                sta tubeStringBuffer,y     ;store in string buffer
6615	.b219	057e	c8		iny		                iny
6616	.b21a	057f	f0 04		beq $0585	                beq +           ;taken if too many bytes received
6617	.b21c	0581	c9 0d		cmp #$0d	                cmp #$0D
6618	.b21e	0583	d0 f3		bne $0578	                bne -           ;taken if end of string data not reached
6619	.b220	0585					+
6620	.b220	0585	a0 07		ldy #$07	                ldy #>tubeStringBuffer
6621							                .cerror (<tubeStringBuffer)!=0,"tubeStringBuffer must be page-aligned"
6622	.b222	0587	60		rts		                rts
6623							                .pend

6625							;-------------------------------------------------------------------------
6626							;
6627							; Handle a Tube OSCLI request.
6628							;
6629							; [Tube p22]
6630							;
6631	.b223	0588					doCLI:
6632	.b223	0588	20 74 05	jsr $0574	                jsr recvR2String
6633	.b226	058b	20 f7 ff	jsr $fff7	                jsr OSCLI
6634	.b229	058e					sendR27FThenGoIdle:
6635	.b229	058e	a9 7f		lda #$7f	                lda #$7F
6636	.b22b	0590					sendR2AThenGoIdle:
6637	.b22b	0590					-
6638	.b22b	0590	2c e2 fe	bit $fee2	                bit tube.status2
6639	.b22e	0593	50 fb		bvc $0590	                bvc -
6640	.b230	0595	8d e3 fe	sta $fee3	                sta tube.data2
6641	.b233	0598					goIdle_0:
6642	.b233	0598	80 4e		bra $05e8	                bra goIdle_1

6644							;-------------------------------------------------------------------------
6645							;
6646							; Handle a Tube OSGBPB request.
6647							;
6648							; [Tube p25]
6649							;
6650	.b235	059a					doGBPB:
6651	.b235	059a	a2 0d		ldx #$0d	                ldx #size(OSGBPBParameterBlock)
6652							                .cerror tubeOSGBPBParameterBlock!=0,"Tube OSGBPB parameter block must be at $0000"
6653	.b237	059c	20 93 06	jsr $0693	                jsr recvR2N     ;receive parameter block + reason code
6654	.b23a	059f	a0 00		ldy #$00	                ldy #>tubeOSGBPBParameterBlock
6655	.b23c	05a1	20 d1 ff	jsr $ffd1	                jsr OSGBPB      ;call OSGBPB
6656	.b23f	05a4	48		pha		                pha             ;save OSGBPB A result

6658							                ; Send updated OSGBPB parameter block.
6659	.b240	05a5	a2 0c		ldx #$0c	                ldx #size(OSGBPBParameterBlock)-1
6660	.b242	05a7					-
6661							                .if version==350
6663							                .else
6664	.b242	05a7	b5 00		lda $00,x	                lda tubeOSGBPBParameterBlock,x
6665							                .endif
6666	.b244	05a9	20 61 06	jsr $0661	                jsr sendR2A
6667	.b247	05ac	ca		dex		                dex
6668	.b248	05ad	10 f8		bpl $05a7	                bpl -
6669	.b24a	05af	68		pla		                pla                          ;restore OSGBPB A result
6670	.b24b	05b0	80 86		bra $0538	                bra sendR2CAThenGoIdle       ;send OSGBPB full result

6672							;-------------------------------------------------------------------------
6673							;
6674							; Handle a Tube OSFILE request.
6675							;
6676							; [Tube p24]
6677							;
6678	.b24d	05b2					doFILE: .proc
6679							                ; receive non-name part of OSFILE parameter block
6680	.b24d	05b2	a2 10		ldx #$10	                ldx #size(OSFILEParameterBlock)-2
6681	.b24f	05b4					-
6682	.b24f	05b4	20 a1 06	jsr $06a1	                jsr recvR2
6683							                .if version==350
6685							                .else
6686	.b252	05b7	95 01		sta $01,x	                sta tubeOSFILEParameterBlock.addresses-1,x
6687							                .endif
6688	.b254	05b9	ca		dex		                dex
6689	.b255	05ba	d0 f8		bne $05b4	                bne -
6690	.b257	05bc	20 74 05	jsr $0574	                jsr recvR2String
6691							                .if version==350
6694							                .else
6695	.b25a	05bf	86 00		stx $00		                stx tubeOSFILEParameterBlock+0
6696	.b25c	05c1	84 01		sty $01		                sty tubeOSFILEParameterBlock+1
6697							                .endif
6698	.b25e	05c3	a0 00		ldy #$00	                ldy #>tubeOSFILEParameterBlock
6699							                .cerror (<tubeOSFILEParameterBlock)!=0,"Tube OSFILE parameter block must be at $0000"
6700	.b260	05c5	20 a1 06	jsr $06a1	                jsr recvR2                   ;receive OSFILE reason code
6701	.b263	05c8	20 dd ff	jsr $ffdd	                jsr OSFILE                   ;call OSFILE
6702	.b266	05cb	20 61 06	jsr $0661	                jsr sendR2A                  ;send OSFILE result

6704							                ; send non-name part of updated OSFILE parameter block
6705	.b269	05ce	a2 10		ldx #$10	                ldx #size(OSFILEParameterBlock)-2
6706	.b26b	05d0					-
6707							                .if version==350
6709							                .else
6710	.b26b	05d0	b5 01		lda $01,x	                lda tubeOSFILEParameterBlock.addresses-1,x
6711							                .endif
6712	.b26d	05d2	20 61 06	jsr $0661	                jsr sendR2A
6713	.b270	05d5	ca		dex		                dex
6714	.b271	05d6	d0 f8		bne $05d0	                bne -
6715	.b273	05d8	80 0e		bra $05e8	                bra goIdle_1
6716							                .pend

6718							;-------------------------------------------------------------------------
6719							;
6720							; Handle a Tube small (A<$80) OSBYTE.
6721							;
6722							; [Tube p22]
6723							;
6724	.b275	05da					doSBYT:
6725	.b275	05da	20 9d 06	jsr $069d	                jsr recvR2XA    ;receive X and A arguments
6726	.b278	05dd	20 f4 ff	jsr $fff4	                jsr OSBYTE
6727	.b27b	05e0					sendR2X:
6728	.b27b	05e0	2c e2 fe	bit $fee2	                bit tube.status2
6729	.b27e	05e3	50 fb		bvc $05e0	                bvc sendR2X
6730	.b280	05e5	8e e3 fe	stx $fee3	                stx tube.data2
6731	.b283	05e8					goIdle_1:
6732	.b283	05e8	4c 36 00	jmp $0036	                jmp idleLoop

6734							;-------------------------------------------------------------------------
6735							;
6736							; Handle a Tube non-small OSBYTE.
6737							;
6738							; [Tube p22]
6739	.b286	05eb					doBYTE:
6740	.b286	05eb	20 9d 06	jsr $069d	                jsr recvR2XA                ;receive X and Y arguments
6741	.b289	05ee	a8		tay		                tay                         ;Y = Y argument
6742	.b28a	05ef	20 a1 06	jsr $06a1	                jsr recvR2                  ;receive A argument
6743	.b28d	05f2	20 f4 ff	jsr $fff4	                jsr OSBYTE                  ;call OSBYTE
6744	.b290	05f5	49 9d		eor #$9d	                eor #$9D                    ;was it Fast Tube BPUT?
6745	.b292	05f7	f0 ef		beq $05e8	                beq goIdle_1      ;if it was, done.
6746	.b294	05f9	6a		ror a		                ror a
6747	.b295	05fa	20 61 06	jsr $0661	                jsr sendR2A       ;send carry result
6748	.b298	05fd					-
6749	.b298	05fd	2c e2 fe	bit $fee2	                bit tube.status2
6750	.b29b	0600	50 fb		bvc $05fd	                bvc -
6751	.b29d	0602	8c e3 fe	sty $fee3	                sty tube.data2               ;send Y result
6752	.b2a0	0605	80 d9		bra $05e0	                bra sendR2X                  ;send X result

6754							;-------------------------------------------------------------------------
6755							;
6756							; Handle a Tube OSWORD request.
6757							;
6758							; [Tube p22]
6759							;
6760	.b2a2	0607					doWORD:
6761	.b2a2	0607	20 a1 06	jsr $06a1	                jsr recvR2
6762	.b2a5	060a	a8		tay		                tay
6763	.b2a6	060b	20 aa 06	jsr $06aa	                jsr LAE0F
6764	.b2a9	060e	30 0a		bmi $061a	                bmi LAD7F
6765	.b2ab	0610					LAD75:
6766	.b2ab	0610	20 a1 06	jsr $06a1	                jsr recvR2
6767	.b2ae	0613	9d 28 01	sta $0128,x	                sta tubeOSWORDBuffer,x
6768	.b2b1	0616	ca		dex		                dex
6769	.b2b2	0617	10 f7		bpl $0610	                bpl LAD75
6770	.b2b4	0619	98		tya		                tya
6771	.b2b5	061a					LAD7F:
6772	.b2b5	061a	a2 28		ldx #$28	                ldx #<tubeOSWORDBuffer
6773	.b2b7	061c	a0 01		ldy #$01	                ldy #>tubeOSWORDBuffer
6774	.b2b9	061e	20 f1 ff	jsr $fff1	                jsr OSWORD
6775	.b2bc	0621	20 aa 06	jsr $06aa	                jsr LAE0F
6776	.b2bf	0624	30 c2		bmi $05e8	                bmi goIdle_1
6777	.b2c1	0626					LAD8B:
6778	.b2c1	0626	bc 28 01	ldy $0128,x	                ldy tubeOSWORDBuffer,x
6779	.b2c4	0629					LAD8E:
6780	.b2c4	0629	2c e2 fe	bit $fee2	                bit tube.status2
6781	.b2c7	062c	50 fb		bvc $0629	                bvc LAD8E
6782	.b2c9	062e	8c e3 fe	sty $fee3	                sty tube.data2
6783	.b2cc	0631	ca		dex		                dex
6784	.b2cd	0632	10 f2		bpl $0626	                bpl LAD8B
6785	.b2cf	0634					LAD99:
6786	.b2cf	0634	80 b2		bra $05e8	                bra goIdle_1

6788							;-------------------------------------------------------------------------

6790	.b2d1	0636					doRDLN:
6791	.b2d1	0636	a2 04		ldx #$04	                ldx #$04
6792	.b2d3	0638					LAD9D:
6793	.b2d3	0638	20 a1 06	jsr $06a1	                jsr recvR2
6794							                .if version==350
6796							                .else
6797	.b2d6	063b	95 00		sta $00,x	                sta $00,x
6798							                .endif
6799	.b2d8	063d	ca		dex		                dex
6800	.b2d9	063e	10 f8		bpl $0638	                bpl LAD9D
6801	.b2db	0640	e8		inx		                inx
6802	.b2dc	0641	8a		txa		                txa
6803	.b2dd	0642	a8		tay		                tay
6804	.b2de	0643	20 f1 ff	jsr $fff1	                jsr OSWORD
6805	.b2e1	0646	90 05		bcc $064d	                bcc LADB2
6806	.b2e3	0648	a9 ff		lda #$ff	                lda #$FF
6807	.b2e5	064a	4c 90 05	jmp $0590	                jmp sendR2AThenGoIdle

6809	.b2e8	064d					LADB2:
6810	.b2e8	064d	a2 00		ldx #$00	                ldx #$00
6811	.b2ea	064f	a9 7f		lda #$7f	                lda #$7F
6812	.b2ec	0651	20 61 06	jsr $0661	                jsr sendR2A
6813	.b2ef	0654					LADB9:
6814	.b2ef	0654	bd 00 07	lda $0700,x	                lda $0700,x
6815	.b2f2	0657	20 61 06	jsr $0661	                jsr sendR2A
6816	.b2f5	065a	e8		inx		                inx
6817	.b2f6	065b	c9 0d		cmp #$0d	                cmp #$0D
6818	.b2f8	065d	d0 f5		bne $0654	                bne LADB9
6819	.b2fa	065f	80 d3		bra $0634	                bra LAD99

6821	.b2fc	0661					sendR2A:                          ;adc6/0661
6822	.b2fc	0661	2c e2 fe	bit $fee2	                bit tube.status2
6823	.b2ff	0664	50 fb		bvc $0661	                bvc sendR2A
6824	.b301	0666	8d e3 fe	sta $fee3	                sta tube.data2
6825	.b304	0669	60		rts		                rts

6827	.b305	066a					sendR4TubeClaimantID:              ;adcf
6828	.b305	066a	a5 15		lda $15		                lda tubeClaimantID ;get Tube ID
6829	.b307	066c					sendR4:                          ;add1/066c
6830	.b307	066c	2c e6 fe	bit $fee6	                bit tube.status4 ;check R4 status
6831	.b30a	066f	50 fb		bvc $066c	                bvc sendR4       ;branch taken if FIFO full
6832	.b30c	0671	8d e7 fe	sta $fee7	                sta tube.data4   ;put byte in FIFO
6833	.b30f	0674	60		rts		                rts

6835	.b310	0675					LADDA:
6836	.b310	0675	a5 ff		lda $ff		                lda $FF
6837	.b312	0677	38		sec		                sec
6838	.b313	0678	6a		ror a		                ror a
6839	.b314	0679	80 0f		bra $068a	                bra LADEF

6841	.b316	067b					eventHandler:
6842	.b316	067b	48		pha		                pha
6843	.b317	067c	a9 00		lda #$00	                lda #$00
6844	.b319	067e	20 8a 06	jsr $068a	                jsr LADEF
6845	.b31c	0681	98		tya		                tya
6846	.b31d	0682	20 8a 06	jsr $068a	                jsr LADEF
6847	.b320	0685	8a		txa		                txa
6848	.b321	0686	20 8a 06	jsr $068a	                jsr LADEF
6849	.b324	0689	68		pla		                pla
6850	.b325	068a					LADEF:
6851	.b325	068a	2c e0 fe	bit $fee0	                bit tube.status1
6852	.b328	068d	50 fb		bvc $068a	                bvc LADEF
6853	.b32a	068f	8d e1 fe	sta $fee1	                sta tube.data1
6854	.b32d	0692	60		rts		                rts

6856							;-------------------------------------------------------------------------
6857							;
6858							; Receive multiple bytes via R2: some kind of parameter block,
6859							; followed by the reason code. Store the first N-1 received in zero
6860							; page, starting at $00.
6861							;
6862							; entry:
6863							;
6864							; X = number of bytes to receive, minus 1
6865							;
6866							; exit:
6867							;
6868							; ?$00, ?$01... = first N-1 bytes received
6869							;
6870							; A = final byte received
6871							;
6872							; X = 0
6873							;
6874	.b32e	0693					recvR2N:
6875	.b32e	0693	20 a1 06	jsr $06a1	                jsr recvR2
6876	.b331	0696	95 ff		sta $ff,x	                sta $ff,x
6877	.b333	0698	ca		dex		                dex
6878	.b334	0699	d0 f8		bne $0693	                bne recvR2N
6879	.b336	069b	80 04		bra $06a1	                bra recvR2

6881							;-------------------------------------------------------------------------
6882							;
6883							; Receive 2 bytes via R2.
6884							;
6885							; exit:
6886							;
6887							; X = first byte received
6888							;
6889							; A = second byte received
6890							;
6891	.b338	069d					recvR2XA:
6892	.b338	069d	20 a1 06	jsr $06a1	                jsr recvR2
6893	.b33b	06a0	aa		tax		                tax

6895							;-------------------------------------------------------------------------
6896							;
6897							; Receive 1 byte via R2.
6898							;
6899							; exit:
6900							;
6901							; A = byte received
6902							;
6903	.b33c	06a1					recvR2:
6904	.b33c	06a1	2c e2 fe	bit $fee2	                bit tube.status2
6905	.b33f	06a4	10 fb		bpl $06a1	                bpl recvR2
6906	.b341	06a6	ad e3 fe	lda $fee3	                lda tube.data2
6907	.b344	06a9	60		rts		                rts

6909							;-------------------------------------------------------------------------

6911	.b345	06aa					LAE0F:
6912	.b345	06aa	2c e2 fe	bit $fee2	                bit tube.status2
6913	.b348	06ad	10 fb		bpl $06aa	                bpl LAE0F
6914	.b34a	06af	ae e3 fe	ldx $fee3	                ldx tube.data2
6915	.b34d	06b2	ca		dex		                dex
6916	.b34e	06b3	60		rts		                rts
6917							                .here
6918							                .bend

6920							;-------------------------------------------------------------------------
6921							                .endif

6923							                .if version<400&&includeTerminalROM
6925							                .endif

6927							                .if version==350&&!includeTerminalROM
6929							                .endif

6931							                .if version>=500||!includeTerminalROM
6933							                .endif

6935							;-------------------------------------------------------------------------

6937							; Unused space
6938							; ============
6939	>b34f		ff ff ff ff ff ff ff ff		                .fill $b900-*,$ff
	>b357		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b367		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b377		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b387		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b397		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b3a7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b3b7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b3c7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b3d7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b3e7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b3f7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b407		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b417		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b427		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b437		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b447		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b457		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b467		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b477		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b487		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b497		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b4a7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b4b7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b4c7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b4d7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b4e7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b4f7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b507		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b517		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b527		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b537		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b547		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b557		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b567		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b577		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b587		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b597		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5a7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5b7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5c7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5d7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5e7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5f7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b607		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b617		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b627		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b637		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b647		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b657		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b667		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b677		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b687		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b697		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6a7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6b7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6c7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6d7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6e7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6f7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b707		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b717		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b727		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b737		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b747		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b757		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b767		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b777		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b787		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b797		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7a7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7b7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7c7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7d7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7e7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7f7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b807		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b817		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b827		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b837		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b847		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b857		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b867		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b877		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b887		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b897		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8a7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8b7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8c7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8d7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8e7		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8f7		ff ff ff ff ff ff ff ff ff

6941							; Default font
6942							; ============
6943	.b900						LB900:
6944							                .cerror (<LB900)!=0,"font data must be page aligned"
6945							                ; CHR$32 -
6946	>b900		00				                .byte %00000000
6947	>b901		00				                .byte %00000000
6948	>b902		00				                .byte %00000000
6949	>b903		00				                .byte %00000000
6950	>b904		00				                .byte %00000000
6951	>b905		00				                .byte %00000000
6952	>b906		00				                .byte %00000000
6953	>b907		00				                .byte %00000000

6955							                ; CHR$33 - !
6956	>b908		18				                .byte %00011000
6957	>b909		18				                .byte %00011000
6958	>b90a		18				                .byte %00011000
6959	>b90b		18				                .byte %00011000
6960	>b90c		18				                .byte %00011000
6961	>b90d		00				                .byte %00000000
6962	>b90e		18				                .byte %00011000
6963	>b90f		00				                .byte %00000000

6965							                ; CHR$34 - "
6966	>b910		6c				                .byte %01101100
6967	>b911		6c				                .byte %01101100
6968	>b912		6c				                .byte %01101100
6969	>b913		00				                .byte %00000000
6970	>b914		00				                .byte %00000000
6971	>b915		00				                .byte %00000000
6972	>b916		00				                .byte %00000000
6973	>b917		00				                .byte %00000000

6975							                ; CHR$35 - #
6976	>b918		36				                .byte %00110110
6977	>b919		36				                .byte %00110110
6978	>b91a		7f				                .byte %01111111
6979	>b91b		36				                .byte %00110110
6980	>b91c		7f				                .byte %01111111
6981	>b91d		36				                .byte %00110110
6982	>b91e		36				                .byte %00110110
6983	>b91f		00				                .byte %00000000

6985							                ; CHR$36 - $
6986	>b920		0c				                .byte %00001100
6987	>b921		3f				                .byte %00111111
6988	>b922		68				                .byte %01101000
6989	>b923		3e				                .byte %00111110
6990	>b924		0b				                .byte %00001011
6991	>b925		7e				                .byte %01111110
6992	>b926		18				                .byte %00011000
6993	>b927		00				                .byte %00000000

6995							                ; CHR$37 - %
6996	>b928		60				                .byte %01100000
6997	>b929		66				                .byte %01100110
6998	>b92a		0c				                .byte %00001100
6999	>b92b		18				                .byte %00011000
7000	>b92c		30				                .byte %00110000
7001	>b92d		66				                .byte %01100110
7002	>b92e		06				                .byte %00000110
7003	>b92f		00				                .byte %00000000

7005							                ; CHR$38 - &
7006	>b930		38				                .byte %00111000
7007	>b931		6c				                .byte %01101100
7008	>b932		6c				                .byte %01101100
7009	>b933		38				                .byte %00111000
7010	>b934		6d				                .byte %01101101
7011	>b935		66				                .byte %01100110
7012	>b936		3b				                .byte %00111011
7013	>b937		00				                .byte %00000000

7015							                ; CHR$39 - '
7016	>b938		0c				                .byte %00001100
7017	>b939		18				                .byte %00011000
7018	>b93a		30				                .byte %00110000
7019	>b93b		00				                .byte %00000000
7020	>b93c		00				                .byte %00000000
7021	>b93d		00				                .byte %00000000
7022	>b93e		00				                .byte %00000000
7023	>b93f		00				                .byte %00000000

7025							                ; CHR$40 - (
7026	>b940		0c				                .byte %00001100
7027	>b941		18				                .byte %00011000
7028	>b942		30				                .byte %00110000
7029	>b943		30				                .byte %00110000
7030	>b944		30				                .byte %00110000
7031	>b945		18				                .byte %00011000
7032	>b946		0c				                .byte %00001100
7033	>b947		00				                .byte %00000000

7035							                ; CHR$41 - )
7036	>b948		30				                .byte %00110000
7037	>b949		18				                .byte %00011000
7038	>b94a		0c				                .byte %00001100
7039	>b94b		0c				                .byte %00001100
7040	>b94c		0c				                .byte %00001100
7041	>b94d		18				                .byte %00011000
7042	>b94e		30				                .byte %00110000
7043	>b94f		00				                .byte %00000000

7045							                ; CHR$42 - *
7046	>b950		00				                .byte %00000000
7047	>b951		18				                .byte %00011000
7048	>b952		7e				                .byte %01111110
7049	>b953		3c				                .byte %00111100
7050	>b954		7e				                .byte %01111110
7051	>b955		18				                .byte %00011000
7052	>b956		00				                .byte %00000000
7053	>b957		00				                .byte %00000000

7055							                ; CHR$43 - +
7056	>b958		00				                .byte %00000000
7057	>b959		18				                .byte %00011000
7058	>b95a		18				                .byte %00011000
7059	>b95b		7e				                .byte %01111110
7060	>b95c		18				                .byte %00011000
7061	>b95d		18				                .byte %00011000
7062	>b95e		00				                .byte %00000000
7063	>b95f		00				                .byte %00000000

7065							                ; CHR$44 - ,
7066	>b960		00				                .byte %00000000
7067	>b961		00				                .byte %00000000
7068	>b962		00				                .byte %00000000
7069	>b963		00				                .byte %00000000
7070	>b964		00				                .byte %00000000
7071	>b965		18				                .byte %00011000
7072	>b966		18				                .byte %00011000
7073	>b967		30				                .byte %00110000

7075							                ; CHR$45 - -
7076	>b968		00				                .byte %00000000
7077	>b969		00				                .byte %00000000
7078	>b96a		00				                .byte %00000000
7079	>b96b		7e				                .byte %01111110
7080	>b96c		00				                .byte %00000000
7081	>b96d		00				                .byte %00000000
7082	>b96e		00				                .byte %00000000
7083	>b96f		00				                .byte %00000000

7085							                ; CHR$46 - .
7086	>b970		00				                .byte %00000000
7087	>b971		00				                .byte %00000000
7088	>b972		00				                .byte %00000000
7089	>b973		00				                .byte %00000000
7090	>b974		00				                .byte %00000000
7091	>b975		18				                .byte %00011000
7092	>b976		18				                .byte %00011000
7093	>b977		00				                .byte %00000000

7095							                ; CHR$47 - /
7096	>b978		00				                .byte %00000000
7097	>b979		06				                .byte %00000110
7098	>b97a		0c				                .byte %00001100
7099	>b97b		18				                .byte %00011000
7100	>b97c		30				                .byte %00110000
7101	>b97d		60				                .byte %01100000
7102	>b97e		00				                .byte %00000000
7103	>b97f		00				                .byte %00000000

7105							                ; CHR$48 - 0
7106	>b980		3c				                .byte %00111100
7107	>b981		66				                .byte %01100110
7108	>b982		6e				                .byte %01101110
7109	>b983		7e				                .byte %01111110
7110	>b984		76				                .byte %01110110
7111	>b985		66				                .byte %01100110
7112	>b986		3c				                .byte %00111100
7113	>b987		00				                .byte %00000000

7115							                ; CHR$49 - 1
7116	>b988		18				                .byte %00011000
7117	>b989		38				                .byte %00111000
7118	>b98a		18				                .byte %00011000
7119	>b98b		18				                .byte %00011000
7120	>b98c		18				                .byte %00011000
7121	>b98d		18				                .byte %00011000
7122	>b98e		7e				                .byte %01111110
7123	>b98f		00				                .byte %00000000

7125							                ; CHR$50 - 2
7126	>b990		3c				                .byte %00111100
7127	>b991		66				                .byte %01100110
7128	>b992		06				                .byte %00000110
7129	>b993		0c				                .byte %00001100
7130	>b994		18				                .byte %00011000
7131	>b995		30				                .byte %00110000
7132	>b996		7e				                .byte %01111110
7133	>b997		00				                .byte %00000000

7135							                ; CHR$51 - 3
7136	>b998		3c				                .byte %00111100
7137	>b999		66				                .byte %01100110
7138	>b99a		06				                .byte %00000110
7139	>b99b		1c				                .byte %00011100
7140	>b99c		06				                .byte %00000110
7141	>b99d		66				                .byte %01100110
7142	>b99e		3c				                .byte %00111100
7143	>b99f		00				                .byte %00000000

7145							                ; CHR$52 - 4
7146	>b9a0		0c				                .byte %00001100
7147	>b9a1		1c				                .byte %00011100
7148	>b9a2		3c				                .byte %00111100
7149	>b9a3		6c				                .byte %01101100
7150	>b9a4		7e				                .byte %01111110
7151	>b9a5		0c				                .byte %00001100
7152	>b9a6		0c				                .byte %00001100
7153	>b9a7		00				                .byte %00000000

7155							                ; CHR$53 - 5
7156	>b9a8		7e				                .byte %01111110
7157	>b9a9		60				                .byte %01100000
7158	>b9aa		7c				                .byte %01111100
7159	>b9ab		06				                .byte %00000110
7160	>b9ac		06				                .byte %00000110
7161	>b9ad		66				                .byte %01100110
7162	>b9ae		3c				                .byte %00111100
7163	>b9af		00				                .byte %00000000

7165							                ; CHR$54 - 6
7166	>b9b0		1c				                .byte %00011100
7167	>b9b1		30				                .byte %00110000
7168	>b9b2		60				                .byte %01100000
7169	>b9b3		7c				                .byte %01111100
7170	>b9b4		66				                .byte %01100110
7171	>b9b5		66				                .byte %01100110
7172	>b9b6		3c				                .byte %00111100
7173	>b9b7		00				                .byte %00000000

7175							                ; CHR$55 - 7
7176	>b9b8		7e				                .byte %01111110
7177	>b9b9		06				                .byte %00000110
7178	>b9ba		0c				                .byte %00001100
7179	>b9bb		18				                .byte %00011000
7180	>b9bc		30				                .byte %00110000
7181	>b9bd		30				                .byte %00110000
7182	>b9be		30				                .byte %00110000
7183	>b9bf		00				                .byte %00000000

7185							                ; CHR$56 - 8
7186	>b9c0		3c				                .byte %00111100
7187	>b9c1		66				                .byte %01100110
7188	>b9c2		66				                .byte %01100110
7189	>b9c3		3c				                .byte %00111100
7190	>b9c4		66				                .byte %01100110
7191	>b9c5		66				                .byte %01100110
7192	>b9c6		3c				                .byte %00111100
7193	>b9c7		00				                .byte %00000000

7195							                ; CHR$57 - 9
7196	>b9c8		3c				                .byte %00111100
7197	>b9c9		66				                .byte %01100110
7198	>b9ca		66				                .byte %01100110
7199	>b9cb		3e				                .byte %00111110
7200	>b9cc		06				                .byte %00000110
7201	>b9cd		0c				                .byte %00001100
7202	>b9ce		38				                .byte %00111000
7203	>b9cf		00				                .byte %00000000

7205							                ; CHR$58 - :
7206	>b9d0		00				                .byte %00000000
7207	>b9d1		00				                .byte %00000000
7208	>b9d2		18				                .byte %00011000
7209	>b9d3		18				                .byte %00011000
7210	>b9d4		00				                .byte %00000000
7211	>b9d5		18				                .byte %00011000
7212	>b9d6		18				                .byte %00011000
7213	>b9d7		00				                .byte %00000000

7215							                ; CHR$59 - ;
7216	>b9d8		00				                .byte %00000000
7217	>b9d9		00				                .byte %00000000
7218	>b9da		18				                .byte %00011000
7219	>b9db		18				                .byte %00011000
7220	>b9dc		00				                .byte %00000000
7221	>b9dd		18				                .byte %00011000
7222	>b9de		18				                .byte %00011000
7223	>b9df		30				                .byte %00110000

7225							                ; CHR$60 - <
7226	>b9e0		0c				                .byte %00001100
7227	>b9e1		18				                .byte %00011000
7228	>b9e2		30				                .byte %00110000
7229	>b9e3		60				                .byte %01100000
7230	>b9e4		30				                .byte %00110000
7231	>b9e5		18				                .byte %00011000
7232	>b9e6		0c				                .byte %00001100
7233	>b9e7		00				                .byte %00000000

7235							                ; CHR$61 - =
7236	>b9e8		00				                .byte %00000000
7237	>b9e9		00				                .byte %00000000
7238	>b9ea		7e				                .byte %01111110
7239	>b9eb		00				                .byte %00000000
7240	>b9ec		7e				                .byte %01111110
7241	>b9ed		00				                .byte %00000000
7242	>b9ee		00				                .byte %00000000
7243	>b9ef		00				                .byte %00000000

7245							                ; CHR$62 - >
7246	>b9f0		30				                .byte %00110000
7247	>b9f1		18				                .byte %00011000
7248	>b9f2		0c				                .byte %00001100
7249	>b9f3		06				                .byte %00000110
7250	>b9f4		0c				                .byte %00001100
7251	>b9f5		18				                .byte %00011000
7252	>b9f6		30				                .byte %00110000
7253	>b9f7		00				                .byte %00000000

7255							                ; CHR$63 - ?
7256	>b9f8		3c				                .byte %00111100
7257	>b9f9		66				                .byte %01100110
7258	>b9fa		0c				                .byte %00001100
7259	>b9fb		18				                .byte %00011000
7260	>b9fc		18				                .byte %00011000
7261	>b9fd		00				                .byte %00000000
7262	>b9fe		18				                .byte %00011000
7263	>b9ff		00				                .byte %00000000

7265							                ; CHR$64 - @
7266	>ba00		3c				                .byte %00111100
7267	>ba01		66				                .byte %01100110
7268	>ba02		6e				                .byte %01101110
7269	>ba03		6a				                .byte %01101010
7270	>ba04		6e				                .byte %01101110
7271	>ba05		60				                .byte %01100000
7272	>ba06		3c				                .byte %00111100
7273	>ba07		00				                .byte %00000000

7275							                ; CHR$65 - A
7276	>ba08		3c				                .byte %00111100
7277	>ba09		66				                .byte %01100110
7278	>ba0a		66				                .byte %01100110
7279	>ba0b		7e				                .byte %01111110
7280	>ba0c		66				                .byte %01100110
7281	>ba0d		66				                .byte %01100110
7282	>ba0e		66				                .byte %01100110
7283	>ba0f		00				                .byte %00000000

7285							                ; CHR$66 - B
7286	>ba10		7c				                .byte %01111100
7287	>ba11		66				                .byte %01100110
7288	>ba12		66				                .byte %01100110
7289	>ba13		7c				                .byte %01111100
7290	>ba14		66				                .byte %01100110
7291	>ba15		66				                .byte %01100110
7292	>ba16		7c				                .byte %01111100
7293	>ba17		00				                .byte %00000000

7295							                ; CHR$67 - C
7296	>ba18		3c				                .byte %00111100
7297	>ba19		66				                .byte %01100110
7298	>ba1a		60				                .byte %01100000
7299	>ba1b		60				                .byte %01100000
7300	>ba1c		60				                .byte %01100000
7301	>ba1d		66				                .byte %01100110
7302	>ba1e		3c				                .byte %00111100
7303	>ba1f		00				                .byte %00000000

7305							                ; CHR$68 - D
7306	>ba20		78				                .byte %01111000
7307	>ba21		6c				                .byte %01101100
7308	>ba22		66				                .byte %01100110
7309	>ba23		66				                .byte %01100110
7310	>ba24		66				                .byte %01100110
7311	>ba25		6c				                .byte %01101100
7312	>ba26		78				                .byte %01111000
7313	>ba27		00				                .byte %00000000

7315							                ; CHR$69 - E
7316	>ba28		7e				                .byte %01111110
7317	>ba29		60				                .byte %01100000
7318	>ba2a		60				                .byte %01100000
7319	>ba2b		7c				                .byte %01111100
7320	>ba2c		60				                .byte %01100000
7321	>ba2d		60				                .byte %01100000
7322	>ba2e		7e				                .byte %01111110
7323	>ba2f		00				                .byte %00000000

7325							                ; CHR$70 - F
7326	>ba30		7e				                .byte %01111110
7327	>ba31		60				                .byte %01100000
7328	>ba32		60				                .byte %01100000
7329	>ba33		7c				                .byte %01111100
7330	>ba34		60				                .byte %01100000
7331	>ba35		60				                .byte %01100000
7332	>ba36		60				                .byte %01100000
7333	>ba37		00				                .byte %00000000

7335							                ; CHR$71 - G
7336	>ba38		3c				                .byte %00111100
7337	>ba39		66				                .byte %01100110
7338	>ba3a		60				                .byte %01100000
7339	>ba3b		6e				                .byte %01101110
7340	>ba3c		66				                .byte %01100110
7341	>ba3d		66				                .byte %01100110
7342	>ba3e		3c				                .byte %00111100
7343	>ba3f		00				                .byte %00000000

7345							                ; CHR$72 - H
7346	>ba40		66				                .byte %01100110
7347	>ba41		66				                .byte %01100110
7348	>ba42		66				                .byte %01100110
7349	>ba43		7e				                .byte %01111110
7350	>ba44		66				                .byte %01100110
7351	>ba45		66				                .byte %01100110
7352	>ba46		66				                .byte %01100110
7353	>ba47		00				                .byte %00000000

7355							                ; CHR$73 - I
7356	>ba48		7e				                .byte %01111110
7357	>ba49		18				                .byte %00011000
7358	>ba4a		18				                .byte %00011000
7359	>ba4b		18				                .byte %00011000
7360	>ba4c		18				                .byte %00011000
7361	>ba4d		18				                .byte %00011000
7362	>ba4e		7e				                .byte %01111110
7363	>ba4f		00				                .byte %00000000

7365							                ; CHR$74 - J
7366	>ba50		3e				                .byte %00111110
7367	>ba51		0c				                .byte %00001100
7368	>ba52		0c				                .byte %00001100
7369	>ba53		0c				                .byte %00001100
7370	>ba54		0c				                .byte %00001100
7371	>ba55		6c				                .byte %01101100
7372	>ba56		38				                .byte %00111000
7373	>ba57		00				                .byte %00000000

7375							                ; CHR$75 - K
7376	>ba58		66				                .byte %01100110
7377	>ba59		6c				                .byte %01101100
7378	>ba5a		78				                .byte %01111000
7379	>ba5b		70				                .byte %01110000
7380	>ba5c		78				                .byte %01111000
7381	>ba5d		6c				                .byte %01101100
7382	>ba5e		66				                .byte %01100110
7383	>ba5f		00				                .byte %00000000

7385							                ; CHR$76 - L
7386	>ba60		60				                .byte %01100000
7387	>ba61		60				                .byte %01100000
7388	>ba62		60				                .byte %01100000
7389	>ba63		60				                .byte %01100000
7390	>ba64		60				                .byte %01100000
7391	>ba65		60				                .byte %01100000
7392	>ba66		7e				                .byte %01111110
7393	>ba67		00				                .byte %00000000

7395							                ; CHR$77 - M
7396	>ba68		63				                .byte %01100011
7397	>ba69		77				                .byte %01110111
7398	>ba6a		7f				                .byte %01111111
7399	>ba6b		6b				                .byte %01101011
7400	>ba6c		6b				                .byte %01101011
7401	>ba6d		63				                .byte %01100011
7402	>ba6e		63				                .byte %01100011
7403	>ba6f		00				                .byte %00000000

7405							                ; CHR$78 - N
7406	>ba70		66				                .byte %01100110
7407	>ba71		66				                .byte %01100110
7408	>ba72		76				                .byte %01110110
7409	>ba73		7e				                .byte %01111110
7410	>ba74		6e				                .byte %01101110
7411	>ba75		66				                .byte %01100110
7412	>ba76		66				                .byte %01100110
7413	>ba77		00				                .byte %00000000

7415							                ; CHR$79 - O
7416	>ba78		3c				                .byte %00111100
7417	>ba79		66				                .byte %01100110
7418	>ba7a		66				                .byte %01100110
7419	>ba7b		66				                .byte %01100110
7420	>ba7c		66				                .byte %01100110
7421	>ba7d		66				                .byte %01100110
7422	>ba7e		3c				                .byte %00111100
7423	>ba7f		00				                .byte %00000000

7425							                ; CHR$80 - P
7426	>ba80		7c				                .byte %01111100
7427	>ba81		66				                .byte %01100110
7428	>ba82		66				                .byte %01100110
7429	>ba83		7c				                .byte %01111100
7430	>ba84		60				                .byte %01100000
7431	>ba85		60				                .byte %01100000
7432	>ba86		60				                .byte %01100000
7433	>ba87		00				                .byte %00000000

7435							                ; CHR$81 - Q
7436	>ba88		3c				                .byte %00111100
7437	>ba89		66				                .byte %01100110
7438	>ba8a		66				                .byte %01100110
7439	>ba8b		66				                .byte %01100110
7440	>ba8c		6a				                .byte %01101010
7441	>ba8d		6c				                .byte %01101100
7442	>ba8e		36				                .byte %00110110
7443	>ba8f		00				                .byte %00000000

7445							                ; CHR$82 - R
7446	>ba90		7c				                .byte %01111100
7447	>ba91		66				                .byte %01100110
7448	>ba92		66				                .byte %01100110
7449	>ba93		7c				                .byte %01111100
7450	>ba94		6c				                .byte %01101100
7451	>ba95		66				                .byte %01100110
7452	>ba96		66				                .byte %01100110
7453	>ba97		00				                .byte %00000000

7455							                ; CHR$83 - S
7456	>ba98		3c				                .byte %00111100
7457	>ba99		66				                .byte %01100110
7458	>ba9a		60				                .byte %01100000
7459	>ba9b		3c				                .byte %00111100
7460	>ba9c		06				                .byte %00000110
7461	>ba9d		66				                .byte %01100110
7462	>ba9e		3c				                .byte %00111100
7463	>ba9f		00				                .byte %00000000

7465							                ; CHR$84 - T
7466	>baa0		7e				                .byte %01111110
7467	>baa1		18				                .byte %00011000
7468	>baa2		18				                .byte %00011000
7469	>baa3		18				                .byte %00011000
7470	>baa4		18				                .byte %00011000
7471	>baa5		18				                .byte %00011000
7472	>baa6		18				                .byte %00011000
7473	>baa7		00				                .byte %00000000

7475							                ; CHR$85 - U
7476	>baa8		66				                .byte %01100110
7477	>baa9		66				                .byte %01100110
7478	>baaa		66				                .byte %01100110
7479	>baab		66				                .byte %01100110
7480	>baac		66				                .byte %01100110
7481	>baad		66				                .byte %01100110
7482	>baae		3c				                .byte %00111100
7483	>baaf		00				                .byte %00000000

7485							                ; CHR$86 - V
7486	>bab0		66				                .byte %01100110
7487	>bab1		66				                .byte %01100110
7488	>bab2		66				                .byte %01100110
7489	>bab3		66				                .byte %01100110
7490	>bab4		66				                .byte %01100110
7491	>bab5		3c				                .byte %00111100
7492	>bab6		18				                .byte %00011000
7493	>bab7		00				                .byte %00000000

7495							                ; CHR$87 - W
7496	>bab8		63				                .byte %01100011
7497	>bab9		63				                .byte %01100011
7498	>baba		6b				                .byte %01101011
7499	>babb		6b				                .byte %01101011
7500	>babc		7f				                .byte %01111111
7501	>babd		77				                .byte %01110111
7502	>babe		63				                .byte %01100011
7503	>babf		00				                .byte %00000000

7505							                ; CHR$88 - X
7506	>bac0		66				                .byte %01100110
7507	>bac1		66				                .byte %01100110
7508	>bac2		3c				                .byte %00111100
7509	>bac3		18				                .byte %00011000
7510	>bac4		3c				                .byte %00111100
7511	>bac5		66				                .byte %01100110
7512	>bac6		66				                .byte %01100110
7513	>bac7		00				                .byte %00000000

7515							                ; CHR$89 - Y
7516	>bac8		66				                .byte %01100110
7517	>bac9		66				                .byte %01100110
7518	>baca		66				                .byte %01100110
7519	>bacb		3c				                .byte %00111100
7520	>bacc		18				                .byte %00011000
7521	>bacd		18				                .byte %00011000
7522	>bace		18				                .byte %00011000
7523	>bacf		00				                .byte %00000000

7525							                ; CHR$90 - Z
7526	>bad0		7e				                .byte %01111110
7527	>bad1		06				                .byte %00000110
7528	>bad2		0c				                .byte %00001100
7529	>bad3		18				                .byte %00011000
7530	>bad4		30				                .byte %00110000
7531	>bad5		60				                .byte %01100000
7532	>bad6		7e				                .byte %01111110
7533	>bad7		00				                .byte %00000000

7535							                ; CHR$91 - [
7536	>bad8		7c				                .byte %01111100
7537	>bad9		60				                .byte %01100000
7538	>bada		60				                .byte %01100000
7539	>badb		60				                .byte %01100000
7540	>badc		60				                .byte %01100000
7541	>badd		60				                .byte %01100000
7542	>bade		7c				                .byte %01111100
7543	>badf		00				                .byte %00000000

7545							                ; CHR$92 - \
7546	>bae0		00				                .byte %00000000
7547	>bae1		60				                .byte %01100000
7548	>bae2		30				                .byte %00110000
7549	>bae3		18				                .byte %00011000
7550	>bae4		0c				                .byte %00001100
7551	>bae5		06				                .byte %00000110
7552	>bae6		00				                .byte %00000000
7553	>bae7		00				                .byte %00000000

7555							                ; CHR$93 - ]
7556	>bae8		3e				                .byte %00111110
7557	>bae9		06				                .byte %00000110
7558	>baea		06				                .byte %00000110
7559	>baeb		06				                .byte %00000110
7560	>baec		06				                .byte %00000110
7561	>baed		06				                .byte %00000110
7562	>baee		3e				                .byte %00111110
7563	>baef		00				                .byte %00000000

7565							                ; CHR$94 - ^
7566	>baf0		18				                .byte %00011000
7567	>baf1		3c				                .byte %00111100
7568	>baf2		66				                .byte %01100110
7569	>baf3		42				                .byte %01000010
7570	>baf4		00				                .byte %00000000
7571	>baf5		00				                .byte %00000000
7572	>baf6		00				                .byte %00000000
7573	>baf7		00				                .byte %00000000

7575							                ; CHR$95 - _
7576	>baf8		00				                .byte %00000000
7577	>baf9		00				                .byte %00000000
7578	>bafa		00				                .byte %00000000
7579	>bafb		00				                .byte %00000000
7580	>bafc		00				                .byte %00000000
7581	>bafd		00				                .byte %00000000
7582	>bafe		00				                .byte %00000000
7583	>baff		ff				                .byte %11111111

7585							                ; CHR$96
7586	>bb00		1c				                .byte %00011100
7587	>bb01		36				                .byte %00110110
7588	>bb02		30				                .byte %00110000
7589	>bb03		7c				                .byte %01111100
7590	>bb04		30				                .byte %00110000
7591	>bb05		30				                .byte %00110000
7592	>bb06		7e				                .byte %01111110
7593	>bb07		00				                .byte %00000000

7595							                ; CHR$97 - a
7596	>bb08		00				                .byte %00000000
7597	>bb09		00				                .byte %00000000
7598	>bb0a		3c				                .byte %00111100
7599	>bb0b		06				                .byte %00000110
7600	>bb0c		3e				                .byte %00111110
7601	>bb0d		66				                .byte %01100110
7602	>bb0e		3e				                .byte %00111110
7603	>bb0f		00				                .byte %00000000

7605							                ; CHR$98 - b
7606	>bb10		60				                .byte %01100000
7607	>bb11		60				                .byte %01100000
7608	>bb12		7c				                .byte %01111100
7609	>bb13		66				                .byte %01100110
7610	>bb14		66				                .byte %01100110
7611	>bb15		66				                .byte %01100110
7612	>bb16		7c				                .byte %01111100
7613	>bb17		00				                .byte %00000000

7615							                ; CHR$99 - c
7616	>bb18		00				                .byte %00000000
7617	>bb19		00				                .byte %00000000
7618	>bb1a		3c				                .byte %00111100
7619	>bb1b		66				                .byte %01100110
7620	>bb1c		60				                .byte %01100000
7621	>bb1d		66				                .byte %01100110
7622	>bb1e		3c				                .byte %00111100
7623	>bb1f		00				                .byte %00000000

7625							                ; CHR$100 - d
7626	>bb20		06				                .byte %00000110
7627	>bb21		06				                .byte %00000110
7628	>bb22		3e				                .byte %00111110
7629	>bb23		66				                .byte %01100110
7630	>bb24		66				                .byte %01100110
7631	>bb25		66				                .byte %01100110
7632	>bb26		3e				                .byte %00111110
7633	>bb27		00				                .byte %00000000

7635							                ; CHR$101 - e
7636	>bb28		00				                .byte %00000000
7637	>bb29		00				                .byte %00000000
7638	>bb2a		3c				                .byte %00111100
7639	>bb2b		66				                .byte %01100110
7640	>bb2c		7e				                .byte %01111110
7641	>bb2d		60				                .byte %01100000
7642	>bb2e		3c				                .byte %00111100
7643	>bb2f		00				                .byte %00000000

7645							                ; CHR$102 - f
7646	>bb30		1c				                .byte %00011100
7647	>bb31		30				                .byte %00110000
7648	>bb32		30				                .byte %00110000
7649	>bb33		7c				                .byte %01111100
7650	>bb34		30				                .byte %00110000
7651	>bb35		30				                .byte %00110000
7652	>bb36		30				                .byte %00110000
7653	>bb37		00				                .byte %00000000

7655							                ; CHR$103 - g
7656	>bb38		00				                .byte %00000000
7657	>bb39		00				                .byte %00000000
7658	>bb3a		3e				                .byte %00111110
7659	>bb3b		66				                .byte %01100110
7660	>bb3c		66				                .byte %01100110
7661	>bb3d		3e				                .byte %00111110
7662	>bb3e		06				                .byte %00000110
7663	>bb3f		3c				                .byte %00111100

7665							                ; CHR$104 - h
7666	>bb40		60				                .byte %01100000
7667	>bb41		60				                .byte %01100000
7668	>bb42		7c				                .byte %01111100
7669	>bb43		66				                .byte %01100110
7670	>bb44		66				                .byte %01100110
7671	>bb45		66				                .byte %01100110
7672	>bb46		66				                .byte %01100110
7673	>bb47		00				                .byte %00000000

7675							                ; CHR$105 - i
7676	>bb48		18				                .byte %00011000
7677	>bb49		00				                .byte %00000000
7678	>bb4a		38				                .byte %00111000
7679	>bb4b		18				                .byte %00011000
7680	>bb4c		18				                .byte %00011000
7681	>bb4d		18				                .byte %00011000
7682	>bb4e		3c				                .byte %00111100
7683	>bb4f		00				                .byte %00000000

7685							                ; CHR$106 - j
7686	>bb50		18				                .byte %00011000
7687	>bb51		00				                .byte %00000000
7688	>bb52		38				                .byte %00111000
7689	>bb53		18				                .byte %00011000
7690	>bb54		18				                .byte %00011000
7691	>bb55		18				                .byte %00011000
7692	>bb56		18				                .byte %00011000
7693	>bb57		70				                .byte %01110000

7695							                ; CHR$107 - k
7696	>bb58		60				                .byte %01100000
7697	>bb59		60				                .byte %01100000
7698	>bb5a		66				                .byte %01100110
7699	>bb5b		6c				                .byte %01101100
7700	>bb5c		78				                .byte %01111000
7701	>bb5d		6c				                .byte %01101100
7702	>bb5e		66				                .byte %01100110
7703	>bb5f		00				                .byte %00000000

7705							                ; CHR$108 - l
7706	>bb60		38				                .byte %00111000
7707	>bb61		18				                .byte %00011000
7708	>bb62		18				                .byte %00011000
7709	>bb63		18				                .byte %00011000
7710	>bb64		18				                .byte %00011000
7711	>bb65		18				                .byte %00011000
7712	>bb66		3c				                .byte %00111100
7713	>bb67		00				                .byte %00000000

7715							                ; CHR$109 - m
7716	>bb68		00				                .byte %00000000
7717	>bb69		00				                .byte %00000000
7718	>bb6a		36				                .byte %00110110
7719	>bb6b		7f				                .byte %01111111
7720	>bb6c		6b				                .byte %01101011
7721	>bb6d		6b				                .byte %01101011
7722	>bb6e		63				                .byte %01100011
7723	>bb6f		00				                .byte %00000000

7725							                ; CHR$110 - n
7726	>bb70		00				                .byte %00000000
7727	>bb71		00				                .byte %00000000
7728	>bb72		7c				                .byte %01111100
7729	>bb73		66				                .byte %01100110
7730	>bb74		66				                .byte %01100110
7731	>bb75		66				                .byte %01100110
7732	>bb76		66				                .byte %01100110
7733	>bb77		00				                .byte %00000000

7735							                ; CHR$111 - o
7736	>bb78		00				                .byte %00000000
7737	>bb79		00				                .byte %00000000
7738	>bb7a		3c				                .byte %00111100
7739	>bb7b		66				                .byte %01100110
7740	>bb7c		66				                .byte %01100110
7741	>bb7d		66				                .byte %01100110
7742	>bb7e		3c				                .byte %00111100
7743	>bb7f		00				                .byte %00000000

7745							                ; CHR$112 - p
7746	>bb80		00				                .byte %00000000
7747	>bb81		00				                .byte %00000000
7748	>bb82		7c				                .byte %01111100
7749	>bb83		66				                .byte %01100110
7750	>bb84		66				                .byte %01100110
7751	>bb85		7c				                .byte %01111100
7752	>bb86		60				                .byte %01100000
7753	>bb87		60				                .byte %01100000

7755							                ; CHR$113 - q
7756	>bb88		00				                .byte %00000000
7757	>bb89		00				                .byte %00000000
7758	>bb8a		3e				                .byte %00111110
7759	>bb8b		66				                .byte %01100110
7760	>bb8c		66				                .byte %01100110
7761	>bb8d		3e				                .byte %00111110
7762	>bb8e		06				                .byte %00000110
7763	>bb8f		07				                .byte %00000111

7765							                ; CHR$114 - r
7766	>bb90		00				                .byte %00000000
7767	>bb91		00				                .byte %00000000
7768	>bb92		6c				                .byte %01101100
7769	>bb93		76				                .byte %01110110
7770	>bb94		60				                .byte %01100000
7771	>bb95		60				                .byte %01100000
7772	>bb96		60				                .byte %01100000
7773	>bb97		00				                .byte %00000000

7775							                ; CHR$115 - s
7776	>bb98		00				                .byte %00000000
7777	>bb99		00				                .byte %00000000
7778	>bb9a		3e				                .byte %00111110
7779	>bb9b		60				                .byte %01100000
7780	>bb9c		3c				                .byte %00111100
7781	>bb9d		06				                .byte %00000110
7782	>bb9e		7c				                .byte %01111100
7783	>bb9f		00				                .byte %00000000

7785							                ; CHR$116 - t
7786	>bba0		30				                .byte %00110000
7787	>bba1		30				                .byte %00110000
7788	>bba2		7c				                .byte %01111100
7789	>bba3		30				                .byte %00110000
7790	>bba4		30				                .byte %00110000
7791	>bba5		30				                .byte %00110000
7792	>bba6		1c				                .byte %00011100
7793	>bba7		00				                .byte %00000000

7795							                ; CHR$117 - u
7796	>bba8		00				                .byte %00000000
7797	>bba9		00				                .byte %00000000
7798	>bbaa		66				                .byte %01100110
7799	>bbab		66				                .byte %01100110
7800	>bbac		66				                .byte %01100110
7801	>bbad		66				                .byte %01100110
7802	>bbae		3e				                .byte %00111110
7803	>bbaf		00				                .byte %00000000

7805							                ; CHR$118 - v
7806	>bbb0		00				                .byte %00000000
7807	>bbb1		00				                .byte %00000000
7808	>bbb2		66				                .byte %01100110
7809	>bbb3		66				                .byte %01100110
7810	>bbb4		66				                .byte %01100110
7811	>bbb5		3c				                .byte %00111100
7812	>bbb6		18				                .byte %00011000
7813	>bbb7		00				                .byte %00000000

7815							                ; CHR$119 - w
7816	>bbb8		00				                .byte %00000000
7817	>bbb9		00				                .byte %00000000
7818	>bbba		63				                .byte %01100011
7819	>bbbb		6b				                .byte %01101011
7820	>bbbc		6b				                .byte %01101011
7821	>bbbd		7f				                .byte %01111111
7822	>bbbe		36				                .byte %00110110
7823	>bbbf		00				                .byte %00000000

7825							                ; CHR$120 - x
7826	>bbc0		00				                .byte %00000000
7827	>bbc1		00				                .byte %00000000
7828	>bbc2		66				                .byte %01100110
7829	>bbc3		3c				                .byte %00111100
7830	>bbc4		18				                .byte %00011000
7831	>bbc5		3c				                .byte %00111100
7832	>bbc6		66				                .byte %01100110
7833	>bbc7		00				                .byte %00000000

7835							                ; CHR$121 - y
7836	>bbc8		00				                .byte %00000000
7837	>bbc9		00				                .byte %00000000
7838	>bbca		66				                .byte %01100110
7839	>bbcb		66				                .byte %01100110
7840	>bbcc		66				                .byte %01100110
7841	>bbcd		3e				                .byte %00111110
7842	>bbce		06				                .byte %00000110
7843	>bbcf		3c				                .byte %00111100

7845							                ; CHR$122 - z
7846	>bbd0		00				                .byte %00000000
7847	>bbd1		00				                .byte %00000000
7848	>bbd2		7e				                .byte %01111110
7849	>bbd3		0c				                .byte %00001100
7850	>bbd4		18				                .byte %00011000
7851	>bbd5		30				                .byte %00110000
7852	>bbd6		7e				                .byte %01111110
7853	>bbd7		00				                .byte %00000000

7855							                ; CHR$123 - {
7856	>bbd8		0c				                .byte %00001100
7857	>bbd9		18				                .byte %00011000
7858	>bbda		18				                .byte %00011000
7859	>bbdb		70				                .byte %01110000
7860	>bbdc		18				                .byte %00011000
7861	>bbdd		18				                .byte %00011000
7862	>bbde		0c				                .byte %00001100
7863	>bbdf		00				                .byte %00000000

7865							                ; CHR$124 - |
7866	>bbe0		18				                .byte %00011000
7867	>bbe1		18				                .byte %00011000
7868	>bbe2		18				                .byte %00011000
7869	>bbe3		00				                .byte %00000000
7870	>bbe4		18				                .byte %00011000
7871	>bbe5		18				                .byte %00011000
7872	>bbe6		18				                .byte %00011000
7873	>bbe7		00				                .byte %00000000

7875							                ; CHR$125 - }
7876	>bbe8		30				                .byte %00110000
7877	>bbe9		18				                .byte %00011000
7878	>bbea		18				                .byte %00011000
7879	>bbeb		0e				                .byte %00001110
7880	>bbec		18				                .byte %00011000
7881	>bbed		18				                .byte %00011000
7882	>bbee		30				                .byte %00110000
7883	>bbef		00				                .byte %00000000

7885							                ; CHR$126 - ~
7886	>bbf0		31				                .byte %00110001
7887	>bbf1		6b				                .byte %01101011
7888	>bbf2		46				                .byte %01000110
7889	>bbf3		00				                .byte %00000000
7890	>bbf4		00				                .byte %00000000
7891	>bbf5		00				                .byte %00000000
7892	>bbf6		00				                .byte %00000000
7893	>bbf7		00				                .byte %00000000

7895							                ; CHR$127
7896	.bbf8						chr127:
7897	>bbf8		ff				                .byte %11111111
7898	>bbf9		ff				                .byte %11111111
7899	>bbfa		ff				                .byte %11111111
7900	>bbfb		ff				                .byte %11111111
7901	>bbfc		ff				                .byte %11111111
7902	>bbfd		ff				                .byte %11111111
7903	>bbfe		ff				                .byte %11111111
7904	>bbff		ff				                .byte %11111111

7906							                ; CHR$128
7907							                .if version==350
7916							                .else
7917	>bc00		66				                .byte %01100110
7918	>bc01		00				                .byte %00000000
7919	>bc02		3c				                .byte %00111100
7920	>bc03		66				                .byte %01100110
7921	>bc04		7e				                .byte %01111110
7922	>bc05		66				                .byte %01100110
7923	>bc06		66				                .byte %01100110
7924	>bc07		00				                .byte %00000000
7925							                .endif

7927							                ; CHR$129
7928							                .if version==350
7937							                .else
7938	>bc08		3c				                .byte %00111100
7939	>bc09		66				                .byte %01100110
7940	>bc0a		3c				                .byte %00111100
7941	>bc0b		66				                .byte %01100110
7942	>bc0c		7e				                .byte %01111110
7943	>bc0d		66				                .byte %01100110
7944	>bc0e		66				                .byte %01100110
7945	>bc0f		00				                .byte %00000000
7946							                .endif

7948							                ; CHR$130
7949	>bc10		3f				                .byte %00111111
7950	>bc11		66				                .byte %01100110
7951	>bc12		66				                .byte %01100110
7952	>bc13		7f				                .byte %01111111
7953	>bc14		66				                .byte %01100110
7954	>bc15		66				                .byte %01100110
7955	>bc16		67				                .byte %01100111
7956	>bc17		00				                .byte %00000000

7958							                ; CHR$131
7959							                .if version==350
7968							                .else
7969	>bc18		3c				                .byte %00111100
7970	>bc19		66				                .byte %01100110
7971	>bc1a		60				                .byte %01100000
7972	>bc1b		60				                .byte %01100000
7973	>bc1c		60				                .byte %01100000
7974	>bc1d		66				                .byte %01100110
7975	>bc1e		3c				                .byte %00111100
7976	>bc1f		60				                .byte %01100000
7977							                .endif

7979							                ; CHR$132
7980	>bc20		0c				                .byte %00001100
7981	>bc21		18				                .byte %00011000
7982	>bc22		7e				                .byte %01111110
7983	>bc23		60				                .byte %01100000
7984	>bc24		7c				                .byte %01111100
7985	>bc25		60				                .byte %01100000
7986	>bc26		7e				                .byte %01111110
7987	>bc27		00				                .byte %00000000

7989							                ; CHR$133
7990							                .if version==350
7999							                .else
8000	>bc28		66				                .byte %01100110
8001	>bc29		3c				                .byte %00111100
8002	>bc2a		66				                .byte %01100110
8003	>bc2b		66				                .byte %01100110
8004	>bc2c		66				                .byte %01100110
8005	>bc2d		66				                .byte %01100110
8006	>bc2e		3c				                .byte %00111100
8007	>bc2f		00				                .byte %00000000
8008							                .endif

8010							                ; CHR$134
8011	>bc30		66				                .byte %01100110
8012	>bc31		00				                .byte %00000000
8013	>bc32		66				                .byte %01100110
8014	>bc33		66				                .byte %01100110
8015	>bc34		66				                .byte %01100110
8016	>bc35		66				                .byte %01100110
8017	>bc36		3c				                .byte %00111100
8018	>bc37		00				                .byte %00000000

8020							                ; CHR$135
8021							                .if version==350
8030							                .else
8031	>bc38		7e				                .byte %01111110
8032	>bc39		c3				                .byte %11000011
8033	>bc3a		9d				                .byte %10011101
8034	>bc3b		b1				                .byte %10110001
8035	>bc3c		9d				                .byte %10011101
8036	>bc3d		c3				                .byte %11000011
8037	>bc3e		7e				                .byte %01111110
8038	>bc3f		00				                .byte %00000000
8039							                .endif

8041							                ; CHR$136
8042	>bc40		00				                .byte %00000000
8043	>bc41		18				                .byte %00011000
8044	>bc42		38				                .byte %00111000
8045	>bc43		7f				                .byte %01111111
8046	>bc44		38				                .byte %00111000
8047	>bc45		18				                .byte %00011000
8048	>bc46		00				                .byte %00000000
8049	>bc47		00				                .byte %00000000

8051							                ; CHR$137
8052	>bc48		00				                .byte %00000000
8053	>bc49		18				                .byte %00011000
8054	>bc4a		1c				                .byte %00011100
8055	>bc4b		fe				                .byte %11111110
8056	>bc4c		1c				                .byte %00011100
8057	>bc4d		18				                .byte %00011000
8058	>bc4e		00				                .byte %00000000
8059	>bc4f		00				                .byte %00000000

8061							                ; CHR$138
8062	>bc50		18				                .byte %00011000
8063	>bc51		18				                .byte %00011000
8064	>bc52		18				                .byte %00011000
8065	>bc53		18				                .byte %00011000
8066	>bc54		7e				                .byte %01111110
8067	>bc55		3c				                .byte %00111100
8068	>bc56		18				                .byte %00011000
8069	>bc57		00				                .byte %00000000

8071							                ; CHR$139
8072	>bc58		00				                .byte %00000000
8073	>bc59		18				                .byte %00011000
8074	>bc5a		3c				                .byte %00111100
8075	>bc5b		7e				                .byte %01111110
8076	>bc5c		18				                .byte %00011000
8077	>bc5d		18				                .byte %00011000
8078	>bc5e		18				                .byte %00011000
8079	>bc5f		18				                .byte %00011000

8081							                ; CHR$140
8082	>bc60		30				                .byte %00110000
8083	>bc61		18				                .byte %00011000
8084	>bc62		3c				                .byte %00111100
8085	>bc63		06				                .byte %00000110
8086	>bc64		3e				                .byte %00111110
8087	>bc65		66				                .byte %01100110
8088	>bc66		3e				                .byte %00111110
8089	>bc67		00				                .byte %00000000

8091							                ; CHR$141
8092	>bc68		30				                .byte %00110000
8093	>bc69		18				                .byte %00011000
8094	>bc6a		3c				                .byte %00111100
8095	>bc6b		66				                .byte %01100110
8096	>bc6c		7e				                .byte %01111110
8097	>bc6d		60				                .byte %01100000
8098	>bc6e		3c				                .byte %00111100
8099	>bc6f		00				                .byte %00000000

8101							                ; CHR$142
8102	>bc70		66				                .byte %01100110
8103	>bc71		00				                .byte %00000000
8104	>bc72		3c				                .byte %00111100
8105	>bc73		66				                .byte %01100110
8106	>bc74		7e				                .byte %01111110
8107	>bc75		60				                .byte %01100000
8108	>bc76		3c				                .byte %00111100
8109	>bc77		00				                .byte %00000000

8111							                ; CHR$143
8112	>bc78		3c				                .byte %00111100
8113	>bc79		66				                .byte %01100110
8114	>bc7a		3c				                .byte %00111100
8115	>bc7b		66				                .byte %01100110
8116	>bc7c		7e				                .byte %01111110
8117	>bc7d		60				                .byte %01100000
8118	>bc7e		3c				                .byte %00111100
8119	>bc7f		00				                .byte %00000000

8121							                ; CHR$144
8122	>bc80		66				                .byte %01100110
8123	>bc81		00				                .byte %00000000
8124	>bc82		3c				                .byte %00111100
8125	>bc83		06				                .byte %00000110
8126	>bc84		3e				                .byte %00111110
8127	>bc85		66				                .byte %01100110
8128	>bc86		3e				                .byte %00111110
8129	>bc87		00				                .byte %00000000

8131							                ; CHR$145
8132	>bc88		3c				                .byte %00111100
8133	>bc89		66				                .byte %01100110
8134	>bc8a		3c				                .byte %00111100
8135	>bc8b		06				                .byte %00000110
8136	>bc8c		3e				                .byte %00111110
8137	>bc8d		66				                .byte %01100110
8138	>bc8e		3e				                .byte %00111110
8139	>bc8f		00				                .byte %00000000

8141							                ; CHR$146
8142	>bc90		00				                .byte %00000000
8143	>bc91		00				                .byte %00000000
8144	>bc92		3f				                .byte %00111111
8145	>bc93		0d				                .byte %00001101
8146	>bc94		3f				                .byte %00111111
8147	>bc95		6c				                .byte %01101100
8148	>bc96		3f				                .byte %00111111
8149	>bc97		00				                .byte %00000000

8151							                ; CHR$147
8152	>bc98		00				                .byte %00000000
8153	>bc99		00				                .byte %00000000
8154	>bc9a		3c				                .byte %00111100
8155	>bc9b		66				                .byte %01100110
8156	>bc9c		60				                .byte %01100000
8157	>bc9d		66				                .byte %01100110
8158	>bc9e		3c				                .byte %00111100
8159	>bc9f		60				                .byte %01100000

8161							                ; CHR$148
8162	>bca0		0c				                .byte %00001100
8163	>bca1		18				                .byte %00011000
8164	>bca2		3c				                .byte %00111100
8165	>bca3		66				                .byte %01100110
8166	>bca4		7e				                .byte %01111110
8167	>bca5		60				                .byte %01100000
8168	>bca6		3c				                .byte %00111100
8169	>bca7		00				                .byte %00000000

8171							                ; CHR$149
8172							                .if version==350
8181							                .else
8182	>bca8		66				                .byte %01100110
8183	>bca9		00				                .byte %00000000
8184	>bcaa		3c				                .byte %00111100
8185	>bcab		66				                .byte %01100110
8186	>bcac		66				                .byte %01100110
8187	>bcad		66				                .byte %01100110
8188	>bcae		3c				                .byte %00111100
8189	>bcaf		00				                .byte %00000000
8190							                .endif

8192							                ; CHR$150
8193							                .if version==350
8202							                .else
8203	>bcb0		66				                .byte %01100110
8204	>bcb1		00				                .byte %00000000
8205	>bcb2		66				                .byte %01100110
8206	>bcb3		66				                .byte %01100110
8207	>bcb4		66				                .byte %01100110
8208	>bcb5		66				                .byte %01100110
8209	>bcb6		3e				                .byte %00111110
8210	>bcb7		00				                .byte %00000000
8211							                .endif

8213							                ; CHR$151
8214	>bcb8		30				                .byte %00110000
8215	>bcb9		18				                .byte %00011000
8216	>bcba		00				                .byte %00000000
8217	>bcbb		38				                .byte %00111000
8218	>bcbc		18				                .byte %00011000
8219	>bcbd		18				                .byte %00011000
8220	>bcbe		3c				                .byte %00111100
8221	>bcbf		00				                .byte %00000000

8223							                ; CHR$152
8224	>bcc0		3c				                .byte %00111100
8225	>bcc1		66				                .byte %01100110
8226	>bcc2		00				                .byte %00000000
8227	>bcc3		38				                .byte %00111000
8228	>bcc4		18				                .byte %00011000
8229	>bcc5		18				                .byte %00011000
8230	>bcc6		3c				                .byte %00111100
8231	>bcc7		00				                .byte %00000000

8233							                ; CHR$153
8234	>bcc8		30				                .byte %00110000
8235	>bcc9		18				                .byte %00011000
8236	>bcca		00				                .byte %00000000
8237	>bccb		3c				                .byte %00111100
8238	>bccc		66				                .byte %01100110
8239	>bccd		66				                .byte %01100110
8240	>bcce		3c				                .byte %00111100
8241	>bccf		00				                .byte %00000000

8243							                ; CHR$154
8244	>bcd0		3c				                .byte %00111100
8245	>bcd1		66				                .byte %01100110
8246	>bcd2		00				                .byte %00000000
8247	>bcd3		3c				                .byte %00111100
8248	>bcd4		66				                .byte %01100110
8249	>bcd5		66				                .byte %01100110
8250	>bcd6		3c				                .byte %00111100
8251	>bcd7		00				                .byte %00000000

8253							                ; CHR$155
8254	>bcd8		30				                .byte %00110000
8255	>bcd9		18				                .byte %00011000
8256	>bcda		00				                .byte %00000000
8257	>bcdb		66				                .byte %01100110
8258	>bcdc		66				                .byte %01100110
8259	>bcdd		66				                .byte %01100110
8260	>bcde		3e				                .byte %00111110
8261	>bcdf		00				                .byte %00000000

8263							                ; CHR$156
8264	>bce0		3c				                .byte %00111100
8265	>bce1		66				                .byte %01100110
8266	>bce2		00				                .byte %00000000
8267	>bce3		66				                .byte %01100110
8268	>bce4		66				                .byte %01100110
8269	>bce5		66				                .byte %01100110
8270	>bce6		3e				                .byte %00111110
8271	>bce7		00				                .byte %00000000

8273							                ; CHR$157
8274	>bce8		66				                .byte %01100110
8275	>bce9		00				                .byte %00000000
8276	>bcea		66				                .byte %01100110
8277	>bceb		66				                .byte %01100110
8278	>bcec		66				                .byte %01100110
8279	>bced		3e				                .byte %00111110
8280	>bcee		06				                .byte %00000110
8281	>bcef		3c				                .byte %00111100

8283							                ; CHR$158
8284	>bcf0		00				                .byte %00000000
8285	>bcf1		66				                .byte %01100110
8286	>bcf2		3c				                .byte %00111100
8287	>bcf3		66				                .byte %01100110
8288	>bcf4		66				                .byte %01100110
8289	>bcf5		3c				                .byte %00111100
8290	>bcf6		66				                .byte %01100110
8291	>bcf7		00				                .byte %00000000

8293							                ; CHR$159
8294	>bcf8		3c				                .byte %00111100
8295	>bcf9		60				                .byte %01100000
8296	>bcfa		3c				                .byte %00111100
8297	>bcfb		66				                .byte %01100110
8298	>bcfc		3c				                .byte %00111100
8299	>bcfd		06				                .byte %00000110
8300	>bcfe		3c				                .byte %00111100
8301	>bcff		00				                .byte %00000000

8303							                ; CHR$160
8304	>bd00		3c				                .byte %00111100
8305	>bd01		66				                .byte %01100110
8306	>bd02		3c				                .byte %00111100
8307	>bd03		00				                .byte %00000000
8308	>bd04		00				                .byte %00000000
8309	>bd05		00				                .byte %00000000
8310	>bd06		00				                .byte %00000000
8311	>bd07		00				                .byte %00000000

8313							                ; CHR$161
8314	>bd08		00				                .byte %00000000
8315	>bd09		00				                .byte %00000000
8316	>bd0a		00				                .byte %00000000
8317	>bd0b		18				                .byte %00011000
8318	>bd0c		18				                .byte %00011000
8319	>bd0d		18				                .byte %00011000
8320	>bd0e		18				                .byte %00011000
8321	>bd0f		18				                .byte %00011000

8323							                ; CHR$162
8324	>bd10		00				                .byte %00000000
8325	>bd11		00				                .byte %00000000
8326	>bd12		00				                .byte %00000000
8327	>bd13		1f				                .byte %00011111
8328	>bd14		00				                .byte %00000000
8329	>bd15		00				                .byte %00000000
8330	>bd16		00				                .byte %00000000
8331	>bd17		00				                .byte %00000000

8333							                ; CHR$163
8334	>bd18		00				                .byte %00000000
8335	>bd19		00				                .byte %00000000
8336	>bd1a		00				                .byte %00000000
8337	>bd1b		1f				                .byte %00011111
8338	>bd1c		18				                .byte %00011000
8339	>bd1d		18				                .byte %00011000
8340	>bd1e		18				                .byte %00011000
8341	>bd1f		18				                .byte %00011000

8343							                ; CHR$164
8344	>bd20		00				                .byte %00000000
8345	>bd21		00				                .byte %00000000
8346	>bd22		00				                .byte %00000000
8347	>bd23		f8				                .byte %11111000
8348	>bd24		00				                .byte %00000000
8349	>bd25		00				                .byte %00000000
8350	>bd26		00				                .byte %00000000
8351	>bd27		00				                .byte %00000000

8353							                ; CHR$165
8354	>bd28		00				                .byte %00000000
8355	>bd29		00				                .byte %00000000
8356	>bd2a		00				                .byte %00000000
8357	>bd2b		f8				                .byte %11111000
8358	>bd2c		18				                .byte %00011000
8359	>bd2d		18				                .byte %00011000
8360	>bd2e		18				                .byte %00011000
8361	>bd2f		18				                .byte %00011000

8363							                ; CHR$166
8364	>bd30		00				                .byte %00000000
8365	>bd31		00				                .byte %00000000
8366	>bd32		00				                .byte %00000000
8367	>bd33		ff				                .byte %11111111
8368	>bd34		00				                .byte %00000000
8369	>bd35		00				                .byte %00000000
8370	>bd36		00				                .byte %00000000
8371	>bd37		00				                .byte %00000000

8373							                ; CHR$167
8374	>bd38		00				                .byte %00000000
8375	>bd39		00				                .byte %00000000
8376	>bd3a		00				                .byte %00000000
8377	>bd3b		ff				                .byte %11111111
8378	>bd3c		18				                .byte %00011000
8379	>bd3d		18				                .byte %00011000
8380	>bd3e		18				                .byte %00011000
8381	>bd3f		18				                .byte %00011000

8383							                ; CHR$168
8384	>bd40		18				                .byte %00011000
8385	>bd41		18				                .byte %00011000
8386	>bd42		18				                .byte %00011000
8387	>bd43		18				                .byte %00011000
8388	>bd44		00				                .byte %00000000
8389	>bd45		00				                .byte %00000000
8390	>bd46		00				                .byte %00000000
8391	>bd47		00				                .byte %00000000

8393							                ; CHR$169
8394	>bd48		18				                .byte %00011000
8395	>bd49		18				                .byte %00011000
8396	>bd4a		18				                .byte %00011000
8397	>bd4b		18				                .byte %00011000
8398	>bd4c		18				                .byte %00011000
8399	>bd4d		18				                .byte %00011000
8400	>bd4e		18				                .byte %00011000
8401	>bd4f		18				                .byte %00011000

8403							                ; CHR$170
8404	>bd50		18				                .byte %00011000
8405	>bd51		18				                .byte %00011000
8406	>bd52		18				                .byte %00011000
8407	>bd53		1f				                .byte %00011111
8408	>bd54		00				                .byte %00000000
8409	>bd55		00				                .byte %00000000
8410	>bd56		00				                .byte %00000000
8411	>bd57		00				                .byte %00000000

8413							                ; CHR$171
8414	>bd58		18				                .byte %00011000
8415	>bd59		18				                .byte %00011000
8416	>bd5a		18				                .byte %00011000
8417	>bd5b		1f				                .byte %00011111
8418	>bd5c		18				                .byte %00011000
8419	>bd5d		18				                .byte %00011000
8420	>bd5e		18				                .byte %00011000
8421	>bd5f		18				                .byte %00011000

8423							                ; CHR$172
8424	>bd60		18				                .byte %00011000
8425	>bd61		18				                .byte %00011000
8426	>bd62		18				                .byte %00011000
8427	>bd63		f8				                .byte %11111000
8428	>bd64		00				                .byte %00000000
8429	>bd65		00				                .byte %00000000
8430	>bd66		00				                .byte %00000000
8431	>bd67		00				                .byte %00000000

8433							                ; CHR$173
8434	>bd68		18				                .byte %00011000
8435	>bd69		18				                .byte %00011000
8436	>bd6a		18				                .byte %00011000
8437	>bd6b		f8				                .byte %11111000
8438	>bd6c		18				                .byte %00011000
8439	>bd6d		18				                .byte %00011000
8440	>bd6e		18				                .byte %00011000
8441	>bd6f		18				                .byte %00011000

8443							                ; CHR$174
8444	>bd70		18				                .byte %00011000
8445	>bd71		18				                .byte %00011000
8446	>bd72		18				                .byte %00011000
8447	>bd73		ff				                .byte %11111111
8448	>bd74		00				                .byte %00000000
8449	>bd75		00				                .byte %00000000
8450	>bd76		00				                .byte %00000000
8451	>bd77		00				                .byte %00000000

8453							                ; CHR$175
8454	>bd78		18				                .byte %00011000
8455	>bd79		18				                .byte %00011000
8456	>bd7a		18				                .byte %00011000
8457	>bd7b		ff				                .byte %11111111
8458	>bd7c		18				                .byte %00011000
8459	>bd7d		18				                .byte %00011000
8460	>bd7e		18				                .byte %00011000
8461	>bd7f		18				                .byte %00011000

8463							                ; CHR$176
8464	>bd80		00				                .byte %00000000
8465	>bd81		00				                .byte %00000000
8466	>bd82		00				                .byte %00000000
8467	>bd83		07				                .byte %00000111
8468	>bd84		0c				                .byte %00001100
8469	>bd85		18				                .byte %00011000
8470	>bd86		18				                .byte %00011000
8471	>bd87		18				                .byte %00011000

8473							                ; CHR$177
8474	>bd88		00				                .byte %00000000
8475	>bd89		00				                .byte %00000000
8476	>bd8a		00				                .byte %00000000
8477	>bd8b		e0				                .byte %11100000
8478	>bd8c		30				                .byte %00110000
8479	>bd8d		18				                .byte %00011000
8480	>bd8e		18				                .byte %00011000
8481	>bd8f		18				                .byte %00011000

8483							                ; CHR$178
8484	>bd90		18				                .byte %00011000
8485	>bd91		18				                .byte %00011000
8486	>bd92		0c				                .byte %00001100
8487	>bd93		07				                .byte %00000111
8488	>bd94		00				                .byte %00000000
8489	>bd95		00				                .byte %00000000
8490	>bd96		00				                .byte %00000000
8491	>bd97		00				                .byte %00000000

8493							                ; CHR$179
8494	>bd98		18				                .byte %00011000
8495	>bd99		18				                .byte %00011000
8496	>bd9a		30				                .byte %00110000
8497	>bd9b		e0				                .byte %11100000
8498	>bd9c		00				                .byte %00000000
8499	>bd9d		00				                .byte %00000000
8500	>bd9e		00				                .byte %00000000
8501	>bd9f		00				                .byte %00000000

8503							                ; CHR$180
8504	>bda0		18				                .byte %00011000
8505	>bda1		00				                .byte %00000000
8506	>bda2		18				                .byte %00011000
8507	>bda3		18				                .byte %00011000
8508	>bda4		30				                .byte %00110000
8509	>bda5		66				                .byte %01100110
8510	>bda6		3c				                .byte %00111100
8511	>bda7		00				                .byte %00000000

8513							                ; CHR$181
8514	>bda8		18				                .byte %00011000
8515	>bda9		00				                .byte %00000000
8516	>bdaa		18				                .byte %00011000
8517	>bdab		18				                .byte %00011000
8518	>bdac		18				                .byte %00011000
8519	>bdad		18				                .byte %00011000
8520	>bdae		18				                .byte %00011000
8521	>bdaf		00				                .byte %00000000

8523							                ; CHR$182
8524	>bdb0		36				                .byte %00110110
8525	>bdb1		6c				                .byte %01101100
8526	>bdb2		00				                .byte %00000000
8527	>bdb3		66				                .byte %01100110
8528	>bdb4		76				                .byte %01110110
8529	>bdb5		6e				                .byte %01101110
8530	>bdb6		66				                .byte %01100110
8531	>bdb7		00				                .byte %00000000

8533							                ; CHR$183
8534	>bdb8		36				                .byte %00110110
8535	>bdb9		6c				                .byte %01101100
8536	>bdba		00				                .byte %00000000
8537	>bdbb		7c				                .byte %01111100
8538	>bdbc		66				                .byte %01100110
8539	>bdbd		66				                .byte %01100110
8540	>bdbe		66				                .byte %01100110
8541	>bdbf		00				                .byte %00000000

8543							                ; CHR$184
8544	>bdc0		18				                .byte %00011000
8545	>bdc1		7e				                .byte %01111110
8546	>bdc2		18				                .byte %00011000
8547	>bdc3		18				                .byte %00011000
8548	>bdc4		18				                .byte %00011000
8549	>bdc5		18				                .byte %00011000
8550	>bdc6		18				                .byte %00011000
8551	>bdc7		00				                .byte %00000000

8553							                ; CHR$185
8554	>bdc8		18				                .byte %00011000
8555	>bdc9		7e				                .byte %01111110
8556	>bdca		18				                .byte %00011000
8557	>bdcb		18				                .byte %00011000
8558	>bdcc		18				                .byte %00011000
8559	>bdcd		7e				                .byte %01111110
8560	>bdce		18				                .byte %00011000
8561	>bdcf		00				                .byte %00000000

8563							                ; CHR$186
8564							                .if version==350
8573							                .else
8574	>bdd0		18				                .byte %00011000
8575	>bdd1		18				                .byte %00011000
8576	>bdd2		18				                .byte %00011000
8577	>bdd3		00				                .byte %00000000
8578	>bdd4		00				                .byte %00000000
8579	>bdd5		00				                .byte %00000000
8580	>bdd6		00				                .byte %00000000
8581	>bdd7		00				                .byte %00000000
8582							                .endif

8584							                ; CHR$187
8585							                .if version==350
8594							                .else
8595	>bdd8		30				                .byte %00110000
8596	>bdd9		18				                .byte %00011000
8597	>bdda		0c				                .byte %00001100
8598	>bddb		00				                .byte %00000000
8599	>bddc		00				                .byte %00000000
8600	>bddd		00				                .byte %00000000
8601	>bdde		00				                .byte %00000000
8602	>bddf		00				                .byte %00000000
8603							                .endif

8605							                ; CHR$188
8606							                .if version==350
8615							                .else
8616	>bde0		3f				                .byte %00111111
8617	>bde1		7b				                .byte %01111011
8618	>bde2		7b				                .byte %01111011
8619	>bde3		3b				                .byte %00111011
8620	>bde4		1b				                .byte %00011011
8621	>bde5		1b				                .byte %00011011
8622	>bde6		1f				                .byte %00011111
8623	>bde7		00				                .byte %00000000
8624							                .endif

8626							                ; CHR$189
8627	>bde8		00				                .byte %00000000
8628	>bde9		00				                .byte %00000000
8629	>bdea		00				                .byte %00000000
8630	>bdeb		18				                .byte %00011000
8631	>bdec		18				                .byte %00011000
8632	>bded		00				                .byte %00000000
8633	>bdee		00				                .byte %00000000
8634	>bdef		00				                .byte %00000000

8636							                ; CHR$190
8637	>bdf0		03				                .byte %00000011
8638	>bdf1		03				                .byte %00000011
8639	>bdf2		06				                .byte %00000110
8640	>bdf3		06				                .byte %00000110
8641	>bdf4		76				                .byte %01110110
8642	>bdf5		1c				                .byte %00011100
8643	>bdf6		0c				                .byte %00001100
8644	>bdf7		00				                .byte %00000000

8646							                ; CHR$191
8647	>bdf8		aa				                .byte %10101010
8648	>bdf9		55				                .byte %01010101
8649	>bdfa		aa				                .byte %10101010
8650	>bdfb		55				                .byte %01010101
8651	>bdfc		aa				                .byte %10101010
8652	>bdfd		55				                .byte %01010101
8653	>bdfe		aa				                .byte %10101010
8654	>bdff		55				                .byte %01010101

8656							                ; CHR$192
8657	>be00		3e				                .byte %00111110
8658	>be01		63				                .byte %01100011
8659	>be02		67				                .byte %01100111
8660	>be03		6b				                .byte %01101011
8661	>be04		73				                .byte %01110011
8662	>be05		63				                .byte %01100011
8663	>be06		3e				                .byte %00111110
8664	>be07		00				                .byte %00000000

8666							                ; CHR$193
8667	>be08		1c				                .byte %00011100
8668	>be09		36				                .byte %00110110
8669	>be0a		63				                .byte %01100011
8670	>be0b		63				                .byte %01100011
8671	>be0c		7f				                .byte %01111111
8672	>be0d		63				                .byte %01100011
8673	>be0e		63				                .byte %01100011
8674	>be0f		00				                .byte %00000000

8676							                ; CHR$194
8677	>be10		7e				                .byte %01111110
8678	>be11		33				                .byte %00110011
8679	>be12		33				                .byte %00110011
8680	>be13		3e				                .byte %00111110
8681	>be14		33				                .byte %00110011
8682	>be15		33				                .byte %00110011
8683	>be16		7e				                .byte %01111110
8684	>be17		00				                .byte %00000000

8686							                ; CHR$195
8687	>be18		7f				                .byte %01111111
8688	>be19		63				                .byte %01100011
8689	>be1a		60				                .byte %01100000
8690	>be1b		60				                .byte %01100000
8691	>be1c		60				                .byte %01100000
8692	>be1d		60				                .byte %01100000
8693	>be1e		60				                .byte %01100000
8694	>be1f		00				                .byte %00000000

8696							                ; CHR$196
8697	>be20		1c				                .byte %00011100
8698	>be21		1c				                .byte %00011100
8699	>be22		36				                .byte %00110110
8700	>be23		36				                .byte %00110110
8701	>be24		63				                .byte %01100011
8702	>be25		63				                .byte %01100011
8703	>be26		7f				                .byte %01111111
8704	>be27		00				                .byte %00000000

8706							                ; CHR$197
8707	>be28		7f				                .byte %01111111
8708	>be29		33				                .byte %00110011
8709	>be2a		30				                .byte %00110000
8710	>be2b		3e				                .byte %00111110
8711	>be2c		30				                .byte %00110000
8712	>be2d		33				                .byte %00110011
8713	>be2e		7f				                .byte %01111111
8714	>be2f		00				                .byte %00000000

8716							                ; CHR$198
8717	>be30		7e				                .byte %01111110
8718	>be31		66				                .byte %01100110
8719	>be32		0c				                .byte %00001100
8720	>be33		18				                .byte %00011000
8721	>be34		30				                .byte %00110000
8722	>be35		66				                .byte %01100110
8723	>be36		7e				                .byte %01111110
8724	>be37		00				                .byte %00000000

8726							                ; CHR$199
8727	>be38		77				                .byte %01110111
8728	>be39		33				                .byte %00110011
8729	>be3a		33				                .byte %00110011
8730	>be3b		3f				                .byte %00111111
8731	>be3c		33				                .byte %00110011
8732	>be3d		33				                .byte %00110011
8733	>be3e		77				                .byte %01110111
8734	>be3f		00				                .byte %00000000

8736							                ; CHR$200
8737	>be40		3e				                .byte %00111110
8738	>be41		63				                .byte %01100011
8739	>be42		63				                .byte %01100011
8740	>be43		7f				                .byte %01111111
8741	>be44		63				                .byte %01100011
8742	>be45		63				                .byte %01100011
8743	>be46		3e				                .byte %00111110
8744	>be47		00				                .byte %00000000

8746							                ; CHR$201
8747	>be48		3c				                .byte %00111100
8748	>be49		18				                .byte %00011000
8749	>be4a		18				                .byte %00011000
8750	>be4b		18				                .byte %00011000
8751	>be4c		18				                .byte %00011000
8752	>be4d		18				                .byte %00011000
8753	>be4e		3c				                .byte %00111100
8754	>be4f		00				                .byte %00000000

8756							                ; CHR$202
8757	>be50		63				                .byte %01100011
8758	>be51		66				                .byte %01100110
8759	>be52		6c				                .byte %01101100
8760	>be53		78				                .byte %01111000
8761	>be54		6c				                .byte %01101100
8762	>be55		66				                .byte %01100110
8763	>be56		63				                .byte %01100011
8764	>be57		00				                .byte %00000000

8766							                ; CHR$203
8767	>be58		1c				                .byte %00011100
8768	>be59		1c				                .byte %00011100
8769	>be5a		36				                .byte %00110110
8770	>be5b		36				                .byte %00110110
8771	>be5c		63				                .byte %01100011
8772	>be5d		63				                .byte %01100011
8773	>be5e		63				                .byte %01100011
8774	>be5f		00				                .byte %00000000

8776							                ; CHR$204
8777	>be60		63				                .byte %01100011
8778	>be61		77				                .byte %01110111
8779	>be62		7f				                .byte %01111111
8780	>be63		6b				                .byte %01101011
8781	>be64		63				                .byte %01100011
8782	>be65		63				                .byte %01100011
8783	>be66		63				                .byte %01100011
8784	>be67		00				                .byte %00000000

8786							                ; CHR$205
8787	>be68		63				                .byte %01100011
8788	>be69		73				                .byte %01110011
8789	>be6a		7b				                .byte %01111011
8790	>be6b		6f				                .byte %01101111
8791	>be6c		67				                .byte %01100111
8792	>be6d		63				                .byte %01100011
8793	>be6e		63				                .byte %01100011
8794	>be6f		00				                .byte %00000000

8796							                ; CHR$206
8797	>be70		7e				                .byte %01111110
8798	>be71		00				                .byte %00000000
8799	>be72		00				                .byte %00000000
8800	>be73		3c				                .byte %00111100
8801	>be74		00				                .byte %00000000
8802	>be75		00				                .byte %00000000
8803	>be76		7e				                .byte %01111110
8804	>be77		00				                .byte %00000000

8806							                ; CHR$207
8807	>be78		3e				                .byte %00111110
8808	>be79		63				                .byte %01100011
8809	>be7a		63				                .byte %01100011
8810	>be7b		63				                .byte %01100011
8811	>be7c		63				                .byte %01100011
8812	>be7d		63				                .byte %01100011
8813	>be7e		3e				                .byte %00111110
8814	>be7f		00				                .byte %00000000

8816							                ; CHR$208
8817	>be80		7f				                .byte %01111111
8818	>be81		36				                .byte %00110110
8819	>be82		36				                .byte %00110110
8820	>be83		36				                .byte %00110110
8821	>be84		36				                .byte %00110110
8822	>be85		36				                .byte %00110110
8823	>be86		36				                .byte %00110110
8824	>be87		00				                .byte %00000000

8826							                ; CHR$209
8827	>be88		7e				                .byte %01111110
8828	>be89		33				                .byte %00110011
8829	>be8a		33				                .byte %00110011
8830	>be8b		3e				                .byte %00111110
8831	>be8c		30				                .byte %00110000
8832	>be8d		30				                .byte %00110000
8833	>be8e		78				                .byte %01111000
8834	>be8f		00				                .byte %00000000

8836							                ; CHR$210
8837	>be90		7f				                .byte %01111111
8838	>be91		63				                .byte %01100011
8839	>be92		30				                .byte %00110000
8840	>be93		18				                .byte %00011000
8841	>be94		30				                .byte %00110000
8842	>be95		63				                .byte %01100011
8843	>be96		7f				                .byte %01111111
8844	>be97		00				                .byte %00000000

8846							                ; CHR$211
8847	>be98		7e				                .byte %01111110
8848	>be99		5a				                .byte %01011010
8849	>be9a		18				                .byte %00011000
8850	>be9b		18				                .byte %00011000
8851	>be9c		18				                .byte %00011000
8852	>be9d		18				                .byte %00011000
8853	>be9e		18				                .byte %00011000
8854	>be9f		00				                .byte %00000000

8856							                ; CHR$212
8857	>bea0		66				                .byte %01100110
8858	>bea1		66				                .byte %01100110
8859	>bea2		66				                .byte %01100110
8860	>bea3		3c				                .byte %00111100
8861	>bea4		18				                .byte %00011000
8862	>bea5		18				                .byte %00011000
8863	>bea6		3c				                .byte %00111100
8864	>bea7		00				                .byte %00000000

8866							                ; CHR$213
8867	>bea8		3e				                .byte %00111110
8868	>bea9		08				                .byte %00001000
8869	>beaa		3e				                .byte %00111110
8870	>beab		6b				                .byte %01101011
8871	>beac		3e				                .byte %00111110
8872	>bead		08				                .byte %00001000
8873	>beae		3e				                .byte %00111110
8874	>beaf		00				                .byte %00000000

8876							                ; CHR$214
8877	>beb0		63				                .byte %01100011
8878	>beb1		63				                .byte %01100011
8879	>beb2		36				                .byte %00110110
8880	>beb3		1c				                .byte %00011100
8881	>beb4		36				                .byte %00110110
8882	>beb5		63				                .byte %01100011
8883	>beb6		63				                .byte %01100011
8884	>beb7		00				                .byte %00000000

8886							                ; CHR$215
8887	>beb8		3e				                .byte %00111110
8888	>beb9		08				                .byte %00001000
8889	>beba		6b				                .byte %01101011
8890	>bebb		6b				                .byte %01101011
8891	>bebc		3e				                .byte %00111110
8892	>bebd		08				                .byte %00001000
8893	>bebe		3e				                .byte %00111110
8894	>bebf		00				                .byte %00000000

8896							                ; CHR$216
8897	>bec0		3e				                .byte %00111110
8898	>bec1		63				                .byte %01100011
8899	>bec2		63				                .byte %01100011
8900	>bec3		63				                .byte %01100011
8901	>bec4		36				                .byte %00110110
8902	>bec5		36				                .byte %00110110
8903	>bec6		63				                .byte %01100011
8904	>bec7		00				                .byte %00000000

8906							                ; CHR$217
8907	>bec8		7f				                .byte %01111111
8908	>bec9		63				                .byte %01100011
8909	>beca		63				                .byte %01100011
8910	>becb		36				                .byte %00110110
8911	>becc		36				                .byte %00110110
8912	>becd		1c				                .byte %00011100
8913	>bece		1c				                .byte %00011100
8914	>becf		00				                .byte %00000000

8916							                ; CHR$218
8917	>bed0		18				                .byte %00011000
8918	>bed1		18				                .byte %00011000
8919	>bed2		7e				                .byte %01111110
8920	>bed3		18				                .byte %00011000
8921	>bed4		18				                .byte %00011000
8922	>bed5		00				                .byte %00000000
8923	>bed6		7e				                .byte %01111110
8924	>bed7		00				                .byte %00000000

8926							                ; CHR$219
8927	>bed8		00				                .byte %00000000
8928	>bed9		7e				                .byte %01111110
8929	>beda		00				                .byte %00000000
8930	>bedb		18				                .byte %00011000
8931	>bedc		18				                .byte %00011000
8932	>bedd		7e				                .byte %01111110
8933	>bede		18				                .byte %00011000
8934	>bedf		18				                .byte %00011000

8936							                ; CHR$220
8937	>bee0		18				                .byte %00011000
8938	>bee1		18				                .byte %00011000
8939	>bee2		18				                .byte %00011000
8940	>bee3		18				                .byte %00011000
8941	>bee4		18				                .byte %00011000
8942	>bee5		18				                .byte %00011000
8943	>bee6		18				                .byte %00011000
8944	>bee7		00				                .byte %00000000

8946							                ; CHR$221
8947	>bee8		36				                .byte %00110110
8948	>bee9		36				                .byte %00110110
8949	>beea		36				                .byte %00110110
8950	>beeb		36				                .byte %00110110
8951	>beec		36				                .byte %00110110
8952	>beed		36				                .byte %00110110
8953	>beee		36				                .byte %00110110
8954	>beef		00				                .byte %00000000

8956							                ; CHR$222
8957	>bef0		00				                .byte %00000000
8958	>bef1		66				                .byte %01100110
8959	>bef2		66				                .byte %01100110
8960	>bef3		66				                .byte %01100110
8961	>bef4		66				                .byte %01100110
8962	>bef5		66				                .byte %01100110
8963	>bef6		3c				                .byte %00111100
8964	>bef7		00				                .byte %00000000

8966							                ; CHR$223
8967	>bef8		00				                .byte %00000000
8968	>bef9		3c				                .byte %00111100
8969	>befa		66				                .byte %01100110
8970	>befb		66				                .byte %01100110
8971	>befc		66				                .byte %01100110
8972	>befd		66				                .byte %01100110
8973	>befe		66				                .byte %01100110
8974	>beff		00				                .byte %00000000

8976							                ; CHR$224
8977							                .if version==350
8986							                .else
8987	>bf00		00				                .byte %00000000
8988	>bf01		03				                .byte %00000011
8989	>bf02		3e				                .byte %00111110
8990	>bf03		67				                .byte %01100111
8991	>bf04		6b				                .byte %01101011
8992	>bf05		73				                .byte %01110011
8993	>bf06		3e				                .byte %00111110
8994	>bf07		60				                .byte %01100000
8995							                .endif

8997							                ; CHR$225
8998	>bf08		00				                .byte %00000000
8999	>bf09		00				                .byte %00000000
9000	>bf0a		3b				                .byte %00111011
9001	>bf0b		6e				                .byte %01101110
9002	>bf0c		66				                .byte %01100110
9003	>bf0d		6e				                .byte %01101110
9004	>bf0e		3b				                .byte %00111011
9005	>bf0f		00				                .byte %00000000

9007							                ; CHR$226
9008	>bf10		1e				                .byte %00011110
9009	>bf11		33				                .byte %00110011
9010	>bf12		33				                .byte %00110011
9011	>bf13		3e				                .byte %00111110
9012	>bf14		33				                .byte %00110011
9013	>bf15		33				                .byte %00110011
9014	>bf16		3e				                .byte %00111110
9015	>bf17		60				                .byte %01100000

9017							                ; CHR$227
9018	>bf18		00				                .byte %00000000
9019	>bf19		00				                .byte %00000000
9020	>bf1a		66				                .byte %01100110
9021	>bf1b		36				                .byte %00110110
9022	>bf1c		1c				                .byte %00011100
9023	>bf1d		18				                .byte %00011000
9024	>bf1e		30				                .byte %00110000
9025	>bf1f		30				                .byte %00110000

9027							                ; CHR$228
9028	>bf20		3c				                .byte %00111100
9029	>bf21		60				                .byte %01100000
9030	>bf22		30				                .byte %00110000
9031	>bf23		3c				                .byte %00111100
9032	>bf24		66				                .byte %01100110
9033	>bf25		66				                .byte %01100110
9034	>bf26		3c				                .byte %00111100
9035	>bf27		00				                .byte %00000000

9037							                ; CHR$229
9038	>bf28		00				                .byte %00000000
9039	>bf29		00				                .byte %00000000
9040	>bf2a		1e				                .byte %00011110
9041	>bf2b		30				                .byte %00110000
9042	>bf2c		1c				                .byte %00011100
9043	>bf2d		30				                .byte %00110000
9044	>bf2e		1e				                .byte %00011110
9045	>bf2f		00				                .byte %00000000

9047							                ; CHR$230
9048	>bf30		3e				                .byte %00111110
9049	>bf31		0c				                .byte %00001100
9050	>bf32		18				                .byte %00011000
9051	>bf33		30				                .byte %00110000
9052	>bf34		60				                .byte %01100000
9053	>bf35		60				                .byte %01100000
9054	>bf36		3e				                .byte %00111110
9055	>bf37		06				                .byte %00000110

9057							                ; CHR$231
9058	>bf38		00				                .byte %00000000
9059	>bf39		00				                .byte %00000000
9060	>bf3a		7c				                .byte %01111100
9061	>bf3b		66				                .byte %01100110
9062	>bf3c		66				                .byte %01100110
9063	>bf3d		66				                .byte %01100110
9064	>bf3e		06				                .byte %00000110
9065	>bf3f		06				                .byte %00000110

9067							                ; CHR$232
9068	>bf40		3c				                .byte %00111100
9069	>bf41		66				                .byte %01100110
9070	>bf42		66				                .byte %01100110
9071	>bf43		7e				                .byte %01111110
9072	>bf44		66				                .byte %01100110
9073	>bf45		66				                .byte %01100110
9074	>bf46		3c				                .byte %00111100
9075	>bf47		00				                .byte %00000000

9077							                ; CHR$233
9078	>bf48		00				                .byte %00000000
9079	>bf49		00				                .byte %00000000
9080	>bf4a		18				                .byte %00011000
9081	>bf4b		18				                .byte %00011000
9082	>bf4c		18				                .byte %00011000
9083	>bf4d		18				                .byte %00011000
9084	>bf4e		0c				                .byte %00001100
9085	>bf4f		00				                .byte %00000000

9087							                ; CHR$234
9088	>bf50		00				                .byte %00000000
9089	>bf51		00				                .byte %00000000
9090	>bf52		66				                .byte %01100110
9091	>bf53		6c				                .byte %01101100
9092	>bf54		78				                .byte %01111000
9093	>bf55		6c				                .byte %01101100
9094	>bf56		66				                .byte %01100110
9095	>bf57		00				                .byte %00000000

9097							                ; CHR$235
9098	>bf58		60				                .byte %01100000
9099	>bf59		30				                .byte %00110000
9100	>bf5a		18				                .byte %00011000
9101	>bf5b		1c				                .byte %00011100
9102	>bf5c		36				                .byte %00110110
9103	>bf5d		63				                .byte %01100011
9104	>bf5e		63				                .byte %01100011
9105	>bf5f		00				                .byte %00000000

9107							                ; CHR$236
9108	>bf60		00				                .byte %00000000
9109	>bf61		00				                .byte %00000000
9110	>bf62		33				                .byte %00110011
9111	>bf63		33				                .byte %00110011
9112	>bf64		33				                .byte %00110011
9113	>bf65		33				                .byte %00110011
9114	>bf66		3e				                .byte %00111110
9115	>bf67		60				                .byte %01100000

9117							                ; CHR$237
9118	>bf68		00				                .byte %00000000
9119	>bf69		00				                .byte %00000000
9120	>bf6a		63				                .byte %01100011
9121	>bf6b		33				                .byte %00110011
9122	>bf6c		1b				                .byte %00011011
9123	>bf6d		1e				                .byte %00011110
9124	>bf6e		1c				                .byte %00011100
9125	>bf6f		00				                .byte %00000000

9127							                ; CHR$238
9128							                .if version==350
9137							                .else
9138	>bf70		3c				                .byte %00111100
9139	>bf71		60				                .byte %01100000
9140	>bf72		60				                .byte %01100000
9141	>bf73		3c				                .byte %00111100
9142	>bf74		60				                .byte %01100000
9143	>bf75		60				                .byte %01100000
9144	>bf76		3e				                .byte %00111110
9145	>bf77		06				                .byte %00000110
9146							                .endif

9148							                ; CHR$239
9149	>bf78		00				                .byte %00000000
9150	>bf79		00				                .byte %00000000
9151	>bf7a		3e				                .byte %00111110
9152	>bf7b		63				                .byte %01100011
9153	>bf7c		63				                .byte %01100011
9154	>bf7d		63				                .byte %01100011
9155	>bf7e		3e				                .byte %00111110
9156	>bf7f		00				                .byte %00000000

9158							                ; CHR$240
9159	>bf80		00				                .byte %00000000
9160	>bf81		00				                .byte %00000000
9161	>bf82		7f				                .byte %01111111
9162	>bf83		36				                .byte %00110110
9163	>bf84		36				                .byte %00110110
9164	>bf85		36				                .byte %00110110
9165	>bf86		36				                .byte %00110110
9166	>bf87		00				                .byte %00000000

9168							                ; CHR$241
9169	>bf88		00				                .byte %00000000
9170	>bf89		00				                .byte %00000000
9171	>bf8a		3c				                .byte %00111100
9172	>bf8b		66				                .byte %01100110
9173	>bf8c		66				                .byte %01100110
9174	>bf8d		7c				                .byte %01111100
9175	>bf8e		60				                .byte %01100000
9176	>bf8f		60				                .byte %01100000

9178							                ; CHR$242
9179	>bf90		00				                .byte %00000000
9180	>bf91		00				                .byte %00000000
9181	>bf92		3f				                .byte %00111111
9182	>bf93		66				                .byte %01100110
9183	>bf94		66				                .byte %01100110
9184	>bf95		66				                .byte %01100110
9185	>bf96		3c				                .byte %00111100
9186	>bf97		00				                .byte %00000000

9188							                ; CHR$243
9189	>bf98		00				                .byte %00000000
9190	>bf99		00				                .byte %00000000
9191	>bf9a		7e				                .byte %01111110
9192	>bf9b		18				                .byte %00011000
9193	>bf9c		18				                .byte %00011000
9194	>bf9d		18				                .byte %00011000
9195	>bf9e		0c				                .byte %00001100
9196	>bf9f		00				                .byte %00000000

9198							                ; CHR$244
9199	>bfa0		00				                .byte %00000000
9200	>bfa1		00				                .byte %00000000
9201	>bfa2		73				                .byte %01110011
9202	>bfa3		33				                .byte %00110011
9203	>bfa4		33				                .byte %00110011
9204	>bfa5		33				                .byte %00110011
9205	>bfa6		1e				                .byte %00011110
9206	>bfa7		00				                .byte %00000000

9208							                ; CHR$245
9209	>bfa8		00				                .byte %00000000
9210	>bfa9		00				                .byte %00000000
9211	>bfaa		3e				                .byte %00111110
9212	>bfab		6b				                .byte %01101011
9213	>bfac		6b				                .byte %01101011
9214	>bfad		3e				                .byte %00111110
9215	>bfae		18				                .byte %00011000
9216	>bfaf		18				                .byte %00011000

9218							                ; CHR$246
9219	>bfb0		00				                .byte %00000000
9220	>bfb1		00				                .byte %00000000
9221	>bfb2		66				                .byte %01100110
9222	>bfb3		36				                .byte %00110110
9223	>bfb4		1c				                .byte %00011100
9224	>bfb5		1c				                .byte %00011100
9225	>bfb6		36				                .byte %00110110
9226	>bfb7		33				                .byte %00110011

9228							                ; CHR$247
9229	>bfb8		00				                .byte %00000000
9230	>bfb9		00				                .byte %00000000
9231	>bfba		63				                .byte %01100011
9232	>bfbb		6b				                .byte %01101011
9233	>bfbc		6b				                .byte %01101011
9234	>bfbd		3e				                .byte %00111110
9235	>bfbe		18				                .byte %00011000
9236	>bfbf		18				                .byte %00011000

9238							                ; CHR$248
9239							                .if version==350
9248							                .else
9249	>bfc0		00				                .byte %00000000
9250	>bfc1		00				                .byte %00000000
9251	>bfc2		36				                .byte %00110110
9252	>bfc3		63				                .byte %01100011
9253	>bfc4		6b				                .byte %01101011
9254	>bfc5		7f				                .byte %01111111
9255	>bfc6		36				                .byte %00110110
9256	>bfc7		00				                .byte %00000000
9257							                .endif

9259							                ; CHR$249
9260	>bfc8		38				                .byte %00111000
9261	>bfc9		0c				                .byte %00001100
9262	>bfca		06				                .byte %00000110
9263	>bfcb		3e				                .byte %00111110
9264	>bfcc		66				                .byte %01100110
9265	>bfcd		66				                .byte %01100110
9266	>bfce		3c				                .byte %00111100
9267	>bfcf		00				                .byte %00000000

9269							                ; CHR$250
9270	>bfd0		00				                .byte %00000000
9271	>bfd1		31				                .byte %00110001
9272	>bfd2		6b				                .byte %01101011
9273	>bfd3		46				                .byte %01000110
9274	>bfd4		00				                .byte %00000000
9275	>bfd5		7f				                .byte %01111111
9276	>bfd6		00				                .byte %00000000
9277	>bfd7		00				                .byte %00000000

9279							                ; CHR$251
9280	>bfd8		00				                .byte %00000000
9281	>bfd9		7e				                .byte %01111110
9282	>bfda		00				                .byte %00000000
9283	>bfdb		7e				                .byte %01111110
9284	>bfdc		00				                .byte %00000000
9285	>bfdd		7e				                .byte %01111110
9286	>bfde		00				                .byte %00000000
9287	>bfdf		00				                .byte %00000000

9289							                ; CHR$252
9290	>bfe0		07				                .byte %00000111
9291	>bfe1		1c				                .byte %00011100
9292	>bfe2		70				                .byte %01110000
9293	>bfe3		1c				                .byte %00011100
9294	>bfe4		07				                .byte %00000111
9295	>bfe5		00				                .byte %00000000
9296	>bfe6		7f				                .byte %01111111
9297	>bfe7		00				                .byte %00000000

9299							                ; CHR$253
9300	>bfe8		06				                .byte %00000110
9301	>bfe9		0c				                .byte %00001100
9302	>bfea		7e				                .byte %01111110
9303	>bfeb		18				                .byte %00011000
9304	>bfec		7e				                .byte %01111110
9305	>bfed		30				                .byte %00110000
9306	>bfee		60				                .byte %01100000
9307	>bfef		00				                .byte %00000000

9309							                ; CHR$254
9310	>bff0		70				                .byte %01110000
9311	>bff1		1c				                .byte %00011100
9312	>bff2		07				                .byte %00000111
9313	>bff3		1c				                .byte %00011100
9314	>bff4		70				                .byte %01110000
9315	>bff5		00				                .byte %00000000
9316	>bff6		7f				                .byte %01111111
9317	>bff7		00				                .byte %00000000

9319							                ; CHR$255
9320	>bff8		ff				                .byte %11111111
9321	>bff9		ff				                .byte %11111111
9322	>bffa		ff				                .byte %11111111
9323	>bffb		ff				                .byte %11111111
9324	>bffc		ff				                .byte %11111111
9325	>bffd		ff				                .byte %11111111
9326	>bffe		ff				                .byte %11111111
9327	>bfff		ff				                .byte %11111111


:1	;******  Return to file: mos400.s65

32							                .endsection

34							                .section mos
35							                .include "src/mos.s65"

:12	;******  Processing file: src/mos.s65

1							; -*- comment-column:45; -*-

3							; VDU driver entry block
4							; ======================
5	.c000						LC000:                                       ; Read from VDU memory
6	.c000		b1 d6		lda ($d6),y	                lda (ZMEMG),y
7	.c002		60		rts		                rts
8	.c003						LC003:                                       ; Write to VDU memory
9	.c003		91 d6		sta ($d6),y	                sta (ZMEMG),y
10	.c005		60		rts		                rts

12							; MasRef E.4-6
13							;
14							; JSR PLBYTE plots the mask held in ZMASK into the byte pointed to by
15							; (ZMEMG),y, using ZGORA and ZGEOR as colour masks. See GADDR below
16							; for an example of its use.
17							;
18							; PLBYTE uses ZTEMP as workspace and preserves X, Y, V and C.
19	.c006						PLBYTE:
20	.c006		4c 4f db	jmp $db4f	                jmp plbyteEntryPoint

22							; MasRef E.4-6
23							;
24							; JSR HPLOT plots a fast horizontal line in the current graphics
25							; colour or ECF and the current graphics mode (all as set by VDU 18)
26							; between two specified points. It is the low level primitive used by
27							; all the MOS area fill commands.
28							;
29							; On entry, two 4 byte areas at &300+X and &300+Y contain the
30							; coordinates of the two endpoints, in the standard
31							; lowX,highX,lowY,highY order. Should the Y coordinates differ, the Y
32							; coordinate of the line plotted is taken from the leftmost of the two
33							; points specified.
34							;
35							; Only portions of the line inside the graphics window are plotted.
36							; Subject to this, both endpoints of the line are plotted.
37							;
38							; HPLOT uses ZGORA, ZGEOR, ZMASK, ZMEMG, ZTEMP (but not ZTEMP+1),
39							; ZTEMPB, ZTEMPB+1, ZTEMPC and ZTEMPC+1 as workspace. No registers or
40							; flags are preserved.
41	.c009						HPLOT:
42	.c009		4c e6 da	jmp $dae6	                jmp LDAE8

44							; MasRef E.4-6
45							;
46							; JSR EIGABS converts the 4 byte pair of external coordinates at
47							; &300+X where X>=2 (in standard lowX,highX,lowY,highY order) into the
48							; corresponding pair of pixel coordinates by offsetting by the
49							; graphics origin, then dividing by an appropriate power of 2.
50							;
51							; EIGABS uses ZTEMP as workspace, and corrupts all registers and
52							; flags.
53	.c00c						EIGABS:
54	.c00c		4c dc d1	jmp $d1dc	                jmp eigabsEntryPoint

56							; MasRef E.4-7
57							;
58							; JSR WIND windows the 4 byte pair of pixel coordinates (in standard
59							; lowX,highX,lowY,highY order) at &300+X, and returns a result in A
60							; according to its position with respect to the window:

62							; 9 | 8 | 10
63							; --+---+---
64							; 1 | 0 | 2
65							; --+---+---
66							; 5 | 4 | 6

68							; WIND uses ZTEMP as workspace, preserves X and sets N and Z according
69							; to A.
70	.c00f						WIND:
71	.c00f		4c a6 d1	jmp $d1a6	                jmp windEntryPoint

73							; MasRef E.4-7
74							;
75							; JSR GADDR addresses the pixel whose 4 byte pair of pixel coordinates
76							; (in standard lowX,highX,lowY,highY order) is at &300+X. GADDR should
77							; not be called without first ensuring (typically by means of WIND)
78							; that the point concerned does lie within the screen.
79							;
80							; GADDR initialises the following variables:
81							;
82							; . ZMEMG to the start of the page of memory containing the pixel.
83							;
84							; . Y and VDU variable &1A (i.e. location &31A) to contain the offset
85							; of the byte containing the pixel within this page - i.e. (ZMEMG),y
86							; points to the byte containing the pixel.
87							;
88							; . ZMASK to a mask indicating which bits of this byte constitute the
89							; pixel.
90							;
91							; . ZGORA and ZGEOR to the correct colour masks for the current
92							; graphics plot mode (found in VDU variable &5A) and colour/ECF
93							;
94							; . X to Y MOD 7, i.e. the scan line within a character row of the
95							; pixel.
96							;
97							; Additionally, GADDR uses ZTEMP as workspace and returns A=0, Z=1.
98							;
99							; An example of the use of PLBYTE, WIND and GADDR is the following
100							; code, which effectively re-implements the VDU 25 64-71 (plot a
101							; point) calls. It assumes that the routine addresses have been
102							; previously defined and that the graphics plot mode, etc. were set up
103							; by the VDU 25 code before the unknown PLOT codes vector was entered:

105							; .POINT
106							;  LDX #&20   ;Addresses new point within VDU queue, as
107							;             ;left on entry to the unknown PLOT codes
108							;             ;vector.
109							;  JSR WIND   ;Is the point inside the window?
110							;  BNE END    ;Return if not.
111							;  JSR GADDR  ;Address the point now we know it's on
112							;             ;screen.
113							;  JSR PLBYTE ;And plot the point.
114							; .END
115							;  RTS
116	.c012						GADDR:
117	.c012		4c c6 de	jmp $dec6	                jmp gaddrEntryPoint

119							; MasRef E.4-8
120							;
121							; JSR IEG takes the internal pixel coordinates of the graphics cursor
122							; (in VDU variables &24-&27), converts it back to external coordinates
123							; and stores the result in VDU variables &10-&13.
124							;
125							; It should be called whenever the graphics code generates a new
126							; graphics cursor position (e.g. in the VDU drivers, it is called
127							; after a character is printed in VDU 5 mode). Its purpose is to make
128							; the two versions of the graphics cursor agree again, and thus
129							; prevent errors occurring with relative plots.
130							;
131							; IEG uses no page zero locations and corrupts all registers and
132							; flags.
133	.c015						IEG:
134	.c015		4c df c4	jmp $c4df	                jmp LC4DF

136							;-------------------------------------------------------------------------

138	.c018						LC018:                                       ; Fetch byte from ROM Y
139	.c018		a6 f4		ldx $f4		                ldx $F4                      ; Get current ROM
140	.c01a		84 f4		sty $f4		                sty $F4                      ; Select ROM in Y
141	.c01c		8c 30 fe	sty $fe30	                sty ROMSEL
142	.c01f		b2 f6		lda ($f6)	                lda ($F6)                    ; Get byte with ROM Y paged in
143	.c021		4c 8e e5	jmp $e58e	                jmp selectROMX                    ; Page in ROM X and return

145	.c024						LC024:
146	.c024		6c 5d 03	jmp ($035d)	                jmp ($035D)

148							;-------------------------------------------------------------------------
149							;
150							; VDU driver entry point
151							;
152							; Output to VDU.
153							;
154	.c027						outputToVDU:
155	.c027		ae 6a 02	ldx $026a	                ldx vduQueueNegativeLength  ;get VDU queue length
156	.c02a		f0 2d		beq $c059	                beq outputCharToVDU         ;taken if empty
157	.c02c		9d 24 02	sta $0224,x	                sta vduv.queueEnd-1-255,x   ;add to queue
158	.c02f		ee 6a 02	inc $026a	                inc vduQueueNegativeLength  ;one more in the queue...
159	.c032		f0 02		beq $c036	                beq outputQueueToVDU        ;taken if queue now filled
160	.c034						clc_rts_c034:
161	.c034		18		clc		                clc

163							;-------------------------------------------------------------------------
164							;
165							; VDU 0 (&00) Null [MasRef E.3-1]
166							; VDU 6 (&06) Enable VDU driver [MasRef E.3-3]
167							; VDU 27 (&1B) Null [MasRef E.3-34]
168							;
169	.c035						vdu0EntryPoint:
170	.c035						vdu6EntryPoint:
171	.c035						vdu27EntryPoint:
172	.c035						rtsC035:
173	.c035		60		rts		                rts

175							;-------------------------------------------------------------------------

177	.c036						outputQueueToVDU:
178	.c036		24 d0		bit $d0		                bit STATE
179	.c038		10 19		bpl $c053	                bpl LC053              ;branch taken if not VDU21 mode

181							                ; ????
182	.c03a		ac 5e 03	ldy $035e	                ldy vduv.jumpVector+1
183	.c03d		c0 c0		cpy #$c0	                cpy #>vdu1EntryPoint
184	.c03f		d0 f3		bne $c034	                bne clc_rts_c034
185	.c041		ac 5d 03	ldy $035d	                ldy vduv.jumpVector+0
186	.c044		c0 e2		cpy #$e2	                cpy #<vdu1EntryPoint
187	.c046		d0 ec		bne $c034	                bne clc_rts_c034

189	.c048						outputCharToPrinter:
190	.c048		aa		tax		                tax                          ;save char to print
191	.c049		a5 d0		lda $d0		                lda STATE
192	.c04b		4a		lsr a		                lsr a                       ;C set if isPrinterEnabled
193	.c04c		90 e7		bcc $c035	                bcc rtsC035 ;taken if printer disabled - VDU 1 then a no-op
194	.c04e		8a		txa		                txa                          ;restore char to print
195	.c04f		18		clc		                clc
196							                .if version<350
198							                .else
199	.c050		4c db e2	jmp $e2db	                jmp LE2ED
200							                .endif

202	.c053						LC053:
203	.c053		20 fa c0	jsr $c0fa	                jsr stopCursorEditing
204	.c056		18		clc		                clc
205	.c057		80 67		bra $c0c0	                bra LC0C0

207	.c059						outputCharToVDU:
208	.c059		20 fa c0	jsr $c0fa	                jsr stopCursorEditing
209	.c05c		50 0f		bvc $c06d	                bvc LC06D             ;taken if not previously editing
210	.c05e		30 0d		bmi $c06d	                bmi LC06D             ;taken if VDU 21
211	.c060		c9 0d		cmp #$0d	                cmp #$0D
212	.c062		d0 09		bne $c06d	                bne LC06D                  ;taken if not printing a CR
213	.c064		48		pha		                pha                        ;save char to print
214	.c065		a9 42		lda #$42	                lda #STATE.isCursorEditing|STATE.isScrollingDisabled
215	.c067		14 d0		trb $d0		                trb STATE
216	.c069		20 4e cf	jsr $cf4e	                jsr showCursor
217	.c06c		68		pla		                pla                          ;restore char to print
218	.c06d						LC06D:
219	.c06d		c9 20		cmp #$20	                cmp #$20
220	.c06f		90 06		bcc $c077	                bcc handleControlChar
221	.c071		c9 7f		cmp #$7f	                cmp #$7F
222	.c073		d0 21		bne $c096	                bne LC096                    ;taken if not backspace
223	.c075		a9 20		lda #$20	                lda #$20 ;backspace is entry 32 in the VDU routines table
224	.c077						handleControlChar:
225	.c077		a8		tay		                tay                          ;Y=index in table
226	.c078		b9 25 e0	lda $e025,y	                lda vduRoutinesLSBTable,y
227	.c07b		8d 5d 03	sta $035d	                sta vduv.jumpVector+0 ; Store jump address LSB (see MasRef E.4-3)
228	.c07e		b9 46 e0	lda $e046,y	                lda vduRoutinesMSBTable,y
229	.c081		30 30		bmi $c0b3	                bmi LC0B3           ;branch taken if MSB directly
230	.c083		aa		tax		                tax                          ; Save original MSB value
231	.c084		09 f0		ora #$f0	                ora #$F0
232	.c086		8d 6a 02	sta $026a	                sta vduQueueNegativeLength ;initialise initial VDU queue length
233	.c089		8a		txa		                txa                          ; Restore original MSB value
234							                .if version==350
236							                .else
237	.c08a		4a		lsr a		                lsr a                        ;
238	.c08b		4a		lsr a		                lsr a                        ;
239	.c08c		4a		lsr a		                lsr a                        ;
240	.c08d		4a		lsr a		                lsr a                        ; Extract value in top 4 bits
241							                .endif
242	.c08e		18		clc		                clc                          ;
243	.c08f		69 c0		adc #$c0	                adc #vduRoutinesPage         ; form MSB
244	.c091		8d 5e 03	sta $035e	                sta vduv.jumpVector+1
245	.c094		80 34		bra $c0ca	                bra reinstateCursorEditing                    ; Continue

247	.c096						LC096:
248	.c096		24 d0		bit $d0		                bit STATE
249	.c098		30 2d		bmi $c0c7	                bmi LC0C7                    ;taken if VDU21
250	.c09a		20 0a ce	jsr $ce0a	                jsr LCE0C
251	.c09d		a9 20		lda #$20	                lda #$20
252	.c09f		2c 66 03	bit $0366	                bit $0366
253	.c0a2		d0 23		bne $c0c7	                bne LC0C7
254	.c0a4		20 76 c2	jsr $c276	                jsr LC276
255	.c0a7		80 1e		bra $c0c7	                bra LC0C7

257	.c0a9						LC0A9:
258	.c0a9		49 06		eor #$06	                eor #$06
259	.c0ab		d0 18		bne $c0c5	                bne LC0C5
260	.c0ad		a9 80		lda #$80	                lda #STATE.isVDU21
261	.c0af		14 d0		trb $d0		                trb STATE
262	.c0b1		80 17		bra $c0ca	                bra reinstateCursorEditing

264	.c0b3						LC0B3:
265	.c0b3		8d 5e 03	sta $035e	                sta vduv.jumpVector+1
266	.c0b6		98		tya		                tya
267	.c0b7		49 f7		eor #$f7	                eor #$F7
268	.c0b9		c9 fa		cmp #$fa	                cmp #$FA
269	.c0bb		98		tya		                tya
270	.c0bc		24 d0		bit $d0		                bit STATE
271	.c0be		30 e9		bmi $c0a9	                bmi LC0A9             ;branch taken if VDU21 in effect
272	.c0c0						LC0C0:
273	.c0c0		08		php		                php
274	.c0c1		20 24 c0	jsr $c024	                jsr LC024
275	.c0c4		28		plp		                plp
276	.c0c5						LC0C5:
277	.c0c5		90 03		bcc $c0ca	                bcc reinstateCursorEditing
278	.c0c7						LC0C7:
279	.c0c7		a5 d0		lda $d0		                lda STATE
280	.c0c9		4a		lsr a		                lsr a                          ;C=1 if printer enabled
281	.c0ca						reinstateCursorEditing:
282	.c0ca		24 d0		bit $d0		                bit STATE
283	.c0cc		50 13		bvc $c0e1	                bvc rtsC0E1               ;taken if not cursor editing
284	.c0ce		20 05 c1	jsr $c105	                jsr activateEditCursor
285	.c0d1						exchangeCursors:
286	.c0d1		08		php		                php
287	.c0d2		48		pha		                pha
288	.c0d3		a5 d0		lda $d0		                lda STATE
289	.c0d5		49 02		eor #$02	                eor #STATE.isScrollingDisabled
290	.c0d7		85 d0		sta $d0		                sta STATE
291	.c0d9		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
292	.c0dc		20 d8 c6	jsr $c6d8	                jsr updateCRTCTextCursor
293	.c0df		68		pla		                pla
294	.c0e0		28		plp		                plp
295	.c0e1						rtsC0E1:
296	.c0e1		60		rts		                rts

298							;-------------------------------------------------------------------------
299							;
300							; VDU 1 (&01) Send next character to printer only [MasRef E.3-2]
301							;
302	.c0e2						vdu1EntryPoint:
303	.c0e2		20 ca c0	jsr $c0ca	                jsr reinstateCursorEditing
304	.c0e5		20 48 c0	jsr $c048	                jsr outputCharToPrinter
305	.c0e8		80 10		bra $c0fa	                bra stopCursorEditing

307							;-------------------------------------------------------------------------
308							;
309							; VDU 2 (&02) Enable printer [MasRef E.3-2]
310							; VDU 3 (&03) Disable printer [MasRef E.3-3]
311							;
312	.c0ea						vdu2EntryPoint:
313	.c0ea						vdu3EntryPoint:
314	.c0ea		48		pha		                pha                          ;
315	.c0eb		20 ca c0	jsr $c0ca	                jsr reinstateCursorEditing
316							                .if version<350
318							                .else
319	.c0ee		20 d5 e2	jsr $e2d5	                jsr LE2E7
320							                .endif
321	.c0f1		a9 01		lda #$01	                lda #STATE.isPrinterEnabled  ;
322	.c0f3		04 d0		tsb $d0		                tsb STATE
323	.c0f5		68		pla		                pla
324	.c0f6		29 01		and #$01	                and #STATE.isPrinterEnabled
325	.c0f8		14 d0		trb $d0		                trb STATE

327							;-------------------------------------------------------------------------
328							;
329							; Stop cursor editing, if it's on.
330							;
331							; exit:
332							;
333							; V=1 if cursor editing previous on
334							; N=1 if VDU 21 on
335							;
336	.c0fa						stopCursorEditing:
337	.c0fa		24 d0		bit $d0		                bit STATE
338	.c0fc		50 e3		bvc $c0e1	                bvc rtsC0E1                    ;taken if not cursor editing
339	.c0fe		20 d1 c0	jsr $c0d1	                jsr exchangeCursors
340	.c101		08		php		                php
341	.c102						deactivateEditCursor:
342	.c102		38		sec		                sec
343	.c103		80 02		bra $c107	                bra updateEditCursorState

345							;-------------------------------------------------------------------------

347	.c105						activateEditCursor:
348	.c105		08		php		                php
349	.c106		18		clc		                clc

351							;-------------------------------------------------------------------------
352							;
353							; Handle cursor editing on/off.
354							;
355							; entry:
356							;
357							; C=0 - cursor editing on; add fake cursor
358							;
359							; C=1 = cursor editing off; remove fake cursor and restore screen
360							;
361	.c107						updateEditCursorState: .proc
362	.c107		48		pha		                pha
363	.c108		a5 d8		lda $d8		                lda ZMEMT+0
364	.c10a		85 e0		sta $e0		                sta ZTEMPD+0
365	.c10c		a5 d9		lda $d9		                lda ZMEMT+1
366	.c10e		85 e1		sta $e1		                sta ZTEMPD+1
367	.c110		ac 4f 03	ldy $034f	                ldy vduv.bytesPerCharacter
368	.c113		88		dey		                dey
369	.c114		d0 0e		bne $c124	                bne bitmap

371	.c116						teletext:
372	.c116		ad 38 03	lda $0338	                lda vduv.workspace._38 ;get old byte under fake cursor (may be bogus)
373	.c119		b0 17		bcs $c132	                bcs storeToScreen      ;taken if switching off
374	.c11b		b2 d8		lda ($d8)	                lda (ZMEMT)            ;get screen byte
375	.c11d		8d 38 03	sta $0338	                sta vduv.workspace._38 ;store old byte
376	.c120		a9 7f		lda #$7f	                lda #$7F               ;store solid block to screen
377	.c122		80 0e		bra $c132	                bra storeToScreen

379	.c124						bitmap:
380	.c124		a9 ff		lda #$ff	                lda #%11111111          ;invert all bits
381	.c126		c0 1f		cpy #$1f	                cpy #$1F      ;check for 32 chars/byte - i.e., MODE 2
382	.c128		d0 02		bne $c12c	                bne +         ;taken if not MODE 2
383	.c12a		a9 3f		lda #$3f	                lda #%00111111       ;avoid flashing colours in MODE 2
384	.c12c						+
385	.c12c		85 da		sta $da		                sta ZTEMP
386	.c12e						loop:
387	.c12e		b2 e0		lda ($e0)	                lda (ZTEMPD)
388	.c130		45 da		eor $da		                eor ZTEMP
389	.c132						storeToScreen:
390	.c132		92 e0		sta ($e0)	                sta (ZTEMPD)
391	.c134		e6 e0		inc $e0		                inc ZTEMPD+0
392	.c136		d0 09		bne $c141	                bne +                    ;taken if no carry out of LSB
393	.c138		e6 e1		inc $e1		                inc ZTEMPD+1
394	.c13a		10 05		bpl $c141	                bpl +                 ;taken if no screen address wrap
395	.c13c		ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
396	.c13f		85 e1		sta $e1		                sta ZTEMPD+1
397	.c141						+
398	.c141		88		dey		                dey               ;Y=$ff after 1 iteration in teletext
399	.c142		10 ea		bpl $c12e	                bpl loop
400	.c144		68		pla		                pla
401	.c145		28		plp		                plp
402	.c146		60		rts		                rts
403							                .endproc

405							;-------------------------------------------------------------------------

407	.c147						LC147:
408	>c147		be c1				                .word LC1BE
409	>c149		b1 c1				                .word LC1B1
410	>c14b		be c1				                .word LC1BE
411	>c14d		b1 c1				                .word LC1B1
412	>c14f		95 c1				                .word LC195
413	>c151		95 c1				                .word LC195
414	>c153		a2 c1				                .word LC1A2
415	>c155		a2 c1				                .word LC1A2

417							;-------------------------------------------------------------------------

419	.c157						LC157:
420	>c157		01 c2				                .word LC201
421	>c159		ee c1				                .word LC1EE
422	>c15b		01 c2				                .word LC201
423	>c15d		ee c1				                .word LC1EE
424	>c15f		21 c2				                .word LC221
425	>c161		21 c2				                .word LC221
426	>c163		10 c2				                .word LC210
427	>c165		10 c2				                .word LC210

429							;-------------------------------------------------------------------------
430							;
431							; Indexed by the swapAxes, invertVertical and invertHorizontal cursor
432							; flags bits.
433							;
434	.c167						setTextCursorXPositionRoutinesTable:
435	>c167		d3 c2				                .word setTextCursorXPosition           ;0
436	>c169		cb c2				                .word setTextCursorXPositionInvertHorizontal ;invertHorizontal
437	>c16b		d3 c2				                .word setTextCursorXPosition ;invertVertical
438	>c16d		cb c2				                .word setTextCursorXPositionInvertHorizontal ;invertVertical|invertHorizontal
439	>c16f		e2 c2				                .word setTextCursorXPositionSwapAxes         ;swapAxes
440	>c171		e2 c2				                .word setTextCursorXPositionSwapAxes ;swapAxes|invertHorizontal
441	>c173		da c2				                .word setTextCursorXPositionSwapAxesInvertVertical ;swapAxes|invertVertical
442	>c175		da c2				                .word setTextCursorXPositionSwapAxesInvertVertical ;swapAxes|invertVertical|invertHorizontal

444							;-------------------------------------------------------------------------

446	.c177						LC177:
447	>c177		10 c3				                .word LC310
448	>c179		f2 c2				                .word LC2F2
449	>c17b		10 c3				                .word LC310
450	>c17d		f2 c2				                .word LC2F2
451	>c17f		5a c3				                .word LC35A
452	>c181		5a c3				                .word LC35A
453	>c183		38 c3				                .word LC338
454	>c185		38 c3				                .word LC338

456							;-------------------------------------------------------------------------

458	.c187						LC187:
459	.c187		4d 66 03	eor $0366	                eor $0366
460	.c18a		29 0e		and #$0e	                and #$0E
461	.c18c		48		pha		                pha
462	.c18d		20 a4 d1	jsr $d1a4	                jsr LD1A6
463	.c190		fa		plx		                plx
464	.c191		38		sec		                sec
465	.c192		7c 47 c1	jmp ($c147,x)	                jmp (LC147,x)

467	.c195						LC195:
468	.c195		ad 26 03	lda $0326	                lda $0326
469	.c198		e9 08		sbc #$08	                sbc #$08
470	.c19a		8d 26 03	sta $0326	                sta $0326
471	.c19d		ce 27 03	dec $0327	                dec $0327
472	.c1a0		80 08		bra $c1aa	                bra LC1AA

474	.c1a2						LC1A2:
475	.c1a2		ad 26 03	lda $0326	                lda $0326
476	.c1a5		69 07		adc #$07	                adc #$07
477	.c1a7		8d 26 03	sta $0326	                sta $0326
478	.c1aa						LC1AA:
479	.c1aa		90 1f		bcc $c1cb	                bcc LC1CB
480	.c1ac		ee 27 03	inc $0327	                inc $0327
481	.c1af		80 1a		bra $c1cb	                bra LC1CB

483	.c1b1						LC1B1:
484	.c1b1		ad 24 03	lda $0324	                lda $0324
485	.c1b4		e9 08		sbc #$08	                sbc #$08
486	.c1b6		8d 24 03	sta $0324	                sta $0324
487	.c1b9		ce 25 03	dec $0325	                dec $0325
488	.c1bc		80 08		bra $c1c6	                bra LC1C6

490	.c1be						LC1BE:
491	.c1be		ad 24 03	lda $0324	                lda $0324
492	.c1c1		69 07		adc #$07	                adc #$07
493	.c1c3		8d 24 03	sta $0324	                sta $0324
494	.c1c6						LC1C6:
495	.c1c6		90 03		bcc $c1cb	                bcc LC1CB
496	.c1c8		ee 25 03	inc $0325	                inc $0325
497	.c1cb						LC1CB:
498	.c1cb		a5 da		lda $da		                lda $DA
499	.c1cd		d0 0c		bne $c1db	                bne LC1DB
500	.c1cf		2c 66 03	bit $0366	                bit $0366
501	.c1d2		70 07		bvs $c1db	                bvs LC1DB
502	.c1d4		da		phx		                phx
503	.c1d5		20 a4 d1	jsr $d1a4	                jsr LD1A6
504	.c1d8		fa		plx		                plx
505	.c1d9		a8		tay		                tay
506	.c1da		60		rts		                rts

508	.c1db						LC1DB:
509	.c1db		a9 00		lda #$00	                lda #$00
510	.c1dd		60		rts		                rts

512	.c1de						LC1DE:
513	.c1de		a9 00		lda #$00	                lda #$00
514	.c1e0						LC1E0:
515	.c1e0		64 da		stz $da		                stz $DA
516	.c1e2		0a		asl a		                asl a
517	.c1e3		26 da		rol $da		                rol $DA
518	.c1e5		0a		asl a		                asl a
519	.c1e6		26 da		rol $da		                rol $DA
520	.c1e8		0a		asl a		                asl a
521	.c1e9		26 da		rol $da		                rol $DA
522	.c1eb		7c 57 c1	jmp ($c157,x)	                jmp (LC157,x)

524	.c1ee						LC1EE:
525	.c1ee		49 f9		eor #$f9	                eor #$F9
526	.c1f0		6d 04 03	adc $0304	                adc $0304
527	.c1f3		8d 24 03	sta $0324	                sta $0324
528	.c1f6		a5 da		lda $da		                lda $DA
529	.c1f8		49 ff		eor #$ff	                eor #$FF
530	.c1fa		6d 05 03	adc $0305	                adc $0305
531	.c1fd		8d 25 03	sta $0325	                sta $0325
532	.c200		60		rts		                rts

534	.c201						LC201:
535	.c201		6d 00 03	adc $0300	                adc $0300
536	.c204		8d 24 03	sta $0324	                sta $0324
537	.c207		a5 da		lda $da		                lda $DA
538	.c209		6d 01 03	adc $0301	                adc $0301
539	.c20c		8d 25 03	sta $0325	                sta $0325
540	.c20f		60		rts		                rts

542	.c210						LC210:
543	.c210		49 07		eor #$07	                eor #$07
544	.c212		6d 02 03	adc $0302	                adc $0302
545	.c215		8d 26 03	sta $0326	                sta $0326
546	.c218		a5 da		lda $da		                lda $DA
547	.c21a		6d 03 03	adc $0303	                adc $0303
548	.c21d		8d 27 03	sta $0327	                sta $0327
549	.c220		60		rts		                rts

551	.c221						LC221:
552	.c221		38		sec		                sec
553	.c222		49 ff		eor #$ff	                eor #$FF
554	.c224		6d 06 03	adc $0306	                adc $0306
555	.c227		8d 26 03	sta $0326	                sta $0326
556	.c22a		a5 da		lda $da		                lda $DA
557	.c22c		49 ff		eor #$ff	                eor #$FF
558	.c22e		6d 07 03	adc $0307	                adc $0307
559	.c231		8d 27 03	sta $0327	                sta $0327
560	.c234		60		rts		                rts

562	.c235						LC235:
563	.c235		a9 00		lda #$00	                lda #$00
564	.c237		20 87 c1	jsr $c187	                jsr LC187
565	.c23a		f0 0d		beq $c249	                beq LC249
566	.c23c		20 de c1	jsr $c1de	                jsr LC1DE
567	.c23f						LC23F:
568	.c23f		a9 08		lda #$08	                lda #$08
569	.c241						LC241:
570	.c241		20 87 c1	jsr $c187	                jsr LC187
571	.c244		f0 03		beq $c249	                beq LC249
572	.c246		20 de c1	jsr $c1de	                jsr LC1DE
573	.c249						LC249:
574	.c249		4c df c4	jmp $c4df	                jmp LC4DF

576	.c24c						vdu9EntryPoint:
577	.c24c		20 2b d1	jsr $d12b	                jsr handleColumn81
578	.c24f		b0 e4		bcs $c235	                bcs LC235
579	.c251		a9 00		lda #$00	                lda #$00
580	.c253		20 e9 c2	jsr $c2e9	                jsr LC2E9
581	.c256		90 1b		bcc $c273	                bcc LC273
582	.c258						LC258:
583	.c258		20 8f c3	jsr $c38f	                jsr LC38F
584	.c25b						vdu10EntryPoint:
585	.c25b		20 d0 e2	jsr $e2d0	                jsr testVDU5State
586	.c25e		d0 df		bne $c23f	                bne LC23F
587	.c260		18		clc		                clc
588	.c261		20 8e c8	jsr $c88e	                jsr LC88E
589	.c264		a9 08		lda #$08	                lda #$08
590	.c266		20 e9 c2	jsr $c2e9	                jsr LC2E9
591	.c269						LC269:
592	.c269		90 08		bcc $c273	                bcc LC273
593	.c26b		20 7b c3	jsr $c37b	                jsr LC37B
594	.c26e		90 03		bcc $c273	                bcc LC273
595	.c270		4c 4f d0	jmp $d04f	                jmp LD051

597	.c273						LC273:
598	.c273		4c ed c6	jmp $c6ed	                jmp updateCRTCCursorAddress

600	.c276						LC276:
601	.c276		20 d0 e2	jsr $e2d0	                jsr testVDU5State
602	.c279		d0 ba		bne $c235	                bne LC235
603	.c27b		20 e9 c2	jsr $c2e9	                jsr LC2E9
604	.c27e		90 f3		bcc $c273	                bcc LC273
605	.c280		a9 01		lda #$01	                lda #$01
606	.c282		2c 66 03	bit $0366	                bit $0366
607	.c285		f0 d1		beq $c258	                beq LC258
608	.c287		38		sec		                sec
609	.c288		6e 6c 03	ror $036c	                ror $036C
610	.c28b						LC28B:
611	.c28b		60		rts		                rts

613	.c28c						LC28C:
614	.c28c		a9 06		lda #$06	                lda #$06
615	.c28e		20 87 c1	jsr $c187	                jsr LC187
616	.c291		f0 b6		beq $c249	                beq LC249
617	.c293		20 de c1	jsr $c1de	                jsr LC1DE
618	.c296						LC296:
619	.c296		a9 0e		lda #$0e	                lda #$0E
620	.c298		80 a7		bra $c241	                bra LC241

622	.c29a						vdu8EntryPoint:
623	.c29a		20 d0 e2	jsr $e2d0	                jsr testVDU5State
624	.c29d		d0 ed		bne $c28c	                bne LC28C
625	.c29f		4e 6c 03	lsr $036c	                lsr $036C
626	.c2a2		2c 6c 03	bit $036c	                bit $036C
627	.c2a5		70 e4		bvs $c28b	                bvs LC28B
628	.c2a7		a9 06		lda #$06	                lda #$06
629	.c2a9		20 e9 c2	jsr $c2e9	                jsr LC2E9
630	.c2ac		90 c5		bcc $c273	                bcc LC273
631	.c2ae		20 8f c3	jsr $c38f	                jsr LC38F
632	.c2b1						vdu11EntryPoint:
633	.c2b1		20 d0 e2	jsr $e2d0	                jsr testVDU5State
634	.c2b4		d0 e0		bne $c296	                bne LC296
635	.c2b6		ce 69 02	dec $0269	                dec pagedModeCounter
636	.c2b9		10 03		bpl $c2be	                bpl LC2BE
637	.c2bb		ee 69 02	inc $0269	                inc pagedModeCounter
638	.c2be						LC2BE:
639	.c2be		a9 0e		lda #$0e	                lda #$0E
640	.c2c0		20 e9 c2	jsr $c2e9	                jsr LC2E9
641	.c2c3		80 a4		bra $c269	                bra LC269

643							;-------------------------------------------------------------------------
644							;
645							; Set/reset cursor position, taking cursor flags into account.
646							;
647							; entry:
648							;
649							; (set only) A = cursor position
650							;
651							; X = cursorFlags bits: swapAxes, invertVertical, invertHorizontal
652							;
653	.c2c5						resetTextCursorXPositionWithCursorFlags:
654	.c2c5		a9 00		lda #$00	                lda #$00
655	.c2c7						setTextCursorXPositionWithCursorFlags:
656	.c2c7		18		clc		                clc
657	.c2c8		7c 67 c1	jmp ($c167,x)	                jmp (setTextCursorXPositionRoutinesTable,x)

659							;-------------------------------------------------------------------------

661	.c2cb						setTextCursorXPositionInvertHorizontal:
662	.c2cb		38		sec		                sec                          ;+1
663	.c2cc		49 ff		eor #$ff	                eor #$FF          ;^$ff+1 (i.e., adc will add the -ve)
664	.c2ce		6d 0a 03	adc $030a	                adc vduv.textWindowRight
665	.c2d1		80 03		bra $c2d6	                bra staTextCursorXPosition

667							;-------------------------------------------------------------------------

669	.c2d3						setTextCursorXPosition:
670	.c2d3		6d 08 03	adc $0308	                adc vduv.textWindowLeft
671	.c2d6						staTextCursorXPosition:
672	.c2d6		8d 18 03	sta $0318	                sta vduv.textCursorXPosition
673	.c2d9		60		rts		                rts

675							;-------------------------------------------------------------------------

677	.c2da						setTextCursorXPositionSwapAxesInvertVertical:
678	.c2da		38		sec		                sec
679	.c2db		49 ff		eor #$ff	                eor #$FF
680	.c2dd		6d 09 03	adc $0309	                adc vduv.textWindowBottom
681	.c2e0		80 03		bra $c2e5	                bra staTextCursorYPosition

683	.c2e2						setTextCursorXPositionSwapAxes:
684	.c2e2		6d 0b 03	adc $030b	                adc vduv.textWindowTop
685	.c2e5						staTextCursorYPosition:
686	.c2e5		8d 19 03	sta $0319	                sta vduv.textCursorYPosition
687	.c2e8		60		rts		                rts

689							;-------------------------------------------------------------------------

691	.c2e9						LC2E9:
692	.c2e9		4d 66 03	eor $0366	                eor $0366
693	.c2ec		29 0e		and #$0e	                and #$0E
694	.c2ee		aa		tax		                tax
695	.c2ef						LC2EF:
696	.c2ef		7c 77 c1	jmp ($c177,x)	                jmp (LC177,x)

698	.c2f2						LC2F2:
699	.c2f2		ad 08 03	lda $0308	                lda $0308
700	.c2f5		cd 18 03	cmp $0318	                cmp $0318
701	.c2f8		b0 3d		bcs $c337	                bcs LC337
702	.c2fa		ce 18 03	dec $0318	                dec $0318
703	.c2fd		38		sec		                sec
704	.c2fe		ad 4a 03	lda $034a	                lda $034A
705	.c301		ed 4f 03	sbc $034f	                sbc $034F
706	.c304		8d 4a 03	sta $034a	                sta $034A
707	.c307		85 d8		sta $d8		                sta ZMEMT+0
708	.c309		b0 2b		bcs $c336	                bcs LC336
709	.c30b		ce 4b 03	dec $034b	                dec $034B
710	.c30e		80 1b		bra $c32b	                bra LC32B

712	.c310						LC310:
713	.c310		ad 18 03	lda $0318	                lda $0318
714	.c313		cd 0a 03	cmp $030a	                cmp $030A
715	.c316		b0 1f		bcs $c337	                bcs LC337
716	.c318		ee 18 03	inc $0318	                inc $0318
717	.c31b		ad 4a 03	lda $034a	                lda $034A
718	.c31e		6d 4f 03	adc $034f	                adc $034F
719	.c321		8d 4a 03	sta $034a	                sta $034A
720	.c324		85 d8		sta $d8		                sta ZMEMT+0
721	.c326		90 0f		bcc $c337	                bcc LC337
722	.c328		ee 4b 03	inc $034b	                inc $034B
723	.c32b						LC32B:
724	.c32b		ad 4b 03	lda $034b	                lda $034B
725	.c32e						LC32E:
726	.c32e		10 04		bpl $c334	                bpl LC334
727	.c330		38		sec		                sec
728	.c331		ed 54 03	sbc $0354	                sbc $0354
729	.c334						LC334:
730	.c334		85 d9		sta $d9		                sta ZMEMT+1
731	.c336						LC336:
732	.c336		18		clc		                clc
733	.c337						LC337:
734	.c337		60		rts		                rts

736	.c338						LC338:
737	.c338		ad 0b 03	lda $030b	                lda $030B
738	.c33b		cd 19 03	cmp $0319	                cmp $0319
739	.c33e		b0 f7		bcs $c337	                bcs LC337
740	.c340		ce 19 03	dec $0319	                dec $0319
741	.c343		38		sec		                sec
742	.c344		ad 4a 03	lda $034a	                lda $034A
743	.c347		ed 52 03	sbc $0352	                sbc $0352
744	.c34a		8d 4a 03	sta $034a	                sta $034A
745	.c34d		85 d8		sta $d8		                sta ZMEMT+0
746	.c34f		ad 4b 03	lda $034b	                lda $034B
747	.c352		ed 53 03	sbc $0353	                sbc $0353
748	.c355		8d 4b 03	sta $034b	                sta $034B
749	.c358		80 d4		bra $c32e	                bra LC32E

751	.c35a						LC35A:
752	.c35a		ad 19 03	lda $0319	                lda $0319
753	.c35d		cd 09 03	cmp $0309	                cmp $0309
754	.c360		b0 d5		bcs $c337	                bcs LC337
755	.c362		ee 19 03	inc $0319	                inc $0319
756	.c365		ad 4a 03	lda $034a	                lda $034A
757	.c368		6d 52 03	adc $0352	                adc $0352
758	.c36b		8d 4a 03	sta $034a	                sta $034A
759	.c36e		85 d8		sta $d8		                sta ZMEMT+0
760	.c370		ad 4b 03	lda $034b	                lda $034B
761	.c373		6d 53 03	adc $0353	                adc $0353
762	.c376		8d 4b 03	sta $034b	                sta $034B
763	.c379		80 b3		bra $c32e	                bra LC32E

765	.c37b						LC37B:
766	.c37b		a9 10		lda #$10	                lda #$10
767	.c37d		2c 66 03	bit $0366	                bit $0366
768	.c380		d0 0d		bne $c38f	                bne LC38F
769	.c382		8a		txa		                txa
770	.c383		49 06		eor #$06	                eor #$06
771	.c385		48		pha		                pha
772	.c386		a9 42		lda #$42	                lda #$42
773	.c388		24 d0		bit $d0		                bit STATE
774	.c38a		f0 16		beq $c3a2	                beq LC3A2
775	.c38c		70 09		bvs $c397	                bvs LC397
776	.c38e		68		pla		                pla
777	.c38f						LC38F:
778	.c38f		20 c5 c2	jsr $c2c5	                jsr resetTextCursorXPositionWithCursorFlags
779	.c392		20 f8 cc	jsr $ccf8	                jsr updateZMEMTWithTextCursorPosition
780	.c395		18		clc		                clc
781	.c396		60		rts		                rts

783	.c397						LC397:
784	.c397		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
785	.c39a		fa		plx		                plx
786	.c39b		da		phx		                phx
787	.c39c		20 ef c2	jsr $c2ef	                jsr LC2EF
788	.c39f		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
789	.c3a2						LC3A2:
790	.c3a2		fa		plx		                plx
791	.c3a3		38		sec		                sec
792	.c3a4						LC3A4:
793	.c3a4		60		rts		                rts

795	.c3a5						vdu28EntryPoint:
796	.c3a5		ae 55 03	ldx $0355	                ldx $0355
797	.c3a8		ad 21 03	lda $0321	                lda $0321
798	.c3ab		cd 23 03	cmp $0323	                cmp $0323
799	.c3ae		90 f4		bcc $c3a4	                bcc LC3A4
800	.c3b0		dd ff e0	cmp $e0ff,x	                cmp modeMaxRow,x
801	.c3b3		f0 02		beq $c3b7	                beq LC3B7
802	.c3b5		b0 ed		bcs $c3a4	                bcs LC3A4
803	.c3b7						LC3B7:
804	.c3b7		ad 22 03	lda $0322	                lda $0322
805	.c3ba		dd 07 e1	cmp $e107,x	                cmp modeMaxColumn,x
806	.c3bd		f0 03		beq $c3c2	                beq LC3C2
807	.c3bf		b0 e3		bcs $c3a4	                bcs LC3A4
808	.c3c1		38		sec		                sec
809	.c3c2						LC3C2:
810	.c3c2		ed 20 03	sbc $0320	                sbc $0320
811	.c3c5		90 dd		bcc $c3a4	                bcc LC3A4
812	.c3c7		20 80 c7	jsr $c780	                jsr setTextWindowWidthInBytes
813	.c3ca		a9 08		lda #$08	                lda #$08
814	.c3cc		04 d0		tsb $d0		                tsb STATE
815	.c3ce		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
816	.c3d0		a0 08		ldy #$08	                ldy #VDUVariables.textWindowLeft
817	.c3d2		20 1c c9	jsr $c91c	                jsr copyFourBytesWithinVDUVariables
818	.c3d5		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
819	.c3d8		20 d8 cc	jsr $ccd8	                jsr LCCDA
820	.c3db		90 03		bcc $c3e0	                bcc LC3E0
821	.c3dd		20 e8 c3	jsr $c3e8	                jsr LC3E8
822	.c3e0						LC3E0:
823	.c3e0		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
824	.c3e3		20 d8 cc	jsr $ccd8	                jsr LCCDA
825	.c3e6		90 1f		bcc $c407	                bcc LC407
826	.c3e8						LC3E8:
827	.c3e8		a5 d0		lda $d0		                lda STATE
828	.c3ea		48		pha		                pha
829	.c3eb		29 df		and #$df	                and #$DF
830	.c3ed		85 d0		sta $d0		                sta STATE
831	.c3ef		20 7c c4	jsr $c47c	                jsr vdu30EntryPoint
832	.c3f2		68		pla		                pla
833	.c3f3		85 d0		sta $d0		                sta STATE
834	.c3f5		60		rts		                rts

836	.c3f6						vdu13EntryPoint:
837	.c3f6		ad 66 03	lda $0366	                lda $0366
838	.c3f9		29 0e		and #$0e	                and #$0E
839	.c3fb		aa		tax		                tax
840	.c3fc		20 d0 e2	jsr $e2d0	                jsr testVDU5State
841	.c3ff		d0 09		bne $c40a	                bne LC40A
842	.c401		4e 6c 03	lsr $036c	                lsr $036C
843	.c404		20 8f c3	jsr $c38f	                jsr LC38F
844	.c407						LC407:
845	.c407		4c ed c6	jmp $c6ed	                jmp updateCRTCCursorAddress

847	.c40a						LC40A:
848	.c40a		20 de c1	jsr $c1de	                jsr LC1DE
849	.c40d		4c df c4	jmp $c4df	                jmp LC4DF

851	.c410						LC410:
852	.c410		20 7c c4	jsr $c47c	                jsr vdu30EntryPoint

854							;-------------------------------------------------------------------------
855							;
856							; VDU 16 (&10) Clear graphics window [MasRef E.3-7]
857							;
858	.c413						vdu16EntryPoint:
859	.c413		ad 61 03	lda $0361	                lda vduv.pixelsPerByteMinusOne
860	.c416		f0 8c		beq $c3a4	                beq LC3A4                    ;taken if MODE 7
861	.c418		a2 00		ldx #$00	                ldx #VDUVariables.graphicsWindowPixelsLeft
862	.c41a		20 00 c9	jsr $c900	                jsr copyEightBytesToWorkspace28
863	.c41d		20 4f c9	jsr $c94f	                jsr prepareForPlotBackground
864	.c420						LC420:
865	.c420		a2 2a		ldx #$2a	                ldx #$2A
866	.c422		a0 2e		ldy #$2e	                ldy #$2E
867	.c424		20 b0 e2	jsr $e2b0	                jsr exchangeTwoVDUBytes
868	.c427						LC427:
869	.c427		a2 28		ldx #$28	                ldx #$28
870	.c429		a0 2c		ldy #$2c	                ldy #$2C
871	.c42b		20 e6 da	jsr $dae6	                jsr LDAE8
872	.c42e		ad 2a 03	lda $032a	                lda $032A
873	.c431		d0 03		bne $c436	                bne LC436
874	.c433		ce 2b 03	dec $032b	                dec $032B
875	.c436						LC436:
876	.c436		ce 2a 03	dec $032a	                dec $032A
877	.c439		ad 2a 03	lda $032a	                lda $032A
878	.c43c		cd 2e 03	cmp $032e	                cmp $032E
879	.c43f		ad 2b 03	lda $032b	                lda $032B
880	.c442		ed 2f 03	sbc $032f	                sbc $032F
881	.c445		10 e0		bpl $c427	                bpl LC427
882	.c447		60		rts		                rts

884	.c448						LC448:
885	.c448		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
886	.c44a		20 e4 c8	jsr $c8e4	                jsr prepareAABB
887	.c44d		80 d1		bra $c420	                bra LC420

889							;-------------------------------------------------------------------------
890							;
891							; VDU 12 (&0C) Clear text window [MasRef E.3-5]
892							;
893	.c44f						vdu12EntryPoint:
894	.c44f		a9 20		lda #$20	                lda #STATE.isVDU5
895	.c451		24 d0		bit $d0		                bit STATE
896	.c453		d0 bb		bne $c410	                bne LC410                    ;taken if VDU 5 mode
897	.c455		a9 08		lda #$08	                lda #STATE.isTextWindow
898	.c457		24 d0		bit $d0		                bit STATE
899	.c459		d0 03		bne $c45e	                bne clearTextWindow                    ;taken if text window
900	.c45b		4c 66 c8	jmp $c866	                jmp clsFastPath

902							                ; Clear screen within text window
903							                ; -------------------------------
904	.c45e						clearTextWindow:
905	.c45e		20 06 c9	jsr $c906	                jsr copyTextWindowWidthInBytesToWorkspace28
906	.c461		ae 08 03	ldx $0308	                ldx vduv.textWindowLeft
907	.c464		8e 18 03	stx $0318	                stx vduv.textCursorXPosition
908	.c467		ae 0b 03	ldx $030b	                ldx vduv.textWindowTop
909	.c46a						clearTextWindowRowsLoop:
910	.c46a		8e 19 03	stx $0319	                stx vduv.textCursorYPosition
911	.c46d		20 f8 cc	jsr $ccf8	                jsr updateZMEMTWithTextCursorPosition
912	.c470		20 e6 ca	jsr $cae6	                jsr LCAE8
913	.c473		ae 19 03	ldx $0319	                ldx vduv.textCursorYPosition
914	.c476		ec 09 03	cpx $0309	                cpx vduv.textWindowBottom
915	.c479		e8		inx		                inx
916	.c47a		90 ee		bcc $c46a	                bcc clearTextWindowRowsLoop

918							;-------------------------------------------------------------------------
919							;
920							; VDU 30 (&1E) Home cursor [MasRef E.3-36]
921							;
922	.c47c						vdu30EntryPoint:
923							                ; pretend it's VDU 31,0,0
924	.c47c		9c 23 03	stz $0323	                stz vduv.queueEnd-1
925	.c47f		9c 22 03	stz $0322	                stz vduv.queueEnd-2

927							;-------------------------------------------------------------------------
928							;
929							; VDU 31 (&1F) Tab cursor [MasRef E.3-36]
930							;
931	.c482						vdu31EntryPoint:
932	.c482		ad 66 03	lda $0366	                lda vduv.cursorFlags
933	.c485		29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
934	.c487		aa		tax		                tax
935	.c488						LC488:
936	.c488		20 d0 e2	jsr $e2d0	                jsr testVDU5State
937	.c48b		d0 42		bne $c4cf	                bne LC4CF                    ;taken if VDU 5
938	.c48d		ad 18 03	lda $0318	                lda vduv.textCursorXPosition
939	.c490		48		pha		                pha                          ;save old X pos
940	.c491		ad 19 03	lda $0319	                lda vduv.textCursorYPosition
941	.c494		48		pha		                pha                          ;save old Y pos
942	.c495		ad 22 03	lda $0322	                lda vduv.queueEnd-2          ;X coordinate
943	.c498		20 c7 c2	jsr $c2c7	                jsr setTextCursorXPositionWithCursorFlags
944	.c49b		da		phx		                phx                          ;save true cursorFlags bits
945	.c49c		8a		txa		                txa
946	.c49d		49 08		eor #$08	                eor #vduv.cursorFlags.swapAxes ;cheekily do the other axis by just changing the cursor flags
947	.c49f		aa		tax		                tax
948	.c4a0		ad 23 03	lda $0323	                lda vduv.queueEnd-1          ;Y coordinate
949	.c4a3		20 d5 cc	jsr $ccd5	                jsr LCCD7
950	.c4a6		fa		plx		                plx                    ;restore true cursorFlags bits
951	.c4a7		90 11		bcc $c4ba	                bcc LC4BA              ;taken if no scrolling required
952	.c4a9		a9 01		lda #$01	                lda #vduv.cursorFlags.scrollProtect
953	.c4ab		2c 66 03	bit $0366	                bit $0366
954	.c4ae		f0 11		beq $c4c1	                beq LC4C1                 ;taken if scroll protect off

956							                ; Wrap text cursor X.
957	.c4b0		ad 22 03	lda $0322	                lda vduv.queueEnd-2       ;X coordinate
958	.c4b3		3a		dec a		                dec a
959	.c4b4		20 d5 cc	jsr $ccd5	                jsr LCCD7
960	.c4b7		b0 08		bcs $c4c1	                bcs LC4C1
961	.c4b9		38		sec		                sec
962	.c4ba						LC4BA:
963	.c4ba		6e 6c 03	ror $036c	                ror vduv.column81
964	.c4bd		68		pla		                pla                          ;discard old Y pos
965	.c4be		68		pla		                pla                          ;discard old X pos
966	.c4bf		80 0b		bra $c4cc	                bra LC4CC

968	.c4c1						LC4C1:
969	.c4c1		68		pla		                pla
970	.c4c2		8d 19 03	sta $0319	                sta vduv.textCursorYPosition ;restore old Y pos
971	.c4c5		68		pla		                pla
972	.c4c6		8d 18 03	sta $0318	                sta vduv.textCursorXPosition ;restore old X pos
973	.c4c9		20 f8 cc	jsr $ccf8	                jsr updateZMEMTWithTextCursorPosition
974	.c4cc						LC4CC:
975	.c4cc		4c ed c6	jmp $c6ed	                jmp updateCRTCCursorAddress

977	.c4cf						LC4CF:
978	.c4cf		ad 22 03	lda $0322	                lda $0322
979	.c4d2		20 e0 c1	jsr $c1e0	                jsr LC1E0
980	.c4d5		8a		txa		                txa
981	.c4d6		49 08		eor #$08	                eor #$08
982	.c4d8		aa		tax		                tax
983	.c4d9		ad 23 03	lda $0323	                lda $0323
984	.c4dc		20 e0 c1	jsr $c1e0	                jsr LC1E0
985	.c4df						LC4DF:
986	.c4df		a0 10		ldy #$10	                ldy #$10
987	.c4e1		20 1a c9	jsr $c91a	                jsr copyGraphicsCursorPixels
988	.c4e4		a2 02		ldx #$02	                ldx #$02
989	.c4e6		a0 02		ldy #$02	                ldy #$02
990	.c4e8		20 fc c4	jsr $c4fc	                jsr LC4FC
991	.c4eb		a2 00		ldx #$00	                ldx #$00
992	.c4ed		a0 04		ldy #$04	                ldy #$04
993	.c4ef		ad 61 03	lda $0361	                lda $0361
994	.c4f2						LC4F2:
995	.c4f2		88		dey		                dey
996	.c4f3		4a		lsr a		                lsr a
997	.c4f4		d0 fc		bne $c4f2	                bne LC4F2
998	.c4f6		ad 56 03	lda $0356	                lda $0356
999	.c4f9		f0 01		beq $c4fc	                beq LC4FC
1000	.c4fb		c8		iny		                iny
1001	.c4fc						LC4FC:
1002	.c4fc		1e 10 03	asl $0310,x	                asl $0310,x
1003	.c4ff		3e 11 03	rol $0311,x	                rol $0311,x
1004	.c502		88		dey		                dey
1005	.c503		d0 f7		bne $c4fc	                bne LC4FC
1006	.c505		38		sec		                sec
1007	.c506		20 0a c5	jsr $c50a	                jsr LC50A
1008	.c509		e8		inx		                inx
1009	.c50a						LC50A:
1010	.c50a		bd 10 03	lda $0310,x	                lda $0310,x
1011	.c50d		fd 0c 03	sbc $030c,x	                sbc $030C,x
1012	.c510		9d 10 03	sta $0310,x	                sta $0310,x
1013	.c513		60		rts		                rts

1015							;-------------------------------------------------------------------------
1016							;
1017							; VDU 14 (&0E) Page mode on [MasRef E.3-6]
1018							;
1019	.c514						vdu14EntryPoint:
1020	.c514		9c 69 02	stz $0269	                stz pagedModeCounter
1021	.c517		a9 91		lda #$91	                lda #$91

1023							;-------------------------------------------------------------------------
1024							;
1025							; VDU 21 (&15) Disable VDU driver [MasRef E.3-11]
1026							;
1027	.c519						vdu21EntryPoint:
1028	.c519		49 95		eor #$95	                eor #$95
1029	.c51b						LC51B:
1030	.c51b		04 d0		tsb $d0		                tsb STATE
1031	.c51d		60		rts		                rts

1033							;-------------------------------------------------------------------------
1034							;
1035							; VDU 4 (&04) Print at text cursor [MasRef E.3-2]
1036							;
1037	.c51e						vdu4EntryPoint:
1038	.c51e		ad 61 03	lda $0361	                lda $0361
1039	.c521		f0 09		beq $c52c	                beq LC52C
1040	.c523		20 4e cf	jsr $cf4e	                jsr showCursor
1041	.c526		a9 2b		lda #$2b	                lda #$2B

1043							                ; fall through to vdu15EntryPoint

1045							;-------------------------------------------------------------------------
1046							;
1047							; VDU 15 (&0F) Page mode off [MasRef E.3-6]
1048							;
1049	.c528						vdu15EntryPoint:
1050	.c528		49 0b		eor #$0b	                eor #$0B
1051	.c52a		14 d0		trb $d0		                trb STATE
1052	.c52c						LC52C:
1053	.c52c		60		rts		                rts

1055							;-------------------------------------------------------------------------
1056							;
1057							; VDU 5 (&05) Print text at graphics cursor [MasRef E.3-3]
1058							;
1059	.c52d						vdu5EntryPoint:
1060	.c52d		ad 61 03	lda $0361	                lda $0361
1061	.c530		f0 fa		beq $c52c	                beq LC52C
1062	.c532		a9 20		lda #$20	                lda #$20
1063	.c534		20 51 cf	jsr $cf51	                jsr setCRTCRegister10
1064	.c537		80 e2		bra $c51b	                bra LC51B

1066							;-------------------------------------------------------------------------
1067							;
1068							; VDU 17 (&11) Define text colour [MasRef E.3-7]
1069							;
1070	.c539						vdu17EntryPoint:
1071	.c539		a0 00		ldy #$00	                ldy #$00
1072	.c53b		ad 23 03	lda $0323	                lda $0323
1073	.c53e		10 01		bpl $c541	                bpl LC541
1074	.c540		c8		iny		                iny
1075	.c541						LC541:
1076	.c541		2d 60 03	and $0360	                and $0360
1077	.c544		85 da		sta $da		                sta $DA
1078	.c546		ad 60 03	lda $0360	                lda $0360
1079	.c549		f0 18		beq $c563	                beq LC563
1080	.c54b		29 07		and #$07	                and #$07
1081	.c54d		18		clc		                clc
1082	.c54e		65 da		adc $da		                adc $DA
1083	.c550		aa		tax		                tax
1084	.c551		bd 49 e1	lda $e149,x	                lda solidColoursTable-1,x
1085	.c554		99 57 03	sta $0357,y	                sta $0357,y
1086	.c557		ad 57 03	lda $0357	                lda $0357
1087	.c55a		49 ff		eor #$ff	                eor #$FF
1088	.c55c		85 d3		sta $d3		                sta ZEOR
1089	.c55e		4d 58 03	eor $0358	                eor $0358
1090	.c561		85 d2		sta $d2		                sta ZORA
1091	.c563						LC563:
1092	.c563		60		rts		                rts

1094							;-------------------------------------------------------------------------
1095							;
1096							; VDU 18 (&12) Define graphics colour [MasRef E.3-7]
1097							;
1098	.c564						vdu18EntryPoint:
1099	.c564		a0 00		ldy #$00	                ldy #$00                    ;assume setting foreground
1100	.c566		ad 23 03	lda $0323	                lda vduv.queueEnd-1         ;get colour
1101	.c569		10 01		bpl $c56c	                bpl +                     ;taken if setting foreground
1102	.c56b		c8		iny		                iny                       ;setting background
1103	.c56c						+
1104	.c56c		2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne
1105	.c56f		99 6d 03	sta $036d,y	                sta vduv.foregroundGraphicsColour,y
1106	.c572		ad 22 03	lda $0322	                lda vduv.queueEnd-2          ;get GCOL mode
1107	.c575		99 5b 03	sta $035b,y	                sta vduv.foregroundGCOLMode,y
1108	.c578		29 f0		and #$f0	                and #$F0                     ;non-zero if ECF
1109	.c57a		99 6a 03	sta $036a,y	                sta vduv.isForegroundECF,y
1110	.c57d						initializeCurrentECFPatterns:
1111	.c57d		ad 5b 03	lda $035b	                lda vduv.foregroundGCOLMode
1112	.c580		ae 6d 03	ldx $036d	                ldx vduv.foregroundGraphicsColour
1113	.c583		a0 00		ldy #$00	                ldy #andy.fgECFPattern-andy.currentECFPatterns
1114	.c585		20 90 c5	jsr $c590	                jsr initializeCurrentECFPattern
1115	.c588		ad 5c 03	lda $035c	                lda vduv.backgroundGCOLMode
1116	.c58b		ae 6e 03	ldx $036e	                ldx vduv.backgroundGraphicsColour
1117	.c58e		a0 08		ldy #$08	                ldy #andy.bgECFPattern-andy.currentECFPatterns
1118	.c590						initializeCurrentECFPattern:
1119	.c590		29 f0		and #$f0	                and #$F0                     ;GCOL mode ECF bits
1120	.c592		d0 18		bne $c5ac	                bne initializeECFPatternFromPattern

1122	.c594						initializeECFPatternFromColour:
1123	.c594		86 da		stx $da		                stx ZTEMP+0                  ;colour low bits
1124	.c596		ad 60 03	lda $0360	                lda vduv.numberOfLogicalColoursMinusOne
1125	.c599		29 07		and #$07	                and #$07
1126	.c59b		18		clc		                clc
1127	.c59c		65 da		adc $da		                adc ZTEMP+0
1128	.c59e		aa		tax		                tax
1129							                ; use solid colour as ECF "pattern".
1130	.c59f		bd 49 e1	lda $e149,x	                lda solidColoursTable-1,x
1131	.c5a2		a2 07		ldx #$07	                ldx #$07
1132	.c5a4						-
1133	.c5a4		99 20 88	sta $8820,y	                sta andy.fgECFPattern,y
1134	.c5a7		c8		iny		                iny
1135	.c5a8		ca		dex		                dex
1136	.c5a9		10 f9		bpl $c5a4	                bpl -
1137	.c5ab		60		rts		                rts

1139	.c5ac						initializeECFPatternFromPattern:
1140	.c5ac		4a		lsr a		                lsr a                        ;(index+1)*8
1141	.c5ad		aa		tax		                tax
1142	.c5ae		a9 07		lda #$07	                lda #$07
1143	.c5b0		85 da		sta $da		                sta ZTEMP+0
1144	.c5b2						-
1145	.c5b2		bd f8 87	lda $87f8,x	                lda andy.ecfPatterns-8,x     ;-8 due to index+1 above
1146	.c5b5		99 20 88	sta $8820,y	                sta andy.fgECFPattern,y
1147	.c5b8		e8		inx		                inx
1148	.c5b9		c8		iny		                iny
1149	.c5ba		c6 da		dec $da		                dec ZTEMP+0
1150	.c5bc		10 f4		bpl $c5b2	                bpl -
1151	.c5be		60		rts		                rts

1153							;-------------------------------------------------------------------------
1154							;
1155							; VDU 20 (&14) Restore default logical colours [MasRef E.3-10]
1156							;
1157	.c5bf						setBackgroundTextColourForTeletext:
1158	.c5bf		a9 20		lda #$20	                lda #' '
1159	.c5c1		8d 58 03	sta $0358	                sta vduv.backgroundTextColour
1160	.c5c4		60		rts		                rts

1162	.c5c5						vdu20EntryPoint:
1163	.c5c5		a2 05		ldx #$05	                ldx #$05
1164	.c5c7						-
1165	.c5c7		9e 57 03	stz $0357,x	                stz vduv.foregroundTextColour,x
1166	.c5ca		ca		dex		                dex
1167	.c5cb		10 fa		bpl $c5c7	                bpl -
1168	.c5cd		9c 6e 03	stz $036e	                stz vduv.backgroundGraphicsColour
1169	.c5d0		9c 6b 03	stz $036b	                stz vduv.isBackgroundECF
1170	.c5d3		a9 ff		lda #$ff	                lda #%11111111
1171	.c5d5		ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
1172	.c5d8		f0 e5		beq $c5bf	                beq setBackgroundTextColourForTeletext
1173	.c5da		e0 0f		cpx #$0f	                cpx #$0F
1174	.c5dc		d0 02		bne $c5e0	                bne +                        ;taken unless MODE 2
1175	.c5de		a9 3f		lda #$3f	                lda #%00111111               ;MODE 2 default foreground colour is 7
1176	.c5e0						+
1177	.c5e0		8d 57 03	sta $0357	                sta vduv.foregroundTextColour
1178	.c5e3		49 ff		eor #$ff	                eor #$FF
1179	.c5e5		85 d2		sta $d2		                sta ZORA
1180	.c5e7		85 d3		sta $d3		                sta ZEOR
1181	.c5e9		8a		txa		                txa
1182	.c5ea		29 07		and #$07	                and #$07
1183	.c5ec		8d 6d 03	sta $036d	                sta vduv.foregroundGraphicsColour
1184	.c5ef		9c 6a 03	stz $036a	                stz vduv.isForegroundECF
1185	.c5f2		da		phx		                phx                          ;save numberOfLogicalColoursMinusOne
1186	.c5f3		20 7d c5	jsr $c57d	                jsr initializeCurrentECFPatterns
1187	.c5f6		fa		plx		                plx                          ;restore numberOfLogicalColoursMinusOne
1188	.c5f7		8e 1f 03	stx $031f	                stx vduv.queueEnd-5          ;Prepare VDU19,<max logical colour>
1189	.c5fa		e0 03		cpx #$03	                cpx #$03
1190	.c5fc		f0 11		beq $c60f	                beq reset4Colours            ;taken if MODE 1/5
1191	.c5fe		90 20		bcc $c620	                bcc reset2Colours            ;taken if MODE 0/3/4/6
1192	.c600						reset16Colours:
1193	.c600		8e 20 03	stx $0320	                stx vduv.queueEnd-4          ;start with VDU19,15,15,_,_,_
1194	.c603						-
1195	.c603		20 2d c6	jsr $c62d	                jsr vdu19EntryPoint
1196	.c606		ce 20 03	dec $0320	                dec vduv.queueEnd-4
1197	.c609		ce 1f 03	dec $031f	                dec vduv.queueEnd-5
1198	.c60c		10 f5		bpl $c603	                bpl -
1199	.c60e		60		rts		                rts

1201	.c60f						reset4Colours:
1202	.c60f		a2 07		ldx #$07	                ldx #$07
1203	.c611		8e 20 03	stx $0320	                stx vduv.queueEnd-4          ;start with VDU19,3,7,_,_,_
1204	.c614						-
1205	.c614		20 2d c6	jsr $c62d	                jsr vdu19EntryPoint          ;2,3, then 1,1, then 0,0
1206	.c617		4e 20 03	lsr $0320	                lsr vduv.queueEnd-4
1207	.c61a		ce 1f 03	dec $031f	                dec vduv.queueEnd-5
1208	.c61d		10 f5		bpl $c614	                bpl -
1209	.c61f		60		rts		                rts

1211	.c620						reset2Colours:
1212	.c620		a2 07		ldx #$07	                ldx #$07
1213	.c622		20 2a c6	jsr $c62a	                jsr +                        ;VDU19,1,7,_,_,_
1214	.c625		a2 00		ldx #$00	                ldx #$00
1215	.c627		9c 1f 03	stz $031f	                stz vduv.queueEnd-5          ;VDU19,0,0,_,_,_
1216	.c62a						+
1217	.c62a		8e 20 03	stx $0320	                stx vduv.queueEnd-4          ;VDU19,N,X,_,_,_

1219							                ; fall through to VDU19

1221							;-------------------------------------------------------------------------
1222							;
1223							; VDU 19 (&13) Define logical colour [MasRef E.3-9]
1224							;
1225	.c62d						vdu19EntryPoint:
1226	.c62d		08		php		                php
1227	.c62e		78		sei		                sei
1228	.c62f		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get logical colour
1229	.c632		2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne ;apply logical colour limit
1230	.c635		aa		tax		                tax                        ;X = clamped logical colour
1231	.c636		ad 20 03	lda $0320	                lda vduv.queueEnd-4        ;get physical colour
1232	.c639						LC639:
1233	.c639		29 0f		and #$0f	                and #$0F                     ;apply physical colour limit
1234	.c63b		9d 6f 03	sta $036f,x	                sta vduv.currentPalette,x    ;update palette
1235	.c63e		a8		tay		                tay                          ;Y = physical colour
1236	.c63f		ad 60 03	lda $0360	                lda vduv.numberOfLogicalColoursMinusOne
1237	.c642		85 fa		sta $fa		                sta SEIWKA
1238	.c644		c9 03		cmp #$03	                cmp #$03 ;Z=1 C=1 if 4 colour; Z=0 C=1 if 16 colour; Z=0 C=0 if 2 colour
1239	.c646		08		php		                php      ;save flags
1240	.c647		8a		txa		                txa                          ;A = logical colour

1242							                ;put the logical colour value in the top 1, 2 or 4
1243							                ;bits of SEIWKA, depending on the colour depth.
1244							                ;
1245							                ; 2 colours: turn %0000000a into %a0000000
1246							                ; 4 colours: turn %000000ab into %ab000000
1247							                ;16 colours: turn %0000abcd into %abcd0000
1248	.c648						-
1249	.c648		4a		lsr a		                lsr a
1250	.c649		66 fa		ror $fa		                ror SEIWKA
1251	.c64b		b0 fb		bcs $c648	                bcs -
1252	.c64d		06 fa		asl $fa		                asl SEIWKA

1254	.c64f		98		tya		                tya                          ;A = physical colour
1255	.c650		05 fa		ora $fa		                ora SEIWKA                   ;mix in logical colour
1256	.c652		aa		tax		                tax                          ;X = VPALETTE value
1257	.c653		a0 f0		ldy #$f0	                ldy #$F0 ;counts up to zero - counter for setting
1258							                         ;multiple logical colours [AUG p380]
1259	.c655						LC655:
1260	.c655		28		plp		                plp                          ;restore flags
1261	.c656		08		php		                php                          ;save flags
1262	.c657		d0 03		bne $c65c	                bne +                     ;taken if 2 colour/16 colour
1263	.c659		20 6f c6	jsr $c66f	                jsr fixUpVPALETTEFor4Colours
1264	.c65c						+
1265	.c65c		20 50 f0	jsr $f050	                jsr writeVPALETTE
1266	.c65f		18		clc		                clc
1267	.c660		98		tya		                tya
1268	.c661		6d 60 03	adc $0360	                adc vduv.numberOfLogicalColoursMinusOne
1269	.c664		a8		tay		                tay
1270	.c665		8a		txa		                txa
1271	.c666		69 10		adc #$10	                adc #$10                     ;next logical colour
1272	.c668		aa		tax		                tax
1273	.c669		c8		iny		                iny                          ;Y+=numberOfLogicalColours
1274	.c66a		d0 e9		bne $c655	                bne LC655                    ;all logical colours set once zero
1275	.c66c		28		plp		                plp
1276	.c66d		28		plp		                plp
1277	.c66e		60		rts		                rts

1279	.c66f						fixUpVPALETTEFor4Colours:
1280	.c66f		2a		rol a		                rol a                        ;A BCDabcd1
1281	.c670		85 da		sta $da		                sta ZTEMP+0                  ;  BCDabcd1
1282	.c672		2a		rol a		                rol a                        ;B CDabcd1A
1283	.c673		2a		rol a		                rol a                        ;C Dabcd1AB
1284	.c674		08		php		                php                          ;C
1285	.c675		26 da		rol $da		                rol ZTEMP+0                  ;B CDabcd1C
1286	.c677		6a		ror a		                ror a                        ;B BDabcd1A
1287	.c678		28		plp		                plp                          ;C BDabcd1A
1288	.c679		6a		ror a		                ror a                        ;A CBDabcd1
1289	.c67a		6a		ror a		                ror a                        ;1 ACBDabcd
1290	.c67b		60		rts		                rts                          ;

1292							;-------------------------------------------------------------------------
1293							;
1294							; VDU 23 (&17) Various functions [MasRef E.3-12]
1295							;
1296	.c67c						vdu23EntryPoint:
1297	.c67c		ad 1b 03	lda $031b	                lda vduv.queueEnd-9           ;get VDU 23 code
1298	.c67f		c9 20		cmp #$20	                cmp #$20
1299	.c681		90 0e		bcc $c691	                bcc LC691         ;branch taken if <32 - i.e., special

1301							                ; copy the 8 bytes of character definition to the
1302							                ; appropriate place.
1303	.c683		20 2a e2	jsr $e22a	                jsr getSoftCharacterDefinitionAddress
1304	.c686		a0 07		ldy #$07	                ldy #$07
1305	.c688						LC688:
1306	.c688		b9 1c 03	lda $031c,y	                lda vduv.queueEnd-8,y
1307	.c68b		91 de		sta ($de),y	                sta ($DE),y
1308	.c68d		88		dey		                dey
1309	.c68e		10 f8		bpl $c688	                bpl LC688
1310	.c690		60		rts		                rts

1312	.c691						LC691:
1313	.c691		0a		asl a		                asl a
1314	.c692		aa		tax		                tax
1315	.c693		4a		lsr a		                lsr a
1316	.c694		c9 11		cmp #$11	                cmp #$11
1317	.c696		b0 0f		bcs $c6a7	                bcs callVDUV    ;call with C=1 - invalid code [MasRef
1318							                                ;E.3-19]
1319	.c698		7c 67 e0	jmp ($e067,x)	                jmp (vdu23EntryPointTable,x)

1321							;-------------------------------------------------------------------------
1322							;
1323							; VDU 25 (&19) PLOT commands [MasRef E.3-21]
1324							;
1325	.c69b						vdu25EntryPoint:
1326	.c69b		ae 61 03	ldx $0361	                ldx vduv.pixelsPerByteMinusOne
1327	.c69e		f0 03		beq $c6a3	                beq callVDUVForPLOT          ;non-graphics PLOT
1328	.c6a0		4c 44 d1	jmp $d144	                jmp handlePLOT

1330							;-------------------------------------------------------------------------
1331							;
1332							; Call VDUV for a PLOT call, either to handle non-graphics PLOT
1333							; [MasRef E.3-21] or PLOT 240-255 [MasRef E.3-34].
1334							;
1335	.c6a3						callVDUVForPLOT:
1336	.c6a3		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT code
1337	.c6a6		18		clc		                clc ;call with C=0 - non-graphics PLOT [MasRef E.3-21]

1339							;-------------------------------------------------------------------------
1340							;
1341							; Call VDUV.
1342							;
1343	.c6a7						callVDUV:
1344							                .if version<350
1346							                .else
1347	.c6a7		4c e1 e2	jmp $e2e1	                jmp LE2F3
1348							                .endif

1350							;-------------------------------------------------------------------------
1351							;
1352							; VDU 26 (&1A) Restore default windows [MasRef E.3-34]
1353							;
1354	.c6aa						vdu26EntryPoint:
1355	.c6aa		a2 2c		ldx #$2c	                ldx #VDUVariables.workspace._2C
1356	.c6ac						-
1357	.c6ac		9e 00 03	stz $0300,x	                stz vduv,x                    ;reset workspace
1358	.c6af		ca		dex		                dex
1359	.c6b0		10 fa		bpl $c6ac	                bpl -

1361	.c6b2		20 a0 e2	jsr $e2a0	                jsr getDefaultBoundsForCurrentScreenMODE
1362	.c6b5		8e 0a 03	stx $030a	                stx vduv.textWindowRight
1363	.c6b8		8c 09 03	sty $0309	                sty vduv.textWindowBottom

1365	.c6bb		8a		txa		                txa
1366	.c6bc		20 80 c7	jsr $c780	                jsr setTextWindowWidthInBytes

1368							                ; Set up the VDU queue as if VDU 24,0;0;1279;1023;,
1369							                ; then call the VDU 24 entry point.

1371							                ; 1c - ll - $00
1372							                ; 1d - lh - $00
1373							                ; 1e - tl - $00
1374							                ; 1f - th - $00
1375							                ; 20 - rl - $ff
1376							                ; 21 - rh - $04
1377							                ; 22 - tl - $ff
1378							                ; 23 - th - $03

1380	.c6bf		a0 03		ldy #$03	                ldy #$03
1381	.c6c1		8c 23 03	sty $0323	                sty $0323
1382	.c6c4		c8		iny		                iny
1383	.c6c5		8c 21 03	sty $0321	                sty $0321
1384	.c6c8		ce 22 03	dec $0322	                dec $0322
1385	.c6cb		ce 20 03	dec $0320	                dec $0320
1386	.c6ce		20 1f c7	jsr $c71f	                jsr vdu24EntryPoint

1388	.c6d1		a9 08		lda #$08	                lda #STATE.isTextWindow
1389	.c6d3		14 d0		trb $d0		                trb STATE                    ;reset isTextWindow

1391	.c6d5		4c 7c c4	jmp $c47c	                jmp vdu30EntryPoint          ;reset text cursor

1393							;-------------------------------------------------------------------------
1394							;
1395							; Update CRTC cursor address to reflect text cursor position.
1396							;
1397	.c6d8						updateCRTCTextCursor:
1398	.c6d8		20 f8 cc	jsr $ccf8	                jsr updateZMEMTWithTextCursorPosition
1399	.c6db		80 10		bra $c6ed	                bra updateCRTCCursorAddress

1401							;-------------------------------------------------------------------------

1403	.c6dd						setCRTCCursorAddress:
1404	.c6dd		8e 4a 03	stx $034a	                stx vduv.textCursorCRTCAddress+0
1405	.c6e0		8d 4b 03	sta $034b	                sta vduv.textCursorCRTCAddress+1
1406	.c6e3		10 04		bpl $c6e9	                bpl +
1407	.c6e5		38		sec		                sec
1408	.c6e6		ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte
1409	.c6e9						+
1410	.c6e9		86 d8		stx $d8		                stx ZMEMT+0
1411	.c6eb		85 d9		sta $d9		                sta ZMEMT+1

1413							;-------------------------------------------------------------------------
1414							;
1415							;
1416	.c6ed						updateCRTCCursorAddress:
1417	.c6ed		ae 4a 03	ldx $034a	                ldx vduv.textCursorCRTCAddress+0
1418	.c6f0		ad 4b 03	lda $034b	                lda vduv.textCursorCRTCAddress+1
1419	.c6f3		a0 0e		ldy #$0e	                ldy #$0E

1421							;-------------------------------------------------------------------------
1422							;
1423							; Set CRTC address - cursor, or screen start.
1424							;
1425							; entry:
1426							;
1427							; A (msb), X (msb) = 6502 address to set
1428							;
1429							; Y = first CRTC register to set
1430							;
1431	.c6f5						setCRTCAddress:
1432	.c6f5		48		pha		                pha                          ;save screen address MSB
1433	.c6f6		ad 55 03	lda $0355	                lda vduv.currentScreenMODE
1434	.c6f9		c9 07		cmp #$07	                cmp #$07
1435	.c6fb		68		pla		                pla                        ;restore screen address MSB
1436	.c6fc		b0 0f		bcs $c70d	                bcs adjustAddressForMODE7
1437	.c6fe		86 da		stx $da		                stx ZTEMP+0
1438	.c700		4a		lsr a		                lsr a
1439	.c701		66 da		ror $da		                ror ZTEMP+0                  ;/2
1440	.c703		4a		lsr a		                lsr a
1441	.c704		66 da		ror $da		                ror ZTEMP+0                  ;/4
1442	.c706		4a		lsr a		                lsr a
1443	.c707		66 da		ror $da		                ror ZTEMP+0                  ;/8
1444	.c709		a6 da		ldx $da		                ldx ZTEMP+0
1445	.c70b		80 04		bra $c711	                bra setCRTCAddressRegisters

1447	.c70d						adjustAddressForMODE7:
1448							                ; C=1
1449	.c70d		e9 74		sbc #$74	                sbc #$74                 ;adjust for Mode 7 addressing
1450	.c70f		49 20		eor #$20	                eor #$20                 ;adjust for Mode 7 addressing
1451	.c711						setCRTCAddressRegisters:
1452	.c711		8c 00 fe	sty $fe00	                sty CRTC+0
1453	.c714		8d 01 fe	sta $fe01	                sta CRTC+1
1454	.c717		c8		iny		                iny
1455	.c718		8c 00 fe	sty $fe00	                sty CRTC+0
1456	.c71b		8e 01 fe	stx $fe01	                stx CRTC+1
1457	.c71e		60		rts		                rts

1459							;-------------------------------------------------------------------------
1460							;
1461							; VDU 24 (&18) Define graphics window [MasRef E.3-21]
1462							;
1463							; VDU queue:
1464							;
1465							; -8 = <left
1466							; -7 = >left
1467							; -6 = <bottom
1468							; -5 = >bottom
1469							; -4 = <right
1470							; -3 = >right
1471							; -2 = <top
1472							; -1 = >top
1473							;
1474	.c71f						vdu24EntryPoint:
1475	.c71f		20 79 c7	jsr $c779	                jsr LC779

1477	.c722		a2 02		ldx #$02	                ldx #2
1478	.c724						-
1479	.c724		38		sec		                sec

1481							                ; <height when X=2, then <width when X=0
1482	.c725		bd 20 03	lda $0320,x	                lda vduv.queueEnd-4+0,x
1483	.c728		fd 1c 03	sbc $031c,x	                sbc vduv.queueEnd-8+0,x
1484	.c72b		9d 2c 03	sta $032c,x	                sta vduv.workspace._2C+0,x

1486							                ; >height when X=2, then >width when X=0
1487	.c72e		bd 21 03	lda $0321,x	                lda vduv.queueEnd-4+1,x
1488	.c731		fd 1d 03	sbc $031d,x	                sbc vduv.queueEnd-8+1,x
1489	.c734		9d 2d 03	sta $032d,x	                sta vduv.workspace._2C+1,x

1491	.c737		ca		dex		                dex
1492	.c738		ca		dex		                dex
1493	.c739		10 e9		bpl $c724	                bpl -

1495	.c73b		0d 2f 03	ora $032f	                ora vduv.workspace._2C+3     ;A=>width|>height
1496	.c73e		30 39		bmi $c779	                bmi LC779 ;taken if either dimension negative - window invalid
1497	.c740		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4 ;left bottom
1498	.c742		20 dc d1	jsr $d1dc	                jsr eigabsEntryPoint         ;convert to pixels
1499	.c745		a2 1c		ldx #$1c	                ldx #VDUVariables.queueEnd-8 ;right top
1500	.c747		20 dc d1	jsr $d1dc	                jsr eigabsEntryPoint         ;convert to pixels
1501	.c74a		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;>bottom
1502	.c74d		0d 1d 03	ora $031d	                ora vduv.queueEnd-7          ;>left
1503	.c750		30 27		bmi $c779	                bmi LC779 ;taken if either bottom or left negative - window invalid
1504	.c752		ad 23 03	lda $0323	                lda vduv.queueEnd-1          ;>top
1505	.c755		d0 22		bne $c779	                bne LC779          ;taken if top>=256 - window invalid
1506	.c757		ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
1507	.c75a		ad 21 03	lda $0321	                lda vduv.queueEnd-3          ;>right
1508	.c75d		85 da		sta $da		                sta ZTEMP+0
1509	.c75f		ad 20 03	lda $0320	                lda vduv.queueEnd-4          ;<right
1510	.c762		46 da		lsr $da		                lsr ZTEMP+0                  ;>(right/2)
1511	.c764		6a		ror a		                ror a                        ;<(right/2)
1512	.c765		46 da		lsr $da		                lsr ZTEMP+0                  ;>(right/4)

1514							                ; 639>>2=159 - so any valid pixel X in any mode will
1515							                ; have an MSB of 0 after being shifted right 2.
1516	.c767		d0 10		bne $c779	                bne LC779 ;taken if right edge definitely off screen - window invalid
1517	.c769		6a		ror a		                ror a     ;<(right/4)
1518	.c76a		4a		lsr a		                lsr a     ;<(right/8)
1519	.c76b		dd 07 e1	cmp $e107,x	                cmp modeMaxColumn,x
1520	.c76e		f0 02		beq $c772	                beq LC772                    ;taken if right edge just on screen
1521	.c770		10 07		bpl $c779	                bpl LC779 ;taken if right edge off screen - window definitely invalid
1522	.c772						LC772:
1523	.c772		a0 00		ldy #$00	                ldy #VDUVariables.graphicsWindowPixelsLeft
1524	.c774		a2 1c		ldx #$1c	                ldx #VDUVariables.queueEnd-8
1525	.c776		20 02 c9	jsr $c902	                jsr copyEightBytesWithinVDUVariables
1526	.c779						LC779:
1527	.c779		a2 10		ldx #$10	                ldx #VDUVariables.graphicsCursorPositionX
1528	.c77b		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
1529	.c77d		4c b8 e2	jmp $e2b8	                jmp exchangeFourVDUBytes

1531							;-------------------------------------------------------------------------
1532							;
1533							; Call getBytesPerInclusiveTextRow, and store the result in the
1534							; textWindowWidthInBytes VDU variable.
1535							;
1536	.c780						setTextWindowWidthInBytes:
1537	.c780		20 39 c9	jsr $c939	                jsr getBytesPerInclusiveTextRow
1538	.c783		8d 4c 03	sta $034c	                sta vduv.textWindowWidthInBytes+0
1539	.c786		8e 4d 03	stx $034d	                stx vduv.textWindowWidthInBytes+1
1540	.c789		60		rts		                rts

1542							;-------------------------------------------------------------------------
1543							;
1544							; VDU 29 (&1D) Define graphics origin [MasRef E.3-35]
1545							;
1546	.c78a						vdu29EntryPoint:
1547	.c78a		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
1548	.c78c		a0 0c		ldy #$0c	                ldy #VDUVariables.graphicsWindowOriginX
1549	.c78e		20 1c c9	jsr $c91c	                jsr copyFourBytesWithinVDUVariables
1550	.c791		4c df c4	jmp $c4df	                jmp LC4DF

1552							;-------------------------------------------------------------------------
1553							;
1554							; VDU 22 (&16) Select screen mode [MasRef E.3-11]
1555							;
1556	.c794						vdu22EntryPoint:
1557	.c794		ad 23 03	lda $0323	                lda vduv.queueEnd-1          ;get MODE number
1558	.c797		80 23		bra $c7bc	                bra setMODE

1560							;-------------------------------------------------------------------------
1561							;
1562	.c799						setStartupMODE:
1563							                .if version==350
1565							                .endif
1566	.c799		85 da		sta $da		                sta ZTEMP+0                  ;save MODE
1567	.c79b		a5 f4		lda $f4		                lda $F4
1568	.c79d		48		pha		                pha
1569	.c79e		09 80		ora #$80	                ora #$80                     ;page in ANDY
1570	.c7a0		20 9f e5	jsr $e59f	                jsr selectROMA
1571	.c7a3		20 aa c7	jsr $c7aa	                jsr +
1572	.c7a6		68		pla		                pla
1573	.c7a7		4c 9f e5	jmp $e59f	                jmp selectROMA               ;restore old ROM

1575	.c7aa						+
1576							                ; TODO but what of the reserved byte here?
1577	.c7aa		a2 7f		ldx #$7f	                ldx #size(VDUVariables)-1
1578	.c7ac		64 d0		stz $d0		                stz STATE
1579	.c7ae		ad 66 03	lda $0366	                lda vduv.cursorFlags
1580	.c7b1						-
1581	.c7b1		9e ff 02	stz $02ff,x	                stz vduv-1,x
1582	.c7b4		ca		dex		                dex
1583	.c7b5		d0 fa		bne $c7b1	                bne -
1584	.c7b7		8d 66 03	sta $0366	                sta vduv.cursorFlags
1585	.c7ba		a5 da		lda $da		                lda ZTEMP                    ;restore MODE

1587							                ; fall through to setMODE

1589							;-------------------------------------------------------------------------
1590							;
1591							;
1592							;
1593	.c7bc						setMODE:
1594	.c7bc		9c 8a 02	stz $028a	                stz vduDriverMemory
1595	.c7bf		9c 8b 02	stz $028b	                stz displayMemory
1596	.c7c2		a8		tay		                tay                          ;Y=mode
1597	.c7c3		30 10		bmi $c7d5	                bmi setShadowMODE
1598	.c7c5		ae 7f 02	ldx $027f	                ldx shadowRAMState
1599	.c7c8		f0 0b		beq $c7d5	                beq setShadowMODE
1600	.c7ca		a9 10		lda #$10	                lda #STATE.isShadowMode
1601	.c7cc		14 d0		trb $d0		                trb STATE
1602	.c7ce		a9 03		lda #$03	                lda #ACCCON.D|ACCCON.E
1603	.c7d0		1c 34 fe	trb $fe34	                trb ACCCON ;display main RAM, VDU code accesses main RAM
1604	.c7d3		80 09		bra $c7de	                bra +

1606	.c7d5						setShadowMODE:
1607	.c7d5		a9 10		lda #$10	                lda #STATE.isShadowMode
1608	.c7d7		04 d0		tsb $d0		                tsb STATE
1609	.c7d9		a9 03		lda #$03	                lda #ACCCON.D|ACCCON.E
1610	.c7db		0c 34 fe	tsb $fe34	                tsb ACCCON ;display shadow RAM, VDU code accesses shadow RAM
1611	.c7de						+
1612	.c7de		98		tya		                tya                          ;A=mode
1613	.c7df		29 07		and #$07	                and #$07                     ;get MODE 0-7
1614	.c7e1		aa		tax		                tax                          ;X=MODE 0-7
1615	.c7e2		8e 55 03	stx $0355	                stx vduv.currentScreenMODE
1616	.c7e5		bd 3a e1	lda $e13a,x	                lda numberOfLogicalColoursMinusOneForMODE,x
1617	.c7e8		8d 60 03	sta $0360	                sta vduv.numberOfLogicalColoursMinusOne
1618	.c7eb		bd 17 e1	lda $e117,x	                lda bytesPerCharacterForMODE,x
1619	.c7ee		8d 4f 03	sta $034f	                sta vduv.bytesPerCharacter
1620	.c7f1		bd 60 e1	lda $e160,x	                lda pixelsPerByteMinusOneForMODE,x
1621	.c7f4		8d 61 03	sta $0361	                sta vduv.pixelsPerByteMinusOne
1622	.c7f7		d0 02		bne $c7fb	                bne +                        ;taken if graphics mode
1623	.c7f9		a9 07		lda #$07	                lda #$07                     ;assume 8 px/byte for non-graphics modes
1624	.c7fb						+
1625	.c7fb		0a		asl a		                asl a            ;convert to pixelMasks index for rightmost pixel
1626	.c7fc		a8		tay		                tay
1627	.c7fd		b9 2c e1	lda $e12c,y	                lda pixelMasks-1,y
1628	.c800		8d 63 03	sta $0363	                sta vduv.colourMaskRight
1629	.c803						-
1630	.c803		0a		asl a		                asl a
1631	.c804		10 fd		bpl $c803	                bpl -   ;keep shifting until leftmost pixel mask found
1632	.c806		8d 62 03	sta $0362	                sta vduv.colourMaskLeft
1633	.c809		bc 66 e1	ldy $e166,x	                ldy screenMODEGroupForMODE,x
1634	.c80c		8c 56 03	sty $0356	                sty vduv.currentScreenMODEGroup
1635	.c80f		b9 72 e1	lda $e172,y	                lda latchBit4ForScreenMODEGroup,y
1636	.c812		08		php		                php
1637	.c813		78		sei		                sei
1638	.c814		8d 40 fe	sta $fe40	                sta systemVIA.orb
1639	.c817		b9 6e e1	lda $e16e,y	                lda latchBit5ForScreenMODEGroup,y
1640	.c81a		8d 40 fe	sta $fe40	                sta systemVIA.orb
1641	.c81d		28		plp		                plp
1642	.c81e		b9 77 e1	lda $e177,y	                lda screenSizeHighByteForScreenMODEGroup,y
1643	.c821		8d 54 03	sta $0354	                sta vduv.screenSizeHighByte
1644	.c824		b9 7c e1	lda $e17c,y	                lda startScreenAddressHighByteForScreenMODEGroup,y
1645	.c827		8d 4e 03	sta $034e	                sta vduv.startScreenAddressHighByte
1646	.c82a		a9 ee		lda #$ee	                lda #STATE.isVDU21|STATE.isCursorEditing|STATE.isVDU5|STATE.isTextWindow|STATE.isPagedScrolling|STATE.isScrollingDisabled
1647	.c82c		14 d0		trb $d0		                trb STATE
1648	.c82e		ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
1649	.c831		bd 0f e1	lda $e10f,x	                lda vcontrolForScreenMODE,x
1650	.c834		20 3f f0	jsr $f03f	                jsr setVCONTROL
1651	.c837		08		php		                php
1652	.c838		78		sei		                sei
1653	.c839		be 81 e1	ldx $e181,y	                ldx crtcRegisterLastIndexForScreenMODEGroup,y
1654	.c83c		a0 0b		ldy #$0b	                ldy #$0B
1655	.c83e						-
1656	.c83e		bd 86 e1	lda $e186,x	                lda crtcRegisterValues,x
1657	.c841		20 ff ce	jsr $ceff	                jsr setCRTCRegister
1658	.c844		ca		dex		                dex
1659	.c845		88		dey		                dey
1660	.c846		10 f6		bpl $c83e	                bpl -
1661	.c848		28		plp		                plp
1662	.c849		20 c5 c5	jsr $c5c5	                jsr vdu20EntryPoint
1663	.c84c		20 6b cf	jsr $cf6b	                jsr vdu23_11_EntryPoint
1664	.c84f		a9 aa		lda #$aa	                lda #%10101010
1665	.c851		8d 67 03	sta $0367	                sta vduv.dotPattern
1666	.c854		8d 68 03	sta $0368	                sta vduv.dotPatternState
1667	.c857		20 aa c6	jsr $c6aa	                jsr vdu26EntryPoint
1668	.c85a		ad 4c 03	lda $034c	                lda vduv.textWindowWidthInBytes+0
1669	.c85d		ae 4d 03	ldx $034d	                ldx vduv.textWindowWidthInBytes+1
1670	.c860		8d 52 03	sta $0352	                sta vduv.bytesPerCharacterRow+0
1671	.c863		8e 53 03	stx $0353	                stx vduv.bytesPerCharacterRow+1

1673							                ; Do a fast hardware CLS of the whole screen
1674							                ; ------------------------------------------
1675	.c866						clsFastPath:
1676	.c866		a2 00		ldx #$00	                ldx #$00
1677	.c868		ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
1678	.c86b		9c 50 03	stz $0350	                stz vduv.screenTopLeftAddress+0
1679	.c86e		8d 51 03	sta $0351	                sta vduv.screenTopLeftAddress+1
1680	.c871		20 dd c6	jsr $c6dd	                jsr setCRTCCursorAddress
1681	.c874		a0 0c		ldy #$0c	                ldy #$0C
1682	.c876		20 11 c7	jsr $c711	                jsr setCRTCAddressRegisters
1683	.c879		9c 69 02	stz $0269	                stz pagedModeCounter
1684	.c87c		38		sec		                sec
1685	.c87d		a9 80		lda #$80	                lda #$80
1686	.c87f		ed 4e 03	sbc $034e	                sbc vduv.startScreenAddressHighByte
1687	.c882		aa		tax		                tax
1688	.c883		a0 00		ldy #$00	                ldy #$00
1689	.c885		20 82 cb	jsr $cb82	                jsr clearTextMemory
1690	.c888		4c 7c c4	jmp $c47c	                jmp vdu30EntryPoint

1692	.c88b						LC88B:
1693	.c88b		20 ce c8	jsr $c8ce	                jsr LC8CF                    ; Clear paged mode counter
1694	.c88e						LC88E:
1695	.c88e		20 1f f0	jsr $f01f	                jsr osbyte76    ; Call KEYV to test Shift & Ctrl keys
1696	.c891		90 02		bcc $c895	                bcc LC895                    ; Ctrl not pressed, exit loop
1697	.c893		30 f6		bmi $c88b	                bmi LC88B                    ; Shift pressed, loop back
1698	.c895						LC895:
1699	.c895		a5 d0		lda $d0		                lda STATE
1700	.c897		49 04		eor #$04	                eor #STATE.isPagedScrolling
1701	.c899		29 46		and #$46	                and #STATE.isCursorEditing|STATE.isPagedScrolling|STATE.isScrollingDisabled;
1702	.c89b		d0 37		bne $c8d4	                bne LC8D6
1703	.c89d		20 d5 c8	jsr $c8d5	                jsr LC8D7
1704	.c8a0		b9 18 03	lda $0318,y	                lda vduv.textCursorXPosition,y
1705	.c8a3		dd 08 03	cmp $0308,x	                cmp vduv.textWindowLeft,x
1706	.c8a6		d0 29		bne $c8d1	                bne LC8D3
1707							                .if version==400||version==350
1708	.c8a8		c0 00		cpy #$00	                cpy #0
1713							                .endif
1714	.c8aa		d0 08		bne $c8b4	                bne LC8B5
1715	.c8ac		ad 0a 03	lda $030a	                lda vduv.textWindowRight
1716	.c8af		ed 08 03	sbc $0308	                sbc vduv.textWindowLeft
1717	.c8b2		80 06		bra $c8ba	                bra LC8BB

1719	.c8b4						LC8B5:
1720	.c8b4		ad 09 03	lda $0309	                lda vduv.textWindowBottom
1721	.c8b7		ed 0b 03	sbc $030b	                sbc vduv.textWindowTop
1722	.c8ba						LC8BB:
1723	.c8ba		48		pha		                pha
1724	.c8bb		4a		lsr a		                lsr a
1725	.c8bc		4a		lsr a		                lsr a
1726	.c8bd		85 da		sta $da		                sta ZTEMP+0
1727	.c8bf		38		sec		                sec
1728	.c8c0		68		pla		                pla
1729	.c8c1		e5 da		sbc $da		                sbc ZTEMP+0
1730	.c8c3		cd 69 02	cmp $0269	                cmp pagedModeCounter
1731	.c8c6		b0 09		bcs $c8d1	                bcs LC8D3
1732	.c8c8						LC8C9:
1733	.c8c8		20 1f f0	jsr $f01f	                jsr osbyte76
1734	.c8cb		38		sec		                sec
1735	.c8cc		10 fa		bpl $c8c8	                bpl LC8C9

1737	.c8ce						LC8CF:
1738	.c8ce		9c 69 02	stz $0269	                stz pagedModeCounter        ; Clear paged mode counter
1739							                .if version!=400&&version!=350
1741							                .endif
1742	.c8d1						LC8D3:
1743	.c8d1		ee 69 02	inc $0269	                inc pagedModeCounter
1744	.c8d4						LC8D6:
1745	.c8d4		60		rts		                rts

1747	.c8d5						LC8D7:
1748	.c8d5		ad 66 03	lda $0366	                lda vduv.cursorFlags
1749	.c8d8		29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
1750	.c8da		4a		lsr a		                lsr a                        ;xvh
1751	.c8db		aa		tax		                tax
1752	.c8dc		bd 02 e2	lda $e202,x	                lda LE204,x
1753	.c8df		aa		tax		                tax
1754	.c8e0		29 01		and #$01	                and #$01
1755	.c8e2		a8		tay		                tay
1756	.c8e3		60		rts		                rts

1758							;-------------------------------------------------------------------------
1759							;
1760							; Prepare AABB based on the current graphics cursor and some other
1761							; coordinate.
1762							;
1763							; entry:
1764							;
1765							; X = VDU variable offset of other coordinate (4 bytes: X;Y;)
1766							;
1767							; exit:
1768							;
1769							; vduv.workspace._28 = minimum
1770							;
1771							; vduv.workspace._2c = maximum
1772							;
1773	.c8e4						prepareAABB:
1774	.c8e4		a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixels
1775	.c8e6		20 b5 d5	jsr $d5b5	                jsr sortVDUVariableCoordinates
1776	.c8e9		5a		phy		                phy                          ;save greater Y
1777	.c8ea		da		phx		                phx                          ;save lesser Y
1778	.c8eb		20 ca d5	jsr $d5ca	                jsr sortVDUVariableWords     ;X=lesser X, Y=greater X
1779	.c8ee		68		pla		                pla                          ;A=lesser Y
1780	.c8ef		5a		phy		                phy                          ;save greater X
1781	.c8f0		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
1782	.c8f2		20 f7 c8	jsr $c8f7	                jsr +
1783	.c8f5		fa		plx		                plx                          ;X=greater X
1784	.c8f6		68		pla		                pla                          ;A=greater Y
1785	.c8f7						+
1786							                ; Copy VDU variable word +X to VDU variable word+Y.
1787							                ; Then cropy VDU variable word +A+2 to VDU variable
1788							                ; word+Y+2. Return with updated Y.
1789	.c8f7		48		pha		                pha
1790	.c8f8		20 0a c9	jsr $c90a	                jsr copyTwoBytesWithinVDUVariables
1791	.c8fb		fa		plx		                plx
1792	.c8fc		e8		inx		                inx
1793	.c8fd		e8		inx		                inx
1794	.c8fe		80 0a		bra $c90a	                bra copyTwoBytesWithinVDUVariables

1796							;-------------------------------------------------------------------------
1797							;
1798							; Copy 8 bytes to workspace 28 in the VDU variables.
1799							;
1800							; entry:
1801							;
1802							; X = source offset
1803							;
1804	.c900						copyEightBytesToWorkspace28:
1805	.c900		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28

1807							;-------------------------------------------------------------------------
1808							;
1809							; Copy 8 bytes in the VDU variables.
1810							;
1811							; entry:
1812							;
1813							; X = source offset
1814							;
1815							; Y = dest offset
1816							;
1817	.c902						copyEightBytesWithinVDUVariables:
1818	.c902		a9 08		lda #$08	                lda #$08
1819	.c904		80 18		bra $c91e	                bra copyABytesWithinVDUVariables

1821							;-------------------------------------------------------------------------
1822							;
1823							; copyTextWindowWidthInBytesToWorkspace28
1824	.c906						copyTextWindowWidthInBytesToWorkspace28:
1825	.c906		a2 4c		ldx #$4c	                ldx #VDUVariables.textWindowWidthInBytes
1826	.c908		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28

1828							;-------------------------------------------------------------------------
1829							;
1830							;
1831	.c90a						copyTwoBytesWithinVDUVariables:
1832	.c90a		a9 02		lda #$02	                lda #$02
1833	.c90c		80 10		bra $c91e	                bra copyABytesWithinVDUVariables

1835							;-------------------------------------------------------------------------
1836							;
1837							; Copy text window info to workspace2C.
1838							;
1839	.c90e						copyTextWindowToWorkspace2C:
1840	.c90e		a2 08		ldx #$08	                ldx #VDUVariables.textWindowLeft
1841	.c910		a0 2c		ldy #$2c	                ldy #VDUVariables.workspace._2C
1842	.c912		80 08		bra $c91c	                bra copyFourBytesWithinVDUVariables

1844							;-------------------------------------------------------------------------
1845							;
1846							; Copy last 4 bytes of VDU queue somewhere.
1847							;
1848	.c914						copyLastFourVDUQueueBytes:
1849	.c914		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
1850	.c916		80 04		bra $c91c	                bra copyFourBytesWithinVDUVariables

1852							;-------------------------------------------------------------------------
1853							;
1854							; Copy old graphics cursor position to current graphics cursor position.
1855							;
1856	.c918						copyGraphicsCursorPixelsToOldGraphicsCursorPixels:
1857	.c918		a0 14		ldy #$14	                ldy #VDUVariables.oldGraphicsCursorPixelsX

1859							;-------------------------------------------------------------------------
1860							;
1861							; Copy the graphics cursor position somewhere.
1862							;
1863	.c91a						copyGraphicsCursorPixels:
1864	.c91a		a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX

1866							;-------------------------------------------------------------------------
1867							;
1868							; Copy 4 bytes in the VDU variables.
1869							;
1870							; entry:
1871							;
1872							; X = source offset
1873							;
1874							; Y = dest offset
1875							;
1876	.c91c						copyFourBytesWithinVDUVariables:
1877	.c91c		a9 04		lda #$04	                lda #$04

1879							                ; fall through to copyABytesWithinVDUVariables

1881							;-------------------------------------------------------------------------
1882							;
1883							; Copy some bytes in the VDU variables.
1884							;
1885							; entry:
1886							;
1887							; A = number of bytes
1888							;
1889							; X = source offset
1890							;
1891							; Y = dest offset
1892							;
1893							; exit:
1894							;
1895							; X = updated source offset
1896							;
1897							; Y = updated dest offset
1898							;
1899	.c91e						copyABytesWithinVDUVariables:
1900	.c91e		48		pha		                pha
1901	.c91f		bd 00 03	lda $0300,x	                lda vduv,x
1902	.c922		99 00 03	sta $0300,y	                sta vduv,y
1903	.c925		e8		inx		                inx
1904	.c926		c8		iny		                iny
1905	.c927		68		pla		                pla
1906	.c928		3a		dec a		                dec a
1907	.c929		d0 f3		bne $c91e	                bne copyABytesWithinVDUVariables
1908	.c92b		60		rts		                rts

1910							;-------------------------------------------------------------------------
1911							;
1912							; Negate a 16-bit value stored in Y/A
1913							;
1914							; entry:
1915							;
1916							; Y (LSB), A (MSB) = value
1917							;
1918							; exit:
1919							;
1920							; Y (LSB), A (MSB) = -value
1921							;
1922	.c92c						negateAY:
1923	.c92c		48		pha		                pha
1924	.c92d		98		tya		                tya
1925	.c92e		49 ff		eor #$ff	                eor #$FF
1926	.c930		a8		tay		                tay
1927	.c931		68		pla		                pla
1928	.c932		49 ff		eor #$ff	                eor #$FF
1929	.c934		c8		iny		                iny
1930	.c935		d0 01		bne $c938	                bne +
1931	.c937		1a		inc a		                inc a
1932	.c938						+
1933	.c938		60		rts		                rts

1935							;-------------------------------------------------------------------------
1936							;
1937							; Multiply a text window width by the number of bytes per char. There
1938							; are inclusive and exclusive versions, depending on how the width was
1939							; calculated.
1940							;
1941							; entry:
1942							;
1943							; A = value-1 to multiply (inclusive), value to multiply (exclusive)
1944							;
1945							; exit:
1946							;
1947							; A (lsb), X (msb) = value*vduv.bytesPerCharacter
1948							;
1949	.c939						getBytesPerInclusiveTextRow:
1950	.c939		1a		inc a		                inc a
1951	.c93a						getBytesPerExclusiveTextRow:
1952	.c93a		85 da		sta $da		                sta $DA
1953	.c93c		64 db		stz $db		                stz $DB
1954	.c93e		ad 4f 03	lda $034f	                lda vduv.bytesPerCharacter    ;A=1/8/16/32
1955	.c941						-
1956	.c941		4a		lsr a		                lsr a
1957	.c942		b0 06		bcs $c94a	                bcs +                     ;taken when multiply is done
1958	.c944		06 da		asl $da		                asl $DA              ;shift size LSB
1959	.c946		26 db		rol $db		                rol $DB              ;carry into size MSB
1960	.c948		80 f7		bra $c941	                bra -

1962	.c94a						+
1963	.c94a		a5 da		lda $da		                lda $DA
1964	.c94c		a6 db		ldx $db		                ldx $DB
1965	.c94e		60		rts		                rts

1967							;-------------------------------------------------------------------------
1968							;
1969							;
1970	.c94f						prepareForPlotBackground:
1971	.c94f		a2 08		ldx #$08	                ldx #$08                     ;plot background
1972	.c951		8e 59 03	stx $0359	                stx vduv.graphicsPlotState
1973	.c954		ad 5c 03	lda $035c	                lda vduv.backgroundGCOLMode
1974	.c957		29 0f		and #$0f	                and #$0F
1975	.c959		8d 5a 03	sta $035a	                sta vduv.graphicsPlotMode
1976	.c95c		60		rts		                rts

1978							;-------------------------------------------------------------------------

1980	.c95d						LC95F:
1981	.c95d		a9 00		lda #$00	                lda #$00
1982	.c95f		48		pha		                pha
1983	.c960		48		pha		                pha
1984	.c961		ae 2a 03	ldx $032a	                ldx $032A
1985	.c964		20 7b cc	jsr $cc7b	                jsr LCC7D
1986	.c967		80 14		bra $c97d	                bra LC97F

1988	.c969						LC96B:
1989	.c969		38		sec		                sec
1990	.c96a		ad 4f 03	lda $034f	                lda $034F
1991	.c96d		ed 2a 03	sbc $032a	                sbc $032A
1992	.c970		48		pha		                pha
1993	.c971		20 a0 e2	jsr $e2a0	                jsr getDefaultBoundsForCurrentScreenMODE
1994	.c974		da		phx		                phx
1995	.c975		a9 00		lda #$00	                lda #$00
1996	.c977		ae 2a 03	ldx $032a	                ldx $032A
1997	.c97a		20 5b cc	jsr $cc5b	                jsr LCC5D
1998	.c97d						LC97F:
1999							                ; scroll left/right
2000	.c97d		8e 50 03	stx $0350	                stx vduv.screenTopLeftAddress+0
2001	.c980		8d 51 03	sta $0351	                sta vduv.screenTopLeftAddress+1
2002	.c983		fa		plx		                plx
2003	.c984		a0 00		ldy #$00	                ldy #$00
2004	.c986		20 ae cc	jsr $ccae	                jsr getAddressForTextPosition
2005	.c989		fa		plx		                plx
2006	.c98a		a9 00		lda #$00	                lda #$00
2007	.c98c		20 5b cc	jsr $cc5b	                jsr LCC5D
2008	.c98f		86 d8		stx $d8		                stx ZMEMT+0
2009	.c991		85 d9		sta $d9		                sta ZMEMT+1
2010	.c993		20 a0 e2	jsr $e2a0	                jsr getDefaultBoundsForCurrentScreenMODE
2011	.c996		20 ac ca	jsr $caac	                jsr LCAAE
2012	.c999		80 1b		bra $c9b6	                bra LC9B8

2014	.c99b						LC99D:
2015	.c99b		a0 00		ldy #$00	                ldy #$00
2016	.c99d		20 75 cc	jsr $cc75	                jsr LCC77
2017	.c9a0		80 06		bra $c9a8	                bra LC9AA

2019	.c9a2						LC9A4:
2020	.c9a2		20 a0 e2	jsr $e2a0	                jsr getDefaultBoundsForCurrentScreenMODE
2021	.c9a5		20 55 cc	jsr $cc55	                jsr LCC57
2022	.c9a8						LC9AA:
2023	.c9a8		8e 50 03	stx $0350	                stx vduv.screenTopLeftAddress+0
2024	.c9ab		8d 51 03	sta $0351	                sta vduv.screenTopLeftAddress+1
2025	.c9ae		a2 00		ldx #$00	                ldx #$00
2026	.c9b0		20 ae cc	jsr $ccae	                jsr getAddressForTextPosition
2027	.c9b3		20 e6 ca	jsr $cae6	                jsr LCAE8
2028	.c9b6						LC9B8:
2029	.c9b6		a0 0c		ldy #$0c	                ldy #$0C
2030	.c9b8		ad 51 03	lda $0351	                lda vduv.screenTopLeftAddress+1
2031	.c9bb		ae 50 03	ldx $0350	                ldx vduv.screenTopLeftAddress+0
2032	.c9be		4c f5 c6	jmp $c6f5	                jmp setCRTCAddress

2034	.c9c1						LC9C3:
2035	.c9c1		20 9e cc	jsr $cc9e	                jsr LCCA0
2036	.c9c4						LC9C6:
2037	.c9c4		85 dd		sta $dd		                sta $DD
2038	.c9c6		86 dc		stx $dc		                stx $DC
2039	.c9c8		20 2a cc	jsr $cc2a	                jsr LCC2C
2040	.c9cb		ad 29 03	lda $0329	                lda $0329
2041	.c9ce		ae 28 03	ldx $0328	                ldx $0328
2042	.c9d1		20 5b cc	jsr $cc5b	                jsr LCC5D
2043	.c9d4		20 86 cc	jsr $cc86	                jsr LCC88
2044	.c9d7		86 d8		stx $d8		                stx ZMEMT+0
2045	.c9d9		85 d9		sta $d9		                sta ZMEMT+1
2046	.c9db		a9 00		lda #$00	                lda #$00
2047	.c9dd		ae 2a 03	ldx $032a	                ldx $032A
2048	.c9e0		20 7b cc	jsr $cc7b	                jsr LCC7D
2049	.c9e3		20 86 cc	jsr $cc86	                jsr LCC88
2050	.c9e6		86 da		stx $da		                stx $DA
2051	.c9e8		85 db		sta $db		                sta $DB
2052	.c9ea		ac 28 03	ldy $0328	                ldy $0328
2053	.c9ed		ae 29 03	ldx $0329	                ldx $0329
2054	.c9f0		50 23		bvc $ca15	                bvc LCA17
2055	.c9f2		a4 e0		ldy $e0		                ldy $E0
2056	.c9f4		a6 e1		ldx $e1		                ldx $E1
2057	.c9f6		20 e5 cb	jsr $cbe5	                jsr LCBE7
2058	.c9f9		a4 e0		ldy $e0		                ldy $E0
2059	.c9fb		90 09		bcc $ca06	                bcc LCA08
2060	.c9fd		a2 80		ldx #$80	                ldx #$80
2061	.c9ff		86 db		stx $db		                stx $DB
2062	.ca01		64 da		stz $da		                stz $DA
2063	.ca03		ac 2a 03	ldy $032a	                ldy $032A
2064	.ca06						LCA08:
2065	.ca06		a2 00		ldx #$00	                ldx #$00
2066	.ca08		20 f1 cb	jsr $cbf1	                jsr LCBF3
2067	.ca0b		a2 80		ldx #$80	                ldx #$80
2068	.ca0d		86 d9		stx $d9		                stx ZMEMT+1
2069	.ca0f		64 d8		stz $d8		                stz ZMEMT+0
2070	.ca11		a4 de		ldy $de		                ldy $DE
2071	.ca13		a6 df		ldx $df		                ldx $DF
2072	.ca15						LCA17:
2073	.ca15		20 e5 cb	jsr $cbe5	                jsr LCBE7
2074	.ca18		20 95 cc	jsr $cc95	                jsr LCC97
2075	.ca1b		20 92 cc	jsr $cc92	                jsr LCC94
2076	.ca1e		20 55 cc	jsr $cc55	                jsr LCC57
2077	.ca21		86 d8		stx $d8		                stx ZMEMT+0
2078	.ca23		85 d9		sta $d9		                sta ZMEMT+1
2079	.ca25		ce 2b 03	dec $032b	                dec $032B
2080	.ca28		10 9a		bpl $c9c4	                bpl LC9C6
2081	.ca2a		60		rts		                rts

2083	.ca2b						LCA2D:
2084	.ca2b		20 9e cc	jsr $cc9e	                jsr LCCA0
2085	.ca2e						LCA30:
2086	.ca2e		20 2a cc	jsr $cc2a	                jsr LCC2C
2087	.ca31		a9 00		lda #$00	                lda #$00
2088	.ca33		ae 2a 03	ldx $032a	                ldx $032A
2089	.ca36		20 5b cc	jsr $cc5b	                jsr LCC5D
2090	.ca39		86 da		stx $da		                stx $DA
2091	.ca3b		85 db		sta $db		                sta $DB
2092	.ca3d		20 55 cc	jsr $cc55	                jsr LCC57
2093	.ca40		86 dc		stx $dc		                stx $DC
2094	.ca42		85 dd		sta $dd		                sta $DD
2095	.ca44		ac 28 03	ldy $0328	                ldy $0328
2096	.ca47		ae 29 03	ldx $0329	                ldx $0329
2097	.ca4a		50 25		bvc $ca71	                bvc LCA73
2098	.ca4c		a4 de		ldy $de		                ldy $DE
2099	.ca4e		a6 df		ldx $df		                ldx $DF
2100	.ca50		20 a6 cb	jsr $cba6	                jsr LCBA8
2101	.ca53		a4 de		ldy $de		                ldy $DE
2102	.ca55		90 0a		bcc $ca61	                bcc LCA63
2103	.ca57		ae 4e 03	ldx $034e	                ldx $034E
2104	.ca5a		86 db		stx $db		                stx $DB
2105	.ca5c		64 da		stz $da		                stz $DA
2106	.ca5e		ac 2a 03	ldy $032a	                ldy $032A
2107	.ca61						LCA63:
2108	.ca61		a2 00		ldx #$00	                ldx #$00
2109	.ca63		20 b2 cb	jsr $cbb2	                jsr LCBB4
2110	.ca66		ae 4e 03	ldx $034e	                ldx $034E
2111	.ca69		86 d9		stx $d9		                stx ZMEMT+1
2112	.ca6b		64 d8		stz $d8		                stz ZMEMT+0
2113	.ca6d		a4 e0		ldy $e0		                ldy $E0
2114	.ca6f		a6 e1		ldx $e1		                ldx $E1
2115	.ca71						LCA73:
2116	.ca71		20 a6 cb	jsr $cba6	                jsr LCBA8
2117	.ca74		20 92 cc	jsr $cc92	                jsr LCC94
2118	.ca77		ce 2b 03	dec $032b	                dec $032B
2119	.ca7a		10 b2		bpl $ca2e	                bpl LCA30
2120	.ca7c						LCA7E:
2121	.ca7c		60		rts		                rts

2123	.ca7d						LCA7F:
2124	.ca7d		86 dc		stx $dc		                stx $DC
2125	.ca7f		aa		tax		                tax
2126	.ca80		38		sec		                sec
2127	.ca81		e5 dc		sbc $dc		                sbc $DC
2128	.ca83		f0 f7		beq $ca7c	                beq LCA7E
2129	.ca85		85 dd		sta $dd		                sta $DD
2130	.ca87		da		phx		                phx
2131	.ca88		20 3a c9	jsr $c93a	                jsr getBytesPerExclusiveTextRow
2132	.ca8b		fa		plx		                plx
2133	.ca8c		ad 66 03	lda $0366	                lda $0366
2134	.ca8f		89 08		bit #$08	                bit #$08
2135	.ca91		d0 0b		bne $ca9e	                bne LCAA0
2136	.ca93		89 02		bit #$02	                bit #$02
2137	.ca95		20 c8 cc	jsr $ccc8	                jsr LCCCA
2138	.ca98		a4 da		ldy $da		                ldy $DA
2139	.ca9a		a6 db		ldx $db		                ldx $DB
2140	.ca9c		80 2e		bra $cacc	                bra LCACE

2142	.ca9e						LCAA0:
2143	.ca9e		89 04		bit #$04	                bit #$04
2144	.caa0		20 c8 cc	jsr $ccc8	                jsr LCCCA
2145	.caa3		ad 4f 03	lda $034f	                lda $034F
2146	.caa6		8d 2a 03	sta $032a	                sta $032A
2147	.caa9		a4 dd		ldy $dd		                ldy $DD
2148	.caab		88		dey		                dey
2149	.caac						LCAAE:
2150	.caac		98		tya		                tya
2151	.caad		f0 18		beq $cac7	                beq LCAC9
2152	.caaf		84 dc		sty $dc		                sty $DC
2153	.cab1						LCAB3:
2154	.cab1		20 55 cc	jsr $cc55	                jsr LCC57
2155	.cab4		86 da		stx $da		                stx $DA
2156	.cab6		85 db		sta $db		                sta $DB
2157	.cab8		20 c7 ca	jsr $cac7	                jsr LCAC9
2158	.cabb		a6 da		ldx $da		                ldx $DA
2159	.cabd		86 d8		stx $d8		                stx ZMEMT+0
2160	.cabf		a5 db		lda $db		                lda $DB
2161	.cac1		85 d9		sta $d9		                sta ZMEMT+1
2162	.cac3		c6 dc		dec $dc		                dec $DC
2163	.cac5		d0 ea		bne $cab1	                bne LCAB3
2164	.cac7						LCAC9:
2165	.cac7		a2 00		ldx #$00	                ldx #$00
2166	.cac9		ac 2a 03	ldy $032a	                ldy $032A
2167	.cacc						LCACE:
2168	.cacc		ad 28 03	lda $0328	                lda $0328
2169	.cacf		48		pha		                pha
2170	.cad0		ad 29 03	lda $0329	                lda $0329
2171	.cad3		48		pha		                pha
2172	.cad4		8c 28 03	sty $0328	                sty $0328
2173	.cad7		8e 29 03	stx $0329	                stx $0329
2174	.cada		20 e6 ca	jsr $cae6	                jsr LCAE8
2175	.cadd		68		pla		                pla
2176	.cade		8d 29 03	sta $0329	                sta $0329
2177	.cae1		68		pla		                pla
2178	.cae2		8d 28 03	sta $0328	                sta $0328
2179	.cae5		60		rts		                rts

2181							;-------------------------------------------------------------------------

2183	.cae6						LCAE8:
2184	.cae6		a6 d8		ldx $d8		                ldx ZMEMT+0
2185	.cae8		a5 d9		lda $d9		                lda ZMEMT+1
2186	.caea		20 2a cc	jsr $cc2a	                jsr LCC2C
2187	.caed		80 79		bra $cb68	                bra LCB6A

2189							;-------------------------------------------------------------------------

2191	.caef						LCAF1:
2192	.caef		a2 75		ldx #$75	                ldx #<LCC77
2193	.caf1		a9 cc		lda #$cc	                lda #>LCC77
2194	.caf3		ac 2d 03	ldy $032d	                ldy $032D
2195	.caf6		80 07		bra $caff	                bra LCB01

2197	.caf8						LCAFA:
2198	.caf8		a2 55		ldx #$55	                ldx #<LCC57
2199	.cafa		a9 cc		lda #$cc	                lda #>LCC57
2200	.cafc		ac 2f 03	ldy $032f	                ldy $032F
2201	.caff						LCB01:
2202	.caff		8e 5d 03	stx $035d	                stx $035D
2203	.cb02		8d 5e 03	sta $035e	                sta $035E
2204	.cb05		38		sec		                sec
2205	.cb06		ad 2d 03	lda $032d	                lda $032D
2206	.cb09		ed 2f 03	sbc $032f	                sbc $032F
2207	.cb0c		8d 2b 03	sta $032b	                sta $032B
2208	.cb0f		ae 2c 03	ldx $032c	                ldx $032C
2209	.cb12		20 ae cc	jsr $ccae	                jsr getAddressForTextPosition
2210	.cb15		85 dd		sta $dd		                sta $DD
2211	.cb17		86 dc		stx $dc		                stx $DC
2212	.cb19		20 2a cc	jsr $cc2a	                jsr LCC2C
2213	.cb1c		ad 2b 03	lda $032b	                lda $032B
2214	.cb1f		f0 47		beq $cb68	                beq LCB6A
2215	.cb21						LCB23:
2216	.cb21		08		php		                php
2217	.cb22		20 24 c0	jsr $c024	                jsr LC024
2218	.cb25		86 da		stx $da		                stx $DA
2219	.cb27		85 db		sta $db		                sta $DB
2220	.cb29		86 dc		stx $dc		                stx $DC
2221	.cb2b		85 dd		sta $dd		                sta $DD
2222	.cb2d		28		plp		                plp
2223	.cb2e		50 1d		bvc $cb4d	                bvc LCB4F
2224	.cb30		b8		clv		                clv
2225	.cb31						LCB33:
2226	.cb31		a6 df		ldx $df		                ldx $DF
2227	.cb33		a4 de		ldy $de		                ldy $DE
2228	.cb35		20 b2 cb	jsr $cbb2	                jsr LCBB4
2229	.cb38		ad 4e 03	lda $034e	                lda $034E
2230	.cb3b		70 06		bvs $cb43	                bvs LCB45
2231	.cb3d		85 d9		sta $d9		                sta ZMEMT+1
2232	.cb3f		64 d8		stz $d8		                stz ZMEMT+0
2233	.cb41		80 04		bra $cb47	                bra LCB49

2235	.cb43						LCB45:
2236	.cb43		85 db		sta $db		                sta $DB
2237	.cb45		64 da		stz $da		                stz $DA
2238	.cb47						LCB49:
2239	.cb47		a6 e1		ldx $e1		                ldx $E1
2240	.cb49		a4 e0		ldy $e0		                ldy $E0
2241	.cb4b		80 0b		bra $cb58	                bra LCB5A

2243	.cb4d						LCB4F:
2244	.cb4d		20 2a cc	jsr $cc2a	                jsr LCC2C
2245	.cb50		70 df		bvs $cb31	                bvs LCB33
2246	.cb52		ae 29 03	ldx $0329	                ldx $0329
2247	.cb55		ac 28 03	ldy $0328	                ldy $0328
2248	.cb58						LCB5A:
2249	.cb58		20 b2 cb	jsr $cbb2	                jsr LCBB4
2250	.cb5b		a6 dc		ldx $dc		                ldx $DC
2251	.cb5d		86 d8		stx $d8		                stx ZMEMT+0
2252	.cb5f		a5 dd		lda $dd		                lda $DD
2253	.cb61		85 d9		sta $d9		                sta ZMEMT+1
2254	.cb63		ce 2b 03	dec $032b	                dec $032B
2255	.cb66		d0 b9		bne $cb21	                bne LCB23
2256	.cb68						LCB6A:
2257	.cb68		ae 29 03	ldx $0329	                ldx $0329
2258	.cb6b		ac 28 03	ldy $0328	                ldy $0328
2259	.cb6e		50 12		bvc $cb82	                bvc clearTextMemory
2260	.cb70		a6 df		ldx $df		                ldx $DF
2261	.cb72		a4 de		ldy $de		                ldy $DE
2262	.cb74		20 82 cb	jsr $cb82	                jsr clearTextMemory
2263	.cb77		ad 4e 03	lda $034e	                lda $034E
2264	.cb7a		85 d9		sta $d9		                sta ZMEMT+1
2265	.cb7c		64 d8		stz $d8		                stz ZMEMT+0
2266	.cb7e		a6 e1		ldx $e1		                ldx $E1
2267	.cb80		a4 e0		ldy $e0		                ldy $E0

2269							;-------------------------------------------------------------------------
2270							;
2271							; Clear a block of text screen memory.
2272							;
2273							; entry:
2274							;
2275							; (ZMEMT),y - first byte to clear
2276							;
2277							; X = number of pages (including first, possibly partial page) to clear
2278							;
2279	.cb82						clearTextMemory:
2280							                ; align memory so that Y=0 on each page boundary
2281							                ; crossing.
2282							                ;
2283							                ; e.g., on entry ZMEMT=$30f8, Y=$08 - then after,
2284							                ; ZMEMT=$3000, Y=$F7; or, ZMEMT=$30f0, Y=$08 -> ZMEMT=$2ff8, Y=$F7.
2285	.cb82		98		tya		                tya                          ;A=initial offset
2286	.cb83		18		clc		                clc
2287	.cb84		65 d8		adc $d8		                adc ZMEMT+0                  ;add to dest address
2288	.cb86		85 d8		sta $d8		                sta ZMEMT+0
2289	.cb88		b0 02		bcs $cb8c	                bcs +
2290	.cb8a		c6 d9		dec $d9		                dec ZMEMT+1
2291	.cb8c						+
2292	.cb8c		98		tya		                tya
2293	.cb8d		49 ff		eor #$ff	                eor #$FF
2294	.cb8f		a8		tay		                tay
2295	.cb90		4a		lsr a		                lsr a                        ;C set if odd
2296	.cb91		ad 58 03	lda $0358	                lda vduv.backgroundTextColour
2297	.cb94		b0 07		bcs $cb9d	                bcs nextByte                    ;taken if odd - slightly different loop
2298	.cb96		80 02		bra $cb9a	                bra clearTextMemoryByte

2300	.cb98						clearTextMemoryLoop:
2301	.cb98		91 d8		sta ($d8),y	                sta (ZMEMT),y
2302	.cb9a						clearTextMemoryByte:
2303	.cb9a		c8		iny		                iny
2304	.cb9b		91 d8		sta ($d8),y	                sta (ZMEMT),y
2305	.cb9d						nextByte:
2306	.cb9d		c8		iny		                iny
2307	.cb9e		d0 f8		bne $cb98	                bne clearTextMemoryLoop
2308	.cba0		e6 d9		inc $d9		                inc ZMEMT+1
2309	.cba2		ca		dex		                dex
2310	.cba3		10 f3		bpl $cb98	                bpl clearTextMemoryLoop
2311	.cba5		60		rts		                rts

2313							;-------------------------------------------------------------------------

2315	.cba6						LCBA8:
2316	.cba6		38		sec		                sec
2317	.cba7		98		tya		                tya
2318	.cba8		ed 2a 03	sbc $032a	                sbc $032A
2319	.cbab		a8		tay		                tay
2320	.cbac		b0 04		bcs $cbb2	                bcs LCBB4
2321	.cbae		ca		dex		                dex
2322	.cbaf		30 33		bmi $cbe4	                bmi LCBE6
2323	.cbb1		38		sec		                sec
2324	.cbb2						LCBB4:
2325	.cbb2		08		php		                php
2326	.cbb3		98		tya		                tya
2327	.cbb4		18		clc		                clc
2328	.cbb5		65 da		adc $da		                adc ZTEMP+0
2329	.cbb7		85 da		sta $da		                sta ZTEMP+0
2330	.cbb9		b0 02		bcs $cbbd	                bcs LCBBF
2331	.cbbb		c6 db		dec $db		                dec ZTEMP+1
2332	.cbbd						LCBBF:
2333	.cbbd		98		tya		                tya
2334	.cbbe		18		clc		                clc
2335	.cbbf		65 d8		adc $d8		                adc ZMEMT+0
2336	.cbc1		85 d8		sta $d8		                sta ZMEMT+0
2337	.cbc3		b0 02		bcs $cbc7	                bcs LCBC9
2338	.cbc5		c6 d9		dec $d9		                dec ZMEMT+1
2339	.cbc7						LCBC9:
2340	.cbc7		98		tya		                tya
2341	.cbc8		49 ff		eor #$ff	                eor #$FF
2342	.cbca		a8		tay		                tay
2343	.cbcb		4a		lsr a		                lsr a
2344	.cbcc		b0 0b		bcs $cbd9	                bcs LCBDB
2345	.cbce		80 04		bra $cbd4	                bra LCBD6

2347	.cbd0						LCBD2:
2348	.cbd0		b1 da		lda ($da),y	                lda ($DA),y
2349	.cbd2		91 d8		sta ($d8),y	                sta (ZMEMT),y
2350	.cbd4						LCBD6:
2351	.cbd4		c8		iny		                iny
2352	.cbd5		b1 da		lda ($da),y	                lda ($DA),y
2353	.cbd7		91 d8		sta ($d8),y	                sta (ZMEMT),y
2354	.cbd9						LCBDB:
2355	.cbd9		c8		iny		                iny
2356	.cbda		d0 f4		bne $cbd0	                bne LCBD2
2357	.cbdc		e6 db		inc $db		                inc $DB
2358	.cbde		e6 d9		inc $d9		                inc ZMEMT+1
2359	.cbe0		ca		dex		                dex
2360	.cbe1		10 ed		bpl $cbd0	                bpl LCBD2
2361	.cbe3						LCBE5:
2362	.cbe3		28		plp		                plp
2363	.cbe4						LCBE6:
2364	.cbe4		60		rts		                rts

2366	.cbe5						LCBE7:
2367	.cbe5		38		sec		                sec
2368	.cbe6		98		tya		                tya
2369	.cbe7		ed 2a 03	sbc $032a	                sbc $032A
2370	.cbea		a8		tay		                tay
2371	.cbeb		b0 04		bcs $cbf1	                bcs LCBF3
2372	.cbed		ca		dex		                dex
2373	.cbee		30 f4		bmi $cbe4	                bmi LCBE6
2374	.cbf0		38		sec		                sec
2375	.cbf1						LCBF3:
2376	.cbf1		08		php		                php
2377	.cbf2		98		tya		                tya
2378	.cbf3		49 ff		eor #$ff	                eor #$FF
2379	.cbf5		48		pha		                pha
2380	.cbf6		38		sec		                sec
2381	.cbf7		65 da		adc $da		                adc $DA
2382	.cbf9		85 da		sta $da		                sta $DA
2383	.cbfb		b0 02		bcs $cbff	                bcs LCC01
2384	.cbfd		c6 db		dec $db		                dec $DB
2385	.cbff						LCC01:
2386	.cbff		68		pla		                pla
2387	.cc00		38		sec		                sec
2388	.cc01		65 d8		adc $d8		                adc ZMEMT+0
2389	.cc03		85 d8		sta $d8		                sta ZMEMT+0
2390	.cc05		b0 02		bcs $cc09	                bcs LCC0B
2391	.cc07		c6 d9		dec $d9		                dec ZMEMT+1
2392	.cc09						LCC0B:
2393	.cc09		98		tya		                tya
2394	.cc0a		4a		lsr a		                lsr a
2395	.cc0b		b0 14		bcs $cc21	                bcs LCC23
2396	.cc0d		d0 0d		bne $cc1c	                bne LCC1E
2397	.cc0f						LCC11:
2398	.cc0f		ca		dex		                dex
2399	.cc10		30 d1		bmi $cbe3	                bmi LCBE5
2400	.cc12		c6 db		dec $db		                dec $DB
2401	.cc14		c6 d9		dec $d9		                dec ZMEMT+1
2402	.cc16		80 04		bra $cc1c	                bra LCC1E

2404	.cc18						LCC1A:
2405	.cc18		b1 da		lda ($da),y	                lda ($DA),y
2406	.cc1a		91 d8		sta ($d8),y	                sta (ZMEMT),y
2407	.cc1c						LCC1E:
2408	.cc1c		88		dey		                dey
2409	.cc1d		b1 da		lda ($da),y	                lda ($DA),y
2410	.cc1f		91 d8		sta ($d8),y	                sta (ZMEMT),y
2411	.cc21						LCC23:
2412	.cc21		88		dey		                dey
2413	.cc22		d0 f4		bne $cc18	                bne LCC1A
2414	.cc24		b2 da		lda ($da)	                lda ($DA)
2415	.cc26		92 d8		sta ($d8)	                sta (ZMEMT)
2416	.cc28		80 e5		bra $cc0f	                bra LCC11

2418							;-------------------------------------------------------------------------
2419							;
2420							; Get pointers for a text window row.
2421							;
2422							; entry:
2423							;
2424							; vduv.workspace._28; = text window stride, in bytes
2425							;
2426							; >A, <X = address
2427							;
2428							; exit:
2429							;
2430							; V=0: >A, <X = new address
2431							;
2432							; V=1: (ZTEMPC) =

2434	.cc2a						LCC2C:
2435	.cc2a		48		pha		                pha                          ;save >address
2436	.cc2b		8a		txa		                txa                          ;A=<address
2437	.cc2c		18		clc		                clc
2438	.cc2d		6d 28 03	adc $0328	                adc vduv.workspace._28       ;A=<(new address)
2439	.cc30		aa		tax		                tax                          ;X=<(new address)
2440	.cc31		68		pla		                pla                          ;restore >addcess
2441	.cc32		6d 29 03	adc $0329	                adc vduv.workspace._29       ;A=>(new address)
2442	.cc35		50 1d		bvc $cc54	                bvc rtsCC56                  ;taken if no address wrap
2443	.cc37		86 e0		stx $e0		                stx ZTEMPD+0
2444	.cc39		29 7f		and #$7f	                and #$7F                     ;
2445	.cc3b		85 e1		sta $e1		                sta ZTEMPD+1
2446	.cc3d		05 e0		ora $e0		                ora ZTEMPD+0
2447	.cc3f		f0 12		beq $cc53	                beq clv_rts
2448	.cc41		08		php		                php
2449	.cc42		38		sec		                sec
2450	.cc43		ad 28 03	lda $0328	                lda vduv.workspace._28
2451	.cc46		e5 e0		sbc $e0		                sbc ZTEMPD+0
2452	.cc48		85 de		sta $de		                sta ZTEMPC+0
2453	.cc4a		ad 29 03	lda $0329	                lda vduv.workspace._29
2454	.cc4d		e5 e1		sbc $e1		                sbc ZTEMPD+1
2455	.cc4f		85 df		sta $df		                sta ZTEMPC+1
2456	.cc51		28		plp		                plp
2457	.cc52		60		rts		                rts

2459							;-------------------------------------------------------------------------

2461	.cc53						clv_rts:
2462	.cc53		b8		clv		                clv
2463	.cc54						rtsCC56:
2464	.cc54		60		rts		                rts

2466	.cc55						LCC57:
2467	.cc55		ad 53 03	lda $0353	                lda vduv.bytesPerCharacterRow+1
2468	.cc58		ae 52 03	ldx $0352	                ldx vduv.bytesPerCharacterRow+0
2469	.cc5b						LCC5D:
2470	.cc5b		18		clc		                clc
2471	.cc5c						LCC5E:
2472	.cc5c		08		php		                php
2473	.cc5d		48		pha		                pha
2474	.cc5e		8a		txa		                txa
2475	.cc5f		65 d8		adc $d8		                adc ZMEMT+0
2476	.cc61		aa		tax		                tax
2477	.cc62		68		pla		                pla
2478	.cc63		65 d9		adc $d9		                adc ZMEMT+1
2479	.cc65		10 04		bpl $cc6b	                bpl +
2480	.cc67		38		sec		                sec
2481	.cc68		ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte ;handle wraparound at end
2482	.cc6b						+
2483	.cc6b		cd 4e 03	cmp $034e	                cmp vduv.startScreenAddressHighByte
2484	.cc6e		b0 03		bcs $cc73	                bcs +
2485	.cc70		6d 54 03	adc $0354	                adc vduv.screenSizeHighByte ;handle wraparound at start
2486	.cc73						+
2487	.cc73		28		plp		                plp
2488	.cc74		60		rts		                rts

2490	.cc75						LCC77:
2491	.cc75		ad 53 03	lda $0353	                lda $0353
2492	.cc78		ae 52 03	ldx $0352	                ldx $0352
2493	.cc7b						LCC7D:
2494	.cc7b		48		pha		                pha
2495	.cc7c		8a		txa		                txa
2496	.cc7d		49 ff		eor #$ff	                eor #$FF
2497	.cc7f		aa		tax		                tax
2498	.cc80		68		pla		                pla
2499	.cc81		49 ff		eor #$ff	                eor #$FF
2500	.cc83		38		sec		                sec
2501	.cc84		80 d6		bra $cc5c	                bra LCC5E

2503	.cc86						LCC88:
2504	.cc86		cd 4e 03	cmp $034e	                cmp $034E
2505	.cc89		d0 06		bne $cc91	                bne LCC93
2506	.cc8b		e0 00		cpx #$00	                cpx #$00
2507	.cc8d		d0 02		bne $cc91	                bne LCC93
2508	.cc8f		a9 80		lda #$80	                lda #$80
2509	.cc91						LCC93:
2510	.cc91		60		rts		                rts

2512	.cc92						LCC94:
2513	.cc92		20 c7 ca	jsr $cac7	                jsr LCAC9
2514	.cc95						LCC97:
2515	.cc95		a6 dc		ldx $dc		                ldx $DC
2516	.cc97		86 d8		stx $d8		                stx ZMEMT+0
2517	.cc99		a5 dd		lda $dd		                lda $DD
2518	.cc9b		85 d9		sta $d9		                sta ZMEMT+1
2519	.cc9d		60		rts		                rts

2521	.cc9e						LCCA0:
2522	.cc9e		38		sec		                sec
2523	.cc9f		ad 2d 03	lda $032d	                lda $032D
2524	.cca2		ed 2f 03	sbc $032f	                sbc $032F
2525	.cca5		8d 2b 03	sta $032b	                sta $032B
2526	.cca8		ae 2c 03	ldx $032c	                ldx $032C
2527	.ccab		ac 2f 03	ldy $032f	                ldy $032F

2529							;-------------------------------------------------------------------------
2530							;
2531							; Get display address for a text position.
2532							;
2533	.ccae						getAddressForTextPosition:
2534	.ccae		ad 18 03	lda $0318	                lda vduv.textCursorXPosition
2535	.ccb1		48		pha		                pha
2536	.ccb2		ad 19 03	lda $0319	                lda vduv.textCursorYPosition
2537	.ccb5		48		pha		                pha
2538	.ccb6		8e 18 03	stx $0318	                stx vduv.textCursorXPosition
2539	.ccb9		8c 19 03	sty $0319	                sty vduv.textCursorYPosition
2540	.ccbc		20 f8 cc	jsr $ccf8	                jsr updateZMEMTWithTextCursorPosition
2541	.ccbf		7a		ply		                ply
2542	.ccc0		8c 19 03	sty $0319	                sty vduv.textCursorYPosition
2543	.ccc3		7a		ply		                ply
2544	.ccc4		8c 18 03	sty $0318	                sty vduv.textCursorXPosition
2545	.ccc7		60		rts		                rts

2547							;-------------------------------------------------------------------------

2549	.ccc8						LCCCA:
2550	.ccc8		f0 03		beq $cccd	                beq LCCCF
2551	.ccca		ca		dex		                dex
2552	.cccb		86 dc		stx $dc		                stx ZTEMPB+0
2553	.cccd						LCCCF:
2554	.cccd		ad 66 03	lda $0366	                lda vduv.cursorFlags
2555	.ccd0		29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
2556	.ccd2		aa		tax		                tax
2557	.ccd3		a5 dc		lda $dc		                lda ZTEMPB+0
2558	.ccd5						LCCD7:
2559	.ccd5		20 c7 c2	jsr $c2c7	                jsr setTextCursorXPositionWithCursorFlags
2560	.ccd8						LCCDA:
2561	.ccd8		ae 18 03	ldx $0318	                ldx vduv.textCursorXPosition
2562	.ccdb		ec 08 03	cpx $0308	                cpx vduv.textWindowLeft
2563	.ccde		30 16		bmi $ccf6	                bmi LCCF8            ;taken if off left edge of window
2564	.cce0		ec 0a 03	cpx $030a	                cpx vduv.textWindowRight
2565	.cce3		f0 02		beq $cce7	                beq LCCE9            ;taken if at right edge of window
2566	.cce5		10 0f		bpl $ccf6	                bpl LCCF8            ;taken if off right edge of window
2567	.cce7						LCCE9:
2568	.cce7		ae 19 03	ldx $0319	                ldx vduv.textCursorYPosition
2569	.ccea		ec 0b 03	cpx $030b	                cpx vduv.textWindowTop
2570	.cced		30 07		bmi $ccf6	                bmi LCCF8
2571	.ccef		ec 09 03	cpx $0309	                cpx vduv.textWindowBottom
2572	.ccf2		30 04		bmi $ccf8	                bmi updateZMEMTWithTextCursorPosition
2573	.ccf4		f0 02		beq $ccf8	                beq updateZMEMTWithTextCursorPosition
2574	.ccf6						LCCF8:
2575	.ccf6		38		sec		                sec
2576	.ccf7		60		rts		                rts

2578							;-------------------------------------------------------------------------
2579							;
2580							; Get display address for current text cursor position.
2581							;
2582							; Set up display address without using BBC lookup table at &E0/1
2583							;
2584	.ccf8						updateZMEMTWithTextCursorPosition:
2585	.ccf8		ad 56 03	lda $0356	                lda vduv.currentScreenMODEGroup
2586	.ccfb		29 fe		and #$fe	                and #$fe                     ; Reduce to 0,0,2,2,4
2587	.ccfd		aa		tax		                tax                          ; Index into jump table
2588	.ccfe		ac 19 03	ldy $0319	                ldy vduv.textCursorYPosition  ; Get current line
2589	.cd01		7c 04 cd	jmp ($cd04,x)	                jmp (multiplyRoutinesTable,x) ; Jump to calculation setup

2591	.cd04						multiplyRoutinesTable:
2592	>cd04		1f cd				                .word multiplyBy640     ; Memory map 0,1  MODE 0,1,2,3
2593	>cd06		13 cd				                .word multiplyBy320       ; Memory map 2,3  MODE 4,5,6
2594	>cd08		0a cd				                .word multiplyBy40        ; Memory map 4    MODE 7

2596	.cd0a						multiplyBy40:
2597	.cd0a		be ad e0	ldx $e0ad,y	                ldx multiplyBy40TableHigh,y ; Get offset high byte for start of this line
2598	.cd0d		b9 c6 e0	lda $e0c6,y	                lda multiplyBy40TableLow,y ; Get offset low byte for start of this line
2599	.cd10		18		clc		                clc
2600	.cd11		80 14		bra $cd27	                bra LCD29

2602	.cd13						multiplyBy320:
2603	.cd13		b9 df e0	lda $e0df,y	                lda multiplyBy640TableHigh,y
2604	.cd16		4a		lsr a		                lsr a
2605	.cd17		aa		tax		                tax
2606	.cd18		98		tya		                tya
2607	.cd19		29 03		and #$03	                and #$03
2608	.cd1b		4a		lsr a		                lsr a
2609	.cd1c		6a		ror a		                ror a
2610	.cd1d		80 07		bra $cd26	                bra LCD28

2612	.cd1f						multiplyBy640:
2613	.cd1f		be df e0	ldx $e0df,y	                ldx multiplyBy640TableHigh,y
2614	.cd22		98		tya		                tya
2615	.cd23		29 01		and #$01	                and #$01
2616	.cd25		4a		lsr a		                lsr a
2617	.cd26						LCD28:
2618	.cd26		6a		ror a		                ror a                        ; A=A/2 +(128*carry)

2620	.cd27						LCD29:
2621	.cd27		6d 50 03	adc $0350	                adc vduv.screenTopLeftAddress+0
2622	.cd2a		85 d8		sta $d8		                sta ZMEMT+0                      ; store it
2623	.cd2c		8a		txa		                txa
2624	.cd2d		6d 51 03	adc $0351	                adc vduv.screenTopLeftAddress+1 ; window start address hi
2625	.cd30		a8		tay		                tay
2626	.cd31		ad 18 03	lda $0318	                lda vduv.textCursorXPosition  ; text column
2627	.cd34		ae 4f 03	ldx $034f	                ldx vduv.bytesPerCharacter    ; bytes per character
2628	.cd37		ca		dex		                dex
2629	.cd38		f0 12		beq $cd4c	                beq LCD4E                    ; 1 colour, MODE 7
2630	.cd3a		e0 0f		cpx #$0f	                cpx #$0F
2631	.cd3c		f0 03		beq $cd41	                beq LCD43                    ; 4 colours, MODE 1 or MODE 5
2632	.cd3e		90 02		bcc $cd42	                bcc LCD44                    ; 2 colours, MODE 0,3,4,6
2633	.cd40		0a		asl a		                asl a                        ; 16 colours, MODE 2
2634	.cd41						LCD43:
2635	.cd41		0a		asl a		                asl a
2636	.cd42						LCD44:
2637	.cd42		0a		asl a		                asl a
2638	.cd43		0a		asl a		                asl a
2639	.cd44		90 02		bcc $cd48	                bcc LCD4A
2640	.cd46		c8		iny		                iny
2641	.cd47		c8		iny		                iny
2642	.cd48						LCD4A:
2643	.cd48		0a		asl a		                asl a
2644	.cd49		90 02		bcc $cd4d	                bcc LCD4F
2645	.cd4b		c8		iny		                iny
2646	.cd4c						LCD4E:
2647	.cd4c		18		clc		                clc
2648	.cd4d						LCD4F:
2649	.cd4d		65 d8		adc $d8		                adc ZMEMT+0
2650	.cd4f		85 d8		sta $d8		                sta ZMEMT+0
2651	.cd51		8d 4a 03	sta $034a	                sta vduv.textCursorCRTCAddress+0
2652	.cd54		aa		tax		                tax
2653	.cd55		98		tya		                tya
2654	.cd56		69 00		adc #$00	                adc #$00
2655	.cd58		8d 4b 03	sta $034b	                sta vduv.textCursorCRTCAddress+1
2656	.cd5b		10 04		bpl $cd61	                bpl LCD63
2657	.cd5d		38		sec		                sec
2658	.cd5e		ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte
2659	.cd61						LCD63:
2660	.cd61		85 d9		sta $d9		                sta ZMEMT+1
2661	.cd63		18		clc		                clc
2662	.cd64		60		rts		                rts

2664							;-------------------------------------------------------------------------

2666	.cd65						nextMaskedCharColumn
2667	.cd65		ee 24 03	inc $0324	                inc vduv.graphicsCursorPixelsX+0
2668	.cd68		d0 03		bne $cd6d	                bne +
2669	.cd6a		ee 25 03	inc $0325	                inc vduv.graphicsCursorPixelsX+1
2670	.cd6d						+
2671	.cd6d		0a		asl a		                asl a
2672	.cd6e						plotMaskedCharRow:
2673							                ; find next pixel to plot, updating graphics cursor X
2674							                ; as it goes. A is non-zero, so this loop will finish
2675							                ; eventually.
2676	.cd6e		10 f5		bpl $cd65	                bpl nextMaskedCharColumn
2677	.cd70		5a		phy		                phy
2678	.cd71		85 dd		sta $dd		                sta ZTEMPB+1                 ;
2679	.cd73		a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixels
2680	.cd75		20 c6 de	jsr $dec6	                jsr gaddrEntryPoint
2681	.cd78		80 02		bra $cd7c	                bra plotMaskedCharPixel

2683	.cd7a						plotMaskedCharPixelsLoop:
2684	.cd7a		10 03		bpl $cd7f	                bpl nextMaskedCharPixel
2685	.cd7c						plotMaskedCharPixel:
2686	.cd7c		20 4f db	jsr $db4f	                jsr plbyteEntryPoint
2687	.cd7f						nextMaskedCharPixel
2688	.cd7f		46 d1		lsr $d1		                lsr ZMASK
2689	.cd81		90 03		bcc $cd86	                bcc +
2690	.cd83		20 65 da	jsr $da65	                jsr nextColumnAndResetMask
2691	.cd86						+
2692	.cd86		06 dd		asl $dd		                asl ZTEMPB+1
2693	.cd88		d0 f0		bne $cd7a	                bne plotMaskedCharPixelsLoop
2694	.cd8a		a2 28		ldx #$28	                ldx #VDUVariables.workspace._28
2695	.cd8c		a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixelsX
2696	.cd8e		20 0a c9	jsr $c90a	                jsr copyTwoBytesWithinVDUVariables
2697	.cd91		7a		ply		                ply
2698	.cd92		80 50		bra $cde4	                bra nextMaskedCharY

2700	.cd94						plotCharAtGraphicsCursor:
2701	.cd94		20 2a e2	jsr $e22a	                jsr getSoftCharacterDefinitionAddress
2702	.cd97		9c 59 03	stz $0359	                stz vduv.graphicsPlotState   ;plot in foreground colour
2703	.cd9a		ad 5b 03	lda $035b	                lda vduv.foregroundGCOLMode
2704	.cd9d		29 0f		and #$0f	                and #$0F
2705	.cd9f						plotFontDataAtGraphicsCursorWithPlotMode:
2706	.cd9f		8d 5a 03	sta $035a	                sta vduv.graphicsPlotMode
2707	.cda2		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
2708	.cda4		20 1a c9	jsr $c91a	                jsr copyGraphicsCursorPixels
2709	.cda7		a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixelsX
2710	.cda9		a2 00		ldx #$00	                ldx #VDUVariables.graphicsWindowPixelsLeft
2711	.cdab		20 b2 ce	jsr $ceb2	                jsr getDistanceMask
2712	.cdae		85 dc		sta $dc		                sta ZTEMPB+0
2713	.cdb0		a2 04		ldx #$04	                ldx #VDUVariables.graphicsWindowPixelsRight
2714	.cdb2		20 b2 ce	jsr $ceb2	                jsr getDistanceMask
2715	.cdb5		6a		ror a		                ror a
2716	.cdb6		14 dc		trb $dc		                trb ZTEMPB+0
2717	.cdb8		a2 26		ldx #$26	                ldx #VDUVariables.graphicsCursorPixelsY
2718	.cdba		a0 06		ldy #$06	                ldy #VDUVariables.graphicsWindowPixelsTop
2719	.cdbc		20 b2 ce	jsr $ceb2	                jsr getDistanceMask
2720	.cdbf		85 dd		sta $dd		                sta ZTEMPB+1
2721	.cdc1		a2 26		ldx #$26	                ldx #VDUVariables.graphicsCursorPixelsY
2722	.cdc3		a0 02		ldy #$02	                ldy #VDUVariables.graphicsWindowPixelsBottom
2723	.cdc5		20 b2 ce	jsr $ceb2	                jsr getDistanceMask
2724	.cdc8		6a		ror a		                ror a
2725	.cdc9		14 dd		trb $dd		                trb ZTEMPB+1
2726	.cdcb		a0 07		ldy #$07	                ldy #$07
2727	.cdcd						copyMaskedCharLoop:
2728	.cdcd		b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte
2729	.cdcf		25 dc		and $dc		                and ZTEMPB+0                 ;mask out columns
2730	.cdd1		46 dd		lsr $dd		                lsr ZTEMPB+1                 ;test row
2731	.cdd3		b0 02		bcs $cdd7	                bcs +
2732	.cdd5		a9 00		lda #$00	                lda #$00                     ;mask out this row
2733	.cdd7						+
2734	.cdd7		99 2c 03	sta $032c,y	                sta vduv.workspace._2C,y
2735	.cdda		88		dey		                dey
2736	.cddb		10 f0		bpl $cdcd	                bpl copyMaskedCharLoop
2737	.cddd		a0 f8		ldy #$f8	                ldy #$F8
2738	.cddf						plotMaskedCharLoop:
2739	.cddf		b9 34 02	lda $0234,y	                lda vduv.workspace._2C-$f8,y ;get masked byte
2740	.cde2		d0 8a		bne $cd6e	                bne plotMaskedCharRow        ;taken if data to write
2741	.cde4						nextMaskedCharY:
2742	.cde4		ae 26 03	ldx $0326	                ldx vduv.graphicsCursorPixelsY+0
2743	.cde7		d0 03		bne $cdec	                bne +
2744	.cde9		ce 27 03	dec $0327	                dec vduv.graphicsCursorPixelsY+1
2745	.cdec						+
2746	.cdec		ce 26 03	dec $0326	                dec vduv.graphicsCursorPixelsY+0
2747	.cdef		c8		iny		                iny
2748	.cdf0		d0 ed		bne $cddf	                bne plotMaskedCharLoop
2749	.cdf2		a2 2a		ldx #$2a	                ldx #VDUVariables.workspace._2A
2750	.cdf4		a0 26		ldy #$26	                ldy #VDUVariables.graphicsCursorPixelsY
2751	.cdf6		4c 0a c9	jmp $c90a	                jmp copyTwoBytesWithinVDUVariables

2753	.cdf9						vdu127AtGraphicsCursor:
2754							                ; CHR$127 is a solid block, not a backspace.
2755	.cdf9		a9 f8		lda #$f8	                lda #<chr127
2756	.cdfb		85 de		sta $de		                sta ZTEMPC+0
2757	.cdfd		a9 bb		lda #$bb	                lda #>chr127
2758	.cdff		85 df		sta $df		                sta ZTEMPC+1
2759	.ce01		a2 08		ldx #$08	                ldx #$08
2760	.ce03		8e 59 03	stx $0359	                stx vduv.graphicsPlotState   ;plot in background colour
2761	.ce06		a9 00		lda #$00	                lda #$00
2762	.ce08		80 95		bra $cd9f	                bra plotFontDataAtGraphicsCursorWithPlotMode

2764	.ce0a						LCE0C:
2765	.ce0a		20 2b d1	jsr $d12b	                jsr handleColumn81
2766	.ce0d		b0 85		bcs $cd94	                bcs plotCharAtGraphicsCursor          ;taken if VDU5
2767	.ce0f		ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
2768	.ce12		f0 37		beq $ce4b	                beq writeTeletextChar
2769	.ce14		20 2a e2	jsr $e22a	                jsr getSoftCharacterDefinitionAddress
2770	.ce17						writeBitmapChar:
2771	.ce17		a0 07		ldy #$07	                ldy #$07
2772	.ce19		e0 03		cpx #$03	                cpx #$03
2773	.ce1b		f0 34		beq $ce51	                beq write2bppChar            ;taken if MODE 1/5
2774	.ce1d		b0 5b		bcs $ce7a	                bcs write4bppChar                    ;taken if MODE 2
2775	.ce1f						write1bppChar:
2776	.ce1f		b1 de		lda ($de),y	                lda (ZTEMPC),y
2777	.ce21		05 d2		ora $d2		                ora ZORA
2778	.ce23		45 d3		eor $d3		                eor ZEOR
2779	.ce25		91 d8		sta ($d8),y	                sta (ZMEMT),y
2780	.ce27		88		dey		                dey
2781	.ce28		10 f5		bpl $ce1f	                bpl write1bppChar
2782	.ce2a		60		rts		                rts

2784	.ce2b						vdu127EntryPoint:
2785	.ce2b		a9 20		lda #$20	                lda #$20
2786	.ce2d		2c 66 03	bit $0366	                bit $0366
2787	.ce30		d0 03		bne $ce35	                bne LCE37
2788	.ce32		20 9a c2	jsr $c29a	                jsr vdu8EntryPoint
2789	.ce35						LCE37:
2790	.ce35		20 d0 e2	jsr $e2d0	                jsr testVDU5State
2791	.ce38		d0 bf		bne $cdf9	                bne vdu127AtGraphicsCursor
2792	.ce3a		ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
2793	.ce3d		f0 0a		beq $ce49	                beq writeTeletextSpaceChar   ;taken if teletext mode

2795							                ; Address of space char is known.
2796	.ce3f		a9 00		lda #$00	                lda #<LB900
2797	.ce41		85 de		sta $de		                sta ZTEMPC+0
2798	.ce43		a9 b9		lda #$b9	                lda #>LB900
2799	.ce45		85 df		sta $df		                sta ZTEMPC+1
2800	.ce47		80 ce		bra $ce17	                bra writeBitmapChar

2802	.ce49						writeTeletextSpaceChar:
2803	.ce49		a9 20		lda #$20	                lda #$20
2804	.ce4b						writeTeletextChar:
2805	.ce4b		20 e3 dd	jsr $dde3	                jsr getSAA5050FromASCII
2806	.ce4e		92 d8		sta ($d8)	                sta (ZMEMT)
2807	.ce50		60		rts		                rts

2809	.ce51						write2bppChar:
2810	.ce51		a5 d9		lda $d9		                lda ZMEMT+1
2811	.ce53		a6 d8		ldx $d8		                ldx ZMEMT+0
2812	.ce55		20 e5 ce	jsr $cee5	                jsr getNextColumnAddress
2813	.ce58						-
2814	.ce58		b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte
2815	.ce5a		29 0f		and #$0f	                and #$0F                     ;get data for right 4 pixels
2816	.ce5c		aa		tax		                tax
2817	.ce5d		bd 11 e0	lda $e011,x	                lda LE013,x                  ;form byte
2818	.ce60		05 d2		ora $d2		                ora ZORA
2819	.ce62		45 d3		eor $d3		                eor ZEOR
2820	.ce64		91 e0		sta ($e0),y	                sta (ZTEMPD),y               ;write to right column
2821	.ce66		b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte
2822							                .if version==350
2824							                .else
2825	.ce68		4a		lsr a		                lsr a                        ;
2826	.ce69		4a		lsr a		                lsr a                        ;
2827	.ce6a		4a		lsr a		                lsr a                        ;
2828	.ce6b		4a		lsr a		                lsr a                        ;get data for left 4 pixels
2829							                .endif
2830	.ce6c		aa		tax		                tax                          ;
2831	.ce6d		bd 11 e0	lda $e011,x	                lda LE013,x                  ;form byte
2832	.ce70		05 d2		ora $d2		                ora ZORA
2833	.ce72		45 d3		eor $d3		                eor ZEOR
2834	.ce74		91 d8		sta ($d8),y	                sta (ZMEMT),y                ;write to left column
2835	.ce76		88		dey		                dey
2836	.ce77		10 df		bpl $ce58	                bpl -
2837	.ce79		60		rts		                rts

2839	.ce7a						write4bppChar:
2840	.ce7a		a5 d9		lda $d9		                lda ZMEMT+1
2841	.ce7c		a6 d8		ldx $d8		                ldx ZMEMT+0
2842	.ce7e		20 d7 ce	jsr $ced7	                jsr getNext3ColumnAddresses
2843	.ce81						-
2844	.ce81		b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte - %abcdefgh
2845	.ce83		20 a7 ce	jsr $cea7	                jsr get4bppScreenByteFor2Pixels ;pixels g and h
2846	.ce86		91 e0		sta ($e0),y	                sta ($E0),y
2847	.ce88		b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte - %abcdefgh
2848	.ce8a		4a		lsr a		                lsr a                        ;%0abcdefg
2849	.ce8b		4a		lsr a		                lsr a                        ;%00abcdef
2850	.ce8c		48		pha		                pha                          ;save %00abcdef
2851	.ce8d		20 a7 ce	jsr $cea7	                jsr get4bppScreenByteFor2Pixels ;pixels e and f
2852	.ce90		91 dc		sta ($dc),y	                sta (ZTEMPB),y
2853	.ce92		68		pla		                pla                          ;restore %00abcdef
2854	.ce93		4a		lsr a		                lsr a                        ;%000abcde
2855	.ce94		4a		lsr a		                lsr a                        ;%0000abcd
2856	.ce95		48		pha		                pha                          ;save %0000abcd
2857	.ce96		20 a7 ce	jsr $cea7	                jsr get4bppScreenByteFor2Pixels ;pixels c and d
2858	.ce99		91 da		sta ($da),y	                sta (ZTEMP),y
2859	.ce9b		68		pla		                pla                          ;restore %0000abcd
2860	.ce9c		4a		lsr a		                lsr a                        ;%00000abc
2861	.ce9d		4a		lsr a		                lsr a                        ;%000000ab
2862	.ce9e		20 a7 ce	jsr $cea7	                jsr get4bppScreenByteFor2Pixels ;pixels a and b
2863	.cea1		91 d8		sta ($d8),y	                sta (ZMEMT),y
2864	.cea3		88		dey		                dey
2865	.cea4		10 db		bpl $ce81	                bpl -
2866	.cea6		60		rts		                rts

2868	.cea7						get4bppScreenByteFor2Pixels:
2869	.cea7		29 03		and #$03	                and #$03                     ;mask out 2 pixels
2870	.cea9		aa		tax		                tax
2871	.ceaa		bd 21 e0	lda $e021,x	                lda LE023,x                  ;form byte
2872	.cead		05 d2		ora $d2		                ora ZORA
2873	.ceaf		45 d3		eor $d3		                eor ZEOR
2874	.ceb1		60		rts		                rts

2876							;-------------------------------------------------------------------------
2877							;
2878							; Get mask indicating the distance between two 16-bit VDU variable
2879							; values - >=8, or some amount less than that.
2880							;
2881							; (These can be used for masking pixels, or counting loops, or
2882							; whatever.)
2883							;
2884							; entry:
2885							;
2886							; X = offset of value A in VDU variables
2887							;
2888							; Y = offset of value B in VDU variables
2889							;
2890							; exit:
2891							;
2892							; if distance<=0, A=255, C=1
2893							;
2894							; if distance>=8, A=0, C=0
2895							;
2896							; otherwise, A=255>>distance, C=0
2897							;
2898	.ceb2						getDistanceMask:
2899	.ceb2		38		sec		                sec
2900	.ceb3		bd 00 03	lda $0300,x	                lda vduv+0,x
2901	.ceb6		f9 00 03	sbc $0300,y	                sbc vduv+0,y
2902	.ceb9		85 da		sta $da		                sta ZTEMP                    ;get result LSB
2903	.cebb		bd 01 03	lda $0301,x	                lda vduv+1,x
2904	.cebe		f9 01 03	sbc $0301,y	                sbc vduv+1,y
2905	.cec1		30 0c		bmi $cecf	                bmi distanceMask255                  ;taken if result -ve
2906	.cec3		d0 0e		bne $ced3	                bne distanceMask0                  ;taken if result >=256
2907	.cec5		a6 da		ldx $da		                ldx ZTEMP
2908	.cec7		e0 08		cpx #$08	                cpx #$08
2909	.cec9		b0 08		bcs $ced3	                bcs distanceMask0                    ;taken if result>=8
2910	.cecb		bd 25 e1	lda $e125,x	                lda distanceMasksTable,x             ;get mask for <8 items
2911	.cece		60		rts		                rts

2913	.cecf						distanceMask255:
2914	.cecf		a9 ff		lda #$ff	                lda #%11111111
2915	.ced1		38		sec		                sec
2916	.ced2		60		rts		                rts

2918	.ced3						distanceMask0:
2919	.ced3		a9 00		lda #$00	                lda #$00
2920	.ced5		18		clc		                clc
2921	.ced6		60		rts		                rts

2923							;-------------------------------------------------------------------------
2924							;
2925							; Get addresses of next 3 columns on screen.
2926							;
2927							; entry:
2928							;
2929							; A (MSB)/X (LSB) = address
2930							;
2931							; exit:
2932							;
2933							; (ZTEMP) = column N+1
2934							; (ZTEMPB) = column N+2
2935							; (ZTEMPC) = column N+3
2936							;
2937	.ced7						getNext3ColumnAddresses:
2938	.ced7		20 e5 ce	jsr $cee5	                jsr getNextColumnAddress
2939	.ceda		86 da		stx $da		                stx ZTEMP+0
2940	.cedc		85 db		sta $db		                sta ZTEMP+1
2941	.cede		20 e5 ce	jsr $cee5	                jsr getNextColumnAddress
2942	.cee1		86 dc		stx $dc		                stx ZTEMPB+0
2943	.cee3		85 dd		sta $dd		                sta ZTEMPB+1

2945							;-------------------------------------------------------------------------
2946							;
2947							; Get address of next column on screen.
2948							;
2949							; entry:
2950							;
2951							; A (MSB)/X (LSB) = address
2952							;
2953							; exit:
2954							;
2955							; A (MSB)/X (LSB) = address of next column
2956							; (ZTEMPD) = address of next column
2957							;
2958	.cee5						getNextColumnAddress:
2959	.cee5		48		pha		                pha
2960	.cee6		8a		txa		                txa
2961	.cee7		18		clc		                clc
2962	.cee8		69 08		adc #$08	                adc #$08                     ;next column...
2963	.ceea		aa		tax		                tax
2964	.ceeb		68		pla		                pla
2965	.ceec		90 06		bcc $cef4	                bcc +                        ;taken if no carry
2966	.ceee		1a		inc a		                inc a
2967	.ceef		10 03		bpl $cef4	                bpl +           ;taken if no screen address wraparound
2968	.cef1		ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
2969	.cef4						+
2970	.cef4		86 e0		stx $e0		                stx ZTEMPD+0
2971	.cef6		85 e1		sta $e1		                sta ZTEMPD+1
2972	.cef8		60		rts		                rts

2974							;-------------------------------------------------------------------------
2975							;
2976							; VDU 23 0 Control 6845 CRTC directly [MasRef E.3-12]
2977							;
2978	.cef9						vdu23_0_EntryPoint:
2979	.cef9		ad 1d 03	lda $031d	                lda vduv.queueEnd-7           ;get value
2980	.cefc		ac 1c 03	ldy $031c	                ldy vduv.queueEnd-8           ;get register

2982							                ; fall through to setCRTCRegister

2984							;-------------------------------------------------------------------------
2985							;
2986							; Set a CRTC register, adjusting and/or noting values if appropriate.
2987							;
2988							; entry:
2989							;
2990							; Y = register to set
2991							;
2992							; A = value

2994	.ceff						setCRTCRegister:
2995	.ceff		c0 07		cpy #$07	                cpy #$07
2996	.cf01		90 1f		bcc $cf22	                bcc setCRTCRegisterRaw
2997	.cf03		d0 03		bne $cf08	                bne +        ;taken if not setting R7

2999							                ; Setting R7 (vsync position), so apply the *TV offset.
3000	.cf05		6d 90 02	adc $0290	                adc tvOffset
3001	.cf08						+
3002	.cf08		c0 08		cpy #$08	                cpy #$08
3003	.cf0a		d0 07		bne $cf13	                bne +                    ;taken if not setting R8

3005							                ; Setting R8 (interlace/delay register), so apply the
3006							                ; *TV interlace setting.
3007	.cf0c		09 00		ora #$00	                ora #$00
3008	.cf0e		30 03		bmi $cf13	                bmi +       ;branch taken if bit 7 set - this is taken
3009							                            ;to imply the mode being set is Mode 7
3010	.cf10		4d 91 02	eor $0291	                eor tvInterlace ;apply *TV interlace setting
3011	.cf13						+
3012	.cf13		c0 0a		cpy #$0a	                cpy #$0A
3013	.cf15		d0 0b		bne $cf22	                bne setCRTCRegisterRaw

3015							                ; Setting R10 (cursor start register). Note the new
3016							                ; setting in the VDU variable. If in VDU5 mode, reuse
3017							                ; the result of testVDU5State - i.e., 32 - as the
3018							                ; setting, hiding the cursor.
3019	.cf17		8d 5f 03	sta $035f	                sta vduv.lastCursorStartRegisterValue
3020	.cf1a		20 d0 e2	jsr $e2d0	                jsr testVDU5State
3021	.cf1d		d0 09		bne $cf28	                bne rtsCF2A
3022	.cf1f		ad 5f 03	lda $035f	                lda vduv.lastCursorStartRegisterValue

3024							                ; fall through to setCRTCRegisterRaw

3026							;-------------------------------------------------------------------------
3027							;
3028							; Set a CRTC register.
3029							;
3030	.cf22						setCRTCRegisterRaw:
3031	.cf22		8c 00 fe	sty $fe00	                sty CRTC+0
3032	.cf25		8d 01 fe	sta $fe01	                sta CRTC+1
3033	.cf28						rtsCF2A:
3034	.cf28		60		rts		                rts

3036							;-------------------------------------------------------------------------
3037							;
3038							; VDU 23 1 Turn cursor on/off [MasRef E.3-12]
3039							;
3040	.cf29						vdu23_1_EntryPoint:
3041	.cf29		20 d0 e2	jsr $e2d0	                jsr testVDU5State
3042	.cf2c		d0 fa		bne $cf28	                bne rtsCF2A                  ;taken if VDU5
3043	.cf2e		ad 1c 03	lda $031c	                lda vduv.queueEnd-8           ;get new cursor state
3044	.cf31		29 03		and #$03	                and #$03                     ;mask off bits of interest
3045	.cf33		0a		asl a		                asl a
3046	.cf34		aa		tax		                tax
3047	.cf35		a9 20		lda #$20	                lda #$20 ;R10 value for hiding the cursor - save a few
3048							                         ;bytes by loading this here
3049	.cf37		7c 3a cf	jmp ($cf3a,x)	                jmp (LCF3C,x)

3051	.cf3a						LCF3C:
3052	>cf3a		51 cf				                .word setCRTCRegister10            ; 23,1,0... - hide
3053	>cf3c		4e cf				                .word showCursor            ; 23,1,1... - show
3054	>cf3e		42 cf				                .word steadyCursor          ; 23,1,2... - steady
3055	>cf40		49 cf				                .word slowFlashCursor       ; 23,1,3... - flash slowly

3057	.cf42						steadyCursor:
3058	.cf42		a9 60		lda #$60	                lda #%01100000
3059	.cf44		1c 5f 03	trb $035f	                trb vduv.lastCursorStartRegisterValue ;steady cursor
3060	.cf47		80 05		bra $cf4e	                bra showCursor

3062	.cf49						slowFlashCursor:
3063	.cf49		a9 60		lda #$60	                lda #%01100000
3064	.cf4b		0c 5f 03	tsb $035f	                tsb vduv.lastCursorStartRegisterValue ;slow blink cursor
3065	.cf4e						showCursor:
3066	.cf4e		ad 5f 03	lda $035f	                lda vduv.lastCursorStartRegisterValue
3067	.cf51						setCRTCRegister10:
3068	.cf51		a0 0a		ldy #$0a	                ldy #$0A
3069	.cf53		80 cd		bra $cf22	                bra setCRTCRegisterRaw

3071							;-------------------------------------------------------------------------
3072							;
3073							; VDU 23 2-5 Set ECF patterns [MasRef E.3-13]
3074							;
3075	.cf55						vdu23_2_EntryPoint:
3076	.cf55						vdu23_3_EntryPoint:
3077	.cf55						vdu23_4_EntryPoint:
3078	.cf55						vdu23_5_EntryPoint:
3079	.cf55		e9 01		sbc #$01	                sbc #$01  ;subtract 2 (C=0 on entry...) to get pattern
3080							                          ;index
3081	.cf57		0a		asl a		                asl a
3082	.cf58		0a		asl a		                asl a
3083	.cf59		0a		asl a		                asl a                        ;index*8
3084	.cf5a		69 07		adc #$07	                adc #$07                     ;index*8+7
3085	.cf5c		a8		tay		                tay
3086	.cf5d		a2 07		ldx #$07	                ldx #$07
3087	.cf5f						-
3088	.cf5f		bd 1c 03	lda $031c,x	                lda vduv.queueEnd-8,x
3089	.cf62		99 00 88	sta $8800,y	                sta andy.ecfPatterns,y
3090	.cf65		88		dey		                dey
3091	.cf66		ca		dex		                dex
3092	.cf67		10 f6		bpl $cf5f	                bpl -
3093	.cf69		80 26		bra $cf91	                bra LCF93

3095							;-------------------------------------------------------------------------

3097	.cf6b						vdu23_11_EntryPoint:
3098	.cf6b		ad 55 03	lda $0355	                lda vduv.currentScreenMODE
3099	.cf6e		d0 01		bne $cf71	                bne +
3100							                ; Use a different table for MODE 0 - see MasRef E.3-16.
3101	.cf70		3a		dec a		                dec a                        ;
3102	.cf71						+
3103	.cf71		29 03		and #$03	                and #$03 ;index=0 (mode 4); 1 (mode 1/5); 2 (mode 2);
3104							                         ;3 (mode 0)
3105	.cf73		1a		inc a		                inc a
3106	.cf74		0a		asl a		                asl a
3107	.cf75		0a		asl a		                asl a
3108	.cf76		0a		asl a		                asl a
3109	.cf77		0a		asl a		                asl a                        ;(index+1)*16
3110	.cf78		aa		tax		                tax
3111	.cf79		a0 1c		ldy #$1c	                ldy #32-4
3112	.cf7b						setDefaultECFPatterns:
3113	.cf7b		bd c1 e1	lda $e1c1,x	                lda defaultECFPatterns-1,x
3114	.cf7e		99 ff 87	sta $87ff,y	                sta andy.ecfPatterns-1,y     ;copy first repeat
3115	.cf81		99 03 88	sta $8803,y	                sta andy.ecfPatterns+4-1,y   ;copy second repeat
3116	.cf84		ca		dex		                dex                          ;next byte in defaults table
3117	.cf85		88		dey		                dey
3118	.cf86		98		tya		                tya
3119	.cf87		89 07		bit #$07	                bit #$07
3120	.cf89		d0 f0		bne $cf7b	                bne setDefaultECFPatterns ;taken if pattern not filled
3121							                ; skip to start of previous pattern
3122	.cf8b		88		dey		                dey
3123	.cf8c		88		dey		                dey
3124	.cf8d		88		dey		                dey
3125	.cf8e		88		dey		                dey
3126	.cf8f		10 ea		bpl $cf7b	                bpl setDefaultECFPatterns
3127	.cf91						LCF93:
3128	.cf91		4c 7d c5	jmp $c57d	                jmp initializeCurrentECFPatterns

3130							;-------------------------------------------------------------------------
3131							;
3132							; VDU 23 12-15 Set simple ECF pattern [MasRef E.3-17]
3133							;
3134	.cf94						vdu23_12_EntryPoint:
3135	.cf94						vdu23_13_EntryPoint:
3136	.cf94						vdu23_14_EntryPoint:
3137	.cf94						vdu23_15_EntryPoint:
3138	.cf94		e9 0b		sbc #$0b	                sbc #$0B                     ;-12 to get pattern index
3139	.cf96		0a		asl a		                asl a                        ;index*2
3140	.cf97		0a		asl a		                asl a                        ;index*4
3141	.cf98		0a		asl a		                asl a                        ;index*8, C=0
3142	.cf99		69 03		adc #$03	                adc #$03                     ;index*8+3, C=0
3143	.cf9b		48		pha		                pha                          ;save offset
3144	.cf9c		a2 07		ldx #$07	                ldx #$07                     ;
3145	.cf9e						LCFA0:
3146	.cf9e		bd 1c 03	lda $031c,x	                lda vduv.queueEnd-8,x        ;get simple pattern byte
3147	.cfa1		2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne ;apply logical colour limit
3148	.cfa4		85 da		sta $da		                sta ZTEMP+0
3149	.cfa6		ad 60 03	lda $0360	                lda vduv.numberOfLogicalColoursMinusOne
3150	.cfa9		29 07		and #$07	                and #$07                     ;1/3/7
3151	.cfab		65 da		adc $da		                adc ZTEMP+0                  ;select 2/4/16 colour table
3152	.cfad		a8		tay		                tay
3153	.cfae		b9 49 e1	lda $e149,y	                lda solidColoursTable-1,y
3154	.cfb1		9d 1c 03	sta $031c,x	                sta vduv.queueEnd-8,x
3155	.cfb4		ca		dex		                dex
3156	.cfb5		10 e7		bpl $cf9e	                bpl LCFA0
3157	.cfb7		a9 55		lda #$55	                lda #%01010101
3158	.cfb9		ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
3159	.cfbc		d0 02		bne $cfc0	                bne +                 ;taken if not MODE 0
3160	.cfbe		a9 33		lda #$33	                lda #%00110011        ;double-width pattern for MODE 0
3161	.cfc0						+
3162	.cfc0		85 da		sta $da		                sta ZTEMP+0
3163	.cfc2		7a		ply		                ply
3164	.cfc3		a2 07		ldx #$07	                ldx #$07
3165	.cfc5						LCFC7:
3166	.cfc5		bd 1c 03	lda $031c,x	                lda vduv.queueEnd-8,x
3167	.cfc8		ca		dex		                dex
3168	.cfc9		5d 1c 03	eor $031c,x	                eor vduv.queueEnd-8,x
3169	.cfcc		25 da		and $da		                and ZTEMP+0
3170	.cfce		5d 1c 03	eor $031c,x	                eor vduv.queueEnd-8,x
3171	.cfd1		99 00 88	sta $8800,y	                sta andy.ecfPatterns+0,y
3172	.cfd4		99 04 88	sta $8804,y	                sta andy.ecfPatterns+4,y
3173	.cfd7		88		dey		                dey
3174	.cfd8		ca		dex		                dex
3175	.cfd9		10 ea		bpl $cfc5	                bpl LCFC7
3176	.cfdb		80 b4		bra $cf91	                bra LCF93

3178							;-------------------------------------------------------------------------
3179							;
3180							; VDU 23 6 Set dotted lines pattern [MasRef E.3-13]
3181							;
3182	.cfdd						vdu23_6_EntryPoint:
3183	.cfdd		ad 1c 03	lda $031c	                lda vduv.queueEnd-8
3184	.cfe0		8d 67 03	sta $0367	                sta vduv.dotPattern
3185	.cfe3		60		rts		                rts

3187							;-------------------------------------------------------------------------
3188							;
3189							; VDU 23 7 Scroll window directly [MasRef E.3-14]
3190							;
3191	.cfe4						vdu23_7_EntryPoint:
3192	.cfe4		ad 1c 03	lda $031c	                lda vduv.queueEnd-8           ;get <m>
3193	.cfe7		d0 0a		bne $cff3	                bne scrollEntireScreen
3194	.cfe9		20 0e c9	jsr $c90e	                jsr copyTextWindowToWorkspace2C
3195	.cfec		a5 d0		lda $d0		                lda STATE
3196	.cfee		29 08		and #$08	                and #STATE.isTextWindow
3197	.cff0		0a		asl a		                asl a ;A=$10 (text window active) or $00 (no text window)
3198	.cff1		80 11		bra $d004	                bra +

3200	.cff3						scrollEntireScreen:
3201	.cff3		a9 00		lda #$00	                lda #$00
3202	.cff5		8d 2c 03	sta $032c	                sta vduv.workspace._2C          ;left
3203	.cff8		8d 2f 03	sta $032f	                sta vduv.workspace._2F          ;top
3204	.cffb		20 a0 e2	jsr $e2a0	                jsr getDefaultBoundsForCurrentScreenMODE
3205	.cffe		8e 2e 03	stx $032e	                stx vduv.workspace._2E          ;right
3206	.d001		8c 2d 03	sty $032d	                sty vduv.workspace._2D          ;bottom
3207	.d004						+
3208	.d004		85 dc		sta $dc		                sta ZTEMPB+0
3209	.d006		38		sec		                sec
3210	.d007		ad 2e 03	lda $032e	                lda vduv.workspace._2E          ;right
3211	.d00a		ed 2c 03	sbc $032c	                sbc vduv.workspace._2C          ;right-left
3212	.d00d		20 39 c9	jsr $c939	                jsr getBytesPerInclusiveTextRow
3213	.d010		8d 28 03	sta $0328	                sta vduv.workspace._28+0        ;bytes per row LSB
3214	.d013		8e 29 03	stx $0329	                stx vduv.workspace._28+1        ;bytes per row MSB
3215	.d016		ae 4f 03	ldx $034f	                ldx vduv.bytesPerCharacter
3216	.d019		e0 01		cpx #$01	                cpx #$01
3217	.d01b		f0 07		beq $d024	                beq +  ;when 1 byte/char, no cell/byte distinction
3218	.d01d		ad 1e 03	lda $031e	                lda vduv.queueEnd-6       ;get <z>
3219	.d020		f0 02		beq $d024	                beq +                ;taken if scrolling by 1 cell
3220	.d022		a2 08		ldx #$08	                ldx #$08                 ;scroll by 1 horizontal byte
3221	.d024						+
3222	.d024		8e 2a 03	stx $032a	                stx vduv.workspace._2A

3224							; <d> is a bitmask - %00000AVN.
3225							;
3226							; A is set if scrolling by axis (controlled by the VDU cursor flags)
3227							; rather than by direction.
3228							;
3229							; V is set to scroll vertically/in Y rather than horizontally/in X.
3230							;
3231							; N is set to scroll in the negative direction.

3233	.d027		ad 1d 03	lda $031d	                lda vduv.queueEnd-7           ;00000avn C=?
3234	.d02a		4a		lsr a		                lsr a                        ;000000av C=n
3235	.d02b		08		php		                php
3236	.d02c		2a		rol a		                rol a                        ;00000avn C=0
3237	.d02d		28		plp		                plp                          ;00000avn C=n
3238	.d02e		2a		rol a		                rol a                        ;0000avnn C=0
3239	.d02f		0a		asl a		                asl a                        ;000avnn0 C=0
3240	.d030		c9 10		cmp #$10	                cmp #$10                     ;$10 = 000a0000
3241	.d032		90 03		bcc $d037	                bcc LD039                 ;taken if scrolling by direction
3242	.d034		4d 66 03	eor $0366	                eor vduv.cursorFlags       ;adjust axes
3243	.d037						LD039:
3244	.d037		29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
3245	.d039		05 dc		ora $dc		                ora ZTEMPB+0
3246	.d03b						LD03D:
3247	.d03b		aa		tax		                tax
3248	.d03c		ad 50 03	lda $0350	                lda vduv.screenTopLeftAddress+0
3249	.d03f		85 d8		sta $d8		                sta ZMEMT+0
3250	.d041		ad 51 03	lda $0351	                lda vduv.screenTopLeftAddress+1
3251	.d044		85 d9		sta $d9		                sta ZMEMT+1
3252	.d046		20 4c d0	jsr $d04c	                jsr callScrollRoutine
3253	.d049		4c d8 c6	jmp $c6d8	                jmp updateCRTCTextCursor

3255	.d04c						callScrollRoutine:
3256	.d04c		7c 0a e2	jmp ($e20a,x)	                jmp (scrollRoutinesTable,x)

3258	.d04f						LD051:
3259	.d04f		da		phx		                phx
3260	.d050		20 0e c9	jsr $c90e	                jsr copyTextWindowToWorkspace2C
3261	.d053		20 06 c9	jsr $c906	                jsr copyTextWindowWidthInBytesToWorkspace28
3262	.d056		ae 4f 03	ldx $034f	                ldx $034F
3263	.d059		8e 2a 03	stx $032a	                stx $032A
3264	.d05c		68		pla		                pla
3265	.d05d		4a		lsr a		                lsr a
3266	.d05e		45 d0		eor $d0		                eor STATE
3267	.d060		29 f7		and #$f7	                and #(~STATE.isTextWindow)&$ff
3268	.d062		45 d0		eor $d0		                eor STATE
3269	.d064		0a		asl a		                asl a
3270	.d065		80 d4		bra $d03b	                bra LD03D

3272							;-------------------------------------------------------------------------
3273							;
3274							; VDU 23 8 Clear block [MasRef E.3-15]
3275							;
3276	.d067						vdu23_8_EntryPoint:
3277	.d067		9c 34 03	stz $0334	                stz $0334
3278	.d06a		9c 35 03	stz $0335	                stz $0335
3279	.d06d		20 50 e2	jsr $e250	                jsr getTextCursorPositionWithColumn81
3280	.d070		8e 36 03	stx $0336	                stx $0336
3281	.d073		8c 37 03	sty $0337	                sty $0337
3282	.d076		20 5a e2	jsr $e25a	                jsr LE25C
3283	.d079		e8		inx		                inx
3284	.d07a		8e 38 03	stx $0338	                stx $0338
3285	.d07d		8c 39 03	sty $0339	                sty $0339
3286	.d080		a0 00		ldy #$00	                ldy #$00
3287	.d082		ad 1c 03	lda $031c	                lda $031C
3288	.d085		20 e3 d0	jsr $d0e3	                jsr LD0E5
3289	.d088		ad 1d 03	lda $031d	                lda $031D
3290	.d08b		20 e3 d0	jsr $d0e3	                jsr LD0E5
3291	.d08e		ad 33 03	lda $0333	                lda $0333
3292	.d091		cd 31 03	cmp $0331	                cmp $0331
3293	.d094		90 76		bcc $d10c	                bcc LD10E
3294	.d096		d0 08		bne $d0a0	                bne LD0A2
3295	.d098		ad 30 03	lda $0330	                lda $0330
3296	.d09b		cd 32 03	cmp $0332	                cmp $0332
3297	.d09e		b0 6c		bcs $d10c	                bcs LD10E
3298	.d0a0						LD0A2:
3299	.d0a0		ad 18 03	lda $0318	                lda $0318
3300	.d0a3		48		pha		                pha
3301	.d0a4		ad 19 03	lda $0319	                lda $0319
3302	.d0a7		48		pha		                pha
3303	.d0a8		ac 31 03	ldy $0331	                ldy $0331
3304	.d0ab						LD0AD:
3305	.d0ab		5a		phy		                phy
3306	.d0ac		ad 66 03	lda $0366	                lda $0366
3307	.d0af		49 08		eor #$08	                eor #$08
3308	.d0b1		29 0e		and #$0e	                and #$0E
3309	.d0b3		aa		tax		                tax
3310	.d0b4		98		tya		                tya
3311	.d0b5		20 c7 c2	jsr $c2c7	                jsr setTextCursorXPositionWithCursorFlags
3312	.d0b8		a2 00		ldx #$00	                ldx #$00
3313	.d0ba		ad 38 03	lda $0338	                lda $0338
3314	.d0bd		cc 31 03	cpy $0331	                cpy $0331
3315	.d0c0		d0 03		bne $d0c5	                bne LD0C7
3316	.d0c2		ae 30 03	ldx $0330	                ldx $0330
3317	.d0c5						LD0C7:
3318	.d0c5		cc 33 03	cpy $0333	                cpy $0333
3319	.d0c8		f0 07		beq $d0d1	                beq LD0D3
3320	.d0ca		20 7d ca	jsr $ca7d	                jsr LCA7F
3321	.d0cd		7a		ply		                ply
3322	.d0ce		c8		iny		                iny
3323	.d0cf		80 da		bra $d0ab	                bra LD0AD

3325	.d0d1						LD0D3:
3326	.d0d1		ad 32 03	lda $0332	                lda $0332
3327	.d0d4		20 7d ca	jsr $ca7d	                jsr LCA7F
3328	.d0d7		7a		ply		                ply
3329	.d0d8		68		pla		                pla
3330	.d0d9		8d 19 03	sta $0319	                sta $0319
3331	.d0dc		68		pla		                pla
3332	.d0dd		8d 18 03	sta $0318	                sta $0318
3333	.d0e0		4c f8 cc	jmp $ccf8	                jmp updateZMEMTWithTextCursorPosition

3335	.d0e3						LD0E5:
3336	.d0e3		48		pha		                pha
3337	.d0e4		29 03		and #$03	                and #$03
3338	.d0e6		0a		asl a		                asl a
3339	.d0e7		20 ee d0	jsr $d0ee	                jsr LD0F0
3340	.d0ea		68		pla		                pla
3341	.d0eb		4a		lsr a		                lsr a
3342	.d0ec		09 01		ora #$01	                ora #$01
3343	.d0ee						LD0F0:
3344	.d0ee		aa		tax		                tax
3345	.d0ef		29 01		and #$01	                and #$01
3346	.d0f1		48		pha		                pha
3347	.d0f2		bd 34 03	lda $0334,x	                lda $0334,x
3348	.d0f5		fa		plx		                plx
3349	.d0f6		18		clc		                clc
3350	.d0f7		c8		iny		                iny
3351	.d0f8		79 1d 03	adc $031d,y	                adc $031D,y
3352	.d0fb		30 0a		bmi $d107	                bmi LD109
3353	.d0fd		dd 38 03	cmp $0338,x	                cmp $0338,x
3354	.d100		90 07		bcc $d109	                bcc LD10B
3355	.d102		bd 38 03	lda $0338,x	                lda $0338,x
3356	.d105		80 02		bra $d109	                bra LD10B

3358	.d107						LD109:
3359	.d107		a9 00		lda #$00	                lda #$00
3360	.d109						LD10B:
3361	.d109		99 2f 03	sta $032f,y	                sta $032F,y
3362	.d10c						LD10E:
3363	.d10c		60		rts		                rts

3365							;-------------------------------------------------------------------------
3366							;
3367							; VDU 23 9 Set 1st flash time [MasRef E.3-16]
3368							;
3369	.d10d						vdu23_9_EntryPoint:
3370	.d10d		38		sec		                sec

3372							;-------------------------------------------------------------------------
3373							;
3374							; VDU 23 10 Set 2nd flash time [MasRef E.3-16]
3375							;
3376	.d10e						vdu23_10_EntryPoint:
3377	.d10e		ae 1c 03	ldx $031c	                ldx vduv.queueEnd-8          ;get flash value
3378	.d111		a0 00		ldy #$00	                ldy #$00                     ;Y=0 for OSBYTE call
3379	.d113		90 03		bcc $d118	                bcc doOSBYTE0A               ;taken if VDU23,10
3380	.d115		4c f4 ea	jmp $eaf4	                jmp osbyte09
3381	.d118						doOSBYTE0A:
3382	.d118		38		sec		                sec
3383	.d119		4c f6 ea	jmp $eaf6	                jmp osbyte0A

3385							;-------------------------------------------------------------------------
3386							;
3387							; VDU 23 16 Cursor movement control [MasRef E.3-17]
3388							;
3389	.d11c						vdu23_16_EntryPoint:
3390	.d11c		ad 66 03	lda $0366	                lda vduv.cursorFlags
3391	.d11f		2d 1d 03	and $031d	                and vduv.queueEnd-7          ;value AND <y>
3392	.d122		4d 1c 03	eor $031c	                eor vduv.queueEnd-8          ;(value AND <y>) EOR <x>
3393	.d125		8d 66 03	sta $0366	                sta vduv.cursorFlags
3394	.d128		4a		lsr a		                lsr a
3395	.d129		b0 18		bcs $d143	                bcs rtsD145            ;taken if scrollProtect flag on
3396							                ; scroll protect flag is off, so handle column 81 if
3397							                ; necessary.

3399							;-------------------------------------------------------------------------
3400							;
3401							; Handle column 81, if necessary.
3402							;
3403							; TODO - probably misnamed due to the return value
3404							;
3405							; exit:
3406							;
3407							; C=0 if not VDU 5
3408							;
3409							; C=1 if VDU 5
3410							;
3411	.d12b						handleColumn81:
3412	.d12b		48		pha		                pha
3413	.d12c		da		phx		                phx
3414	.d12d		20 d0 e2	jsr $e2d0	                jsr testVDU5State
3415	.d130		38		sec		                sec
3416	.d131		d0 0e		bne $d141	                bne plx_pla_rts        ;taken if VDU5
3417	.d133		18		clc		                clc
3418	.d134		2c 6c 03	bit $036c	                bit vduv.column81
3419	.d137		10 08		bpl $d141	                bpl plx_pla_rts        ;taken if not column 81
3420	.d139		08		php		                php
3421	.d13a		20 f6 c3	jsr $c3f6	                jsr vdu13EntryPoint          ;CR
3422	.d13d		20 5b c2	jsr $c25b	                jsr vdu10EntryPoint          ;LF
3423	.d140		28		plp		                plp
3424	.d141						plx_pla_rts:
3425	.d141		fa		plx		                plx
3426	.d142		68		pla		                pla
3427	.d143						rtsD145:
3428	.d143		60		rts		                rts

3430							;-------------------------------------------------------------------------
3431							;
3432							; Handle PLOT. [MasRef E.3-21]
3433							;
3434							; PLOT numbers are of the form %pppppamm, where %ppppp is the PLOT
3435							; type, %a the absolute flag and %mm the PLOT mode.
3436							;
3437							; Absolute flag and mode are clear enough from [MasRef E.3-22]. The
3438							; %ppppp part isn't documented as such, so here's a list:
3439							;
3440							; %00000 =  0 = 0-7 = Plot solid line (both endpoints included) [MasRef E.3-23]
3441							; %00001 =  1 = 8-15 = Plot solid line (final point omitted) [MasRef E.3-23]
3442							; %00010 =  2 = 16-23 = Plot solid line (final point omitted) [MasRef E.3-23]
3443							; %00011 =  3 = 24-31 = Plot dotted line (final point omitted) [MasRef E.3-23]
3444							; %00100 =  4 = 32-39 = Plot solid line (initial point omitted) [MasRef E.3-24]
3445							; %00101 =  5 = 40-47 = Plot solid line (both endpoints omitted) [MasRef E.3-24]
3446							; %00110 =  6 = 48-55 = Plot dotted line (initial point omitted) [MasRef E.3-24]
3447							; %00111 =  7 = 56-63 = Plot dotted line (both endpoints omitted) [MasRef E.3-24]
3448							; %01000 =  8 = 64-71 = Plot point [MasRef E.3-24]
3449							; %01001 =  9 = 72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
3450							; %01010 = 10 = 80-87 = Plot triangle [MasRef E.3-25]
3451							; %01011 = 11 = 88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
3452							; %01100 = 12 = 96-103 = Plot rectangle [MasRef E.3-26]
3453							; %01101 = 13 = 104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
3454							; %01110 = 14 = 112-119 = Plot parallelogram [MasRef E.3-27]
3455							; %01111 = 15 = 120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
3456							; %10000 = 16 = 128-135 = Flood fill to non-background [MasRef E.3-28]
3457							; %10001 = 17 = 136-143 = Flood fill to foreground [MasRef E.3-28]
3458							; %10010 = 18 = 144-151 = Plot circle outline [MasRef E.3-28]
3459							; %10011 = 19 = 152-159 = Plot filled circle [MasRef E.3-29]
3460							; %10100 = 20 = 160-167 = Plot circular arc [MasRef E.3-29]
3461							; %10101 = 21 = 168-175 = Plot filled chord segment [MasRef E.3-30]
3462							; %10110 = 22 = 176-183 = Plot filled sector [MasRef E.3-30]
3463							; %10111 = 23 = 184-191 = Move/copy rectangle [MasRef E.3-31]
3464							; %11000 = 24 = 192-199 = Plot ellipse outline [MasRef E.3-32]
3465							; %11001 = 25 = 200-207 = Plot solid ellipse [MasRef E.3-32]
3466							; %11010 = 26 = 208-215 = Reserved [MasRef E.3-34]
3467							; %11011 = 27 = 215-223 = Reserved [MasRef E.3-34]
3468							; %11100 = 28 = 224-231 = Reserved [MasRef E.3-34]
3469							; %11101 = 29 = 232-239 = Reserved for Acornsoft sprites [MasRef E.3-34]
3470							; %11110 = 30 = 240-247 = User program calls [MasRef E.3-34]
3471							; %11111 = 31 = 248-255 = User program calls [MasRef E.3-34]
3472							;
3473							; entry:
3474							;
3475							; vduQueueEnd-5 = PLOT number
3476							;
3477							; vduQueueEnd-3 = X coordinate
3478							;
3479							; vduQueueEnd-1 = Y coordinate
3480							;;

3482	.d144						handlePLOT:
3483	.d144		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
3484	.d146		20 e0 d1	jsr $d1e0	                jsr eigabsForPLOT
3485	.d149		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number
3486	.d14c		a0 05		ldy #$05	                ldy #gcolModeLeave                     ;
3487	.d14e		29 03		and #$03	                and #$03                     ;mask out colour/plot mode [MasRef E.3-22]
3488	.d150		f0 0c		beq $d15e	                beq LD160 ;taken if <p> MOD 4=0 - early out
3489	.d152		4a		lsr a		                lsr a                        ;C=1 if using VDU18 settings
3490	.d153		88		dey		                dey                          ;Y=gcolModeInvert
3491	.d154		90 08		bcc $d15e	                bcc LD160                    ;taken if invert mode
3492	.d156		aa		tax		                tax              ;X=0 if fg settings, 1 if bg settings
3493	.d157		bc 5b 03	ldy $035b,x	                ldy vduv.foregroundGCOLMode,x
3494	.d15a		0a		asl a		                asl a
3495	.d15b		0a		asl a		                asl a
3496	.d15c		0a		asl a		                asl a
3497	.d15d		aa		tax		                tax              ;X=0 if fg settings, 8 if bg settings
3498	.d15e						LD160:
3499	.d15e		8e 59 03	stx $0359	                stx vduv.graphicsPlotState
3500	.d161		98		tya		                tya
3501	.d162		29 0f		and #$0f	                and #$0F
3502	.d164		8d 5a 03	sta $035a	                sta vduv.graphicsPlotMode
3503	.d167		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number pppppmmm
3504	.d16a		4a		lsr a		                lsr a                        ;0pppppmm
3505	.d16b		4a		lsr a		                lsr a                        ;00pppppm
3506	.d16c		29 fe		and #$fe	                and #$fe                     ;00ppppp0
3507	.d16e		aa		tax		                tax
3508	.d16f		c9 34		cmp #$34	                cmp #208/4
3509	.d171		b0 1b		bcs $d18e	                bcs LD190                    ;taken if reserved PLOT
3510	.d173		29 f3		and #$f3	                and #$F3                     ;00pp00p0
3511	.d175		c9 12		cmp #$12	                cmp #$12                     ;
3512	.d177		08		php		                php                          ;
3513	.d178		f0 08		beq $d182	                beq LD184                ;taken if horizonal line fill
3514	.d17a		e0 2e		cpx #$2e	                cpx #184/4
3515	.d17c		f0 04		beq $d182	                beq LD184                ;taken if move/copy rectangle
3516	.d17e		c0 05		cpy #$05	                cpy #gcolModeLeave
3517	.d180		f0 19		beq $d19b	                beq LD19D
3518	.d182						LD184:
3519	.d182		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number
3520	.d185		20 91 d1	jsr $d191	                jsr LD193
3521	.d188		28		plp		                plp
3522	.d189		d0 11		bne $d19c	                bne LD19E
3523	.d18b		4c df c4	jmp $c4df	                jmp LC4DF

3525	.d18e						LD190:
3526	.d18e		4c a3 c6	jmp $c6a3	                jmp callVDUVForPLOT

3528	.d191						LD193:
3529	.d191		e0 10		cpx #$10	                cpx #64/4
3530	.d193		b0 03		bcs $d198	                bcs LD19A                     ;taken if PLOT >=64
3531	.d195		4c a7 d8	jmp $d8a7	                jmp LD8A9                    ;handle line PLOTs

3533	.d198						LD19A:
3534	.d198		7c 79 e0	jmp ($e079,x)	                jmp (plotEntryPointTable-8*2,x)

3536	.d19b						LD19D:
3537	.d19b		68		pla		                pla
3538	.d19c						LD19E:
3539	.d19c		20 18 c9	jsr $c918	                jsr copyGraphicsCursorPixelsToOldGraphicsCursorPixels
3540	.d19f		a0 24		ldy #$24	                ldy #$24
3541	.d1a1		4c 14 c9	jmp $c914	                jmp copyLastFourVDUQueueBytes

3543	.d1a4						LD1A6:
3544	.d1a4		a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX

3546							;-------------------------------------------------------------------------
3547							;
3548							; WIND [MasRef E.4-7]. The result is a bit field, %vvhh, where %vv is
3549							; the outcode for the vertical axis and %hh the outcode for the
3550							; horizontal axis. Each outcode is %xn, where x is set if point above
3551							; maximum and n set if point below minimum. (Of course, %11 is then
3552							; not possible.)
3553							;
3554							; See https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm
3555							;
3556							; So the possible results, in binary, are:
3557							;
3558							; %1001 | %1000 | %1010
3559							; ------+-------+------
3560							; %0001 | %0000 | %0010
3561							; ------+-------+------
3562							; %0101 | %0100 | %0110
3563							;
3564	.d1a6						windEntryPoint:
3565	.d1a6		e8		inx		                inx
3566	.d1a7		e8		inx		                inx                          ;point to Y coordinate
3567	.d1a8		20 b3 d1	jsr $d1b3	                jsr getOutcodeForYAxis                    ;process Y coordinate
3568	.d1ab		ca		dex		                dex
3569	.d1ac		ca		dex		                dex                          ;point to X coordinate
3570	.d1ad		0a		asl a		                asl a
3571	.d1ae		0a		asl a		                asl a                        ;shift Y outcode into bits 2/3
3572	.d1af		a0 00		ldy #$00	                ldy #$00                     ;doing Y axis
3573	.d1b1		80 04		bra $d1b7	                bra updateOutcodeForAxis

3575							;-------------------------------------------------------------------------
3576							;
3577	.d1b3						getOutcodeForYAxis:
3578	.d1b3		a0 02		ldy #$02	                ldy #$02                     ;Y=2 for Y coordinate
3579							;-------------------------------------------------------------------------
3580							;
3581							; Get outcode for X or Y axis.
3582							;
3583							; entry:
3584							;
3585							; X = offset in VDU variables of coordinate
3586							;
3587							; Y = 0 if X axis, 2 if Y axis
3588							;
3589							; exit:
3590							;
3591							; ZTEMP?0 = outcode - 0, 1 or 2
3592							;
3593							; A = outcode
3594							;
3595							; N/Z set as per outcode
3596							;
3597	.d1b5						getOutcodeForAxis:
3598	.d1b5		a9 00		lda #$00	                lda #$00                     ;initialize result

3600							;-------------------------------------------------------------------------
3601							;
3602							; Update outcode for X or Y axis
3603							;
3604							; entry: as per getOutcodeForAxis
3605							;
3606							; exit:
3607							;
3608							; ZTEMP?0 = updated; outcode is added to its existing value
3609							;
3610	.d1b7						updateOutcodeForAxis:
3611	.d1b7		85 da		sta $da		                sta ZTEMP+0                  ;save current result
3612							                ; set flags for coordinate-minimum
3613	.d1b9		bd 00 03	lda $0300,x	                lda vduv+0,x
3614	.d1bc		d9 00 03	cmp $0300,y	                cmp vduv.graphicsWindowPixelsLeft+0,y
3615	.d1bf		bd 01 03	lda $0301,x	                lda vduv+1,x
3616	.d1c2		f9 01 03	sbc $0301,y	                sbc vduv.graphicsWindowPixelsLeft+1,y
3617	.d1c5		30 10		bmi $d1d7	                bmi add1ToOutcode ;taken if point below minimum - outcode is 1

3619							                ; set flags for maximum-coordinate
3620	.d1c7		b9 04 03	lda $0304,y	                lda vduv.graphicsWindowPixelsRight+0,y
3621	.d1ca		dd 00 03	cmp $0300,x	                cmp vduv+0,x
3622	.d1cd		b9 05 03	lda $0305,y	                lda vduv.graphicsWindowPixelsRight+1,y
3623	.d1d0		fd 01 03	sbc $0301,x	                sbc vduv+1,x
3624	.d1d3		10 04		bpl $d1d9	                bpl gotOutcode ;taken if point below maximum - axis outcode is 0
3625							                ; point is above maximum - axis outcode is 2
3626	.d1d5						add2ToOutcode:
3627	.d1d5		e6 da		inc $da		                inc ZTEMP+0
3628	.d1d7						add1ToOutcode:
3629	.d1d7		e6 da		inc $da		                inc ZTEMP+0
3630	.d1d9						gotOutcode:
3631	.d1d9		a5 da		lda $da		                lda ZTEMP+0
3632	.d1db		60		rts		                rts

3634							;-------------------------------------------------------------------------
3635							;
3636							; EIGABS entry point.
3637							;
3638	.d1dc						eigabsEntryPoint:
3639	.d1dc		a9 ff		lda #$ff	                lda #$FF ;pretend it's PLOT 255 (as that would be absolute coordinates)
3640	.d1de		80 03		bra $d1e3	                bra eigabsCommon

3642							;-------------------------------------------------------------------------
3643							;
3644							; EIGABS, but for a VDU 25. Handles relative/absolute addressing,
3645							; based on the PLOT number in the VDU queue.
3646							;
3647	.d1e0						eigabsForPLOT:
3648	.d1e0		ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number

3650							;-------------------------------------------------------------------------
3651							;
3652							; EIGABS shared code.
3653							;
3654	.d1e3						eigabsCommon:
3655	.d1e3		85 da		sta $da		                sta ZTEMP+0                  ;save PLOT number
3656	.d1e5		a0 02		ldy #$02	                ldy #$02                     ;process Y
3657	.d1e7		20 09 d2	jsr $d209	                jsr handleExternalCoordinate
3658	.d1ea		20 40 d2	jsr $d240	                jsr divideCoordinatesBy2     ;divide Y by 4 - convert 0-1023 to 0-255
3659	.d1ed		a0 00		ldy #$00	                ldy #$00                     ;process X
3660	.d1ef		ca		dex		                dex                          ;...
3661	.d1f0		ca		dex		                dex                          ;...
3662	.d1f1		20 09 d2	jsr $d209	                jsr handleExternalCoordinate
3663	.d1f4		ac 61 03	ldy $0361	                ldy vduv.pixelsPerByteMinusOne
3664	.d1f7		c0 03		cpy #$03	                cpy #$03  ;
3665	.d1f9		f0 05		beq $d200	                beq +     ;branch taken if mode 1/5 - divide by 4 or 8
3666	.d1fb		b0 06		bcs $d203	                bcs ++    ;branch taken if mode 0/4 - divide by 2 or 4
3667	.d1fd		20 40 d2	jsr $d240	                jsr divideCoordinatesBy2     ;mode 2 - divide by 8
3668	.d200						+
3669	.d200		20 40 d2	jsr $d240	                jsr divideCoordinatesBy2
3670	.d203						+
3671	.d203		ad 56 03	lda $0356	                lda vduv.currentScreenMODEGroup
3672	.d206		d0 38		bne $d240	                bne divideCoordinatesBy2     ;branch taken if MODE 4/5
3673	.d208		60		rts		                rts

3675							;-------------------------------------------------------------------------
3676							;
3677							; Handle external coordinate.
3678							;
3679							; 1. Deal with absolute or relative PLOTting
3680							;
3681							; 2. Update graphics cursor position
3682							;
3683							; 3. Handle window origin
3684							;
3685							; 4. Update input coordinate
3686							;
3687							; 5. Divide result by 2 (as this always needs doing at least once)
3688							;
3689							; entry:
3690							;
3691							; ZTEMP?0 = PLOT number
3692							;
3693							; X = offset-2 of external coordinates
3694							;
3695							; Y = 0 to process X coordinate, 2 to process Y coordinate
3696							;
3697	.d209						handleExternalCoordinate:
3698	.d209		18		clc		                clc
3699	.d20a		a5 da		lda $da		                lda ZTEMP+0                  ;get PLOT number
3700	.d20c		29 04		and #$04	                and #$04                     ;get absolute/relative flag
3701	.d20e		f0 09		beq $d219	                beq relativePLOT             ;branch taken if relative
3702	.d210						absolutePLOT:
3703	.d210		bd 02 03	lda $0302,x	                lda vduv+2,x                 ;get coordinate LSB
3704	.d213		48		pha		                pha                          ;save coordinate LSB
3705	.d214		bd 03 03	lda $0303,x	                lda vduv+3,x                 ;get coordinate MSB
3706	.d217		80 0e		bra $d227	                bra LD229                    ;

3708	.d219						relativePLOT:
3709	.d219		bd 02 03	lda $0302,x	                lda vduv+2,x                 ;get coordinate LSB
3710	.d21c		79 10 03	adc $0310,y	                adc vduv.graphicsCursorPositionX+0,y ;add current position LSB
3711	.d21f		48		pha		                pha                                  ;save coordinate LSB
3712	.d220		bd 03 03	lda $0303,x	                lda vduv+3,x                 ;get coordinate MSB
3713	.d223		79 11 03	adc $0311,y	                adc vduv.graphicsCursorPositionX+1,y ;add current position MSB
3714	.d226		18		clc		                clc
3715	.d227						LD229:
3716	.d227		99 11 03	sta $0311,y	                sta vduv.graphicsCursorPositionX+1,y ;update current position MSB
3717	.d22a		79 0d 03	adc $030d,y	                adc vduv.graphicsWindowOriginX+1,y   ;add window origin MSB
3718	.d22d		9d 03 03	sta $0303,x	                sta vduv+3,x                  ;update coordinate MSB
3719	.d230		68		pla		                pla                          ;restore coordinate LSB
3720	.d231		99 10 03	sta $0310,y	                sta vduv.graphicsCursorPositionX+0,y ;update current position LSB
3721	.d234		18		clc		                clc
3722	.d235		79 0c 03	adc $030c,y	                adc vduv.graphicsWindowOriginX+0,y ;add window origin LSB
3723	.d238		9d 02 03	sta $0302,x	                sta vduv+2,x                       ;update coordinate LSB
3724	.d23b		90 03		bcc $d240	                bcc +
3725	.d23d		fe 03 03	inc $0303,x	                inc vduv+3,x       ;handle carry, ignored earlier
3726	.d240						+

3728	.d240						divideCoordinatesBy2:
3729	.d240		bd 03 03	lda $0303,x	                lda vduv+3,x
3730	.d243		0a		asl a		                asl a                        ;C=bit 7
3731	.d244		7e 03 03	ror $0303,x	                ror vduv+3,x                  ;signed divide by 2
3732	.d247		7e 02 03	ror $0302,x	                ror vduv+2,x                  ;signed divide by 2
3733	.d24a		60		rts		                rts

3735							;-------------------------------------------------------------------------

3737	.d24b						LD24D:
3738	.d24b		da		phx		                phx
3739	.d24c		5a		phy		                phy
3740	.d24d		5a		phy		                phy
3741	.d24e		da		phx		                phx
3742	.d24f		5a		phy		                phy
3743	.d250		20 7e d2	jsr $d27e	                jsr LD280
3744	.d253		fa		plx		                plx
3745	.d254		20 7e d2	jsr $d27e	                jsr LD280
3746	.d257		fa		plx		                plx
3747	.d258		7a		ply		                ply
3748	.d259		20 e6 da	jsr $dae6	                jsr LDAE8
3749	.d25c		fa		plx		                plx
3750	.d25d		20 66 d2	jsr $d266	                jsr LD268
3751	.d260		fa		plx		                plx
3752	.d261		80 03		bra $d266	                bra LD268

3754	.d263						LD265:
3755	.d263		20 9d 9d	jsr $9d9d	                jsr L9B09
3756	.d266						LD268:
3757	.d266		a0 00		ldy #$00	                ldy #$00
3758	.d268		20 6e d2	jsr $d26e	                jsr LD270
3759	.d26b		e8		inx		                inx
3760	.d26c		a0 02		ldy #$02	                ldy #$02
3761	.d26e						LD270:
3762	.d26e		38		sec		                sec
3763	.d26f		20 74 d2	jsr $d274	                jsr LD276
3764	.d272		e8		inx		                inx
3765	.d273		c8		iny		                iny
3766	.d274						LD276:
3767	.d274		bd 00 03	lda $0300,x	                lda $0300,x
3768	.d277		f9 14 03	sbc $0314,y	                sbc $0314,y
3769	.d27a		9d 00 03	sta $0300,x	                sta $0300,x
3770	.d27d						LD27F:
3771	.d27d		60		rts		                rts

3773	.d27e						LD280:
3774	.d27e		a0 00		ldy #$00	                ldy #$00
3775	.d280		20 86 d2	jsr $d286	                jsr LD288
3776	.d283		e8		inx		                inx
3777	.d284		a0 02		ldy #$02	                ldy #$02
3778	.d286						LD288:
3779	.d286		18		clc		                clc
3780	.d287		20 8c d2	jsr $d28c	                jsr LD28E
3781	.d28a		e8		inx		                inx
3782	.d28b		c8		iny		                iny
3783	.d28c						LD28E:
3784	.d28c		bd 00 03	lda $0300,x	                lda $0300,x
3785	.d28f		79 14 03	adc $0314,y	                adc $0314,y
3786	.d292		9d 00 03	sta $0300,x	                sta $0300,x
3787	.d295		60		rts		                rts

3789	.d296						LD298:
3790	.d296		85 e1		sta $e1		                sta $E1
3791	.d298		20 23 d4	jsr $d423	                jsr LD425
3792	.d29b		f0 e0		beq $d27d	                beq LD27F
3793	.d29d		a0 14		ldy #$14	                ldy #$14
3794	.d29f		a9 20		lda #$20	                lda #$20
3795	.d2a1		a2 2c		ldx #$2c	                ldx #$2C
3796	.d2a3		20 63 d2	jsr $d263	                jsr LD265
3797	.d2a6		20 a8 d3	jsr $d3a8	                jsr LD3AA
3798	.d2a9		a9 01		lda #$01	                lda #$01
3799	.d2ab						LD2AD:
3800	.d2ab		84 e0		sty $e0		                sty $E0
3801	.d2ad		04 e0		tsb $e0		                tsb $E0
3802	.d2af		a2 2c		ldx #$2c	                ldx #VDUVariables.workspace._2C
3803	.d2b1		a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
3804	.d2b3		20 1c c9	jsr $c91c	                jsr copyFourBytesWithinVDUVariables
3805	.d2b6		2c 35 03	bit $0335	                bit $0335
3806	.d2b9		08		php		                php
3807	.d2ba		a2 2c		ldx #$2c	                ldx #$2C
3808	.d2bc		20 24 d7	jsr $d724	                jsr LD726
3809	.d2bf		28		plp		                plp
3810	.d2c0		10 03		bpl $d2c5	                bpl LD2C7
3811	.d2c2		20 a8 d3	jsr $d3a8	                jsr LD3AA
3812	.d2c5						LD2C7:
3813	.d2c5		ac 2c 03	ldy $032c	                ldy $032C
3814	.d2c8		ad 2d 03	lda $032d	                lda $032D
3815	.d2cb		30 03		bmi $d2d0	                bmi LD2D2
3816	.d2cd		20 2c c9	jsr $c92c	                jsr negateAY
3817	.d2d0						LD2D2:
3818	.d2d0		48		pha		                pha
3819	.d2d1		18		clc		                clc
3820	.d2d2		98		tya		                tya
3821	.d2d3		6d 30 88	adc $8830	                adc L8830
3822	.d2d6		a8		tay		                tay
3823	.d2d7		68		pla		                pla
3824	.d2d8		6d 31 88	adc $8831	                adc L8831
3825	.d2db		10 ce		bpl $d2ab	                bpl LD2AD
3826	.d2dd		1a		inc a		                inc a
3827	.d2de		d0 23		bne $d303	                bne LD305
3828	.d2e0		c8		iny		                iny
3829	.d2e1		d0 20		bne $d303	                bne LD305
3830	.d2e3		a5 e0		lda $e0		                lda $E0
3831	.d2e5		f0 1c		beq $d303	                beq LD305
3832	.d2e7		ad 2c 03	lda $032c	                lda $032C
3833	.d2ea		cd 28 03	cmp $0328	                cmp $0328
3834	.d2ed		f0 14		beq $d303	                beq LD305
3835	.d2ef		a2 2c		ldx #$2c	                ldx #$2C
3836	.d2f1		a0 28		ldy #$28	                ldy #$28
3837	.d2f3		ad 36 03	lda $0336	                lda $0336
3838	.d2f6		0a		asl a		                asl a
3839	.d2f7		4d 36 03	eor $0336	                eor $0336
3840	.d2fa		10 04		bpl $d300	                bpl LD302
3841	.d2fc		e8		inx		                inx
3842	.d2fd		e8		inx		                inx
3843	.d2fe		c8		iny		                iny
3844	.d2ff		c8		iny		                iny
3845	.d300						LD302:
3846	.d300		20 0a c9	jsr $c90a	                jsr copyTwoBytesWithinVDUVariables
3847	.d303						LD305:
3848	.d303		20 23 d4	jsr $d423	                jsr LD425
3849	.d306		ad 29 03	lda $0329	                lda $0329
3850	.d309		aa		tax		                tax
3851	.d30a		4d 1c 03	eor $031c	                eor $031C
3852	.d30d		30 18		bmi $d327	                bmi LD329
3853	.d30f		a0 02		ldy #$02	                ldy #$02
3854	.d311		20 6d d4	jsr $d46d	                jsr LD46F
3855	.d314		d0 0c		bne $d322	                bne LD324
3856	.d316		ae 2b 03	ldx $032b	                ldx $032B
3857	.d319		a0 00		ldy #$00	                ldy #$00
3858	.d31b		20 6d d4	jsr $d46d	                jsr LD46F
3859	.d31e		f0 11		beq $d331	                beq LD333
3860	.d320		49 80		eor #$80	                eor #$80
3861	.d322						LD324:
3862	.d322		86 da		stx $da		                stx $DA
3863	.d324		45 da		eor $da		                eor $DA
3864	.d326		aa		tax		                tax
3865	.d327						LD329:
3866	.d327		8a		txa		                txa
3867	.d328		29 80		and #$80	                and #$80
3868	.d32a		f0 02		beq $d32e	                beq LD330
3869	.d32c		a9 c0		lda #$c0	                lda #$C0
3870	.d32e						LD330:
3871	.d32e		04 e1		tsb $e1		                tsb $E1
3872	.d330		18		clc		                clc
3873	.d331						LD333:
3874	.d331		60		rts		                rts

3876	.d332						LD334:
3877	.d332		a5 e1		lda $e1		                lda $E1
3878	.d334		8d 48 88	sta $8848	                sta L8848
3879	.d337		89 03		bit #$03	                bit #$03
3880	.d339		f0 f6		beq $d331	                beq LD333
3881	.d33b		a9 10		lda #$10	                lda #$10
3882	.d33d		85 dc		sta $dc		                sta $DC
3883	.d33f		0a		asl a		                asl a
3884	.d340		85 dd		sta $dd		                sta $DD
3885	.d342		a2 1b		ldx #$1b	                ldx #$1B
3886	.d344		20 4d d3	jsr $d34d	                jsr LD34F
3887	.d347		06 dc		asl $dc		                asl $DC
3888	.d349		46 dd		lsr $dd		                lsr $DD
3889	.d34b		a2 28		ldx #$28	                ldx #$28
3890	.d34d						LD34F:
3891	.d34d		a9 80		lda #$80	                lda #$80
3892	.d34f		85 da		sta $da		                sta $DA
3893	.d351		bd 02 03	lda $0302,x	                lda $0302,x
3894	.d354		cd 32 88	cmp $8832	                cmp L8832
3895	.d357		d0 d8		bne $d331	                bne LD333
3896	.d359		bd 03 03	lda $0303,x	                lda $0303,x
3897	.d35c		cd 33 88	cmp $8833	                cmp L8833
3898	.d35f		d0 d0		bne $d331	                bne LD333
3899	.d361		bc 00 03	ldy $0300,x	                ldy $0300,x
3900	.d364		bd 01 03	lda $0301,x	                lda $0301,x
3901	.d367		10 05		bpl $d36e	                bpl LD370
3902	.d369		46 da		lsr $da		                lsr $DA
3903	.d36b		20 2c c9	jsr $c92c	                jsr negateAY
3904	.d36e						LD370:
3905	.d36e		cc 30 88	cpy $8830	                cpy L8830
3906	.d371		d0 be		bne $d331	                bne LD333
3907	.d373		cd 31 88	cmp $8831	                cmp L8831
3908	.d376		d0 b9		bne $d331	                bne LD333
3909	.d378		a5 e1		lda $e1		                lda $E1
3910	.d37a		89 02		bit #$02	                bit #$02
3911	.d37c		f0 19		beq $d397	                beq LD399
3912	.d37e		a0 30		ldy #$30	                ldy #$30
3913	.d380		89 01		bit #$01	                bit #$01
3914	.d382		f0 02		beq $d386	                beq LD388
3915	.d384		a4 dc		ldy $dc		                ldy $DC
3916	.d386						LD388:
3917	.d386		98		tya		                tya
3918	.d387		4a		lsr a		                lsr a
3919	.d388		4a		lsr a		                lsr a
3920	.d389		24 e1		bit $e1		                bit $E1
3921	.d38b		d0 06		bne $d393	                bne LD395
3922	.d38d		05 dc		ora $dc		                ora $DC
3923	.d38f		04 e1		tsb $e1		                tsb $E1
3924	.d391		80 04		bra $d397	                bra LD399

3926	.d393						LD395:
3927	.d393		05 dd		ora $dd		                ora $DD
3928	.d395		14 e1		trb $e1		                trb $E1
3929	.d397						LD399:
3930	.d397		a5 da		lda $da		                lda $DA
3931	.d399		24 e1		bit $e1		                bit $E1
3932	.d39b		f0 91		beq $d32e	                beq LD330
3933	.d39d		14 e1		trb $e1		                trb $E1
3934	.d39f		a5 e1		lda $e1		                lda $E1
3935	.d3a1		8d 48 88	sta $8848	                sta L8848
3936	.d3a4		8d 49 88	sta $8849	                sta L8849
3937	.d3a7		60		rts		                rts

3939	.d3a8						LD3AA:
3940	.d3a8		ad 2e 03	lda $032e	                lda $032E
3941	.d3ab		8d 32 88	sta $8832	                sta L8832
3942	.d3ae		ad 2f 03	lda $032f	                lda $032F
3943	.d3b1		8d 33 88	sta $8833	                sta L8833
3944	.d3b4		20 fa d3	jsr $d3fa	                jsr LD3FC
3945	.d3b7		20 11 d5	jsr $d511	                jsr LD513
3946	.d3ba		8c 30 88	sty $8830	                sty L8830
3947	.d3bd		ad 46 88	lda $8846	                lda L8846
3948	.d3c0		4a		lsr a		                lsr a
3949	.d3c1		ad 3d 88	lda $883d	                lda L883D
3950	.d3c4		90 06		bcc $d3cc	                bcc LD3CE
3951	.d3c6		c9 80		cmp #$80	                cmp #$80
3952	.d3c8		6a		ror a		                ror a
3953	.d3c9		6e 30 88	ror $8830	                ror L8830
3954	.d3cc						LD3CE:
3955	.d3cc		8d 31 88	sta $8831	                sta L8831
3956	.d3cf		60		rts		                rts

3958	.d3d0						LD3D2:
3959	.d3d0		9c 47 88	stz $8847	                stz L8847
3960	.d3d3		9c 30 88	stz $8830	                stz L8830
3961	.d3d6		9c 31 88	stz $8831	                stz L8831
3962	.d3d9		9c 34 88	stz $8834	                stz L8834
3963	.d3dc		9c 35 88	stz $8835	                stz L8835
3964	.d3df		ad 32 88	lda $8832	                lda L8832
3965	.d3e2		0a		asl a		                asl a
3966	.d3e3		8d 36 88	sta $8836	                sta L8836
3967	.d3e6		ad 33 88	lda $8833	                lda L8833
3968	.d3e9		2a		rol a		                rol a
3969	.d3ea		8d 37 88	sta $8837	                sta L8837
3970	.d3ed		ad 46 88	lda $8846	                lda L8846
3971	.d3f0		89 02		bit #$02	                bit #$02
3972	.d3f2		f0 06		beq $d3fa	                beq LD3FC
3973	.d3f4		0e 36 88	asl $8836	                asl L8836
3974	.d3f7		2e 37 88	rol $8837	                rol L8837
3975	.d3fa						LD3FC:
3976	.d3fa		ad 46 88	lda $8846	                lda L8846
3977	.d3fd		4a		lsr a		                lsr a
3978	.d3fe		4a		lsr a		                lsr a
3979	.d3ff		ac 32 88	ldy $8832	                ldy L8832
3980	.d402		ad 33 88	lda $8833	                lda L8833
3981	.d405		20 c3 d4	jsr $d4c3	                jsr LD4C5
3982	.d408		38		sec		                sec
3983	.d409		a2 fc		ldx #$fc	                ldx #$FC
3984	.d40b						LD40D:
3985	.d40b		bd 3c 87	lda $873c,x	                lda L873C,x
3986	.d40e		fd 44 87	sbc $8744,x	                sbc L8744,x
3987	.d411		9d 44 87	sta $8744,x	                sta L8744,x
3988	.d414		e8		inx		                inx
3989	.d415		d0 f4		bne $d40b	                bne LD40D
3990	.d417		60		rts		                rts

3992	.d418						LD41A:
3993	.d418		20 18 c9	jsr $c918	                jsr copyGraphicsCursorPixelsToOldGraphicsCursorPixels
3994	.d41b		64 e1		stz $e1		                stz $E1
3995	.d41d		a2 20		ldx #$20	                ldx #$20
3996	.d41f		20 25 d4	jsr $d425	                jsr LD427
3997	.d422		60		rts		                rts

3999	.d423						LD425:
4000	.d423		a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX
4001	.d425						LD427:
4002	.d425		a0 1b		ldy #$1b	                ldy #VDUVariables.queueEnd-9
4003	.d427		20 1c c9	jsr $c91c	                jsr copyFourBytesWithinVDUVariables
4004	.d42a		a2 1b		ldx #$1b	                ldx #$1B
4005	.d42c		20 66 d2	jsr $d266	                jsr LD268
4006	.d42f		20 84 d4	jsr $d484	                jsr LD486
4007	.d432		20 11 d5	jsr $d511	                jsr LD513
4008	.d435		a0 0c		ldy #$0c	                ldy #$0C
4009	.d437		20 a9 d4	jsr $d4a9	                jsr LD4AB
4010	.d43a		20 11 d5	jsr $d511	                jsr LD513
4011	.d43d		c9 20		cmp #$20	                cmp #$20
4012	.d43f		90 05		bcc $d446	                bcc LD448
4013	.d441		68		pla		                pla
4014	.d442		68		pla		                pla
4015	.d443		68		pla		                pla
4016	.d444		68		pla		                pla
4017	.d445		60		rts		                rts

4019	.d446						LD448:
4020	.d446		8c 44 88	sty $8844	                sty L8844
4021	.d449		8d 45 88	sta $8845	                sta L8845
4022	.d44c		ad 46 88	lda $8846	                lda L8846
4023	.d44f		89 02		bit #$02	                bit #$02
4024	.d451		f0 06		beq $d459	                beq LD45B
4025	.d453		4e 45 88	lsr $8845	                lsr L8845
4026	.d456		6e 44 88	ror $8844	                ror L8844
4027	.d459						LD45B:
4028	.d459		ac 44 88	ldy $8844	                ldy L8844
4029	.d45c		ad 45 88	lda $8845	                lda L8845
4030	.d45f		20 2c c9	jsr $c92c	                jsr negateAY
4031	.d462		8c 32 88	sty $8832	                sty L8832
4032	.d465		8d 33 88	sta $8833	                sta L8833
4033	.d468		0d 32 88	ora $8832	                ora L8832
4034	.d46b		38		sec		                sec
4035	.d46c		60		rts		                rts

4037	.d46d						LD46F:
4038	.d46d		64 da		stz $da		                stz $DA
4039	.d46f		b9 1b 03	lda $031b,y	                lda $031B,y
4040	.d472		d9 28 03	cmp $0328,y	                cmp $0328,y
4041	.d475		f0 02		beq $d479	                beq LD47B
4042	.d477		e6 da		inc $da		                inc $DA
4043	.d479						LD47B:
4044	.d479		b9 1c 03	lda $031c,y	                lda $031C,y
4045	.d47c		f9 29 03	sbc $0329,y	                sbc $0329,y
4046	.d47f		d0 02		bne $d483	                bne LD485
4047	.d481		a5 da		lda $da		                lda $DA
4048	.d483						LD485:
4049	.d483		60		rts		                rts

4051	.d484						LD486:
4052	.d484		ae 55 03	ldx $0355	                ldx $0355
4053	.d487		bd bd d4	lda $d4bd,x	                lda LD4BF,x
4054	.d48a		8d 46 88	sta $8846	                sta L8846
4055	.d48d		4a		lsr a		                lsr a
4056	.d48e		48		pha		                pha
4057	.d48f		a2 04		ldx #$04	                ldx #$04
4058	.d491						LD493:
4059	.d491		9e 37 88	stz $8837,x	                stz L8837,x
4060	.d494		ca		dex		                dex
4061	.d495		d0 fa		bne $d491	                bne LD493
4062	.d497		20 9e d4	jsr $d49e	                jsr LD4A0
4063	.d49a		68		pla		                pla
4064	.d49b		4a		lsr a		                lsr a
4065	.d49c		a2 02		ldx #$02	                ldx #$02
4066	.d49e						LD4A0:
4067	.d49e		bc 1b 03	ldy $031b,x	                ldy $031B,x
4068	.d4a1		bd 1c 03	lda $031c,x	                lda $031C,x
4069	.d4a4		20 c3 d4	jsr $d4c3	                jsr LD4C5
4070	.d4a7		a0 10		ldy #$10	                ldy #$10
4071	.d4a9						LD4AB:
4072	.d4a9		18		clc		                clc
4073	.d4aa		a2 fc		ldx #$fc	                ldx #$FC
4074	.d4ac						LD4AE:
4075	.d4ac		bd 3c 87	lda $873c,x	                lda L873C,x
4076	.d4af		79 30 88	adc $8830,y	                adc L8830,y
4077	.d4b2		9d 3c 87	sta $873c,x	                sta L873C,x
4078	.d4b5		9d 44 87	sta $8744,x	                sta L8744,x
4079	.d4b8		c8		iny		                iny
4080	.d4b9		e8		inx		                inx
4081	.d4ba		d0 f0		bne $d4ac	                bne LD4AE
4082	.d4bc		60		rts		                rts

4084	.d4bd						LD4BF:
4085	>d4bd		02				                .byte $02
4086	.d4be		00		brk #		                brk
4087	.d4bf		01 ff		ora ($ff,x)	                ora ($FF,x)
4088	.d4c1		00		brk #		                brk
4089							;ORA (&8C,x)      :\ D4C4= 01       ..
4090	>d4c2		01				                .byte $01
4091	.d4c3						LD4C5:
4092	.d4c3		8c 3c 88	sty $883c	                sty L883C
4093	.d4c6		90 04		bcc $d4cc	                bcc LD4CE
4094	.d4c8		0e 3c 88	asl $883c	                asl L883C
4095	.d4cb		2a		rol a		                rol a
4096	.d4cc						LD4CE:
4097	.d4cc		8d 3d 88	sta $883d	                sta L883D
4098	.d4cf		ac 3c 88	ldy $883c	                ldy L883C
4099	.d4d2		aa		tax		                tax
4100	.d4d3		10 03		bpl $d4d8	                bpl LD4DA
4101	.d4d5		20 2c c9	jsr $c92c	                jsr negateAY
4102	.d4d8						LD4DA:
4103	.d4d8		8c 3c 88	sty $883c	                sty L883C
4104	.d4db		8d 3d 88	sta $883d	                sta L883D
4105	.d4de		8c 40 88	sty $8840	                sty L8840
4106	.d4e1		9c 42 88	stz $8842	                stz L8842
4107	.d4e4		9c 43 88	stz $8843	                stz L8843
4108	.d4e7		a0 0f		ldy #$0f	                ldy #$0F
4109	.d4e9		4a		lsr a		                lsr a
4110	.d4ea		8d 41 88	sta $8841	                sta L8841
4111	.d4ed		6e 40 88	ror $8840	                ror L8840
4112	.d4f0						LD4F2:
4113	.d4f0		90 13		bcc $d505	                bcc LD507
4114	.d4f2		18		clc		                clc
4115	.d4f3		ad 3c 88	lda $883c	                lda L883C
4116	.d4f6		6d 42 88	adc $8842	                adc L8842
4117	.d4f9		8d 42 88	sta $8842	                sta L8842
4118	.d4fc		ad 3d 88	lda $883d	                lda L883D
4119	.d4ff		6d 43 88	adc $8843	                adc L8843
4120	.d502		8d 43 88	sta $8843	                sta L8843
4121	.d505						LD507:
4122	.d505		a2 03		ldx #$03	                ldx #$03
4123	.d507						LD509:
4124	.d507		7e 40 88	ror $8840,x	                ror L8840,x
4125	.d50a		ca		dex		                dex
4126	.d50b		10 fa		bpl $d507	                bpl LD509
4127	.d50d		88		dey		                dey
4128	.d50e		10 e0		bpl $d4f0	                bpl LD4F2
4129	.d510		60		rts		                rts

4131	.d511						LD513:
4132	.d511		a2 02		ldx #$02	                ldx #$02
4133	.d513						LD515:
4134	.d513		9e 3c 88	stz $883c,x	                stz L883C,x
4135	.d516		74 db		stz $db,x	                stz $DB,x
4136	.d518		ca		dex		                dex
4137	.d519		10 f8		bpl $d513	                bpl LD515
4138	.d51b		a0 03		ldy #$03	                ldy #$03
4139	.d51d						LD51F:
4140	.d51d		b9 40 88	lda $8840,y	                lda L8840,y
4141	.d520		85 da		sta $da		                sta $DA
4142	.d522		5a		phy		                phy
4143	.d523		a0 03		ldy #$03	                ldy #$03
4144	.d525						LD527:
4145	.d525		5a		phy		                phy
4146	.d526		38		sec		                sec
4147	.d527		2e 3c 88	rol $883c	                rol L883C
4148	.d52a		2e 3d 88	rol $883d	                rol L883D
4149	.d52d		2e 3e 88	rol $883e	                rol L883E
4150	.d530		a2 01		ldx #$01	                ldx #$01
4151	.d532		a5 db		lda $db		                lda $DB
4152	.d534						LD536:
4153	.d534		06 da		asl $da		                asl $DA
4154	.d536		2a		rol a		                rol a
4155	.d537		26 dc		rol $dc		                rol $DC
4156	.d539		26 dd		rol $dd		                rol $DD
4157	.d53b		ca		dex		                dex
4158	.d53c		10 f6		bpl $d534	                bpl LD536
4159	.d53e		85 db		sta $db		                sta $DB
4160	.d540		38		sec		                sec
4161	.d541		ed 3c 88	sbc $883c	                sbc L883C
4162	.d544		aa		tax		                tax
4163	.d545		a5 dc		lda $dc		                lda $DC
4164	.d547		ed 3d 88	sbc $883d	                sbc L883D
4165	.d54a		a8		tay		                tay
4166	.d54b		a5 dd		lda $dd		                lda $DD
4167	.d54d		ed 3e 88	sbc $883e	                sbc L883E
4168	.d550		90 0b		bcc $d55d	                bcc LD55F
4169	.d552		85 dd		sta $dd		                sta $DD
4170	.d554		84 dc		sty $dc		                sty $DC
4171	.d556		86 db		stx $db		                stx $DB
4172	.d558		ee 3c 88	inc $883c	                inc L883C
4173	.d55b		80 03		bra $d560	                bra LD562

4175	.d55d						LD55F:
4176	.d55d		ce 3c 88	dec $883c	                dec L883C
4177	.d560						LD562:
4178	.d560		7a		ply		                ply
4179	.d561		88		dey		                dey
4180	.d562		10 c1		bpl $d525	                bpl LD527
4181	.d564		7a		ply		                ply
4182	.d565		88		dey		                dey
4183	.d566		10 b5		bpl $d51d	                bpl LD51F
4184	.d568		4e 3e 88	lsr $883e	                lsr L883E
4185	.d56b		6e 3d 88	ror $883d	                ror L883D
4186	.d56e		6e 3c 88	ror $883c	                ror L883C
4187	.d571		9c 3e 88	stz $883e	                stz L883E
4188	.d574		9c 3f 88	stz $883f	                stz L883F
4189	.d577		ac 3c 88	ldy $883c	                ldy L883C
4190	.d57a		ad 3d 88	lda $883d	                lda L883D
4191	.d57d		60		rts		                rts

4193							;-------------------------------------------------------------------------
4194							;
4195							; Add dimension of region to a coordinate.
4196							;
4197							; entry:
4198							;
4199							; X = VDU variable offset of coordinate
4200							;
4201							; A = VDU variable offset of minimum coordinate of region
4202							;
4203							; Y = VDU variable offset of maximum coordinate of region
4204							;
4205							; ZTEMP?0 = VDU variable offset for result
4206							;
4207							; exit:
4208							;
4209							; result variable = coordinate+(min-max)
4210							;
4211	.d57e						addRegionDimensionsToVDUVariableCoordinates:
4212	.d57e		20 8b d5	jsr $d58b	                jsr addRegionDimensionToVDUVariableCoordinate ;do X

4214							                ; bump offsets to do Y.
4215	.d581		c8		iny		                iny
4216	.d582		c8		iny		                iny
4217	.d583		e8		inx		                inx
4218	.d584		e8		inx		                inx
4219	.d585		1a		inc a		                inc a
4220	.d586		1a		inc a		                inc a
4221	.d587		e6 da		inc $da		                inc ZTEMP+0
4222	.d589		e6 da		inc $da		                inc ZTEMP+0

4224							                ; TODO - not a great name. Could probably just be
4225							                ; addDifference, or something.
4226	.d58b						addRegionDimensionToVDUVariableCoordinate:
4227	.d58b		da		phx		                phx                          ;save VX
4228	.d58c		5a		phy		                phy                          ;save VY
4229	.d58d		48		pha		                pha                          ;save VA
4230	.d58e		18		clc		                clc
4231	.d58f		bd 00 03	lda $0300,x	                lda vduv+0,x                 ;<VX
4232	.d592		79 00 03	adc $0300,y	                adc vduv+0,y                 ;<(VX+VY)
4233	.d595		85 de		sta $de		                sta ZTEMPC+0                 ;ZTEMPC?0=<(VX+VY)
4234	.d597		bd 01 03	lda $0301,x	                lda vduv+1,x                 ;>VX
4235	.d59a		79 01 03	adc $0301,y	                adc vduv+1,y                 ;>(VX+VY)
4236	.d59d		fa		plx		                plx                          ;X=VA
4237	.d59e		48		pha		                pha                          ;save >(VX+VY)
4238	.d59f		a4 da		ldy $da		                ldy ZTEMP+0                  ;Y=VT
4239	.d5a1		38		sec		                sec
4240	.d5a2		a5 de		lda $de		                lda ZTEMPC+0                 ;<(VX+VY)
4241	.d5a4		fd 00 03	sbc $0300,x	                sbc vduv+0,x                 ;<(VX+VY-VA)
4242	.d5a7		99 00 03	sta $0300,y	                sta vduv+0,y                 ;<VT=<(VX+VY-VA)
4243	.d5aa		68		pla		                pla                          ;>(VX+VY)
4244	.d5ab		fd 01 03	sbc $0301,x	                sbc vduv+1,x                 ;>(VX+VY-VA)
4245	.d5ae		99 01 03	sta $0301,y	                sta vduv+1,y                 ;>VT=<(VX+VY-VA)
4246	.d5b1		8a		txa		                txa                          ;restore old A
4247	.d5b2		7a		ply		                ply                          ;restore old Y
4248	.d5b3		fa		plx		                plx                          ;restore old X
4249	.d5b4		60		rts		                rts

4251							;-------------------------------------------------------------------------
4252							;
4253							; Sort points by Y coordinate, then X.
4254							;
4255							; entry:
4256							;
4257							; X = VDU variable offset of point A (4 bytes: X;Y;)
4258							;
4259							; Y = VDU variable offset of point B (4 bytes: X;Y;)
4260							;
4261							; exit:
4262							;
4263							; X = offset of point with lesser Y (or lesser X, if same Y)
4264							;
4265							; Y = offset of point with greater Y (or greater X, if same Y)
4266							;
4267	.d5b5						sortVDUVariableCoordinates:
4268	.d5b5		38		sec		                sec
4269	.d5b6		b9 02 03	lda $0302,y	                lda vduv+2,y
4270	.d5b9		fd 02 03	sbc $0302,x	                sbc vduv+2,x
4271	.d5bc		85 de		sta $de		                sta ZTEMPC
4272	.d5be		b9 03 03	lda $0303,y	                lda vduv+3,y
4273	.d5c1		fd 03 03	sbc $0303,x	                sbc vduv+3,x
4274	.d5c4		30 09		bmi $d5cf	                bmi exchangeXAndY           ;taken if PX.y>PY.y
4275	.d5c6		05 de		ora $de		                ora ZTEMPC
4276	.d5c8		d0 09		bne $d5d3	                bne rtsD5D5                  ;taken if PX.y<PY.y

4278							;-------------------------------------------------------------------------
4279							;
4280							; Sort words by value.
4281							;
4282							; entry:
4283							;
4284							; X = VDU variable offset of word A
4285							;
4286							; Y = VDU variable offset of word B
4287							;
4288							; exit:
4289							;
4290							; X = offset of lesser value
4291							;
4292							; Y = offset of greater value
4293							;
4294	.d5ca						sortVDUVariableWords:
4295	.d5ca		20 d4 d5	jsr $d5d4	                jsr compareVDUVariableWords
4296	.d5cd		10 04		bpl $d5d3	                bpl rtsD5D5
4297	.d5cf						exchangeXAndY:
4298	.d5cf		8a		txa		                txa
4299	.d5d0		5a		phy		                phy
4300	.d5d1		fa		plx		                plx
4301	.d5d2		a8		tay		                tay
4302	.d5d3						rtsD5D5:
4303	.d5d3		60		rts		                rts

4305							;-------------------------------------------------------------------------
4306							;
4307							; Compare 2 16-bit VDU variable values.
4308							;
4309							; entry:
4310							;
4311							; X = offset of one variable
4312							;
4313							; Y = offset of the other variable
4314							;
4315							; exit:
4316							;
4317							; N=1 if X>Y
4318							;
4319	.d5d4						compareVDUVariableWords:
4320	.d5d4		b9 00 03	lda $0300,y	                lda vduv+0,y
4321	.d5d7		dd 00 03	cmp $0300,x	                cmp vduv+0,x
4322	.d5da		b9 01 03	lda $0301,y	                lda vduv+1,y
4323	.d5dd		fd 01 03	sbc $0301,x	                sbc vduv+1,x
4324	.d5e0		60		rts		                rts

4326							;-------------------------------------------------------------------------

4328	.d5e1						LD5E3:
4329	.d5e1		ee 47 88	inc $8847	                inc L8847
4330	.d5e4						LD5E6:
4331	.d5e4		ad 47 88	lda $8847	                lda L8847
4332	.d5e7		d0 0f		bne $d5f8	                bne LD5FA
4333	.d5e9		ad 32 88	lda $8832	                lda L8832
4334	.d5ec		0d 33 88	ora $8833	                ora L8833
4335	.d5ef		f0 f0		beq $d5e1	                beq LD5E3
4336	.d5f1		a2 00		ldx #$00	                ldx #$00
4337	.d5f3		20 42 d6	jsr $d642	                jsr LD644
4338	.d5f6		10 49		bpl $d641	                bpl LD643
4339	.d5f8						LD5FA:
4340	.d5f8		a2 02		ldx #$02	                ldx #$02
4341	.d5fa		20 42 d6	jsr $d642	                jsr LD644
4342	.d5fd		10 42		bpl $d641	                bpl LD643
4343	.d5ff		a2 00		ldx #$00	                ldx #$00
4344	.d601		20 08 d6	jsr $d608	                jsr LD60A
4345	.d604		10 3b		bpl $d641	                bpl LD643
4346	.d606		a2 02		ldx #$02	                ldx #$02
4347	.d608						LD60A:
4348	.d608		bd 30 88	lda $8830,x	                lda L8830,x
4349	.d60b		d0 03		bne $d610	                bne LD612
4350	.d60d		de 31 88	dec $8831,x	                dec L8831,x
4351	.d610						LD612:
4352	.d610		de 30 88	dec $8830,x	                dec L8830,x
4353	.d613		8a		txa		                txa
4354	.d614		4a		lsr a		                lsr a
4355	.d615		1a		inc a		                inc a
4356	.d616		2c 46 88	bit $8846	                bit L8846
4357	.d619		f0 03		beq $d61e	                beq LD620
4358	.d61b		20 1e d6	jsr $d61e	                jsr LD620
4359	.d61e						LD620:
4360	.d61e		20 34 d6	jsr $d634	                jsr LD636
4361	.d621		18		clc		                clc
4362	.d622		ad 40 88	lda $8840	                lda L8840
4363	.d625		7d 34 88	adc $8834,x	                adc L8834,x
4364	.d628		8d 40 88	sta $8840	                sta L8840
4365	.d62b		ad 41 88	lda $8841	                lda L8841
4366	.d62e		7d 35 88	adc $8835,x	                adc L8835,x
4367	.d631		8d 41 88	sta $8841	                sta L8841
4368	.d634						LD636:
4369	.d634		08		php		                php
4370	.d635		bd 34 88	lda $8834,x	                lda L8834,x
4371	.d638		d0 03		bne $d63d	                bne LD63F
4372	.d63a		de 35 88	dec $8835,x	                dec L8835,x
4373	.d63d						LD63F:
4374	.d63d		de 34 88	dec $8834,x	                dec L8834,x
4375	.d640		28		plp		                plp
4376	.d641						LD643:
4377	.d641		60		rts		                rts

4379	.d642						LD644:
4380	.d642		fe 30 88	inc $8830,x	                inc L8830,x
4381	.d645		d0 03		bne $d64a	                bne LD64C
4382	.d647		fe 31 88	inc $8831,x	                inc L8831,x
4383	.d64a						LD64C:
4384	.d64a		8a		txa		                txa
4385	.d64b		4a		lsr a		                lsr a
4386	.d64c		1a		inc a		                inc a
4387	.d64d		2c 46 88	bit $8846	                bit L8846
4388	.d650		f0 03		beq $d655	                beq LD657
4389	.d652		20 55 d6	jsr $d655	                jsr LD657
4390	.d655						LD657:
4391	.d655		20 6b d6	jsr $d66b	                jsr LD66D
4392	.d658		38		sec		                sec
4393	.d659		ad 40 88	lda $8840	                lda L8840
4394	.d65c		fd 34 88	sbc $8834,x	                sbc L8834,x
4395	.d65f		8d 40 88	sta $8840	                sta L8840
4396	.d662		ad 41 88	lda $8841	                lda L8841
4397	.d665		fd 35 88	sbc $8835,x	                sbc L8835,x
4398	.d668		8d 41 88	sta $8841	                sta L8841
4399	.d66b						LD66D:
4400	.d66b		08		php		                php
4401	.d66c		fe 34 88	inc $8834,x	                inc L8834,x
4402	.d66f		d0 03		bne $d674	                bne LD676
4403	.d671		fe 35 88	inc $8835,x	                inc L8835,x
4404	.d674						LD676:
4405	.d674		28		plp		                plp
4406	.d675		60		rts		                rts

4408	.d676						LD678:
4409	.d676		48		pha		                pha
4410	.d677		38		sec		                sec
4411	.d678		b9 00 03	lda $0300,y	                lda $0300,y
4412	.d67b		fd 00 03	sbc $0300,x	                sbc $0300,x
4413	.d67e		48		pha		                pha
4414	.d67f		b9 01 03	lda $0301,y	                lda $0301,y
4415	.d682		fd 01 03	sbc $0301,x	                sbc $0301,x
4416	.d685		7a		ply		                ply
4417	.d686		c9 80		cmp #$80	                cmp #$80
4418	.d688		90 03		bcc $d68d	                bcc LD68F
4419	.d68a		20 2c c9	jsr $c92c	                jsr negateAY
4420	.d68d						LD68F:
4421	.d68d		fa		plx		                plx
4422	.d68e		9d 01 03	sta $0301,x	                sta $0301,x
4423	.d691		98		tya		                tya
4424	.d692		9d 00 03	sta $0300,x	                sta $0300,x
4425	.d695		60		rts		                rts

4427	.d696						LD698:
4428	.d696		a2 37		ldx #$37	                ldx #$37
4429	.d698		20 21 d7	jsr $d721	                jsr LD723
4430	.d69b						LD69D:
4431	.d69b		3c 0a 03	bit $030a,x	                bit $030A,x
4432	.d69e		70 10		bvs $d6b0	                bvs LD6B2
4433	.d6a0		60		rts		                rts

4435	.d6a1						LD6A3:
4436	.d6a1		a2 2c		ldx #$2c	                ldx #$2C
4437	.d6a3		20 21 d7	jsr $d721	                jsr LD723
4438	.d6a6						LD6A8:
4439	.d6a6		3c 0a 03	bit $030a,x	                bit $030A,x
4440	.d6a9		50 05		bvc $d6b0	                bvc LD6B2
4441	.d6ab		60		rts		                rts

4443	.d6ac						LD6AE:
4444	.d6ac		fa		plx		                plx
4445	.d6ad		20 24 d7	jsr $d724	                jsr LD726
4446	.d6b0						LD6B2:
4447	.d6b0		bd 09 03	lda $0309,x	                lda $0309,x
4448	.d6b3		30 10		bmi $d6c5	                bmi LD6C7
4449	.d6b5		a0 03		ldy #$03	                ldy #$03
4450	.d6b7		da		phx		                phx
4451	.d6b8						LD6BA:
4452	.d6b8		bd 00 03	lda $0300,x	                lda $0300,x
4453	.d6bb		dd 1e 88	cmp $881e,x	                cmp L881E,x
4454	.d6be		d0 ec		bne $d6ac	                bne LD6AE
4455	.d6c0		e8		inx		                inx
4456	.d6c1		88		dey		                dey
4457	.d6c2		10 f4		bpl $d6b8	                bpl LD6BA
4458	.d6c4		fa		plx		                plx
4459	.d6c5						LD6C7:
4460	.d6c5		60		rts		                rts

4462	.d6c6						LD6C8:
4463	.d6c6		20 fb d6	jsr $d6fb	                jsr LD6FD
4464	.d6c9		bd 0a 03	lda $030a,x	                lda $030A,x
4465	.d6cc		0a		asl a		                asl a
4466	.d6cd		0a		asl a		                asl a
4467	.d6ce		bd 0a 03	lda $030a,x	                lda $030A,x
4468	.d6d1		6a		ror a		                ror a
4469	.d6d2		85 da		sta $da		                sta $DA
4470	.d6d4		18		clc		                clc
4471	.d6d5		10 0f		bpl $d6e6	                bpl LD6E8
4472	.d6d7		bd 02 03	lda $0302,x	                lda $0302,x
4473	.d6da		ed 04 03	sbc $0304	                sbc $0304
4474	.d6dd		a8		tay		                tay
4475	.d6de		bd 03 03	lda $0303,x	                lda $0303,x
4476	.d6e1		ed 05 03	sbc $0305	                sbc $0305
4477	.d6e4		80 0d		bra $d6f3	                bra LD6F5

4479	.d6e6						LD6E8:
4480	.d6e6		ad 00 03	lda $0300	                lda $0300
4481	.d6e9		fd 02 03	sbc $0302,x	                sbc $0302,x
4482	.d6ec		a8		tay		                tay
4483	.d6ed		ad 01 03	lda $0301	                lda $0301
4484	.d6f0		fd 03 03	sbc $0303,x	                sbc $0303,x
4485	.d6f3						LD6F5:
4486	.d6f3		20 a2 d7	jsr $d7a2	                jsr LD7A4
4487	.d6f6		20 fb d6	jsr $d6fb	                jsr LD6FD
4488	.d6f9		80 58		bra $d753	                bra LD755

4490	.d6fb						LD6FD:
4491	.d6fb		8a		txa		                txa
4492	.d6fc		1a		inc a		                inc a
4493	.d6fd		48		pha		                pha
4494	.d6fe		1a		inc a		                inc a
4495	.d6ff		a8		tay		                tay
4496	.d700		20 b0 e2	jsr $e2b0	                jsr exchangeTwoVDUBytes
4497	.d703		e8		inx		                inx
4498	.d704		e8		inx		                inx
4499	.d705		c8		iny		                iny
4500	.d706		c8		iny		                iny
4501	.d707		20 b0 e2	jsr $e2b0	                jsr exchangeTwoVDUBytes
4502	.d70a		fa		plx		                plx
4503	.d70b		20 0f d7	jsr $d70f	                jsr LD711
4504	.d70e		ca		dex		                dex
4505	.d70f						LD711:
4506	.d70f		bd 08 03	lda $0308,x	                lda $0308,x
4507	.d712		49 ff		eor #$ff	                eor #$FF
4508	.d714		9d 08 03	sta $0308,x	                sta $0308,x
4509	.d717		60		rts		                rts

4511	.d718						LD71A:
4512	.d718		20 24 d7	jsr $d724	                jsr LD726
4513	.d71b						LD71D:
4514	.d71b		bd 09 03	lda $0309,x	                lda $0309,x
4515	.d71e		10 f8		bpl $d718	                bpl LD71A
4516	.d720		60		rts		                rts

4518	.d721						LD723:
4519	.d721		20 1b d7	jsr $d71b	                jsr LD71D
4520	.d724						LD726:
4521	.d724		bd 09 03	lda $0309,x	                lda $0309,x
4522	.d727		10 2a		bpl $d753	                bpl LD755
4523	.d729						LD72B:
4524	.d729		18		clc		                clc
4525	.d72a		bd 08 03	lda $0308,x	                lda $0308,x
4526	.d72d		7d 04 03	adc $0304,x	                adc $0304,x
4527	.d730		9d 08 03	sta $0308,x	                sta $0308,x
4528	.d733		bd 09 03	lda $0309,x	                lda $0309,x
4529	.d736		7d 05 03	adc $0305,x	                adc $0305,x
4530	.d739		9d 09 03	sta $0309,x	                sta $0309,x
4531	.d73c		30 03		bmi $d741	                bmi LD743
4532	.d73e		20 53 d7	jsr $d753	                jsr LD755
4533	.d741						LD743:
4534	.d741		da		phx		                phx
4535	.d742		e8		inx		                inx
4536	.d743		e8		inx		                inx
4537	.d744		3c 08 03	bit $0308,x	                bit $0308,x
4538	.d747		30 23		bmi $d76c	                bmi LD76E
4539	.d749						LD74B:
4540	.d749		fe 00 03	inc $0300,x	                inc $0300,x
4541	.d74c		d0 03		bne $d751	                bne LD753
4542	.d74e		fe 01 03	inc $0301,x	                inc $0301,x
4543	.d751						LD753:
4544	.d751		fa		plx		                plx
4545	.d752		60		rts		                rts

4547	.d753						LD755:
4548	.d753		38		sec		                sec
4549	.d754		bd 08 03	lda $0308,x	                lda $0308,x
4550	.d757		fd 06 03	sbc $0306,x	                sbc $0306,x
4551	.d75a		9d 08 03	sta $0308,x	                sta $0308,x
4552	.d75d		bd 09 03	lda $0309,x	                lda $0309,x
4553	.d760		fd 07 03	sbc $0307,x	                sbc $0307,x
4554	.d763		9d 09 03	sta $0309,x	                sta $0309,x
4555	.d766		da		phx		                phx
4556	.d767		3c 0a 03	bit $030a,x	                bit $030A,x
4557	.d76a		50 dd		bvc $d749	                bvc LD74B
4558	.d76c						LD76E:
4559	.d76c		bd 00 03	lda $0300,x	                lda $0300,x
4560	.d76f		d0 03		bne $d774	                bne LD776
4561	.d771		de 01 03	dec $0301,x	                dec $0301,x
4562	.d774						LD776:
4563	.d774		de 00 03	dec $0300,x	                dec $0300,x
4564	.d777		fa		plx		                plx
4565	.d778		60		rts		                rts

4567	.d779						LD77B:
4568	.d779		18		clc		                clc
4569	.d77a		bd 0a 03	lda $030a,x	                lda $030A,x
4570	.d77d		85 da		sta $da		                sta $DA
4571	.d77f		10 0f		bpl $d790	                bpl LD792
4572	.d781		bd 02 03	lda $0302,x	                lda $0302,x
4573	.d784		ed 06 03	sbc $0306	                sbc $0306
4574	.d787		a8		tay		                tay
4575	.d788		bd 03 03	lda $0303,x	                lda $0303,x
4576	.d78b		ed 07 03	sbc $0307	                sbc $0307
4577	.d78e		80 0d		bra $d79d	                bra LD79F

4579	.d790						LD792:
4580	.d790		ad 02 03	lda $0302	                lda $0302
4581	.d793		fd 02 03	sbc $0302,x	                sbc $0302,x
4582	.d796		a8		tay		                tay
4583	.d797		ad 03 03	lda $0303	                lda $0303
4584	.d79a		fd 03 03	sbc $0303,x	                sbc $0303,x
4585	.d79d						LD79F:
4586	.d79d		20 a2 d7	jsr $d7a2	                jsr LD7A4
4587	.d7a0		80 87		bra $d729	                bra LD72B

4589	.d7a2						LD7A4:
4590	.d7a2		84 de		sty $de		                sty $DE
4591	.d7a4		85 df		sta $df		                sta $DF
4592	.d7a6		bd 02 03	lda $0302,x	                lda $0302,x
4593	.d7a9		bc 03 03	ldy $0303,x	                ldy $0303,x
4594	.d7ac		06 da		asl $da		                asl $DA
4595	.d7ae		b0 0a		bcs $d7ba	                bcs LD7BC
4596	.d7b0		65 de		adc $de		                adc $DE
4597	.d7b2		9d 02 03	sta $0302,x	                sta $0302,x
4598	.d7b5		98		tya		                tya
4599	.d7b6		65 df		adc $df		                adc $DF
4600	.d7b8		80 08		bra $d7c2	                bra LD7C4

4602	.d7ba						LD7BC:
4603	.d7ba		e5 de		sbc $de		                sbc $DE
4604	.d7bc		9d 02 03	sta $0302,x	                sta $0302,x
4605	.d7bf		98		tya		                tya
4606	.d7c0		e5 df		sbc $df		                sbc $DF
4607	.d7c2						LD7C4:
4608	.d7c2		9d 03 03	sta $0303,x	                sta $0303,x
4609	.d7c5		a9 00		lda #$00	                lda #$00
4610	.d7c7		3c 09 03	bit $0309,x	                bit $0309,x
4611	.d7ca		10 01		bpl $d7cd	                bpl LD7CF
4612	.d7cc		3a		dec a		                dec a
4613	.d7cd						LD7CF:
4614	.d7cd		85 dc		sta $dc		                sta $DC
4615	.d7cf		4a		lsr a		                lsr a
4616	.d7d0		85 dd		sta $dd		                sta $DD
4617	.d7d2		a0 10		ldy #$10	                ldy #$10
4618	.d7d4						LD7D6:
4619	.d7d4		a5 dd		lda $dd		                lda $DD
4620	.d7d6		0a		asl a		                asl a
4621	.d7d7		3e 08 03	rol $0308,x	                rol $0308,x
4622	.d7da		3e 09 03	rol $0309,x	                rol $0309,x
4623	.d7dd		26 dc		rol $dc		                rol $DC
4624	.d7df		26 dd		rol $dd		                rol $DD
4625	.d7e1		06 de		asl $de		                asl $DE
4626	.d7e3		26 df		rol $df		                rol $DF
4627	.d7e5		90 19		bcc $d800	                bcc LD802
4628	.d7e7		18		clc		                clc
4629	.d7e8		a5 dc		lda $dc		                lda $DC
4630	.d7ea		7d 04 03	adc $0304,x	                adc $0304,x
4631	.d7ed		85 dc		sta $dc		                sta $DC
4632	.d7ef		a5 dd		lda $dd		                lda $DD
4633	.d7f1		7d 05 03	adc $0305,x	                adc $0305,x
4634	.d7f4		85 dd		sta $dd		                sta $DD
4635	.d7f6		90 08		bcc $d800	                bcc LD802
4636	.d7f8		fe 08 03	inc $0308,x	                inc $0308,x
4637	.d7fb		d0 03		bne $d800	                bne LD802
4638	.d7fd		fe 09 03	inc $0309,x	                inc $0309,x
4639	.d800						LD802:
4640	.d800		88		dey		                dey
4641	.d801		d0 d1		bne $d7d4	                bne LD7D6
4642	.d803		3c 09 03	bit $0309,x	                bit $0309,x
4643	.d806		50 0b		bvc $d813	                bvc LD815
4644	.d808		a5 dc		lda $dc		                lda $DC
4645	.d80a		9d 08 03	sta $0308,x	                sta $0308,x
4646	.d80d		a5 dd		lda $dd		                lda $DD
4647	.d80f		9d 09 03	sta $0309,x	                sta $0309,x
4648	.d812		60		rts		                rts

4650	.d813						LD815:
4651	.d813		a0 10		ldy #$10	                ldy #$10
4652	.d815						LD817:
4653	.d815		26 dc		rol $dc		                rol $DC
4654	.d817		26 dd		rol $dd		                rol $DD
4655	.d819		3e 08 03	rol $0308,x	                rol $0308,x
4656	.d81c		3e 09 03	rol $0309,x	                rol $0309,x
4657	.d81f		38		sec		                sec
4658	.d820		bd 08 03	lda $0308,x	                lda $0308,x
4659	.d823		fd 06 03	sbc $0306,x	                sbc $0306,x
4660	.d826		85 de		sta $de		                sta $DE
4661	.d828		bd 09 03	lda $0309,x	                lda $0309,x
4662	.d82b		fd 07 03	sbc $0307,x	                sbc $0307,x
4663	.d82e		90 08		bcc $d838	                bcc LD83A
4664	.d830		9d 09 03	sta $0309,x	                sta $0309,x
4665	.d833		a5 de		lda $de		                lda $DE
4666	.d835		9d 08 03	sta $0308,x	                sta $0308,x
4667	.d838						LD83A:
4668	.d838		88		dey		                dey
4669	.d839		d0 da		bne $d815	                bne LD817
4670	.d83b		26 dc		rol $dc		                rol $DC
4671	.d83d		26 dd		rol $dd		                rol $DD
4672	.d83f		38		sec		                sec
4673	.d840		bd 08 03	lda $0308,x	                lda $0308,x
4674	.d843		fd 06 03	sbc $0306,x	                sbc $0306,x
4675	.d846		9d 08 03	sta $0308,x	                sta $0308,x
4676	.d849		bd 09 03	lda $0309,x	                lda $0309,x
4677	.d84c		fd 07 03	sbc $0307,x	                sbc $0307,x
4678	.d84f		9d 09 03	sta $0309,x	                sta $0309,x
4679	.d852		bd 00 03	lda $0300,x	                lda $0300,x
4680	.d855		bc 01 03	ldy $0301,x	                ldy $0301,x
4681	.d858		06 da		asl $da		                asl $DA
4682	.d85a		b0 0b		bcs $d867	                bcs LD869
4683	.d85c		38		sec		                sec
4684	.d85d		65 dc		adc $dc		                adc $DC
4685	.d85f		9d 00 03	sta $0300,x	                sta $0300,x
4686	.d862		98		tya		                tya
4687	.d863		65 dd		adc $dd		                adc $DD
4688	.d865		80 09		bra $d870	                bra LD872

4690	.d867						LD869:
4691	.d867		18		clc		                clc
4692	.d868		e5 dc		sbc $dc		                sbc $DC
4693	.d86a		9d 00 03	sta $0300,x	                sta $0300,x
4694	.d86d		98		tya		                tya
4695	.d86e		e5 dd		sbc $dd		                sbc $DD
4696	.d870						LD872:
4697	.d870		9d 01 03	sta $0301,x	                sta $0301,x
4698	.d873						LD875:
4699	.d873		60		rts		                rts

4701	.d874						LD876:
4702	.d874		0e 32 03	asl $0332	                asl $0332
4703	.d877		a0 2c		ldy #$2c	                ldy #$2C
4704	.d879		20 14 c9	jsr $c914	                jsr copyLastFourVDUQueueBytes
4705	.d87c		06 db		asl $db		                asl $DB
4706	.d87e		90 0d		bcc $d88d	                bcc LD88F
4707	.d880		20 24 da	jsr $da24	                jsr LDA26
4708	.d883		f0 ee		beq $d873	                beq LD875
4709	.d885		a2 00		ldx #$00	                ldx #$00
4710	.d887		ad 32 03	lda $0332	                lda $0332
4711	.d88a		20 0d da	jsr $da0d	                jsr LDA0F
4712	.d88d						LD88F:
4713	.d88d		24 db		bit $db		                bit $DB
4714	.d88f		50 0f		bvc $d8a0	                bvc LD8A2
4715	.d891		20 24 da	jsr $da24	                jsr LDA26
4716	.d894		f0 dd		beq $d873	                beq LD875
4717	.d896		a2 04		ldx #$04	                ldx #$04
4718	.d898		ad 32 03	lda $0332	                lda $0332
4719	.d89b		49 80		eor #$80	                eor #$80
4720	.d89d		20 0d da	jsr $da0d	                jsr LDA0F
4721	.d8a0						LD8A2:
4722	.d8a0		a2 28		ldx #$28	                ldx #$28
4723	.d8a2		a0 2c		ldy #$2c	                ldy #$2C
4724	.d8a4		4c e6 da	jmp $dae6	                jmp LDAE8

4726	.d8a7						LD8A9:
4727	.d8a7		0a		asl a		                asl a
4728	.d8a8		0a		asl a		                asl a
4729	.d8a9		85 db		sta $db		                sta $DB
4730	.d8ab		29 c0		and #$c0	                and #$C0
4731	.d8ad		49 40		eor #$40	                eor #$40
4732	.d8af		d0 06		bne $d8b7	                bne LD8B9
4733	.d8b1		ad 67 03	lda $0367	                lda $0367
4734	.d8b4		8d 68 03	sta $0368	                sta $0368
4735	.d8b7						LD8B9:
4736	.d8b7		20 a4 d1	jsr $d1a4	                jsr LD1A6
4737	.d8ba		85 dc		sta $dc		                sta $DC
4738	.d8bc		f0 04		beq $d8c2	                beq LD8C4
4739	.d8be		a9 80		lda #$80	                lda #$80
4740	.d8c0		14 db		trb $db		                trb $DB
4741	.d8c2						LD8C4:
4742	.d8c2		a2 20		ldx #$20	                ldx #$20
4743	.d8c4		20 a6 d1	jsr $d1a6	                jsr windEntryPoint
4744	.d8c7		85 e0		sta $e0		                sta $E0
4745	.d8c9		f0 0a		beq $d8d5	                beq LD8D7
4746	.d8cb		aa		tax		                tax
4747	.d8cc		a9 20		lda #$20	                lda #$20
4748	.d8ce		14 db		trb $db		                trb $DB
4749	.d8d0		8a		txa		                txa
4750	.d8d1		24 dc		bit $dc		                bit $DC
4751	.d8d3						LD8D5:
4752	.d8d3		d0 9e		bne $d873	                bne LD875
4753	.d8d5						LD8D7:
4754	.d8d5		a0 24		ldy #$24	                ldy #$24
4755	.d8d7		a9 20		lda #$20	                lda #$20
4756	.d8d9		a2 28		ldx #$28	                ldx #$28
4757	.d8db		20 9d 9d	jsr $9d9d	                jsr L9B09
4758	.d8de		24 db		bit $db		                bit $DB
4759	.d8e0		70 08		bvs $d8ea	                bvs LD8EC
4760	.d8e2		ad 2e 03	lda $032e	                lda $032E
4761	.d8e5		0d 2f 03	ora $032f	                ora $032F
4762	.d8e8		f0 8a		beq $d874	                beq LD876
4763	.d8ea						LD8EC:
4764	.d8ea		a5 dc		lda $dc		                lda $DC
4765	.d8ec		89 0c		bit #$0c	                bit #$0C
4766	.d8ee		f0 0e		beq $d8fe	                beq LD900
4767	.d8f0		a2 28		ldx #$28	                ldx #$28
4768	.d8f2		20 79 d7	jsr $d779	                jsr LD77B
4769	.d8f5		a2 28		ldx #$28	                ldx #$28
4770	.d8f7		20 a6 d1	jsr $d1a6	                jsr windEntryPoint
4771	.d8fa		24 e0		bit $e0		                bit $E0
4772	.d8fc		d0 d5		bne $d8d3	                bne LD8D5
4773	.d8fe						LD900:
4774	.d8fe		89 03		bit #$03	                bit #$03
4775	.d900		f0 0a		beq $d90c	                beq LD90E
4776	.d902		a2 28		ldx #$28	                ldx #$28
4777	.d904		20 c6 d6	jsr $d6c6	                jsr LD6C8
4778	.d907		a2 28		ldx #$28	                ldx #$28
4779	.d909		20 a6 d1	jsr $d1a6	                jsr windEntryPoint
4780	.d90c						LD90E:
4781	.d90c		a8		tay		                tay
4782	.d90d		d0 c4		bne $d8d3	                bne LD8D5
4783	.d90f		a0 20		ldy #$20	                ldy #$20
4784	.d911		a2 22		ldx #$22	                ldx #$22
4785	.d913		a5 e0		lda $e0		                lda $E0
4786	.d915		f0 0f		beq $d926	                beq LD928
4787	.d917		a0 04		ldy #$04	                ldy #$04
4788	.d919		a2 06		ldx #$06	                ldx #$06
4789	.d91b		2c 32 03	bit $0332	                bit $0332
4790	.d91e		10 02		bpl $d922	                bpl LD924
4791	.d920		a2 02		ldx #$02	                ldx #$02
4792	.d922						LD924:
4793	.d922		50 02		bvc $d926	                bvc LD928
4794	.d924		a0 00		ldy #$00	                ldy #$00
4795	.d926						LD928:
4796	.d926		18		clc		                clc
4797	.d927		bd 00 03	lda $0300,x	                lda $0300,x
4798	.d92a		ed 2a 03	sbc $032a	                sbc $032A
4799	.d92d		90 03		bcc $d932	                bcc LD934
4800	.d92f		1a		inc a		                inc a
4801	.d930		49 ff		eor #$ff	                eor #$FF
4802	.d932						LD934:
4803	.d932		85 dc		sta $dc		                sta $DC
4804	.d934		18		clc		                clc
4805	.d935		b9 00 03	lda $0300,y	                lda $0300,y
4806	.d938		ed 28 03	sbc $0328	                sbc $0328
4807	.d93b		aa		tax		                tax
4808	.d93c		b9 01 03	lda $0301,y	                lda $0301,y
4809	.d93f		ed 29 03	sbc $0329	                sbc $0329
4810	.d942		30 0c		bmi $d950	                bmi LD952
4811	.d944		e8		inx		                inx
4812	.d945		d0 01		bne $d948	                bne LD94A
4813	.d947		1a		inc a		                inc a
4814	.d948						LD94A:
4815	.d948		49 ff		eor #$ff	                eor #$FF
4816	.d94a		a8		tay		                tay
4817	.d94b		8a		txa		                txa
4818	.d94c		49 ff		eor #$ff	                eor #$FF
4819	.d94e		aa		tax		                tax
4820	.d94f		98		tya		                tya
4821	.d950						LD952:
4822	.d950		85 dd		sta $dd		                sta $DD
4823	.d952		86 e0		stx $e0		                stx $E0
4824	.d954		a2 28		ldx #$28	                ldx #$28
4825	.d956		20 3f df	jsr $df3f	                jsr LDF41
4826	.d959		06 db		asl $db		                asl $DB
4827	.d95b		b0 2a		bcs $d987	                bcs LD989
4828	.d95d						LD95F:
4829	.d95d		24 db		bit $db		                bit $DB
4830	.d95f		50 0b		bvc $d96c	                bvc LD96E
4831	.d961		a5 e0		lda $e0		                lda $E0
4832	.d963		25 dc		and $dc		                and $DC
4833	.d965		25 dd		and $dd		                and $DD
4834	.d967		1a		inc a		                inc a
4835	.d968		f0 34		beq $d99e	                beq LD9A0
4836	.d96a		24 db		bit $db		                bit $DB
4837	.d96c						LD96E:
4838	.d96c		10 09		bpl $d977	                bpl LD979
4839	.d96e		ad 68 03	lda $0368	                lda $0368
4840	.d971		0a		asl a		                asl a
4841	.d972		2e 68 03	rol $0368	                rol $0368
4842	.d975		90 10		bcc $d987	                bcc LD989
4843	.d977						LD979:
4844	.d977		a5 d1		lda $d1		                lda ZMASK
4845	.d979		25 d4		and $d4		                and ZGORA
4846	.d97b		11 d6		ora ($d6),y	                ora (ZMEMG),y
4847	.d97d		85 da		sta $da		                sta $DA
4848	.d97f		a5 d1		lda $d1		                lda ZMASK
4849	.d981		25 d5		and $d5		                and ZGEOR
4850	.d983		45 da		eor $da		                eor $DA
4851	.d985		91 d6		sta ($d6),y	                sta (ZMEMG),y
4852	.d987						LD989:
4853	.d987		ad 31 03	lda $0331	                lda $0331
4854	.d98a		10 4e		bpl $d9da	                bpl LD9DC
4855	.d98c		e6 dc		inc $dc		                inc $DC
4856	.d98e		f0 0e		beq $d99e	                beq LD9A0
4857	.d990		2c 32 03	bit $0332	                bit $0332
4858	.d993		30 0a		bmi $d99f	                bmi LD9A1
4859	.d995		88		dey		                dey
4860	.d996		ca		dex		                dex
4861	.d997		10 24		bpl $d9bd	                bpl LD9BF
4862	.d999		20 4a da	jsr $da4a	                jsr LDA4C
4863	.d99c		80 1f		bra $d9bd	                bra LD9BF

4865	.d99e						LD9A0:
4866	.d99e		60		rts		                rts

4868	.d99f						LD9A1:
4869	.d99f		c8		iny		                iny
4870	.d9a0		e8		inx		                inx
4871	.d9a1		e0 08		cpx #$08	                cpx #$08
4872	.d9a3		d0 18		bne $d9bd	                bne LD9BF
4873	.d9a5		38		sec		                sec
4874	.d9a6		98		tya		                tya
4875	.d9a7		e9 08		sbc #$08	                sbc #$08
4876	.d9a9		18		clc		                clc
4877	.d9aa		6d 52 03	adc $0352	                adc $0352
4878	.d9ad		a8		tay		                tay
4879	.d9ae		a5 d7		lda $d7		                lda ZMEMG+1
4880	.d9b0		6d 53 03	adc $0353	                adc $0353
4881	.d9b3		10 04		bpl $d9b9	                bpl LD9BB
4882	.d9b5		38		sec		                sec
4883	.d9b6		ed 54 03	sbc $0354	                sbc $0354
4884	.d9b9						LD9BB:
4885	.d9b9		85 d7		sta $d7		                sta ZMEMG+1
4886	.d9bb		a2 00		ldx #$00	                ldx #$00
4887	.d9bd						LD9BF:
4888	.d9bd		ad 69 03	lda $0369	                lda $0369
4889	.d9c0		f0 03		beq $d9c5	                beq LD9C7
4890	.d9c2		20 7a da	jsr $da7a	                jsr setupColourMasks
4891	.d9c5						LD9C7:
4892	.d9c5		18		clc		                clc
4893	.d9c6		ad 30 03	lda $0330	                lda $0330
4894	.d9c9		6d 2c 03	adc $032c	                adc $032C
4895	.d9cc		8d 30 03	sta $0330	                sta $0330
4896	.d9cf		ad 31 03	lda $0331	                lda $0331
4897	.d9d2		6d 2d 03	adc $032d	                adc $032D
4898	.d9d5		8d 31 03	sta $0331	                sta $0331
4899	.d9d8		30 83		bmi $d95d	                bmi LD95F
4900	.d9da						LD9DC:
4901	.d9da		e6 e0		inc $e0		                inc $E0
4902	.d9dc		d0 04		bne $d9e2	                bne LD9E4
4903	.d9de		e6 dd		inc $dd		                inc $DD
4904	.d9e0		f0 bc		beq $d99e	                beq LD9A0
4905	.d9e2						LD9E4:
4906	.d9e2		2c 32 03	bit $0332	                bit $0332
4907	.d9e5		70 09		bvs $d9f0	                bvs LD9F2
4908	.d9e7		46 d1		lsr $d1		                lsr ZMASK
4909	.d9e9		90 0c		bcc $d9f7	                bcc LD9F9
4910	.d9eb		20 65 da	jsr $da65	                jsr nextColumnAndResetMask
4911	.d9ee		80 07		bra $d9f7	                bra LD9F9

4913	.d9f0						LD9F2:
4914	.d9f0		06 d1		asl $d1		                asl ZMASK
4915	.d9f2		90 03		bcc $d9f7	                bcc LD9F9
4916	.d9f4		20 32 da	jsr $da32	                jsr previousColumnAndResetMask
4917	.d9f7						LD9F9:
4918	.d9f7		38		sec		                sec
4919	.d9f8		ad 30 03	lda $0330	                lda $0330
4920	.d9fb		ed 2e 03	sbc $032e	                sbc $032E
4921	.d9fe		8d 30 03	sta $0330	                sta $0330
4922	.da01		ad 31 03	lda $0331	                lda $0331
4923	.da04		ed 2f 03	sbc $032f	                sbc $032F
4924	.da07		8d 31 03	sta $0331	                sta $0331
4925	.da0a		4c 5d d9	jmp $d95d	                jmp LD95F

4927	.da0d						LDA0F:
4928	.da0d		30 09		bmi $da18	                bmi LDA1A
4929	.da0f		fe 28 03	inc $0328,x	                inc $0328,x
4930	.da12		d0 0f		bne $da23	                bne LDA25
4931	.da14		fe 29 03	inc $0329,x	                inc $0329,x
4932	.da17		60		rts		                rts

4934	.da18						LDA1A:
4935	.da18		bd 28 03	lda $0328,x	                lda $0328,x
4936	.da1b		d0 03		bne $da20	                bne LDA22
4937	.da1d		de 29 03	dec $0329,x	                dec $0329,x
4938	.da20						LDA22:
4939	.da20		de 28 03	dec $0328,x	                dec $0328,x
4940	.da23						LDA25:
4941	.da23		60		rts		                rts

4943	.da24						LDA26:
4944	.da24		a0 04		ldy #$04	                ldy #$04
4945	.da26						LDA28:
4946	.da26		b9 27 03	lda $0327,y	                lda $0327,y
4947	.da29		d9 2b 03	cmp $032b,y	                cmp $032B,y
4948	.da2c		d0 03		bne $da31	                bne LDA33
4949	.da2e		88		dey		                dey
4950	.da2f		d0 f5		bne $da26	                bne LDA28
4951	.da31						LDA33:
4952	.da31		60		rts		                rts

4954							;-------------------------------------------------------------------------

4956	.da32						previousColumnAndResetMask:
4957	.da32		ad 63 03	lda $0363	                lda vduv.colourMaskRight
4958	.da35		85 d1		sta $d1		                sta ZMASK
4959	.da37		98		tya		                tya
4960	.da38		e9 08		sbc #$08	                sbc #$08
4961	.da3a		a8		tay		                tay
4962	.da3b		b0 0c		bcs $da49	                bcs rtsDA4B
4963	.da3d		a5 d7		lda $d7		                lda ZMEMG+1
4964	.da3f		3a		dec a		                dec a
4965	.da40		cd 4e 03	cmp $034e	                cmp vduv.startScreenAddressHighByte
4966	.da43		b0 02		bcs $da47	                bcs +
4967	.da45		a9 7f		lda #$7f	                lda #$7F
4968	.da47						+
4969	.da47		85 d7		sta $d7		                sta ZMEMG+1
4970	.da49						rtsDA4B:
4971	.da49		60		rts		                rts

4973							;-------------------------------------------------------------------------

4975	.da4a						LDA4C:
4976	.da4a		18		clc		                clc
4977	.da4b		98		tya		                tya
4978	.da4c		69 08		adc #$08	                adc #$08
4979	.da4e		38		sec		                sec
4980	.da4f		ed 52 03	sbc $0352	                sbc $0352
4981	.da52		a8		tay		                tay
4982	.da53		a5 d7		lda $d7		                lda ZMEMG+1
4983	.da55		ed 53 03	sbc $0353	                sbc $0353
4984	.da58		cd 4e 03	cmp $034e	                cmp $034E
4985	.da5b		b0 03		bcs $da60	                bcs LDA62
4986	.da5d		6d 54 03	adc $0354	                adc $0354
4987	.da60						LDA62:
4988	.da60		85 d7		sta $d7		                sta ZMEMG+1
4989	.da62		a2 07		ldx #$07	                ldx #$07
4990	.da64		60		rts		                rts

4992							;-------------------------------------------------------------------------
4993							;
4994	.da65						nextColumnAndResetMask:
4995	.da65		ad 62 03	lda $0362	                lda vduv.colourMaskLeft
4996	.da68		85 d1		sta $d1		                sta ZMASK

4998							;-------------------------------------------------------------------------
4999							;
5000							; Add 8 to (ZMEMG),Y, taking into account screen wrap.
5001							;
5002							; entry:
5003							;
5004							; C=1
5005							;
5006							; (ZMEMG),Y = screen address
5007							;
5008							; exit:
5009							;
5010							; (ZMEMG),Y = new screen address
5011							;
5012	.da6a						nextColumn:
5013	.da6a		98		tya		                tya
5014	.da6b		69 07		adc #$07	                adc #$07
5015	.da6d		a8		tay		                tay
5016	.da6e		90 09		bcc $da79	                bcc +
5017	.da70		e6 d7		inc $d7		                inc ZMEMG+1
5018	.da72		10 05		bpl $da79	                bpl +
5019	.da74		ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
5020	.da77		85 d7		sta $d7		                sta ZMEMG+1
5021	.da79						+
5022	.da79		60		rts		                rts

5024							;-------------------------------------------------------------------------
5025							;
5026							; Set up colour masks, taking into account ECF pattern.
5027							;
5028							; entry:
5029							;
5030							; X = scanline in row, 0-7
5031							;
5032	.da7a						setupColourMasks:
5033	.da7a		da		phx		                phx                          ;save scanline
5034	.da7b		8a		txa		                txa                          ;A=scanline
5035	.da7c		0d 59 03	ora $0359	                ora vduv.graphicsPlotState   ;0-7 if fg, 8-15 if bg
5036	.da7f		aa		tax		                tax
5037	.da80		bd 20 88	lda $8820,x	                lda andy.fgECFPattern,x      ;get appropriate ECF byte
5038	.da83		ae 5a 03	ldx $035a	                ldx vduv.graphicsPlotMode
5039	.da86		48		pha		                pha
5040	.da87		1d 42 e1	ora $e142,x	                ora zgoraORTable,x
5041	.da8a		5d 43 e1	eor $e143,x	                eor zgoraEORTable,x
5042	.da8d		85 d4		sta $d4		                sta ZGORA
5043	.da8f		68		pla		                pla
5044	.da90		1d 41 e1	ora $e141,x	                ora zgeorORTable,x
5045	.da93		5d 46 e1	eor $e146,x	                eor zgeorEORTable,x
5046	.da96		85 d5		sta $d5		                sta ZGEOR
5047	.da98		fa		plx		                plx
5048	.da99		60		rts		                rts

5050							;-------------------------------------------------------------------------

5052	.da9a						LDA9C:
5053	.da9a		b9 01 03	lda $0301,y	                lda $0301,y
5054	.da9d		48		pha		                pha
5055	.da9e		b9 00 03	lda $0300,y	                lda $0300,y
5056	.daa1		48		pha		                pha
5057	.daa2		2d 61 03	and $0361	                and $0361
5058	.daa5		18		clc		                clc
5059	.daa6		6d 61 03	adc $0361	                adc $0361
5060	.daa9		a8		tay		                tay
5061	.daaa		b9 2c e1	lda $e12c,y	                lda pixelMasks-1,y
5062	.daad		59 1e e1	eor $e11e,y	                eor LE120,y
5063	.dab0		85 dc		sta $dc		                sta $DC
5064	.dab2		bd 00 03	lda $0300,x	                lda $0300,x
5065	.dab5		2d 61 03	and $0361	                and $0361
5066	.dab8		6d 61 03	adc $0361	                adc $0361
5067	.dabb		a8		tay		                tay
5068	.dabc		b9 1e e1	lda $e11e,y	                lda LE120,y
5069	.dabf		85 d1		sta $d1		                sta ZMASK
5070	.dac1		38		sec		                sec
5071	.dac2		68		pla		                pla
5072	.dac3		0d 61 03	ora $0361	                ora $0361
5073	.dac6		fd 00 03	sbc $0300,x	                sbc $0300,x
5074	.dac9		a8		tay		                tay
5075	.daca		68		pla		                pla
5076	.dacb		fd 01 03	sbc $0301,x	                sbc $0301,x
5077	.dace		85 dd		sta $dd		                sta $DD
5078	.dad0		98		tya		                tya
5079	.dad1		ac 61 03	ldy $0361	                ldy $0361
5080	.dad4		c0 03		cpy #$03	                cpy #$03
5081	.dad6		f0 05		beq $dadd	                beq LDADF
5082	.dad8		90 06		bcc $dae0	                bcc LDAE2
5083	.dada		46 dd		lsr $dd		                lsr $DD
5084	.dadc		6a		ror a		                ror a
5085	.dadd						LDADF:
5086	.dadd		46 dd		lsr $dd		                lsr $DD
5087	.dadf		6a		ror a		                ror a
5088	.dae0						LDAE2:
5089	.dae0		4a		lsr a		                lsr a
5090	.dae1						LDAE3:
5091	.dae1		60		rts		                rts

5093	.dae2						LDAE4:                                       ; fillRow?
5094	.dae2		a2 42		ldx #$42	                ldx #$42
5095	.dae4		a0 46		ldy #$46	                ldy #$46
5096	.dae6						LDAE8:                                       ; fillRowInternal?
5097	.dae6		20 ca d5	jsr $d5ca	                jsr sortVDUVariableWords
5098	.dae9		86 de		stx $de		                stx $DE
5099	.daeb		84 df		sty $df		                sty $DF
5100	.daed		a6 df		ldx $df		                ldx $DF
5101	.daef		a0 00		ldy #$00	                ldy #$00
5102	.daf1		20 b5 d1	jsr $d1b5	                jsr getOutcodeForAxis
5103	.daf4		f0 07		beq $dafd	                beq LDAFF
5104	.daf6		4a		lsr a		                lsr a
5105	.daf7		f0 e8		beq $dae1	                beq LDAE3
5106	.daf9		a2 04		ldx #$04	                ldx #$04
5107	.dafb		86 df		stx $df		                stx $DF
5108	.dafd						LDAFF:
5109	.dafd		a6 de		ldx $de		                ldx $DE
5110	.daff		20 a6 d1	jsr $d1a6	                jsr windEntryPoint
5111	.db02		4a		lsr a		                lsr a
5112	.db03		d0 dc		bne $dae1	                bne LDAE3
5113	.db05		bd 02 03	lda $0302,x	                lda $0302,x
5114	.db08		90 04		bcc $db0e	                bcc LDB10
5115	.db0a		a2 00		ldx #$00	                ldx #$00
5116	.db0c		86 de		stx $de		                stx $DE
5117	.db0e						LDB10:
5118	.db0e		20 c9 de	jsr $dec9	                jsr LDECB
5119	.db11		a6 de		ldx $de		                ldx $DE
5120	.db13		a4 df		ldy $df		                ldy $DF
5121	.db15		20 9a da	jsr $da9a	                jsr LDA9C
5122	.db18		aa		tax		                tax
5123	.db19		ac 1a 03	ldy $031a	                ldy $031A
5124	.db1c		8a		txa		                txa
5125	.db1d		f0 23		beq $db42	                beq LDB44
5126	.db1f		20 4f db	jsr $db4f	                jsr plbyteEntryPoint
5127	.db22		80 08		bra $db2c	                bra LDB2E

5129	.db24						LDB26:
5130	.db24		b1 d6		lda ($d6),y	                lda (ZMEMG),y
5131	.db26		05 d4		ora $d4		                ora ZGORA
5132	.db28		45 d5		eor $d5		                eor ZGEOR
5133	.db2a		91 d6		sta ($d6),y	                sta (ZMEMG),y
5134	.db2c						LDB2E:
5135	.db2c		98		tya		                tya
5136	.db2d		18		clc		                clc
5137	.db2e		69 08		adc #$08	                adc #$08
5138	.db30		a8		tay		                tay
5139	.db31		90 09		bcc $db3c	                bcc LDB3E
5140	.db33		e6 d7		inc $d7		                inc ZMEMG+1
5141	.db35		10 05		bpl $db3c	                bpl LDB3E
5142	.db37		ad 4e 03	lda $034e	                lda $034E
5143	.db3a		85 d7		sta $d7		                sta ZMEMG+1
5144	.db3c						LDB3E:
5145	.db3c		ca		dex		                dex
5146	.db3d		d0 e5		bne $db24	                bne LDB26
5147	.db3f		ca		dex		                dex
5148	.db40		86 d1		stx $d1		                stx ZMASK
5149	.db42						LDB44:
5150	.db42		a5 dc		lda $dc		                lda $DC
5151	.db44		14 d1		trb $d1		                trb ZMASK
5152	.db46		80 07		bra $db4f	                bra plbyteEntryPoint

5154							;-------------------------------------------------------------------------
5155							;
5156							; mem mask ora eor | result
5157							; --- ---- --- --- | ------
5158							;  0    0   0   0  |   0
5159							;  0    0   0   1  |   0
5160							;  0    0   1   0  |   0
5161							;  0    0   1   1  |   0
5162							;  0    1   0   0  |   0
5163							;  0    1   0   1  |   1
5164							;  0    1   1   0  |   1
5165							;  0    1   1   1  |   0
5166							;  1    0   0   0  |   1
5167							;  1    0   0   1  |   1
5168							;  1    0   1   0  |   1
5169							;  1    0   1   1  |   1
5170							;  1    1   0   0  |   1
5171							;  1    1   0   1  |   0
5172							;  1    1   1   0  |   1
5173							;  1    1   1   1  |   0
5174							;
5175	.db48						plotPoint:
5176	.db48		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
5177	.db4a						plotPointInternal:
5178	.db4a		20 c1 de	jsr $dec1	                jsr windGADDR
5179	.db4d		d0 10		bne $db5f	                bne rtsDB61                  ;taken if point outside window
5180	.db4f						plbyteEntryPoint:
5181	.db4f		a5 d1		lda $d1		                lda ZMASK
5182	.db51		25 d4		and $d4		                and ZGORA
5183	.db53		11 d6		ora ($d6),y	                ora (ZMEMG),y
5184	.db55		85 da		sta $da		                sta ZTEMP+0
5185	.db57		a5 d5		lda $d5		                lda ZGEOR
5186	.db59		25 d1		and $d1		                and ZMASK
5187	.db5b		45 da		eor $da		                eor ZTEMP+0
5188	.db5d						oswrscCode:
5189	.db5d		91 d6		sta ($d6),y	                sta (ZMEMG),y
5190	.db5f						rtsDB61:
5191	.db5f		60		rts		                rts

5193							;-------------------------------------------------------------------------

5195	.db60						LDB62:
5196	.db60		a2 2a		ldx #$2a	                ldx #VDUVariables.workspace._2A
5197	.db62		a0 32		ldy #$32	                ldy #VDUVariables.workspace._32
5198	.db64		20 0a c9	jsr $c90a	                jsr copyTwoBytesWithinVDUVariables
5199	.db67		a2 36		ldx #$36	                ldx #VDUVariables.workspace._36
5200	.db69		a0 3e		ldy #$3e	                ldy #VDUVariables.workspace._3E
5201	.db6b		20 0a c9	jsr $c90a	                jsr copyTwoBytesWithinVDUVariables
5202	.db6e		a2 2a		ldx #$2a	                ldx #$2A
5203	.db70		20 b3 d1	jsr $d1b3	                jsr getOutcodeForYAxis
5204	.db73		48		pha		                pha
5205	.db74		a2 36		ldx #$36	                ldx #$36
5206	.db76		20 b3 d1	jsr $d1b3	                jsr getOutcodeForYAxis
5207	.db79		f0 0f		beq $db8a	                beq LDB8C
5208	.db7b		68		pla		                pla
5209	.db7c		d0 05		bne $db83	                bne LDB85
5210	.db7e		ad 45 03	lda $0345	                lda $0345
5211	.db81		f0 01		beq $db84	                beq LDB86
5212	.db83						LDB85:
5213	.db83		60		rts		                rts

5215	.db84						LDB86:
5216	.db84		a2 28		ldx #$28	                ldx #$28
5217	.db86		a0 2c		ldy #$2c	                ldy #$2C
5218	.db88		80 07		bra $db91	                bra LDB93

5220	.db8a						LDB8C:
5221	.db8a		68		pla		                pla
5222	.db8b		f0 07		beq $db94	                beq LDB96
5223	.db8d		a2 34		ldx #$34	                ldx #$34
5224	.db8f		a0 38		ldy #$38	                ldy #$38
5225	.db91						LDB93:
5226	.db91		4c e6 da	jmp $dae6	                jmp LDAE8

5228	.db94						LDB96:
5229	.db94		a2 30		ldx #$30	                ldx #$30
5230	.db96		20 c6 de	jsr $dec6	                jsr gaddrEntryPoint
5231	.db99		2c 47 03	bit $0347	                bit $0347
5232	.db9c		30 09		bmi $dba7	                bmi LDBA9
5233	.db9e		98		tya		                tya
5234	.db9f		38		sec		                sec
5235	.dba0		e9 08		sbc #$08	                sbc #$08
5236	.dba2		a8		tay		                tay
5237	.dba3		b0 02		bcs $dba7	                bcs LDBA9
5238	.dba5		c6 d7		dec $d7		                dec ZMEMG+1
5239	.dba7						LDBA9:
5240	.dba7		ad 44 03	lda $0344	                lda $0344
5241	.dbaa		85 dd		sta $dd		                sta $DD
5242	.dbac						LDBAE:
5243	.dbac		b1 d6		lda ($d6),y	                lda (ZMEMG),y
5244	.dbae		ae 42 03	ldx $0342	                ldx $0342
5245	.dbb1		f0 04		beq $dbb7	                beq LDBB9
5246	.dbb3						LDBB5:
5247	.dbb3		0a		asl a		                asl a
5248	.dbb4		ca		dex		                dex
5249	.dbb5		d0 fc		bne $dbb3	                bne LDBB5
5250	.dbb7						LDBB9:
5251	.dbb7		85 da		sta $da		                sta $DA
5252	.dbb9		38		sec		                sec
5253	.dbba		20 6a da	jsr $da6a	                jsr nextColumn
5254	.dbbd		b1 d6		lda ($d6),y	                lda (ZMEMG),y
5255	.dbbf		ae 43 03	ldx $0343	                ldx $0343
5256	.dbc2		f0 04		beq $dbc8	                beq LDBCA
5257	.dbc4						LDBC6:
5258	.dbc4		4a		lsr a		                lsr a
5259	.dbc5		ca		dex		                dex
5260	.dbc6		d0 fc		bne $dbc4	                bne LDBC6
5261	.dbc8						LDBCA:
5262	.dbc8		45 da		eor $da		                eor $DA
5263	.dbca		25 e1		and $e1		                and $E1
5264	.dbcc		45 da		eor $da		                eor $DA
5265	.dbce		a6 dd		ldx $dd		                ldx $DD
5266	.dbd0		9d 30 88	sta $8830,x	                sta L8830,x
5267	.dbd3		c6 dd		dec $dd		                dec $DD
5268	.dbd5		10 d5		bpl $dbac	                bpl LDBAE
5269	.dbd7		a2 34		ldx #$34	                ldx #$34
5270	.dbd9		a0 38		ldy #$38	                ldy #$38
5271	.dbdb		20 e6 da	jsr $dae6	                jsr LDAE8
5272	.dbde		ad 45 03	lda $0345	                lda $0345
5273	.dbe1		d0 03		bne $dbe6	                bne LDBE8
5274	.dbe3		20 84 db	jsr $db84	                jsr LDB86
5275	.dbe6						LDBE8:
5276	.dbe6		a2 3c		ldx #$3c	                ldx #$3C
5277	.dbe8		20 c6 de	jsr $dec6	                jsr gaddrEntryPoint
5278	.dbeb		ad 46 03	lda $0346	                lda $0346
5279	.dbee		85 da		sta $da		                sta $DA
5280	.dbf0		ae 44 03	ldx $0344	                ldx $0344
5281	.dbf3		f0 15		beq $dc0a	                beq LDC0C
5282	.dbf5		20 0e dc	jsr $dc0e	                jsr LDC10
5283	.dbf8		a9 ff		lda #$ff	                lda #$FF
5284	.dbfa		85 da		sta $da		                sta $DA
5285	.dbfc		80 05		bra $dc03	                bra LDC05

5287	.dbfe						LDC00_code:
5288	.dbfe		bd 30 88	lda $8830,x	                lda L8830,x
5289	.dc01		91 d6		sta ($d6),y	                sta (ZMEMG),y
5290	.dc03						LDC05:
5291	.dc03		38		sec		                sec
5292	.dc04		20 6a da	jsr $da6a	                jsr nextColumn
5293	.dc07		ca		dex		                dex
5294	.dc08		d0 f4		bne $dbfe	                bne LDC00_code
5295	.dc0a						LDC0C:
5296	.dc0a		a5 e0		lda $e0		                lda $E0
5297	.dc0c		14 da		trb $da		                trb $DA
5298	.dc0e						LDC10:
5299	.dc0e		bd 30 88	lda $8830,x	                lda L8830,x
5300	.dc11		51 d6		eor ($d6),y	                eor (ZMEMG),y
5301	.dc13		25 da		and $da		                and $DA
5302	.dc15		51 d6		eor ($d6),y	                eor (ZMEMG),y
5303	.dc17		91 d6		sta ($d6),y	                sta (ZMEMG),y
5304	.dc19		60		rts		                rts

5306	.dc1a						LDC1C:
5307	.dc1a		ad 37 03	lda $0337	                lda $0337
5308	.dc1d		1a		inc a		                inc a
5309	.dc1e		cd 36 03	cmp $0336	                cmp $0336
5310	.dc21		f0 22		beq $dc45	                beq LDC47
5311	.dc23		8d 37 03	sta $0337	                sta $0337
5312	.dc26		aa		tax		                tax
5313	.dc27		ad 2e 03	lda $032e	                lda $032E
5314	.dc2a		9d 00 84	sta $8400,x	                sta L8400,x
5315	.dc2d		ad 32 03	lda $0332	                lda $0332
5316	.dc30		9d 00 85	sta $8500,x	                sta L8500,x
5317	.dc33		ad 2f 03	lda $032f	                lda $032F
5318	.dc36		0a		asl a		                asl a
5319	.dc37		0a		asl a		                asl a
5320	.dc38		0d 33 03	ora $0333	                ora $0333
5321	.dc3b		9d 00 86	sta $8600,x	                sta L8600,x
5322	.dc3e		ad 30 03	lda $0330	                lda $0330
5323	.dc41		9d 00 87	sta $8700,x	                sta L8700,x
5324	.dc44						LDC46:
5325	.dc44		18		clc		                clc
5326	.dc45						LDC47:
5327	.dc45		60		rts		                rts

5329	.dc46						LDC48:
5330	.dc46		8d 2a 03	sta $032a	                sta $032A
5331	.dc49		a2 28		ldx #$28	                ldx #$28
5332	.dc4b		20 ae dc	jsr $dcae	                jsr LDCB0
5333	.dc4e		d0 0a		bne $dc5a	                bne LDC5C
5334	.dc50						LDC52:
5335	.dc50		20 1a dc	jsr $dc1a	                jsr LDC1C
5336	.dc53		b0 f0		bcs $dc45	                bcs LDC47
5337	.dc55		20 eb 9f	jsr $9feb	                jsr L9D57
5338	.dc58		b0 ea		bcs $dc44	                bcs LDC46
5339	.dc5a						LDC5C:
5340	.dc5a		20 bf dc	jsr $dcbf	                jsr LDCC1
5341	.dc5d		20 eb 9f	jsr $9feb	                jsr L9D57
5342	.dc60		b0 e2		bcs $dc44	                bcs LDC46
5343	.dc62		20 d5 dc	jsr $dcd5	                jsr LDCD7
5344	.dc65		20 b6 dc	jsr $dcb6	                jsr LDCB8
5345	.dc68		80 e6		bra $dc50	                bra LDC52

5347							;-------------------------------------------------------------------------
5348							;
5349							; 72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
5350							; 88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
5351							; 104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
5352							; 120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
5353							;
5354	.dc6a						plotHorizontalLineFill:
5355	.dc6a		20 9d dd	jsr $dd9d	                jsr copyECFPatternForLineFill
5356	.dc6d		20 ae dc	jsr $dcae	                jsr LDCB0
5357	.dc70		18		clc		                clc
5358	.dc71		80 0e		bra $dc81	                bra LDC83

5360	.dc73						plotHorizontalLineFillRight:
5361	.dc73		20 9d dd	jsr $dd9d	                jsr copyECFPatternForLineFill
5362	.dc76		20 c7 dc	jsr $dcc7	                jsr LDCC9
5363	.dc79		20 d0 dc	jsr $dcd0	                jsr LDCD2
5364	.dc7c		d0 03		bne $dc81	                bne LDC83
5365	.dc7e		20 b6 dc	jsr $dcb6	                jsr LDCB8
5366	.dc81						LDC83:
5367	.dc81		08		php		                php
5368	.dc82		a2 2e		ldx #$2e	                ldx #VDUVariables.hlfw.pixelsX
5369	.dc84		a0 14		ldy #$14	                ldy #VDUVariables.oldGraphicsCursorPixelsX
5370	.dc86		20 1c c9	jsr $c91c	                jsr copyFourBytesWithinVDUVariables
5371	.dc89		28		plp		                plp
5372	.dc8a		08		php		                php
5373	.dc8b		f0 02		beq $dc8f	                beq LDC91
5374	.dc8d		a2 2e		ldx #$2e	                ldx #VDUVariables.hlfw.pixelsX
5375	.dc8f						LDC91:
5376	.dc8f		a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixelsX
5377	.dc91		20 0a c9	jsr $c90a	                jsr copyTwoBytesWithinVDUVariables
5378	.dc94		a2 30		ldx #$30	                ldx #VDUVariables.hlfw.pixelsY
5379	.dc96		20 0a c9	jsr $c90a	                jsr copyTwoBytesWithinVDUVariables
5380	.dc99		28		plp		                plp
5381	.dc9a		f0 05		beq $dca1	                beq LDCA3
5382	.dc9c		b0 04		bcs $dca2	                bcs LDCA4
5383	.dc9e		ee 16 03	inc $0316	                inc $0316
5384	.dca1						LDCA3:
5385	.dca1		60		rts		                rts

5387	.dca2						LDCA4:
5388	.dca2		ad 24 03	lda $0324	                lda $0324
5389	.dca5		d0 03		bne $dcaa	                bne LDCAC
5390	.dca7		ce 25 03	dec $0325	                dec $0325
5391	.dcaa						LDCAC:
5392	.dcaa		ce 24 03	dec $0324	                dec $0324
5393	.dcad		60		rts		                rts

5395							;-------------------------------------------------------------------------

5397	.dcae						LDCB0:
5398	.dcae		20 d0 dc	jsr $dcd0	                jsr LDCD2
5399	.dcb1		d0 55		bne $dd08	                bne rtsDD0A
5400	.dcb3		20 09 dd	jsr $dd09	                jsr LDD0B
5401	.dcb6						LDCB8:
5402	.dcb6		a2 2e		ldx #$2e	                ldx #$2E
5403	.dcb8		a0 32		ldy #$32	                ldy #$32
5404	.dcba		20 e6 da	jsr $dae6	                jsr LDAE8
5405	.dcbd		80 46		bra $dd05	                bra LDD07

5407	.dcbf						LDCC1:
5408	.dcbf		20 c7 dc	jsr $dcc7	                jsr LDCC9
5409	.dcc2		a2 2c		ldx #$2c	                ldx #$2C
5410	.dcc4		20 d7 dc	jsr $dcd7	                jsr LDCD9
5411	.dcc7						LDCC9:
5412	.dcc7		08		php		                php
5413	.dcc8		a5 e1		lda $e1		                lda $E1
5414	.dcca		49 08		eor #$08	                eor #$08
5415	.dccc		85 e1		sta $e1		                sta $E1
5416	.dcce		28		plp		                plp
5417	.dccf		60		rts		                rts

5419							;-------------------------------------------------------------------------

5421	.dcd0						LDCD2:
5422	.dcd0		a0 2e		ldy #$2e	                ldy #VDUVariables.hlfw.pixelsX
5423	.dcd2		20 1c c9	jsr $c91c	                jsr copyFourBytesWithinVDUVariables
5424	.dcd5						LDCD7:
5425	.dcd5		a2 04		ldx #$04	                ldx #VDUVariables.graphicsWindowPixelsRight
5426	.dcd7						LDCD9:
5427	.dcd7		a0 34		ldy #$34	                ldy #VDUVariables.hlfw.pixelsLimitX
5428	.dcd9		20 0a c9	jsr $c90a	                jsr copyTwoBytesWithinVDUVariables
5429	.dcdc		a2 34		ldx #$34	                ldx #VDUVariables.hlfw.pixelsLimitX
5430	.dcde		20 33 dd	jsr $dd33	                jsr shouldFillPixel
5431	.dce1		d0 25		bne $dd08	                bne rtsDD0A  ;taken if pixel not to be filled, so done
5432	.dce3						LDCE5:
5433	.dce3		46 d1		lsr $d1		                lsr ZMASK                    ;next pixel
5434	.dce5		90 08		bcc $dcef	                bcc LDCF1                    ;taken if still in same byte
5435	.dce7						LDCE9:
5436	.dce7		20 65 da	jsr $da65	                jsr nextColumnAndResetMask
5437	.dcea		20 63 dd	jsr $dd63	                jsr shouldFillByte
5438	.dced		b0 f8		bcs $dce7	                bcs LDCE9
5439	.dcef						LDCF1:
5440	.dcef		20 83 dd	jsr $dd83	                jsr LDD85
5441	.dcf2		b0 ef		bcs $dce3	                bcs LDCE5
5442	.dcf4		38		sec		                sec
5443	.dcf5		ad 34 03	lda $0334	                lda vduv.hlfw.pixelsLimitX+0
5444	.dcf8		e5 de		sbc $de		                sbc zhlfw.pixelsX+0
5445	.dcfa		8d 32 03	sta $0332	                sta vduv.hlfw.pixelsRightEndX+0
5446	.dcfd		ad 35 03	lda $0335	                lda vduv.hlfw.pixelsLimitX+1
5447	.dd00		e5 df		sbc $df		                sbc zhlfw.pixelsX+1
5448	.dd02		8d 33 03	sta $0333	                sta vduv.hlfw.pixelsRightEndX+1
5449	.dd05						LDD07:
5450	.dd05		a9 00		lda #$00	                lda #$00
5451	.dd07		38		sec		                sec
5452	.dd08						rtsDD0A:
5453	.dd08		60		rts		                rts

5455	.dd09						LDD0B:
5456	.dd09		a2 00		ldx #$00	                ldx #VDUVariables.graphicsWindowPixelsLeft
5457	.dd0b		20 33 dd	jsr $dd33	                jsr shouldFillPixel
5458	.dd0e		d0 f8		bne $dd08	                bne rtsDD0A                    ;taken if pixel not to be filled, so done
5459	.dd10						LDD12:
5460	.dd10		06 d1		asl $d1		                asl ZMASK                      ;next pixel
5461	.dd12		90 08		bcc $dd1c	                bcc LDD1E                    ;taken if still in same byte
5462	.dd14						LDD16:
5463	.dd14		20 32 da	jsr $da32	                jsr previousColumnAndResetMask
5464	.dd17		20 63 dd	jsr $dd63	                jsr shouldFillByte
5465	.dd1a		b0 f8		bcs $dd14	                bcs LDD16
5466	.dd1c						LDD1E:
5467	.dd1c		20 83 dd	jsr $dd83	                jsr LDD85
5468	.dd1f		b0 ef		bcs $dd10	                bcs LDD12
5469	.dd21		ad 00 03	lda $0300	                lda vduv.graphicsWindowPixelsLeft+0
5470	.dd24		65 de		adc $de		                adc zhlfw.pixelsX+0
5471	.dd26		8d 2e 03	sta $032e	                sta vduv.hlfw.pixelsX+0
5472	.dd29		ad 01 03	lda $0301	                lda vduv.graphicsWindowPixelsLeft+1
5473	.dd2c		65 df		adc $df		                adc zhlfw.pixelsX+1
5474	.dd2e		8d 2f 03	sta $032f	                sta vduv.hlfw.pixelsX+1
5475	.dd31		80 d2		bra $dd05	                bra LDD07

5477							;-------------------------------------------------------------------------
5478							;
5479							; Check whether line fill should fill a pixel.
5480							;
5481							; entry:
5482							;
5483							; X = VDU variable offset of edge of window
5484							;
5485							; vduv.workspace._2E - pixel X, Y coordinates
5486							;
5487							; exit:
5488							;
5489							; Z=1 if pixel should be filled
5490							;
5491							; ZTEMPC = ???
5492							;
5493	.dd33						shouldFillPixel:
5494	.dd33		38		sec		                sec
5495	.dd34		ad 2e 03	lda $032e	                lda vduv.workspace._2E+0
5496	.dd37		fd 00 03	sbc $0300,x	                sbc vduv+0,x
5497	.dd3a		a8		tay		                tay
5498	.dd3b		ad 2f 03	lda $032f	                lda vduv.workspace._2E+1
5499	.dd3e		fd 01 03	sbc $0301,x	                sbc vduv+1,x
5500	.dd41		10 03		bpl $dd46	                bpl +
5501	.dd43		20 2c c9	jsr $c92c	                jsr negateAY
5502	.dd46						+
5503	.dd46		84 de		sty $de		                sty zhlfw.pixelsX+0
5504	.dd48		85 df		sta $df		                sta zhlfw.pixelsX+1
5505	.dd4a		a2 2e		ldx #$2e	                ldx #VDUVariables.workspace._2E
5506	.dd4c		20 c1 de	jsr $dec1	                jsr windGADDR
5507	.dd4f		18		clc		                clc
5508	.dd50		d0 10		bne $dd62	                bne rtsDD64                    ;taken if point outside window
5509	.dd52		b1 d6		lda ($d6),y	                lda (ZMEMG),y                  ;get screen byte
5510	.dd54		5d 30 88	eor $8830,x	                eor andy.hlfw.ecfPattern,x     ;EOR with appropriate pattern
5511	.dd57		85 da		sta $da		                sta zhlfw.notByteMatch ;0 if whole byte matches
5512	.dd59		25 d1		and $d1		                and ZMASK                      ;0 if masked byte matches
5513	.dd5b		f0 02		beq $dd5f	                beq +              ;taken if masked byte matches - A=0
5514	.dd5d		a9 08		lda #$08	                lda #$08              ;masked byte doesn't match - A=8
5515	.dd5f						+
5516	.dd5f		45 e1		eor $e1		                eor zhlfw.resultEOR ;maybe invert result
5517	.dd61		38		sec		                sec
5518	.dd62						rtsDD64:
5519	.dd62		60		rts		                rts

5521							;-------------------------------------------------------------------------

5523	.dd63						shouldFillByte:
5524	.dd63		b1 d6		lda ($d6),y	                lda (ZMEMG),y
5525	.dd65		5d 30 88	eor $8830,x	                eor andy.hlfw.ecfPattern,x
5526	.dd68		85 da		sta $da		                sta zhlfw.notByteMatch
5527	.dd6a		05 e1		ora $e1		                ora zhlfw.resultEOR
5528	.dd6c		18		clc		                clc
5529	.dd6d		d0 13		bne $dd82	                bne rtsDD84
5530	.dd6f		a5 de		lda $de		                lda zhlfw.pixelsX+0
5531	.dd71		ed 61 03	sbc $0361	                sbc vduv.pixelsPerByteMinusOne
5532	.dd74		48		pha		                pha
5533	.dd75		a5 df		lda $df		                lda zhlfw.pixelsX+1
5534	.dd77		e9 00		sbc #$00	                sbc #$00
5535	.dd79		90 06		bcc $dd81	                bcc pla_rts_DD83             ;taken if past X=0
5536	.dd7b		85 df		sta $df		                sta zhlfw.pixelsX+1
5537	.dd7d		68		pla		                pla
5538	.dd7e		85 de		sta $de		                sta zhlfw.pixelsX+0
5539	.dd80		60		rts		                rts

5541	.dd81						pla_rts_DD83:
5542	.dd81		68		pla		                pla
5543	.dd82						rtsDD84:
5544	.dd82		60		rts		                rts

5546							;-------------------------------------------------------------------------

5548	.dd83						LDD85:
5549	.dd83		a5 da		lda $da		                lda zhlfw.notByteMatch
5550	.dd85		25 d1		and $d1		                and ZMASK
5551	.dd87		f0 02		beq $dd8b	                beq +
5552	.dd89		a9 08		lda #$08	                lda #$08
5553	.dd8b						+
5554	.dd8b		45 e1		eor $e1		                eor zhlfw.resultEOR
5555	.dd8d		d0 0d		bne $dd9c	                bne rtsDD9E

5557							                ; pixelsX -= 1
5558	.dd8f		a5 de		lda $de		                lda zhlfw.pixelsX+0
5559	.dd91		d0 06		bne $dd99	                bne +
5560	.dd93		a5 df		lda $df		                lda zhlfw.pixelsX+1
5561	.dd95		f0 05		beq $dd9c	                beq rtsDD9E
5562	.dd97		c6 df		dec $df		                dec zhlfw.pixelsX+1
5563	.dd99						+
5564	.dd99		c6 de		dec $de		                dec zhlfw.pixelsX+0
5565	.dd9b		38		sec		                sec
5566	.dd9c						rtsDD9E:
5567	.dd9c		60		rts		                rts

5569							;-------------------------------------------------------------------------
5570							;
5571							; Copy appropriate ECF pattern for line fill.
5572							;
5573							; entry:
5574							;
5575							; A = horizontal line fill PLOT code
5576							;
5577							; exit:
5578							;
5579							; andy.hlfw.ecfPattern = holds bg/fg ECF pattern as required
5580							;
5581							; ZTEMPD?1 = 0 for fill to matching, 8 to fill to non-matching
5582							;
5583	.dd9d						copyECFPatternForLineFill:
5584	.dd9d		4a		lsr a		                lsr a                        ;36-39; 44-47; 52-55; 60-63
5585	.dd9e		4a		lsr a		                lsr a                        ;18-19; 42-43; 26-27; 30-31
5586	.dd9f						LDDA1:
5587	.dd9f		29 08		and #$08	                and #$08                     ;8 if PLOT >= 104
5588	.dda1		85 e1		sta $e1		                sta zhlfw.resultEOR
5589	.dda3		49 0f		eor #$0f	                eor #$0F                     ;
5590	.dda5		aa		tax		                tax
5591	.dda6		a0 07		ldy #$07	                ldy #$07
5592	.dda8						-
5593	.dda8		bd 20 88	lda $8820,x	                lda andy.currentECFPatterns,x
5594	.ddab		99 30 88	sta $8830,y	                sta andy.hlfw.ecfPattern,y
5595	.ddae		ca		dex		                dex
5596	.ddaf		88		dey		                dey
5597	.ddb0		10 f6		bpl $dda8	                bpl -
5598	.ddb2		a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
5599	.ddb4		60		rts		                rts

5601							;-------------------------------------------------------------------------
5602							;
5603							;
5604							; entry:
5605							;
5606							; A = offset into VDU variables of coordinates
5607							;
5608							; exit:
5609							;
5610							; A = colour, or $ff if off screen/teletext (as per OSWORD $09)
5611							;
5612	.ddb5						readPixelColour: .proc
5613	.ddb5		20 fa c0	jsr $c0fa	                jsr stopCursorEditing
5614	.ddb8		ae 61 03	ldx $0361	                ldx vduv.pixelsPerByteMinusOne
5615	.ddbb		f0 21		beq $ddde	                beq invalid             ;taken if teletext
5616	.ddbd		48		pha		                pha
5617	.ddbe		aa		tax		                tax
5618	.ddbf		20 dc d1	jsr $d1dc	                jsr eigabsEntryPoint
5619	.ddc2		fa		plx		                plx
5620	.ddc3		20 c1 de	jsr $dec1	                jsr windGADDR
5621	.ddc6		d0 16		bne $ddde	                bne invalid             ;taken if off screen
5622	.ddc8		b1 d6		lda ($d6),y	                lda (ZMEMG),y
5623	.ddca		64 da		stz $da		                stz ZTEMP+0
5624	.ddcc		80 01		bra $ddcf	                bra shiftMask

5626							                ; Keep shifting the byte and the mask. When a 1 bit is
5627							                ; shifted out of the mask, shift the corresponding
5628							                ; byte bit bit into ZTEMP+0, building up the pixel
5629							                ; colour a bit at a time.
5630							                ;
5631							                ; When the mask becomes 0, done.
5632	.ddce						shiftByteAndMask:
5633	.ddce		0a		asl a		                asl a
5634	.ddcf						shiftMask:
5635	.ddcf		06 d1		asl $d1		                asl ZMASK
5636	.ddd1		90 fb		bcc $ddce	                bcc shiftByteAndMask
5637	.ddd3		0a		asl a		                asl a
5638	.ddd4		26 da		rol $da		                rol ZTEMP+0
5639	.ddd6		a6 d1		ldx $d1		                ldx ZMASK
5640	.ddd8		d0 f5		bne $ddcf	                bne shiftMask
5641	.ddda		a5 da		lda $da		                lda ZTEMP+0
5642	.dddc		80 02		bra $dde0	                bra done

5644	.ddde						invalid:
5645	.ddde		a9 ff		lda #$ff	                lda #$FF
5646	.dde0						done:
5647	.dde0		4c ca c0	jmp $c0ca	                jmp reinstateCursorEditing
5648							                .endproc

5650							;-------------------------------------------------------------------------
5651							;
5652							; Translate ASCII char to the SAA5050 character set.
5653							;
5654							; # ($23) becomes $5f
5655							; _ ($5f) becomes $60
5656							; GBP ($60) becomes $23
5657							;
5658							; Because the mapping is a kind of cycle, you can call this routine
5659							; twice to translate from SAA5050 to ASCII.
5660							;
5661							; entry:
5662							;
5663							; A = ASCII char
5664							;
5665							; exit:
5666							;
5667							; A = SAA550 char
5668							;
5669	.dde3						getSAA5050FromASCII:
5670	.dde3		c9 23		cmp #$23	                cmp #$23
5671	.dde5		f0 0a		beq $ddf1	                beq translateHash
5672	.dde7		c9 5f		cmp #$5f	                cmp #$5F
5673	.dde9		f0 08		beq $ddf3	                beq translateUnderscore
5674	.ddeb		c9 60		cmp #$60	                cmp #$60
5675	.dded		d0 06		bne $ddf5	                bne rtsDDF7
5676	.ddef						translateGBP:
5677	.ddef		49 3f		eor #$3f	                eor #$3F                     ;0x60->0x5f
5678	.ddf1						translateHash:
5679	.ddf1		49 43		eor #$43	                eor #$43                     ;0x23->0x5f or 0x5f->0x1c
5680	.ddf3						translateUnderscore:
5681	.ddf3		49 3f		eor #$3f	                eor #$3F                     ;0x5f->0x60 or 0x1c->0x23
5682	.ddf5						rtsDDF7:
5683	.ddf5		60		rts		                rts

5685							;-------------------------------------------------------------------------

5687	.ddf6						readCharacterAtTextCursor: .proc
5688	.ddf6		58		cli		                cli
5689	.ddf7		24 d0		bit $d0		                bit STATE
5690	.ddf9		50 06		bvc $de01	                bvc +                      ;taken if not cursor editing
5691	.ddfb		20 fa c0	jsr $c0fa	                jsr stopCursorEditing
5692	.ddfe		20 d1 c0	jsr $c0d1	                jsr exchangeCursors
5693	.de01						+
5694	.de01		ac 60 03	ldy $0360	                ldy vduv.numberOfLogicalColoursMinusOne
5695	.de04		d0 17		bne $de1d	                bne bitmapMode
5696	.de06						readTeletextChar:
5697	.de06		b2 d8		lda ($d8)	                lda (ZMEMT)                  ;read character from screen
5698	.de08		20 e3 dd	jsr $dde3	                jsr getSAA5050FromASCII      ;call 2x to convert to ASCII
5699	.de0b		20 e3 dd	jsr $dde3	                jsr getSAA5050FromASCII      ;call 2x to convert to ASCII
5700	.de0e						done:
5701	.de0e		24 d0		bit $d0		                bit STATE
5702	.de10		50 06		bvc $de18	                bvc +                     ;taken if not cursor editing
5703	.de12		20 d1 c0	jsr $c0d1	                jsr exchangeCursors
5704	.de15		20 ca c0	jsr $c0ca	                jsr reinstateCursorEditing
5705	.de18						+
5706	.de18		ac 55 03	ldy $0355	                ldy vduv.currentScreenMODE
5707	.de1b		aa		tax		                tax
5708	.de1c		60		rts		                rts

5710	.de1d						bitmapMode:
5711	.de1d		20 54 de	jsr $de54	                jsr LDE56
5712	.de20		a5 f4		lda $f4		                lda $F4
5713	.de22		48		pha		                pha
5714	.de23		20 8c e5	jsr $e58c	                jsr selectTerminalROMAndANDY
5715	.de26		a9 20		lda #$20	                lda #$20
5716	.de28		aa		tax		                tax                          ;X = ASCII code for char
5717	.de29		20 2a e2	jsr $e22a	                jsr getSoftCharacterDefinitionAddress
5718	.de2c						compare:
5719	.de2c		a0 07		ldy #$07	                ldy #$07
5720	.de2e						-
5721	.de2e		b9 28 03	lda $0328,y	                lda vduv.workspace._28,y
5722	.de31		51 de		eor ($de),y	                eor (ZTEMPC),y
5723	.de33		d0 0a		bne $de3f	                bne nextFontChar ;taken if no match - can't be this char
5724	.de35		88		dey		                dey
5725	.de36		10 f6		bpl $de2e	                bpl -

5727	.de38		8a		txa		                txa                          ;A = char found
5728							                .if version==350
5731							                .endif
5732	.de39						bitmapModeDone:
5733	.de39		fa		plx		                plx
5734	.de3a		20 8e e5	jsr $e58e	                jsr selectROMX
5735	.de3d		80 cf		bra $de0e	                bra done

5737	.de3f						nextFontChar:
5738	.de3f		e8		inx		                inx                          ;next ASCII code
5739							                .if version==350
5745							                .else
5746	.de40		18		clc		                clc
5747	.de41		a5 de		lda $de		                lda ZTEMPC+0
5748	.de43		69 08		adc #$08	                adc #$08                     ;8 bytes/font char
5749	.de45		85 de		sta $de		                sta ZTEMPC+0
5750	.de47		90 02		bcc $de4b	                bcc gotCharAddress
5751	.de49		e6 df		inc $df		                inc ZTEMPC+1
5752							                .endif
5753	.de4b						gotCharAddress:
5754	.de4b		e0 7f		cpx #$7f	                cpx #$7F
5755	.de4d		f0 f0		beq $de3f	                beq nextFontChar                 ;skip CHR$127
5756	.de4f		8a		txa		                txa
5757	.de50		d0 da		bne $de2c	                bne compare           ;taken if more chars to consider
5758	.de52		80 e5		bra $de39	                bra bitmapModeDone ;finish with A=0 - i.e., no match found
5759							                .endproc

5761							;-------------------------------------------------------------------------
5762							;
5763							; Copy character out of screen memory, and store as a 1 bpp bitmap in
5764							; VDU variables workspace.
5765							;
5766	.de54						LDE56: .proc
5767	.de54		a6 d8		ldx $d8		                ldx ZMEMT+0
5768	.de56		a5 d9		lda $d9		                lda ZMEMT+1
5769	.de58		20 d7 ce	jsr $ced7	                jsr getNext3ColumnAddresses
5770	.de5b		a0 07		ldy #$07	                ldy #$07
5771	.de5d						loop:
5772	.de5d		ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
5773	.de60		e0 03		cpx #$03	                cpx #$03
5774	.de62		f0 09		beq $de6d	                beq read2bppChar
5775	.de64		b0 13		bcs $de79	                bcs read4bppChar
5776	.de66						read1bppChar:
5777	.de66		b1 d8		lda ($d8),y	                lda (ZMEMT),y
5778	.de68		4d 58 03	eor $0358	                eor vduv.backgroundTextColour
5779	.de6b		80 22		bra $de8f	                bra next

5781	.de6d						read2bppChar:
5782	.de6d		b1 d8		lda ($d8),y	                lda (ZMEMT),y                ;get pixels 0-3
5783	.de6f		20 a0 de	jsr $dea0	                jsr get4Pixels
5784	.de72		b1 da		lda ($da),y	                lda (ZTEMP),y                  ;get pixels 4-7
5785	.de74		20 a0 de	jsr $dea0	                jsr get4Pixels
5786	.de77		80 14		bra $de8d	                bra LDE8F

5788	.de79						read4bppChar:
5789	.de79		b1 d8		lda ($d8),y	                lda (ZMEMT),y                ;get pixels 0/1
5790	.de7b		20 96 de	jsr $de96	                jsr get2Pixels
5791	.de7e		b1 da		lda ($da),y	                lda (ZTEMP),y                ;get pixels 2/3
5792	.de80		20 96 de	jsr $de96	                jsr get2Pixels
5793	.de83		b1 dc		lda ($dc),y	                lda (ZTEMPB),y               ;get pixels 4/5
5794	.de85		20 96 de	jsr $de96	                jsr get2Pixels
5795	.de88		b1 e0		lda ($e0),y	                lda (ZTEMPD),y               ;get pixels 6/7
5796	.de8a		20 96 de	jsr $de96	                jsr get2Pixels
5797	.de8d						LDE8F:
5798	.de8d		a5 df		lda $df		                lda ZTEMPC+1
5799	.de8f						next:
5800	.de8f		99 28 03	sta $0328,y	                sta vduv.workspace._28,y
5801	.de92		88		dey		                dey
5802	.de93		10 c8		bpl $de5d	                bpl loop
5803	.de95		60		rts		                rts

5805	.de96						get2Pixels:
5806	.de96		4d 58 03	eor $0358	                eor vduv.backgroundTextColour ;reset background pixel bits
5807	.de99		20 b3 de	jsr $deb3	                jsr or2Pixels
5808	.de9c		29 03		and #$03	                and #%00000011               ;2 pixels/byte
5809	.de9e		80 0c		bra $deac	                bra shiftIn2

5811	.dea0						get4Pixels:
5812	.dea0		4d 58 03	eor $0358	                eor vduv.backgroundTextColour ;
5813	.dea3		20 b8 de	jsr $deb8	                jsr or4Pixels
5814	.dea6		29 0f		and #$0f	                and #%00001111               ;4 pixels/byte

5816							                ; Build up the 1bpp char row in ZTEMPC?1, 2 or 4 bits
5817							                ; at a time.
5818	.dea8		06 df		asl $df		                asl ZTEMPC+1
5819	.deaa		06 df		asl $df		                asl ZTEMPC+1
5820	.deac						shiftIn2:
5821	.deac		06 df		asl $df		                asl ZTEMPC+1
5822	.deae		06 df		asl $df		                asl ZTEMPC+1
5823	.deb0		04 df		tsb $df		                tsb ZTEMPC+1
5824	.deb2		60		rts		                rts

5826							                ; OR together all the N bits for each pixel, making a
5827							                ; byte in which the bottom N bits have a bit set for
5828							                ; each non-0 pixel in the byte.
5829	.deb3						or2Pixels:
5830	.deb3		85 de		sta $de		                sta ZTEMPC+0
5831	.deb5		20 bc de	jsr $debc	                jsr shiftOut2
5832	.deb8						or4Pixels:
5833	.deb8		85 de		sta $de		                sta ZTEMPC+0                 ;%abcdABCD
5834	.deba		4a		lsr a		                lsr a                        ;%0abcdABC
5835	.debb		4a		lsr a		                lsr a                        ;%00abcdAB
5836	.debc						shiftOut2:
5837	.debc		4a		lsr a		                lsr a                        ;%000abcdA
5838	.debd		4a		lsr a		                lsr a                        ;%0000abcd
5839	.debe		05 de		ora $de		                ora ZTEMPC+0                 ;%0000abcd|%abcdABCD
5840							                .endproc
5841	.dec0						rtsDEC2:
5842	.dec0		60		rts		                rts

5844							;-------------------------------------------------------------------------
5845							;
5846							; Do WIND. If point not in window, return with Z=0. Otherwise, call
5847							; GADDR and return with Z=1.
5848							;
5849	.dec1						windGADDR:
5850	.dec1		20 a6 d1	jsr $d1a6	                jsr windEntryPoint
5851	.dec4		d0 fa		bne $dec0	                bne rtsDEC2                  ;taken if point outside window
5852	.dec6						gaddrEntryPoint:
5853	.dec6		bd 02 03	lda $0302,x	                lda vduv+2,x                 ;get Y coordinate
5854	.dec9						LDECB:
5855	.dec9		49 ff		eor #$ff	                eor #$FF                     ;invert Y coordinate
5856	.decb		a8		tay		                tay                          ;Y=Y coordinate
5857	.decc		29 07		and #$07	                and #$07                ;get scanline in character row
5858	.dece		85 da		sta $da		                sta ZTEMP+0             ;save scanline
5859	.ded0		98		tya		                tya                          ;A=Y coordinate
5860	.ded1		29 f8		and #$f8	                and #$F8                     ;row*8
5861	.ded3		4a		lsr a		                lsr a                        ;row*4
5862	.ded4		85 d7		sta $d7		                sta ZMEMG+1                  ;>(row*1024)
5863	.ded6		4a		lsr a		                lsr a                        ;>(row*512)
5864	.ded7		4a		lsr a		                lsr a                        ;>(row*256)
5865	.ded8		65 d7		adc $d7		                adc ZMEMG+1                  ;>(row*1280)
5866	.deda		4a		lsr a		                lsr a                        ;>(row*640)
5867	.dedb		85 d7		sta $d7		                sta ZMEMG+1                  ;
5868	.dedd		a9 00		lda #$00	                lda #$00                     ;
5869	.dedf		6a		ror a		                ror a                        ;<(row*640) - $00/$80
5870	.dee0		ac 56 03	ldy $0356	                ldy vduv.currentScreenMODEGroup
5871	.dee3		f0 03		beq $dee8	                beq +                      ;taken if 640 bytes per row
5872	.dee5		46 d7		lsr $d7		                lsr ZMEMG+1                ;>(row*320)
5873	.dee7		6a		ror a		                ror a                    ;<(row*320) - $00/$40/$80/$c0
5874	.dee8						+
5875	.dee8		05 da		ora $da		                ora ZTEMP+0               ;include the scanline offset
5876	.deea		6d 50 03	adc $0350	                adc vduv.screenTopLeftAddress+0 ;include LSB of screen base
5877	.deed		8d 1a 03	sta $031a	                sta vduv.graphicsAddressOffset

5879							                ; add MSB of screen base to ZMEMG+1
5880	.def0		a5 d7		lda $d7		                lda ZMEMG+1
5881	.def2		6d 51 03	adc $0351	                adc vduv.screenTopLeftAddress+1
5882	.def5		85 d7		sta $d7		                sta ZMEMG+1

5884	.def7		bd 01 03	lda $0301,x	                lda vduv+1,x                 ;get >X
5885	.defa		85 d6		sta $d6		                sta ZMEMG+0                  ;save >X
5886	.defc		bd 00 03	lda $0300,x	                lda vduv+0,x                 ;get <X
5887	.deff		2d 61 03	and $0361	                and vduv.pixelsPerByteMinusOne ;index for pixel
5888	.df02		6d 61 03	adc $0361	                adc vduv.pixelsPerByteMinusOne ;offset into pixel mask table
5889	.df05		a8		tay		                tay
5890	.df06		b9 2c e1	lda $e12c,y	                lda pixelMasks-1,y
5891	.df09		85 d1		sta $d1		                sta ZMASK

5893							                ; Form 16-bit column address offset (LSB in A, MSB in
5894							                ; ZMEMG+0), assuming 8 bits/pixel. No adjustment
5895							                ; needed if MODE 0/4, but scale up by 2 if MODE 1/5 or
5896							                ; 4 if MODE 2.

5898	.df0b		bd 00 03	lda $0300,x	                lda vduv+0,x                 ;A = <X
5899	.df0e		ac 61 03	ldy $0361	                ldy vduv.pixelsPerByteMinusOne
5900	.df11		c0 03		cpy #$03	                cpy #$03
5901	.df13		f0 05		beq $df1a	                beq LDF1C         ;taken if 4 px/byte - i.e., MODE 1/5
5902	.df15		b0 06		bcs $df1d	                bcs LDF1F        ;taken if >4 px/byte - i.e., MODE 0/4
5903	.df17		0a		asl a		                asl a
5904	.df18		26 d6		rol $d6		                rol ZMEMG+0
5905	.df1a						LDF1C:
5906	.df1a		0a		asl a		                asl a
5907	.df1b		26 d6		rol $d6		                rol ZMEMG+0
5908	.df1d						LDF1F:
5909	.df1d		29 f8		and #$f8	                and #$F8                     ;<column offset
5910	.df1f		18		clc		                clc
5911	.df20		6d 1a 03	adc $031a	                adc vduv.graphicsAddressOffset
5912	.df23		8d 1a 03	sta $031a	                sta vduv.graphicsAddressOffset
5913	.df26		a5 d6		lda $d6		                lda ZMEMG+0                  ;>column offset
5914	.df28		65 d7		adc $d7		                adc ZMEMG+1                  ;add to address MSB
5915	.df2a		10 04		bpl $df30	                bpl +                        ;taken if no wrap
5916	.df2c		38		sec		                sec
5917	.df2d		ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte ;handle wrap at end of screen
5918	.df30						+
5919	.df30		85 d7		sta $d7		                sta ZMEMG+1                  ;got MSB
5920	.df32		64 d6		stz $d6		                stz ZMEMG+0 ;LSB always 0 - the offset takes care of this
5921	.df34		a6 da		ldx $da		                ldx ZTEMP+0 ;get scanline in row
5922	.df36		20 7a da	jsr $da7a	                jsr setupColourMasks
5923	.df39		ac 1a 03	ldy $031a	                ldy vduv.graphicsAddressOffset
5924	.df3c						ldaim00_rts_DF3E:
5925	.df3c		a9 00		lda #$00	                lda #$00                     ;return with Z=1, as per WIND
5926	.df3e		60		rts		                rts

5928							;-------------------------------------------------------------------------

5930	.df3f						LDF41:
5931	.df3f		20 c6 de	jsr $dec6	                jsr gaddrEntryPoint
5932	.df42		da		phx		                phx
5933	.df43		a2 00		ldx #$00	                ldx #$00
5934	.df45		ad 5a 03	lda $035a	                lda $035A
5935	.df48		c9 04		cmp #$04	                cmp #$04
5936	.df4a		b0 0b		bcs $df57	                bcs LDF59
5937	.df4c		ae 6a 03	ldx $036a	                ldx $036A
5938	.df4f		ad 59 03	lda $0359	                lda $0359
5939	.df52		f0 03		beq $df57	                beq LDF59
5940	.df54		ae 6b 03	ldx $036b	                ldx $036B
5941	.df57						LDF59:
5942	.df57		8e 69 03	stx $0369	                stx $0369
5943	.df5a		fa		plx		                plx
5944	.df5b		60		rts		                rts

5946							;-------------------------------------------------------------------------

5948	.df5c						handleCopyKey:
5949	.df5c		a9 20		lda #$20	                lda #STATE.isVDU5
5950	.df5e		24 d0		bit $d0		                bit STATE
5951	.df60		50 da		bvc $df3c	                bvc ldaim00_rts_DF3E      ;taken if not cursor editing
5952	.df62		d0 d8		bne $df3c	                bne ldaim00_rts_DF3E      ;taken if VDU5
5953							                .if version==350&&!finmos329
5955							                .elsif (version<511||autocue)&&!finmos329
5956	.df64		20 f6 dd	jsr $ddf6	                jsr readCharacterAtTextCursor
5961							                .endif
5962	.df67		f0 0c		beq $df75	                beq rtsDF77              ;taken if char not recognised
5963	.df69		48		pha		                pha                      ;save char recognised
5964	.df6a		20 d3 df	jsr $dfd3	                jsr isCursorEditingPossible
5965	.df6d		d0 05		bne $df74	                bne pla_rts_DF76
5966	.df6f		a9 09		lda #$09	                lda #$09
5967	.df71		20 ba df	jsr $dfba	                jsr moveEditCursor
5968	.df74						pla_rts_DF76:
5969	.df74		68		pla		                pla
5970	.df75						rtsDF77:
5971	.df75		60		rts		                rts

5973							;-------------------------------------------------------------------------
5974							;
5975							; Handle cursor key press.
5976							;
5977							; Entry: A = one of the cursor key codes:
5978							;            $88 = left
5979							;            $89 = right
5980							;            $8a = down
5981							;            $8b = up

5983	.df76						handleCursorKey:
5984	.df76		48		pha		                pha                          ;save cursor key code
5985	.df77		20 d3 df	jsr $dfd3	                jsr isCursorEditingPossible
5986	.df7a		d0 f8		bne $df74	                bne pla_rts_DF76             ;bail if editing not possible
5987	.df7c		70 16		bvs $df94	                bvs editing                  ;taken if already editing
5988	.df7e						beginEditing:
5989	.df7e		ad 5f 03	lda $035f	                lda vduv.lastCursorStartRegisterValue
5990	.df81		29 df		and #$df	                and #%11011111
5991	.df83		20 51 cf	jsr $cf51	                jsr setCRTCRegister10        ;hide cursor
5992	.df86		a2 18		ldx #$18	                ldx #VDUVariables.textCursorXPosition
5993	.df88		a0 64		ldy #$64	                ldy #VDUVariables.editCursorXPosition
5994	.df8a		20 0a c9	jsr $c90a	                jsr copyTwoBytesWithinVDUVariables ;edit cursor pos =
5995							                                                   ;text cursor pos
5996	.df8d		20 05 c1	jsr $c105	                jsr activateEditCursor
5997	.df90		a9 02		lda #$02	                lda #STATE.isScrollingDisabled
5998	.df92		04 d0		tsb $d0		                tsb STATE
5999	.df94						editing:
6000	.df94		68		pla		                pla                          ;restore cursor key code

6002							                ; Form appropriate VDU command (8/9/10/11) for the
6003							                ; key, assuming no VDU axis rearrangement.
6004	.df95		29 7f		and #$7f	                and #$7F
6005	.df97		85 da		sta $da		                sta ZTEMP                    ;save VDU command

6007							                ; Adjust VDU command based on axis swap/inversion.
6008	.df99		c9 0a		cmp #$0a	                cmp #$0A
6009	.df9b		b0 0e		bcs $dfab	                bcs handleCursorUpOrDown     ;taken if up/down
6010	.df9d						handleCursorLeftOrRightOrCopy:
6011	.df9d		ad 66 03	lda $0366	                lda vduv.cursorFlags
6012	.dfa0		4a		lsr a		                lsr a
6013	.dfa1		29 05		and #$05	                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertHorizontal)>>1
6014	.dfa3		89 04		bit #$04	                bit #vduv.cursorFlags.swapAxes>>1
6015	.dfa5		f0 11		beq $dfb8	                beq gotActualMoveCommand

6017	.dfa7		49 07		eor #$07	                eor #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal)>>1
6018	.dfa9		80 0d		bra $dfb8	                bra gotActualMoveCommand

6020	.dfab						handleCursorUpOrDown:
6021	.dfab		ad 66 03	lda $0366	                lda vduv.cursorFlags
6022	.dfae		4a		lsr a		                lsr a
6023	.dfaf		4a		lsr a		                lsr a
6024	.dfb0		29 03		and #$03	                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical)>>2 ;000000SV
6025	.dfb2		89 02		bit #$02	                bit #vduv.cursorFlags.swapAxes>>2
6026	.dfb4		f0 02		beq $dfb8	                beq gotActualMoveCommand

6028	.dfb6		49 01		eor #$01	                eor #vduv.cursorFlags.invertVertical>>2
6029	.dfb8						gotActualMoveCommand:
6030	.dfb8		45 da		eor $da		                eor ZTEMP
6031	.dfba						moveEditCursor:
6032	.dfba		a8		tay		                tay                          ;save command
6033	.dfbb		a9 40		lda #$40	                lda #STATE.isCursorEditing
6034	.dfbd		14 d0		trb $d0		                trb STATE            ;temporarily disable edit mode
6035	.dfbf		98		tya		                tya                  ;restore command
6036	.dfc0		ae 6c 03	ldx $036c	                ldx vduv.column81
6037	.dfc3		da		phx		                phx                  ;save old column 81 flag
6038	.dfc4		4e 6c 03	lsr $036c	                lsr vduv.column81    ;temporarily reset column 81 flag
6039	.dfc7		20 27 c0	jsr $c027	                jsr outputToVDU      ;print the cursor movement command
6040	.dfca		68		pla		                pla
6041	.dfcb		8d 6c 03	sta $036c	                sta vduv.column81            ;restore column 81 flag
6042	.dfce		a9 40		lda #$40	                lda #STATE.isCursorEditing
6043	.dfd0		04 d0		tsb $d0		                tsb STATE                    ;reinstate edit mode
6044	.dfd2		60		rts		                rts

6046							; Check if cursor editing is possible.
6047							;
6048							; Exit: Z=1 - editing is possible
6049							;             V reflects current STATE.isCursorEditing bit
6050							;       Z=0 - editing not possible
6051	.dfd3						isCursorEditingPossible:
6052	.dfd3		ae 6a 02	ldx $026a	                ldx vduQueueNegativeLength
6053	.dfd6		d0 04		bne $dfdc	                bne +                        ;return with Z=0 if VDU
6054							                                             ;queue not empty
6055	.dfd8		a9 a0		lda #$a0	                lda #STATE.isVDU21|STATE.isVDU5
6056	.dfda		24 d0		bit $d0		                bit STATE   ;return with Z=0 if neither VDU21 nor VDU5
6057	.dfdc						+
6058	.dfdc		60		rts		                rts

6060							;-------------------------------------------------------------------------
6061							;
6062							; 184-191 = Move/copy rectangle [MasRef E.3-31]
6063							;
6064							                .if version!=400
6070							                .endif

6072							;-------------------------------------------------------------------------
6073							;
6074							; 192-199 = Plot ellipse outline [MasRef E.3-32]
6075							;
6076							                .if version!=400
6083							                .endif

6085							;-------------------------------------------------------------------------
6086							;
6087							; 200-207 = Plot solid ellipse [MasRef E.3-32]
6088							;
6089							                .if version!=400
6095							                .endif

6097							                .if version==400
6098	>dfdd						                .align 256
6099							                .endif

6101							;-------------------------------------------------------------------------

6103							; Pretty sure I have the logic for this all wrong...

6105							                .if !finmos329
6107							                .endif
6108	.e000						startupMessages: .block
6109							                .if version==500||version==510||autocue
6111							                .endif

6113							                .if version>=511&&!autocue
6115							                .endif
6116	.e000						acornMOS:
6117	>e000		0d				                .text 13
6118							                .if olivetti
6128							                .else
6129	>e001		41 63 6f 72 6e 20 4d 4f		                .text "Acorn MOS"
	>e009		53
6130							                .endif
6131							                .if version==400||version==350
6132	>e00a		20				                .text " "
6133							                .endif
6134	>e00b		00				                .byte 0
6135	.e00c						beep:
6136	>e00c		07				                .byte 7
6137	>e00d		00				                .byte 0
6138							                .if version!=400&&version!=350
6140							                .endif

6142	.e00e						twoNewlines:
6143	>e00e		08				                .byte 8
6144	>e00f		0d				                .byte $0D
6145	>e010		0d				                .byte $0D
6146							                ; terminating 0 comes from following table!
6147							                .cerror *!=LE013,"startupMessages needs a terminating 0"
6148							                .endblock
6149	.e011						LE013:
6150	>e011		00				                .byte %00000000;$00
6151	>e012		11				                .byte %00010001;$11
6152	>e013		22				                .byte %00100010;$22
6153	>e014		33				                .byte %00110011;$33
6154	>e015		44				                .byte %01000100;$44
6155	>e016		55				                .byte %01010101;$55
6156	>e017		66				                .byte %01100110;$66
6157	>e018		77				                .byte %01110111;$77
6158	>e019		88				                .byte %10001000;$88
6159	>e01a		99				                .byte %10011001;$99
6160	>e01b		aa				                .byte %10101010;$AA
6161	>e01c		bb				                .byte %10111011;$BB
6162	>e01d		cc				                .byte %11001100;$CC
6163	>e01e		dd				                .byte %11011101;$DD
6164	>e01f		ee				                .byte %11101110;$EE
6165	>e020		ff				                .byte %11111111;$FF
6166	.e021						LE023:
6167	>e021		00				                .byte %00000000;$00
6168	>e022		55				                .byte %01010101;$55
6169	>e023		aa				                .byte %10101010;$AA
6170	>e024		ff				                .byte %11111111;$FF

6172							; VDU control code dispatch tables
6173							; ================================
6174							;
6175							; entry:
6176							;
6177							;

6179							; each routine is (address, number of additional VDU bytes)
6180	=[($c035,0)]					_:=[(vdu0EntryPoint,0)] ; VDU0
6181	=[($c035,0),($c0e2,1)]				_..=[(vdu1EntryPoint,1)] ; VDU1
6182	=[($c035,0),($c0e2,1),($c0ea,0)]		_..=[(vdu2EntryPoint,0)] ; VDU2
6183	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0)]	_..=[(vdu3EntryPoint,0)] ; VDU3
6184	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0)]
							_..=[(vdu4EntryPoint,0)] ; VDU4
6185	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0)]
							_..=[(vdu5EntryPoint,0)] ; VDU5
6186	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0)]
							_..=[(vdu6EntryPoint,0)] ; VDU6
6187	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0)]
							_..=[(vdu7EntryPoint,0)] ; VDU7
6188	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0)]
							_..=[(vdu8EntryPoint,0)] ; VDU8
6189	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0)]
							_..=[(vdu9EntryPoint,0)] ; VDU9
6190	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0)]
							_..=[(vdu10EntryPoint,0)] ; VDU10
6191	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0)]
							_..=[(vdu11EntryPoint,0)] ; VDU11
6192	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0)]
							_..=[(vdu12EntryPoint,0)] ; VDU12
6193	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0)]
							_..=[(vdu13EntryPoint,0)] ; VDU13
6194	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0)]
							_..=[(vdu14EntryPoint,0)] ; VDU14
6195	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0)]
							_..=[(vdu15EntryPoint,0)] ; VDU15
6196	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0)]
							_..=[(vdu16EntryPoint,0)] ; VDU16
6197	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1)]
							_..=[(vdu17EntryPoint,1)] ; VDU17
6198	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2)]
							_..=[(vdu18EntryPoint,2)] ; VDU18
6199	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5)]
							_..=[(vdu19EntryPoint,5)] ; VDU19
6200	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0)]
							_..=[(vdu20EntryPoint,0)] ; VDU20
6201	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0)]
							_..=[(vdu21EntryPoint,0)] ; VDU21
6202	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1)]
							_..=[(vdu22EntryPoint,1)] ; VDU22
6203	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9)]
							_..=[(vdu23EntryPoint,9)] ; VDU23
6204	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8)]
							_..=[(vdu24EntryPoint,8)] ; VDU24
6205	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5)]
							_..=[(vdu25EntryPoint,5)] ; VDU25
6206	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0)]
							_..=[(vdu26EntryPoint,0)] ; VDU26
6207	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0)]
							_..=[(vdu27EntryPoint,0)] ; VDU27
6208	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4)]
							_..=[(vdu28EntryPoint,4)] ; VDU28
6209	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4),($c78a,4)]
							_..=[(vdu29EntryPoint,4)] ; VDU29
6210	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4),($c78a,4),($c47c,0)]
							_..=[(vdu30EntryPoint,0)] ; VDU30
6211	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4),($c78a,4),($c47c,0),($c482,2)]
							_..=[(vdu31EntryPoint,2)] ; VDU31
6212	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4),($c78a,4),($c47c,0),($c482,2),($ce2b,0)]
							_..=[(vdu127EntryPoint,0)] ; VDU127
6213	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($edae,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4),($c78a,4),($c47c,0),($c482,2),($ce2b,0)]
							vdu_routines=_

6215							; LSB of routine address
6216	.e025						vduRoutinesLSBTable:
6217							                .for _i=0,_i<len(vdu_routines),_i+=1
6218	>e025		35				                .byte <vdu_routines[_i][0]
6218	>e026		e2				                .byte <vdu_routines[_i][0]
6218	>e027		ea				                .byte <vdu_routines[_i][0]
6218	>e028		ea				                .byte <vdu_routines[_i][0]
6218	>e029		1e				                .byte <vdu_routines[_i][0]
6218	>e02a		2d				                .byte <vdu_routines[_i][0]
6218	>e02b		35				                .byte <vdu_routines[_i][0]
6218	>e02c		ae				                .byte <vdu_routines[_i][0]
6218	>e02d		9a				                .byte <vdu_routines[_i][0]
6218	>e02e		4c				                .byte <vdu_routines[_i][0]
6218	>e02f		5b				                .byte <vdu_routines[_i][0]
6218	>e030		b1				                .byte <vdu_routines[_i][0]
6218	>e031		4f				                .byte <vdu_routines[_i][0]
6218	>e032		f6				                .byte <vdu_routines[_i][0]
6218	>e033		14				                .byte <vdu_routines[_i][0]
6218	>e034		28				                .byte <vdu_routines[_i][0]
6218	>e035		13				                .byte <vdu_routines[_i][0]
6218	>e036		39				                .byte <vdu_routines[_i][0]
6218	>e037		64				                .byte <vdu_routines[_i][0]
6218	>e038		2d				                .byte <vdu_routines[_i][0]
6218	>e039		c5				                .byte <vdu_routines[_i][0]
6218	>e03a		19				                .byte <vdu_routines[_i][0]
6218	>e03b		94				                .byte <vdu_routines[_i][0]
6218	>e03c		7c				                .byte <vdu_routines[_i][0]
6218	>e03d		1f				                .byte <vdu_routines[_i][0]
6218	>e03e		9b				                .byte <vdu_routines[_i][0]
6218	>e03f		aa				                .byte <vdu_routines[_i][0]
6218	>e040		35				                .byte <vdu_routines[_i][0]
6218	>e041		a5				                .byte <vdu_routines[_i][0]
6218	>e042		8a				                .byte <vdu_routines[_i][0]
6218	>e043		7c				                .byte <vdu_routines[_i][0]
6218	>e044		82				                .byte <vdu_routines[_i][0]
6218	>e045		2b				                .byte <vdu_routines[_i][0]
6219							                .next

6221							; If bit 7 set: MSB of routine address
6222							;
6223							; If bit 7 clear:
6224							;
6225							; Top 4 bits are bits 8-11 of routine address (bits 12-15 are %1010,
6226							; so address is $C0xx to $C7xx)
6227							;
6228							; Bottom 4 bits are ORed with $f0 and stored in $26a - -ve bytes left
6229							; in VDU queue.
6230	.e046						vduRoutinesMSBTable:
6231							                .for _i=0,_i<len(vdu_routines),_i+=1
6232							                .if vdu_routines[_i][1]==0
6233	>e046		c0				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e047		0f				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e048		c0				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e049		c0				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04a		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04b		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04c		c0				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04d		ed				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04e		c2				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e04f		c2				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e050		c2				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e051		c2				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e052		c4				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e053		c3				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e054		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e055		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e056		c4				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e057		5f				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e058		5e				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e059		6b				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e05a		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e05b		c5				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e05c		7f				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e05d		67				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e05e		78				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e05f		6b				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e060		c6				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e061		c0				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e062		3c				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e063		7c				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e064		c4				                .byte >vdu_routines[_i][0]
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6234							                .else
6235							                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
6236							                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
6237	>e065		4e				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6238							                .endif
6232							                .if vdu_routines[_i][1]==0
6233	>e066		ce				                .byte >vdu_routines[_i][0]
6238							                .endif
6239							                .next

6241							;-------------------------------------------------------------------------
6242							;
6243							; entry:
6244							;
6245							; C=0
6246							;
6247							; A = vdu 23 code
6248							;
6249							; VDU queue = the full 9 bytes of the VDU 23
6250							;
6251	.e067						vdu23EntryPointTable:
6252	>e067		f9 ce				                .word vdu23_0_EntryPoint
6253	>e069		29 cf				                .word vdu23_1_EntryPoint
6254	>e06b		55 cf				                .word vdu23_2_EntryPoint
6255	>e06d		55 cf				                .word vdu23_3_EntryPoint
6256	>e06f		55 cf				                .word vdu23_4_EntryPoint
6257	>e071		55 cf				                .word vdu23_5_EntryPoint
6258	>e073		dd cf				                .word vdu23_6_EntryPoint
6259	>e075		e4 cf				                .word vdu23_7_EntryPoint
6260	>e077		67 d0				                .word vdu23_8_EntryPoint
6261	>e079		0d d1				                .word vdu23_9_EntryPoint
6262	>e07b		0e d1				                .word vdu23_10_EntryPoint
6263	>e07d		6b cf				                .word vdu23_11_EntryPoint
6264	>e07f		94 cf				                .word vdu23_12_EntryPoint
6265	>e081		94 cf				                .word vdu23_13_EntryPoint
6266	>e083		94 cf				                .word vdu23_14_EntryPoint
6267	>e085		94 cf				                .word vdu23_15_EntryPoint
6268	>e087		1c d1				                .word vdu23_16_EntryPoint

6270							;-------------------------------------------------------------------------
6271							;
6272							; entry:
6273							;
6274							; A = plot number
6275							;
6276	.e089						plotEntryPointTable:
6277	>e089		48 db				                .word plotPoint    ;64-71 = Plot point [MasRef E.3-24]
6278	>e08b		6a dc				                .word plotHorizontalLineFill ;72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
6279	>e08d		8b 9e				                .word L9BF7 ;80-87 = Plot triangle [MasRef E.3-25]
6280	>e08f		73 dc				                .word plotHorizontalLineFillRight ;88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
6281	>e091		48 c4				                .word LC448 ;96-103 = Plot rectangle [MasRef E.3-26]
6282	>e093		6a dc				                .word plotHorizontalLineFill ;104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
6283	>e095		37 9e				                .word plotParallelogram ;112-119 = Plot parallelogram [MasRef E.3-27]
6284	>e097		73 dc				                .word plotHorizontalLineFillRight ;120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
6285	>e099		8d 9f				                .word L9CF9 ;128-135 = Flood fill to non-background [MasRef E.3-28]
6286	>e09b		8d 9f				                .word L9CF9 ;136-143 = Flood fill to foreground [MasRef E.3-28]
6287	>e09d		38 9c				                .word L99A4 ;144-151 = Plot circle outline [MasRef E.3-28]
6288	>e09f		d8 9b				                .word L9944 ;152-159 = Plot filled circle [MasRef E.3-29]
6289	>e0a1		2d 9c				                .word L9999 ;160-167 = Plot circular arc [MasRef E.3-29]
6290	>e0a3		c9 9b				                .word L9935 ;168-175 = Plot filled chord segment [MasRef E.3-30]
6291	>e0a5		b7 9b				                .word L9923 ;176-183 = Plot filled sector [MasRef E.3-30]
6292	>e0a7		c4 a4				                .word selectExtROMAndPlotMoveOrCopyRectangle ;184-191 = Move/copy rectangle [MasRef E.3-31]
6293	>e0a9		06 a0				                .word selectExtROMAndPlotEllipseOutline ;192-199 = Plot ellipse outline [MasRef E.3-32]
6294	>e0ab		6d a0				                .word selectExtROMAndPlotEllipseFilled ;200-207 = Plot solid ellipse [MasRef E.3-32]

6296							; Times 40 lookup table, high bytes
6297	.e0ad						multiplyBy40TableHigh:
6298							                .for _i=0,_i<25,_i+=1
6299	>e0ad		00				                .byte >_i*40
6299	>e0ae		00				                .byte >_i*40
6299	>e0af		00				                .byte >_i*40
6299	>e0b0		00				                .byte >_i*40
6299	>e0b1		00				                .byte >_i*40
6299	>e0b2		00				                .byte >_i*40
6299	>e0b3		00				                .byte >_i*40
6299	>e0b4		01				                .byte >_i*40
6299	>e0b5		01				                .byte >_i*40
6299	>e0b6		01				                .byte >_i*40
6299	>e0b7		01				                .byte >_i*40
6299	>e0b8		01				                .byte >_i*40
6299	>e0b9		01				                .byte >_i*40
6299	>e0ba		02				                .byte >_i*40
6299	>e0bb		02				                .byte >_i*40
6299	>e0bc		02				                .byte >_i*40
6299	>e0bd		02				                .byte >_i*40
6299	>e0be		02				                .byte >_i*40
6299	>e0bf		02				                .byte >_i*40
6299	>e0c0		02				                .byte >_i*40
6299	>e0c1		03				                .byte >_i*40
6299	>e0c2		03				                .byte >_i*40
6299	>e0c3		03				                .byte >_i*40
6299	>e0c4		03				                .byte >_i*40
6299	>e0c5		03				                .byte >_i*40
6300							                .next

6302							; Times 40 lookup table, low bytes
6303	.e0c6						multiplyBy40TableLow:
6304							                .for _i=0,_i<25,_i+=1
6305	>e0c6		00				                .byte <_i*40
6305	>e0c7		28				                .byte <_i*40
6305	>e0c8		50				                .byte <_i*40
6305	>e0c9		78				                .byte <_i*40
6305	>e0ca		a0				                .byte <_i*40
6305	>e0cb		c8				                .byte <_i*40
6305	>e0cc		f0				                .byte <_i*40
6305	>e0cd		18				                .byte <_i*40
6305	>e0ce		40				                .byte <_i*40
6305	>e0cf		68				                .byte <_i*40
6305	>e0d0		90				                .byte <_i*40
6305	>e0d1		b8				                .byte <_i*40
6305	>e0d2		e0				                .byte <_i*40
6305	>e0d3		08				                .byte <_i*40
6305	>e0d4		30				                .byte <_i*40
6305	>e0d5		58				                .byte <_i*40
6305	>e0d6		80				                .byte <_i*40
6305	>e0d7		a8				                .byte <_i*40
6305	>e0d8		d0				                .byte <_i*40
6305	>e0d9		f8				                .byte <_i*40
6305	>e0da		20				                .byte <_i*40
6305	>e0db		48				                .byte <_i*40
6305	>e0dc		70				                .byte <_i*40
6305	>e0dd		98				                .byte <_i*40
6305	>e0de		c0				                .byte <_i*40
6306							                .next

6308							; Times 640 lookup table, high bytes
6309	.e0df						multiplyBy640TableHigh:
6310							                .for _i=0,_i<32,_i+=1
6311	>e0df		00				                .byte >_i*640
6311	>e0e0		02				                .byte >_i*640
6311	>e0e1		05				                .byte >_i*640
6311	>e0e2		07				                .byte >_i*640
6311	>e0e3		0a				                .byte >_i*640
6311	>e0e4		0c				                .byte >_i*640
6311	>e0e5		0f				                .byte >_i*640
6311	>e0e6		11				                .byte >_i*640
6311	>e0e7		14				                .byte >_i*640
6311	>e0e8		16				                .byte >_i*640
6311	>e0e9		19				                .byte >_i*640
6311	>e0ea		1b				                .byte >_i*640
6311	>e0eb		1e				                .byte >_i*640
6311	>e0ec		20				                .byte >_i*640
6311	>e0ed		23				                .byte >_i*640
6311	>e0ee		25				                .byte >_i*640
6311	>e0ef		28				                .byte >_i*640
6311	>e0f0		2a				                .byte >_i*640
6311	>e0f1		2d				                .byte >_i*640
6311	>e0f2		2f				                .byte >_i*640
6311	>e0f3		32				                .byte >_i*640
6311	>e0f4		34				                .byte >_i*640
6311	>e0f5		37				                .byte >_i*640
6311	>e0f6		39				                .byte >_i*640
6311	>e0f7		3c				                .byte >_i*640
6311	>e0f8		3e				                .byte >_i*640
6311	>e0f9		41				                .byte >_i*640
6311	>e0fa		43				                .byte >_i*640
6311	>e0fb		46				                .byte >_i*640
6311	>e0fc		48				                .byte >_i*640
6311	>e0fd		4b				                .byte >_i*640
6311	>e0fe		4d				                .byte >_i*640
6312							                .next

6314							;-------------------------------------------------------------------------

6316	.e0ff						modeMaxRow:
6317	>e0ff		1f				                .byte 31                     ;MODE 0 = 32 rows
6318	>e100		1f				                .byte 31                     ;MODE 1 = 32 rows
6319	>e101		1f				                .byte 31                     ;MODE 2 = 32 rows
6320	>e102		18				                .byte 24                     ;MODE 3 = 25 rows
6321	>e103		1f				                .byte 31                     ;MODE 4 = 32 rows
6322	>e104		1f				                .byte 31                     ;MODE 5 = 32 rows
6323	>e105		18				                .byte 24                     ;MODE 6 = 25 rows
6324	>e106		18				                .byte 24                     ;MODE 7 = 25 rows

6326							;-------------------------------------------------------------------------

6328	.e107						modeMaxColumn:
6329	>e107		4f				                .byte 79                     ;MODE 0 = 80 columns
6330	>e108		27				                .byte 39                     ;MODE 1 = 40 columns
6331	>e109		13				                .byte 19                     ;MODE 2 = 20 columns
6332	>e10a		4f				                .byte 79                     ;MODE 3 = 80 columns
6333	>e10b		27				                .byte 39                     ;MODE 4 = 40 columns
6334	>e10c		13				                .byte 19                     ;MODE 5 = 20 columns
6335	>e10d		27				                .byte 39                     ;MODE 6 = 40 columns
6336	>e10e		27				                .byte 39                     ;MODE 7 = 40 columns

6338							;-------------------------------------------------------------------------

6340	.e10f						vcontrolForScreenMODE:
6341	>e10f		9c				                .byte VCONTROL.cursorX___|VCONTROL.crtc2MHz|VCONTROL.shift16MHz ; $9C - MODE 0
6342	>e110		d8				                .byte VCONTROL.cursorXX__|VCONTROL.crtc2MHz|VCONTROL.shift8MHz ; $d8 - MODE 1
6343	>e111		f4				                .byte VCONTROL.cursorXXXX|VCONTROL.crtc2MHz|VCONTROL.shift4MHz ; $F4 - MODE 2
6344	>e112		9c				                .byte VCONTROL.cursorX___|VCONTROL.crtc2MHz|VCONTROL.shift16MHz ; $9C - MODE 3
6345	>e113		88				                .byte VCONTROL.cursorX___|VCONTROL.crtc1MHz|VCONTROL.shift8MHz ; $88 - MODE 4
6346	>e114		c4				                .byte VCONTROL.cursorXX__|VCONTROL.crtc1MHz|VCONTROL.shift4MHz ; $C4 - MODE 5
6347	>e115		88				                .byte VCONTROL.cursorX___|VCONTROL.crtc1MHz|VCONTROL.shift8MHz ; $88 - MODE 6
6348	>e116		4b				                .byte VCONTROL.cursor_X__|VCONTROL.crtc1MHz|VCONTROL.shift8MHz|VCONTROL.isTeletext|VCONTROL.flash ; $4B - MODE 7

6350							;-------------------------------------------------------------------------

6352	.e117						bytesPerCharacterForMODE:
6353	>e117		08				                .byte 8                      ;MODE 0
6354	>e118		10				                .byte 16                     ;MODE 1
6355	>e119		20				                .byte 32                     ;MODE 2
6356	>e11a		08				                .byte 8                      ;MODE 3
6357	>e11b		08				                .byte 8                      ;MODE 4
6358	>e11c		10				                .byte 16                     ;MODE 5
6359	>e11d		08				                .byte 8                      ;MODE 6
6360	.e11e						LE120:
6361	>e11e		01				                .byte %00000001              ;MODE 7
6362	>e11f		ff				                .byte %11111111
6363	>e120		55				                .byte %01010101
6364	>e121		ff				                .byte %11111111
6365	>e122		77				                .byte %01110111
6366	>e123		33				                .byte %00110011
6367	>e124		11				                .byte %00010001

6369							;-------------------------------------------------------------------------

6371	.e125						distanceMasksTable:
6372	>e125		ff				                .byte %11111111
6373	>e126		7f				                .byte %01111111
6374	>e127		3f				                .byte %00111111
6375	>e128		1f				                .byte %00011111
6376	>e129		0f				                .byte %00001111
6377	>e12a		07				                .byte %00000111
6378	>e12b		03				                .byte %00000011
6379	>e12c		01				                .byte %00000001

6381							;-------------------------------------------------------------------------
6382							;
6383							; These graphics tables often overlap. I haven't always bothered
6384							; commenting the MODEs for the MODE-indexed tables, as even those
6385							; sometimes overlap.
6386							;
6387							;------------------------------------------------------------------------

6389							;-------------------------------------------------------------------------
6390							;
6391							; This is 3 tables in one. Use the numberOfLogicalColoursMinusOne VDU
6392							; variable to access it:
6393							; pixelMasks[(numberOfLogicalColoursMinusOne&7)-1+colour&numberOfLogicalColoursMinusOne=
6394							;
6395	.e12d						pixelMasks:
6396	>e12d		aa				                .byte %10101010
6397	>e12e		55				                .byte %01010101

6399	>e12f		88				                .byte %10001000
6400	>e130		44				                .byte %01000100
6401	>e131		22				                .byte %00100010
6402	>e132		11				                .byte %00010001

6404	>e133		80				                .byte %10000000
6405	>e134		40				                .byte %01000000
6406	>e135		20				                .byte %00100000
6407	>e136		10				                .byte %00010000
6408	>e137		08				                .byte %00001000
6409	>e138		04				                .byte %00000100
6410	>e139		02				                .byte %00000010
6411	.e13a						numberOfLogicalColoursMinusOneForMODE:
6412	>e13a		01				                .byte %00000001              ;MODE 0 (also part of pixelMasks)
6413	>e13b		03				                .byte 3                      ;MODE 1
6414	>e13c		0f				                .byte 15                     ;MODE 2
6415	>e13d		01				                .byte 1                      ;MODE 3
6416	>e13e		01				                .byte 1                      ;MODE 4
6417	>e13f		03				                .byte 3                      ;MODE 5
6418	>e140		01				                .byte 1                      ;MODE 6
6419							                ; MODE 7 value (0) is in next table

6421							;-------------------------------------------------------------------------
6422							;
6423							; Overwrite: ZGORA=$ff, ZGEOR=$ff
6424							; OR: ZGORA=value, ZGEOR=$00
6425							; AND: ZGORA=~value, ZGEOR=$00
6426							; EOR: ZGORA=$00, ZGEOR=value
6427							; Invert: ZGORA=$00, ZGEOR=$ff
6428							; Leave: ZGORA=$00, ZGEOR=$ff
6429							;
6430	.e141						zgeorORTable:
6431	>e141		00				                .byte $00
6432	.e142						zgoraORTable:
6433	>e142		ff				                .byte $FF
6434	.e143						zgoraEORTable:
6435	>e143		00				                .byte $00
6436	>e144		00				                .byte $00
6437	>e145		ff				                .byte $FF
6438	.e146						zgeorEORTable:
6439	>e146		ff				                .byte $FF
6440	>e147		ff				                .byte $FF
6441	>e148		ff				                .byte $FF
6442	>e149		00				                .byte $00

6444							;-------------------------------------------------------------------------
6445							;
6446							; Index using logical colour value to get a byte with that colour
6447							; value in every pixel.
6448							;
6449							; This is 3 tables in one. Use the numberOfLogicalColoursMinusOne VDU
6450							; variable to access it:
6451							; solidColoursTable[(numberOfLogicalColoursMinusOne&7)-1+colour&numberOfLogicalColoursMinusOne=
6452							;
6453	.e14a						solidColoursTable:

6455							                ; 1 bpp
6456	>e14a		00				                .byte %00000000
6457	>e14b		ff				                .byte %11111111

6459							                ; 2 bpp
6460	>e14c		00				                .byte %00000000
6461	>e14d		0f				                .byte %00001111
6462	>e14e		f0				                .byte %11110000
6463	>e14f		ff				                .byte %11111111

6465							                ; 4 bpp
6466	>e150		00				                .byte %00000000
6467	>e151		03				                .byte %00000011
6468	>e152		0c				                .byte %00001100
6469	>e153		0f				                .byte %00001111
6470	>e154		30				                .byte %00110000
6471	>e155		33				                .byte %00110011
6472	>e156		3c				                .byte %00111100
6473	>e157		3f				                .byte %00111111
6474	>e158		c0				                .byte %11000000
6475	>e159		c3				                .byte %11000011
6476	>e15a		cc				                .byte %11001100
6477	>e15b		cf				                .byte %11001111
6478	>e15c		f0				                .byte %11110000
6479	>e15d		f3				                .byte %11110011
6480	>e15e		fc				                .byte %11111100
6481	>e15f		ff				                .byte %11111111

6483	.e160						pixelsPerByteMinusOneForMODE:
6484	>e160		07				                .byte 7
6485	>e161		03				                .byte 3
6486	>e162		01				                .byte 1
6487	.e163						LE165:
6488	>e163		00				                .byte 0
6489	>e164		07				                .byte 7
6490	>e165		03				                .byte 3
6491	.e166						screenMODEGroupForMODE:
6492	>e166		00				                .byte 0
6493	>e167		00				                .byte 0
6494	.e168		00		brk #		                brk
6495	.e169		01 02		ora ($02,x)	                ora ($02,x)
6496	>e16b		02				                .byte $02
6497	>e16c		03				                .byte $03
6498							;TSB &0D          :\ E16F= 04 0D       ..
6499	>e16d		04				                .byte $04

6501							;-------------------------------------------------------------------------
6502							;
6503							; Hardware scrolling wraparound size settings for screen mode group.
6504							;
6505							; The values for group 4 (1 KB) are bogus - the Mode 7 addressing
6506							; wraparound is handled differently.
6507							;
6508	.e16e						latchBit5ForScreenMODEGroup:
6509	>e16e		0d				                .byte 5|8                    ;20 KB
6510	>e16f		05				                .byte 5|0                    ;16 KB
6511	>e170		0d				                .byte 5|8                    ;10 KB
6512	>e171		05				                .byte 5|0                    ; 8 KB
6513	.e172						latchBit4ForScreenMODEGroup:
6514	>e172		04				                .byte 4|0                    ;20 KB (also benign value for 1 KB)
6515	>e173		04				                .byte 4|0                    ;16 KB
6516	>e174		0c				                .byte 4|8                    ;10 KB
6517	>e175		0c				                .byte 4|8                    ; 8 KB
6518	>e176		04				                .byte 4|0                    ;(benign value for 1 KB)

6520							;-------------------------------------------------------------------------

6522	.e177						screenSizeHighByteForScreenMODEGroup:
6523	>e177		50				                .byte $50
6524	>e178		40				                .byte $40
6525	>e179		28				                .byte $28
6526	>e17a		20				                .byte $20
6527	>e17b		04				                .byte $04
6528	.e17c						startScreenAddressHighByteForScreenMODEGroup:
6529	>e17c		30				                .byte $30
6530	>e17d		40				                .byte $40
6531	>e17e		58				                .byte $58
6532	>e17f		60				                .byte $60
6533	>e180		7c				                .byte $7c
6534	.e181						crtcRegisterLastIndexForScreenMODEGroup:
6535	>e181		0b				                .byte (crtcRegisterValues20KB-crtcRegisterValues)+$0B
6536	>e182		17				                .byte (crtcRegisterValues16KB-crtcRegisterValues)+$0B
6537	>e183		23				                .byte (crtcRegisterValues10KB-crtcRegisterValues)+$0B
6538	>e184		2f				                .byte (crtcRegisterValues8KB-crtcRegisterValues)+$0B
6539	>e185		3b				                .byte (crtcRegisterValues1KB-crtcRegisterValues)+$0B
6540	.e186						crtcRegisterValues:
6541	.e186						crtcRegisterValues20KB:                   ;MODEs 0/1/2
6542	>e186		7f				                .byte $7F            ;R0 - Horizontal Total
6543	>e187		50				                .byte $50            ;R1 - Horizontal Displayed
6544	>e188		62				                .byte $62            ;R2 - Horizontal Sync
6545	>e189		28				                .byte $28            ;R3 - Sync Width (%vvvvhhhh)
6546	>e18a		26				                .byte $26            ;R4 - Vertical Total
6547	>e18b		00				                .byte $00            ;R5 - Vertical Total Adjust
6548	>e18c		20				                .byte $20            ;R6 - Vertical Displayed
6549	>e18d		22				                .byte $22            ;R7 - Vertical Sync Position
6550	>e18e		01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6551	>e18f		07				                .byte $07               ;R9 - Scan lines per character
6552	>e190		67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6553	>e191		08				                .byte 8                    ;R11 - Cursor End
6554	.e192						crtcRegisterValues16KB:                    ;MODE 3
6555	>e192		7f				                .byte $7F                 ;R0 - Horizontal Total
6556	>e193		50				                .byte $50                 ;R1 - Horizontal Displayed
6557	>e194		62				                .byte $62                 ;R2 - Horizontal Sync
6558	>e195		28				                .byte $28                 ;R3 - Sync Width (%vvvvhhhh)
6559	>e196		1e				                .byte $1e                 ;R4 - Vertical Total
6560	>e197		02				                .byte $02                 ;R5 - Vertical Total Adjust
6561	>e198		19				                .byte $19                 ;R6 - Vertical Displayed
6562	>e199		1b				                .byte $1B                 ;R7 - Vertical Sync Position
6563	>e19a		01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6564	>e19b		09				                .byte $09               ;R9 - Scan lines per character
6565	>e19c		67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6566	>e19d		09				                .byte 9                      ;R11 - Cursor End
6567	.e19e						crtcRegisterValues10KB:                      ;MODEs 4/5
6568	>e19e		3f				                .byte $3f                 ;R0 - Horizontal Total
6569	>e19f		28				                .byte $28                 ;R1 - Horizontal Displayed
6570	>e1a0		31				                .byte $31                 ;R2 - Horizontal Sync
6571	>e1a1		24				                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
6572	>e1a2		26				                .byte $26                 ;R4 - Vertical Total
6573	>e1a3		00				                .byte $00                 ;R5 - Vertical Total Adjust
6574	>e1a4		20				                .byte $20                 ;R6 - Vertical Displayed
6575	>e1a5		22				                .byte $22                 ;R7 - Vertical Sync Position
6576	>e1a6		01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6577	>e1a7		07				                .byte $07               ;R9 - Scan lines per character
6578	>e1a8		67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6579	>e1a9		08				                .byte 8                      ;R11 - Cursor End
6580	.e1aa						crtcRegisterValues8KB:                       ;MODE 6
6581	>e1aa		3f				                .byte $3F                 ;R0 - Horizontal Total
6582	>e1ab		28				                .byte $28                 ;R1 - Horizontal Displayed
6583	>e1ac		31				                .byte $31                 ;R2 - Horizontal Sync
6584	>e1ad		24				                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
6585	>e1ae		1e				                .byte $1e                 ;R4 - Vertical Total
6586	>e1af		02				                .byte $02                 ;R5 - Vertical Total Adjust
6587	>e1b0		19				                .byte $19                 ;R6 - Vertical Displayed
6588	>e1b1		1b				                .byte $1B                 ;R7 - Vertical Sync Position
6589	>e1b2		01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6590	>e1b3		09				                .byte $09               ;R9 - Scan lines per character
6591	>e1b4		67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6592	>e1b5		09				                .byte 9                      ;R11 - Cursor End
6593	.e1b6						crtcRegisterValues1KB:                       ;MODE 7
6594	>e1b6		3f				                .byte $3f                 ;R0 - Horizontal Total
6595	>e1b7		28				                .byte $28                 ;R1 - Horizontal Displayed
6596	>e1b8		33				                .byte $33                 ;R2 - Horizontal Sync
6597	>e1b9		24				                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
6598	>e1ba		1e				                .byte $1e                 ;R4 - Vertical Total
6599	>e1bb		02				                .byte $02                 ;R5 - Vertical Total Adjust
6600	>e1bc		19				                .byte $19                 ;R6 - Vertical Displayed
6601	>e1bd		1b				                .byte $1b                 ;R7 - Vertical Sync Position
6602	>e1be		93				                .byte CRTC.R8.cursorDelay2|CRTC.R8.displayDelay1|CRTC.R8.interlaceSyncAndVideo ;R8 - Interlace/Delay
6603	>e1bf		12				                .byte $12               ;R9 - Scan lines per character
6604	>e1c0		72				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|18 ;R10 - Cursor blink/start
6605	>e1c1		13				                .byte 19                     ;R11 - Cursor End

6607							;-------------------------------------------------------------------------
6608							;
6609							; Default ECF patterns [MasRef E.3-16]
6610							;
6611							; Only half the pattern is stored. Each pattern repeats every 4
6612							; scanlines.
6613							;
6614	.e1c2						defaultECFPatterns:
6615							                ; MODE 4
6616	>e1c2		aa 00 aa 00			                .byte $aa,$00,$aa,$00        ;1 - Dark grey
6617	>e1c6		aa 55 aa 55			                .byte $aa,$55,$aa,$55        ;2 - Grey
6618	>e1ca		ff 55 ff 55			                .byte $ff,$55,$ff,$55        ;3 - Light grey
6619	>e1ce		11 22 44 88			                .byte $11,$22,$44,$88        ;4 - Hatching

6621							                ; MODE 1/5
6622	>e1d2		a5 0f a5 0f			                .byte $a5,$0f,$a5,$0f        ;1 - Red-orange
6623	>e1d6		a5 5a a5 5a			                .byte $a5,$5a,$a5,$5a        ;2 - Orange
6624	>e1da		f0 5a f0 5a			                .byte $f0,$5a,$f0,$5a        ;3 - Yellow-orange
6625	>e1de		f5 fa f5 fa			                .byte $f5,$fa,$f5,$fa        ;4 - Cream

6627							                ; MODE 2
6628	>e1e2		0b 07 0b 07			                .byte $0b,$07,$0b,$07        ;1 - Orange
6629	>e1e6		23 13 23 13			                .byte $23,$13,$23,$13        ;2 - Pink
6630	>e1ea		0e 0d 0e 0d			                .byte $0e,$0d,$0e,$0d        ;3 - Yellow-green
6631	>e1ee		1f 2f 1f 2f			                .byte $1f,$2f,$1f,$2f        ;4 - Cream

6633							                ; MODE 0
6634	>e1f2		cc 00 cc 00			                .byte $cc,$00,$cc,$00        ;0 - Dark grey
6635	>e1f6		cc 33 cc 33			                .byte $cc,$33,$cc,$33        ;1 - Grey
6636	>e1fa		ff 33 ff 33			                .byte $ff,$33,$ff,$33        ;2 - Light grey
6637	>e1fe		03 0c 30 c0			                .byte $03,$0c,$30,$c0        ;4 - Hatching

6639	.e202						LE204:
6640	>e202		01				                .byte $01                    ;---
6641	>e203		01				                .byte $01                    ;--h
6642	>e204		03				                .byte $03                    ;-v-
6643	>e205		03				                .byte $03                    ;-vh
6644	>e206		02				                .byte $02                    ;x--
6645	>e207		00				                .byte $00                    ;x-h
6646	>e208		02				                .byte $02                    ;xv-
6647	>e209		00				                .byte $00                    ;xvh

6649	.e20a						scrollRoutinesTable:
6650	>e20a		5d c9				                .word LC95F
6651	>e20c		69 c9				                .word LC96B
6652	>e20e		5d c9				                .word LC95F
6653	>e210		69 c9				                .word LC96B
6654	>e212		9b c9				                .word LC99D
6655	>e214		9b c9				                .word LC99D
6656	>e216		a2 c9				                .word LC9A4
6657	>e218		a2 c9				                .word LC9A4
6658	>e21a		c1 c9				                .word LC9C3
6659	>e21c		2b ca				                .word LCA2D
6660	>e21e		c1 c9				                .word LC9C3
6661	>e220		2b ca				                .word LCA2D
6662	>e222		ef ca				                .word LCAF1
6663	>e224		ef ca				                .word LCAF1
6664	>e226		f8 ca				                .word LCAFA
6665	>e228		f8 ca				                .word LCAFA

6667							;-------------------------------------------------------------------------
6668							;
6669							; Get address of soft character definition.
6670							;
6671							; entry:
6672							;
6673							; A = character (32-255)
6674							;
6675							; exit:
6676							;
6677							; (ZTEMPC) = address
6678							;
6679	.e22a						getSoftCharacterDefinitionAddress:
6680	.e22a		0a		asl a		                asl a                        ;a bcdefgh0
6681	.e22b		2a		rol a		                rol a                        ;b cdefgh0a
6682	.e22c		2a		rol a		                rol a                        ;c defgh0ab
6683	.e22d		a8		tay		                tay
6684	.e22e		29 03		and #$03	                and #$03                     ;c 000000ab
6685	.e230		2a		rol a		                rol a                        ;0 00000abc
6686	.e231		69 88		adc #$88	                adc #(>andy.softCharacterDefinitions)-1
6687	.e233		85 df		sta $df		                sta ZTEMPC+1
6688	.e235		98		tya		                tya                          ;0 defgh0ab
6689	.e236		29 f8		and #$f8	                and #$F8                     ;0 defgh000
6690	.e238		85 de		sta $de		                sta ZTEMPC+0
6691	.e23a		60		rts		                rts                          ;

6693							;-------------------------------------------------------------------------
6694							;
6695							; OSBYTE 165 (&A5) Read output cursor position [MasRef D.2-50]
6696							;
6697	.e23b						osbyteA5:
6698	.e23b		20 9a f1	jsr $f19a	                jsr withMOSROM
6699	.e23e		24 d0		bit $d0		                bit STATE
6700	.e240		50 0e		bvc $e250	                bvc getTextCursorPositionWithColumn81                    ;taken if cursor editing
6701	.e242		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
6702	.e245		20 50 e2	jsr $e250	                jsr getTextCursorPositionWithColumn81
6703	.e248		da		phx		                phx
6704	.e249		5a		phy		                phy
6705	.e24a		20 ac e2	jsr $e2ac	                jsr exchangeEditCursorPositionAndTextCursorPosition
6706	.e24d		7a		ply		                ply
6707	.e24e		fa		plx		                plx
6708	.e24f		60		rts		                rts

6710							;-------------------------------------------------------------------------
6711							;
6712							; Get text cursor position, taking the column 81 flag into account and
6713							; reporting the X coordinate as N+1 in that case.
6714							;
6715	.e250						getTextCursorPositionWithColumn81:
6716	.e250		20 6b e2	jsr $e26b	                jsr getTextCursorPosition
6717	.e253		2c 6c 03	bit $036c	                bit vduv.column81
6718	.e256		10 01		bpl $e259	                bpl +                       ;taken if not at column 81
6719	.e258		e8		inx		                inx                         ;X=81
6720	.e259						+
6721	.e259		60		rts		                rts

6723							;-------------------------------------------------------------------------

6725	.e25a						LE25C:
6726	.e25a		38		sec		                sec
6727	.e25b		ad 0a 03	lda $030a	                lda vduv.textWindowRight
6728	.e25e		ed 08 03	sbc $0308	                sbc vduv.textWindowLeft
6729	.e261		48		pha		                pha
6730	.e262		a9 00		lda #$00	                lda #$00
6731	.e264		a8		tay		                tay
6732	.e265		80 10		bra $e277	                bra LE279

6734							;-------------------------------------------------------------------------
6735							;
6736							; OSBYTE 134 (&86) Read text cursor position [MasRef D.2-41]
6737							;
6738	.e267						osbyte86:
6739	.e267		24 d0		bit $d0		                bit STATE
6740	.e269		50 d0		bvc $e23b	                bvc osbyteA5       ;taken if not cursor editing
6741	.e26b						getTextCursorPosition:
6742	.e26b		a9 02		lda #$02	                lda #VDUVariables.cursorFlags.invertHorizontal
6743	.e26d		a0 10		ldy #$10	                ldy #VDUVariables.textCursorXPosition-VDUVariables.textWindow
6744	.e26f		a2 00		ldx #$00	                ldx #VDUVariables.textWindowLeft-VDUVariables.textWindow
6745	.e271		20 88 e2	jsr $e288	                jsr getTextWindowRelativePosition
6746	.e274		48		pha		                pha                          ;save X position
6747	.e275		a9 04		lda #$04	                lda #VDUVariables.cursorFlags.invertVertical
6748	.e277						LE279:
6749	.e277		c8		iny		                iny               ;i.e., offset of textCursorYPosition
6750	.e278		a2 03		ldx #$03	                ldx #VDUVariables.textWindowTop-VDUVariables.textWindow
6751	.e27a		20 88 e2	jsr $e288	                jsr getTextWindowRelativePosition
6752	.e27d		aa		tax		                tax                          ;X = Y position
6753	.e27e		a8		tay		                tay                          ;Y = Y position
6754	.e27f		a9 08		lda #$08	                lda #vduv.cursorFlags.swapAxes
6755	.e281		2c 66 03	bit $0366	                bit vduv.cursorFlags
6756	.e284		f0 24		beq $e2aa	                beq plx_rts ;taken if axes unswapped - so X = X position, Y = Y position
6757	.e286		7a		ply		                ply                          ;Y = Y position, X = X position
6758	.e287		60		rts		                rts

6760							;-------------------------------------------------------------------------
6761							;
6762							; Get text window-relative cursor position, taking into account cursor
6763							; flags.
6764							;
6765							; entry:
6766							;
6767							; A = cursorFlags bit for axis of interest - invertHorizontal or invertVertical
6768							;
6769							; X = offset in VDU variables of text window minimum for axis of interest
6770							;
6771							; Y = offset in VDU variables of cursor position for axis of interest
6772							;
6773							; exit:
6774							;
6775							; A = text window-relative coordinate
6776							;
6777	.e288						getTextWindowRelativePosition:
6778	.e288		38		sec		                sec                     ;C=1 ready for the subtraction
6779	.e289		2c 66 03	bit $0366	                bit vduv.cursorFlags ;test cursor flags inversion bit of interest
6780	.e28c		f0 0b		beq $e299	                beq axisNotInverted
6781	.e28e						axisInverted:
6782	.e28e		8a		txa		                txa
6783	.e28f		49 02		eor #$02	                eor #$02                     ;swap min and max
6784	.e291		aa		tax		                tax
6785	.e292		bd 08 03	lda $0308,x	                lda vduv.textWindow,x
6786	.e295		f9 08 03	sbc $0308,y	                sbc vduv.textWindow,y
6787	.e298		60		rts		                rts

6789	.e299						axisNotInverted:
6790	.e299		b9 08 03	lda $0308,y	                lda vduv.textWindow,y
6791	.e29c		fd 08 03	sbc $0308,x	                sbc vduv.textWindow,x
6792	.e29f		60		rts		                rts

6794							;-------------------------------------------------------------------------
6795							;
6796							; Get default bounds for current mode.
6797							;
6798							; exit:
6799							;
6800							; X = max column (19, 39 or 79)
6801							;
6802							; Y = max row (24 or 31)
6803							;
6804							; preserves: A, C
6805							;
6806	.e2a0						getDefaultBoundsForCurrentScreenMODE:
6807	.e2a0		ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
6808	.e2a3		bc 07 e1	ldy $e107,x	                ldy modeMaxColumn,x          ;Y = max column
6809	.e2a6		5a		phy		                phy                          ;save max column
6810	.e2a7		bc ff e0	ldy $e0ff,x	                ldy modeMaxRow,x             ;Y = max row
6811	.e2aa						plx_rts:
6812	.e2aa		fa		plx		                plx                          ;X = max column
6813	.e2ab		60		rts		                rts

6815							;-------------------------------------------------------------------------
6816							;
6817							; Swap edit cursor position and text cursor position.
6818							;
6819	.e2ac						exchangeEditCursorPositionAndTextCursorPosition:
6820	.e2ac		a2 18		ldx #$18	                ldx #VDUVariables.textCursorXPosition
6821	.e2ae		a0 64		ldy #$64	                ldy #VDUVariables.editCursorXPosition

6823							;-------------------------------------------------------------------------
6824							;
6825							; Swap 2 bytes in the VDU variables.
6826							;
6827							; entry:
6828							;
6829							; X = offset of one set of 2 bytes
6830							;
6831							; Y = offset of the other set of 2 bytes
6832							;
6833	.e2b0						exchangeTwoVDUBytes:
6834	.e2b0		a9 02		lda #$02	                lda #$02
6835	.e2b2		80 06		bra $e2ba	                bra exchangeVDUVariables

6837							;-------------------------------------------------------------------------
6838							;
6839							; Swap graphics cursor and old graphics cursor.
6840							;
6841	.e2b4						LE2B6:
6842	.e2b4		a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX
6843	.e2b6						LE2B8:
6844	.e2b6		a0 14		ldy #$14	                ldy #VDUVariables.oldGraphicsCursorPixelsX

6846							;-------------------------------------------------------------------------
6847							;
6848							; Swap 4 bytes in the VDU variables.
6849							;
6850							; entry:
6851							;
6852							; X = offset of one set of 4 bytes
6853							;
6854							; Y = offset of the other set of 4 bytes
6855							;
6856	.e2b8						exchangeFourVDUBytes:
6857	.e2b8		a9 04		lda #$04	                lda #$04

6859							;-------------------------------------------------------------------------
6860							;
6861							; Swap bytes in the VDU variables.
6862							;
6863							; entry:
6864							;
6865							; A = number of bytes to swap
6866							;
6867							; X = offset of one set of bytes
6868							;
6869							; Y = offset of the other set of bytes
6870							;
6871	.e2ba						exchangeVDUVariables:
6872	.e2ba		48		pha		                pha                          ;save count remaining
6873	.e2bb		bd 00 03	lda $0300,x	                lda vduv,x
6874	.e2be		48		pha		                pha
6875	.e2bf		b9 00 03	lda $0300,y	                lda vduv,y
6876	.e2c2		9d 00 03	sta $0300,x	                sta vduv,x
6877	.e2c5		68		pla		                pla
6878	.e2c6		99 00 03	sta $0300,y	                sta vduv,y
6879	.e2c9		e8		inx		                inx
6880	.e2ca		c8		iny		                iny
6881	.e2cb		68		pla		                pla
6882	.e2cc		3a		dec a		                dec a
6883	.e2cd		d0 eb		bne $e2ba	                bne exchangeVDUVariables
6884	.e2cf		60		rts		                rts

6886							;-------------------------------------------------------------------------
6887							;
6888							; Test current VDU4/VDU5 status.
6889							;
6890							; exit:
6891							;
6892							; Z=0 if VDU5 mode
6893	.e2d0						testVDU5State:
6894	.e2d0		a5 d0		lda $d0		                lda STATE
6895	.e2d2		29 20		and #$20	                and #STATE.isVDU5
6896	.e2d4		60		rts		                rts

6898							;-------------------------------------------------------------------------

6900							                .if version>=350
6901	.e2d5						LE2E7:
6902	.e2d5		20 9a f1	jsr $f19a	                jsr withMOSROM
6903	.e2d8		4c e2 e7	jmp $e7e2	                jmp callPrinterDriverWithPrinterBuffer
6904							                .endif

6906							;-------------------------------------------------------------------------

6908							                .if version>=350
6909	.e2db						LE2ED:
6910	.e2db		20 9a f1	jsr $f19a	                jsr withMOSROM
6911	.e2de		4c ae e7	jmp $e7ae	                jmp LE8B9
6912							                .endif

6914							;-------------------------------------------------------------------------

6916							                .if version>=350
6917	.e2e1						LE2F3:
6918	.e2e1		20 9a f1	jsr $f19a	                jsr withMOSROM
6919	.e2e4		6c 26 02	jmp ($0226)	                jmp (VDUV)
6920							                .endif

6922							;-------------------------------------------------------------------------

6924							; Default vector table
6925							; ====================
6926	.e2e7						defaultVectorTable: .block
6927	>e2e7		bd fa				                .word badCommandError        ; USERV=$200
6928	>e2e9		72 e5				                .word defaultBRKHandler      ; BRKV=$202
6929	>e2eb		e1 e5				                .word irq1EntryPoint         ; IRQ1V=$204
6930	>e2ed		ed e5				                .word irq2EntryPoint         ; IRQ2V=$206
6931	>e2ef		18 e7				                .word oscliEntryPoint        ; CLIV=$208
6932	>e2f1		b9 ec				                .word osbyteEntryPoint       ; BYTEV=$20a
6933	>e2f3		2d ed				                .word oswordEntryPoint       ; WORDV=$20c
6934	>e2f5		38 e7				                .word oswrchEntryPoint       ; WRCHV=$20e
6935	>e2f7		d5 e6				                .word osrdchEntryPoint       ; RDCHV=$210
6936	.e2f9						fsVectors: .block
6937	>e2f9		1b ff				                .word E_FILEV                ; FILEV=$212
6938	>e2fb		1e ff				                .word E_ARGSV                ; ARGSV=$214
6939	>e2fd		21 ff				                .word E_BGETV                ; BGETV=$216
6940	>e2ff		24 ff				                .word E_BPUTV                ; BPUTV=$218
6941	>e301		27 ff				                .word E_GBPBV                ; GBPBV=$21a
6942	>e303		2a ff				                .word E_FINDV                ; FINDV=$21c
6943	>e305		2d ff				                .word E_FSCV                 ; FSCV=$21e
6944	.e307						end:
6945							                .bend
6946	>e307		aa ff				                .word rtsFFAA                ; EVENTV=$220
6947	>e309		aa ff				                .word rtsFFAA                ; UPTV=$222
6948	>e30b		aa ff				                .word rtsFFAA                ; NETV=$224
6949	>e30d		aa ff				                .word rtsFFAA                ; VDUV=$226
6950	>e30f		3b f5				                .word keyEntryPoint          ; KEYV=$228
6951	>e311		eb e8				                .word insEntryPoint          ; INSV=$22a
6952	>e313		a0 e8				                .word remEntryPoint          ; REMV=$22c
6953	>e315		23 e8				                .word cnpEntryPoint          ; CNPV=$22e
6954	>e317		aa ff				                .word rtsFFAA                ; IND1V=$230
6955	>e319		aa ff				                .word rtsFFAA                ; IND2V=$232
6956	>e31b		aa ff				                .word rtsFFAA                ; IND3V=$234
6957	.e31d						end:
6958							                .bend

6960							                ; valueFF is a (presumably arbitrary) byte with the
6961							                ; value 255, that's BIT'd in a few places to set the V
6962							                ; flag.
6963	.e31d						defaultMOSVariables:
6964	>e31d		90 01				                .word mosVariables-166       ;mosVariablesAddress
6965	>e31f		9f 0d				                .word extendedVectorSpace    ;extendedVectorSpaceAddress
6966	>e321		a1 02				                .word romInformationTable  ;romInformationTableAddress
6967	>e323		71 f6				                .word keyTranslationTable-16 ;keyboardTranslationTableAddress
6968	>e325		00 03				                .word vduv                   ;vduVariablesAddress
6969	>e327		00				                .byte $00                    ;cfsTimeoutCounter
6970	>e328		00				                .byte $00                    ;inputSource
6971	>e329		ff				                .byte $FF                    ;keyboardSemaphore
6972	>e32a		00				                .byte $00                    ;romPollingSemaphore
6973	>e32b		00				                .byte $00                    ;oshwm
6974	>e32c		01				                .byte $01                    ;rs423InputInterpretationStatus
6975	>e32d		00				                .byte $00                    ;noignoreState
6976	>e32e		00				                .byte $00                    ;cfsRFSFSSwitch
6977	>e32f		00				                .byte $00                    ;vcontrolRegister
6978	>e330		00				                .byte $00                    ;vpaletteRegister
6979	>e331		00				                .byte $00                    ;romActiveAtLastBRK
6980	>e332		ff				                .byte $FF                    ;basicROMNumber
6981							                .if version<500
6982	>e333		04				                .byte $04                    ;currentADCChannel
6983	>e334		04				                .byte $04                    ;maximumADCChannel
6987							                .endif
6988	>e335		00				                .byte $00                    ;adcConversionType
6989	>e336		ff				                .byte $FF                    ;rs423Busy
6990							                .if version==400
6991	>e337		00				                .byte $00                    ;aciaControlRegister
6994							                .endif
6995	>e338		19				                .byte $19                    ;flashCounter
6996	>e339		19				                .byte $19                    ;firstFlashColourDuration
6997	>e33a		19				                .byte $19                    ;secondFlashColourDuration
6998	>e33b		32				                .byte $32                    ;keyboardAutoRepeatDelay
6999	>e33c		08				                .byte $08                    ;keyboardAutoRepeatRate
7000	>e33d		00				                .byte $00                    ;execFileHandle
7001	>e33e		00				                .byte $00                    ;spoolFileHandle
7002	>e33f		00				                .byte $00                    ;breakAndESCAPEEffect
7003	>e340		00				                .byte $00                    ;keyboardStatus
7004	>e341		20				                .byte $20                    ;keyboardStatusByte
7005	>e342		09				                .byte $09                    ;rs423InputBufferMinimumSpace
7006	>e343		00				                .byte $00                    ;rs423Ignore
7007	>e344		00				                .byte $00                    ;rs423Destination
7008	>e345		00				                .byte $00                    ;econetInterceptionStatus
7009	>e346		00				                .byte $00                    ;econetInputInterpretationStatus
7010	>e347		00				                .byte $00                    ;econetOutputInterpretationStatus
7011	>e348		00				                .byte $00                    ;speechSystemByte1
7012	>e349		00				                .byte $00                    ;soundSuppressionStatus
7013	>e34a		03				                .byte $03                    ;bellChannel
7014	>e34b		90				                .byte $90                    ;bellSound
7015	>e34c		64				                .byte $64                    ;bellFrequency
7016	>e34d		06				                .byte $06                    ;bellDuration
7017	>e34e		81				                .byte $81                    ;startupMessageSuppressionStatus
7018	>e34f		00				                .byte $00                    ;softKeyStringLength
7019	>e350		00				                .byte $00                    ;pagedModeCounter
7020	>e351		00				                .byte $00                    ;vduQueueNegativeLength
7021	>e352		09				                .byte $09                    ;tabKeyCode
7022	>e353		1b				                .byte $1B                    ;escapeCharacter
7023	>e354		01				                .byte $01                    ;input192To207Interpretation
7024	>e355		d0				                .byte $D0                    ;input208To223Interpretation
7025	>e356		e0				                .byte $E0                    ;input224To239Interpretation
7026	>e357		f0				                .byte $F0                    ;input240To255Interpretation
7027	>e358		01				                .byte $01                    ;softKeyInterpretation
7028	>e359		80				                .byte $80                    ;shiftSoftKeyInterpretation
7029	>e35a		90				                .byte $90                    ;ctrlSoftKeyInterpretation
7030	>e35b		00				                .byte $00                    ;shiftCtrlSoftKeyInterpretation
7031	>e35c		00				                .byte $00                    ;escapeKeyStatus
7032	>e35d		00				                .byte $00                    ;escapeEffects
7033	>e35e		ff				valueFF:        .byte $FF                    ;userVIAInterruptMask
7034	>e35f		ff				                .byte $FF                    ;rs423InterruptMask
7035	>e360		ff				                .byte $FF                    ;systemVIAInterruptMask
7036	>e361		00				                .byte $00                    ;tubePresence
7037	>e362		00				                .byte $00                    ;speechSystemByte2
7038	>e363		00				                .byte $00                    ;characterDestinationStatus
7039	>e364		00				                .byte editKeysMode.editKeys  ;editKeysMode
7040	>e365		30				                .byte $30                    ;numericKeypadInterpretation
7041	>e366		01				                .byte $01                    ;shadowRAMState
7042	>e367		00				                .byte $00                    ;countryFlag
7043	>e368		00				                .byte $00                    ;userFlag
7044							                .if version==400
7045	>e369		00				                .byte $00                    ;serialULARegister
7048							                .endif
7049	>e36a		05				                .byte initialTimerSwitchState ;timerSwitchState
7050	>e36b		ff				                .byte $FF                    ;softKeyConsistencyFlag
7051							                .if version==400
7052	>e36c		00				                .byte $00                    ;printerDriverType
7055							                .endif
7056	>e36d		0a				                .byte $0a                    ;printerIgnoreChar
7057	>e36e		00				                .byte $00                    ;breakVectorByte0
7058	>e36f		00				                .byte $00                    ;breakVectorByte1
7059	>e370		00				                .byte $00                    ;breakVectorByte2
7060	>e371		00				                .byte $00                    ;vduDriverMemory
7061	>e372		00				                .byte $00                    ;displayMemory
7062	>e373		ff				                .byte $FF                    ;currentLanguageROM

7064							;-------------------------------------------------------------------------
7065							;
7066							; STARTUP
7067							; =======
7068							;
7069	.e374						resetEntryPoint:                ;e364
7070	.e374		a9 40		lda #$40	                lda #$40        ; $40 = RTI
7071	.e376		8d 00 0d	sta $0d00	                sta nmiEntryPoint ; make NMI routine a no-op
7072	.e379		78		sei		                sei
7073	.e37a		a9 53		lda #$53	                lda #$53                 ; ???
7074	.e37c		8d 8e fe	sta $fe8e	                sta LFE8E                ; ???
7075							                .if version==350
7081							                .endif
7082							                .if version==350
7085							                .else
7086	.e37f		20 9d e5	jsr $e59d	                jsr selectTerminalROM ; Page in ROM 15 and continue
7087	.e382		4c 1b 80	jmp $801b	                jmp reset
7088							                .endif

7090							;-------------------------------------------------------------------------

7092							                .if version==350
7097							                .endif

7099							;-------------------------------------------------------------------------

7101							                .if version!=350&&(includeTubeSupport||version>=500)
7102							                .include "isSecondProcessorPresent.s65"

:19	;******  Processing file: src/isSecondProcessorPresent.s65

1							;-------------------------------------------------------------------------
2							;
3							; Check if a coprocessor is attached to the Tube
4							;
5							; exit:
6							;
7							; C=0 = no Tube
8							;
9							; C=1 = Tube
10							;

12							; (Note that this code is always included in MOS 5.xx, even though
13							; there's no second processor support.)

15	.e385						isSecondProcessorPresent:
16							                .if version==350
18							                .endif
19	.e385		a2 01		ldx #$01	                ldx #$01
20	.e387		8e e0 fe	stx $fee0	                stx $fee0;tube.status1
21	.e38a		ad e0 fe	lda $fee0	                lda $fee0;tube.status1
22	.e38d		49 01		eor #$01	                eor #$01
23	.e38f		a2 81		ldx #$81	                ldx #$81
24	.e391		8e e0 fe	stx $fee0	                stx $fee0;tube.status1
25	.e394		2d e0 fe	and $fee0	                and $fee0;tube.status1       ; Cy=0 if no Tube, Cy=1 if Tube
26	.e397		6a		ror a		                ror a
27	.e398		60		rts		                rts


:12	;******  Return to file: src/mos.s65

7103							                .endif

7105							;-------------------------------------------------------------------------
7106							;
7107							;
7108							;
7109							                .if version==350
7112							                .endif

7114	.e399						LE389:
7115	.e399		5a		phy		                phy
7116	.e39a		da		phx		                phx
7117							                .if useTableDrivenConfigure
7120							                .else
7121	.e39b		20 63 e8	jsr $e863	                jsr getROMInsertedFlagRTCAddressAndMask
7122	.e39e		85 fc		sta $fc		                sta TEMPA                    ;save mask
7123	.e3a0		20 9d e5	jsr $e59d	                jsr selectTerminalROM
7124	.e3a3		20 4b 9b	jsr $9b4b	                jsr readRTCByte     ;read inserted flag
7125	.e3a6		98		tya		                tya                          ;A = byte read
7126	.e3a7		25 fc		and $fc		                and TEMPA                    ;do mask
7127							                .endif
7128	.e3a9		c9 01		cmp #$01	                cmp #$01                     ;C set if ROM is inserted
7129	.e3ab		fa		plx		                plx
7130	.e3ac		7a		ply		                ply
7131	.e3ad		4c 8e e5	jmp $e58e	                jmp selectROMX

7133							;-------------------------------------------------------------------------
7134							;
7135							; Scan ROMs and fill in the rom information table.
7136							;
7137							; entry:
7138							;
7139							; X = first ROM to scan
7140							;
7141							                .if version!=350
7142	.e3b0						scanROMs: .proc
7143							                .include "scan_roms.s65"

:13	;******  Processing file: src/scan_roms.s65

1	.e3b0		8a		txa		                txa               ;A = ROM of interest
2	.e3b1		a8		tay		                tay               ;Y = ROM of interest
3							                .if version<500&&version!=350
4	.e3b2		20 99 e3	jsr $e399	                jsr LE389         ;select ROM and check insertion flag
5	.e3b5		90 34		bcc $e3eb	                bcc currentROMInvalid ;taken if ROM not actually inserted
6							                .endif
7	.e3b7		20 07 e4	jsr $e407	                jsr isROMValid
8	.e3ba		90 2f		bcc $e3eb	                bcc currentROMInvalid        ;taken if ROM invalid
9	.e3bc		a6 f4		ldx $f4		                ldx $F4                      ;start from current ROM
10	.e3be		a4 f4		ldy $f4		                ldy $F4                      ;start from current ROM
11	.e3c0						nextOtherROM:
12	.e3c0		c8		iny		                iny                          ;next other ROM
13	.e3c1		c0 10		cpy #$10	                cpy #$10                     ;out of other ROMs?
14	.e3c3		b0 2a		bcs $e3ef	                bcs currentROMValid       ;taken if no more other ROMs
15							                .if version<500&&version!=350
16	.e3c5		20 99 e3	jsr $e399	                jsr LE389   ;select other ROM and check insertion flag
17	.e3c8		90 f6		bcc $e3c0	                bcc nextOtherROM ;taken if other ROM not actually inserted
18							                .endif
19							                .if version==350
23							                .else
24							                ; Start address is $8000-Y, so that there's no need to
25							                ; save Y.
26	.e3ca		98		tya		                tya
27	.e3cb		49 ff		eor #$ff	                eor #$FF
28	.e3cd		85 fa		sta $fa		                sta SEIWKA+0
29	.e3cf		a9 7f		lda #$7f	                lda #$7F
30	.e3d1		85 fb		sta $fb		                sta SEIWKA+1
31							                .endif
32	.e3d3						compareLoop:
33	.e3d3		8c 30 fe	sty $fe30	                sty ROMSEL                   ;select other ROM
34							                .if version==350
36							                .else
37	.e3d6		b1 fa		lda ($fa),y	                lda (SEIWKA),y               ;get byte from other ROM
38							                .endif
39	.e3d8		8e 30 fe	stx $fe30	                stx ROMSEL                   ;select ROM
40							                .if version==350
42							                .else
43	.e3db		d1 fa		cmp ($fa),y	                cmp (SEIWKA),y               ;same as other ROM?
44							                .endif
45	.e3dd		d0 e1		bne $e3c0	                bne nextOtherROM             ;taken if other ROM is good
46	.e3df		e6 fa		inc $fa		                inc SEIWKA+0
47	.e3e1		d0 f0		bne $e3d3	                bne compareLoop
48	.e3e3		e6 fb		inc $fb		                inc SEIWKA+1
49	.e3e5		a5 fb		lda $fb		                lda SEIWKA+1
50							                .if version>=500
55							                .endif
56	.e3e7		c9 84		cmp #$84	                cmp #$84                  ;compare only the first 1 KB
57	.e3e9		90 e8		bcc $e3d3	                bcc compareLoop
58							                ; The first 1 KB of the current ROM matches the first
59							                ; 1 KB of some higher-priority ROM, so the current ROM
60							                ; is invalid.
61							                .if version>=500||version==350
64							                .endif

66	.e3eb						currentROMInvalid:
67	.e3eb		a6 f4		ldx $f4		                ldx $F4
68	.e3ed		80 0d		bra $e3fc	                bra nextROM

70	.e3ef						currentROMValid:
71							                .if version>=500||version==350
80							                .endif
81	.e3ef		ad 06 80	lda $8006	                lda $8006
82	.e3f2		9d a1 02	sta $02a1,x	                sta romInformationTable,x
83	.e3f5		29 8f		and #$8f	                and #$8F
84	.e3f7		d0 03		bne $e3fc	                bne nextROM       ;taken if any mandatory bits are set

86							                ; A bogus ROM type means this ROM is the BASIC ROM.
87							                .if version>=500&&version!=350
90							                .endif

92	.e3f9		8e 4b 02	stx $024b	                stx basicROMNumber

94	.e3fc						nextROM:
95	.e3fc		e8		inx		                inx
96	.e3fd		e0 10		cpx #$10	                cpx #$10
97	.e3ff		90 af		bcc $e3b0	                bcc scanROMs
98	.e401		20 9d e5	jsr $e59d	                jsr selectTerminalROM


:12	;******  Return to file: src/mos.s65

7144	.e404		4c fa 81	jmp $81fa	                jmp romsScanned     ;not sure why not RTS.
7145							                .endproc
7146							                .endif

7148							;-------------------------------------------------------------------------
7149							;
7150							; Checks a ROM is valid - i.e., has a valid-looking copyright string.
7151							;
7152							; Entry:
7153							;
7154							; X = ROM to check
7155							;
7156							; Exit:
7157							;
7158							; C=0 if ROM invalid; C=1 if ROM valid
7159							;
7160							; ROM of interest is selected
7161							;
7162	.e407						isROMValid: .proc ;e3f7
7163	.e407		20 8e e5	jsr $e58e	                jsr selectROMX
7164	.e40a		a2 03		ldx #$03	                ldx #$03
7165	.e40c		ac 07 80	ldy $8007	                ldy $8007       ; fetch ROM copyright offset pointer
7166	.e40f		18		clc		                clc             ; assume no match
7167	.e410						-
7168	.e410		b9 00 80	lda $8000,y	                lda $8000,y     ; fetch possible ROM copyright char
7169	.e413		5d 20 e5	eor $e520,x	                eor sidewaysROMCopyrightPrefix,x     ; Z=1 if it matches "\x0(C)"
7170	.e416		d0 05		bne $e41d	                bne +           ; branch taken if no match
7171	.e418		c8		iny		                iny             ; next copyright byte
7172	.e419		ca		dex		                dex             ; count 4 chars
7173	.e41a		10 f4		bpl $e410	                bpl -
7174	.e41c		38		sec		                sec             ; C=1 means a match
7175	.e41d						+
7176	.e41d		60		rts		                rts
7177							                .pend

7179							;-------------------------------------------------------------------------

7181							; End of STARTUP code
7182							; ===================
7183	.e41e						LE40E:
7184	.e41e		38		sec		                sec                      ; Call Break Intercept Vector
7185	.e41f		20 38 f1	jsr $f138	                jsr osbyte247EntryPoint
7186	.e422		a2 27		ldx #$27	                ldx #romServiceCallInformReset
7187	.e424		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
7188	.e427		ac 56 02	ldy $0256	                ldy execFileHandle ; Get Exec handle, skip past if closed
7189	.e42a		f0 08		beq $e434	                beq LE424
7190	.e42c		9c 56 02	stz $0256	                stz execFileHandle           ; Clear Exec handle
7191	.e42f		a9 00		lda #$00	                lda #$00                     ; Close Exec channel
7192	.e431		20 ce ff	jsr $ffce	                jsr OSFIND
7193	.e434						LE424:
7194	.e434		38		sec		                sec                          ;
7195	.e435		6e 00 df	ror $df00	                ror hazel.currentFS
7196	.e438		ad 8d 02	lda $028d	                lda lastBREAKType            ; Soft Break
7197	.e43b		f0 04		beq $e441	                beq LE431
7198	.e43d		38		sec		                sec                          ;
7199	.e43e		6e 02 df	ror $df02	                ror hazel.libFS
7200	.e441						LE431:
7201	.e441		20 44 ec	jsr $ec44	                jsr LEE64                    ; Set default ROMFS/TAPEFS settings
7202	.e444		20 1f f0	jsr $f01f	                jsr osbyte76                    ; Test Shift and Ctrl keys
7203							                .if version==350
7205							                .else
7206	.e447		4a		lsr a		                lsr a                        ; Move SHIFT status from b7 to b3
7207	.e448		4a		lsr a		                lsr a
7208	.e449		4a		lsr a		                lsr a
7209	.e44a		4a		lsr a		                lsr a
7210							                .endif
7211	.e44b		4d 8f 02	eor $028f	                eor startupOptions ; Toggle with OSBYTE 255 boot status
7212	.e44e		29 08		and #$08	                and #$08
7213	.e450		a8		tay		                tay
7214	.e451		ae 03 df	ldx $df03	                ldx hazel.currentFSROM
7215	.e454		ad 8d 02	lda $028d	                lda lastBREAKType ; Soft Break, use current filing system
7216	.e457		f0 0b		beq $e464	                beq LE454
7217	.e459		20 9d e5	jsr $e59d	                jsr selectTerminalROM
7218							                .if useTableDrivenConfigure
7221							                .else
7222	.e45c		5a		phy		                phy
7223	.e45d		20 38 91	jsr $9138	                jsr readDefaultROMs
7224	.e460		29 0f		and #$0f	                and #$0F                     ;get default FS ROM
7225	.e462		7a		ply		                ply
7226							                .endif

7228	.e463		aa		tax		                tax
7229	.e464						LE454:
7230	.e464		3c a1 02	bit $02a1,x	                bit romInformationTable,x
7231	.e467		10 1f		bpl $e488	                bpl LE478
7232	.e469		20 8e e5	jsr $e58e	                jsr selectROMX
7233	.e46c		e0 0f		cpx #$0f	                cpx #terminalROM
7234	.e46e		d0 0c		bne $e47c	                bne LE46C
7235	.e470		20 ff f6	jsr $f6ff	                jsr osbyte7A
7236	.e473		e8		inx		                inx
7237	.e474		f0 19		beq $e48f	                beq LE47F
7238	.e476		e0 63		cpx #$63	                cpx #$63
7239	.e478		f0 15		beq $e48f	                beq LE47F
7240	.e47a		80 0c		bra $e488	                bra LE478

7242	.e47c						LE46C:
7243	.e47c		a9 03		lda #$03	                lda #romServiceCallAutoBoot  ; Filing System selection
7244	.e47e		20 03 80	jsr $8003	                jsr $8003
7245	.e481		aa		tax		                tax
7246	.e482		20 9d e5	jsr $e59d	                jsr selectTerminalROM
7247	.e485		8a		txa		                txa
7248	.e486		f0 28		beq $e4b0	                beq LE4A3
7249	.e488						LE478:
7250	.e488		a2 03		ldx #$03	                ldx #romServiceCallAutoBoot
7251	.e48a		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
7252	.e48d		f0 21		beq $e4b0	                beq LE4A3
7253	.e48f						LE47F:
7254	.e48f		98		tya		                tya
7255	.e490		d0 17		bne $e4a9	                bne LE499
7256	.e492		a9 8d		lda #$8d	                lda #$8D
7257	.e494		20 99 eb	jsr $eb99	                jsr osbyte8C8D
7258	.e497		a2 f7		ldx #$f7	                ldx #<starRunBOOT
7259	.e499		a0 f1		ldy #$f1	                ldy #>starRunBOOT
7260	.e49b		ce 67 02	dec $0267	                dec startupMessageSuppressionStatus
7261	.e49e		20 f7 ff	jsr $fff7	                jsr OSCLI
7262	.e4a1		ee 67 02	inc $0267	                inc startupMessageSuppressionStatus
7263	.e4a4		80 0a		bra $e4b0	                bra LE4A3

7265							;-------------------------------------------------------------------------

7267	.e4a6						LE496:
7268	.e4a6		ee 67 02	inc $0267	                inc startupMessageSuppressionStatus ;set bit 0
7269	.e4a9						LE499:
7270	.e4a9		38		sec		                sec
7271	.e4aa		6e 00 df	ror $df00	                ror hazel.currentFS
7272							                .if version<400
7276							                .elsif version<500
7277	.e4ad		20 c5 eb	jsr $ebc5	                jsr selectROMOrTAPEByOSBYTE
7281							                .endif
7282	.e4b0						LE4A3:
7283	.e4b0		a9 05		lda #$05	                lda #$05                     ;
7284	.e4b2		ae 85 02	ldx $0285	                ldx printerDriverType        ; *FX5,<current printer>
7285	.e4b5		20 b9 ec	jsr $ecb9	                jsr osbyteEntryPoint
7286	.e4b8		ad 8d 02	lda $028d	                lda lastBREAKType ; If not Soft Break, select default language
7287	.e4bb		d0 0b		bne $e4c8	                bne LE4BB
7288	.e4bd		ae 8c 02	ldx $028c	                ldx currentLanguageROM      ; Get current language ROM
7289							                .if version==350&&!finmos329
7293							                .else
7294	.e4c0		e0 10		cpx #$10	                cpx #$10                     ; <16, normal ROM number, use it
7295							                .endif
7296	.e4c2		90 0b		bcc $e4cf	                bcc LE4C2
7297							                .if version==350&&!finmos329
7299							                .else
7300	.e4c4		e0 1f		cpx #$1f	                cpx #$10+terminalROM ; 16+UTILS ROM, re-enter Supervisor or Tube CLI
7301							                .endif
7302	.e4c6		f0 4e		beq $e516	                beq LE509
7303	.e4c8						LE4BB:
7304	.e4c8		20 9d e5	jsr $e59d	                jsr selectTerminalROM     ; Page in ROM 15 - UTILS ROM
7305							                .if useTableDrivenConfigure
7308							                .else
7309	.e4cb		20 30 91	jsr $9130	                jsr readDefaultLanguageROM        ; Read configured LANG
7310							                .endif
7311	.e4ce		aa		tax		                tax
7312	.e4cf						LE4C2:
7313	.e4cf		18		clc		                clc

7315							;-------------------------------------------------------------------------
7316							;
7317							; OSBYTE 142 (&8E) Enter language ROM [MasRef D.2-44]
7318							;
7319	.e4d0						osbyte8E:
7320							                .if version==350
7325							                .endif
7326	.e4d0		3c a1 02	bit $02a1,x	                bit romInformationTable,x ; b6=0, error Not a language
7327							                .if version==350
7329							                .endif
7330	.e4d3		50 4e		bvc $e523	                bvc thisIsNotALanguageError
7331	.e4d5		08		php		                php
7332	.e4d6		90 16		bcc $e4ee	                bcc LE4E1 ;taken if not OSBYTE 142 - so skip ROM check
7333	.e4d8		20 8e e5	jsr $e58e	                jsr selectROMX
7334	.e4db		ad 06 80	lda $8006	                lda sidewaysROMType
7335	.e4de		29 0d		and #$0d	                and #%00001101
7336	.e4e0		f0 05		beq $e4e7	                beq is6502ROM ;taken if low nybble is 0 (6502 BASIC) or 2 (other 6502 ROM)
7337							                .if includeTubeSupport
7338	.e4e2		2c 7a 02	bit $027a	                bit tubePresence
7341							                .endif
7342	.e4e5		10 54		bpl $e53b	                bpl iCannotRunThisCodeError  ;taken if no Tube - assume impossible to run
7343	.e4e7						is6502ROM:
7344	.e4e7		da		phx		                phx                          ;save ROM slot
7345	.e4e8		a2 2a		ldx #$2a	                ldx #romServiceCallLanguageChange
7346	.e4ea		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
7347	.e4ed		fa		plx		                plx                          ;restore ROM slot
7348	.e4ee						LE4E1:
7349	.e4ee		8e 8c 02	stx $028c	                stx currentLanguageROM
7350	.e4f1		20 8e e5	jsr $e58e	                jsr selectROMX
7351	.e4f4		a9 80		lda #$80	                lda #>sidewaysROMName
7352	.e4f6		a0 08		ldy #$08	                ldy #(<sidewaysROMName)-1
7353	.e4f8		20 bc e6	jsr $e6bc	                jsr print0TerminatedString
7354	.e4fb		84 fd		sty $fd		                sty errPtr+0
7355	.e4fd		20 e7 ff	jsr $ffe7	                jsr OSNEWL
7356	.e500		20 e7 ff	jsr $ffe7	                jsr OSNEWL
7357	.e503		28		plp		                plp
7358							                .if includeTubeSupport
7359	.e504		a9 01		lda #$01	                lda #$01               ; A=1 on default language entry
7360	.e506		2c 7a 02	bit $027a	                bit tubePresence
7361	.e509		30 12		bmi $e51d	                bmi copyLanguageOverTube     ;taken if Tube is present
7362							                .endif
7363	.e50b		ad 06 80	lda $8006	                lda sidewaysROMType
7364	.e50e		29 0d		and #$0d	                and #%00001101
7365	.e510		d0 29		bne $e53b	                bne iCannotRunThisCodeError ;taken if low nybble isn't 0 (6502 BASIC) or 2 (other 6502 ROM)
7366	.e512		1a		inc a		                inc a                   ;A=1 on default language entry
7367	.e513		4c 00 80	jmp $8000	                jmp sidewaysROMLanguageEntry

7369	.e516						LE509:
7370	.e516		a9 00		lda #$00	                lda #$00
7371							                .if includeTubeSupport
7372	.e518		2c 7a 02	bit $027a	                bit tubePresence
7373	.e51b		10 69		bpl $e586	                bpl startCommandLineUI
7374	.e51d						copyLanguageOverTube:
7375	.e51d		4c 00 04	jmp $0400	                jmp tubeHost.copyLanguage
7378							                .endif

7380							;-------------------------------------------------------------------------

7382	.e520						sidewaysROMCopyrightPrefix: .block
7383	>e520		29 43 28			                .text ")C("
7384	.e523						end:
7385							                .endblock

7387							;-------------------------------------------------------------------------

7389	.e523						thisIsNotALanguageError:
7390	.e523		00		brk #		                brk
7391	>e524		00 54 68 69 73 20 69 73		                .text 0,"This is not a language"
	>e52c		20 6e 6f 74 20 61 20 6c 61 6e 67 75 61 67 65

7393							;-------------------------------------------------------------------------

7395	.e53b						iCannotRunThisCodeError:
7396	.e53b		00		brk #		                brk
7397	>e53c		00 49 20 63 61 6e 6e 6f		                .text 0,"I cannot run this code",0
	>e544		74 20 72 75 6e 20 74 68 69 73 20 63 6f 64 65 00

7399							;-------------------------------------------------------------------------
7400							;
7401							; OSBYTE 164 (&A4) Check processor type [MasRef D.2-50]
7402							;
7403	.e554						osbyteA4:
7404	.e554		a2 03		ldx #$03	                ldx #sidewaysROMCopyrightPrefix.end-sidewaysROMCopyrightPrefix
7405	.e556		a0 07		ldy #$07	                ldy #<sidewaysROMCopyrightOffset
7406	.e558		b1 f0		lda ($f0),y	                lda (originalX),y
7407	.e55a		a8		tay		                tay
7408	.e55b						-
7409	.e55b		b1 f0		lda ($f0),y	                lda (originalX),y
7410	.e55d		dd 20 e5	cmp $e520,x	                cmp sidewaysROMCopyrightPrefix,x
7411	.e560		d0 0f		bne $e571	                bne rtsE564 ;taken if (C) not found - must be OK, if it's not a ROM?
7412	.e562		c8		iny		                iny
7413	.e563		ca		dex		                dex
7414	.e564		10 f5		bpl $e55b	                bpl -
7415	.e566		a0 06		ldy #$06	                ldy #<sidewaysROMType
7416	.e568		b1 f0		lda ($f0),y	                lda (originalX),y
7417	.e56a		0a		asl a		                asl a
7418	.e56b		10 b6		bpl $e523	                bpl thisIsNotALanguageError ;taken if no language entry point
7419	.e56d		29 1a		and #$1a	                and #%00001101<<1
7420	.e56f		d0 ca		bne $e53b	                bne iCannotRunThisCodeError ;taken if low nybble wasn't 0 (6502 BASIC) or 2 (other 6502 ROM)
7421	.e571						rtsE564:
7422	.e571		60		rts		                rts

7424							;-------------------------------------------------------------------------

7426							                .if version==350
7433							                .endif

7435							;-------------------------------------------------------------------------

7437							                .if version==350
7443							                .endif

7445							;-------------------------------------------------------------------------

7447	.e572						defaultBRKHandler:
7448	.e572		a0 00		ldy #$00	                ldy #$00
7449	.e574		20 c0 e6	jsr $e6c0	                jsr printBRKMessage
7450	.e577		20 e7 ff	jsr $ffe7	                jsr OSNEWL
7451	.e57a		ad 67 02	lda $0267	                lda startupMessageSuppressionStatus
7452	.e57d		6a		ror a		                ror a
7453	.e57e		b0 06		bcs $e586	                bcs startCommandLineUI                   ;taken if bit 0 was set
7454	.e580		20 e7 ff	jsr $ffe7	                jsr OSNEWL
7455	.e583		4c a6 e4	jmp $e4a6	                jmp LE496

7457							;-------------------------------------------------------------------------

7459	.e586						startCommandLineUI:
7460	.e586		20 9d e5	jsr $e59d	                jsr selectTerminalROM
7461	.e589		4c 76 86	jmp $8676	                jmp commandLineUI

7463							;-------------------------------------------------------------------------
7464							;
7465							; Select paged ROM bank 15 - TERMINAL - with ANDY paged in,
7466							;
7467							; Preserves A/Y
7468	.e58c						selectTerminalROMAndANDY:   ;e57f
7469	.e58c		a2 8f		ldx #$8f	                ldx #$80|terminalROM
7470							                ; fall through into selectROMX

7472							;-------------------------------------------------------------------------
7473							;-------------------------------------------------------------------------
7474							;
7475							; Select paged ROM bank.
7476							;
7477							; Entry:
7478							;
7479							; X = bank to select.
7480							;
7481							; Preserves A/X/Y/P
7482	.e58e						selectROMX:   ;e581
7483	.e58e		86 f4		stx $f4		                stx $F4
7484	.e590		8e 30 fe	stx $fe30	                stx ROMSEL
7485	.e593		60		rts		                rts

7487							;-------------------------------------------------------------------------
7488							;
7489	.e594						isROMValidThenSelectTerminalROM:
7490	.e594		5a		phy		                phy
7491	.e595		20 07 e4	jsr $e407	                jsr isROMValid
7492	.e598		20 9d e5	jsr $e59d	                jsr selectTerminalROM
7493	.e59b		7a		ply		                ply
7494	.e59c		60		rts		                rts

7496							;-------------------------------------------------------------------------
7497							;
7498							; Select paged ROM bank 15 -
7499							;
7500							; Preserves X/Y
7501	.e59d						selectTerminalROM:            ;e590
7502	.e59d		a9 0f		lda #$0f	                lda #terminalROM
7503							                ; fall through into selectROMA

7505							;-------------------------------------------------------------------------
7506							;
7507							; Select paged ROM bank.
7508							;
7509							; A = bank to select.
7510							;
7511							; Preserves A/X/Y/P
7512	.e59f						selectROMA:                   ;e592
7513	.e59f		85 f4		sta $f4		                sta $F4         ;update ROMSEL copy
7514	.e5a1		8d 30 fe	sta $fe30	                sta ROMSEL
7515	.e5a4		60		rts		                rts

7517							;-------------------------------------------------------------------------
7518							;
7519							; Select paged ROM bank 15 - TERMINAL - with ANDY paged in,
7520							;
7521							; Preserves A/X/Y

7523	.e5a5						selectTerminalROMAndANDY2:
7524	.e5a5		da		phx		                phx
7525	.e5a6		20 8c e5	jsr $e58c	                jsr selectTerminalROMAndANDY
7526	.e5a9		fa		plx		                plx
7527	.e5aa		60		rts		                rts

7529							;-------------------------------------------------------------------------

7531	.e5ab						irqEntryPoint:
7532	.e5ab		85 fc		sta $fc		                sta TEMPA
7533	.e5ad		68		pla		                pla                          ;restore P
7534	.e5ae		48		pha		                pha                          ;save P
7535	.e5af		29 10		and #$10	                and #$10
7536	.e5b1		d0 03		bne $e5b6	                bne brkEntryPoint
7537	.e5b3		6c 04 02	jmp ($0204)	                jmp (IRQ1V)

7539	.e5b6						brkEntryPoint:
7540	.e5b6		da		phx		                phx
7541	.e5b7		ba		tsx		                tsx
7542	.e5b8		bd 03 01	lda $0103,x	                lda $0103,x                  ;get BRK address+1 LSB
7543	.e5bb		d8		cld		                cld                          ;
7544	.e5bc		38		sec		                sec                          ;
7545	.e5bd		e9 01		sbc #$01	                sbc #$01                     ;get BRK address LSB
7546	.e5bf		85 fd		sta $fd		                sta errPtr+0
7547	.e5c1		bd 04 01	lda $0104,x	                lda $0104,x                  ;get BRK address+1 MSB
7548	.e5c4		e9 00		sbc #$00	                sbc #$00                     ;get BRK address MSB
7549	.e5c6		85 fe		sta $fe		                sta errPtr+1
7550	.e5c8		a5 f4		lda $f4		                lda $F4
7551	.e5ca		8d 4a 02	sta $024a	                sta romActiveAtLastBRK
7552	.e5cd		86 f0		stx $f0		                stx originalX
7553	.e5cf		a2 06		ldx #$06	                ldx #romServiceCallBreakInstruction
7554	.e5d1		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
7555	.e5d4		ae 8c 02	ldx $028c	                ldx currentLanguageROM
7556	.e5d7		20 8e e5	jsr $e58e	                jsr selectROMX
7557	.e5da		fa		plx		                plx
7558	.e5db		a5 fc		lda $fc		                lda TEMPA
7559	.e5dd		58		cli		                cli
7560	.e5de		6c 02 02	jmp ($0202)	                jmp (BRKV)

7562							;-------------------------------------------------------------------------

7564							                .if version!=400
7590							                .endif

7592							;-------------------------------------------------------------------------

7594	.e5e1						irq1EntryPoint:
7595	.e5e1		a5 fc		lda $fc		                lda TEMPA
7596	.e5e3		48		pha		                pha
7597	.e5e4		da		phx		                phx
7598	.e5e5		5a		phy		                phy
7599							                .if version!=400
7601							                .endif
7602	.e5e6		20 00 e6	jsr $e600	                jsr irq1Handler
7603	.e5e9		7a		ply		                ply
7604	.e5ea		fa		plx		                plx
7605	.e5eb		68		pla		                pla
7606	.e5ec		40		rti		                rti

7608							;-------------------------------------------------------------------------

7610	.e5ed						irq2EntryPoint:
7611	.e5ed		a5 fc		lda $fc		                lda TEMPA
7612	.e5ef		40		rti		                rti

7614							;-------------------------------------------------------------------------

7616							                .if version==400
7617	.e5f0						rtsE64D:
7618	.e5f0		60		rts		                rts
7678							                .endif

7680							;-------------------------------------------------------------------------

7682	.e5f1						handleUnrecogisedInterrupt:
7683	.e5f1		a2 05		ldx #$05	                ldx #romServiceCallUnrecognisedInterrupt
7684	.e5f3		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
7685	.e5f6		f0 f8		beq $e5f0	                beq rtsE64D                  ;taken if handled

7687							                ; Pass unrecognised, unhandled interrupts to IRQ2V.
7688	.e5f8		68		pla		                pla
7689	.e5f9		68		pla		                pla
7690	.e5fa		7a		ply		                ply
7691	.e5fb		fa		plx		                plx
7692	.e5fc		68		pla		                pla
7693							                .if version==350
7695							                .endif
7696	.e5fd		6c 06 02	jmp ($0206)	                jmp (IRQ2V)

7698							;-------------------------------------------------------------------------

7700							                .if version==400
7701	.e600						irq1Handler:
7704							                .endif
7705	.e600		ad 4d fe	lda $fe4d	                lda systemVIA.ifr
7706							                .if version==400
7707	.e603		10 ec		bpl $e5f1	                bpl handleUnrecogisedInterrupt
7710							                .endif
7711	.e605		2d 79 02	and $0279	                and systemVIAInterruptMask
7712	.e608		2d 4e fe	and $fe4e	                and systemVIA.ier
7713	.e60b		89 02		bit #$02	                bit #VIA.irq.ca1
7714	.e60d		f0 2b		beq $e63a	                beq checkForSystemVIAT1Interrupt

7716							                ; Handle CA1 interrupt - CRTC vsync.

7718	.e60f		ce 40 02	dec $0240	                dec cfsTimeoutCounter
7719							                .if version!=400
7724							                .endif
7725	.e612		ad 51 02	lda $0251	                lda flashCounter
7726	.e615		f0 1a		beq $e631	                beq flashDone                    ;taken if no flash
7727	.e617		ce 51 02	dec $0251	                dec flashCounter             ;count down
7728	.e61a		d0 15		bne $e631	                bne flashDone
7729	.e61c		ae 52 02	ldx $0252	                ldx firstFlashColourDuration ;assume first flash colour is next
7730	.e61f		ad 48 02	lda $0248	                lda vcontrolRegister
7731	.e622		4a		lsr a		                lsr a                        ;C=flash bit
7732	.e623		90 03		bcc $e628	                bcc +                        ;taken if first flash colour is next
7733	.e625		ae 53 02	ldx $0253	                ldx secondFlashColourDuration ;actually, second flash colour is next
7734	.e628						+
7735	.e628		2a		rol a		                rol a                        ;reinstate old register value
7736	.e629		49 01		eor #$01	                eor #VCONTROL.flash          ;toggle flash bit
7737	.e62b		20 3f f0	jsr $f03f	                jsr setVCONTROL
7738	.e62e		8e 51 02	stx $0251	                stx flashCounter
7739	.e631						flashDone:
7740	.e631		a0 04		ldy #$04	                ldy #eventStartOfVerticalSync
7741	.e633		20 d0 e8	jsr $e8d0	                jsr eventEntryPoint
7742	.e636		a9 02		lda #$02	                lda #VIA.irq.ca1
7743							                .if version==400
7744	.e638		80 79		bra $e6b3	                bra staSystemVIAIFR
7747							                .endif

7749							                .if version!=400
7766							                .endif

7768	.e63a						checkForSystemVIAT1Interrupt:
7769	.e63a		89 40		bit #$40	                bit #VIA.irq.t1
7770							                .if version<400
7772							                .else
7773	.e63c		f0 6c		beq $e6aa	                beq checkForSystemVIACA2Interrupt
7774							                .endif

7776							                ; Handle T1 interrupt - 100 Hz timer.

7778	.e63e		a9 40		lda #$40	                lda #VIA.irq.t1
7779	.e640		8d 4d fe	sta $fe4d	                sta systemVIA.ifr            ;acknowledge T1 interrupt
7780	.e643		ad 83 02	lda $0283	                lda timerSwitchState
7781	.e646		aa		tax		                tax                          ;X=old timerSwitchState
7782	.e647		49 0f		eor #$0f	                eor #$0F
7783	.e649		48		pha		                pha                          ;save new timerSwitchState
7784	.e64a		a8		tay		                tay                          ;Y=new timerSwitchState
7785	.e64b		38		sec		                sec                          ;C=1 - increment
7786	.e64c						updateTIMELoop:
7787	.e64c		bd 91 02	lda $0291,x	                lda timer0-1,x
7788	.e64f		69 00		adc #$00	                adc #$00
7789	.e651		99 91 02	sta $0291,y	                sta timer0-1,y

7791							                ; one of X or Y will get to 0 to indicate the end of
7792							                ; the loop.
7793	.e654		ca		dex		                dex
7794	.e655		f0 03		beq $e65a	                beq updateTIMEDone
7795	.e657		88		dey		                dey
7796	.e658		d0 f2		bne $e64c	                bne updateTIMELoop
7797	.e65a						updateTIMEDone:
7798	.e65a		68		pla		                pla                          ;restore new timerSwitchState
7799	.e65b		8d 83 02	sta $0283	                sta timerSwitchState
7800	.e65e		a2 05		ldx #$05	                ldx #$05
7801	.e660						incrementIntervalTimer:
7802	.e660		fe 9b 02	inc $029b,x	                inc intervalTimer-1,x
7803	.e663		d0 08		bne $e66d	                bne intervalTimerDone
7804	.e665		ca		dex		                dex
7805	.e666		d0 f8		bne $e660	                bne incrementIntervalTimer
7806	.e668		a0 05		ldy #$05	                ldy #eventIntervalTimerCrossingZero
7807	.e66a		20 d0 e8	jsr $e8d0	                jsr eventEntryPoint
7808	.e66d						intervalTimerDone:
7809	.e66d		ad b1 02	lda $02b1	                lda inkeyTimeoutCounter+0
7810	.e670		d0 08		bne $e67a	                bne LE715
7811	.e672		ad b2 02	lda $02b2	                lda inkeyTimeoutCounter+1
7812	.e675		f0 06		beq $e67d	                beq LE718
7813	.e677		ce b2 02	dec $02b2	                dec inkeyTimeoutCounter+1
7814	.e67a						LE715:
7815	.e67a		ce b1 02	dec $02b1	                dec inkeyTimeoutCounter+0
7816	.e67d						LE718:
7817	.e67d		2c cd 02	bit $02cd	                bit previousKeyPressedWhenReadingOSBYTE
7818	.e680		10 0b		bpl $e68d	                bpl LE728
7819	.e682		ee cd 02	inc $02cd	                inc previousKeyPressedWhenReadingOSBYTE
7820	.e685		58		cli		                cli
7821							                .if version==350
7823							                .else
7824	.e686		20 05 f2	jsr $f205	                jsr LF416                    ;update sound???
7825							                .endif
7826	.e689		78		sei		                sei
7827	.e68a		ce cd 02	dec $02cd	                dec previousKeyPressedWhenReadingOSBYTE
7828	.e68d						LE728:
7829	.e68d		2c 5e e3	bit $e35e	                bit valueFF                  ;V=1
7830							                .if version!=400
7832							                .endif
7833	.e690		a5 ec		lda $ec		                lda lastKeyPressedInternal
7834	.e692		05 ed		ora $ed		                ora firstKeyPressedInternal
7835	.e694		2d 42 02	and $0242	                and keyboardSemaphore
7836	.e697		f0 04		beq $e69d	                beq +
7837	.e699		38		sec		                sec
7838	.e69a		20 ee f6	jsr $f6ee	                jsr LF8FF
7839	.e69d						+
7840							                .if version>=500
7842							                .endif
7843	.e69d		20 db e7	jsr $e7db	                jsr pollPrinterDriver
7844	.e6a0		ac 43 02	ldy $0243	                ldy romPollingSemaphore
7845							                .if version==400
7846	.e6a3		f0 11		beq $e6b6	                beq rtsE6B6
7849							                .endif
7850	.e6a5		a2 15		ldx #$15	                ldx #romServiceCallPollingInterrupt
7851							                .if version==400
7852	.e6a7		4c 52 ec	jmp $ec52	                jmp makeROMServiceCall
7861							                .endif

7863							                .if version!=400
7905							                .endif

7907	.e6aa						checkForSystemVIACA2Interrupt:
7908	.e6aa		4a		lsr a		                lsr a                        ;C = CA2
7909	.e6ab		90 0a		bcc $e6b7	                bcc handleUnrecognisedInterruptE799

7911							                ; Handle CA2 interrupt - keyboard.

7913	.e6ad		18		clc		                clc
7914	.e6ae		20 ee f6	jsr $f6ee	                jsr LF8FF
7915	.e6b1		a9 01		lda #$01	                lda #VIA.irq.ca2
7916							                .if version<400
7918							                .else
7919	.e6b3						staSystemVIAIFR:
7920	.e6b3		8d 4d fe	sta $fe4d	                sta systemVIA.ifr
7921	.e6b6						rtsE6B6:
7922	.e6b6		60		rts		                rts
7923							                .endif

7925	.e6b7						handleUnrecognisedInterruptE799:
7926	.e6b7		4c f1 e5	jmp $e5f1	                jmp handleUnrecogisedInterrupt

7928							;-------------------------------------------------------------------------
7929							;
7930							; OSBYTE 17 (&11) Write next ADC channel to be sampled [MasRef D.2-25]
7931							;
7932	.e6ba						osbyte11:
7933							                .if version!=400
7940							                .endif

7942							;-------------------------------------------------------------------------
7943							;
7944							; Print a 0-terminated string at some offset from startupMessages.
7945							;
7946							; entry:
7947							;
7948							; Y = offset-1 of message
7949							;
7950	.e6ba						printStartupMessage:
7951	.e6ba		a9 e0		lda #$e0	                lda #>startupMessages
7952							                ; .cerror (<startupMessages)!=0,"startupMessages must be page-aligned" ;it's more flexible than this, but this'll do for now

7954							;-------------------------------------------------------------------------
7955							;
7956							; Print a 0-terminated string.
7957							;
7958							; entry:
7959							;
7960							; A = address MSB
7961							;
7962							; Y = (address LSB)-1
7963							;
7964	.e6bc						print0TerminatedString:
7965	.e6bc		85 fe		sta $fe		                sta errPtr+1
7966	.e6be		64 fd		stz $fd		                stz errPtr+0

7968							;-------------------------------------------------------------------------
7969							;
7970							; Print the BRK message.
7971							;
7972							; entry:
7973							;
7974							; (errPtr) = pointer to the error number (as will be the case after a
7975							; BRK)
7976							;
7977							; Y=0
7978							;
7979	.e6c0						printBRKMessage:
7980	.e6c0		c8		iny		                iny
7981	.e6c1		b1 fd		lda ($fd),y	                lda (errPtr),y
7982	.e6c3		20 e3 ff	jsr $ffe3	                jsr OSASCI
7983	.e6c6		aa		tax		                tax
7984	.e6c7		d0 f7		bne $e6c0	                bne printBRKMessage
7985	.e6c9						rtsE7B0:
7986	.e6c9		60		rts		                rts

7988							;-------------------------------------------------------------------------

7990							                .if version>=500
8230							                .endif

8232							;-------------------------------------------------------------------------

8234	.e6ca						osbyte81Timed:
8235	.e6ca		8e b1 02	stx $02b1	                stx inkeyTimeoutCounter+0
8236	.e6cd		8c b2 02	sty $02b2	                sty inkeyTimeoutCounter+1
8237	.e6d0		66 e6		ror $e6		                ror readCharacterTimedFlag   ;set the timed flag
8238	.e6d2		58		cli		                cli
8239	.e6d3		80 02		bra $e6d7	                bra osrdchWithTimeout

8241							;-------------------------------------------------------------------------

8243	.e6d5						osrdchEntryPoint:
8244	.e6d5		64 e6		stz $e6		                stz readCharacterTimedFlag   ;clear the timed flag
8245	.e6d7						osrdchWithTimeout:
8246	.e6d7		da		phx		                phx
8247	.e6d8		5a		phy		                phy
8248	.e6d9		ac 56 02	ldy $0256	                ldy execFileHandle
8249	.e6dc		f0 12		beq $e6f0	                beq osrdchLoop               ;taken if not *EXEC'ing
8250	.e6de		38		sec		                sec
8251	.e6df		66 eb		ror $eb		                ror tapeCritical
8252	.e6e1		20 d7 ff	jsr $ffd7	                jsr OSBGET             ;get 1 byte from the *EXEC file
8253	.e6e4		64 eb		stz $eb		                stz tapeCritical
8254	.e6e6		90 21		bcc $e709	                bcc osrdchDone                    ;taken if byte valid
8255	.e6e8		a9 00		lda #$00	                lda #$00                     ;OSFIND close file
8256	.e6ea		9c 56 02	stz $0256	                stz execFileHandle           ;reset *EXEC handle
8257	.e6ed		20 ce ff	jsr $ffce	                jsr OSFIND                   ;close *EXEC file
8258	.e6f0						osrdchLoop:
8259	.e6f0		a5 ff		lda $ff		                lda escapeFlag               ;b7 set if ESCAPE pressed
8260	.e6f2		0a		asl a		                asl a                        ;C=1 if ESCAPE pressed
8261	.e6f3		a9 1b		lda #$1b	                lda #27                      ;ASCII for ESCAPE
8262	.e6f5		b0 12		bcs $e709	                bcs osrdchDone               ;exit with C=1 if ESCAPE
8263							                                             ;pressed
8264							                .if version!=400
8266							                .endif
8267	.e6f7		20 8c e9	jsr $e98c	                jsr readFromEconetOrSoftKeyOrInputBufferA ;handle Econet/soft key stuff???
8268	.e6fa		90 0d		bcc $e709	                bcc osrdchDone
8269	.e6fc		24 e6		bit $e6		                bit readCharacterTimedFlag
8270	.e6fe		10 f0		bpl $e6f0	                bpl osrdchLoop     ;taken if no timeout - keep looping
8271	.e700		ad b2 02	lda $02b2	                lda inkeyTimeoutCounter+1
8272	.e703		0d b1 02	ora $02b1	                ora inkeyTimeoutCounter+0
8273	.e706		d0 e8		bne $e6f0	                bne osrdchLoop     ;taken if timeout not timed out yet
8274	.e708		3a		dec a		                dec a              ;timed out: A=$ff, C=1
8275	.e709						osrdchDone:
8276	.e709		7a		ply		                ply
8277	.e70a		fa		plx		                plx
8278	.e70b		60		rts		                rts

8280							;-------------------------------------------------------------------------

8282	.e70c						starLIBFS:
8283	.e70c		ad 01 df	lda $df01	                lda hazel.activeFS
8284	.e70f		8d 02 df	sta $df02	                sta hazel.libFS
8285	.e712		60		rts		                rts

8287							;-------------------------------------------------------------------------

8289							                .if includeStarX
8290	.e713						starX:
8291	.e713		8d e8 fe	sta $fee8	                sta TUBE+8
8292	.e716						LE800:
8293	.e716		80 fe		bra $e716	                bra LE800
8294							                .endif

8296							;-------------------------------------------------------------------------
8297							;
8298							; OSCLI
8299							;
8300							; MasRef D.4-1
8301							;

8303	.e718						oscliEntryPoint: .block
8304	.e718		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
8305	.e71b		86 f2		stx $f2		                stx stringInputBufferAddress+0
8306	.e71d		84 f3		sty $f3		                sty stringInputBufferAddress+1
8307	.e71f		a0 00		ldy #$00	                ldy #$00
8308	.e721						-
8309	.e721		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
8310	.e723		99 00 dc	sta $dc00,y	                sta hazel.commandLine,y
8311	=$e727						emptyCommandLine=*+1                         ;arbitrary place that's
8312							                                             ;just a 13 byte...
8313	.e726		c9 0d		cmp #$0d	                cmp #$0D
8314	.e728		f0 04		beq $e72e	                beq +     ;branch taken if end of command line reached
8315	.e72a		c8		iny		                iny
8316	.e72b		d0 f4		bne $e721	                bne -

8318							                ; OSCLI is a no-op if the command line is too long.
8319	.e72d		60		rts		                rts

8321	.e72e						+
8322	.e72e		a0 dc		ldy #$dc	                ldy #>hazel.commandLine
8323	.e730		a2 00		ldx #$00	                ldx #<hazel.commandLine
8324	.e732		20 73 f1	jsr $f173	                jsr withTerminalROM
8325	.e735		4c 14 85	jmp $8514	                jmp oscli
8326							                .endblock

8328	=$e727						emptyCommandLine=oscliEntryPoint.emptyCommandLine

8330							                ; OSWRCH
8331							                ; ======
8332	.e738						oswrchEntryPoint:
8333	.e738		48		pha		                pha                          ;S=[ch]
8334	.e739		da		phx		                phx                          ;S=[x; ch]
8335	.e73a		5a		phy		                phy                          ;S=[y; x; ch]
8336	.e73b		48		pha		                pha                          ;S=[ch; y; x; ch]
8337	.e73c		2c 60 02	bit $0260	                bit econetOutputInterpretationStatus
8338	.e73f		10 08		bpl $e749	                bpl LE833
8339	.e741		a8		tay		                tay
8340	.e742		a9 04		lda #$04	                lda #netWriteCharacterAttempted
8341	.e744		20 95 e9	jsr $e995	                jsr callNETV
8342	.e747		b0 51		bcs $e79a	                bcs LE8A5
8343	.e749						LE833:
8344	.e749		a9 02		lda #$02	                lda #$02
8345	.e74b		2c 7c 02	bit $027c	                bit characterDestinationStatus
8346	.e74e		d0 28		bne $e778	                bne LE862
8347	.e750		68		pla		                pla                          ;restore char to print
8348	.e751		48		pha		                pha                          ;save it again
8349	.e752		aa		tax		                tax                          ;X=char to print
8350	.e753		ad 34 fe	lda $fe34	                lda ACCCON                   ;
8351	.e756		48		pha		                pha                          ;S=[old ACCCON; ch; y; x; ch]
8352							                .if version==350
8354							                .else
8355	.e757		a9 08		lda #$08	                lda #ACCCON.Y
8356	.e759		1c 34 fe	trb $fe34	                trb ACCCON                   ;MOS ROM at $c000
8357							                .endif
8358	.e75c		a5 f4		lda $f4		                lda $F4
8359	.e75e		48		pha		                pha          ;S=[old ROMSEL; old ACCCON; ch; y; x; ch]
8360	.e75f		a9 8f		lda #$8f	                lda #$80|terminalROM
8361	.e761		85 f4		sta $f4		                sta $F4
8362	.e763		8d 30 fe	sta $fe30	                sta ROMSEL                   ;page in ANDY+Terminal
8363	.e766		8a		txa		                txa                          ;A=char to print
8364	.e767		20 27 c0	jsr $c027	                jsr outputToVDU
8365	.e76a		68		pla		                pla
8366	.e76b		85 f4		sta $f4		                sta $F4
8367	.e76d		8d 30 fe	sta $fe30	                sta ROMSEL
8368	.e770		68		pla		                pla
8369	.e771		29 08		and #$08	                and #ACCCON.Y
8370	.e773		0c 34 fe	tsb $fe34	                tsb ACCCON
8371	.e776		b0 07		bcs $e77f	                bcs LE869
8372	.e778						LE862:
8373	.e778		a9 08		lda #$08	                lda #$08
8374	.e77a		2c 7c 02	bit $027c	                bit characterDestinationStatus
8375	.e77d		f0 05		beq $e784	                beq LE86E
8376	.e77f						LE869:
8377	.e77f		68		pla		                pla
8378	.e780		48		pha		                pha
8379	.e781		20 9f e7	jsr $e79f	                jsr LE8AA
8380	.e784						LE86E:
8381							                .if version!=400
8403							                .endif

8405	.e784		a9 10		lda #$10	                lda #$10
8406	.e786		2c 7c 02	bit $027c	                bit characterDestinationStatus
8407	.e789		d0 0f		bne $e79a	                bne LE8A5
8408	.e78b		ac 57 02	ldy $0257	                ldy spoolFileHandle
8409	.e78e		f0 0a		beq $e79a	                beq LE8A5
8410	.e790		68		pla		                pla
8411	.e791		48		pha		                pha
8412	.e792		38		sec		                sec
8413	.e793		66 eb		ror $eb		                ror $EB
8414	.e795		20 d4 ff	jsr $ffd4	                jsr OSBPUT
8415	.e798		46 eb		lsr $eb		                lsr $EB
8416	.e79a						LE8A5:
8417	.e79a		68		pla		                pla
8418	.e79b		7a		ply		                ply
8419	.e79c		fa		plx		                plx
8420	.e79d		68		pla		                pla
8421	.e79e		60		rts		                rts

8423	.e79f						LE8AA:
8424	.e79f		2c 7c 02	bit $027c	                bit characterDestinationStatus
8425	.e7a2		70 25		bvs $e7c9	                bvs LE8D4
8426	.e7a4		cd 86 02	cmp $0286	                cmp printerIgnoreChar
8427	.e7a7		d0 05		bne $e7ae	                bne LE8B9
8428	.e7a9		2c 46 02	bit $0246	                bit noignoreState
8429	.e7ac		10 1b		bpl $e7c9	                bpl LE8D4
8430	.e7ae						LE8B9:
8431	.e7ae		08		php		                php
8432	.e7af		78		sei		                sei
8433	.e7b0		aa		tax		                tax
8434	.e7b1		a9 04		lda #$04	                lda #$04
8435	.e7b3		2c 7c 02	bit $027c	                bit characterDestinationStatus
8436	.e7b6		d0 10		bne $e7c8	                bne LE8D3
8437	.e7b8		8a		txa		                txa
8438	.e7b9		a2 03		ldx #$03	                ldx #$03
8439	.e7bb		20 4b e8	jsr $e84b	                jsr LE9A3
8440	.e7be		b0 08		bcs $e7c8	                bcs LE8D3
8441	.e7c0		2c d1 02	bit $02d1	                bit bufferEmptyFlags+bufferPrinter
8442	.e7c3		10 03		bpl $e7c8	                bpl LE8D3
8443	.e7c5		20 ca e7	jsr $e7ca	                jsr LE8D5
8444	.e7c8						LE8D3:
8445	.e7c8		28		plp		                plp
8446	.e7c9						LE8D4:
8447	.e7c9		60		rts		                rts

8449	.e7ca						LE8D5:                                       ;E7CA in MOS 4.00
8450	.e7ca		ad 85 02	lda $0285	                lda printerDriverType
8451							                .if version!=400
8504							                .else

8506	.e7cd		c9 03		cmp #$03	                cmp #printerDriverTypeUser
8507	.e7cf		90 30		bcc $e801	                bcc LE959

8509	.e7d1						writeACIAControlRegister:
8510	.e7d1						osbyte9C:
8511	.e7d1						setRS423Active:

8513							                .endif

8515							;-------------------------------------------------------------------------

8517	.e7d1						activatePrinterDriver:
8518	.e7d1		18		clc		                clc
8519	.e7d2		a9 01		lda #$01	                lda #printerDriverActivate
8520	.e7d4		20 e2 e7	jsr $e7e2	                jsr callPrinterDriverWithPrinterBuffer

8522							                ; printer driver will set C=0 if active, C=1 if
8523							                ; inactive.

8525							;-------------------------------------------------------------------------
8526							;
8527							; OSBYTE 123 (&7B) Inform MOS of printer driver going dormant [MasRef
8528							; D.2-36]
8529							;
8530	.e7d7						osbyte7B:
8531	.e7d7		6e d1 02	ror $02d1	                ror bufferEmptyFlags+bufferPrinter   ;C=1 on entry, so set bit 7
8532	.e7da						rtsE932:
8533	.e7da		60		rts		                rts

8535							;-------------------------------------------------------------------------

8537	.e7db						pollPrinterDriver:
8538	.e7db		2c d1 02	bit $02d1	                bit bufferEmptyFlags+bufferPrinter
8539	.e7de		30 fa		bmi $e7da	                bmi rtsE932           ;taken if printer driver dormant
8540	.e7e0		a9 00		lda #$00	                lda #printerDriverPoll
8541	.e7e2						callPrinterDriverWithPrinterBuffer:
8542	.e7e2		a2 03		ldx #$03	                ldx #bufferPrinter
8543	.e7e4						callPrinterDriver:
8544	.e7e4		ac 85 02	ldy $0285	                ldy printerDriverType
8545	.e7e7		20 95 e9	jsr $e995	                jsr callNETV
8546	.e7ea		6c 22 02	jmp ($0222)	                jmp (UPTV)

8548							;-------------------------------------------------------------------------
8549							;
8550							; OSBYTE 15 (&0F) Flush buffer
8551							;
8552	.e7ed						osbyte0F:
8553	.e7ed		d0 0f		bne $e7fe	                bne LE956
8554	.e7ef						LE947:
8555	.e7ef		a2 08		ldx #$08	                ldx #$08
8556	.e7f1						LE949:
8557	.e7f1		58		cli		                cli
8558	.e7f2		78		sei		                sei
8559	.e7f3		20 f9 e7	jsr $e7f9	                jsr osbyte15
8560	.e7f6		ca		dex		                dex
8561	.e7f7		10 f8		bpl $e7f1	                bpl LE949

8563							;-------------------------------------------------------------------------
8564							;
8565							; OSBYTE 21 (&15) Flush selected buffer
8566							;
8567	.e7f9						osbyte15:                                    ;e951
8568	.e7f9		e0 09		cpx #$09	                cpx #bufferMax+1
8569	.e7fb		90 04		bcc $e801	                bcc LE959
8570	.e7fd		60		rts		                rts

8572	.e7fe						LE956:
8573	.e7fe		ae 41 02	ldx $0241	                ldx inputSource
8574	.e801						LE959:
8575	.e801		18		clc		                clc
8576	.e802						LE95A:
8577	.e802		48		pha		                pha
8578	.e803		08		php		                php
8579	.e804		78		sei		                sei
8580	.e805		b0 08		bcs $e80f	                bcs LE967
8581	.e807		8a		txa		                txa
8582	.e808		29 04		and #$04	                and #$04                     ;buffer 4-7?
8583	.e80a		f0 03		beq $e80f	                beq LE967                    ;taken if not sound buffer
8584	.e80c		20 4c f3	jsr $f34c	                jsr clearSoundChannelBuffer
8585	.e80f						LE967:
8586	.e80f		38		sec		                sec
8587	.e810		7e ce 02	ror $02ce,x	                ror bufferEmptyFlags,x
8588	.e813		e0 02		cpx #$02	                cpx #bufferFirstOutput
8589	.e815		b0 06		bcs $e81d	                bcs LE975                    ;taken if output buffer
8590	.e817		9c 68 02	stz $0268	                stz softKeyStringLength
8591	.e81a		9c 6a 02	stz $026a	                stz vduQueueNegativeLength
8592	.e81d						LE975:
8593	.e81d		20 53 eb	jsr $eb53	                jsr purgeBufferViaCNPV
8594	.e820		28		plp		                plp
8595	.e821		68		pla		                pla
8596	.e822		60		rts		                rts

8598							;-------------------------------------------------------------------------
8599							;
8600							; Count/purge entry point [AUG p264]
8601							;
8602	.e823						cnpEntryPoint:
8603	.e823		50 07		bvc $e82c	                bvc countBuffer
8604	.e825						purgeBuffer:
8605	.e825		bd d7 02	lda $02d7,x	                lda bufferStartIndices,x
8606	.e828		9d e0 02	sta $02e0,x	                sta bufferEndIndices,x
8607	.e82b		60		rts		                rts

8609	.e82c						countBuffer:
8610	.e82c		08		php		                php
8611	.e82d		78		sei		                sei
8612	.e82e		08		php		                php
8613	.e82f		38		sec		                sec
8614	.e830		bd e0 02	lda $02e0,x	                lda bufferEndIndices,x
8615	.e833		fd d7 02	sbc $02d7,x	                sbc bufferStartIndices,x
8616	.e836		b0 04		bcs $e83c	                bcs LE994
8617	.e838		38		sec		                sec
8618	.e839		fd 83 e8	sbc $e883,x	                sbc bufferIndex0Offsets,x
8619	.e83c						LE994:
8620	.e83c		28		plp		                plp
8621	.e83d		90 06		bcc $e845	                bcc LE99D
8622	.e83f		18		clc		                clc
8623	.e840		7d 83 e8	adc $e883,x	                adc bufferIndex0Offsets,x
8624	.e843		49 ff		eor #$ff	                eor #$FF
8625	.e845						LE99D:
8626	.e845		a0 00		ldy #$00	                ldy #$00
8627	.e847		aa		tax		                tax
8628	.e848		28		plp		                plp
8629	.e849						rtsE9A1:
8630	.e849		60		rts		                rts

8632							;-------------------------------------------------------------------------

8634	.e84a						LE9A2:
8635	.e84a		58		cli		                cli
8636	.e84b						LE9A3:
8637	.e84b		78		sei		                sei
8638	.e84c						LE9A4:
8639	.e84c		20 e8 e8	jsr $e8e8	                jsr callINSV
8640	.e84f		90 f8		bcc $e849	                bcc rtsE9A1
8641	.e851		20 30 f0	jsr $f030	                jsr LF241
8642	.e854		48		pha		                pha
8643	.e855		20 24 f5	jsr $f524	                jsr updateKeyboardLEDs
8644	.e858		0a		asl a		                asl a
8645	.e859		68		pla		                pla
8646	.e85a		90 ee		bcc $e84a	                bcc LE9A2
8647	.e85c		60		rts		                rts

8649							;-------------------------------------------------------------------------
8650							;
8651							; OSBYTE $77
8652							;
8653							; D.2-33
8654							;
8655							                .if version!=350
8656	.e85d						selectTerminalROMAndOSBYTE77:
8657	.e85d		20 73 f1	jsr $f173	                jsr withTerminalROM
8658	.e860		4c b7 96	jmp $96b7	                jmp osbyte77
8659							                .endif

8661							;-------------------------------------------------------------------------
8662							;
8663							; Get *IGNORE CMOS byte offset and mask for a given ROM.
8664							;
8665							; entry:
8666							;
8667							; Y = ROM number
8668							;
8669							; exit:
8670							;
8671							; A = mask
8672							;
8673							; X = RTC address of byte
8674							;
8675	.e863						getROMInsertedFlagRTCAddressAndMask:
8676	.e863		a9 00		lda #$00	                lda #$00
8677	.e865		38		sec		                sec
8678	.e866		a2 14		ldx #$14	                ldx #CMOSBytes.insertedROMs+0+cmosBytesOffset
8679	.e868						-
8680	.e868		2a		rol a		                rol a
8681	.e869		d0 02		bne $e86d	                bne +
8682	.e86b		e8		inx		                inx
8683	.e86c		2a		rol a		                rol a
8684	.e86d						+
8685	.e86d		88		dey		                dey
8686	.e86e		10 f8		bpl $e868	                bpl -
8687	.e870		60		rts		                rts

8689							;-------------------------------------------------------------------------

8691	=[]						_:=[]
8692	=[($03e0,32)]					_..=[(bufferKeyboardAddress,bufferKeyboardSize)]
8693	=[($03e0,32),($0a00,256)]			_..=[(bufferRS423InputAddress,bufferRS423InputSize)]
8694	=[($03e0,32),($0a00,256),($0900,192)]		_..=[(bufferRS423OutputAddress,bufferRS423OutputSize)]
8695	=[($03e0,32),($0a00,256),($0900,192),($0880,64)]
							_..=[(bufferPrinterAddress,bufferPrinterSize)]
8696	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16)]
							_..=[(bufferSoundChannel0Address,bufferSoundChannel0Size)]
8697	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16)]
							_..=[(bufferSoundChannel1Address,bufferSoundChannel1Size)]
8698	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16)]
							_..=[(bufferSoundChannel2Address,bufferSoundChannel2Size)]
8699	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16),($0870,16)]
							_..=[(bufferSoundChannel3Address,bufferSoundChannel3Size)]
8700	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16),($0870,16),($09c0,64)]
							_..=[(buffer8Address,buffer8Size)]
8701	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16),($0870,16),($09c0,64)]
							buffers=_

8703							BufferTableIndex0Offset: .function buffer
8704							                .endfunction 256-buffer[1]

8706							BufferTableBase: .function buffer
8707							                .endfunction buffer[0]-BufferTableIndex0Offset(buffer)

8709							;-------------------------------------------------------------------------
8710							;
8711							; Buffer base addresses - each buffer's address, offset by the offset
8712							; for index 0 (see bufferIndex0Offsets).
8713							;
8714	.e871						bufferBaseAddressMSBs:
8715							                .for _i=0,_i<len(buffers),_i+=1
8716	>e871		03				                .byte >BufferTableBase(buffers[_i])
8716	>e872		0a				                .byte >BufferTableBase(buffers[_i])
8716	>e873		08				                .byte >BufferTableBase(buffers[_i])
8716	>e874		07				                .byte >BufferTableBase(buffers[_i])
8716	>e875		07				                .byte >BufferTableBase(buffers[_i])
8716	>e876		07				                .byte >BufferTableBase(buffers[_i])
8716	>e877		07				                .byte >BufferTableBase(buffers[_i])
8716	>e878		07				                .byte >BufferTableBase(buffers[_i])
8716	>e879		09				                .byte >BufferTableBase(buffers[_i])
8717							                .endfor

8719	.e87a						bufferBaseAddressLSBs:
8720							                .for _i=0,_i<len(buffers),_i+=1
8721	>e87a		00				                .byte <BufferTableBase(buffers[_i])
8721	>e87b		00				                .byte <BufferTableBase(buffers[_i])
8721	>e87c		c0				                .byte <BufferTableBase(buffers[_i])
8721	>e87d		c0				                .byte <BufferTableBase(buffers[_i])
8721	>e87e		50				                .byte <BufferTableBase(buffers[_i])
8721	>e87f		60				                .byte <BufferTableBase(buffers[_i])
8721	>e880		70				                .byte <BufferTableBase(buffers[_i])
8721	>e881		80				                .byte <BufferTableBase(buffers[_i])
8721	>e882		00				                .byte <BufferTableBase(buffers[_i])
8722							                .endfor

8724							;-------------------------------------------------------------------------

8726							; Offset of buffer index 0 for each buffer. Index 0 is (-buffer size)
8727							; - buffer indexes count up, and wrap once they reach 0.

8729	.e883						bufferIndex0Offsets:
8730							                .for _i=0,_i<len(buffers),_i+=1
8731	>e883		e0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e884		00				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e885		40				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e886		c0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e887		f0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e888		f0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e889		f0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e88a		f0				                .byte BufferTableIndex0Offset(buffers[_i])
8731	>e88b		c0				                .byte BufferTableIndex0Offset(buffers[_i])
8732							                .endfor

8734							;-------------------------------------------------------------------------
8735							;
8736							; Get base address for a buffer.
8737							;
8738							; entry:
8739							;
8740							; X = buffer number
8741							;
8742							; exit:
8743							;
8744							; (SEIWKA) = buffer base address
8745							;
8746	.e88c						getBufferBaseAddress:
8747	.e88c		bd 7a e8	lda $e87a,x	                lda bufferBaseAddressLSBs,x
8748	.e88f		85 fa		sta $fa		                sta SEIWKA
8749	.e891		bd 71 e8	lda $e871,x	                lda bufferBaseAddressMSBs,x
8750	.e894		85 fb		sta $fb		                sta SEIWKB
8751	.e896		60		rts		                rts

8753							;-------------------------------------------------------------------------
8754							;
8755							; OSBYTE 152 (&98) Examine buffer status [MasRef D.2-45]
8756							;
8757	.e897						osbyte98:
8758	.e897		2c 5e e3	bit $e35e	                bit valueFF                  ;V=1
8759	.e89a		80 01		bra $e89d	                bra callREMV

8761							;-------------------------------------------------------------------------
8762							;
8763							; OSBYTE 145 (&91) Get character from buffer [MasRef D.2-45]
8764							;
8765							; X = buffer number
8766	.e89c						osbyte91:
8767	.e89c		b8		clv		                clv                          ;remove
8768	.e89d						callREMV:
8769	.e89d		6c 2c 02	jmp ($022c)	                jmp (REMV)

8771							;-------------------------------------------------------------------------
8772							;
8773							; Buffer remove entry point. [AUG p263]
8774							;
8775							; Even in remove mode, A is the character removed on exit. Some of the
8776							; other MOS routines rely on this.
8777							;
8778	.e8a0						remEntryPoint:
8779	.e8a0		08		php		                php
8780	.e8a1		78		sei		                sei
8781	.e8a2		bd d7 02	lda $02d7,x	                lda bufferStartIndices,x
8782	.e8a5		dd e0 02	cmp $02e0,x	                cmp bufferEndIndices,x
8783	.e8a8		f0 6c		beq $e916	                beq plp_sec_rts  ;taken if buffer empty
8784	.e8aa		a8		tay		                tay                          ;Y=start index
8785	.e8ab		20 8c e8	jsr $e88c	                jsr getBufferBaseAddress
8786	.e8ae		b1 fa		lda ($fa),y	                lda (SEIWKA),y               ;get byte from buffer
8787	.e8b0		70 1a		bvs $e8cc	                bvs tay_plp_clc_rts                  ;taken if only looking
8788	.e8b2		48		pha		                pha                          ;save buffered byte
8789	.e8b3		c8		iny		                iny                          ;next char in buffer
8790	.e8b4		98		tya		                tya                          ;set Z if wrap
8791	.e8b5		d0 03		bne $e8ba	                bne +                        ;branch taken if no wrap
8792	.e8b7		bd 83 e8	lda $e883,x	                lda bufferIndex0Offsets,x    ;reset index on wrap
8793	.e8ba						+
8794	.e8ba		9d d7 02	sta $02d7,x	                sta bufferStartIndices,x

8796							                ; Issue output buffer empty event when appropriate.
8797	.e8bd		e0 02		cpx #$02	                cpx #bufferFirstOutput
8798	.e8bf		90 0a		bcc $e8cb	                bcc pla_tay_plp_clc_rts ;taken if keyboard or RS423
8799							                                        ;input - i.e., buffer is input
8800	.e8c1		dd e0 02	cmp $02e0,x	                cmp bufferEndIndices,x       ;buffer now empty?
8801	.e8c4		d0 05		bne $e8cb	                bne pla_tay_plp_clc_rts           ;taken if not empty
8802	.e8c6		a0 00		ldy #$00	                ldy #eventOutputBufferEmpty
8803	.e8c8		20 d0 e8	jsr $e8d0	                jsr eventEntryPoint
8804	.e8cb						pla_tay_plp_clc_rts:
8805	.e8cb		68		pla		                pla                          ;restore buffered byte
8806	.e8cc						tay_plp_clc_rts:
8807	.e8cc		a8		tay		                tay                          ;Y=buffered byte
8808	.e8cd						plp_clc_rts:
8809	.e8cd		28		plp		                plp
8810	.e8ce		18		clc		                clc
8811	.e8cf		60		rts		                rts

8813							;-------------------------------------------------------------------------
8814							;
8815							; [MasRef D.9-1]
8816							;
8817	.e8d0						eventEntryPoint:
8818	.e8d0		08		php		                php
8819	.e8d1		78		sei		                sei
8820	.e8d2		48		pha		                pha
8821	.e8d3		b9 bf 02	lda $02bf,y	                lda eventEnabledFlags,y      ;is the event enabled?
8822	.e8d6		f0 3d		beq $e915	                beq pla_plp_sec_rts                    ;
8823	.e8d8		98		tya		                tya
8824	.e8d9		7a		ply		                ply
8825	.e8da		5a		phy		                phy
8826	.e8db		20 ae f6	jsr $f6ae	                jsr LF8BF
8827	.e8de		80 eb		bra $e8cb	                bra pla_tay_plp_clc_rts

8829							;-------------------------------------------------------------------------
8830							;
8831							; Insert character into buffer and issue an event for it.
8832							;
8833							; entry:
8834							;
8835							; Y = buffer number
8836							;
8837	.e8e0						insertCharacterIntoBuffer:
8838	.e8e0		98		tya		                tya
8839	.e8e1		a0 02		ldy #$02	                ldy #eventCharacterEnteringBuffer
8840	.e8e3		20 d0 e8	jsr $e8d0	                jsr eventEntryPoint
8841	.e8e6		a8		tay		                tay

8843							;-------------------------------------------------------------------------
8844							;
8845							; OSBYTE 138 (&8A) Insert character code into buffer [MasRef D.2-43]
8846							;
8847	.e8e7						osbyte8A:
8848	.e8e7		98		tya		                tya
8849	.e8e8						callINSV:
8850	.e8e8		6c 2a 02	jmp ($022a)	                jmp (INSV)

8852							;-------------------------------------------------------------------------
8853							;
8854							; Default INSV entry point [AUG p263]
8855							;
8856	.e8eb						insEntryPoint:
8857	.e8eb		08		php		                php
8858	.e8ec		78		sei		                sei
8859	.e8ed		48		pha		                pha                          ;save value to insert
8860	.e8ee		bd e0 02	lda $02e0,x	                lda bufferEndIndices,x       ;get buffer index
8861	.e8f1		1a		inc a		                inc a                        ;bump index
8862	.e8f2		d0 03		bne $e8f7	                bne +          ;taken if index hasn't wrapped around
8863	.e8f4		bd 83 e8	lda $e883,x	                lda bufferIndex0Offsets,x        ;reset index due to wrap
8864	.e8f7						+
8865	.e8f7		dd d7 02	cmp $02d7,x	                cmp bufferStartIndices,x     ;are we at the start index?
8866	.e8fa		f0 0e		beq $e90a	                beq bufferFull       ;taken if yes - i.e., buffer full
8867	.e8fc		bc e0 02	ldy $02e0,x	                ldy bufferEndIndices,x       ;note old buffer end
8868	.e8ff		9d e0 02	sta $02e0,x	                sta bufferEndIndices,x       ;update buffer end
8869	.e902		20 8c e8	jsr $e88c	                jsr getBufferBaseAddress
8870	.e905		68		pla		                pla                          ;restore value to insert
8871	.e906		91 fa		sta ($fa),y	                sta (SEIWKA),y               ;store byte in buffer
8872	.e908		80 c3		bra $e8cd	                bra plp_clc_rts              ;done

8874	.e90a						bufferFull
8875							                ; Issue input buffer full event when appropriate.
8876	.e90a		68		pla		                pla
8877	.e90b		e0 02		cpx #$02	                cpx #bufferFirstOutput
8878	.e90d		b0 07		bcs $e916	                bcs plp_sec_rts  ;taken if output buffer
8879	.e90f		a0 01		ldy #$01	                ldy #eventInputBufferFull
8880	.e911		20 d0 e8	jsr $e8d0	                jsr eventEntryPoint
8881	.e914		48		pha		                pha
8882	.e915						pla_plp_sec_rts:
8883	.e915		68		pla		                pla
8884	.e916						plp_sec_rts:
8885	.e916		28		plp		                plp
8886	.e917		38		sec		                sec
8887	.e918		60		rts		                rts

8889							;-------------------------------------------------------------------------
8890							;
8891							; Check if character is a letter - A-Z or a-z.
8892							;
8893							; Entry:
8894							;
8895							; A = character to test
8896							;
8897							; Exit:
8898							;
8899							; C=0 if character is letter, C=1 otherwise
8900							;
8901							; Preserves: A/X/Y
8902	.e919						isLetter: .proc                 ;EA71
8903	.e919		48		pha		                pha
8904	.e91a		29 df		and #$df	                and #$DF        ;convert to upper case
8905	.e91c		c9 5b		cmp #$5b	                cmp #'Z'+1
8906	.e91e		b0 04		bcs $e924	                bcs +           ;branch taken with C=1 if past Z
8907	.e920		49 ff		eor #$ff	                eor #$FF
8908	.e922		c9 bf		cmp #$bf	                cmp #-'A'       ;C=1 if past A
8909	.e924						+
8910	.e924		68		pla		                pla
8911	.e925		60		rts		                rts
8912							                .pend

8914							;-------------------------------------------------------------------------
8915							;
8916							; OSBYTE 153 (&99) Insert character code into buffer, checking for
8917							; ESCAPE [MasRef D.2-46]
8918							;
8919							                .if version==350
8922							                .endif
8923	.e926						insertCharacterIntoKeyboardBuffer:
8924	.e926		a2 00		ldx #$00	                ldx #$00
8925	.e928						osbyte99:
8926							                .if version!=400
8930							                .endif
8931	.e928		98		tya		                tya          ;A=char
8932	.e929		4d 6c 02	eor $026c	                eor escapeCharacter
8933	.e92c		0d 75 02	ora $0275	                ora escapeKeyStatus
8934	.e92f		d0 af		bne $e8e0	                bne insertCharacterIntoBuffer
8935	.e931		ad 58 02	lda $0258	                lda breakAndESCAPEEffect
8936	.e934		6a		ror a		                ror a                        ;C=0 if normal ESCAPE action
8937	.e935		98		tya		                tya                          ;A=char
8938	.e936		b0 0a		bcs $e942	                bcs osbyte99Done             ;taken if ESCAPE inhibited
8939	.e938		a0 06		ldy #$06	                ldy #eventESCAPEPressed
8940	.e93a		20 d0 e8	jsr $e8d0	                jsr eventEntryPoint
8941	.e93d		90 03		bcc $e942	                bcc osbyte99Done             ;taken if event handled
8942	.e93f		20 ea ea	jsr $eaea	                jsr osbyte7D
8943	.e942						osbyte99Done:
8944	.e942		18		clc		                clc
8945	.e943		60		rts		                rts

8947							;-------------------------------------------------------------------------

8949							; A = 0 (edit keys)/1 (ascii keys)/2 (F keys)
8950	.e944						handleCursorKeysAndCopy:
8951							                .if version<500
8952	.e944		6a		ror a		                ror a                        ;test edit keys mode bit 0
8953	.e945		68		pla		                pla                          ;restore translated value
8954	.e946		b0 17		bcs $e95f	                bcs clc_rts_EABD       ;taken if value was asciiKeys
8959							                .endif

8961	.e948						handleFunctionKey:
8962	.e948		98		tya		                tya
8963							                .if version<500&&version!=350
8964	.e949		29 0f		and #$0f	                and #$0F
8965							                .endif
8966							                .if version==350
8969							                .else
8970	.e94b		48		pha		                pha
8971	.e94c		98		tya		                tya
8972	.e94d		4a		lsr a		                lsr a
8973	.e94e		4a		lsr a		                lsr a
8974	.e94f		4a		lsr a		                lsr a
8975	.e950		4a		lsr a		                lsr a
8976							                .endif
8977	.e951		49 04		eor #$04	                eor #$04
8978	.e953		a8		tay		                tay
8979	.e954		b9 65 02	lda $0265,y	                lda input192To207Interpretation-8,y
8980	.e957		4a		lsr a		                lsr a
8981							                .if version<500&&version!=350
8982	.e958		f0 63		beq $e9bd	                beq LEB32
8983	.e95a		68		pla		                pla
8984	.e95b		18		clc		                clc
8985	.e95c		79 65 02	adc $0265,y	                adc input192To207Interpretation-8,y
9006							                .endif

9008	.e95f						clc_rts_EABD:
9009	.e95f		18		clc		                clc
9010	.e960		60		rts		                rts

9012							;-------------------------------------------------------------------------

9014	.e961						copyCharNotRecognised:
9015	.e961		20 ae ed	jsr $edae	                jsr vdu7EntryPoint           ;beep
9016	.e964		fa		plx		                plx
9017	.e965						readFromInputBufferX:
9018	.e965		20 9c e8	jsr $e89c	                jsr osbyte91          ;extract character from buffer X
9019							                .if version<500&&version!=350
9020	.e968		b0 49		bcs $e9b3	                bcs rtsEB28           ;taken if buffer empty
9050							                .endif

9052							                .if version>=511||version==350
9055							                .endif

9057							                .if version!=400
9071							                .endif

9073	.e96a						LEADB:
9074	.e96a		a8		tay		                tay                          ;Y = char
9075	.e96b		10 45		bpl $e9b2	                bpl clc_rts_EB27             ;if normal char, all good
9076	.e96d		29 0f		and #$0f	                and #$0F
9077	.e96f		c9 0b		cmp #$0b	                cmp #$0B
9078	.e971		90 d5		bcc $e948	                bcc handleFunctionKey        ;taken if F key
9079	.e973		69 7b		adc #$7b	                adc #$7B    ;C=1, so +$7c - convert $0b-0$f to $87-$8B
9080	.e975		48		pha		                pha         ;save translated value
9081	.e976		ad 7d 02	lda $027d	                lda editKeysMode
9082	.e979		d0 c9		bne $e944	                bne handleCursorKeysAndCopy  ;taken if not editKeys
9083	.e97b		ad 7c 02	lda $027c	                lda characterDestinationStatus
9084	.e97e		6a		ror a		                ror a                        ;C=rs423_enable
9085	.e97f		6a		ror a		                ror a                        ;C=vdu_disable
9086	.e980		68		pla		                pla                          ;restore translated value
9087	.e981		b0 e2		bcs $e965	                bcs readFromInputBufferX     ;taken if VDU output disabled
9088	.e983		c9 87		cmp #$87	                cmp #$87                     ;COPY?
9089	.e985		f0 2d		beq $e9b4	                beq readCopyChar
9090	.e987		da		phx		                phx                          ;save buffer number
9091	.e988		20 e8 e9	jsr $e9e8	                jsr handleCursorKeyThunk     ;handle cursor key
9092	.e98b		fa		plx		                plx
9093	.e98c						readFromEconetOrSoftKeyOrInputBufferA:
9094							                .if version==400
9095	.e98c		a2 00		ldx #$00	                ldx #0
9096							                .endif
9097	.e98e		2c 5f 02	bit $025f	                bit econetInputInterpretationStatus
9098	.e991		10 05		bpl $e998	                bpl readFromSoftKeyOrInputBufferA
9099	.e993		a9 06		lda #$06	                lda #netReadCharacterAttempted
9100	.e995						callNETV:
9101	.e995		6c 24 02	jmp ($0224)	                jmp (NETV)

9103	.e998						readFromSoftKeyOrInputBufferA:
9104	.e998		ad 68 02	lda $0268	                lda softKeyStringLength
9105	.e99b		f0 c8		beq $e965	                beq readFromInputBufferX
9106							                .if version>=500||version==350
9113							                .endif
9114							                .if version!=400
9118							                .endif
9119	.e99d		a5 f4		lda $f4		                lda $F4
9120	.e99f		48		pha		                pha
9121	.e9a0		20 a5 e5	jsr $e5a5	                jsr selectTerminalROMAndANDY2
9122	.e9a3		b2 f8		lda ($f8)	                lda (softKeyExpansionPtr)
9123	.e9a5		fa		plx		                plx
9124	.e9a6		20 8e e5	jsr $e58e	                jsr selectROMX
9125	.e9a9		ce 68 02	dec $0268	                dec softKeyStringLength
9126	.e9ac		e6 f8		inc $f8		                inc softKeyExpansionPtr+0
9127	.e9ae		d0 02		bne $e9b2	                bne clc_rts_EB27
9128	.e9b0		e6 f9		inc $f9		                inc softKeyExpansionPtr+1
9129	.e9b2						clc_rts_EB27:
9130	.e9b2		18		clc		                clc
9131	.e9b3						rtsEB28:
9132	.e9b3		60		rts		                rts

9134	.e9b4						readCopyChar:
9135	.e9b4		da		phx		                phx
9136	.e9b5		20 ee e9	jsr $e9ee	                jsr handleCopyKeyThunk
9137							                .if version<500&&version!=350
9138	.e9b8		f0 a7		beq $e961	                beq copyCharNotRecognised
9143							                .endif
9144	.e9ba		fa		plx		                plx
9145	.e9bb		18		clc		                clc
9146	.e9bc						rtsEB31:
9147	.e9bc		60		rts		                rts

9149							                .if version>=500||version==350
9160							                .elsif version<500

9162	.e9bd						LEB32:
9163	.e9bd		7a		ply		                ply
9164	.e9be		90 a5		bcc $e965	                bcc readFromInputBufferX
9165	.e9c0		98		tya		                tya
9166	.e9c1		8d c9 02	sta $02c9	                sta currentSoftKey

9168							                .endif

9170	.e9c4		a5 f4		lda $f4		                lda $F4
9171	.e9c6		48		pha		                pha                           ;save old ROMSEL
9172	.e9c7		20 a5 e5	jsr $e5a5	                jsr selectTerminalROMAndANDY2
9173	.e9ca		20 e0 e9	jsr $e9e0	                jsr getSoftKeyStringLength
9174	.e9cd		8d 68 02	sta $0268	                sta softKeyStringLength
9175	.e9d0		b9 00 80	lda $8000,y	                lda andy.softKeys.stringLSBs,y
9176	.e9d3		85 f8		sta $f8		                sta softKeyExpansionPtr+0
9177	.e9d5		b9 11 80	lda $8011,y	                lda andy.softKeys.stringMSBs,y
9178	.e9d8		85 f9		sta $f9		                sta softKeyExpansionPtr+1
9179	.e9da		68		pla		                pla
9180	.e9db		20 9f e5	jsr $e59f	                jsr selectROMA               ;restore old ROMSEL
9181	.e9de		80 ac		bra $e98c	                bra readFromEconetOrSoftKeyOrInputBufferA

9183							;-------------------------------------------------------------------------

9185	.e9e0						getSoftKeyStringLength:
9186	.e9e0		b9 01 80	lda $8001,y	                lda andy.softKeys.stringLSBs+1,y
9187	.e9e3		38		sec		                sec
9188	.e9e4		f9 00 80	sbc $8000,y	                sbc andy.softKeys.stringLSBs+0,y
9189	.e9e7		60		rts		                rts

9191							;-------------------------------------------------------------------------
9192							;
9193							; Page HAZEL out, page MOS in, call handleCursorKey.
9194							;
9195	.e9e8						handleCursorKeyThunk:
9196	.e9e8		20 9a f1	jsr $f19a	                jsr withMOSROM
9197	.e9eb		4c 76 df	jmp $df76	                jmp handleCursorKey

9199							;-------------------------------------------------------------------------
9200							;
9201							; Page HAZEL out, page MOS in, call handleCopyKey.
9202							;
9203	.e9ee						handleCopyKeyThunk:
9204	.e9ee		20 9a f1	jsr $f19a	                jsr withMOSROM
9205	.e9f1		4c 5c df	jmp $df5c	                jmp handleCopyKey

9207							;-------------------------------------------------------------------------

9209							                .if version==350&&!finmos329
9217							                .endif

9219							;-------------------------------------------------------------------------

9221							                .if version<500&&version!=350
9222							                .include "osbyte_osword_table.s65"

:14	;******  Processing file: src/osbyte_osword_table.s65

1							; OSBYTE Dispatch Table
2							; =====================

4							; TODO structure probably the same as
5							; https://tobylobster.github.io/mos/mos/S-s15.html#SP1...

7							; entry:
8							;
9							; A = OSBYTE A
10							;
11							; X = OSBYTE X
12							;
13							; Y = OSBYTE Y
14							;
15							; ?originalA, ?originalX, ?originalY = OSBYTE arguments
16							;
17							; C=1
18							;
19							; N/Z set as per X
20							;

22	.e9f4						osbyteAndOSWORDRoutineTable:
23							                ;Display MOS version D.2-18
24	>e9f4		66 ed				                .word osbyte00

26							                ;Write user flag D.2-18
27	>e9f6		c6 ee				                .word osbyte01

29							                ;Specify input stream D.2-18
30							                .if version==400
31	>e9f8		85 eb				                .word osbyteUnused
34							                .endif

36							                ;Specify output stream D.2-19
37	>e9fa		9b ee				                .word osbyte03

39							                ;Enable/disable cursor editing
40	>e9fc		ce ee				                .word osbyte04

42							                ;Write printer driver type D.2-20
43	>e9fe		b4 ee				                .word osbyte05

45							                ;Write printer ignore character D.2-21
46	>ea00		ab ee				                .word osbyte06

48							                ;Write RS423 receive rate D.2-21
49							                .if version==400
50	>ea02		85 eb				                .word osbyteUnused
53							                .endif

55							                ;Write RS423 transmit rate D.2-22
56							                .if version==400
57	>ea04		85 eb				                .word osbyteUnused
60							                .endif

62							                ;Write duration of first colour D.2-22
63	>ea06		f4 ea				                .word osbyte09

65							                ;Write duration of second colour D.2-22
66	>ea08		f6 ea				                .word osbyte0A

68							                ;Write keyboard auto-repeat delay D.2-22
69	>ea0a		cc ee				                .word osbyte0B

71							                ;Write keyboard auto-repeat rate D.2-23
72	>ea0c		ca ee				                .word osbyte0C

74							                ;Disable event D.2-23
75	>ea0e		16 eb				                .word osbyte0D

77							                ;Enable event D.2-24
78	>ea10		17 eb				                .word osbyte0E

80							                ;Flush buffer D.2-24
81	>ea12		ed e7				                .word osbyte0F

83							                ;Write number of ADC channels D.2-25
84							                .if version==400
85	>ea14		85 eb				                .word osbyteUnused
88							                .endif

90							                ;Write next ADC channel to be sampled D.2-25
91							                .if version==400
92	>ea16		85 eb				                .word osbyteUnused
95							                .endif

97							                ;Reset soft keys D.2-26
98	>ea18		09 ef				                .word osbyte12

100							                ;Wait for vertical sync D.2-26
101	>ea1a		e4 ee				                .word osbyte13

103							                ;Restore default font definitions D.2-26
104	>ea1c		0b f0				                .word osbyte14

106							                ;Flush selected buffer D.2-27
107	>ea1e		f9 e7				                .word osbyte15

109							                ;Increment ROM polling semaphore D.2-27
110	>ea20		17 f0				                .word osbyte16

112							                ;Decrement ROM polling semaphore D.2-27
113	>ea22		1b f0				                .word osbyte17

115							                ; Reserved
116	>ea24		85 eb				                .word osbyteUnused

118							                ;Restore a group of font definitions D.2-28
119	>ea26		11 f0				                .word selectTerminalROMAndOSBYTE19

121							                ; Test RAM presence D.2-28
122							                .if version==350
124							                .elsif version>=400
125	>ea28		6a f8				                .word selectTerminalROMAndOSBYTE44
126							                .endif

128							                ; Test pseudo/absolute use of bank D.2-29
129							                .if version==350
131							                .elsif version>=400
132	>ea2a		70 f8				                .word selectTerminalROMAndOSBYTE45
133							                .endif

135							                ;Write 1MHz bus selection status D.2-29
136	>ea2c		7e ec				                .word osbyte6B

138							                ;Write usage of main/shadow memory D.2-30
139	>ea2e		82 ec				                .word osbyte6C

141							                ;Make temporary Filing System permanent D.2-30
142	>ea30		fe ef				                .word osbyte6D

144							                ;Unused
145	>ea32		85 eb				                .word osbyteUnused

147							                ;Unused
148	>ea34		85 eb				                .word osbyteUnused

150							                ;Select main/shadow memory for VDU access D.2-31
151	>ea36		59 eb				                .word osbyte70

153							                ;Select main/shadow memory for display D.2-31
154	>ea38		69 eb				                .word osbyte71

156							                ;Write usage of shadow memory D.2-31
157	>ea3a		b0 ee				                .word osbyte72

159							                ;Unused
160	>ea3c		aa ff				                .word rtsFFAA

162							                ;Unused
163	>ea3e		aa ff				                .word rtsFFAA

165							                ;Read VDU status D.2-32
166	>ea40		ab ed				                .word osbyte75

168							                ;Reflect keyboard status in keyboard LEDs D.2-33
169	>ea42		1f f0				                .word osbyte76

171							                ;Close all *SPOOL/*SPOOLON or *EXEC files D.2-33
172							                .if version==350
174							                .else
175	>ea44		5d e8				                .word selectTerminalROMAndOSBYTE77
176							                .endif

178							                ;Write keys pressed information D.2-33
179	>ea46		fa f6				                .word osbyte78

181							                ;Keyboard scan D.2-33
182	>ea48		f1 f6				                .word callKEYV

184							                ;Keyboard scan from 16 decimal
185	>ea4a		ff f6				                .word osbyte7A

187							                ;Inform MOS of printer driver going dormant
188	>ea4c		d7 e7				                .word osbyte7B

190							                ;Clear escape condition
191	>ea4e		e9 ea				                .word osbyte7C

193							                ;Set escape condition
194	>ea50		ea ea				                .word osbyte7D

196							                ;Acknowledge escape condition
197	>ea52		cf ea				                .word osbyte7E

199							                ;Check for end of file on an opened file
200	>ea54		d2 ef				                .word osbyte7F

202							                ;Read ADC channel or get buffer status
203							                .if version==400
204	>ea56		48 eb				                .word LED18
207							                .endif

209							                ;Read key with time limit
210	>ea58		24 eb				                .word osbyte81

212							                ;Read machine high order address
213	>ea5a		3b eb				                .word osbyte82

215							                ;Read Operating System High Water Mark (OSHWM)
216	>ea5c		f4 f6				                .word osbyte83

218							                ;Read top of user RAM
219	>ea5e		a9 ef				                .word osbyte84

221							                ;Read top of user RAM for given mode
222	>ea60		bf ef				                .word osbyte85

224							                ;Read text cursor position
225	>ea62		67 e2				                .word osbyte86

227							                ;Read screen mode and character at text cursor position
228	>ea64		cb ef				                .word osbyte87

230							                ;Execute user code
231	>ea66		ca ea				                .word osbyte88

233							                .if version<400
235							                .elsif version<500
236	>ea68		23 eb				                .word LECD9
239							                .endif

241							                ;Insert character code into buffer
242	>ea6a		e7 e8				                .word osbyte8A

244							                ;Write Filing System options
245	>ea6c		d1 ef				                .word osbyte8B

247							                .if version<400
249							                .else
250	>ea6e		85 eb				                .word osbyteUnused
251							                .endif


254							                ;Select ROM Filing System
255	>ea70		99 eb				                .word osbyte8C8D

257							                ;Enter language ROM
258	>ea72		d0 e4				                .word osbyte8E

260							                ;Issue paged ROM service request
261	>ea74		e3 eb				                .word osbyte8F

263							                ;Set vertical screen shift and interlace option
264	>ea76		42 f1				                .word osbyte90

266							                ;Get character from buffer
267	>ea78		9c e8				                .word osbyte91

269							                ;Read from FRED (&FC00 - &FCFF)
270	>ea7a		8d f6				                .word osbyte92

272							                ;Write to FRED (&FC00 - &FCFF)
273	>ea7c		5d f1				                .word osbyte93

275							                ;Read from JIM (&FD00 - &FDFF)
276	>ea7e		9d f6				                .word osbyte94

278							                ;Write to JIM (&FD00 - &FDFF)
279	>ea80		53 f1				                .word osbyte95

281							                ;Read from SHEILA (&FE00 - &FEFF)
282	>ea82		ab ff				                .word osbyte96

284							                ;Write to SHEILA (&FE00 - &FEFF)
285	>ea84		58 f1				                .word osbyte97

287							                ;Examine buffer status
288	>ea86		97 e8				                .word osbyte98

290							                ;Insert character code into buffer checking for escape
291							                .if version==400
292	>ea88		26 e9				                .word insertCharacterIntoKeyboardBuffer
295							                .endif

297							                ;Write video ULA control register
298	>ea8a		3e f0				                .word osbyte9A

300							                ;Write to video ULA palette register and copy
301	>ea8c		4f f0				                .word osbyte9B

303							                ;Read/write serial ACIA control register and copy
304							                .if version==400
305	>ea8e		85 eb				                .word osbyteUnused
308							                .endif

310							                ;Write byte across Tube
311	>ea90		af ff				                .word osbyte9D

313							                ;reserved for the speech system
314	>ea92		85 eb				                .word osbyteUnused

316							                ;reserved for the speech system
317	>ea94		85 eb				                .word osbyteUnused

319							                ;Read VDU variable value
320	>ea96		ee ee				                .word osbyteA0

322							                ;Read CMOS RAM
323							                .if version==350
325							                .else
326	>ea98		8d eb				                .word osbyteA1
327							                .endif

329							                ;Write CMOS RAM
330							                .if version==350
332							                .else
333	>ea9a		93 eb				                .word osbyteA2
334							                .endif

336							                ;reserved for applications software
337	>ea9c		85 eb				                .word osbyteUnused

339							                ;Check processor type
340	>ea9e		54 e5				                .word osbyteA4

342							                ;Read output cursor position
343	>eaa0		3b e2				                .word osbyteA5

345							                ;handle osbyte A6-FF
346	>eaa2		d3 ee				                .word osbyteA6

348							                ;*LINE - not part of the above table???
349	>eaa4		cc ea				                .word callUSERV

351							;-------------------------------------------------------------------------
352							;
353							; OSWORD dispatch table. Must follow on from the OSBYTE table.
354							;
355							; entry:
356							;
357							; A = 0th byte of parameter block
358							;
359							; X = OSWORD X
360							;
361							; Y = 0
362							;
363							; ?originalA, ?originalX, ?originalY = OSWORD arguments
364							;
365							; C=1
366							;
367							; N/Z set as per X
368							;
369	.eaa6						oswordRoutineTable:

371							;Read line from input stream to memory
372	>eaa6		27 ee				                .word osword00

374							                ;Read system clock
375	>eaa8		fa ed				                .word osword01

377							                ;Write system clock
378	>eaaa		0d ee				                .word osword02

380							                ;Read interval timer
381	>eaac		f6 ed				                .word osword03

383							                ;Write interval timer
384	>eaae		09 ee				                .word osword04

386							                ;Read byte from I/O processor memory
387	>eab0		52 ed				                .word osword05

389							                ;Write byte to I/O processor memory
390	>eab2		91 ec				                .word osword06

392							                ;Generate a sound
393	>eab4		73 ed				                .word osword07

395							                ;Define a sound envelope
396	>eab6		d4 ed				                .word osword08

398							                ;Read pixel logical colour
399	>eab8		3f ef				                .word osword09

401							                ;Read a character definition
402	>eaba		64 ef				                .word osword0A

404							                ;Read the palette
405	>eabc		2e ef				                .word osword0B

407							                ;Write the palette
408	>eabe		7c ef				                .word osword0C

410							                ;Read current and previous graphics cursor positions
411	>eac0		8a ef				                .word osword0D

413							                ;Read CMOS clock
414	>eac2		af ec				                .word selectTerminalROMAndOSWORD0E

416							                ;Write CMOS clock
417							                .if version==350
419							                .else
420	>eac4		d7 ef				                .word selectTerminalROMAndOSWORD0F
421							                .endif

423							                .if version>=350
424	.eac6						osword42AndAboveRoutineTable:
425							                ; Sideways RAM Block Transfer
426							                .if version==350
428							                .elsif version>=400
429	>eac6		76 f8				                .word selectTerminalROMAndOSWORD42
430							                .endif

432							                ; Sideways RAM Load/Save
433							                .if version==350
435							                .elsif version>=400
436	>eac8		7c f8				                .word selectTerminalROMAndOSWORD43
437							                .endif
438							                .endif


:12	;******  Return to file: src/mos.s65

9223							                .endif

9225							;-------------------------------------------------------------------------

9227	.eaca						osbyte88: ;LEC37:
9228	.eaca		a9 00		lda #$00	                lda #$00

9230	.eacc						callUSERV:
9231	.eacc		6c 00 02	jmp ($0200)	                jmp (USERV)

9233	.eacf						osbyte7E:                       ;ec3c
9234	.eacf		a2 00		ldx #$00	                ldx #$00
9235	.ead1		24 ff		bit $ff		                bit $FF
9236	.ead3		10 14		bpl $eae9	                bpl osbyte7C
9237	.ead5		ad 76 02	lda $0276	                lda escapeEffects
9238	.ead8		d0 0d		bne $eae7	                bne LEC54
9239	.eada		58		cli		                cli
9240	.eadb		9c 69 02	stz $0269	                stz pagedModeCounter
9241	.eade		20 73 f1	jsr $f173	                jsr withTerminalROM
9242	.eae1		20 49 ac	jsr $ac49	                jsr starEXEC
9243	.eae4		20 ef e7	jsr $e7ef	                jsr LE947
9244	.eae7						LEC54:
9245	.eae7		a2 ff		ldx #$ff	                ldx #$FF
9246	.eae9						osbyte7C: ;EC56
9247	.eae9		18		clc		                clc
9248	.eaea						osbyte7D: ;EC57
9249							                .if includeTubeSupport
9250							                .if version==350
9254							                .endif
9255	.eaea		66 ff		ror $ff		                ror escapeFlag
9256	.eaec		2c 7a 02	bit $027a	                bit tubePresence
9257	.eaef		10 32		bpl $eb23	                bpl LECD9
9258	.eaf1		4c 03 04	jmp $0403	                jmp tubeHost.copyEscapeStatus
9268							                .endif

9270							;-------------------------------------------------------------------------

9272							                .if version<400
9280							                .endif

9282							;-------------------------------------------------------------------------
9283							;
9284							; ;OSBYTE 8 (&08) Write RS423 transmit rate
9285							;
9286							; This call sets the RS423 baud rate for transmitting data. The actual format of
9287							; the data is set using OSBYTE 156/&9C (see below).
9288							;
9289							; Entry parameters :
9290							; X=0 selects 9600 baud
9291							; X=1 selects 75 baud
9292							; X=2 selects 150 baud
9293							; X=3 selects 300 baud
9294							; X=4 selects 1200 baud
9295							; X=5 selects 2400 baud
9296							; X=6 selects 4800 baud
9297							; X=7 selects 9600 baud
9298							; X=8 selects 19200 baud
9299							; Y=0
9300							;
9301							; On exit : X=Y=<old serial ACIA control register contents>

9303							                .if version!=400
9307							                .endif

9309							;-------------------------------------------------------------------------
9310							;
9311							; OSBYTE 7 (&07) Write RS423 receive rate
9312							;
9313							; This call sets the RS423 baud rate for receiving data. The actual
9314							; format of the data is set using OSBYTE 156/&9C (see below).
9315							;
9316							; Entry parameters :
9317							; X=0 selects 9600 baud
9318							; X=1 selects 75 baud
9319							; X=2 selects 150 baud
9320							; X=3 selects 300 baud
9321							; X=4 selects 1200 baud
9322							; X=5 selects 2400 baud
9323							; X=6 selects 4800 baud
9324							; X=7 selects 9600 baud
9325							; X=8 selects 19200 baud
9326							; Y=0
9327							;
9328							; On exit : X=Y=<old serial ACIA control register contents>

9330							                .if version!=400
9357							                .endif

9359							                .if version==400
9360	.eaf4						osbyte08:
9361	.eaf4						osbyte07:
9362	.eaf4						LEC89:
9363	.eaf4						LEC90:
9364							                .endif

9366							;-------------------------------------------------------------------------

9368							; Y=0 on entry.

9370	.eaf4						osbyte09:                       ;ec92
9371	.eaf4		c8		iny		                iny
9372	.eaf5		18		clc		                clc
9373	.eaf6						osbyte0A:                                    ;ec94
9374	.eaf6		b9 52 02	lda $0252,y	                lda firstFlashColourDuration,y
9375	.eaf9		48		pha		                pha
9376	.eafa		8a		txa		                txa
9377	.eafb		99 52 02	sta $0252,y	                sta firstFlashColourDuration,y
9378	.eafe		7a		ply		                ply
9379	.eaff		ad 51 02	lda $0251	                lda flashCounter
9380	.eb02		d0 1d		bne $eb21	                bne LEC8F
9381	.eb04		8e 51 02	stx $0251	                stx flashCounter
9382	.eb07		ad 48 02	lda $0248	                lda vcontrolRegister
9383	.eb0a		08		php		                php
9384	.eb0b		6a		ror a		                ror a
9385	.eb0c		28		plp		                plp
9386	.eb0d		2a		rol a		                rol a
9387	.eb0e		8d 48 02	sta $0248	                sta vcontrolRegister
9388	.eb11		8d 20 fe	sta $fe20	                sta VCONTROL
9389	.eb14		80 0b		bra $eb21	                bra LEC8F

9391							;-------------------------------------------------------------------------
9392							;
9393							; OSBYTE 2 (&02) Specify input stream
9394							;
9395							; Input may be taken from either the keyboard (by default) or the
9396							; RS423 port. This call specifies the selection for all subsequent
9397							; input.
9398							;
9399							; Entry parameters :
9400							; X=0 selects keyboard input and disables RS423
9401							; X=1 selects and enables RS423 input
9402							; X=2 selects keyboard input and enables RS423
9403							; Y=0
9404							;
9405							; On exit : X=0 indicates previous input was from the keyboard
9406							;           X=1 indicates previous input was from RS423
9407							;           Y is undefined
9408							;
9409							; D.2-18
9410							                .if version!=400
9433							                .endif

9435							;-------------------------------------------------------------------------
9436							;
9437							; OSBYTE 13 (&0D) Disable event
9438							;
9439							; All events are assigned a unique number and this call provides a
9440							; means of disabling specific events.
9441							;
9442							; Entry parameters:
9443							; X = event number
9444							;
9445							; On exit: X = Y = <old enable state> (0=disabled)
9446	.eb16						osbyte0D:
9447	.eb16		98		tya		                tya             ;A=0

9449							;-------------------------------------------------------------------------
9450							;
9451							; OSBYTE 14 (&0E) Enable event
9452							;
9453							; This call provides a means of enabling specific events.
9454							;
9455							;
9456	.eb17						osbyte0E:
9457	.eb17		e0 0a		cpx #$0a	                cpx #eventMax+1
9458							                .if version!=400
9460							                .else
9461	.eb19		b0 07		bcs $eb22	                bcs LEB22
9462							                .endif
9463	.eb1b		bc bf 02	ldy $02bf,x	                ldy eventEnabledFlags,x
9464	.eb1e		9d bf 02	sta $02bf,x	                sta eventEnabledFlags,x
9465							                .if version!=400
9467							                .else
9468	.eb21						LEC8F:
9469	.eb21						LEB21:
9470	.eb21		98		tya		                tya
9471	.eb22						LEB22:
9472	.eb22		aa		tax		                tax
9473	.eb23						LECD9:
9474	.eb23		60		rts		                rts
9475							                .endif

9477							;-------------------------------------------------------------------------
9478							;
9479							; OSBYTE 16 (&10) Write number of ADC channels
9480							;
9481							; By default, each of the four ADC channels is sampled and converted
9482							; in turn so that each reading is updated every 40 milliseconds. This
9483							; call enables the number of channels to be changed so that if, for
9484							; example, only two channels are required, each will be updated every
9485							; 20 milliseconds.
9486							;
9487							                .if version!=400
9498							                .endif

9500							;-------------------------------------------------------------------------
9501							;
9502							; OSBYTE 129 (&81) Read key with time limit
9503							;
9504							; This call may be used to read a key from the keyboard subject to a
9505							; specified time limit or to perform a keyboard scan for a specified
9506							; key depression.

9508	.eb24						osbyte81:
9509	.eb24		98		tya		                tya
9510	.eb25		30 0a		bmi $eb31	                bmi LED01          ;taken if scanning for specific key
9511	.eb27		20 ca e6	jsr $e6ca	                jsr osbyte81Timed
9512	.eb2a		b0 03		bcs $eb2f	                bcs LECFF                 ;taken if timed out or error
9513	.eb2c		aa		tax		                tax                       ;X = ASCII char
9514	.eb2d						LECFD:
9515	.eb2d		a9 00		lda #$00	                lda #$00
9516	.eb2f						LECFF:
9517	.eb2f		a8		tay		                tay
9518	.eb30		60		rts		                rts

9520	.eb31						LED01:
9521	.eb31		8a		txa		                txa
9522	.eb32		f0 10		beq $eb44	                beq LED14
9523	.eb34		49 7f		eor #$7f	                eor #$7F
9524	.eb36		aa		tax		                tax
9525	.eb37		20 f1 f6	jsr $f6f1	                jsr callKEYV
9526	.eb3a		2a		rol a		                rol a
9527							                ; fall through

9529							;-------------------------------------------------------------------------

9531	.eb3b						osbyte82:
9532	.eb3b		a2 ff		ldx #$ff	                ldx #$FF
9533	.eb3d		a0 ff		ldy #$ff	                ldy #$FF
9534	.eb3f		b0 02		bcs $eb43	                bcs LEB13                    ;if OSBYTE $82, done
9535	.eb41		e8		inx		                inx
9536	.eb42		c8		iny		                iny
9537	.eb43						LEB13:
9538	.eb43		60		rts		                rts

9540	.eb44						LED14:
9541							                .if version==320
9543							                .elsif version==400
9544	.eb44		a2 f7		ldx #$f7	                ldx #$f7
9551							                .endif
9552	.eb46		80 e5		bra $eb2d	                bra LECFD

9554	.eb48						LED18:
9555							                .if version==400
9556	.eb48		10 f9		bpl $eb43	                bpl LEB13
9557							                .endif
9558	.eb4a		8a		txa		                txa
9559	.eb4b		49 ff		eor #$ff	                eor #$FF
9560	.eb4d		aa		tax		                tax
9561	.eb4e		e0 02		cpx #$02	                cpx #$02
9562							                ; fall through

9564							;-------------------------------------------------------------------------

9566	.eb50						countBufferViaCNPV:
9567	.eb50		b8		clv		                clv
9568	.eb51		80 03		bra $eb56	                bra callCNPV

9570	.eb53						purgeBufferViaCNPV:
9571	.eb53		2c 5e e3	bit $e35e	                bit valueFF                  ;V=1
9572	.eb56						callCNPV:
9573	.eb56		6c 2e 02	jmp ($022e)	                jmp (CNPV)

9575							;-------------------------------------------------------------------------

9577							                .if version!=400
9587							                .endif

9589							;-------------------------------------------------------------------------

9591							                .if version!=400
9612							                .endif

9614							;-------------------------------------------------------------------------

9616							                .if version!=400
9635							                .endif

9637							;-------------------------------------------------------------------------
9638							;
9639							; OSBYTE $70
9640							;
9641							; D.2-31
9642							;
9643	.eb59						osbyte70:                       ;ed58
9644	.eb59		20 71 eb	jsr $eb71	                jsr osbyte7071
9645	.eb5c		0a		asl a		                asl a
9646	.eb5d		f0 04		beq $eb63	                beq clearACCCCONE
9647	.eb5f						LED5E:
9648	.eb5f		0c 34 fe	tsb $fe34	                tsb ACCCON
9649	.eb62		60		rts		                rts

9651	.eb63						clearACCCCONE:
9652	.eb63		a9 02		lda #$02	                lda #ACCCON.E
9653	.eb65						LED64:
9654	.eb65		1c 34 fe	trb $fe34	                trb ACCCON
9655	.eb68		60		rts		                rts

9657							;-------------------------------------------------------------------------

9659	.eb69						osbyte71:                       ;ed68
9660	.eb69		20 71 eb	jsr $eb71	                jsr osbyte7071
9661	.eb6c		d0 f1		bne $eb5f	                bne LED5E
9662	.eb6e		1a		inc a		                inc a
9663	.eb6f		80 f4		bra $eb65	                bra LED64

9665							;-------------------------------------------------------------------------
9666							;
9667							; Handle OSBYTE $70 or OSBYTE $71
9668							;
9669							; Entry: A=$70 or $71
9670							;
9671	.eb71						osbyte7071:
9672	.eb71		a8		tay		                tay
9673	.eb72		8a		txa		                txa
9674							                .cerror vduDriverMemory+1!=displayMemory
9675	.eb73		99 1a 02	sta $021a,y	                sta vduDriverMemory-$70,y
9676	.eb76		d0 09		bne $eb81	                bne LED80
9677	.eb78		a5 d0		lda $d0		                lda STATE
9678	.eb7a		29 10		and #$10	                and #STATE.isShadowMode
9679	.eb7c		f0 06		beq $eb84	                beq LED83
9680	.eb7e						LED7D:
9681	.eb7e		a9 01		lda #$01	                lda #$01
9682	.eb80		60		rts		                rts

9684	.eb81						LED80:
9685	.eb81		3a		dec a		                dec a
9686	.eb82		d0 fa		bne $eb7e	                bne LED7D
9687	.eb84						LED83:
9688	.eb84		60		rts		                rts

9690							;-------------------------------------------------------------------------

9692							; OSBYTE &6E (110), &6F (111)
9693							; ===========================
9694							; Pass to sideways ROMs
9695	.eb85						osbyteUnused:                   ;ed84
9696	.eb85		a2 07		ldx #$07	                ldx #romServiceCallUnrecognisedOSBYTE
9697	.eb87		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
9698	.eb8a		a6 f0		ldx $f0		                ldx originalX
9699							                .if version!=400
9701							                .endif
9702	.eb8c		60		rts		                rts

9704							;-------------------------------------------------------------------------

9706							                .if version!=350
9707	.eb8d						osbyteA1:
9708	.eb8d		20 73 f1	jsr $f173	                jsr withTerminalROM
9709	.eb90		4c 46 9b	jmp $9b46	                jmp readCMOSByte
9710							                .endif

9712							;-------------------------------------------------------------------------

9714							                .if version!=350
9715	.eb93						osbyteA2:
9716	.eb93		20 73 f1	jsr $f173	                jsr withTerminalROM
9717	.eb96		4c 70 9b	jmp $9b70	                jmp writeCMOSByte
9718							                .endif

9720							;-------------------------------------------------------------------------
9721							;
9722							; OSBYTE 140 (&8C) Select Cassette Filing System [MasRef D.2-43]
9723							; OSBYTE 141 (&8D) Select ROM Filing System [MasRef D.2-43]
9724							;
9725	.eb99						osbyte8C8D:
9726	.eb99		20 c5 eb	jsr $ebc5	                jsr selectROMOrTAPEByOSBYTE
9727	.eb9c		ad 34 fe	lda $fe34	                lda ACCCON                    ; Save ACCON register
9728	.eb9f		48		pha		                pha
9729	.eba0		20 b9 eb	jsr $ebb9	                jsr selectHAZEL         ; Page Hazel workspace in
9730	.eba3		ae 01 df	ldx $df01	                ldx hazel.activeFS
9731	.eba6		8e 00 df	stx $df00	                stx hazel.currentFS
9732	.eba9		a9 0f		lda #$0f	                lda #terminalROM
9733	.ebab		8d 03 df	sta $df03	                sta hazel.currentFSROM
9734	.ebae		68		pla		                pla                          ; Restore ACCON
9735	.ebaf						selectMOSOrHAZEL:                                       ;edb0
9736	.ebaf		29 08		and #$08	                and #ACCCON.Y   ;get just the HAZEL/MOS bit
9737	.ebb1		d0 08		bne $ebbb	                bne setACCCONBits      ;branch taken if HAZEL at $c000
9738	.ebb3						selectMOS:
9739	.ebb3		a9 08		lda #$08	                lda #ACCCON.Y
9740	.ebb5		1c 34 fe	trb $fe34	                trb ACCCON      ;page in MOS at $c000
9741	.ebb8		60		rts		                rts

9743	.ebb9						selectHAZEL:
9744	.ebb9		a9 08		lda #$08	                lda #ACCCON.Y
9745	.ebbb						setACCCONBits:
9746	.ebbb		0c 34 fe	tsb $fe34	                tsb ACCCON      ;page in HAZEL at $c000
9747	.ebbe		60		rts		                rts

9749							;-------------------------------------------------------------------------

9751							                .if version==400
9752	.ebbf						LEBBF:
9753	.ebbf		20 44 ec	jsr $ec44	                jsr LEE64
9754	.ebc2		20 dd ef	jsr $efdd	                jsr LF1EE
9755							                .endif

9757							;-------------------------------------------------------------------------
9758							;
9759							; Select ROM or TAPE.
9760							;
9761							; Two entry points: selectROMOrTAPEByOSBYTE picks FS by OSBYTE number
9762							; ($8c=TAPE, $8d=ROM), and selectROMOrTAPE picks FS by number (0=TAPE,
9763							; 1=ROM).
9764							;
9765							; entry:
9766							;
9767							; A = FS to select
9768							;
9769	.ebc5						selectROMOrTAPEByOSBYTE:
9770							                .if version==400

9772	.ebc5						LEDD0:
9773	.ebc5		a9 02		lda #$02	                lda #2
9774	.ebc7		8d 47 02	sta $0247	                sta cfsRFSFSSwitch

9776	.ebca		a9 06		lda #$06	                lda #6
9777	.ebcc		20 d4 ef	jsr $efd4	                jsr callFSCV

9779	.ebcf		64 ce		stz $ce		                stz $ce

9818							                .endif

9820	.ebd1		a2 0e		ldx #$0e	                ldx #defaultVectorTable.fsVectors.end-defaultVectorTable.fsVectors ; Prepare to set 7 vectors
9821	.ebd3						LEDF3:
9822	.ebd3		bd f8 e2	lda $e2f8,x	                lda defaultVectorTable.fsVectors-1,x ; Set filing
9823							                                                     ; system vectors
9824							                                                     ; to point to
9825							                                                     ; extended
9826							                                                     ; vectors
9827	.ebd6		9d 11 02	sta $0211,x	                sta FILEV-1,x
9828	.ebd9		ca		dex		                dex
9829	.ebda		d0 f7		bne $ebd3	                bne LEDF3
9830	.ebdc		20 dd ef	jsr $efdd	                jsr LF1EE                    ; Set extended vectors
9831	.ebdf		64 c2		stz $c2		                stz $C2                      ; Set Progress=idle
9832	.ebe1		a2 0f		ldx #$0f	                ldx #romServiceCallVectorsClaimed ; Send service call &0F - vectors changed

9834							;-------------------------------------------------------------------------
9835							;
9836							; OSBYTE 143 (&8F) Issue paged ROM service request [MasRef D.2-44]
9837							;
9838	.ebe3						osbyte8F: .proc                    ;ee03
9839	.ebe3		5a		phy		                phy
9840	.ebe4		da		phx		                phx                          ; Send service call
9841	.ebe5		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
9842	.ebe8		fa		plx		                plx
9843	.ebe9		e0 0f		cpx #$0f	                cpx #romServiceCallVectorsClaimed ; If VectorsClaimed,
9844							                                                  ; hook FileSwitch
9845							                                                  ; back in
9846	.ebeb		f0 36		beq $ec23	                beq handleVectorsClaimed
9847	.ebed		1a		inc a		                inc a       ; If claimed, check for
9848							                            ; InitialiseFilingSystem or
9849							                            ; UnrecognisedCommand
9850	.ebee		3a		dec a		                dec a       ;Z=1 if claimed
9851	.ebef		f0 03		beq $ebf4	                beq wasClaimed  ;branch taken if claimed
9852	.ebf1						done:
9853	.ebf1		fa		plx		                plx             ; Return with result in X, EQ=Claimed
9854	.ebf2		aa		tax		                tax
9855	.ebf3		60		rts		                rts

9857	.ebf4						wasClaimed:
9858	.ebf4		e0 12		cpx #$12	                cpx #romServiceCallInitialiseFilingSystem
9859	.ebf6		f0 04		beq $ebfc	                beq +
9860	.ebf8		e0 04		cpx #$04	                cpx #romServiceCallUnrecognisedCommand
9861	.ebfa		d0 f5		bne $ebf1	                bne done
9862	.ebfc						+

9864							; handle InitialiseFilingSystem ($12) or UnrecognisedCommand ($04)

9866	.ebfc		7a		ply		                ply                     ;Y=service call arg
9867	.ebfd		48		pha		                pha                     ;save A (though actually it's
9868							                                        ;always $00...)
9869	.ebfe		ad 34 fe	lda $fe34	                lda ACCCON
9870	.ec01		48		pha		                pha                     ;save ACCCON
9871	.ec02		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
9872	.ec05		38		sec		                sec
9873	.ec06		6e 00 df	ror $df00	                ror hazel.currentFS ;set currentFS bit 7
9874	.ec09						LEE29:
9875	.ec09		5a		phy		                phy             ;save ROM service call argument
9876	.ec0a		a9 00		lda #$00	                lda #$00
9877	.ec0c		a8		tay		                tay
9878	.ec0d		20 e8 f8	jsr $f8e8	                jsr callARGSV   ;A=0, Y=0 - get active FS number
9879	.ec10		8d 01 df	sta $df01	                sta hazel.activeFS ;save active FS number
9880	.ec13		2c 00 df	bit $df00	                bit hazel.currentFS
9881	.ec16		10 03		bpl $ec1b	                bpl LEE3B
9882	.ec18		20 fe ef	jsr $effe	                jsr osbyte6D
9883	.ec1b						LEE3B:
9884	.ec1b		7a		ply		                ply
9885	.ec1c		68		pla		                pla
9886	.ec1d		20 af eb	jsr $ebaf	                jsr selectMOSOrHAZEL
9887	.ec20		68		pla		                pla
9888	.ec21		aa		tax		                tax
9889	.ec22		60		rts		                rts

9891	.ec23						handleVectorsClaimed:
9892	.ec23		7a		ply		                ply
9893	.ec24		48		pha		                pha
9894	.ec25		ad 34 fe	lda $fe34	                lda ACCCON
9895	.ec28		48		pha		                pha
9896	.ec29		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
9897	.ec2c		ad 1e 02	lda $021e	                lda FSCV+0
9898	.ec2f		8d da df	sta $dfda	                sta hazel.activeFSCV+0
9899	.ec32		ad 1f 02	lda $021f	                lda FSCV+1
9900	.ec35		8d db df	sta $dfdb	                sta hazel.activeFSCV+1
9901	.ec38		a9 39		lda #$39	                lda #<fileswitchFSCEntryPoint
9902	.ec3a		8d 1e 02	sta $021e	                sta FSCV+0
9903	.ec3d		a9 fa		lda #$fa	                lda #>fileswitchFSCEntryPoint
9904	.ec3f		8d 1f 02	sta $021f	                sta FSCV+1
9905	.ec42		80 c5		bra $ec09	                bra LEE29
9906							                .pend

9908							;-------------------------------------------------------------------------

9910	.ec44						LEE64:
9911	.ec44		a9 a1		lda #$a1	                lda #$A1
9912	.ec46		85 e3		sta $e3		                sta $E3
9913	.ec48		a9 19		lda #$19	                lda #$19
9914	.ec4a		8d d1 03	sta $03d1	                sta $03D1
9915	.ec4d		a9 04		lda #$04	                lda #$04
9916	.ec4f		04 e2		tsb $e2		                tsb $E2
9917	.ec51		60		rts		                rts

9919							;-------------------------------------------------------------------------
9920							;
9921							; Pass service call around sideways ROMs
9922							;
9923							; Entry:
9924							; X=service call number
9925							; Y=any parameters
9926							;
9927							; Exit:
9928							; X=0 or preserved
9929							; Y=any returned parameters
9930							; EQ=call claimed if called directly
9931							;
9932	.ec52						makeROMServiceCall: .proc                    ;ee72
9933	.ec52		a5 f4		lda $f4		                lda $F4         ; Save current ROM
9934	.ec54		48		pha		                pha
9935	.ec55		ad 34 fe	lda $fe34	                lda ACCCON      ; Save current paging state
9936	.ec58		48		pha		                pha
9937	.ec59		20 b9 eb	jsr $ebb9	                jsr selectHAZEL ; Page in Hazel
9938	.ec5c		8a		txa		                txa             ; Pass service call number to A
9939	.ec5d		a2 0f		ldx #$0f	                ldx #$0F     ; Start at ROM 15, and always call ROM 15
9940	.ec5f		80 05		bra $ec66	                bra callServiceEntry
9941	.ec61						callServiceEntriesLoop:
9942	.ec61		3c a1 02	bit $02a1,x	                bit romInformationTable,x ;check if ROM X has a service entry
9943	.ec64		10 0b		bpl $ec71	                bpl nextROM       ;branch taken if no service entry
9944	.ec66						callServiceEntry:
9945	.ec66		20 8e e5	jsr $e58e	                jsr selectROMX  ; Page in ROM X
9946	.ec69		20 03 80	jsr $8003	                jsr $8003       ; Call ROM service entry point
9947	.ec6c		aa		tax		                tax             ; X = service call result
9948	.ec6d		f0 05		beq $ec74	                beq done       ;branch taken if service call claimed
9949	.ec6f		a6 f4		ldx $f4		                ldx $F4         ; Get ROM number
9950	.ec71						nextROM:
9951	.ec71		ca		dex		                dex       ; Step down to next ROM, loop until all done
9952	.ec72		10 ed		bpl $ec61	                bpl callServiceEntriesLoop

9954	.ec74						done:
9955	.ec74		68		pla		                pla                          ; Restore paging state
9956	.ec75		20 af eb	jsr $ebaf	                jsr selectMOSOrHAZEL
9957	.ec78		68		pla		                pla                          ; Restore current ROM
9958	.ec79		20 9f e5	jsr $e59f	                jsr selectROMA
9959	.ec7c		8a		txa		                txa                          ; Pass claim/noclaim to A
9960	.ec7d		60		rts		                rts
9961							                .pend

9963							;-------------------------------------------------------------------------

9965							; OSBYTE &6B (107) - Select memory for direct access
9966							; ==============================================
9967	.ec7e						osbyte6B:                       ;ee9e
9968	.ec7e		a0 20		ldy #$20	                ldy #$20                     ; Y=&20 to change 1MHz bit
9969	.ec80		80 02		bra $ec84	                bra LEEA4

9971							;-------------------------------------------------------------------------

9973							; OSBYTE &6C (108) - Select memory for direct access
9974							; ==============================================
9975	.ec82						osbyte6C:
9976	.ec82		a0 04		ldy #$04	                ldy #ACCCON.X                ; Y=&04 to change RAM bit
9977	.ec84						LEEA4:
9978	.ec84		98		tya		                tya                          ; Clear RAM or 1MHz bit
9979	.ec85		1c 34 fe	trb $fe34	                trb ACCCON
9980	.ec88		8a		txa		                txa                          ; If X=0, exit with normal RAM/1MHz selected
9981	.ec89		f0 05		beq $ec90	                beq LEEB0
9982							                .if correctOSBYTE6B6C
9984							                .else
9985	.ec8b		a9 04		lda #$04	                lda #ACCCON.X                ; BUG! This should be TYA
9986							                .endif
9987	.ec8d		0c 34 fe	tsb $fe34	                tsb ACCCON                   ; Page in shadow RAM
9988	.ec90						LEEB0:
9989	.ec90		60		rts		                rts                          ; X preserved, Y=&04 or &20

9991							;-------------------------------------------------------------------------

9993							osword06Macro: .macro
10000							                .endmacro

10002							LEF1BMacro: .macro
10014							                .endmacro

10016							;-------------------------------------------------------------------------

10018							                .if version>=350
10019	.ec91						osword06:
9994	.ec91		20 5a ed	jsr $ed5a	                jsr getAddressFromOSWORDParameterBlock
9995	.ec94		b1 f0		lda ($f0),y	                lda (originalX),y
9996	.ec96		92 fa		sta ($fa)	                sta (SEIWKA)
9997	.ec98						ret:
9998	.ec98		a9 00		lda #$00	                lda #$00
9999	.ec9a		60		rts		                rts
10020	.ec9b						LEF1B:
10003	.ec9b		a5 eb		lda $eb		                lda $EB
10004	.ec9d		30 f9		bmi $ec98	                bmi osword06.ret
10005	.ec9f		ad 57 02	lda $0257	                lda spoolFileHandle
10006	.eca2		d0 f4		bne $ec98	                bne osword06.ret
10007	.eca4		a9 08		lda #$08	                lda #$08
10008	.eca6		25 e2		and $e2		                and $E2
10009	.eca8		d0 04		bne $ecae	                bne LEF2E
10010	.ecaa		a9 88		lda #$88	                lda #$88
10011	.ecac		25 bb		and $bb		                and $BB
10012	.ecae						LEF2E:
10013	.ecae		60		rts		                rts
10021							                .endif

10023							;-------------------------------------------------------------------------

10025							                .if version>=500
10055							                .endif

10057							;-------------------------------------------------------------------------

10059							                .if version>=350
10060	.ecaf						selectTerminalROMAndOSWORD0E:
10061	.ecaf		c9 03		cmp #$03	                cmp #3
10062	.ecb1		b0 67		bcs $ed1a	                bcs handleUnrecognisedOSWORD
10063	.ecb3		20 73 f1	jsr $f173	                jsr withTerminalROM
10064	.ecb6		4c 48 9a	jmp $9a48	                jmp osword0E
10065							                .endif

10067							;-------------------------------------------------------------------------

10069							                .if version>=500||version==350
10075							                .endif

10077							;-------------------------------------------------------------------------


10080							; OSBYTE
10081							; ======
10082	.ecb9						osbyteEntryPoint:
10083	.ecb9		48		pha		                pha
10084	.ecba		08		php		                php
10085	.ecbb		78		sei		                sei
10086	.ecbc		85 ef		sta $ef		                sta originalA
10087	.ecbe		86 f0		stx $f0		                stx originalX
10088	.ecc0		84 f1		sty $f1		                sty originalY
10089	.ecc2		a2 07		ldx #$07	                ldx #romServiceCallUnrecognisedOSBYTE
10090	.ecc4		c9 6b		cmp #$6b	                cmp #$6B
10091	.ecc6		90 42		bcc $ed0a	                bcc osbyte00To6A
10092	.ecc8		c9 a6		cmp #$a6	                cmp #$A6
10093	.ecca		90 09		bcc $ecd5	                bcc osbyte6BToA5
10094	.eccc		c9 a6		cmp #$a6	                cmp #$A6
10095	.ecce		90 4e		bcc $ed1e	                bcc handleUnrecognisedOSBYTEOrOSWORD       ;??? - wait... didn't we just do this?

10097	.ecd0						osbyteA6ToFF:
10098	.ecd0		18		clc		                clc
10099	.ecd1						osbyteOrUSERV:      ;call OSBYTE A6+ routine if C=0; call USERV if C=1
10100	.ecd1		a9 a6		lda #$a6	                lda #$A6
10101	.ecd3		69 00		adc #$00	                adc #$00
10102							                .if version<350
10105							                .elsif version>=350
10106	.ecd5						osbyte6BToA5:
10107							                ; map $6b-$a5 to $46-$80
10108	.ecd5		e9 24		sbc #$24	                sbc #$24
10109	.ecd7						osbyte44To45:
10110							                ; map $44-$80 $1a-$56
10111	.ecd7		e9 2a		sbc #$2a	                sbc #$2A
10112							                .endif
10113	.ecd9						osbyteUseTable:
10114	.ecd9		0a		asl a		                asl a           ;table is of words
10115	.ecda		38		sec		                sec
10116	.ecdb						callOSBYTEOrOSWORDFromTable:
10117	.ecdb		84 f1		sty $f1		                sty originalY
10118	.ecdd		a8		tay		                tay             ;get table offset in Y
10119	.ecde		2c 5e 02	bit $025e	                bit econetInterceptionStatus
10120	.ece1		10 07		bpl $ecea	                bpl LEEE0             ;taken if no Econet interception
10121	.ece3		8a		txa		                txa
10122							                .cerror (netOSBYTEAttempted!=romServiceCallUnrecognisedOSBYTE),"net/rom reason codes mismatch"
10123							                .cerror (netOSWORDAttempted!=romServiceCallUnrecognisedOSWORD),"net/rom reason codes mismatch"
10124	.ece4		b8		clv		                clv
10125	.ece5		20 95 e9	jsr $e995	                jsr callNETV
10126	.ece8		70 1a		bvs $ed04	                bvs LEEFA
10127	.ecea						LEEE0:
10128							                .if version>=500
10135							                .endif
10136							                .if version==350
10141							                .else
10142	.ecea		b9 f5 e9	lda $e9f5,y	                lda osbyteAndOSWORDRoutineTable+1,y
10143	.eced		85 fb		sta $fb		                sta SEIWKB
10144	.ecef		b9 f4 e9	lda $e9f4,y	                lda osbyteAndOSWORDRoutineTable,y
10145	.ecf2		85 fa		sta $fa		                sta SEIWKA
10146							                .endif
10147							                .if version>=500
10154							                .endif
10155	.ecf4		a5 ef		lda $ef		                lda originalA
10156	.ecf6		a4 f1		ldy $f1		                ldy originalY
10157	.ecf8		b0 04		bcs $ecfe	                bcs +
10158	.ecfa		a0 00		ldy #$00	                ldy #$00            ;??? - is this actually desirable?
10159	.ecfc		b2 f0		lda ($f0)	                lda ($F0)           ;fetch 0th byte of parameter block
10160	.ecfe						+
10161	.ecfe		38		sec		                sec
10162							                .if version==350
10164							                .else
10165	.ecff		a6 f0		ldx $f0		                ldx originalX

10167							; on entry to the OSBYTE handlers, C=1, N/Z set as per X.

10169	.ed01		20 ce f6	jsr $f6ce	                jsr callSEIWKA
10170							                .endif
10171	.ed04						LEEFA:
10172	.ed04		6a		ror a		                ror a
10173	.ed05		28		plp		                plp
10174	.ed06		2a		rol a		                rol a
10175	.ed07		68		pla		                pla
10176	.ed08		b8		clv		                clv
10177	.ed09		60		rts		                rts

10179	.ed0a						osbyte00To6A:
10180	.ed0a		a0 00		ldy #$00	                ldy #$00        ;Y=0 on entry for this lot
10181	.ed0c		c9 1a		cmp #$1a	                cmp #$1A        ;OSBYTE <=$19 is table-driven
10182	.ed0e		90 c9		bcc $ecd9	                bcc osbyteUseTable ;taken if OSBYTE $00-$19
10183							                .if version>=350
10184	.ed10		c9 44		cmp #$44	                cmp #$44
10185	.ed12		f0 c3		beq $ecd7	                beq osbyte44To45
10186	.ed14		c9 45		cmp #$45	                cmp #$45
10187	.ed16		f0 bf		beq $ecd7	                beq osbyte44To45
10188							                .endif
10189	.ed18		80 04		bra $ed1e	                bra handleUnrecognisedOSBYTEOrOSWORD

10191	.ed1a						handleUnrecognisedOSWORD:
10192	.ed1a		a2 08		ldx #$08	                ldx #romServiceCallUnrecognisedOSWORD
10193	.ed1c		68		pla		                pla
10194	.ed1d		68		pla		                pla
10195	.ed1e						handleUnrecognisedOSBYTEOrOSWORD:
10196	.ed1e		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
10197							                .if version<500&&version!=350
10198	.ed21		d0 04		bne $ed27	                bne LEF15
10201							                .endif
10202	.ed23		a6 f0		ldx $f0		                ldx originalX
10203	.ed25		80 dd		bra $ed04	                bra LEEFA
10204							                .if version<500&&version!=350
10205	.ed27						LEF15:
10206	.ed27		28		plp		                plp
10207	.ed28		68		pla		                pla
10208	.ed29		2c 5e e3	bit $e35e	                bit valueFF
10209	.ed2c		60		rts		                rts
10210							                .endif

10212							;-------------------------------------------------------------------------

10214							                .if version<350
10216							                .endif

10218							;-------------------------------------------------------------------------
10219							;
10220							; OSWORD 14 (&0E) Read CMOS clock [MasRef D.3-22]
10221							;
10222							                .if version<350
10228							                .endif

10230							;-------------------------------------------------------------------------
10231							;
10232							; Entry point for OSWORD.
10233							;
10234							; D.3-3
10235							;
10236							                .if version<500
10237	.ed2d						oswordEntryPoint:
10238	.ed2d		48		pha		                pha             ;save OSWORD request
10239	.ed2e		08		php		                php
10240	.ed2f		78		sei		                sei
10241	.ed30		85 ef		sta $ef		                sta originalA
10242	.ed32		86 f0		stx $f0		                stx originalX
10243	.ed34		84 f1		sty $f1		                sty originalY
10244	.ed36		a2 08		ldx #$08	                ldx #romServiceCallUnrecognisedOSWORD
10245	.ed38		c9 e0		cmp #$e0	                cmp #$E0
10246	.ed3a		b0 95		bcs $ecd1	                bcs osbyteOrUSERV ;taken if OSWORD $E0 or higher -
10247							                                  ;these go via USERV

10249							                .if version==320
10260							                .else

10262	.ed3c		c9 10		cmp #$10	                cmp #$10
10263	.ed3e		90 0d		bcc $ed4d	                bcc osword00To0F
10264	.ed40		c9 44		cmp #$44	                cmp #$44
10265	.ed42		b0 da		bcs $ed1e	                bcs handleUnrecognisedOSBYTEOrOSWORD
10266	.ed44		c9 42		cmp #$42	                cmp #$42
10267	.ed46		b0 03		bcs $ed4b	                bcs osword42To43
10268	.ed48		38		sec		                sec
10269	.ed49		80 d3		bra $ed1e	                bra handleUnrecognisedOSBYTEOrOSWORD

10271	.ed4b						osword42To43:
10272							                .cerror (osword42AndAboveRoutineTable-oswordRoutineTable)%2!=0
10273	.ed4b		e9 33		sbc #$33	                sbc #$42-((osword42AndAboveRoutineTable-oswordRoutineTable)/2-1)
10274	.ed4d						osword00To0F:
10275							                .cerror (oswordRoutineTable-osbyteAndOSWORDRoutineTable)%2!=0
10276	.ed4d		69 59		adc #$59	                adc #(oswordRoutineTable-osbyteAndOSWORDRoutineTable)/2
10277	.ed4f		0a		asl a		                asl a
10278	.ed50		80 89		bra $ecdb	                bra callOSBYTEOrOSWORDFromTable
10279							                .endif
10280							                .endif

10282							;-------------------------------------------------------------------------
10283							;
10284							; OSWORD 5 (&05) Read byte from I/O processor memory [MasRef D.3-9]
10285							;
10286	.ed52						osword05:
10287	.ed52		20 5a ed	jsr $ed5a	                jsr getAddressFromOSWORDParameterBlock
10288	.ed55		b2 fa		lda ($fa)	                lda (SEIWKA)                 ;read byte from the address
10289	.ed57		91 f0		sta ($f0),y	                sta (originalX),y                  ;update parameter block
10290	.ed59		60		rts		                rts

10292							;-------------------------------------------------------------------------
10293							;
10294							; OSWORD 6 (&06) Write byte to I/O processor memory [MasRef D.3-9]
10295							;

10297							                .if version<350
10299							                .endif

10301							;-------------------------------------------------------------------------
10302							;
10303							; Get address from OSWORD parameter block.
10304							;
10305							; entry:
10306							;
10307							; A = 0th byte of parameter block
10308							;
10309							; Y = 0
10310							;
10311							; (originalX) = parameter block
10312							;
10313							; exit:
10314							;
10315							; (SEIWKA) = address, first two bytes from parameter block
10316							;
10317							; Y = 4 (this is just convenient for both callers)
10318							;
10319	.ed5a						getAddressFromOSWORDParameterBlock:
10320	.ed5a		85 fa		sta $fa		                sta SEIWKA
10321	.ed5c		c8		iny		                iny
10322	.ed5d		b1 f0		lda ($f0),y	                lda (originalX),y
10323	.ed5f		85 fb		sta $fb		                sta SEIWKA+1
10324	.ed61		a0 04		ldy #$04	                ldy #$04
10325	.ed63						ldxim03_rts:
10326							                .if version<400
10328							                .elsif version<500
10329	.ed63		a2 04		ldx #$04	                ldx #$04
10332							                .endif
10333	.ed65		60		rts		                rts

10335							;-------------------------------------------------------------------------
10336							;
10337							; OSBYTE 0 (&00) Display MOS version
10338							;
10339							; OSBYTE 0 has the effect of performing a BRK instruction and
10340							; displaying the MOS version number.
10341							;
10342							; Entry parameters :
10343							;
10344							; X=0 executes a BRK and displays the OS version
10345							;
10346							; X=1 executes an RTS and returns the Operating system version
10347							;
10348							; On exit : X=<OS version>
10349							;
10350							; D.2-18
10351							;
10352	.ed66						osbyte00:                       ;ef6f
10353	.ed66		d0 fb		bne $ed63	                bne ldxim03_rts ;branch taken if X<>0 - return with
10354							                                 ;X=3

10356							; do a BRK and print MOS version number.

10358	.ed68		00		brk #		                brk
10359	>ed69		f7 4d 4f 53 20 34 2e 30		                .text $f7,versionString,0
	>ed71		30 00

10361							;-------------------------------------------------------------------------
10362							;
10363							; OSWORD 7 (&07) Generate a sound [MasRef D.3-10]
10364							;
10365	.ed73						osword07:
10366	.ed73		c8		iny		                iny
10367	.ed74		b1 f0		lda ($f0),y	                lda ($F0),y
10368	.ed76		c9 20		cmp #$20	                cmp #$20
10369	.ed78		b0 a0		bcs $ed1a	                bcs handleUnrecognisedOSWORD
10370	.ed7a		88		dey		                dey
10371	.ed7b		20 ee ed	jsr $edee	                jsr LEFF6
10372	.ed7e		09 04		ora #$04	                ora #$04
10373	.ed80		aa		tax		                tax
10374	.ed81		90 05		bcc $ed88	                bcc LEF90
10375	.ed83		20 02 e8	jsr $e802	                jsr LE95A
10376	.ed86		a0 01		ldy #$01	                ldy #$01
10377	.ed88						LEF90:
10378	.ed88		20 ee ed	jsr $edee	                jsr LEFF6
10379	.ed8b		85 fa		sta $fa		                sta $FA
10380	.ed8d		08		php		                php
10381	.ed8e		a0 06		ldy #$06	                ldy #$06
10382	.ed90		b1 f0		lda ($f0),y	                lda ($F0),y
10383	.ed92		48		pha		                pha
10384	.ed93		a0 04		ldy #$04	                ldy #$04
10385	.ed95		b1 f0		lda ($f0),y	                lda ($F0),y
10386	.ed97		48		pha		                pha
10387	.ed98		a0 02		ldy #$02	                ldy #$02
10388	.ed9a		b1 f0		lda ($f0),y	                lda ($F0),y
10389	.ed9c		2a		rol a		                rol a
10390	.ed9d		3a		dec a		                dec a
10391	.ed9e		3a		dec a		                dec a
10392	.ed9f		0a		asl a		                asl a
10393	.eda0		0a		asl a		                asl a
10394	.eda1		05 fa		ora $fa		                ora $FA
10395	.eda3		20 4b e8	jsr $e84b	                jsr LE9A3
10396	.eda6		90 1e		bcc $edc6	                bcc LEFCE
10397	.eda8		68		pla		                pla
10398	.eda9		68		pla		                pla
10399	.edaa		28		plp		                plp

10401							                ; WTF... fall through to OSBYTE $75!

10403							;-------------------------------------------------------------------------
10404							;
10405							; OSBYTE 117 (&75) Read VDU status [MasRef D.2-32]
10406							;
10407	.edab						osbyte75:
10408	.edab		a6 d0		ldx $d0		                ldx STATE
10409	.edad		60		rts		                rts

10411							;-------------------------------------------------------------------------
10412							;
10413							; VDU 7 (&07) Produce BELL sound [MasRef E.3-4]
10414							;
10415	.edae						vdu7EntryPoint:
10416	.edae		08		php		                php
10417	.edaf		78		sei		                sei
10418	.edb0		ad 63 02	lda $0263	                lda bellChannel
10419	.edb3		29 07		and #$07	                and #$07
10420	.edb5		09 04		ora #$04	                ora #$04
10421	.edb7		aa		tax		                tax
10422	.edb8		ad 64 02	lda $0264	                lda bellSound
10423	.edbb		20 e8 e8	jsr $e8e8	                jsr callINSV
10424	.edbe		ad 66 02	lda $0266	                lda bellDuration
10425	.edc1		48		pha		                pha
10426	.edc2		ad 65 02	lda $0265	                lda bellFrequency
10427	.edc5		48		pha		                pha
10428	.edc6						LEFCE:
10429	.edc6		38		sec		                sec
10430	.edc7		7e 00 08	ror $0800,x	                ror $0800,x
10431	.edca		68		pla		                pla
10432	.edcb		20 e8 e8	jsr $e8e8	                jsr callINSV
10433	.edce		68		pla		                pla
10434	.edcf		20 e8 e8	jsr $e8e8	                jsr callINSV
10435	.edd2		28		plp		                plp
10436	.edd3		60		rts		                rts

10438							;-------------------------------------------------------------------------
10439							;
10440							; OSWORD 8 (&08) Define a sound envelope [MasRef D.3-14]
10441							;
10442	.edd4						osword08:
10443	.edd4		3a		dec a		                dec a                   ;get index of 1-based envelope
10444	.edd5		0a		asl a		                asl a
10445	.edd6		0a		asl a		                asl a
10446	.edd7		0a		asl a		                asl a
10447	.edd8		0a		asl a		                asl a                        ;index*16
10448	.edd9		09 0f		ora #$0f	                ora #$0F                     ;index*16+15
10449	.eddb		aa		tax		                tax                          ;
10450	.eddc		a9 00		lda #$00	                lda #$00                     ;
10451	.edde		a0 10		ldy #$10	                ldy #16             ;16 bytes of envelope data get set
10452	.ede0						-
10453	.ede0		c0 0e		cpy #$0e	                cpy #$0E                     ;
10454	.ede2		b0 02		bcs $ede6	                bcs + ;taken if last 2 bytes of data - they get initialized to $00
10455	.ede4		b1 f0		lda ($f0),y	                lda (originalX),y        ;fetch byte from OSWORD block
10456	.ede6						+
10457	.ede6		9d c0 08	sta $08c0,x	                sta envelope1Data,x          ;set envelope data bytes
10458	.ede9		ca		dex		                dex
10459	.edea		88		dey		                dey
10460	.edeb		d0 f3		bne $ede0	                bne -
10461	.eded		60		rts		                rts

10463							;-------------------------------------------------------------------------

10465	.edee						LEFF6:
10466	.edee		b1 f0		lda ($f0),y	                lda ($F0),y
10467	.edf0		c9 10		cmp #$10	                cmp #$10
10468	.edf2		29 03		and #$03	                and #$03
10469	.edf4		c8		iny		                iny
10470	.edf5		60		rts		                rts

10472							;-------------------------------------------------------------------------
10473							;
10474							; OSWORD 3 (&03) Read interval timer [MasRef D.3-8]
10475							;
10476	.edf6						osword03:
10477	.edf6		a2 0f		ldx #$0f	                ldx #$0F
10478	.edf8		80 03		bra $edfd	                bra LF005

10480							;-------------------------------------------------------------------------
10481							;
10482							; OSWORD 1 (&01) Read system clock [MasRef D.3-7]
10483							;
10484	.edfa						osword01:
10485	.edfa		ae 83 02	ldx $0283	                ldx timerSwitchState
10486	.edfd						LF005:
10487	.edfd		a0 04		ldy #$04	                ldy #$04
10488	.edff						-
10489	.edff		bd 8d 02	lda $028d,x	                lda timer0-initialTimerSwitchState,x
10490	.ee02		91 f0		sta ($f0),y	                sta (originalX),y
10491	.ee04		e8		inx		                inx
10492	.ee05		88		dey		                dey
10493	.ee06		10 f7		bpl $edff	                bpl -
10494	.ee08						rtsF010:
10495	.ee08		60		rts		                rts

10497							;-------------------------------------------------------------------------
10498							;
10499							; OSWORD 4 (&04) Write interval timer [MasRef D.3-9]
10500							;
10501	.ee09						osword04:
10502	.ee09		a9 0f		lda #$0f	                lda #intervalTimer-(timer0-initialTimerSwitchState)
10503	.ee0b		80 06		bra $ee13	                bra copyTIMEValue

10505							;-------------------------------------------------------------------------
10506							;
10507							; OSWORD 2 (&02) Write system clock [MasRef D.3-8]
10508							;
10509	.ee0d						osword02:
10510	.ee0d		ad 83 02	lda $0283	                lda timerSwitchState
10511	.ee10		49 0f		eor #$0f	                eor #$0F       ;select the timer that isn't being used
10512	.ee12		18		clc		                clc
10513	.ee13						copyTIMEValue:
10514	.ee13		48		pha		                pha
10515	.ee14		aa		tax		                tax
10516	.ee15		a0 04		ldy #$04	                ldy #$04
10517	.ee17						-
10518	.ee17		b1 f0		lda ($f0),y	                lda (originalX),y
10519	.ee19		9d 8d 02	sta $028d,x	                sta timer0-initialTimerSwitchState,x
10520	.ee1c		e8		inx		                inx
10521	.ee1d		88		dey		                dey
10522	.ee1e		10 f7		bpl $ee17	                bpl -
10523	.ee20		68		pla		                pla
10524	.ee21		b0 e5		bcs $ee08	                bcs rtsF010
10525	.ee23		8d 83 02	sta $0283	                sta timerSwitchState
10526	.ee26		60		rts		                rts

10528							;-------------------------------------------------------------------------
10529							;
10530							; OSWORD 0 (&00) Read line from input stream to memory [MasRef D.3-6]
10531							;
10532	.ee27						osword00:
10533	.ee27		a0 04		ldy #$04	                ldy #$04
10534	.ee29						LF031:
10535	.ee29		b1 f0		lda ($f0),y	                lda (originalX),y
10536							                .cerror osword0MaxLineLength+1!=osword0MinASCIICharacter
10537							                .cerror osword0MinASCIICharacter+1!=osword0MaxASCIICharacter
10538	.ee2b		99 b1 02	sta $02b1,y	                sta osword0MaxLineLength-2,y
10539	.ee2e		88		dey		                dey
10540	.ee2f		c0 02		cpy #$02	                cpy #$02
10541	.ee31		b0 f6		bcs $ee29	                bcs LF031
10542	.ee33		b1 f0		lda ($f0),y	                lda ($F0),y
10543	.ee35		85 e9		sta $e9		                sta $E9
10544	.ee37		88		dey		                dey
10545	.ee38		9c 69 02	stz $0269	                stz pagedModeCounter
10546	.ee3b		b2 f0		lda ($f0)	                lda ($F0)
10547	.ee3d		85 e8		sta $e8		                sta $E8
10548	.ee3f		58		cli		                cli
10549	.ee40		80 07		bra $ee49	                bra LF051

10551	.ee42						LF04A:
10552	.ee42		a9 07		lda #$07	                lda #$07
10553	.ee44						LF04C:
10554	.ee44		88		dey		                dey
10555	.ee45						LF04D:
10556	.ee45		c8		iny		                iny
10557	.ee46						LF04E:
10558	.ee46		20 ee ff	jsr $ffee	                jsr OSWRCH
10559	.ee49						LF051:
10560	.ee49		20 e0 ff	jsr $ffe0	                jsr OSRDCH
10561	.ee4c		b0 49		bcs $ee97	                bcs LF09F
10562	.ee4e		aa		tax		                tax
10563	.ee4f		ad 7c 02	lda $027c	                lda characterDestinationStatus
10564	.ee52		6a		ror a		                ror a
10565	.ee53		6a		ror a		                ror a
10566	.ee54		8a		txa		                txa
10567	.ee55		b0 05		bcs $ee5c	                bcs LF064
10568	.ee57		ae 6a 02	ldx $026a	                ldx vduQueueNegativeLength
10569	.ee5a		d0 ea		bne $ee46	                bne LF04E
10570	.ee5c						LF064:
10571	.ee5c		c9 7f		cmp #$7f	                cmp #$7F
10572	.ee5e		d0 07		bne $ee67	                bne LF06F
10573	.ee60		c0 00		cpy #$00	                cpy #$00
10574	.ee62		f0 e5		beq $ee49	                beq LF051
10575	.ee64		88		dey		                dey
10576	.ee65		80 df		bra $ee46	                bra LF04E

10578	.ee67						LF06F:
10579	.ee67		c9 15		cmp #$15	                cmp #$15
10580	.ee69		d0 0d		bne $ee78	                bne LF080
10581	.ee6b		98		tya		                tya
10582	.ee6c		f0 db		beq $ee49	                beq LF051
10583	.ee6e		a9 7f		lda #$7f	                lda #$7F
10584	.ee70						LF078:
10585	.ee70		20 ee ff	jsr $ffee	                jsr OSWRCH
10586	.ee73		88		dey		                dey
10587	.ee74		d0 fa		bne $ee70	                bne LF078
10588	.ee76		80 d1		bra $ee49	                bra LF051

10590	.ee78						LF080:
10591	.ee78		91 e8		sta ($e8),y	                sta ($E8),y
10592	.ee7a		c9 0d		cmp #$0d	                cmp #$0D
10593	.ee7c		f0 13		beq $ee91	                beq LF099
10594	.ee7e		cc b3 02	cpy $02b3	                cpy osword0MaxLineLength
10595	.ee81		b0 bf		bcs $ee42	                bcs LF04A
10596	.ee83		cd b4 02	cmp $02b4	                cmp osword0MinASCIICharacter
10597	.ee86		90 bc		bcc $ee44	                bcc LF04C
10598	.ee88		cd b5 02	cmp $02b5	                cmp osword0MaxASCIICharacter
10599	.ee8b		f0 b8		beq $ee45	                beq LF04D
10600	.ee8d		90 b6		bcc $ee45	                bcc LF04D
10601	.ee8f		80 b3		bra $ee44	                bra LF04C

10603	.ee91						LF099:
10604	.ee91		20 e7 ff	jsr $ffe7	                jsr OSNEWL
10605	.ee94		20 95 e9	jsr $e995	                jsr callNETV
10606	.ee97						LF09F:
10607	.ee97		a5 ff		lda $ff		                lda $FF
10608	.ee99		2a		rol a		                rol a
10609	.ee9a		60		rts		                rts

10611							;-------------------------------------------------------------------------
10612							;
10613							; OSBYTE 3 (&03) Specify output stream [MasRef D.2-19]
10614							;
10615	.ee9b						osbyte03:
10616	.ee9b		da		phx		                phx
10617	.ee9c		ae 7c 02	ldx $027c	                ldx characterDestinationStatus
10618	.ee9f		a9 0a		lda #$0a	                lda #printerDriverFX3
10619	.eea1		20 e4 e7	jsr $e7e4	                jsr callPrinterDriver
10620	.eea4		fa		plx		                plx
10621	.eea5		a9 03		lda #$03	                lda #$03
10622	.eea7		a0 00		ldy #$00	                ldy #$00
10623	.eea9		80 23		bra $eece	                bra osbyte04

10625							;-------------------------------------------------------------------------
10626							;
10627							; OSBYTE 6 (&06) Write printer ignore character [MasRef D.2-21]
10628							;
10629	.eeab						osbyte06:                       ;f0b3
10630	.eeab		4e 46 02	lsr $0246	                lsr noignoreState
10631	.eeae		80 16		bra $eec6	                bra osbyte01

10633							;-------------------------------------------------------------------------
10634							;
10635							; OSBYTE 114 (&72) Write usage of shadow memory [MasRef D.2-32]
10636							;
10637	.eeb0						osbyte72:                       ;f0b8
10638	.eeb0		a9 1f		lda #$1f	                lda #$1F
10639	.eeb2		80 10		bra $eec4	                bra LF0CC

10641							;-------------------------------------------------------------------------
10642							;
10643							; OSBYTE 5 (&05) Write printer driver type [MasRef D.2-20]
10644							;
10645	.eeb4						osbyte05:
10646	.eeb4						waitForPrinterDriverDormant:
10647	.eeb4		58		cli		                cli
10648	.eeb5		78		sei		                sei
10649	.eeb6		24 ff		bit $ff		                bit $FF                      ;test for ESCAPE
10650	.eeb8		30 29		bmi $eee3	                bmi rtsF0EB                  ;taken if ESCAPE pressed
10651	.eeba		2c d1 02	bit $02d1	                bit bufferEmptyFlags+bufferPrinter
10652	.eebd		10 f5		bpl $eeb4	                bpl waitForPrinterDriverDormant ;taken if printer driver active
10653	.eebf		20 e4 e7	jsr $e7e4	                jsr callPrinterDriver    ;call with A=printerDriverFX5
10654	.eec2		a0 00		ldy #$00	                ldy #$00
10655	.eec4						LF0CC:
10656	.eec4		64 f1		stz $f1		                stz $F1

10658							                ; fall through to standard MOS variable handling,
10659							                ; affecting printerDriverType

10661							;-------------------------------------------------------------------------
10662							;
10663							; OSBYTE 1 (&01) Write user flag [MasRef D.2-18]
10664							;
10665	.eec6						osbyte01:
10666	.eec6		49 f0		eor #$f0	                eor #firstMOSVariableOSBYTE+(userFlag-mosVariables)-1 ;-1 because OSBYTE 1
10667	.eec8		80 07		bra $eed1	                bra osbyteA6X  ;jump to standard MOS variable handling

10669							;-------------------------------------------------------------------------
10670							;
10671							; OSBYTE 12 (&0C) Write keyboard auto-repeat rate [MasRef D.2-23]
10672							;
10673	.eeca						osbyte0C:
10674	.eeca		f0 2a		beq $eef6	                beq resetKeyRepeat    ;taken if X=0

10676							;-------------------------------------------------------------------------
10677							;
10678							; OSBYTE 11 (&0B) Write keyboard auto-repeat delay [MasRef D.2-22]
10679							;
10680	.eecc						osbyte0B:
10681							                ; TODO - turn this constant into an expression
10682	.eecc		69 cf		adc #$cf	                adc #$CF

10684							                ;if osbyte0C, A=$db
10685							                ;if osbyteOD, A=$dc

10687							;-------------------------------------------------------------------------
10688							;
10689							; OSBYTE 4 (&04) Enable/disable cursor editing [MasRef D.2-19]
10690							;
10691	.eece						osbyte04:
10692	.eece		18		clc		                clc
10693	.eecf		69 e9		adc #$e9	                adc #firstMOSVariableOSBYTE+(editKeysMode-mosVariables)-4 ;-4 because OSBYTE 4

10695							                ;if originally OSBYTE 4 (&04) Enable/disable cursor
10696							                ;editing [MasRef D.2-19], it's now OSBYTE 237 (&ED)
10697							                ;Read/write cursor editing status [MasRef D.2-77].
10698							                ;
10699							                ;if originally OSBYTE 12 (&0C) Write keyboard
10700							                ;auto-repeat rate [MasRef D.2-23], it's now OSBYTE 197
10701							                ;(&C5) Read/write keyboard auto-repeat rate [MasRef
10702							                ;D.2-60].
10703							                ;
10704							                ;if originally OSBYTE 11 (&0B) Write keyboard
10705							                ;auto-repeat delay [MasRef D.2-22], it's now OSBYTE
10706							                ;196 (&C4) Read/write keyboard auto-repeat delay
10707							                ;[MasRef D.2-60].

10709	.eed1						osbyteA6X:
10710	.eed1		86 f0		stx $f0		                stx originalX

10712							;-------------------------------------------------------------------------
10713							;
10714							; OSBYTE 166 (&A6) Read start address of MOS variables [MasRef D.2-50]
10715							;
10716	.eed3						osbyteA6:
10717	.eed3		a8		tay		                tay             ;
10718	.eed4		b9 90 01	lda $0190,y	                lda mosVariables-firstMOSVariableOSBYTE,y;
10719	.eed7		aa		tax		                tax             ;save old value
10720	.eed8		25 f1		and $f1		                and originalY   ;AND old value with Y
10721	.eeda		45 f0		eor $f0		                eor originalX   ;EOR old value with X
10722	.eedc		99 90 01	sta $0190,y	                sta mosVariables-firstMOSVariableOSBYTE,y     ;set new variable value
10723	.eedf		b9 91 01	lda $0191,y	                lda mosVariables-firstMOSVariableOSBYTE+1,y
10724	.eee2		a8		tay		                tay             ;Y=contents of next location
10725	.eee3						rtsF0EB:
10726	.eee3		60		rts		                rts

10728							;-------------------------------------------------------------------------
10729							;
10730							; This table is used to set the serial baud rate.
10731							;
10732							;   - bit 7 is not used (always clear)
10733							;   - bit 6 is not used (always set)
10734							;   - bits 3,4,5 indicate the serial receive baud rate
10735							;   - bits 0,1,2 indicate the serial transmit baud rate
10736							;
10737							;       111 =    75 baud
10738							;       011 =   150 baud
10739							;       101 =   300 baud
10740							;       001 =  1200 baud
10741							;       110 =  2400 baud
10742							;       010 =  4800 baud
10743							;       100 =  9600 baud
10744							;       000 = 19200 baud
10745							;
10746							                .if version!=400
10757							                .endif

10759							;-------------------------------------------------------------------------
10760							;
10761							; OSBYTE 19 (&13) Wait for vertical sync [MasRef D.2-26]
10762							;
10763	.eee4						osbyte13:
10764	.eee4		ad 40 02	lda $0240	                lda cfsTimeoutCounter
10765	.eee7						-
10766	.eee7		58		cli		                cli
10767	.eee8		78		sei		                sei
10768	.eee9		cd 40 02	cmp $0240	                cmp cfsTimeoutCounter
10769	.eeec		f0 f9		beq $eee7	                beq -

10771							                ; fall through to OSBYTE $a0 (!!)

10773							;-------------------------------------------------------------------------
10774							;
10775							; OSBYTE 160 (&A0) Read VDU variable value [MasRef D.2-49]
10776							;
10777	.eeee						osbyteA0:
10778	.eeee		bc 01 03	ldy $0301,x	                ldy vduv+1,x
10779	.eef1		bd 00 03	lda $0300,x	                lda vduv+0,x
10780	.eef4		aa		tax		                tax
10781	.eef5		60		rts		                rts

10783							;-------------------------------------------------------------------------
10784							;
10785							; Reset key auto repeat settings to the defaults set in CMOS.
10786							;
10787							                .if version==350
10790							                .endif
10791	.eef6						resetKeyRepeat:
10792	.eef6		20 73 f1	jsr $f173	                jsr withTerminalROM
10793							                .if useTableDrivenConfigure
10800							                .else
10801	.eef9		20 91 8e	jsr $8e91	                jsr getDefaultKeyboardAutoRepeatDelay
10802	.eefc		8c 54 02	sty $0254	                sty keyboardAutoRepeatDelay
10803	.eeff		20 96 8e	jsr $8e96	                jsr getDefaultKeyboardAutoRepeatRate
10804							                .endif
10805	.ef02		ae 55 02	ldx $0255	                ldx keyboardAutoRepeatRate
10806	.ef05		8c 55 02	sty $0255	                sty keyboardAutoRepeatRate
10807	.ef08		60		rts		                rts

10809							;-------------------------------------------------------------------------
10810							;
10811							; OSBYTE 18 (&12) Reset soft keys [MasRef D.2-26]
10812							;
10813							; MasRef says X undefined on exit; in fact, X=0, and scanROMs
10814							; relies on this.
10815							;
10816	.ef09						osbyte12:
10817	.ef09		38		sec		                sec
10818	.ef0a		6e 84 02	ror $0284	                ror softKeyConsistencyFlag   ;mark soft keys inconsistent
10819	.ef0d		a5 f4		lda $f4		                lda $F4
10820	.ef0f		48		pha		                pha                          ;push selected paged ROM
10821	.ef10		20 8c e5	jsr $e58c	                jsr selectTerminalROMAndANDY

10823							                ; point each soft key at the 0th byte of the strings -
10824							                ; they all then have length 0.
10825	.ef13		a2 10		ldx #$10	                ldx #softKeyCount
10826	.ef15						-
10827	.ef15		a9 22		lda #$22	                lda #<andy.softKeys.strings
10828	.ef17		9d 00 80	sta $8000,x	                sta andy.softKeys.stringLSBs,x
10829	.ef1a		a9 80		lda #$80	                lda #>andy.softKeys.strings
10830	.ef1c		9d 11 80	sta $8011,x	                sta andy.softKeys.stringMSBs,x
10831	.ef1f		ca		dex		                dex
10832	.ef20		10 f3		bpl $ef15	                bpl -

10834	.ef22		68		pla		                pla                 ;pop previously selected paged ROM
10835	.ef23		20 9f e5	jsr $e59f	                jsr selectROMA

10837	.ef26		9c 68 02	stz $0268	                stz softKeyStringLength
10838	.ef29		9c 84 02	stz $0284	                stz softKeyConsistencyFlag   ;mark soft keys consistent
10839	.ef2c		e8		inx		                inx
10840	.ef2d		60		rts		                rts

10842							;-------------------------------------------------------------------------
10843							;
10844							; OSWORD 11 (&0B) Read the palette [MasRef D.3-20]
10845							;
10846	.ef2e						osword0B:
10847	.ef2e		2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne
10848	.ef31		aa		tax		                tax
10849	.ef32		bd 6f 03	lda $036f,x	                lda vduv.currentPalette,x
10850	.ef35						LF146:
10851	.ef35		c8		iny		                iny
10852	.ef36						LF147:
10853	.ef36		91 f0		sta ($f0),y	                sta (originalX),y
10854	.ef38		a9 00		lda #$00	                lda #$00                     ;fill last 3 bytes with 0
10855	.ef3a		c0 04		cpy #$04	                cpy #$04
10856	.ef3c		d0 f7		bne $ef35	                bne LF146
10857	.ef3e		60		rts		                rts

10859							;-------------------------------------------------------------------------
10860							;
10861							; OSWORD 9 (&09) Read pixel logical colour [MasRef D.3-19]
10862							;
10863	.ef3f						osword09:                                    ;f150
10864	.ef3f		20 9a f1	jsr $f19a	                jsr withMOSROM               ; sF150= 20 AB F3     +s
10865	.ef42		a0 03		ldy #$03	                ldy #$03
10866	.ef44						-
10867	.ef44		b1 f0		lda ($f0),y	                lda (originalX),y
10868	.ef46		99 28 03	sta $0328,y	                sta vduv.workspace._28,y
10869	.ef49		b9 10 03	lda $0310,y	                lda $0310,y
10870	.ef4c		48		pha		                pha
10871	.ef4d		88		dey		                dey
10872	.ef4e		10 f4		bpl $ef44	                bpl -
10873	.ef50		a9 28		lda #$28	                lda #VDUVariables.workspace._28
10874	.ef52		20 b5 dd	jsr $ddb5	                jsr readPixelColour
10875	.ef55		aa		tax		                tax
10876	.ef56		a0 00		ldy #$00	                ldy #$00
10877	.ef58						LF169:
10878	.ef58		68		pla		                pla
10879	.ef59		99 10 03	sta $0310,y	                sta $0310,y
10880	.ef5c		c8		iny		                iny
10881	.ef5d		c0 04		cpy #$04	                cpy #$04
10882	.ef5f		d0 f7		bne $ef58	                bne LF169
10883	.ef61		8a		txa		                txa
10884	.ef62		80 d2		bra $ef36	                bra LF147

10886	.ef64						osword0A:                                    ;f175
10887	.ef64		20 2a e2	jsr $e22a	                jsr getSoftCharacterDefinitionAddress
10888	.ef67		a0 00		ldy #$00	                ldy #$00
10889	.ef69		a5 f4		lda $f4		                lda $F4
10890	.ef6b		48		pha		                pha
10891	.ef6c		20 8c e5	jsr $e58c	                jsr selectTerminalROMAndANDY
10892	.ef6f						LF180:
10893	.ef6f		b1 de		lda ($de),y	                lda ($DE),y
10894	.ef71		c8		iny		                iny
10895	.ef72		91 f0		sta ($f0),y	                sta ($F0),y
10896	.ef74		c0 08		cpy #$08	                cpy #$08
10897	.ef76		d0 f7		bne $ef6f	                bne LF180
10898	.ef78		fa		plx		                plx
10899	.ef79		4c 8e e5	jmp $e58e	                jmp selectROMX

10901	.ef7c						osword0C:                                    ;f18d
10902	.ef7c		20 9a f1	jsr $f19a	                jsr withMOSROM
10903	.ef7f		08		php		                php
10904	.ef80		2d 60 03	and $0360	                and $0360
10905	.ef83		aa		tax		                tax
10906	.ef84		c8		iny		                iny
10907	.ef85		b1 f0		lda ($f0),y	                lda ($F0),y
10908	.ef87		4c 39 c6	jmp $c639	                jmp LC639

10910	.ef8a						osword0D:                                    ;f19b
10911	.ef8a		20 9a f1	jsr $f19a	                jsr withMOSROM
10912	.ef8d		a9 03		lda #$03	                lda #$03
10913	.ef8f		20 94 ef	jsr $ef94	                jsr LF1A5
10914	.ef92		a9 07		lda #$07	                lda #$07
10915	.ef94						LF1A5:
10916	.ef94		48		pha		                pha
10917	.ef95		20 b4 e2	jsr $e2b4	                jsr LE2B6
10918	.ef98		20 df c4	jsr $c4df	                jsr LC4DF
10919	.ef9b		a2 03		ldx #$03	                ldx #$03
10920	.ef9d		68		pla		                pla
10921	.ef9e		a8		tay		                tay
10922	.ef9f						LF1B0:
10923	.ef9f		bd 10 03	lda $0310,x	                lda $0310,x
10924	.efa2		91 f0		sta ($f0),y	                sta ($F0),y
10925	.efa4		88		dey		                dey
10926	.efa5		ca		dex		                dex
10927	.efa6		10 f7		bpl $ef9f	                bpl LF1B0
10928	.efa8		60		rts		                rts

10930							; Read address of bottom of screen/top of user memory
10931							; ===================================================
10932	.efa9						osbyte84:                     ;f1ba
10933	.efa9		a5 d0		lda $d0		                lda STATE     ; Get VDU status
10934	.efab		89 10		bit #$10	                bit #STATE.isShadowMode ; If shadow screen, jump to return &8000
10935	.efad		d0 18		bne $efc7	                bne LF1D8
10936	.efaf						LF1C0:
10937	.efaf		ad 55 03	lda $0355	                lda $0355                    ; Get current screen MODE

10939							; Return start of screen for non-shadow MODE in X
10940							; -----------------------------------------------
10941	.efb2						LF1C3:
10942	.efb2		29 07		and #$07	                and #$07
10943	.efb4		a8		tay		                tay
10944	.efb5		be 66 e1	ldx $e166,y	                ldx screenMODEGroupForMODE,y ; Get screen map for supplied MODE
10945	.efb8		bd 7c e1	lda $e17c,x	                lda startScreenAddressHighByteForScreenMODEGroup,x ; Get address top byte for this screen map
10946	.efbb						LF1CC:
10947	.efbb		a2 00		ldx #$00	                ldx #$00                     ; Address=&xx00
10948	.efbd		a8		tay		                tay
10949	.efbe		60		rts		                rts

10951							;-------------------------------------------------------------------------
10952							;
10953							; OSBYTE 133 (&85) Read top of user RAM for given mode [MasRef D.2-41]
10954							;
10955	.efbf						osbyte85:
10956	.efbf		8a		txa		                txa                          ; If MODE &80+n, return &8000
10957	.efc0		30 05		bmi $efc7	                bmi LF1D8
10958	.efc2		ae 7f 02	ldx $027f	                ldx shadowRAMState ; If *SHADOW<>0, jump to return non-shadow address
10959	.efc5		d0 eb		bne $efb2	                bne LF1C3
10960	.efc7						LF1D8:
10961	.efc7		a9 80		lda #$80	                lda #$80                     ; Return &8000
10962	.efc9		80 f0		bra $efbb	                bra LF1CC

10964							;-------------------------------------------------------------------------
10965							;
10966							; OSBYTE 135 (&87) Read screen mode and character at text cursor
10967							; position [MasRef D.2-42]
10968							;
10969	.efcb						osbyte87: ;F1DC:
10970	.efcb		20 9a f1	jsr $f19a	                jsr withMOSROM
10971	.efce		4c f6 dd	jmp $ddf6	                jmp readCharacterAtTextCursor

10973							;-------------------------------------------------------------------------
10974							;
10975							; OSBYTE 139 (&8B) Write Filing System options [MasRef D.2-43]
10976							;
10977	.efd1						osbyte8B:
10978	.efd1		0a		asl a		                asl a

10980							;-------------------------------------------------------------------------
10981							;
10982							; OSBYTE 127 (&7F) Check for end of file on an opened file [MasRef D.2-37]
10983							;
10984	.efd2						osbyte7F:
10985	.efd2		29 01		and #$01	                and #$01

10987							;-------------------------------------------------------------------------
10988							;
10989							; Call OSFSC. There's no entry point for this.
10990							;
10991	.efd4						callFSCV:
10992	.efd4		6c 1e 02	jmp ($021e)	                jmp (FSCV)

10994							;-------------------------------------------------------------------------
10995							;
10996							; OSWORD 15 (&0F) Write CMOS clock [MasRef D.3-24]
10997							;
10998							                .if version!=350
10999	.efd7						selectTerminalROMAndOSWORD0F:
11000	.efd7		20 73 f1	jsr $f173	                jsr withTerminalROM       ; Page in ROM 15
11001	.efda		4c ea 98	jmp $98ea	                jmp osword0F
11002							                .endif

11004							;-------------------------------------------------------------------------

11006							; Set TAPE/ROM extended vectors
11007							; =============================
11008	.efdd						LF1EE:
11009	.efdd		a2 15		ldx #$15	                ldx #$15
11010	.efdf						LF1F0:
11011	.efdf		bd e8 ef	lda $efe8,x	                lda LF1FA-1,x
11012	.efe2		9d b9 0d	sta $0db9,x	                sta ExtendedVectorAddress(FILEV)-1,x
11013	.efe5		ca		dex		                dex
11014	.efe6		d0 f7		bne $efdf	                bne LF1F0
11015	.efe8						LF1F9:
11016	.efe8		60		rts		                rts

11018							; TAPE/ROM extended vector values
11019							; -------------------------------
11020	.efe9						LF1FA:
11021	>efe9		e0 a8				                .word osfileTapeOrROM ; FILEV
11022	>efeb		0f				                .byte terminalROM
11023	>efec		8c a7				                .word osargsTapeOrROM ; ARGSV
11024	>efee		0f				                .byte terminalROM
11025	>efef		39 aa				                .word bputTapeOrROM ; BPUTV
11026	>eff1		0f				                .byte terminalROM
11027							                .if version==400
11028	>eff2		bd fa				                .word badCommandError
11031							                .endif
11032	>eff4		0f				                .byte terminalROM
11033	>eff5		9a aa				                .word osgbpbTapeOrROM ; GBPBV
11034	>eff7		0f				                .byte terminalROM
11035	>eff8		db a9				                .word osfindTapeOrROM ; FINDV
11036	>effa		0f				                .byte terminalROM
11037	>effb		e8 a7				                .word fscTapeOrROM  ; FSCV
11038	>effd		0f				                .byte terminalROM

11040							;-------------------------------------------------------------------------
11041							;
11042							; OSBYTE 109 (&6D) Make temporary Filing System permanent
11043							;
11044							; MasRef D.2-30
11045							;
11046	.effe						osbyte6D:;f20f
11047	.effe		ae 01 df	ldx $df01	                ldx hazel.activeFS; Copy active FS to current FS
11048	.f001		8e 00 df	stx $df00	                stx hazel.currentFS
11049	.f004		ad bc 0d	lda $0dbc	                lda ExtendedVectorAddress(FILEV)+2 ; Copy XFILEV ROM to current FS ROM number
11050	.f007		8d 03 df	sta $df03	                sta hazel.currentFSROM
11051	.f00a						rtsF180:
11052	.f00a		60		rts		                rts

11054							;-------------------------------------------------------------------------
11055							;
11056							; OSBYTE 20 (&14) Restore default font definitions
11057							;
11058							; MasRef D.2-24
11059							;
11060							                .if version!=350
11061	.f00b						osbyte14:                       ;f21c
11062	.f00b		20 73 f1	jsr $f173	                jsr withTerminalROM
11063	.f00e		4c 38 95	jmp $9538	                jmp restoreFont32To126
11064							                .endif

11066							;-------------------------------------------------------------------------
11067							;
11068							; OSBYTE 25 (&19) Restore a group of font definitions
11069							;
11070							; MasRef D.2-28
11071							;
11072	.f011						selectTerminalROMAndOSBYTE19:                ;f222
11073							                .if version>=511||version==350
11082							                .endif
11083	.f011		20 73 f1	jsr $f173	                jsr withTerminalROM
11084	.f014		4c 3c 95	jmp $953c	                jmp osbyte19

11086							;-------------------------------------------------------------------------

11088							; OSBYTE &16 - Increment ROM polling semaphore
11089							; ========================================
11090	.f017						osbyte16:                       ;f228
11091	.f017		ee 43 02	inc $0243	                inc romPollingSemaphore
11092	.f01a						LF2EB:
11093	.f01a		60		rts		                rts

11095							;-------------------------------------------------------------------------

11097							; OSBYTE &17 - Decrement ROM polling semaphore
11098	.f01b						osbyte17:                       ;f22c
11099							; ========================================
11100	.f01b		ce 43 02	dec $0243	                dec romPollingSemaphore
11101	.f01e		60		rts		                rts

11103							;-------------------------------------------------------------------------

11105							                .if version==350
11113							                .endif

11115							;-------------------------------------------------------------------------

11117							; OSBYTE &76 - Set LEDs to keyboard state
11118							; =======================================
11119	.f01f						osbyte76:
11120	.f01f		08		php		                php                          ; Disable IRQs
11121	.f020		78		sei		                sei
11122	.f021		a9 40		lda #$40	                lda #$40                     ; Turn on LEDs
11123	.f023		20 30 f0	jsr $f030	                jsr LF241
11124	.f026		30 05		bmi $f02d	                bmi LF23E                    ; Exit if Escape pending
11125	.f028		18		clc		                clc                          ; Call KEYV to read SHIFT and CTRL
11126	.f029		b8		clv		                clv
11127	.f02a		20 f1 f6	jsr $f6f1	                jsr callKEYV
11128							; Returns A.b7=CTRL, A.b6=SHIFT, MI=CTRL, VS=SHIFT
11129	.f02d						LF23E:
11130	.f02d		28		plp		                plp                          ; Restore IRQs
11131	.f02e		2a		rol a		                rol a                        ; Set Carry from A bit 7 and return
11132	.f02f		60		rts		                rts
11133							; Returns A.b7=SHIFT, CS=CTRL

11135							; Set keyboard LEDs
11136							; -----------------
11137	.f030						LF241:
11138	.f030		90 09		bcc $f03b	                bcc LF24C                    ; Skip if not called from OSBYTE
11139	.f032		a0 07		ldy #$07	                ldy #$07                     ; Turn ShiftLock LED on
11140	.f034		8c 40 fe	sty $fe40	                sty systemVIA.orb
11141	.f037		88		dey		                dey                          ; Turn CapsLock LED on
11142	.f038		8c 40 fe	sty $fe40	                sty systemVIA.orb
11143	.f03b						LF24C:
11144	.f03b		24 ff		bit $ff		                bit $FF                      ; Test Escape and return
11145	.f03d		60		rts		                rts

11147							;-------------------------------------------------------------------------

11149	.f03e						osbyte9A:
11150	.f03e		8a		txa		                txa
11151	.f03f						setVCONTROL:
11152	.f03f		08		php		                php
11153	.f040		78		sei		                sei
11154	.f041		8d 48 02	sta $0248	                sta vcontrolRegister
11155	.f044		8d 20 fe	sta $fe20	                sta VCONTROL
11156	.f047		ad 53 02	lda $0253	                lda secondFlashColourDuration
11157	.f04a		8d 51 02	sta $0251	                sta flashCounter
11158	.f04d		28		plp		                plp
11159	.f04e		60		rts		                rts

11161							;-------------------------------------------------------------------------
11162							;
11163							; OSBYTE 155 (&9B) Write to video ULA palette register and copy
11164							;
11165	.f04f						osbyte9B:
11166	.f04f		8a		txa		                txa
11167	.f050						writeVPALETTE:
11168	.f050		49 07		eor #$07	                eor #$07
11169	.f052		08		php		                php
11170	.f053		78		sei		                sei
11171	.f054		8d 49 02	sta $0249	                sta vpaletteRegister
11172	.f057		8d 21 fe	sta $fe21	                sta VPALETTE
11173	.f05a		28		plp		                plp
11174	.f05b		60		rts		                rts

11176							;-------------------------------------------------------------------------

11178	.f05c						gsinitForFilenameParsing:
11179	.f05c		18		clc		                clc


11182							;-------------------------------------------------------------------------
11183							;
11184							; GSINIT
11185							;
11186							; MasRef D.10-1
11187							;
11188	.f05d						gsinitEntryPoint:
11189	.f05d		66 e4		ror $e4		                ror stringInputOptions    ;put C into bit 7
11190	.f05f		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
11191	.f062		c8		iny		                iny
11192	.f063		c9 22		cmp #$22	                cmp #'"'
11193	.f065		f0 02		beq $f069	                beq +                       ; C=1 if double quotes
11194	.f067		88		dey		                dey
11195	.f068		18		clc		                clc                         ; clear double quotes flag
11196	.f069						+
11197	.f069		66 e4		ror $e4		                ror stringInputOptions ; set doubleQuotes; move bit 7 into spaceNotATerminator
11198	.f06b		c9 0d		cmp #$0d	                cmp #$0D                     ; set Z if initial CR
11199	.f06d		60		rts		                rts

11201							;-------------------------------------------------------------------------
11202							;
11203							; GSREAD
11204							;
11205							; MasRef D.10-2
11206							; MasRef C.5-8 has the | syntax
11207							;
11208	.f06e						gsreadEntryPoint:
11209	.f06e		a9 01		lda #$01	                lda #stringInputOptions.goodString
11210	.f070		04 e4		tsb $e4		                tsb stringInputOptions
11211	.f072		20 8b f0	jsr $f08b	                jsr LF29C
11212	.f075		08		php		                php                          ; save flags
11213	.f076		46 e4		lsr $e4		                lsr stringInputOptions       ; move goodString into C
11214	.f078		90 04		bcc $f07e	                bcc badStringError           ; branch taken if bad string
11215	.f07a		26 e4		rol $e4		                rol stringInputOptions       ; reinstate goodString
11216	.f07c		28		plp		                plp                          ; restore flags
11217	.f07d		60		rts		                rts                          ;

11219	.f07e						badStringError:
11220	.f07e		00		brk #		                brk                          ;
11221	>f07f		fd 42 61 64 20 73 74 72		                .text $fd,"Bad string",0
	>f087		69 6e 67 00
11222	.f08b						LF29C:
11223	.f08b		18		clc		                clc                          ; last char not !
11224	.f08c						LF29D:
11225							                ; C=1 at this point if |! was the last sequence seen.
11226	.f08c		64 e5		stz $e5		                stz stringInputPlingFlag
11227	.f08e		66 e5		ror $e5		                ror stringInputPlingFlag     ; set ! flag as required
11228	.f090		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11229	.f092		c9 0d		cmp #$0d	                cmp #13                      ;EOL?
11230	.f094		d0 09		bne $f09f	                bne notRETURN                ;taken if not EOL
11231	.f096		24 e4		bit $e4		                bit stringInputOptions
11232	.f098		10 20		bpl $f0ba	                bpl finishedString           ;taken if !doubleQuotes
11233	.f09a						badString:
11234	.f09a		a9 01		lda #$01	                lda #stringInputOptions.goodString
11235	.f09c		14 e4		trb $e4		                trb stringInputOptions
11236	.f09e		60		rts		                rts

11238	.f09f						notRETURN:
11239	.f09f		c9 20		cmp #$20	                cmp #' '
11240	.f0a1		90 f7		bcc $f09a	                bcc badString ;taken if unprintable control char
11241	.f0a3		d0 06		bne $f0ab	                bne notSPACE
11242	.f0a5		24 e4		bit $e4		                bit stringInputOptions ;N=doubleQuotes, V=spaceNotATerminator
11243	.f0a7		30 3e		bmi $f0e7	                bmi finishUpReadClearV ;taken if quoted
11244	.f0a9		50 0f		bvc $f0ba	                bvc finishedString ;taken if space is a terminator
11245	.f0ab						notSPACE:
11246	.f0ab		c9 22		cmp #$22	                cmp #'"'
11247	.f0ad		d0 10		bne $f0bf	                bne notDOUBLEQUOTE         ;taken if not quotes
11248	.f0af		24 e4		bit $e4		                bit stringInputOptions ;N=doubleQuotes, V=spaceNotATerminator
11249	.f0b1		10 34		bpl $f0e7	                bpl finishUpReadClearV ;taken if not double quotes
11250	.f0b3		c8		iny		                iny
11251	.f0b4		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11252	.f0b6		c9 22		cmp #$22	                cmp #'"'
11253	.f0b8		f0 2d		beq $f0e7	                beq finishUpReadClearV       ;taken if quotes
11254	.f0ba						finishedString:
11255	.f0ba		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
11256	.f0bd		38		sec		                sec
11257	.f0be		60		rts		                rts

11259	.f0bf						notDOUBLEQUOTE:
11260	.f0bf		c9 7c		cmp #$7c	                cmp #'|'
11261	.f0c1		d0 24		bne $f0e7	                bne finishUpReadClearV       ;taken if not |
11262	.f0c3		c8		iny		                iny                          ;skip |
11263	.f0c4		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11264	.f0c6		c9 7c		cmp #$7c	                cmp #'|'
11265	.f0c8		f0 1d		beq $f0e7	                beq finishUpReadClearV ;branch taken if "||" - literal |
11266	.f0ca		c9 22		cmp #$22	                cmp #'"'
11267	.f0cc		f0 19		beq $f0e7	                beq finishUpReadClearV ;branch taken if "|\"" - literal "
11268	.f0ce		c9 21		cmp #$21	                cmp #'!'
11269	.f0d0		d0 03		bne $f0d5	                bne LF2E6                    ;taken if not "|!"

11271							                ; Handle |! - ASCII 128-255
11272	.f0d2		c8		iny		                iny                          ;skip !
11273	.f0d3		80 b7		bra $f08c	                bra LF29D

11275	.f0d5						LF2E6:
11276	.f0d5		c9 20		cmp #$20	                cmp #' '
11277	.f0d7		90 c1		bcc $f09a	                bcc badString ;taken if | followed by a non-printable char
11278	.f0d9		c9 3f		cmp #$3f	                cmp #'?'
11279	.f0db		f0 08		beq $f0e5	                beq ascii127                 ;taken if "|?" - CHR$127
11280	.f0dd		20 25 f1	jsr $f125	                jsr implementCTRLCodes
11281	.f0e0		2c 5e e3	bit $e35e	                bit valueFF
11282	.f0e3		80 03		bra $f0e8	                bra LF2F9

11284	.f0e5						ascii127:
11285	.f0e5		a9 7f		lda #$7f	                lda #$7F
11286	.f0e7						finishUpReadClearV:
11287	.f0e7		b8		clv		                clv
11288	.f0e8						LF2F9:
11289	.f0e8		c8		iny		                iny
11290	.f0e9		05 e5		ora $e5		                ora stringInputPlingFlag ;if it was a |! char, set bit 7
11291	.f0eb		18		clc		                clc
11292	.f0ec		60		rts		                rts

11294							;-------------------------------------------------------------------------

11296	.f0ed						incAndSkipSpaces:
11297	.f0ed		c8		iny		                iny
11298	.f0ee						skipSpacesAndCheckForCRInStringInput:
11299	.f0ee		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11300	.f0f0		c9 20		cmp #$20	                cmp #' '
11301	.f0f2		f0 f9		beq $f0ed	                beq incAndSkipSpaces
11302	.f0f4						checkForCR:
11303	.f0f4		c9 0d		cmp #$0d	                cmp #13
11304	.f0f6		60		rts		                rts

11306							;-------------------------------------------------------------------------

11308	.f0f7						LF308:
11309	.f0f7		90 f5		bcc $f0ee	                bcc skipSpacesAndCheckForCRInStringInput
11310	.f0f9						LF30A:
11311	.f0f9		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
11312	.f0fc		c9 2c		cmp #$2c	                cmp #','
11313	.f0fe		d0 f4		bne $f0f4	                bne checkForCR
11314	.f100		c8		iny		                iny
11315	.f101		60		rts		                rts

11317							;-------------------------------------------------------------------------

11319							                .if version==510&&olivetti
11408							                .endif

11410							;-------------------------------------------------------------------------
11411							;
11412							; Modify character in A as if the SHIFT key is being pressed.
11413							;

11415	.f102						implementShift:
11416							                .if version<500&&version!=350

11418	.f102		c9 30		cmp #$30	                cmp #'0'
11419	.f104		f0 1e		beq $f124	                beq gotShiftedChar           ;taken if SHIFT+0 - no change
11420	.f106		c9 40		cmp #$40	                cmp #$40
11421	.f108		f0 1a		beq $f124	                beq gotShiftedChar           ;taken if SHIFT+@ - no change
11422	.f10a		90 12		bcc $f11e	                bcc shiftMaybeNumber ;taken if probably a "number" (ASCII 33-63)
11423	.f10c		c9 7f		cmp #$7f	                cmp #$7F
11424	.f10e		f0 14		beq $f124	                beq gotShiftedChar  ;taken if SHIFT+DELETE - no change
11425	.f110		b0 10		bcs $f122	                bcs shiftNumber     ;taken if SHIFT+CHR$>=127 - ???
11426	.f112						flipBitsForShift:
11427	.f112		49 30		eor #$30	                eor #$30                     ;
11428	.f114		c9 6f		cmp #$6f	                cmp #$6F                     ;
11429	.f116		f0 04		beq $f11c	                beq +                        ;taken if originally _
11430	.f118		c9 50		cmp #$50	                cmp #$50                     ;
11431	.f11a		d0 02		bne $f11e	                bne shiftMaybeNumber         ;taken if not originally GBP
11432	.f11c						+
11433	.f11c		49 1f		eor #$1f	                eor #$1F                     ;extra step for GBP/_ toggle
11434	.f11e						shiftMaybeNumber:
11435	.f11e		c9 21		cmp #$21	                cmp #' '+1
11436	.f120		90 02		bcc $f124	                bcc gotShiftedChar         ;taken if non-printing char
11437	.f122						shiftNumber:
11438	.f122		49 10		eor #$10	                eor #$10                     ;
11439	.f124						gotShiftedChar:
11440	.f124		60		rts		                rts

11486							                .endif

11488							;-------------------------------------------------------------------------
11489							;
11490							; See MasRef C.5-8
11491							;
11492							;
11493	.f125						implementCTRLCodes:
11494							                .if version<500&&version!=350

11496	.f125		c9 7f		cmp #$7f	                cmp #$7F
11497	.f127		f0 0e		beq $f137	                beq gotCtrlChar
11498	.f129		b0 e7		bcs $f112	                bcs flipBitsForShift         ;taken if CHR$>=128
11499	.f12b		c9 60		cmp #$60	                cmp #$60
11500	.f12d		d0 02		bne $f131	                bne +                        ;taken if not GBP
11501	.f12f		a9 5f		lda #$5f	                lda #'_'                     ;GBP and _ are equivalent
11502	.f131						+
11503	.f131		c9 40		cmp #$40	                cmp #$40                     ;
11504	.f133		90 02		bcc $f137	                bcc gotCtrlChar              ;taken if CHR$<64
11505	.f135		29 1f		and #$1f	                and #$1F                     ;|@=0, |A=1, |a=1, etc.
11506	.f137						gotCtrlChar:
11507	.f137		60		rts		                rts

11539							                .endif

11541							;-------------------------------------------------------------------------

11543							                .if version==350
11546							                .endif
11547	.f138						osbyte247EntryPoint:
11548	.f138		ad 87 02	lda $0287	                lda breakVectorByte0
11549	.f13b		49 4c		eor #$4c	                eor #$4C                     ; JMP abs
11550	.f13d		d0 13		bne $f152	                bne rtsF363
11551							                .if version==350
11554							                .elsif version<500
11555	.f13f		4c 87 02	jmp $0287	                jmp breakVectorByte0
11563							                .endif

11565							;-------------------------------------------------------------------------
11566							;
11567							; OSBYTE 144 (&90)
11568							; Set vertical screen shift and interlace
11569							;
11570							; MasRef D.2-44
11571							;
11572	.f142						osbyte90:
11573	.f142		ad 90 02	lda $0290	                lda tvOffset
11574	.f145		8e 90 02	stx $0290	                stx tvOffset
11575	.f148		aa		tax		                tax
11576	.f149		98		tya		                tya
11577	.f14a		29 01		and #$01	                and #$01
11578	.f14c		ac 91 02	ldy $0291	                ldy tvInterlace
11579	.f14f		8d 91 02	sta $0291	                sta tvInterlace
11580	.f152						rtsF363:
11581	.f152		60		rts		                rts

11583							;-------------------------------------------------------------------------
11584							;
11585							; OSBYTE 149 (&95) - write to JIM
11586							;
11587							; MasRef D.2-45
11588							;
11589	.f153						osbyte95:
11590	.f153		98		tya		                tya
11591	.f154		9d 00 fd	sta $fd00,x	                sta $FD00,x
11592	.f157		60		rts		                rts

11594							;-------------------------------------------------------------------------
11595							;
11596							; OSBYTE 151 (&97) - write to SHEILA
11597							;
11598							; MasRef D.2-45
11599							;
11600	.f158						osbyte97:
11601	.f158		98		tya		                tya
11602	.f159		9d 00 fe	sta $fe00,x	                sta $FE00,x
11603	.f15c		60		rts		                rts

11605							;-------------------------------------------------------------------------
11606							;
11607							; OSBYTE 147 (&93) - write to FRED
11608							;
11609							; MasRef D.2-45
11610							;
11611	.f15d						osbyte93:
11612	.f15d		98		tya		                tya
11613	.f15e		9d 00 fc	sta $fc00,x	                sta $FC00,x
11614	.f161		60		rts		                rts

11616							;-------------------------------------------------------------------------
11617							;
11618							; *SHUT [MasRef G.5-10]
11619							;
11620	.f162						starSHUT:
11621	.f162		a2 26		ldx #$26	                ldx #romServiceCallCloseAllOpenFiles
11622	.f164		4c 52 ec	jmp $ec52	                jmp makeROMServiceCall

11624							;-------------------------------------------------------------------------
11625							;
11626							; Return thunk used by withTerminalROM.
11627							;
11628							; On entry here, the old value of $f4 is at the top of the stack.
11629							;
11630	.f167						withTerminalROMReturnThunk:
11631	.f167		08		php		                php                          ; S=[p; old ROMSEL]
11632	.f168		48		pha		                pha                          ; S=[a; p; old ROMSEL]
11633	.f169		da		phx		                phx                          ; S=[x; a; p; old ROMSEL]
11634	.f16a		ba		tsx		                tsx
11635	.f16b		bd 04 01	lda $0104,x	                lda $0104,x                  ; get old ROMSEL
11636	.f16e		20 9f e5	jsr $e59f	                jsr selectROMA               ; re-select old ROM
11637	.f171		80 5d		bra $f1d0	                bra returnThunkSuffix

11639							;-------------------------------------------------------------------------
11640							;
11641							; Select the Terminal ROM. Rearrange the stack so that the original
11642							; ROM is re-selected when withTerminalROM's caller itself returns.
11643							;
11644	.f173						withTerminalROM:
11645							                .if version==350
11653							                .else
11654	.f173		48		pha		                pha                          ; S=[A]
11655	.f174		48		pha		                pha                          ; S=[A; A]
11656	.f175		48		pha		                pha                          ; S=[A; A; A]
11657	.f176		08		php		                php                          ; S=[P; A; A; A]
11658	.f177		48		pha		                pha                          ; S=[A; P; A; A; A]
11659	.f178		da		phx		                phx                          ; S=[X; A; P; A; A; A]
11660	.f179		ba		tsx		                tsx                          ; S=[X; A; P; A; A; A; RL; RH]
11661	.f17a		bd 07 01	lda $0107,x	                lda $0107,x                  ; get RL
11662	.f17d		9d 04 01	sta $0104,x	                sta $0104,x                  ; overwrite placeholder A
11663	.f180		bd 08 01	lda $0108,x	                lda $0108,x                  ; get RH
11664	.f183		9d 05 01	sta $0105,x	                sta $0105,x                  ; overwrite placeholder A
11665	.f186		a5 f4		lda $f4		                lda $F4                      ; get ROMSEL
11666	.f188		9d 08 01	sta $0108,x	                sta $0108,x                  ; overwrite RH

11668							                ; put return thunk in the right spot
11669	.f18b		a9 f1		lda #$f1	                lda #>withTerminalROMReturnThunk-1
11670	.f18d		9d 07 01	sta $0107,x	                sta $0107,x
11671	.f190		a9 66		lda #$66	                lda #<withTerminalROMReturnThunk-1
11672	.f192		9d 06 01	sta $0106,x	                sta $0106,x
11673							                .endif
11674	.f195		20 9d e5	jsr $e59d	                jsr selectTerminalROM
11675	.f198		80 28		bra $f1c2	                bra plx_pla_plp_rts

11677							;-------------------------------------------------------------------------
11678							;
11679							; Select the MOS ROM (i.e., no HAZEL). Rearrange the stack so that the
11680							; original HAZEL state is restored when withMOSROM's caller itself
11681							; returns.
11682							;
11683	.f19a						withMOSROM:
11684							                .if version==350
11693							                .else
11694	.f19a		48		pha		                pha                          ; S=[A]
11695	.f19b		48		pha		                pha                          ; S=[A; A]
11696	.f19c		48		pha		                pha                          ; S=[A; A; A]
11697	.f19d		08		php		                php                          ; S=[P; A; A; A]
11698	.f19e		48		pha		                pha                          ; S=[A; P; A; A; A]
11699	.f19f		da		phx		                phx                          ; S=[X; A; P; A; A; A]
11700	.f1a0		ba		tsx		                tsx                          ; S=[X; A; P; A; A; A; RL; RH]
11701	.f1a1		bd 08 01	lda $0108,x	                lda $0108,x                  ; get RH
11702	.f1a4		9d 05 01	sta $0105,x	                sta $0105,x                  ; overwrite placeholder A
11703	.f1a7		bd 07 01	lda $0107,x	                lda $0107,x                  ; get RL
11704	.f1aa		9d 04 01	sta $0104,x	                sta $0104,x                  ; overwrite placeholder A

11706							                ; put return thunk in the right spot
11707	.f1ad		a9 f1		lda #$f1	                lda #>withMOSROMReturnThunk-1
11708	.f1af		9d 07 01	sta $0107,x	                sta $0107,x
11709	.f1b2		a9 c5		lda #$c5	                lda #<withMOSROMReturnThunk-1
11710	.f1b4		9d 06 01	sta $0106,x	                sta $0106,x

11712	.f1b7		ad 34 fe	lda $fe34	                lda ACCCON                   ; get ACCCON
11713	.f1ba		9d 08 01	sta $0108,x	                sta $0108,x                  ; overwrite RH
11714	.f1bd		a9 08		lda #$08	                lda #ACCCON.Y
11715	.f1bf		1c 34 fe	trb $fe34	                trb ACCCON
11716							                ; HAZEL off
11717							                .endif
11718	.f1c2						plx_pla_plp_rts:
11719							                ; S=[X; A; P; RL; RH; thunkRL; thunkRH; old ACCCON/ROMSEL]
11720	.f1c2		fa		plx		                plx
11721	.f1c3		68		pla		                pla
11722	.f1c4		28		plp		                plp
11723	.f1c5		60		rts		                rts

11725	.f1c6						withMOSROMReturnThunk:
11726	.f1c6		08		php		                php                          ; S=[P]
11727	.f1c7		48		pha		                pha                          ; S=[A; P]
11728	.f1c8		da		phx		                phx                          ; S=[X; A; P]
11729	.f1c9		ba		tsx		                tsx                          ; S=[X; A; P; old ACCCON]
11730	.f1ca		bd 04 01	lda $0104,x	                lda $0104,x                  ; get old ACCCON
11731	.f1cd		20 af eb	jsr $ebaf	                jsr selectMOSOrHAZEL         ; re-select old HAZEL state
11732	.f1d0						returnThunkSuffix:
11733							                ; double up P, as that's the easiest way of ending up
11734							                ; discarding the TOS without affecting the flags.
11735	.f1d0		bd 03 01	lda $0103,x	                lda $0103,x
11736	.f1d3		9d 04 01	sta $0104,x	                sta $0104,x
11737	.f1d6		fa		plx		                plx
11738	.f1d7		68		pla		                pla
11739	.f1d8		28		plp		                plp
11740	.f1d9		28		plp		                plp
11741	.f1da		60		rts		                rts

11743							;-------------------------------------------------------------------------
11744							;
11745							; Clear ACCCON TST bit (paging in I/O for reads, rather than ROM, at
11746							; $fc00...$feff), and restore it on exit from the current routine.
11747							;
11748							                .if version==350
11771							                .endif

11773							;-------------------------------------------------------------------------
11774							;
11775							; Sort out stack for one of the withXXX routines, that set up some
11776							; state and then automatically restore the original state on exit from
11777							; the calling routine.
11778							;
11779							                .if version==350
11796							                .endif

11798							;-------------------------------------------------------------------------

11800	.f1db						vduChrEntryPoint:
11801	.f1db		20 9a f1	jsr $f19a	                jsr withMOSROM
11802	.f1de		a6 f4		ldx $f4		                ldx $F4
11803	.f1e0		da		phx		                phx
11804	.f1e1		20 8c e5	jsr $e58c	                jsr selectTerminalROMAndANDY
11805	.f1e4		20 27 c0	jsr $c027	                jsr outputToVDU
11806	.f1e7		fa		plx		                plx
11807	.f1e8		4c 8e e5	jmp $e58e	                jmp selectROMX

11809							;-------------------------------------------------------------------------
11810							;
11811							; OSRDSC [MasRef D.6-1]
11812							;
11813	.f1eb						osrdscEntryPoint:
11814	.f1eb		20 9a f1	jsr $f19a	                jsr withMOSROM
11815	.f1ee		4c 18 c0	jmp $c018	                jmp LC018

11817							;-------------------------------------------------------------------------
11818							;
11819							; OSWRSC [MasRef D.8-1]
11820							;
11821	.f1f1						oswrscEntryPoint:
11822	.f1f1		20 9a f1	jsr $f19a	                jsr withMOSROM
11823	.f1f4		4c 5d db	jmp $db5d	                jmp oswrscCode

11825							;-------------------------------------------------------------------------

11827	.f1f7						starRunBOOT:
11828	>f1f7		2f 21 42 4f 4f 54 0d		                .text "/!BOOT",13

11830							;-------------------------------------------------------------------------

11832							                .if version<500&&version!=350
11833							                .include "sound_stuff.s65"

:15	;******  Processing file: src/sound_stuff.s65

1							; Table to convert channel number to the bits required by the chip
2	.f1fe						soundParameterTable:
3	>f1fe		e0 c0 a0 80			                .byte $e0,$c0,$a0,$80

5							;-------------------------------------------------------------------------

7	.f202						LF413:
8	.f202		4c 0f f3	jmp $f30f	                jmp LF520

10							;-------------------------------------------------------------------------

12							                .if version>=500
14							                .else
15	.f205						LF416:
16							                .endif
17	.f205		a2 00		ldx #$00	                ldx #$00
18	.f207		ad 38 08	lda $0838	                lda $0838
19	.f20a		d0 04		bne $f210	                bne LF421
20	.f20c		e8		inx		                inx
21	.f20d		ce 38 08	dec $0838	                dec $0838
22	.f210						LF421:
23	.f210		8e 3b 08	stx $083b	                stx $083B
24	.f213		a2 08		ldx #$08	                ldx #$08
25	.f215						LF426:
26	.f215		ca		dex		                dex
27	.f216		bd 00 08	lda $0800,x	                lda $0800,x
28	.f219		f0 e7		beq $f202	                beq LF413
29	.f21b		bd ce 02	lda $02ce,x	                lda bufferEmptyFlags,x
30	.f21e		30 05		bmi $f225	                bmi LF436
31	.f220		bd 18 08	lda $0818,x	                lda $0818,x
32	.f223		d0 08		bne $f22d	                bne LF43E
33	.f225						LF436:
34	.f225		20 17 f3	jsr $f317	                jsr LF528
35	.f228		bd 18 08	lda $0818,x	                lda $0818,x
36	.f22b		f0 12		beq $f23f	                beq LF450
37	.f22d						LF43E:
38	.f22d		1a		inc a		                inc a
39	.f22e		f0 12		beq $f242	                beq LF453
40	.f230		de 1c 08	dec $081c,x	                dec $081C,x
41	.f233		d0 0d		bne $f242	                bne LF453
42	.f235		a9 05		lda #$05	                lda #$05
43	.f237		9d 1c 08	sta $081c,x	                sta $081C,x
44	.f23a		de 18 08	dec $0818,x	                dec $0818,x
45	.f23d		d0 03		bne $f242	                bne LF453
46	.f23f						LF450:
47	.f23f		20 17 f3	jsr $f317	                jsr LF528
48	.f242						LF453:
49	.f242		bd 24 08	lda $0824,x	                lda $0824,x
50	.f245		f0 05		beq $f24c	                beq LF45D
51	.f247		de 24 08	dec $0824,x	                dec $0824,x
52	.f24a		d0 b6		bne $f202	                bne LF413
53	.f24c						LF45D:
54	.f24c		bc 20 08	ldy $0820,x	                ldy $0820,x
55	.f24f		c0 ff		cpy #$ff	                cpy #$FF
56	.f251		f0 af		beq $f202	                beq LF413
57	.f253		b9 c0 08	lda $08c0,y	                lda $08C0,y
58	.f256		29 7f		and #$7f	                and #$7F
59	.f258		9d 24 08	sta $0824,x	                sta $0824,x
60	.f25b		bd 08 08	lda $0808,x	                lda $0808,x
61	.f25e		c9 04		cmp #$04	                cmp #$04
62	.f260		f0 5d		beq $f2bf	                beq LF4D0
63	.f262		18		clc		                clc
64	.f263		7d 20 08	adc $0820,x	                adc $0820,x
65	.f266		a8		tay		                tay
66	.f267		b9 cb 08	lda $08cb,y	                lda $08CB,y
67	.f26a		38		sec		                sec
68	.f26b		e9 3f		sbc #$3f	                sbc #$3F
69	.f26d		8d 3a 08	sta $083a	                sta $083A
70	.f270		b9 c7 08	lda $08c7,y	                lda $08C7,y
71	.f273		8d 39 08	sta $0839	                sta $0839
72	.f276		bd 04 08	lda $0804,x	                lda $0804,x
73	.f279						LF48A:
74	.f279		48		pha		                pha
75	.f27a		18		clc		                clc
76	.f27b		6d 39 08	adc $0839	                adc $0839
77	.f27e		50 07		bvc $f287	                bvc LF498
78	.f280		2a		rol a		                rol a
79	.f281		a9 3f		lda #$3f	                lda #$3F
80	.f283		b0 02		bcs $f287	                bcs LF498
81	.f285		49 ff		eor #$ff	                eor #$FF
82	.f287						LF498:
83	.f287		9d 04 08	sta $0804,x	                sta $0804,x
84	.f28a		2a		rol a		                rol a
85	.f28b		5d 04 08	eor $0804,x	                eor $0804,x
86	.f28e		10 09		bpl $f299	                bpl LF4AA
87	.f290		a9 3f		lda #$3f	                lda #$3F
88	.f292		90 02		bcc $f296	                bcc LF4A7
89	.f294		49 ff		eor #$ff	                eor #$FF
90	.f296						LF4A7:
91	.f296		9d 04 08	sta $0804,x	                sta $0804,x
92	.f299						LF4AA:
93	.f299		ce 39 08	dec $0839	                dec $0839
94	.f29c		bd 04 08	lda $0804,x	                lda $0804,x
95	.f29f		38		sec		                sec
96	.f2a0		ed 3a 08	sbc $083a	                sbc $083A
97	.f2a3		4d 39 08	eor $0839	                eor $0839
98	.f2a6		30 09		bmi $f2b1	                bmi LF4C2
99	.f2a8		ad 3a 08	lda $083a	                lda $083A
100	.f2ab		9d 04 08	sta $0804,x	                sta $0804,x
101	.f2ae		fe 08 08	inc $0808,x	                inc $0808,x
102	.f2b1						LF4C2:
103	.f2b1		68		pla		                pla
104	.f2b2		5d 04 08	eor $0804,x	                eor $0804,x
105	.f2b5		29 f8		and #$f8	                and #$F8
106	.f2b7		f0 06		beq $f2bf	                beq LF4D0
107	.f2b9		bd 04 08	lda $0804,x	                lda $0804,x
108	.f2bc		20 88 f3	jsr $f388	                jsr LF599
109	.f2bf						LF4D0:
110	.f2bf		bd 10 08	lda $0810,x	                lda $0810,x
111	.f2c2		c9 03		cmp #$03	                cmp #$03
112	.f2c4		f0 49		beq $f30f	                beq LF520
113	.f2c6		bd 14 08	lda $0814,x	                lda $0814,x
114	.f2c9		d0 28		bne $f2f3	                bne LF504
115	.f2cb		fe 10 08	inc $0810,x	                inc $0810,x
116	.f2ce		bd 10 08	lda $0810,x	                lda $0810,x
117	.f2d1		c9 03		cmp #$03	                cmp #$03
118	.f2d3		d0 0e		bne $f2e3	                bne LF4F4
119	.f2d5		bc 20 08	ldy $0820,x	                ldy $0820,x
120	.f2d8		b9 c0 08	lda $08c0,y	                lda $08C0,y
121	.f2db		30 32		bmi $f30f	                bmi LF520
122	.f2dd		9e 30 08	stz $0830,x	                stz $0830,x
123	.f2e0		9e 10 08	stz $0810,x	                stz $0810,x
124	.f2e3						LF4F4:
125	.f2e3		bd 10 08	lda $0810,x	                lda $0810,x
126	.f2e6		18		clc		                clc
127	.f2e7		7d 20 08	adc $0820,x	                adc $0820,x
128	.f2ea		a8		tay		                tay
129	.f2eb		b9 c4 08	lda $08c4,y	                lda $08C4,y
130	.f2ee		9d 14 08	sta $0814,x	                sta $0814,x
131	.f2f1		f0 1c		beq $f30f	                beq LF520
132	.f2f3						LF504:
133	.f2f3		de 14 08	dec $0814,x	                dec $0814,x
134	.f2f6		bd 20 08	lda $0820,x	                lda $0820,x
135	.f2f9		18		clc		                clc
136	.f2fa		7d 10 08	adc $0810,x	                adc $0810,x
137	.f2fd		a8		tay		                tay
138	.f2fe		b9 c1 08	lda $08c1,y	                lda $08C1,y
139	.f301		18		clc		                clc
140	.f302		7d 30 08	adc $0830,x	                adc $0830,x
141	.f305		9d 30 08	sta $0830,x	                sta $0830,x
142	.f308		18		clc		                clc
143	.f309		7d 0c 08	adc $080c,x	                adc $080C,x
144	.f30c		20 c4 f3	jsr $f3c4	                jsr LF5D5
145	.f30f						LF520:
146	.f30f		e0 04		cpx #$04	                cpx #$04
147	.f311		f0 03		beq $f316	                beq LF527
148	.f313		4c 15 f2	jmp $f215	                jmp LF426

150	.f316						LF527:
151	.f316		60		rts		                rts

153	.f317						LF528:
154	.f317		bd 08 08	lda $0808,x	                lda $0808,x
155	.f31a		c9 04		cmp #$04	                cmp #$04
156	.f31c		f0 05		beq $f323	                beq LF534
157	.f31e		a9 03		lda #$03	                lda #$03
158	.f320		9d 08 08	sta $0808,x	                sta $0808,x
159	.f323						LF534:
160	.f323		bd ce 02	lda $02ce,x	                lda bufferEmptyFlags,x
161	.f326		f0 14		beq $f33c	                beq LF54D
162	.f328		a9 00		lda #$00	                lda #$00
163	.f32a		9e ce 02	stz $02ce,x	                stz bufferEmptyFlags,x
164	.f32d		a0 04		ldy #$04	                ldy #$04
165	.f32f						LF540:
166	.f32f		99 2b 08	sta $082b,y	                sta $082B,y
167	.f332		88		dey		                dey
168	.f333		d0 fa		bne $f32f	                bne LF540
169	.f335		9e 18 08	stz $0818,x	                stz $0818,x
170	.f338		88		dey		                dey
171	.f339		8c 38 08	sty $0838	                sty $0838
172	.f33c						LF54D:
173	.f33c		bd 28 08	lda $0828,x	                lda $0828,x
174	.f33f		f0 60		beq $f3a1	                beq LF5B2
175	.f341		ad 3b 08	lda $083b	                lda $083B
176	.f344		f0 34		beq $f37a	                beq LF58B
177	.f346		9e 28 08	stz $0828,x	                stz $0828,x
178	.f349						LF55A:
179	.f349		4c 74 f4	jmp $f474	                jmp LF685

181							;-------------------------------------------------------------------------
182							;
183							; Clear a buffer that's a sound channel.
184							;
185							; https://tobylobster.github.io/mos/mos/S-s16.html#SP7
186							;
187							; Entry:
188							;
189							; X = buffer number (must be a sound channel buffer)
190							;
191							                .if version>=500||version==350
195							                .else
196	.f34c						clearSoundChannelBuffer:
197							                .endif
198							                .block
199	.f34c		20 81 f3	jsr $f381	                jsr LF592
200	.f34f		98		tya		                tya
201	.f350		9e 18 08	stz $0818,x	                stz $0818,x
202	.f353		9e ce 02	stz $02ce,x	                stz bufferEmptyFlags,x
203	.f356		9e 00 08	stz $0800,x	                stz $0800,x
204	.f359		a0 03		ldy #$03	                ldy #$03
205	.f35b						loop:
206	.f35b		99 2c 08	sta $082c,y	                sta $082C,y
207	.f35e		88		dey		                dey
208	.f35f		10 fa		bpl $f35b	                bpl loop
209	.f361		8c 38 08	sty $0838	                sty $0838
210	.f364		80 63		bra $f3c9	                bra LF5DA
211							                .endblock

213							;-------------------------------------------------------------------------

215	.f366						LF577:
216	.f366		08		php		                php
217	.f367		78		sei		                sei
218	.f368		bd 08 08	lda $0808,x	                lda $0808,x
219	.f36b		c9 04		cmp #$04	                cmp #$04
220	.f36d		d0 0a		bne $f379	                bne LF58A
221	.f36f		20 97 e8	jsr $e897	                jsr osbyte98
222	.f372		90 05		bcc $f379	                bcc LF58A
223	.f374		a9 00		lda #$00	                lda #$00
224	.f376		9e 00 08	stz $0800,x	                stz $0800,x
225	.f379						LF58A:
226	.f379		28		plp		                plp
227	.f37a						LF58B:
228	.f37a		bc 20 08	ldy $0820,x	                ldy $0820,x
229	.f37d		c0 ff		cpy #$ff	                cpy #$FF
230	.f37f		d0 72		bne $f3f3	                bne LF604

232							                ; https://tobylobster.github.io/mos/mos/S-s16.html#SP2
233	.f381						LF592:
234	.f381		a9 04		lda #$04	                lda #$04
235	.f383		9d 08 08	sta $0808,x	                sta $0808,x
236	.f386		a9 c0		lda #$c0	                lda #$C0
237	.f388						LF599:
238	.f388		9d 04 08	sta $0804,x	                sta $0804,x
239	.f38b		ac 62 02	ldy $0262	                ldy soundSuppressionStatus
240	.f38e		f0 02		beq $f392	                beq LF5A3
241	.f390		a9 c0		lda #$c0	                lda #$C0
242	.f392						LF5A3:
243	.f392		38		sec		                sec
244	.f393		e9 40		sbc #$40	                sbc #$40
245	.f395		4a		lsr a		                lsr a
246	.f396		4a		lsr a		                lsr a
247	.f397		4a		lsr a		                lsr a
248	.f398		49 0f		eor #$0f	                eor #$0F
249	.f39a		1d fa f1	ora $f1fa,x	                ora soundParameterTable-bufferNumberSound0,x
250	.f39d		09 10		ora #$10	                ora #$10
251	.f39f		80 34		bra $f3d5	                bra LF5E6

253	.f3a1						LF5B2:
254	.f3a1		20 97 e8	jsr $e897	                jsr osbyte98
255	.f3a4		b0 c0		bcs $f366	                bcs LF577
256	.f3a6		29 03		and #$03	                and #$03
257	.f3a8		f0 9f		beq $f349	                beq LF55A
258	.f3aa		ad 38 08	lda $0838	                lda $0838
259	.f3ad		f0 cb		beq $f37a	                beq LF58B
260	.f3af		fe 28 08	inc $0828,x	                inc $0828,x
261	.f3b2		a8		tay		                tay
262	.f3b3		10 0a		bpl $f3bf	                bpl LF5D0
263	.f3b5		20 97 e8	jsr $e897	                jsr osbyte98
264	.f3b8		29 03		and #$03	                and #$03
265	.f3ba		8d 38 08	sta $0838	                sta $0838
266	.f3bd		80 bb		bra $f37a	                bra LF58B

268	.f3bf						LF5D0:
269	.f3bf		ce 38 08	dec $0838	                dec $0838
270	.f3c2		80 b6		bra $f37a	                bra LF58B

272	.f3c4						LF5D5:
273	.f3c4		dd 2c 08	cmp $082c,x	                cmp $082C,x
274	.f3c7		f0 2a		beq $f3f3	                beq LF604
275	.f3c9						LF5DA:
276	.f3c9		9d 2c 08	sta $082c,x	                sta $082C,x
277	.f3cc		e0 04		cpx #$04	                cpx #$04
278	.f3ce		d0 24		bne $f3f4	                bne LF605
279	.f3d0		29 0f		and #$0f	                and #$0F
280	.f3d2		1d fa f1	ora $f1fa,x	                ora soundParameterTable-bufferNumberSound0,x
281	.f3d5						LF5E6:
282	.f3d5		08		php		                php
283	.f3d6						LF5E7:
284	.f3d6		78		sei		                sei
285	.f3d7		a0 ff		ldy #$ff	                ldy #$FF
286	.f3d9		8c 43 fe	sty $fe43	                sty systemVIA.ddra
287	.f3dc		8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake
288	.f3df		c8		iny		                iny
289	.f3e0		8c 40 fe	sty $fe40	                sty systemVIA.orb
290	.f3e3		a0 02		ldy #$02	                ldy #$02
291	.f3e5						LF5F6:
292	.f3e5		88		dey		                dey
293	.f3e6		d0 fd		bne $f3e5	                bne LF5F6
294	.f3e8		a0 08		ldy #$08	                ldy #$08
295	.f3ea		8c 40 fe	sty $fe40	                sty systemVIA.orb
296	.f3ed		a0 04		ldy #$04	                ldy #$04
297	.f3ef						LF600:
298	.f3ef		88		dey		                dey
299	.f3f0		d0 fd		bne $f3ef	                bne LF600
300	.f3f2		28		plp		                plp
301	.f3f3						LF604:
302	.f3f3		60		rts		                rts

304	.f3f4						LF605:
305	.f3f4		48		pha		                pha
306	.f3f5		29 03		and #$03	                and #$03
307	.f3f7		8d 3c 08	sta $083c	                sta $083C
308	.f3fa		9c 3d 08	stz $083d	                stz $083D
309	.f3fd		68		pla		                pla
310	.f3fe		4a		lsr a		                lsr a
311	.f3ff		4a		lsr a		                lsr a
312	.f400						LF611:
313	.f400		c9 0c		cmp #$0c	                cmp #$0C
314	.f402		90 07		bcc $f40b	                bcc LF61C
315	.f404		ee 3d 08	inc $083d	                inc $083D
316	.f407		e9 0c		sbc #$0c	                sbc #$0C
317	.f409		d0 f5		bne $f400	                bne LF611
318	.f40b						LF61C:
319	.f40b		a8		tay		                tay
320	.f40c		ad 3d 08	lda $083d	                lda $083D
321	.f40f		48		pha		                pha
322	.f410		b9 d3 f4	lda $f4d3,y	                lda LF6E4,y
323	.f413		8d 3d 08	sta $083d	                sta $083D
324	.f416		b9 df f4	lda $f4df,y	                lda LF6F0,y
325	.f419		48		pha		                pha
326	.f41a		29 03		and #$03	                and #$03
327	.f41c		8d 3e 08	sta $083e	                sta $083E
328	.f41f		68		pla		                pla
329							                .if version==350
331							                .else
332	.f420		4a		lsr a		                lsr a
333	.f421		4a		lsr a		                lsr a
334	.f422		4a		lsr a		                lsr a
335	.f423		4a		lsr a		                lsr a
336							                .endif
337	.f424		8d 3f 08	sta $083f	                sta $083F
338	.f427		ad 3d 08	lda $083d	                lda $083D
339	.f42a		ac 3c 08	ldy $083c	                ldy $083C
340	.f42d		f0 0c		beq $f43b	                beq LF64C
341	.f42f						LF640:
342	.f42f		38		sec		                sec
343	.f430		ed 3f 08	sbc $083f	                sbc $083F
344	.f433		b0 03		bcs $f438	                bcs LF649
345	.f435		ce 3e 08	dec $083e	                dec $083E
346	.f438						LF649:
347	.f438		88		dey		                dey
348	.f439		d0 f4		bne $f42f	                bne LF640
349	.f43b						LF64C:
350	.f43b		8d 3d 08	sta $083d	                sta $083D
351	.f43e		68		pla		                pla
352	.f43f		a8		tay		                tay
353	.f440		f0 09		beq $f44b	                beq LF65C
354	.f442						LF653:
355	.f442		4e 3e 08	lsr $083e	                lsr $083E
356	.f445		6e 3d 08	ror $083d	                ror $083D
357	.f448		88		dey		                dey
358	.f449		d0 f7		bne $f442	                bne LF653
359	.f44b						LF65C:
360	.f44b		ad 3d 08	lda $083d	                lda $083D
361	.f44e		18		clc		                clc
362	.f44f		7d 63 e1	adc $e163,x	                adc LE165,x
363	.f452		8d 3d 08	sta $083d	                sta $083D
364	.f455		90 03		bcc $f45a	                bcc LF66B
365	.f457		ee 3e 08	inc $083e	                inc $083E
366	.f45a						LF66B:
367	.f45a		29 0f		and #$0f	                and #$0F
368	.f45c		1d fa f1	ora $f1fa,x	                ora soundParameterTable-bufferNumberSound0,x
369	.f45f		08		php		                php
370	.f460		78		sei		                sei
371	.f461		20 d5 f3	jsr $f3d5	                jsr LF5E6
372	.f464		ad 3d 08	lda $083d	                lda $083D
373	.f467		4e 3e 08	lsr $083e	                lsr $083E
374	.f46a		6a		ror a		                ror a
375	.f46b		4e 3e 08	lsr $083e	                lsr $083E
376	.f46e		6a		ror a		                ror a
377	.f46f		4a		lsr a		                lsr a
378	.f470		4a		lsr a		                lsr a
379	.f471		4c d6 f3	jmp $f3d6	                jmp LF5E7

381	.f474						LF685:
382	.f474		08		php		                php
383	.f475		78		sei		                sei
384	.f476		20 9c e8	jsr $e89c	                jsr osbyte91
385	.f479		48		pha		                pha
386	.f47a		29 04		and #$04	                and #$04
387	.f47c		f0 13		beq $f491	                beq LF6A2
388	.f47e		68		pla		                pla
389	.f47f		bc 20 08	ldy $0820,x	                ldy $0820,x
390	.f482		c8		iny		                iny
391	.f483		d0 03		bne $f488	                bne LF699Sound
392	.f485		20 81 f3	jsr $f381	                jsr LF592
393	.f488						LF699Sound:
394	.f488		20 9c e8	jsr $e89c	                jsr osbyte91
395	.f48b		20 9c e8	jsr $e89c	                jsr osbyte91
396	.f48e		28		plp		                plp
397	.f48f		80 3e		bra $f4cf	                bra LF6E0

399	.f491						LF6A2:
400	.f491		68		pla		                pla
401	.f492		29 f8		and #$f8	                and #$F8
402	.f494		0a		asl a		                asl a
403	.f495		90 0b		bcc $f4a2	                bcc LF6B3Sound
404	.f497		49 ff		eor #$ff	                eor #$FF
405	.f499		4a		lsr a		                lsr a
406	.f49a		38		sec		                sec
407	.f49b		e9 40		sbc #$40	                sbc #$40
408	.f49d		20 88 f3	jsr $f388	                jsr LF599
409	.f4a0		a9 ff		lda #$ff	                lda #$FF
410	.f4a2						LF6B3Sound:
411	.f4a2		9d 20 08	sta $0820,x	                sta $0820,x
412	.f4a5		a9 05		lda #$05	                lda #$05
413	.f4a7		9d 1c 08	sta $081c,x	                sta $081C,x
414	.f4aa		a9 01		lda #$01	                lda #$01
415	.f4ac		9d 24 08	sta $0824,x	                sta $0824,x
416	.f4af		9e 14 08	stz $0814,x	                stz $0814,x
417	.f4b2		9e 08 08	stz $0808,x	                stz $0808,x
418	.f4b5		9e 30 08	stz $0830,x	                stz $0830,x
419	.f4b8		a9 ff		lda #$ff	                lda #$FF
420	.f4ba		9d 10 08	sta $0810,x	                sta $0810,x
421	.f4bd		20 9c e8	jsr $e89c	                jsr osbyte91
422	.f4c0		9d 0c 08	sta $080c,x	                sta $080C,x
423	.f4c3		20 9c e8	jsr $e89c	                jsr osbyte91
424	.f4c6		28		plp		                plp
425	.f4c7		48		pha		                pha
426	.f4c8		bd 0c 08	lda $080c,x	                lda $080C,x
427	.f4cb		20 c4 f3	jsr $f3c4	                jsr LF5D5
428	.f4ce		68		pla		                pla
429	.f4cf						LF6E0:
430	.f4cf		9d 18 08	sta $0818,x	                sta $0818,x
431	.f4d2		60		rts		                rts

433	.f4d3						LF6E4:
434	>f4d3		f0				                .byte $F0
435	>f4d4		b7				                .byte $B7
436	>f4d5		82				                .byte $82
437	>f4d6		4f				                .byte $4F
438	>f4d7		20				                .byte $20
439	>f4d8		f3				                .byte $F3
440	>f4d9		c8				                .byte $C8
441	>f4da		a0				                .byte $A0
442	>f4db		7b				                .byte $7B
443	>f4dc		57				                .byte $57
444	>f4dd		35				                .byte $35
445	>f4de		16				                .byte $16
446	.f4df						LF6F0:
447	>f4df		e7				                .byte $E7
448	>f4e0		d7				                .byte $D7
449	>f4e1		cb				                .byte $CB
450	>f4e2		c3				                .byte $C3
451	>f4e3		b7				                .byte $B7
452	>f4e4		aa				                .byte $AA
453	>f4e5		a2				                .byte $A2
454	>f4e6		9a				                .byte $9a
455	>f4e7		92				                .byte $92
456	>f4e8		8a				                .byte $8a
457	>f4e9		82				                .byte $82
458	>f4ea		7a				                .byte $7a


:12	;******  Return to file: src/mos.s65

11834							                .endif

11836							;-------------------------------------------------------------------------

11838							                .if version>=500
11859							                .endif

11861							;-------------------------------------------------------------------------

11863							                .if version==350
11869							                .endif

11871							;-------------------------------------------------------------------------

11873							                .if version==350
11881							                .endif

11883							;-------------------------------------------------------------------------

11885							                .if version==350
11890							                .endif

11892							;-------------------------------------------------------------------------

11894	.f4eb						LF6FC:
11895	.f4eb		a9 ff		lda #$ff	                lda #$FF
11896	.f4ed		85 f5		sta $f5		                sta $F5
11897	.f4ef		60		rts		                rts

11899	.f4f0						LF701:
11900	.f4f0		e6 f5		inc $f5		                inc $F5
11901	.f4f2		a4 f5		ldy $f5		                ldy $F5
11902	.f4f4		a2 0d		ldx #$0d	                ldx #romServiceCallROMFilingSystemInitialize
11903	.f4f6						LF707:
11904	.f4f6		08		php		                php
11905	.f4f7		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
11906	.f4fa		28		plp		                plp
11907	.f4fb		c9 01		cmp #$01	                cmp #$01
11908	.f4fd		98		tya		                tya
11909	.f4fe		60		rts		                rts

11911	.f4ff						LF710:
11912	.f4ff		a2 0e		ldx #$0e	                ldx #$0E
11913	.f501		a0 ff		ldy #$ff	                ldy #$FF
11914	.f503		4c f6 f4	jmp $f4f6	                jmp LF707

11916	.f506						LF717:
11917	.f506		ad cb 03	lda $03cb	                lda $03CB
11918	.f509		85 f6		sta $f6		                sta $F6
11919	.f50b		ad cc 03	lda $03cc	                lda $03CC
11920	.f50e		85 f7		sta $f7		                sta $F7
11921	.f510		a5 f5		lda $f5		                lda $F5
11922	.f512		60		rts		                rts

11924	.f513						tidyUpAfterKeyboardProcessing:
11925	.f513		a2 ff		ldx #$ff	                ldx #$FF
11926	.f515		a5 ec		lda $ec		                lda lastKeyPressedInternal
11927	.f517		05 ed		ora $ed		                ora firstKeyPressedInternal
11928	.f519		d0 06		bne $f521	                bne +                    ;taken if any keys pressed
11929	.f51b		a9 81		lda #$81	                lda #$81
11930	.f51d		8d 4e fe	sta $fe4e	                sta systemVIA.ier            ;re-enable keyboard IRQ
11931	.f520		e8		inx		                inx                          ;X=0
11932	.f521						+
11933	.f521		8e 42 02	stx $0242	                stx keyboardSemaphore
11934	.f524						updateKeyboardLEDs:
11935	.f524		08		php		                php
11936	.f525		ad 5a 02	lda $025a	                lda keyboardStatusByte
11937	.f528		4a		lsr a		                lsr a

11939							                ; bit 3 = caps lock off
11940							                ; bit 4 = shift lock off
11941	.f529		29 18		and #$18	                and #(keyboardStatusByte.capsLockDisengaged|keyboardStatusByte.shiftLockDisengaged)>>1
11942	.f52b		09 06		ora #$06	                ora #$06                     ;latch B6 - caps lock
11943	.f52d		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;update caps lock LED
11944	.f530		4a		lsr a		                lsr a                        ;bit 3 = shift lock off
11945	.f531		09 07		ora #$07	                ora #$07                     ;latch B7 - shift lock
11946	.f533		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;update shift lock LED
11947	.f536		20 0b f7	jsr $f70b	                jsr enableKeyboardScanning
11948	.f539		68		pla		                pla
11949	.f53a		60		rts		                rts

11951							; KEYV handler
11952							; ============
11953	.f53b						keyEntryPoint:
11954	.f53b		50 0a		bvc $f547	                bvc keyVClear
11955	.f53d		a9 01		lda #$01	                lda #$01
11956	.f53f		8d 4e fe	sta $fe4e	                sta systemVIA.ier
11957	.f542		b0 08		bcs $f54c	                bcs keyboardTimerInterrupt
11958	.f544		4c 54 f6	jmp $f654	                jmp keyPressedInterrupt

11960	.f547						keyVClear:
11961	.f547		90 06		bcc $f54f	                bcc keyTestSHIFTAndCTRLOrTimerInterrupt
11962	.f549		4c 05 f7	jmp $f705	                jmp scanKeyboard

11964	.f54c						keyboardTimerInterrupt:
11965	.f54c		ee 42 02	inc $0242	                inc keyboardSemaphore

11967							;-------------------------------------------------------------------------
11968							;
11969							; Test Shift & Ctrl keys, or deal with timer interrupt.
11970							;
11971							; Entry: C=0 if KEYV V=0 C=0 - test SHIFT+CTRL keys
11972							;        C=1 if KEYV V=1 C=1 - keyboard timer interrupt
11973							;
11974	.f54f						keyTestSHIFTAndCTRLOrTimerInterrupt:
11975	.f54f		ad 5a 02	lda $025a	                lda keyboardStatusByte
11976	.f552		29 b7		and #$b7	                and #~(keyboardStatusByte.shiftPressed|keyboardStatusByte.ctrlPressed)
11977	.f554		a2 00		ldx #$00	                ldx #key_shift
11978	.f556		20 6f f6	jsr $f66f	                jsr interrogateKeyboard      ;X=$80 if SHIFT pressed
11979	.f559		90 02		bcc $f55d	                bcc +                        ;taken if testing
11980							                                             ;SHIFT+CTRL only
11981	.f55b		86 fa		stx $fa		                stx SEIWKA                   ;b7 set if SHIFT pressed
11982	.f55d						+
11983	.f55d		b8		clv		                clv                        ;V=0
11984	.f55e		10 05		bpl $f565	                bpl testCTRL               ;taken if SHIFT not pressed
11985	.f560		2c 5e e3	bit $e35e	                bit valueFF                ;V=1 N=1
11986	.f563		09 08		ora #$08	                ora #keyboardStatusByte.shiftPressed
11987	.f565						testCTRL:
11988	.f565		e8		inx		                inx                          ;X=1 - key_ctrl
11989	.f566		20 6f f6	jsr $f66f	                jsr interrogateKeyboard
11990	.f569		90 b9		bcc $f524	                bcc updateKeyboardLEDs ;taken if testing SHIFT+CTRL only
11991	.f56b		10 02		bpl $f56f	                bpl updateKeyboardStatusByte ;taken if CTRL not pressed
11992	.f56d		09 40		ora #$40	                ora #keyboardStatusByte.ctrlPressed
11993	.f56f						updateKeyboardStatusByte:
11994	.f56f		8d 5a 02	sta $025a	                sta keyboardStatusByte
11995	.f572		a6 ec		ldx $ec		                ldx lastKeyPressedInternal
11996	.f574		f0 4d		beq $f5c3	                beq braRolloverChecks        ;taken if no key pressed
11997	.f576		20 6f f6	jsr $f66f	                jsr interrogateKeyboard      ;still pressed?
11998	.f579		30 0d		bmi $f588	                bmi checkForKeyAutoRepeat    ;taken if still pressed
11999	.f57b		e4 ec		cpx $ec		                cpx lastKeyPressedInternal   ;X=0 at this point
12000	.f57d						storeLastKeyPressed:
12001	.f57d		86 ec		stx $ec		                stx lastKeyPressedInternal   ;update last key pressed
12002	.f57f		d0 42		bne $f5c3	                bne braRolloverChecks  ;taken if still nothing pressed
12003	.f581		64 ec		stz $ec		                stz lastKeyPressedInternal   ;reset last key pressed
12004	.f583						resetAutoRepeatAndContinue:
12005	.f583		20 64 f6	jsr $f664	                jsr resetAutoRepeatCounters
12006	.f586		80 3b		bra $f5c3	                bra braRolloverChecks

12008	.f588						checkForKeyAutoRepeat:
12009	.f588		e4 ec		cpx $ec		                cpx lastKeyPressedInternal
12010	.f58a		d0 f1		bne $f57d	                bne storeLastKeyPressed      ;taken if new key pressed
12011	.f58c		a5 e7		lda $e7		                lda autoRepeatCountdownTimer
12012	.f58e		f0 33		beq $f5c3	                beq braRolloverChecks      ;taken if countdown timer 0
12013	.f590		c6 e7		dec $e7		                dec autoRepeatCountdownTimer ;timer--
12014	.f592		d0 2f		bne $f5c3	                bne braRolloverChecks        ;taken if timer newly 0
12015	.f594		ad ca 02	lda $02ca	                lda keyboardFirstAutoRepeatCount
12016	.f597		85 e7		sta $e7		                sta autoRepeatCountdownTimer
12017	.f599		ad 55 02	lda $0255	                lda keyboardAutoRepeatRate
12018	.f59c		8d ca 02	sta $02ca	                sta keyboardFirstAutoRepeatCount
12019	.f59f		ad 5a 02	lda $025a	                lda keyboardStatusByte
12020	.f5a2		a6 ec		ldx $ec		                ldx lastKeyPressedInternal
12021	.f5a4		e0 d0		cpx #$d0	                cpx #$80|key_shift_lock
12022	.f5a6		f0 12		beq $f5ba	                beq shiftLockPressed
12023	.f5a8		e0 c0		cpx #$c0	                cpx #$80|key_caps_lock
12024							                .if version>=511||version==350
12026							                .else
12027	.f5aa		d0 19		bne $f5c5	                bne getASCIICode
12028							                .endif
12029	.f5ac						capsLockPressed:
12030	.f5ac		09 a0		ora #$a0	                ora #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
12031	.f5ae		24 fa		bit $fa		                bit SEIWKA                   ;test SHIFT status
12032	.f5b0		10 04		bpl $f5b6	                bpl +                        ;taken if SHIFT not pressed
12033							                ; Do the SHIFT+CAPS LOCK thing
12034	.f5b2		09 10		ora #$10	                ora #keyboardStatusByte.capsLockDisengaged
12035	.f5b4		49 80		eor #$80	                eor #keyboardStatusByte.shiftEnabled
12036	.f5b6						+
12037	.f5b6		49 90		eor #$90	                eor #keyboardStatusByte.shiftEnabled|keyboardStatusByte.capsLockDisengaged
12038	.f5b8		80 04		bra $f5be	                bra resetKeyboardStatusAndTimer

12040	.f5ba						shiftLockPressed:
12041	.f5ba		09 90		ora #$90	                ora #keyboardStatusByte.shiftEnabled|keyboardStatusByte.capsLockDisengaged
12042	.f5bc		49 a0		eor #$a0	                eor #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
12043	.f5be						resetKeyboardStatusAndTimer:
12044	.f5be		8d 5a 02	sta $025a	                sta keyboardStatusByte
12045	.f5c1		64 e7		stz $e7		                stz autoRepeatCountdownTimer
12046	.f5c3						braRolloverChecks:
12047							                .if version<500&&version!=350
12048	.f5c3		80 6f		bra $f634	                bra keyboardRolloverChecks
12051							                .endif

12053							;-------------------------------------------------------------------------

12055							                .if version>=511||version==350
12083							                .endif
12084							;-------------------------------------------------------------------------
12085							;
12086							; Convert internal key number (with bit 7 set) to ASCII code, taking
12087							; into account state of CTRL, SHIFT, CAPS LOCK and SHIFT LOCK.
12088							;
12089	.f5c5						getASCIICode:
12090							                ; -$80 to adjust for bit 7 set; -16 because
12091							                ; interesting keys start at 16
12092	.f5c5		bd f1 f5	lda $f5f1,x	                lda keyTranslationTable-$80-16,x
12093							                .if version>=500
12109							                .endif
12110	.f5c8		f0 08		beq $f5d2	                beq handleTAB                ;taken if TAB
12111	.f5ca		c9 9d		cmp #$9d	                cmp #$9D                     ;was it key_numpad_return?
12112							                .if version<500&&version!=350
12113	.f5cc		d0 07		bne $f5d5	                bne handleKey                ;taken if not
12116							                .endif

12118							                ;Transform $9d into $8d, aka 13|$80. ($8d is already
12119							                ; used in the table for right arrow.)
12120	.f5ce		49 10		eor #$10	                eor #$10
12121	.f5d0		80 07		bra $f5d9	                bra getNumpadASCIICode

12123	.f5d2						handleTAB:
12124	.f5d2		ad 6b 02	lda $026b	                lda tabKeyCode
12125							                .if version>=500
12158							                .endif
12159	.f5d5						handleKey:
12160	.f5d5		c9 a0		cmp #$a0	                cmp #$A0                     ;numpad key?
12161	.f5d7		90 0c		bcc $f5e5	                bcc processModifiers         ;taken if not
12162	.f5d9						getNumpadASCIICode:
12163							                .if version>=500||version==350
12165							                .endif
12166							                ; C=1 at this point
12167	.f5d9		e9 31		sbc #$31	                sbc #'0'+1      ;+1 to compensate for C=1 in the next
12168							                                ;addition
12169	.f5db		6d 7e 02	adc $027e	                adc numericKeypadInterpretation ;form actual ASCII value
12170							                .if version>=500||version==350
12172							                .endif
12173	.f5de		49 80		eor #$80	                eor #$80                     ;clear bit 7
12174	.f5e0		ae 8e 02	ldx $028e	                ldx numericKeypadShiftEffect ;does SHIFT affect the
12175							                                             ;keypad?
12176	.f5e3		d0 43		bne $f628	                bne LF839                    ;taken if no
12177	.f5e5						processModifiers:
12178	.f5e5		ae 5a 02	ldx $025a	                ldx keyboardStatusByte
12179	.f5e8		86 fa		stx $fa		                stx SEIWKA
12180	.f5ea		26 fa		rol $fa		                rol SEIWKA                  ;b7 = ctrlPressed
12181	.f5ec		10 07		bpl $f5f5	                bpl testShiftLock           ;taken if ctrl not pressed
12182	.f5ee		a6 ed		ldx $ed		                ldx firstKeyPressedInternal
12183	.f5f0						localResetAutoRepeatAndContinue:
12184							                .if version<500&&version!=350
12185	.f5f0		d0 91		bne $f583	                bne resetAutoRepeatAndContinue
12186	.f5f2		20 25 f1	jsr $f125	                jsr implementCTRLCodes
12192							                .endif
12193	.f5f5						testShiftLock:
12194	.f5f5		26 fa		rol $fa		                rol SEIWKA                   ;b7 = shiftLockDisengaged
12195	.f5f7		30 07		bmi $f600	                bmi testCapsLock             ;taken if shift lock off
12196	.f5f9		20 02 f1	jsr $f102	                jsr implementShift           ;shift lock on - apply shift
12197	.f5fc		26 fa		rol $fa		                rol SEIWKA                   ;b7 = capsLockDisengaged
12198	.f5fe		80 0c		bra $f60c	                bra testShiftEnabled

12200	.f600						testCapsLock:
12201	.f600		26 fa		rol $fa		                rol SEIWKA                   ;b7 = capsLockDisengaged
12202	.f602		30 0d		bmi $f611	                bmi testShift                ;taken if caps lock off
12203	.f604		20 19 e9	jsr $e919	                jsr isLetter
12204	.f607		b0 08		bcs $f611	                bcs testShift                ;taken if not a letter
12205	.f609		20 02 f1	jsr $f102	                jsr implementShift ;letter + caps lock - make upper case
12206	.f60c						testShiftEnabled:
12207	.f60c		ae 5a 02	ldx $025a	                ldx keyboardStatusByte       ;b7 = shiftEnabled
12208	.f60f		10 0b		bpl $f61c	                bpl testEscape               ;taken if not shiftEnabled
12209	.f611						testShift:
12210	.f611		26 fa		rol $fa		                rol SEIWKA                   ;b7 = shiftPressed
12211	.f613		10 07		bpl $f61c	                bpl testEscape               ;taken if not shiftPressed
12212	.f615		a6 ed		ldx $ed		                ldx firstKeyPressedInternal
12213	.f617		d0 d7		bne $f5f0	                bne localResetAutoRepeatAndContinue
12214	.f619		20 02 f1	jsr $f102	                jsr implementShift
12215	.f61c						testEscape:
12216	.f61c		cd 6c 02	cmp $026c	                cmp escapeCharacter
12217	.f61f		d0 07		bne $f628	                bne LF839
12218	.f621		ae 75 02	ldx $0275	                ldx escapeKeyStatus
12219	.f624		d0 02		bne $f628	                bne LF839
12220	.f626		64 e7		stz $e7		                stz autoRepeatCountdownTimer

12222	.f628						LF839:

12224							                .if version==350
12244							                .elsif version<500

12246	.f628		a8		tay		                tay
12247	.f629		20 95 f7	jsr $f795	                jsr enableKeyboardScanningFlippingInterrupts
12248	.f62c		ad 59 02	lda $0259	                lda keyboardStatus
12249	.f62f		d0 03		bne $f634	                bne keyboardRolloverChecks
12250	.f631		20 26 e9	jsr $e926	                jsr insertCharacterIntoKeyboardBuffer

12340							                .endif

12342	.f634						keyboardRolloverChecks:
12343	.f634		a6 ed		ldx $ed		                ldx firstKeyPressedInternal
12344	.f636		f0 09		beq $f641	                beq LF852                    ;taken if 1 key down
12345	.f638		20 6f f6	jsr $f66f	                jsr interrogateKeyboard      ;test first key pressed
12346	.f63b		86 ed		stx $ed		                stx firstKeyPressedInternal  ;save it
12347	.f63d		30 18		bmi $f657	                bmi LF868                    ;taken if still pressed
12348	.f63f		64 ed		stz $ed		                stz firstKeyPressedInternal  ;reset first key
12349	.f641						LF852:
12350	.f641		a0 ec		ldy #$ec	                ldy #lastKeyPressedInternal
12351	.f643		20 5b f7	jsr $f75b	                jsr scanKeyboardWithExclusion
12352	.f646		30 09		bmi $f651	                bmi LF862
12353	.f648		a5 ec		lda $ec		                lda lastKeyPressedInternal
12354	.f64a		85 ed		sta $ed		                sta firstKeyPressedInternal
12355	.f64c						updateLastKeyPressedInternal:
12356	.f64c		86 ec		stx $ec		                stx lastKeyPressedInternal
12357	.f64e		20 64 f6	jsr $f664	                jsr resetAutoRepeatCounters
12358	.f651						LF862:
12359	.f651		4c 13 f5	jmp $f513	                jmp tidyUpAfterKeyboardProcessing

12361	.f654						keyPressedInterrupt:
12362	.f654		20 6f f6	jsr $f66f	                jsr interrogateKeyboard
12363	.f657						LF868:
12364	.f657		a5 ec		lda $ec		                lda lastKeyPressedInternal
12365	.f659		d0 f6		bne $f651	                bne LF862
12366	.f65b		a0 ed		ldy #$ed	                ldy #firstKeyPressedInternal
12367	.f65d		20 5b f7	jsr $f75b	                jsr scanKeyboardWithExclusion
12368	.f660		30 ef		bmi $f651	                bmi LF862
12369	.f662		80 e8		bra $f64c	                bra updateLastKeyPressedInternal

12371	.f664						resetAutoRepeatCounters:
12372	.f664		a2 01		ldx #$01	                ldx #$01
12373	.f666		86 e7		stx $e7		                stx autoRepeatCountdownTimer
12374	.f668		ae 54 02	ldx $0254	                ldx keyboardAutoRepeatDelay
12375	.f66b		8e ca 02	stx $02ca	                stx keyboardFirstAutoRepeatCount
12376	.f66e		60		rts		                rts

12378							;-------------------------------------------------------------------------
12379							;
12380							; Read a single key's state from the keyboard
12381							;
12382							; Entry:
12383							;
12384							; X = key to test
12385							;
12386							; Exit:
12387							;
12388							; X=$80, N=1 if key pressed; X=$00, N=0 if key not pressed
12389							;
12390							; Preserves: A/C
12391							;
12392							                .if version==350
12395							                .endif
12396	.f66f						interrogateKeyboard:
12397	.f66f		a0 03		ldy #$03	                ldy #$03                     ;write to keyboard
12398	.f671		8c 40 fe	sty $fe40	                sty systemVIA.orb
12399	.f674		a0 7f		ldy #$7f	                ldy #$7F
12400	.f676		8c 43 fe	sty $fe43	                sty systemVIA.ddra           ;bit 7=input, bits 6-0=output
12401	.f679		8e 4f fe	stx $fe4f	                stx systemVIA.oraNoHandshake ;store key value
12402	.f67c		ea		nop		                nop
12403	.f67d		ae 4f fe	ldx $fe4f	                ldx systemVIA.iraNoHandshake ;read key state
12404	.f680		60		rts		                rts

12406							; Default keyboard table
12407							; ======================

12409	.f681						keyTranslationTable:
12410	>f681		71				                .text "q"                    ;10 q
12411	>f682		33				                .byte "3"                    ;11 3
12412	>f683		34				                .byte "4"                    ;12 4
12413	>f684		35				                .byte "5"                    ;13 5
12414	>f685		84				                .byte $84                    ;14 f4
12415	>f686		38				                .text "8"                    ;15 8
12416	>f687		87				                .byte $87                    ;16 f7
12417	>f688		2d				                .text "-"                    ;17 minus
12418	>f689		5e				                .text "^"                    ;18 caret
12419	>f68a		8c				                .byte $8C                    ;19 left
12420	>f68b		b6				                .byte "6"|$80                ;1a numpad_6
12421	>f68c		b7				                .byte "7"|$80                ;1b numpad_7
12422	.f68d						osbyte92:
12423	.f68d		bc 00 fc	ldy $fc00,x	                ldy $FC00,x                  ;1c 1d 1e
12424	.f690		60		rts		                rts                          ;1f

12426							                .cerror *-keyTranslationTable!=16,'oops'
12427	>f691		80				                .byte $80                    ;20 f0
12428	>f692		77				                .text "w"                    ;21 w
12429	>f693		65				                .text "e"                    ;22 e
12430	>f694		74				                .text "t"                    ;23 t
12431	>f695		37				                .text "7"                    ;24 7
12432	>f696		69				                .text "i"                    ;25 i
12433	>f697		39				                .text "9"                    ;26 9
12434	>f698		30				                .text "0"                    ;27 0
12435	>f699		5f				                .text "_"                    ;28 underline
12436	>f69a		8e				                .byte $8E                    ;29 down
12437	>f69b		b8				                .byte "8"|$80                ;2a numpad_8
12438	>f69c		b9				                .byte "9"|$80                ;2b numpad_9
12439	.f69d						osbyte94:
12440	.f69d		bc 00 fd	ldy $fd00,x	                ldy $FD00,x                  ;2c 2d 2e
12441	.f6a0		60		rts		                rts                          ;2f

12443							                .cerror *-keyTranslationTable!=32,'oops'
12444	>f6a1		31				                .text "1"                    ;30 1
12445	>f6a2		32				                .text "2"                    ;31 2
12446	>f6a3		64				                .text "d"                    ;32 d
12447	>f6a4		72				                .text "r"                    ;33 r
12448	>f6a5		36				                .text "6"                    ;34 6
12449	>f6a6		75				                .text "u"                    ;35 u
12450	>f6a7		6f				                .text "o"                    ;36 o
12451	>f6a8		70				                .text "p"                    ;37 p
12452	>f6a9		5b				                .text "["                    ;38 left_square_bracket
12453	>f6aa		8f				                .byte $8F                    ;39 up
12454	>f6ab		ab				                .byte "+"|$80                ;3a numpad_plus
12455	>f6ac		ad				                .byte "-"|$80                ;3b numpad_minus
12456	>f6ad		9d				                .byte $9D                    ;3c numpad_return
12457	.f6ae						LF8BF:
12458	.f6ae		6c 20 02	jmp ($0220)	                jmp (EVENTV)                 ;3d 3e 3f
12459							                .cerror *-keyTranslationTable!=48,'oops'
12460	>f6b1		01				                .byte 1                      ;40 caps_lock
12461	>f6b2		61				                .text "a"                    ;41 a
12462	>f6b3		78				                .text "x"                    ;42 x
12463	>f6b4		66				                .text "f"                    ;43 f
12464	>f6b5		79				                .text "y"                    ;44 y
12465	>f6b6		6a				                .text "j"                    ;45 j
12466	>f6b7		6b				                .text "k"                    ;46 k
12467							                .if version<500
12468	>f6b8		40				                .text "@"                    ;47 at
12471							                .endif
12472	>f6b9		3a				                .text ":"                    ;48 colon
12473	>f6ba		0d				                .byte $0D                    ;49 return
12474	>f6bb		af				                .byte "/"|$80                ;4a numpad_divide
12475	>f6bc		ff				                .byte 127|$80                ;4b numpad_delete
12476	>f6bd		ae				                .byte "."|$80                ;4c numpad_stop
12477	.f6be						call1MHzBusHook:
12478	.f6be		6c fe fd	jmp ($fdfe)	                jmp ($FDFE)                  ;4d 4e 4f

12480							                .cerror *-keyTranslationTable!=64,'oops'
12481	>f6c1		02				                .byte 2                      ;50 shift_lock
12482	>f6c2		73				                .text "s"                    ;51 s
12483	>f6c3		63				                .text "c"                    ;52 c
12484	>f6c4		67				                .text "g"                    ;53 g
12485	>f6c5		68				                .text "h"                    ;54 h
12486	>f6c6		6e				                .text "n"                    ;55 n
12487	>f6c7		6c				                .text "l"                    ;56 l
12488	>f6c8		3b				                .text ";"                    ;57 semicolon
12489	>f6c9		5d				                .text "]"                    ;58 right_square_bracket
12490	>f6ca		7f				                .byte $7F                    ;59 delete
12491	>f6cb		a3				                .byte "#"|$80                ;5a numpad_hash
12492	>f6cc		aa				                .byte "*"|$80                ;5b numpad_multiply
12493	>f6cd		ac				                .byte ","|$80                ;5c numpad_comma
12494	.f6ce						callSEIWKA:
12495	.f6ce		6c fa 00	jmp ($00fa)	                jmp (SEIWKA)                 ;5d 5e 5f
12496							                .cerror *-keyTranslationTable!=80,'oops'
12497	>f6d1		00				                .byte 0                      ;60 tab
12498	>f6d2		7a				                .text "z"                    ;61 z
12499	>f6d3		20				                .text " "                    ;62 space
12500	>f6d4		76				                .text "v"                    ;63 v
12501	>f6d5		62				                .text "b"                    ;64 b
12502	>f6d6		6d				                .text "m"                    ;65 m
12503	>f6d7		2c				                .text ","                    ;66 comma
12504	>f6d8		2e				                .text "."                    ;67 stop
12505	>f6d9		2f				                .text "/"                    ;68 divide
12506	>f6da		8b				                .byte $8B                    ;69 copy
12507	>f6db		b0				                .byte "0"|$80                ;6a numpad_0
12508	>f6dc		b1				                .byte "1"|$80                ;6b numpad_1
12509	>f6dd		b3				                .byte "3"|$80                ;6c numpad_3
12510	>f6de		00				                .byte 0                      ;6d
12511	>f6df		00				                .byte 0                      ;6e
12512	>f6e0		00				                .byte 0                      ;6f
12513							                .cerror *-keyTranslationTable!=96,'oops'
12514	>f6e1		1b				                .byte 27                     ;70 escape
12515	>f6e2		81				                .byte $81                    ;71 f1
12516	>f6e3		82				                .byte $82                    ;72 f2
12517	>f6e4		83				                .byte $83                    ;73 f3
12518	>f6e5		85				                .byte $85                    ;74 f5
12519	>f6e6		86				                .byte $86                    ;75 f6
12520	>f6e7		88				                .byte $88                    ;76 f8
12521	>f6e8		89				                .byte $89                    ;77 f9
12522	>f6e9		5c				                .byte $5C                    ;78 backslash
12523	>f6ea		8d				                .byte $8D                    ;79 right
12524	>f6eb		b4				                .byte "4"|$80                ;7a numpad_4
12525	>f6ec		b5				                .byte "5"|$80                ;7b numpad_5
12526	>f6ed		b2				                .byte "2"|$80                ;7c numpad_2
12527	.f6ee						LF8FF:
12528	.f6ee		2c 5e e3	bit $e35e	                bit valueFF                  ; Set V
12529	.f6f1						callKEYV:
12530	.f6f1		6c 28 02	jmp ($0228)	                jmp (KEYV)                   ; Jump to KEYV

12532							;-------------------------------------------------------------------------
12533							;
12534							; OSBYTE 131 (&83) - Read Operating System High Water Mark (OSHWM)
12535							;
12536							; MasRef D.2-40
12537							;
12538	.f6f4						osbyte83:
12539	.f6f4		ac 44 02	ldy $0244	                ldy oshwm
12540	.f6f7		a2 00		ldx #$00	                ldx #$00
12541	.f6f9		60		rts		                rts

12543							;-------------------------------------------------------------------------
12544							;
12545							; OSBYTE 120 ($78) - Write keys pressed information
12546							;
12547							; MasRef D.2-33
12548							;
12549	.f6fa						osbyte78:                          ;f90b
12550	.f6fa		84 ec		sty $ec		                sty lastKeyPressedInternal
12551	.f6fc		86 ed		stx $ed		                stx firstKeyPressedInternal
12552	.f6fe		60		rts		                rts

12554							;-------------------------------------------------------------------------
12555							;
12556							; OSBYTE 122 (&7A) Keyboard scan from 16 decimal
12557							;
12558							; MasRef D.2-36
12559							;
12560							                .if version==350
12563							                .endif
12564	.f6ff						osbyte7A:
12565	.f6ff		a2 10		ldx #$10	                ldx #$10
12566	.f701		b8		clv		                clv
12567	.f702		38		sec		                sec
12568	.f703		80 ec		bra $f6f1	                bra callKEYV

12570							;-------------------------------------------------------------------------

12572	.f705						scanKeyboard:
12573	.f705		8a		txa		                txa
12574	.f706		10 0a		bpl $f712	                bpl LF923
12575	.f708		20 6f f6	jsr $f66f	                jsr interrogateKeyboard
12576	.f70b						enableKeyboardScanning:
12577	.f70b		a9 0b		lda #$0b	                lda #8|3                     ;set latch B3 - auto scan mode
12578	.f70d		8d 40 fe	sta $fe40	                sta systemVIA.orb            ;set auto scan mode
12579	.f710		8a		txa		                txa
12580	.f711		60		rts		                rts

12582	.f712						LF923:
12583	.f712		8e cb 02	stx $02cb	                stx previousKeyPressedWhenReadingLastKey
12584	.f715		a9 ff		lda #$ff	                lda #$FF
12585	.f717		8d cc 02	sta $02cc	                sta previousKeyPressedWhenReadingFirstKey
12586	.f71a		a2 0c		ldx #$0c	                ldx #$0C
12587	.f71c		a9 7f		lda #$7f	                lda #$7F
12588	.f71e		8d 43 fe	sta $fe43	                sta systemVIA.ddra
12589	.f721		a9 03		lda #$03	                lda #0|3            ;reset latch B3 - manual scan mode
12590	.f723		8d 40 fe	sta $fe40	                sta systemVIA.orb
12591	.f726						loopKeyboardColumns:
12592	.f726		a9 0f		lda #$0f	                lda #$0F
12593	.f728		8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;select a non-existent column
12594	.f72b		a9 01		lda #$01	                lda #$01
12595	.f72d		8d 4d fe	sta $fe4d	                sta systemVIA.ifr            ;cancel keyboard interrupts
12596	.f730		8e 4f fe	stx $fe4f	                stx systemVIA.oraNoHandshake ;select column
12597	.f733		2c 4d fe	bit $fe4d	                bit systemVIA.ifr            ;any key in this column
12598							                                             ;pressed?
12599	.f736		f0 1b		beq $f753	                beq tryNextKeyboardColumn    ;taken if no key
12600	.f738		8a		txa		                txa                          ;A = first key in column
12601	.f739						loopKeyboardRows:
12602	.f739		18		clc		                clc
12603	.f73a		69 10		adc #$10	                adc #$10                     ;next row
12604	.f73c		30 15		bmi $f753	                bmi tryNextKeyboardColumn    ;taken if done
12605	.f73e		8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;store key
12606	.f741		2c 4f fe	bit $fe4f	                bit systemVIA.iraNoHandshake ;pressed?
12607	.f744		10 f3		bpl $f739	                bpl loopKeyboardRows         ;taken if not
12608	.f746		cd cb 02	cmp $02cb	                cmp previousKeyPressedWhenReadingLastKey
12609	.f749		90 ee		bcc $f739	                bcc loopKeyboardRows
12610	.f74b		cd cc 02	cmp $02cc	                cmp previousKeyPressedWhenReadingFirstKey
12611	.f74e		b0 e9		bcs $f739	                bcs loopKeyboardRows
12612	.f750		8d cc 02	sta $02cc	                sta previousKeyPressedWhenReadingFirstKey
12613	.f753						tryNextKeyboardColumn:
12614	.f753		ca		dex		                dex
12615	.f754		10 d0		bpl $f726	                bpl loopKeyboardColumns
12616	.f756		ae cc 02	ldx $02cc	                ldx previousKeyPressedWhenReadingFirstKey
12617	.f759		80 b0		bra $f70b	                bra enableKeyboardScanning

12619	.f75b						scanKeyboardWithExclusion:
12620	.f75b		a2 0c		ldx #$0c	                ldx #$0c
12621	.f75d						LF96E:
12622	.f75d		20 95 f7	jsr $f795	                jsr enableKeyboardScanningFlippingInterrupts
12623	.f760		a9 7f		lda #$7f	                lda #$7F
12624	.f762		8d 43 fe	sta $fe43	                sta systemVIA.ddra
12625	.f765		a9 03		lda #$03	                lda #0|3
12626	.f767		8d 40 fe	sta $fe40	                sta systemVIA.orb
12627	.f76a		a9 0f		lda #$0f	                lda #$0F
12628	.f76c		8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;select non-existent column
12629	.f76f		a9 01		lda #$01	                lda #$01
12630	.f771		8d 4d fe	sta $fe4d	                sta systemVIA.ifr            ;cancel keyboard interrupts
12631	.f774		8e 4f fe	stx $fe4f	                stx systemVIA.oraNoHandshake
12632	.f777		2c 4d fe	bit $fe4d	                bit systemVIA.ifr
12633	.f77a		f0 20		beq $f79c	                beq LF9AD
12634	.f77c		8a		txa		                txa
12635	.f77d						LF98E:
12636	.f77d		18		clc		                clc
12637	.f77e		69 10		adc #$10	                adc #$10
12638	.f780		30 1a		bmi $f79c	                bmi LF9AD                    ;taken if done
12639	.f782		8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;test key
12640	.f785		2c 4f fe	bit $fe4f	                bit systemVIA.iraNoHandshake ;pressed?
12641	.f788		10 f3		bpl $f77d	                bpl LF98E                    ;taken if not
12642	.f78a		48		pha		                pha                          ;save key number
12643	.f78b						LF99C:
12644	.f78b		59 00 00	eor $0000,y	                eor $0000,y                  ;compare to value
12645	.f78e		0a		asl a		                asl a                        ;discard irrelevant bit 7
12646	.f78f		c9 01		cmp #$01	                cmp #$01                     ;C set if different
12647	.f791		68		pla		                pla                          ;restore key number
12648	.f792		90 e9		bcc $f77d	                bcc LF98E                    ;same key found - keep going
12649	.f794		aa		tax		                tax
12650	.f795						enableKeyboardScanningFlippingInterrupts:
12651	.f795		20 0b f7	jsr $f70b	                jsr enableKeyboardScanning
12652	.f798		58		cli		                cli
12653	.f799		78		sei		                sei
12654	.f79a		8a		txa		                txa
12655	.f79b		60		rts		                rts

12657	.f79c						LF9AD:
12658	.f79c		ca		dex		                dex
12659	.f79d		10 be		bpl $f75d	                bpl LF96E
12660	.f79f		80 f4		bra $f795	                bra enableKeyboardScanningFlippingInterrupts

12662							;-------------------------------------------------------------------------

12664							                .if version==400
12665							                .include "sram_access_helpers_tube.s65"

:16	;******  Processing file: src/sram_access_helpers_tube.s65

1							; There's a no-Tube version of transferBetweenSidewaysRAMAndRAM in
2							; mos.s65, that's worth using if Tube not supported as it doesn't do a
3							; jsr on every iteration.

5	.f7a1						transferBetweenSidewaysRAMAndRAM:
6	.f7a1		20 9f e5	jsr $e59f	                jsr selectROMA
7	.f7a4						transferBetweenSidewaysRAMAndRAMLoop:
8	.f7a4		b1 b0		lda ($b0),y	                lda (sramTransferPointers.src),y
9	.f7a6		91 b2		sta ($b2),y	                sta (sramTransferPointers.dest),y
10	.f7a8		20 f0 f7	jsr $f7f0	                jsr transferSidewaysRAMLoopUpdate
11	.f7ab		d0 f7		bne $f7a4	                bne transferBetweenSidewaysRAMAndRAMLoop
12	.f7ad		b5 01		lda $01,x	                lda 1,x
13	.f7af		cd f0 02	cmp $02f0	                cmp sramWorkspace.length+1
14	.f7b2		d0 f0		bne $f7a4	                bne transferBetweenSidewaysRAMAndRAMLoop
15	.f7b4		4c 9d e5	jmp $e59d	                jmp selectTerminalROM

17							;-------------------------------------------------------------------------

19	.f7b7						transferParasiteToSidewaysRAM:
20	.f7b7		20 9f e5	jsr $e59f	                jsr selectROMA
21	.f7ba						transferParasiteToSidewaysRAMLoop:
22	.f7ba		ad e5 fe	lda $fee5	                lda tube.data3
23	.f7bd		91 b2		sta ($b2),y	                sta (sramTransferPointers.dest),y
24	.f7bf		20 00 f8	jsr $f800	                jsr LF800
25	.f7c2		20 f0 f7	jsr $f7f0	                jsr transferSidewaysRAMLoopUpdate
26	.f7c5		d0 f3		bne $f7ba	                bne transferParasiteToSidewaysRAMLoop
27	.f7c7		b5 01		lda $01,x	                lda 1,x
28	.f7c9		cd f0 02	cmp $02f0	                cmp sramWorkspace.length+1
29	.f7cc		d0 ec		bne $f7ba	                bne transferParasiteToSidewaysRAMLoop
30	.f7ce		4c 9d e5	jmp $e59d	                jmp selectTerminalROM

32							;-------------------------------------------------------------------------

34	.f7d1						transferSidewaysRAMOverTube:
35	.f7d1		2c ee 02	bit $02ee	                bit osfileParameterBlock+1
36	.f7d4		30 e1		bmi $f7b7	                bmi transferParasiteToSidewaysRAM
37	.f7d6		20 9f e5	jsr $e59f	                jsr selectROMA  ; select ROM of interest
38	.f7d9						transferSidewaysRAMToParasiteLoop:
39	.f7d9		b1 b0		lda ($b0),y	                lda (sramTransferPointers.src),y ; load byte from sideways RAM
40	.f7db		8d e5 fe	sta $fee5	                sta tube.data3  ; send byte to coprocessor
41	.f7de		20 00 f8	jsr $f800	                jsr LF800       ;
42	.f7e1		20 f0 f7	jsr $f7f0	                jsr transferSidewaysRAMLoopUpdate
43	.f7e4		d0 f3		bne $f7d9	                bne transferSidewaysRAMToParasiteLoop
44	.f7e6		b5 01		lda $01,x	                lda 1,x
45	.f7e8		cd f0 02	cmp $02f0	                cmp sramWorkspace.length+1
46	.f7eb		d0 ec		bne $f7d9	                bne transferSidewaysRAMToParasiteLoop
47	.f7ed		4c 9d e5	jmp $e59d	                jmp selectTerminalROM

49							;-------------------------------------------------------------------------

51	.f7f0						transferSidewaysRAMLoopUpdate:
52	.f7f0		c8		iny		                iny
53	.f7f1		d0 0d		bne $f800	                bne LF800
54	.f7f3		e6 b1		inc $b1		                inc sramTransferPointers.src+1
55	.f7f5		e6 b3		inc $b3		                inc sramTransferPointers.dest+1
56	.f7f7		20 9d e5	jsr $e59d	                jsr selectTerminalROM
57	.f7fa		20 aa 88	jsr $88aa	                jsr L8D0F
58	.f7fd		20 9f e5	jsr $e59f	                jsr selectROMA
59	.f800						LF800:
60	.f800		cc ef 02	cpy $02ef	                cpy osfileParameterBlock+2
61							                ; the dummy ROM header's first byte is the RTS for
62							                ; this routine...
63							                .cerror *!=dummyROMHeader


:12	;******  Return to file: src/mos.s65

12666							                .endif

12668							;-------------------------------------------------------------------------

12670							                .if version>=500
12672							                .endif

12674							;-------------------------------------------------------------------------

12676							                ; Ugly condition...
12677							                .if version>=500||(version==350&&!includeTubeSupport)
12698							                .endif

12700							;-------------------------------------------------------------------------

12702							                .if version>=400
12703							                .include "sram_access_helpers_2.s65"

:17	;******  Processing file: src/sram_access_helpers_2.s65

1	.f803						dummyROMHeader: .block
2	.f803		60		rts		                rts
3	>f804		00 00				                .byte 0,0
4	.f806		60		rts		                rts
5	>f807		00 00				                .byte 0,0
6	>f809		02				                .byte romType6502
7	>f80a		0c				                .byte copyright-dummyROMHeader
8	>f80b		ff				                .byte $ff
9	>f80c		52				                .text "R"
10	.f80d						ram_or_rom_char:
11	>f80d		41				                .text "A"
12	>f80e		4d				                .text "M"
13	.f80f						copyright:
14	>f80f		00				                .byte 0
15	>f810		28 43 29			                .text "(C)"
16	=16						size=*-dummyROMHeader
17							                ; I doubt I've caught all the implied 16s...
18							                .cerror *-dummyROMHeader!=16

20							                ; in any event, this ROM header must be <=16 bytes, as
21							                ; the total pseudo-addressable area has a o documented
22							                ; size of 4*(16384-16)
23							                .cerror *-dummyROMHeader>16
24							                .endblock

26	=32784						dataBankStart=$8000+16
27	=16368						dataBankSize=16384-16

29							;-------------------------------------------------------------------------
30							;
31							;
32	.f813						initDummyROMHeader:
33	.f813		20 8e e5	jsr $e58e	                jsr selectROMX
34	.f816		a0 0f		ldy #$0f	                ldy #size(dummyROMHeader)-1
35	.f818						LF881:
36	.f818		b9 03 f8	lda $f803,y	                lda dummyROMHeader,y
37	.f81b		99 00 80	sta $8000,y	                sta $8000,y
38	.f81e		88		dey		                dey
39	.f81f		10 f7		bpl $f818	                bpl LF881
40	.f821		2c ee 02	bit $02ee	                bit sramWorkspace.type
41	.f824		70 05		bvs $f82b	                bvs LF894       ; taken if called by *SRDATA
42	.f826		a9 4f		lda #$4f	                lda #'O'
43	.f828		8d 0a 80	sta $800a	                sta $8000+(dummyROMHeader.ram_or_rom_char-dummyROMHeader)
44	.f82b						LF894:
45	.f82b		8e 01 80	stx $8001	                stx $8001
46	.f82e		4c 9d e5	jmp $e59d	                jmp selectTerminalROM

48							;-------------------------------------------------------------------------
49							;
50							; Check if a ROM bank is writeable.
51							;
52							; Entry:
53							;
54							; X = ROM bank of interest
55							;
56							; Exit:
57							;
58							; C=0 if ROM, C=1 if RAM
59							;
60							; Terminal ROM selected
61							;
62							; Preserves: X
63							;
64	.f831						isBankROM:
65	.f831		20 8e e5	jsr $e58e	                jsr selectROMX

67							                ; Modify the version number byte - if a valid
68							                ; writeable sideways ROM, don't leave it in a bad
69							                ; state if reset partway through (not much you can do
70							                ; for non-ROMs of course...)
71	.f834		ad 08 80	lda $8008	                lda $8008
72	.f837		a8		tay		                tay             ; Y = original value
73	.f838		49 ff		eor #$ff	                eor #$ff
74	.f83a		78		sei		                sei
75	.f83b		8d 08 80	sta $8008	                sta $8008       ; store modified value
76	.f83e		cd 08 80	cmp $8008	                cmp $8008       ; did it take? Z=1 if RAM
77	.f841		8c 08 80	sty $8008	                sty $8008       ; restore original value
78	.f844		58		cli		                cli
79	.f845		f0 01		beq $f848	                beq jmpSelectTerminalROM ; taken if RAM
80	.f847		18		clc		                clc
81	.f848						jmpSelectTerminalROM:
82	.f848		4c 9d e5	jmp $e59d	                jmp selectTerminalROM

84							;-------------------------------------------------------------------------



:12	;******  Return to file: src/mos.s65

12704							                .endif

12706							;-------------------------------------------------------------------------

12708							                .if version>=400
12709	.f84b						LF8B4:
12710	.f84b		20 8e e5	jsr $e58e	                jsr selectROMX
12711							                .if version==400
12712	.f84e		a9 80		lda #$80	                lda #$80
12713	.f850		85 01		sta $01		                sta 1
12714	.f852		64 00		stz $00		                stz 0
12715	.f854		a9 00		lda #$00	                lda #0
12720							                .endif
12721	.f856		a8		tay		                tay
12722	.f857						LF8BE:
12723	.f857		91 00		sta ($00),y	                sta (0),y
12724	.f859		c8		iny		                iny
12725	.f85a		d0 fb		bne $f857	                bne LF8BE
12726	.f85c		e6 01		inc $01		                inc 1
12727	.f85e		24 01		bit $01		                bit 1
12728	.f860		50 f5		bvc $f857	                bvc LF8BE
12729	.f862		ca		dex		                dex
12730	.f863		e0 04		cpx #$04	                cpx #4
12731	.f865		b0 e4		bcs $f84b	                bcs LF8B4
12732	.f867		4c 9d e5	jmp $e59d	                jmp selectTerminalROM
12733							                .endif

12735							;-------------------------------------------------------------------------

12737							                .if version>=500
12739							                .endif

12741							;-------------------------------------------------------------------------

12743							                .if version>=400
12744	.f86a						selectTerminalROMAndOSBYTE44:
12745	.f86a		20 73 f1	jsr $f173	                jsr withTerminalROM
12746	.f86d		4c 8d 8a	jmp $8a8d	                jmp osbyte44
12747							                .endif

12749							;-------------------------------------------------------------------------

12751							                .if version>=400
12752	.f870						selectTerminalROMAndOSBYTE45:
12753	.f870		20 73 f1	jsr $f173	                jsr withTerminalROM
12754	.f873		4c 3d 8b	jmp $8b3d	                jmp osbyte45
12755							                .endif

12757							;-------------------------------------------------------------------------

12759							                .if version>=400
12760	.f876						selectTerminalROMAndOSWORD42:
12761	.f876		20 73 f1	jsr $f173	                jsr withTerminalROM
12762	.f879		4c 88 87	jmp $8788	                jmp osword42
12763							                .endif

12765							;-------------------------------------------------------------------------

12767							                .if version>=400
12768	.f87c						selectTerminalROMAndOSWORD43:
12769	.f87c		20 73 f1	jsr $f173	                jsr withTerminalROM
12770	.f87f		4c d7 89	jmp $89d7	                jmp osword43
12771							                .endif

12773							;-------------------------------------------------------------------------

12775							                .if version==350
12777							                .endif

12779							;-------------------------------------------------------------------------
12780							;
12781							; OSBPUT [AUG p339]
12782							;
12783	.f882						osbputEntryPoint:
12784	.f882		20 67 f9	jsr $f967	                jsr selectFSForHandle
12785	.f885		6c 18 02	jmp ($0218)	                jmp (BPUTV)

12787							;-------------------------------------------------------------------------
12788							;
12789							; OSBGET [AUG p338]
12790							;
12791	.f888						osbgetEntryPoint:
12792	.f888		20 67 f9	jsr $f967	                jsr selectFSForHandle
12793	.f88b		6c 16 02	jmp ($0216)	                jmp (BGETV)

12795							;-------------------------------------------------------------------------
12796							;
12797							; OSGBPB [AUG p339]
12798							;
12799	.f88e						osgbpbEntryPoint: .proc
12800	.f88e		c9 05		cmp #$05	                cmp #gbpbGetMediaMetadata
12801	.f890		b0 15		bcs $f8a7	                bcs nonFileOperation
12802	.f892		c9 00		cmp #$00	                cmp #$00
12803	.f894		f0 11		beq $f8a7	                beq nonFileOperation

12805							                ; Handle OSGBPB call that's an operation on a file
12806							                ; handle. Select the appropriate FS, given the file
12807							                ; handle, and pass the request along.
12808	.f896		5a		phy		                phy                          ;save OSGBPB Y
12809	.f897		48		pha		                pha                          ;save OSGBPB A
12810	.f898		86 b0		stx $b0		                stx osgbpbWorkspace.ptr+0
12811	.f89a		84 b1		sty $b1		                sty osgbpbWorkspace.ptr+1
12812	.f89c		b2 b0		lda ($b0)	                lda (osgbpbWorkspace.ptr)    ;get file handle
12813	.f89e		a8		tay		                tay
12814	.f89f		68		pla		                pla                          ;restore OSGBPB A
12815	.f8a0		20 67 f9	jsr $f967	                jsr selectFSForHandle
12816	.f8a3						passToCurrentFS:
12817	.f8a3		7a		ply		                ply                          ;restore OSGBPB Y
12818	.f8a4		6c 1a 02	jmp ($021a)	                jmp (GBPBV)

12820							;-------------------------------------------------------------------------
12821							;
12822							; Handle OSGBPB call that isn't an operation on a file handle. Select
12823							; current FS and pass the request along.
12824							;
12825	.f8a7						nonFileOperation:
12826	.f8a7		5a		phy		                phy
12827	.f8a8		da		phx		                phx
12828	.f8a9		48		pha		                pha
12829	.f8aa		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
12830	.f8ad		ad 00 df	lda $df00	                lda hazel.currentFS
12831	.f8b0		20 1d fa	jsr $fa1d	                jsr selectFS
12832	.f8b3		68		pla		                pla
12833	.f8b4		fa		plx		                plx
12834	.f8b5		80 ec		bra $f8a3	                bra passToCurrentFS
12835							                .endproc

12837							;-------------------------------------------------------------------------
12838							;
12839							; OSARGS [AUG p337[
12840							;
12841							;
12842	.f8b7						osargsEntryPoint: .proc
12843	.f8b7		c0 00		cpy #$00	                cpy #$00
12844	.f8b9		d0 2a		bne $f8e5	                bne fileOperation            ;taken if file operation
12845	.f8bb		c9 04		cmp #$04	                cmp #$04
12846	.f8bd		b0 26		bcs $f8e5	                bcs fileOperation ;taken if Y=0, A>=4 - honorary file operation
12847	.f8bf		48		pha		                pha
12848	.f8c0		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
12849	.f8c3		68		pla		                pla
12850	.f8c4		d0 04		bne $f8ca	                bne notGetFS
12851	.f8c6						getFS:
12852							                ; OSARGS Y=0 A=0 - read current FS number
12853	.f8c6		ad 00 df	lda $df00	                lda hazel.currentFS
12854	.f8c9		60		rts		                rts

12856	.f8ca						notGetFS:
12857	.f8ca		3a		dec a		                dec a
12858	.f8cb		d0 10		bne $f8dd	                bne notGetCommandLine
12859	.f8cd						getCommandLine:
12860							                ; OSARGS Y=0 A=1 - read command line tail address
12861	.f8cd		3a		dec a		                dec a                        ;A=$ff
12862	.f8ce		95 02		sta $02,x	                sta 2,x                    ;store full 32-bit address
12863	.f8d0		95 03		sta $03,x	                sta 3,x                    ;store full 32-bit address
12864	.f8d2		ad 04 df	lda $df04	                lda hazel.commandLinePointer+0
12865	.f8d5		95 00		sta $00,x	                sta 0,x                    ;
12866	.f8d7		ad 05 df	lda $df05	                lda hazel.commandLinePointer+1
12867	.f8da		95 01		sta $01,x	                sta 1,x
12868	.f8dc		60		rts		                rts

12870	.f8dd						notGetCommandLine:
12871	.f8dd		c9 01		cmp #$01	                cmp #argsCheckANFS-1    ;-1 due to the dec a above
12872	.f8df		f0 03		beq $f8e4	                beq rtsFA14            ; OSARGS Y=0 A=2 - Read OldNFS flag
12873	.f8e1						getLibFS:
12874	.f8e1		ad 02 df	lda $df02	                lda hazel.libFS      ;OSARGS Y=0 A=3 - Read libfs filing system number
12875	.f8e4						rtsFA14:
12876	.f8e4		60		rts		                rts

12878	.f8e5						fileOperation:
12879							                ; Operating on a file. Select appropriate FS first.
12880	.f8e5		20 67 f9	jsr $f967	                jsr selectFSForHandle
12881							                .endproc


12884							;-------------------------------------------------------------------------
12885							;
12886							; Call current FS's OSARGS routine, bypassing the FileSwitch stuff.
12887							;
12888	.f8e8						callARGSV:                      ;fa18
12889	.f8e8		6c 14 02	jmp ($0214)	                jmp (ARGSV)

12891							;-------------------------------------------------------------------------
12892							;
12893							; OSFIND [AUG p342]
12894							;
12895	.f8eb						osfindEntryPoint: .proc
12896	.f8eb		09 00		ora #$00	                ora #$00        ;A=$00 if a file is to be closed
12897	.f8ed		f0 05		beq $f8f4	                beq close       ;branch taken if closing a file
12898	.f8ef		20 3e f9	jsr $f93e	                jsr parseFileNameAndSelectFS       ;handle something other than a file close
12899	.f8f2		80 03		bra $f8f7	                bra callFINDV

12901	.f8f4						close:
12902	.f8f4		20 67 f9	jsr $f967	                jsr selectFSForHandle
12903	.f8f7						callFINDV:
12904	.f8f7		6c 1c 02	jmp ($021c)	                jmp (FINDV)
12905							                .pend

12907							;-------------------------------------------------------------------------
12908							;
12909							; OSFILE [AUG p335]
12910							;
12911	.f8fa						osfileEntryPoint:               ;fa2a
12912	.f8fa		da		phx		                phx
12913	.f8fb		5a		phy		                phy
12914	.f8fc		48		pha		                pha
12915	.f8fd		86 f2		stx $f2		                stx stringInputBufferAddress+0
12916	.f8ff		84 f3		sty $f3		                sty stringInputBufferAddress+1
12917	.f901		a0 11		ldy #$11	                ldy #size(OSFILEParameterBlock)-1
12918	.f903						-
12919	.f903		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
12920	.f905		99 ed 02	sta $02ed,y	                sta osfileParameterBlock,y
12921	.f908		88		dey		                dey
12922	.f909		10 f8		bpl $f903	                bpl -
12923	.f90b		ae ed 02	ldx $02ed	                ldx osfileParameterBlock+OSFILEParameterBlock.fileName+0
12924	.f90e		ac ee 02	ldy $02ee	                ldy osfileParameterBlock+OSFILEParameterBlock.fileName+1
12925	.f911		20 3e f9	jsr $f93e	                jsr parseFileNameAndSelectFS
12926	.f914		8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
12927	.f917		8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
12928	.f91a		68		pla		                pla
12929	.f91b		a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
12930	.f91d		a0 02		ldy #$02	                ldy #>osfileParameterBlock
12931	.f91f		20 3b f9	jsr $f93b	                jsr callFILEV
12932	.f922		7a		ply		                ply
12933	.f923		84 f3		sty $f3		                sty stringInputBufferAddress+1
12934	.f925		fa		plx		                plx
12935	.f926		86 f2		stx $f2		                stx stringInputBufferAddress+0
12936	.f928		48		pha		                pha
12937	.f929		a0 11		ldy #$11	                ldy #size(OSFILEParameterBlock)-1
12938	.f92b						-
12939	.f92b		b9 ed 02	lda $02ed,y	                lda osfileParameterBlock,y
12940	.f92e		91 f2		sta ($f2),y	                sta (stringInputBufferAddress),y
12941	.f930		88		dey		                dey
12942	.f931		c0 02		cpy #$02	                cpy #$02                     ;don't overwrite file name
12943	.f933		b0 f6		bcs $f92b	                bcs -
12944	.f935		68		pla		                pla
12945	.f936		a6 f2		ldx $f2		                ldx stringInputBufferAddress+0
12946	.f938		a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
12947	.f93a		60		rts		                rts

12949	.f93b						callFILEV:
12950	.f93b		6c 12 02	jmp ($0212)	                jmp (FILEV)

12952							;-------------------------------------------------------------------------
12953							;
12954							; Parse file name. Handle (and skip) any -FS- tempfs syntax, selecting
12955							; the FS specified if required.
12956							;
12957							; entry:
12958							;
12959							; Y (MSB)/X (LSB) = address of file name string
12960							;
12961							; exit:
12962							;
12963							; Y (MSB)/X (LSB) = address of file name part
12964							;
12965							; - New FS may have been selected
12966							;
12967	.f93e						parseFileNameAndSelectFS:
12968	.f93e		48		pha		                pha
12969	.f93f		a5 f2		lda $f2		                lda stringInputBufferAddress+0
12970	.f941		48		pha		                pha
12971	.f942		a5 f3		lda $f3		                lda stringInputBufferAddress+1
12972	.f944		48		pha		                pha
12973	.f945		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
12974	.f948		86 f2		stx $f2		                stx stringInputBufferAddress+0
12975	.f94a		84 f3		sty $f3		                sty stringInputBufferAddress+1
12976	.f94c		a0 00		ldy #$00	                ldy #$00
12977	.f94e		20 76 f9	jsr $f976	                jsr parseFileNameFS      ;find -FS- prefix, if any
12978	.f951		5a		phy		                phy                      ;save offset
12979	.f952		20 1d fa	jsr $fa1d	                jsr selectFS                 ;select desired FS
12980	.f955		68		pla		                pla
12981	.f956		18		clc		                clc
12982	.f957		65 f2		adc $f2		                adc stringInputBufferAddress+0
12983	.f959		aa		tax		                tax                          ;save string address LSB
12984	.f95a		a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
12985	.f95c		90 01		bcc $f95f	                bcc +
12986	.f95e		c8		iny		                iny
12987	.f95f						+
12988	.f95f		68		pla		                pla
12989	.f960		85 f3		sta $f3		                sta stringInputBufferAddress+1
12990	.f962		68		pla		                pla
12991	.f963		85 f2		sta $f2		                sta stringInputBufferAddress+0
12992	.f965		68		pla		                pla
12993	.f966		60		rts		                rts

12995							;-------------------------------------------------------------------------
12996							;
12997							; Select appropriate FS for the given file handle.
12998							;
12999							; entry:
13000							;
13001							; Y = file handle
13002							;
13003							; exit:
13004							;
13005							; - appropriate FS selected
13006							;
13007							; preserves: Y/X/A

13009	.f967						selectFSForHandle:
13010	.f967		da		phx		                phx
13011	.f968		48		pha		                pha
13012	.f969		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
13013	.f96c		20 f3 f9	jsr $f9f3	                jsr findFSForHandle
13014	.f96f		8a		txa		                txa
13015	.f970		20 1d fa	jsr $fa1d	                jsr selectFS
13016	.f973		68		pla		                pla
13017	.f974		fa		plx		                plx
13018	.f975		60		rts		                rts

13020							;-------------------------------------------------------------------------
13021							;
13022							; Parse the FS part of a file name, if any, and return the filing
13023							; system to use.
13024							;
13025							; Entry:
13026							;
13027							; (stringInputBufferAddress),y = the string
13028							;
13029							; Exit:
13030							;
13031							; A = FS number to use
13032							;
13033							; (stringInputBufferAddress),y = next char after any tempfs prefix has
13034							; been consumed
13035	.f976						parseFileNameFS: .proc

13037	.f976		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
13038	.f979		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput
13039	.f97c		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
13040	.f97e		c9 2d		cmp #$2d	                cmp #'-'
13041	.f980		f0 0c		beq $f98e	                beq parseFSNamePrefix ; branch taken if tempfs syntax
13042	.f982		2c c6 df	bit $dfc6	                bit hazel.tempFSFlag
13043	.f985		ad 00 df	lda $df00	                lda hazel.currentFS
13044	.f988		50 03		bvc $f98d	                bvc +
13045	.f98a		ad 01 df	lda $df01	                lda hazel.activeFS
13046	.f98d						+
13047	.f98d		60		rts		                rts

13049	.f98e						parseFSNamePrefix:
13050	.f98e		c8		iny		                iny
13051	.f98f		a2 00		ldx #$00	                ldx #$00
13052	.f991						LFAC1:
13053	.f991		bd 06 df	lda $df06,x	                lda hazel.fsInfoBlocks,x ;get FS name char
13054	.f994		f0 44		beq $f9da	                beq badFilingSystemName
13055	.f996		8a		txa		                txa                      ;A=offset in info blocks
13056	.f997		18		clc		                clc
13057	.f998		69 08		adc #$08	                adc #size(fsInfoBlock.name)
13058	.f99a		85 b0		sta $b0		                sta parseFileNameFSWorkspace.fsInfoOffset
13059	.f99c		5a		phy		                phy
13060	.f99d						compareFSNameLoop:
13061	.f99d		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y

13063							; validate FS name char. Must be letter or digit.

13065	.f99f		20 19 e9	jsr $e919	                jsr isLetter
13066	.f9a2		90 08		bcc $f9ac	                bcc validFSNameChar           ;branch taken if letter
13067	.f9a4		c9 30		cmp #$30	                cmp #'0'
13068	.f9a6		90 1b		bcc $f9c3	                bcc notValidFSNameChar       ;branch taken if not digit
13069	.f9a8		c9 3a		cmp #$3a	                cmp #'9'+1
13070	.f9aa		b0 17		bcs $f9c3	                bcs notValidFSNameChar       ;branch taken if not digit
13071	.f9ac						validFSNameChar:
13072	.f9ac		e4 b0		cpx $b0		                cpx parseFileNameFSWorkspace.fsInfoOffset
13073	.f9ae		b0 0b		bcs $f9bb	                bcs nextFSInfoBlock ;branch taken if end of FS
13074							                                         ;info block name was reached
13075	.f9b0		5d 06 df	eor $df06,x	                eor hazel.fsInfoBlocks,x
13076	.f9b3		29 df		and #$df	                and #$DF                 ;Z=1 if char matches FS name
13077	.f9b5		d0 04		bne $f9bb	                bne nextFSInfoBlock      ;branch taken if not a match
13078	.f9b7		e8		inx		                inx                      ;next fs info block byte
13079	.f9b8		c8		iny		                iny                      ;next input string byte
13080	.f9b9		80 e2		bra $f99d	                bra compareFSNameLoop

13082	.f9bb						nextFSInfoBlock:
13083	.f9bb		7a		ply		                ply
13084	.f9bc		a6 b0		ldx $b0		                ldx parseFileNameFSWorkspace.fsInfoOffset ;offset of end of name
13085	.f9be		e8		inx		                inx
13086	.f9bf		e8		inx		                inx
13087	.f9c0		e8		inx		                inx             ;advance to next entry
13088	.f9c1		80 ce		bra $f991	                bra LFAC1

13090	.f9c3						notValidFSNameChar:

13092							; Matching FS name must be terminated with -. Otherwise, it's bad
13093							; syntax, or perhaps an overly long name.

13095	.f9c3		c9 2d		cmp #$2d	                cmp #'-'
13096	.f9c5		d0 13		bne $f9da	                bne badFilingSystemName
13097	.f9c7		c8		iny		                iny                       ;consume input '-'
13098	.f9c8		e4 b0		cpx $b0		                cpx parseFileNameFSWorkspace.fsInfoOffset
13099	.f9ca		f0 07		beq $f9d3	                beq foundFSInfoBlock     ;branch taken if a match due
13100							                                         ;to being right at end of the
13101							                                         ;FS info block name
13102	.f9cc		bd 06 df	lda $df06,x	                lda hazel.fsInfoBlocks,x ;
13103	.f9cf		c9 20		cmp #$20	                cmp #' '
13104	.f9d1		d0 e8		bne $f9bb	                bne nextFSInfoBlock      ;branch taken if not a match
13105							                                         ;as tthe supplied name was a
13106							                                         ;prefix of this FS's name
13107	.f9d3						foundFSInfoBlock:
13108	.f9d3		68		pla		                pla
13109	.f9d4		a6 b0		ldx $b0		                ldx parseFileNameFSWorkspace.fsInfoOffset
13110	.f9d6		bd 08 df	lda $df08,x	                lda hazel.fsInfoBlocks+(fsInfoBlock.fsNumber-(fsInfoBlock.name+size(fsInfoBlock.name))),x
13111	.f9d9		60		rts		                rts

13113	.f9da						badFilingSystemName:
13114	.f9da		00		brk #		                brk
13115	>f9db		f8 42 61 64 20 66 69 6c		                .text $f8,'Bad filing system name',0
	>f9e3		69 6e 67 20 73 79 73 74 65 6d 20 6e 61 6d 65 00
13116							                .pend

13118							;-------------------------------------------------------------------------
13119							;
13120							; Find FS for the given handle
13121							;
13122							; entry:
13123							;
13124							; Y = file handle
13125							;
13126							; exit:
13127							;
13128							; X = FS number - will just use current FS if none suitable found
13129							;
13130	.f9f3						findFSForHandle: .proc
13131	.f9f3		48		pha		                pha                          ;
13132	.f9f4		5a		phy		                phy                          ;
13133	.f9f5		98		tya		                tya                          ;A = handle to search for
13134	.f9f6		a0 00		ldy #$00	                ldy #$00                     ;
13135	.f9f8						loop:
13136	.f9f8		be 06 df	ldx $df06,y	                ldx hazel.fsInfoBlocks.name+0,y
13137	.f9fb		f0 15		beq $fa12	                beq notFound                  ;taken if terminating entry
13138	.f9fd		d9 0e df	cmp $df0e,y	                cmp hazel.fsInfoBlocks.minHandle,y
13139	.fa00		90 07		bcc $fa09	                bcc next                     ;taken if not this FS
13140	.fa02		d9 0f df	cmp $df0f,y	                cmp hazel.fsInfoBlocks.maxHandle,y
13141	.fa05		90 10		bcc $fa17	                bcc found                    ;taken if this FS
13142	.fa07		f0 0e		beq $fa17	                beq found                    ;taken if this FS

13144	.fa09						next:
13145	.fa09		48		pha		                pha
13146	.fa0a		98		tya		                tya
13147	.fa0b		18		clc		                clc
13148	.fa0c		69 0b		adc #$0b	                adc #size(fsInfoBlock)
13149	.fa0e		a8		tay		                tay
13150	.fa0f		68		pla		                pla
13151	.fa10		80 e6		bra $f9f8	                bra loop

13153	.fa12						notFound:
13154	.fa12		ae 00 df	ldx $df00	                ldx hazel.currentFS
13155	.fa15		80 03		bra $fa1a	                bra done

13157	.fa17						found:
13158	.fa17		be 10 df	ldx $df10,y	                ldx hazel.fsInfoBlocks.fsNumber,y
13159	.fa1a						done:
13160	.fa1a		7a		ply		                ply
13161	.fa1b		68		pla		                pla
13162	.fa1c		60		rts		                rts
13163							                .endproc

13165							;-------------------------------------------------------------------------
13166							;
13167							; Select filing system in A.
13168							;
13169							; Entry:
13170							;
13171							; A = FS number
13172							;
13173	.fa1d						selectFS:                               ;fb4d
13174	.fa1d		cd 01 df	cmp $df01	                cmp hazel.activeFS      ; Check active fs
13175	.fa20		f0 16		beq $fa38	                beq rtsFB68               ; Already active fs, return
13176	.fa22		5a		phy		                phy
13177	.fa23		da		phx		                phx
13178	.fa24		a8		tay		                tay
13179	.fa25		3a		dec a		                dec a
13180	.fa26		d0 07		bne $fa2f	                bne LFB5F       ;taken if not FS 1 (tape)

13182							; ??? - only if trying to select tape FS

13184	.fa28		a9 04		lda #$04	                lda #$04
13185	.fa2a		24 e2		bit $e2		                bit $E2
13186	.fa2c		d0 01		bne $fa2f	                bne LFB5F
13187	.fa2e		c8		iny		                iny
13188	.fa2f						LFB5F:
13189	.fa2f		5a		phy		                phy
13190	.fa30		a2 12		ldx #$12	                ldx #romServiceCallInitialiseFilingSystem
13191	.fa32		20 52 ec	jsr $ec52	                jsr makeROMServiceCall
13192	.fa35		68		pla		                pla
13193	.fa36		fa		plx		                plx
13194	.fa37		7a		ply		                ply
13195	.fa38						rtsFB68:
13196	.fa38		60		rts		                rts

13198							;-------------------------------------------------------------------------
13199							;
13200							; FileSwitch FSC
13201							; ==============
13202							;
13203	.fa39						fileswitchFSCEntryPoint:
13204	.fa39		48		pha		                pha                          ;save request type
13205	.fa3a		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
13206	.fa3d		4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
13207	.fa40		68		pla		                pla                          ;restore request type
13208	.fa41		48		pha		                pha                          ;save request type
13209	.fa42		da		phx		                phx                          ;save request X
13210	.fa43		0a		asl a		                asl a
13211	.fa44		aa		tax		                tax
13212	.fa45		c9 17		cmp #$17	                cmp #11*2+1
13213	.fa47		b0 03		bcs $fa4c	                bcs fileswitchPassFSCToCurrentFS ;taken if out of range
13214	.fa49		7c 51 fa	jmp ($fa51,x)	                jmp (fileswitchFSCRoutinesTable,x)

13216							;-------------------------------------------------------------------------
13217							;
13218							; Pass to filing system's FSC
13219							;
13220							; There's 2 entry points - fileswitchPassFSCToCurrentFS, for
13221							; when X and A are both on the stack, and
13222							; fileswitchPassFSCToCurrentFS_X, for when only A is on the
13223							; stack.
13224							;
13225	.fa4c						fileswitchPassFSCToCurrentFS:
13226	.fa4c						fileswitchFSCNewFS:
13227	.fa4c						fileswitchFSCFileHandleRange:
13228	.fa4c						fileswitchFSCStarCommand:
13229	.fa4c		fa		plx		                plx                          ;restore request X
13230	.fa4d						fileswitchPassFSCToCurrentFS_X:
13231	.fa4d		68		pla		                pla                          ;restore request type
13232	.fa4e		6c da df	jmp ($dfda)	                jmp (hazel.activeFSCV) ;call active FS's real FSCV entry point

13234							;-------------------------------------------------------------------------
13235							;
13236							; FileSwitch FSC table
13237							;
13238	.fa51						fileswitchFSCRoutinesTable:
13239	>fa51		76 fa				                .word fileswitchFSCOPT
13240	>fa53		6f fa				                .word fileswitchFSCCheckEOF
13241	>fa55		83 fa				                .word fileswitchFSCStarSlash
13242	>fa57		69 fa				                .word fileswitchFSCUnknownCommand
13243	>fa59		83 fa				                .word fileswitchFSCStarRUN
13244	>fa5b		88 fa				                .word fileswitchFSCStarCAT
13245	>fa5d		4c fa				                .word fileswitchFSCNewFS
13246	>fa5f		4c fa				                .word fileswitchFSCFileHandleRange
13247	>fa61		4c fa				                .word fileswitchFSCStarCommand
13248	>fa63		88 fa				                .word fileswitchFSCStarEX
13249	>fa65		88 fa				                .word fileswitchFSCStarINFO
13250	>fa67		b8 fa				                .word fileswitchFSCRUNLibrary

13252							;-------------------------------------------------------------------------
13253							;
13254							; FSC 3 - *command [AUG p344]
13255							;
13256	.fa69						fileswitchFSCUnknownCommand:
13257	.fa69		fa		plx		                plx
13258	.fa6a		20 91 fa	jsr $fa91	                jsr getCommandLinePointer
13259	.fa6d		80 de		bra $fa4d	                bra fileswitchPassFSCToCurrentFS_X

13261							;-------------------------------------------------------------------------
13262							;
13263							; FSC 1 - check EOF [AUG p343]
13264							;
13265	.fa6f						fileswitchFSCCheckEOF:
13266	.fa6f		7a		ply		                ply                         ;Y = file handle
13267	.fa70		5a		phy		                phy                         ;restore stack arrangement
13268	.fa71		20 67 f9	jsr $f967	                jsr selectFSForHandle
13269	.fa74		80 d6		bra $fa4c	                bra fileswitchPassFSCToCurrentFS

13271							;-------------------------------------------------------------------------
13272							;
13273							; FSC 0 - *OPT [AUG p343]
13274							;
13275	.fa76						fileswitchFSCOPT:
13276	.fa76		2c c6 df	bit $dfc6	                bit hazel.tempFSFlag   ; Check temporary fs flag
13277	.fa79		70 d1		bvs $fa4c	                bvs fileswitchPassFSCToCurrentFS
13278	.fa7b		ad 00 df	lda $df00	                lda hazel.currentFS ; Get current filing system number

13280							;-------------------------------------------------------------------------
13281							;
13282							; Pass FSCV request through to a particular FS.
13283							;
13284							; entry:
13285							;
13286							; A = FS to select
13287							;
13288							; Y = FSCV Y
13289							;
13290							; S = [FSCV X; FSCV A]
13291							;
13292	.fa7e						fileswitchPassFSCToSpecificFS:
13293	.fa7e		20 1d fa	jsr $fa1d	                jsr selectFS        ; Select filing system
13294	.fa81		80 c9		bra $fa4c	                bra fileswitchPassFSCToCurrentFS

13296							;-------------------------------------------------------------------------
13297							;
13298							; FSC 2 - */filename [AUG p343]
13299							; FSC 4 - *RUN filename [AUG p344]
13300							;
13301	.fa83						fileswitchFSCStarSlash:
13302	.fa83						fileswitchFSCStarRUN:
13303	.fa83		fa		plx		                plx
13304	.fa84		20 91 fa	jsr $fa91	                jsr getCommandLinePointer ; Skip '*'s and spaces, set command line address
13305	.fa87		da		phx		                phx             ; Continue on to pass to filing system


13308							;-------------------------------------------------------------------------
13309							;
13310							; FSC 5 - *CAT [AUG p344]
13311							; FSC 9 - *EX [NAUG p257]
13312							; FSC, 10 - *INFO [NAUG p257]
13313							;
13314	.fa88						fileswitchFSCStarCAT:
13315	.fa88						fileswitchFSCStarEX:
13316	.fa88						fileswitchFSCStarINFO:
13317	.fa88		fa		plx		                plx
13318	.fa89		0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
13319	.fa8c		20 3e f9	jsr $f93e	                jsr parseFileNameAndSelectFS
13320	.fa8f		80 bc		bra $fa4d	                bra fileswitchPassFSCToCurrentFS_X

13322							;-------------------------------------------------------------------------
13323							;
13324							; Get command line pointer.
13325							;
13326							; Entry:
13327							;
13328							; X/Y - pointer to CR-terminated command line string
13329							;
13330							; Exit:
13331							;
13332							; X/Y, (hazel.commandLinePointer) - pointer to first non-space char in
13333							; command line string
13334	.fa91						getCommandLinePointer: .proc ;fbc1
13335	.fa91		86 f2		stx $f2		                stx stringInputBufferAddress+0
13336	.fa93		84 f3		sty $f3		                sty stringInputBufferAddress+1

13338							; skip spaces. Stop if terminating CR encountered.

13340	.fa95		a0 ff		ldy #$ff	                ldy #$FF
13341	.fa97						-
13342	.fa97		c8		iny		                iny
13343	.fa98		b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
13344	.fa9a		c9 0d		cmp #$0d	                cmp #$0D
13345	.fa9c		f0 04		beq $faa2	                beq +
13346	.fa9e		c9 20		cmp #$20	                cmp #' '
13347	.faa0		d0 f5		bne $fa97	                bne -

13349	.faa2						+

13351							; Hmm. Didn't we just do this bit already?

13353	.faa2		20 ee f0	jsr $f0ee	                jsr skipSpacesAndCheckForCRInStringInput

13355							; Store address of first non-space char in the HAZEL command line
13356							; pointer.

13358	.faa5		98		tya		                tya
13359	.faa6		18		clc		                clc
13360	.faa7		65 f2		adc $f2		                adc stringInputBufferAddress+0
13361	.faa9		8d 04 df	sta $df04	                sta hazel.commandLinePointer+0
13362	.faac		a5 f3		lda $f3		                lda stringInputBufferAddress+1
13363	.faae		69 00		adc #$00	                adc #$00
13364	.fab0		8d 05 df	sta $df05	                sta hazel.commandLinePointer+1
13365	.fab3		a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
13366	.fab5		a6 f2		ldx $f2		                ldx stringInputBufferAddress+0
13367	.fab7		60		rts		                rts
13368							                .pend

13370							;-------------------------------------------------------------------------
13371							;
13372							; FSC 11 - RUN from libfs [NAUG p257]
13373							;
13374	.fab8						fileswitchFSCRUNLibrary:
13375	.fab8		ad 02 df	lda $df02	                lda hazel.libFS      ; Is a libfs set?
13376	.fabb		10 c1		bpl $fa7e	                bpl fileswitchPassFSCToSpecificFS
13377	.fabd						badCommandError:
13378	.fabd		00		brk #		                brk
13379	>fabe		fe				                .byte 254
13380	>fabf		42 61 64 20 63 6f 6d 6d		                .text "Bad command"
	>fac7		61 6e 64
13381	.faca		00		brk #		                brk

13383							;-------------------------------------------------------------------------

13385							                .if version==350
13391							                .endif

13393							;-------------------------------------------------------------------------
13394							;
13395							; Tube 6502 language ROM relocation
13396							;

13398							                .if version==350&&includeTubeSupport
13592							                .endif

13594							                .if version==350&&!finmos329
13631							                .endif

13633							;-------------------------------------------------------------------------

13635	>facb		ff ff ff ff ff ff ff ff		                .fill $fc00-*,$ff
	>fad3		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fae3		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>faf3		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb03		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb13		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb23		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb33		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb43		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb53		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb63		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb73		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb83		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb93		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fba3		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbb3		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbc3		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbd3		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbe3		ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbf3		ff ff ff ff ff ff ff ff ff ff ff ff ff

13637							                .if version==350
13666							                .else

13668							;-------------------------------------------------------------------------
13669							;
13670							; Credits - normally hidden by the I/O region.
13671							;

13673							                .if version<500
13674	>fc00		28 43 29 20 31 39 38 34		                .text "(C) 1984 Acorn Computers Ltd."
	>fc08		20 41 63 6f 72 6e 20 43 6f 6d 70 75 74 65 72 73
	>fc18		20 4c 74 64 2e
13675	>fc1d		54 68 61 6e 6b 73 20 61		                .text "Thanks are due to the following contributors to the BBC Computer (among others too numerous to mention):- "
	>fc25		72 65 20 64 75 65 20 74 6f 20 74 68 65 20 66 6f
	>fc35		6c 6c 6f 77 69 6e 67 20 63 6f 6e 74 72 69 62 75
	>fc45		74 6f 72 73 20 74 6f 20 74 68 65 20 42 42 43 20
	>fc55		43 6f 6d 70 75 74 65 72 20 28 61 6d 6f 6e 67 20
	>fc65		6f 74 68 65 72 73 20 74 6f 6f 20 6e 75 6d 65 72
	>fc75		6f 75 73 20 74 6f 20 6d 65 6e 74 69 6f 6e 29 3a
	>fc85		2d 20
13683							                .endif
13684	>fc87		44 61 76 69 64 20 41 6c		                .text "David Allen,"
	>fc8f		6c 65 6e 2c
13685							                .if version<500
13686	>fc93		43 6c 69 76 65 20 41 6e		                .text "Clive Angel,"
	>fc9b		67 65 6c 2c
13687							                .endif
13688	>fc9f		44 61 76 69 64 20 42 65		                .text "David Bell,"
	>fca7		6c 6c 2c
13689	>fcaa		50 61 75 6c 20 42 6f 6e		                .text "Paul Bond,"
	>fcb2		64 2c
13690							                .if version<500
13691	>fcb4		41 6c 6c 65 6e 20 42 6f		                .text "Allen Boothroyd,"
	>fcbc		6f 74 68 72 6f 79 64 2c
13692							                .endif
13693	>fcc4		4a 75 6c 69 61 6e 20 42		                .text "Julian Brown,"
	>fccc		72 6f 77 6e 2c
13694	>fcd1		54 75 64 6f 72 20 42 72		                .text "Tudor Brown,"
	>fcd9		6f 77 6e 2c
13695							                .if version>=500
13697							                .endif
13698	>fcdd		42 72 69 61 6e 20 43 6f		                .text "Brian Cockburn,"
	>fce5		63 6b 62 75 72 6e 2c
13699							                .if version>=500
13701							                .endif
13702							                .if version<500
13703	>fcec		50 65 74 65 20 43 6f 63		                .text "Pete Cockerell,"
	>fcf4		6b 65 72 65 6c 6c 2c
13704							                .endif
13705	>fcfb		4d 61 72 6b 20 43 6f 6c		                .text "Mark Colton,"
	>fd03		74 6f 6e 2c
13706	>fd07		43 68 72 69 73 20 43 75		                .text "Chris Curry,"
	>fd0f		72 72 79 2c
13707							                .if version>=500
13710							                .endif
13711	>fd13		4a 6f 65 20 44 75 6e 6e		                .text "Joe Dunn,"
	>fd1b		2c
13712							                .if version==400
13713	>fd1c		57 65 6e 64 79 20 46 72		                .text "Wendy Frazer,"
	>fd24		61 7a 65 72 2c
13714							                .endif
13715							                .if version<500
13716	>fd29		50 61 75 6c 20 46 72 65		                .text "Paul Freakley,"
	>fd31		61 6b 6c 65 79 2c
13717							                .endif
13718							                .if version>=500
13721							                .endif
13722	>fd37		53 74 65 76 65 20 46 75		                .text "Steve Furber,"
	>fd3f		72 62 65 72 2c
13723	>fd44		4d 61 72 74 79 6e 20 47		                .text "Martyn Gilbert,"
	>fd4c		69 6c 62 65 72 74 2c
13724	>fd53		4a 6f 68 6e 20 48 61 72		                .text "John Harrison,"
	>fd5b		72 69 73 6f 6e 2c
13725	>fd61		48 65 72 6d 61 6e 6e 20		                .text "Hermann Hauser,"
	>fd69		48 61 75 73 65 72 2c
13726							                .if version!=400
13728							                .endif
13729							                .if version>=500
13731							                .endif
13732	>fd70		4a 6f 68 6e 20 48 6f 72		                .text "John Horton,"
	>fd78		74 6f 6e 2c
13733							                .if version==400
13734	>fd7c		52 69 63 68 61 72 64 20		                .text "Richard Hughes,"
	>fd84		48 75 67 68 65 73 2c
13735							                .endif
13736							                .if version>=500
13738							                .endif
13739							                .if version<500
13740	>fd8b		4e 65 69 6c 20 4a 6f 68		                .text "Neil Johnson,"
	>fd93		6e 73 6f 6e 2c
13741							                .endif
13742	>fd98		52 69 63 68 61 72 64 20		                .text "Richard King,"
	>fda0		4b 69 6e 67 2c
13743	>fda5		44 61 76 69 64 20 4b 69		                .text "David Kitson,"
	>fdad		74 73 6f 6e 2c
13744							                .if version>=500
13746							                .endif
13747	>fdb2		4a 75 6c 69 61 6e 20 4c		                .text "Julian Lomberg,"
	>fdba		6f 6d 62 65 72 67 2c
13748	>fdc1		52 6f 62 20 4d 61 63 6d		                .text "Rob Macmillan,"
	>fdc9		69 6c 6c 61 6e 2c
13749							                .if version>=500
13751							                .endif
13752	>fdcf		52 69 63 68 61 72 64 20		                .text "Richard Manby,"
	>fdd7		4d 61 6e 62 79 2c
13753							                .if version<500
13754	>fddd		50 65 74 65 72 20 4d 63		                .text "Peter McKenna,"
	>fde5		4b 65 6e 6e 61 2c
13755	>fdeb		41 6e 64 72 65 77 20 4d		                .text "Andrew McKernan,"
	>fdf3		63 4b 65 72 6e 61 6e 2c
13756							                .if version==400
13757	>fdfb		4d 69 63 6b 20 4e 65 61		                .text "Mick Neal,"
	>fe03		6c 2c
13760							                .endif
13761	>fe05		49 61 6e 20 4e 69 62 6c		                .text "Ian Niblock,"
	>fe0d		6f 63 6b 2c
13762							                .endif
13763							                .if version>=500
13766							                .endif
13767	>fe11		47 6c 65 6e 20 4e 69 63		                .text "Glen Nicholls,"
	>fe19		68 6f 6c 6c 73 2c
13768	>fe1f		52 6f 62 65 72 74 20 4e		                .text "Robert Nokes,"
	>fe27		6f 6b 65 73 2c
13769							                .if version>=500
13771							                .endif
13772	>fe2c		52 69 63 68 61 72 64 20		                .text "Richard Page,"
	>fe34		50 61 67 65 2c
13773							                .if version<400
13775							                .endif
13776							                .if version<=400
13777	>fe39		45 64 20 50 68 69 70 70		                .text "Ed Phipps,"
	>fe41		73 2c
13778							                .endif
13779	>fe43		4a 6f 68 6e 20 52 61 64		                .text "John Radcliffe,"
	>fe4b		63 6c 69 66 66 65 2c
13780	>fe52		52 69 63 6b 20 52 61 6e		                .text "Rick Rand,"
	>fe5a		64 2c
13781							                .if version>=400
13782	>fe5c		4e 69 63 6b 20 52 65 65		                .text "Nick Reeves,"
	>fe64		76 65 73 2c
13783							                .endif
13784	>fe68		42 72 69 61 6e 20 52 6f		                .text "Brian Robertson,"
	>fe70		62 65 72 74 73 6f 6e 2c
13785							                .if version>=500
13787							                .endif
13788	>fe78		52 69 63 68 61 72 64 20		                .text "Richard Russell,"
	>fe80		52 75 73 73 65 6c 6c 2c
13789							                .if version<500
13790	>fe88		47 6f 72 64 6f 6e 20 53		                .text "Gordon Sage,"
	>fe90		61 67 65 2c
13791	>fe94		54 65 72 72 79 20 53 63		                .text "Terry Scotcher,"
	>fe9c		6f 74 63 68 65 72 2c
13792							                .endif
13793							                .if version>=500
13796							                .endif
13797	>fea3		44 61 76 69 64 20 53 65		                .text "David Seal,"
	>feab		61 6c 2c
13798							                .if version>=500
13801							                .endif
13802							                .if version!=400
13804							                .endif
13805	>feae		4a 6f 6e 20 54 68 61 63		                .text "Jon Thackray,"
	>feb6		6b 72 61 79 2c
13806							                .if version>=500
13808							                .endif
13809	>febb		48 75 67 6f 20 54 79 73		                .text "Hugo Tyson,"
	>fec3		6f 6e 2c
13810							                .if version<500
13811	>fec6		41 64 72 69 61 6e 20 57		                .text "Adrian Warner,"
	>fece		61 72 6e 65 72 2c
13812							                .if version==400
13813	>fed4		4a 65 73 20 57 69 6c 6c		                .text "Jes Wills,"
	>fedc		73 2c
13816							                .endif
13817							                .endif
13818							                .if version<500
13819	>fede		52 6f 67 65 72 20 57 69		                .text "Roger Wilson,"
	>fee6		6c 73 6f 6e 2c
13820	>feeb		47 72 61 68 61 6d 20 57		                .text "Graham Winterflood."
	>fef3		69 6e 74 65 72 66 6c 6f 6f 64 2e
13821							                ;.text "   "
13822							                .endif
13823							                .if version>=500
13825							                .endif
13826							                .if version!=400
13832							                .else
13833	>fefe						                .align 256
13834							                .endif

13836							;-------------------------------------------------------------------------

13838							                .endif

13840							;-------------------------------------------------------------------------

13842	.ff00						E_USERV: ; ff00
13843	.ff00		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13844	.ff03						E_BRKV: ; ff03
13845	.ff03		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13846	.ff06						E_IRQ1V: ; ff06
13847	.ff06		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13848	.ff09						E_IRQ2V: ; ff09
13849	.ff09		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13850	.ff0c						E_CLIV: ; ff0c
13851	.ff0c		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13852	.ff0f						E_BYTEV: ; ff0f
13853	.ff0f		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13854	.ff12						E_WORDV: ; ff12
13855	.ff12		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13856	.ff15						E_WRCHV: ; ff15
13857	.ff15		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13858	.ff18						E_RDCHV: ; ff18
13859	.ff18		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13860	.ff1b						E_FILEV: ; ff1b
13861	.ff1b		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13862	.ff1e						E_ARGSV: ; ff1e
13863	.ff1e		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13864	.ff21						E_BGETV: ; ff21
13865	.ff21		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13866	.ff24						E_BPUTV: ; ff24
13867	.ff24		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13868	.ff27						E_GBPBV: ; ff27
13869	.ff27		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13870	.ff2a						E_FINDV: ; ff2a
13871	.ff2a		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13872	.ff2d						E_FSCV: ; ff2d
13873	.ff2d		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13874	.ff30						E_EVENTV: ; ff30
13875	.ff30		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13876	.ff33						E_UPTV: ; ff33
13877	.ff33		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13878	.ff36						E_NETV: ; ff36
13879	.ff36		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13880	.ff39						E_VDUV: ; ff39
13881	.ff39		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13882	.ff3c						E_KEYV: ; ff3c
13883	.ff3c		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13884	.ff3f						E_INSV: ; ff3f
13885	.ff3f		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13886	.ff42						E_REMV: ; ff42
13887	.ff42		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13888	.ff45						E_CNPV: ; ff45
13889	.ff45		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13890	.ff48						E_IND1V: ; ff48
13891	.ff48		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13892	.ff4b						E_IND2V: ; ff4b
13893	.ff4b		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
13894	.ff4e						E_IND3V: ; ff4e
13895	.ff4e		20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint

13897							;-------------------------------------------------------------------------

13899	.ff51						extendedVectorEntryPoint:
13900							                ; .if CFA3000
13901							                ; ;...
13902							                ; .else
13903							                ; $10b,x = rL
13904	.ff51		48		pha		                pha                 ; $10a,x  (old ROMSEL)
13905	.ff52		48		pha		                pha                 ; $109,x  (old ACCCON)
13906	.ff53		48		pha		                pha                 ; $108,x  (thunk rH)
13907	.ff54		48		pha		                pha                 ; $107,x  (thunk rL)
13908	.ff55		48		pha		                pha                 ; $106,x  (jump dest MSB)
13909	.ff56		48		pha		                pha                 ; $105,x  (jump dest LSB)
13910	.ff57		08		php		                php                 ; $104,x  (P for RTI)
13911	.ff58		48		pha		                pha                 ; $103,x  (old A)
13912	.ff59		da		phx		                phx                 ; $102,x  (old X)
13913	.ff5a		5a		phy		                phy                 ; $101,x  (old Y)
13914	.ff5b		ba		tsx		                tsx
13915	.ff5c		a9 ff		lda #$ff	                lda #>extendedVectorReturnThunk-1
13916	.ff5e		9d 08 01	sta $0108,x	                sta $0108,x
13917	.ff61		a9 8c		lda #$8c	                lda #<extendedVectorReturnThunk-1
13918	.ff63		9d 07 01	sta $0107,x	                sta $0107,x

13920							                ; this routine is only ever called from $ff00, $ff03,
13921							                ; $ff06, etc. - so rL holds vectorIndex*3+2, suitable
13922							                ; for indexing into the extended vector space.
13923	.ff66		bc 0b 01	ldy $010b,x	                ldy $010B,x                  ;Y=vectorIndex*3+2
13924	.ff69		b9 9d 0d	lda $0d9d,y	                lda extendedVectorSpace-2,y  ;get vector LSB
13925	.ff6c		9d 05 01	sta $0105,x	                sta $0105,x                  ;
13926	.ff6f		b9 9e 0d	lda $0d9e,y	                lda extendedVectorSpace-1,y  ;get vector MSB
13927	.ff72		9d 06 01	sta $0106,x	                sta $0106,x
13928	.ff75		a5 f4		lda $f4		                lda $F4
13929	.ff77		9d 0a 01	sta $010a,x	                sta $010A,x
13930	.ff7a		ad 34 fe	lda $fe34	                lda ACCCON
13931	.ff7d		9d 09 01	sta $0109,x	                sta $0109,x

13933							                ; New stack layout:
13934							                ;
13935							                ; $10a,x - old ROMSEL
13936							                ; $109,x - old ACCCON
13937							                ; $108,x - thunk rH
13938							                ; $107,x - thunk rL
13939							                ; $106,x - jump dest MSB
13940							                ; $105,x - jump dest LSB
13941							                ; $104,x - P (for RTI)
13942							                ; $103,x - old A
13943							                ; $102,x - old X
13944							                ; $101,x - old Y

13946	.ff80		20 b9 eb	jsr $ebb9	                jsr selectHAZEL
13947	.ff83		b9 9f 0d	lda $0d9f,y	                lda extendedVectorSpace,y    ;get vector ROM number
13948	.ff86		20 9f e5	jsr $e59f	                jsr selectROMA
13949	.ff89		7a		ply		                ply
13950	.ff8a		fa		plx		                plx
13951	.ff8b		68		pla		                pla
13952	.ff8c		40		rti		                rti
13953							;                .endif

13955							;-------------------------------------------------------------------------

13957	.ff8d						extendedVectorReturnThunk:
13958	.ff8d		08		php		                php
13959	.ff8e		48		pha		                pha
13960	.ff8f		da		phx		                phx
13961	.ff90		ba		tsx		                tsx
13962	.ff91		bd 02 01	lda $0102,x	                lda $0102,x
13963	.ff94		9d 06 01	sta $0106,x	                sta $0106,x
13964	.ff97		bd 03 01	lda $0103,x	                lda $0103,x
13965	.ff9a		9d 07 01	sta $0107,x	                sta $0107,x
13966	.ff9d		fa		plx		                plx
13967	.ff9e		68		pla		                pla
13968	.ff9f		68		pla		                pla
13969	.ffa0		68		pla		                pla
13970	.ffa1		20 af eb	jsr $ebaf	                jsr selectMOSOrHAZEL
13971	.ffa4		68		pla		                pla
13972	.ffa5		20 9f e5	jsr $e59f	                jsr selectROMA
13973	.ffa8		68		pla		                pla
13974	.ffa9		28		plp		                plp
13975	.ffaa						rtsFFAA:
13976	.ffaa		60		rts		                rts

13978							;-------------------------------------------------------------------------
13979							;
13980							; OSBYTE 150 (&96) Read from SHEILA (&FE00 - &FEFF) [MasRef D.2-45]
13981							;
13982	.ffab						osbyte96:
13983	.ffab		bc 00 fe	ldy $fe00,x	                ldy $fe00,x
13984	.ffae		60		rts		                rts

13986							;-------------------------------------------------------------------------
13987							;
13988							; OSBYTE 157 (&9D) Write byte across Tube [MasRef D.2-48]
13989							;
13990	.ffaf						osbyte9D:
13991	.ffaf		8a		txa		                txa
13992	.ffb0		80 22		bra $ffd4	                bra OSBPUT

13994	.ffb2		00		brk #		                brk

13996							;-------------------------------------------------------------------------
13997	.ffb3						OSWRSC:
13998	.ffb3		4c f1 f1	jmp $f1f1	                jmp oswrscEntryPoint ; FFB3
13999	>ffb6		36				                .byte defaultVectorTable.end-defaultVectorTable ;
14000	>ffb7		e7 e2				                .word defaultVectorTable ;
14001	.ffb9						OSRDSC:
14002	.ffb9		4c eb f1	jmp $f1eb	                jmp osrdscEntryPoint ; FFB9
14003	.ffbc						VDUCHR:
14004	.ffbc		4c db f1	jmp $f1db	                jmp vduChrEntryPoint ; FFBC
14005	.ffbf						OSEVEN:
14006	.ffbf		4c d0 e8	jmp $e8d0	                jmp eventEntryPoint ; FFBF
14007	.ffc2						GSINIT:
14008	.ffc2		4c 5d f0	jmp $f05d	                jmp gsinitEntryPoint ; FFC2
14009	.ffc5						GSREAD:
14010	.ffc5		4c 6e f0	jmp $f06e	                jmp gsreadEntryPoint ; FFC5
14011	.ffc8						NVRDCH:
14012	.ffc8		4c d5 e6	jmp $e6d5	                jmp osrdchEntryPoint                    ; FFC8
14013	.ffcb						NVWRCH:
14014	.ffcb		4c 38 e7	jmp $e738	                jmp oswrchEntryPoint                    ; FFCB
14015	.ffce						OSFIND:
14016	.ffce		4c eb f8	jmp $f8eb	                jmp osfindEntryPoint                    ; FFCE
14017	.ffd1						OSGBPB:
14018	.ffd1		4c 8e f8	jmp $f88e	                jmp osgbpbEntryPoint                    ; FFD1
14019	.ffd4						OSBPUT:
14020	.ffd4		4c 82 f8	jmp $f882	                jmp osbputEntryPoint                    ; FFD4
14021	.ffd7						OSBGET:
14022	.ffd7		4c 88 f8	jmp $f888	                jmp osbgetEntryPoint                    ; FFD7
14023	.ffda						OSARGS:
14024	.ffda		4c b7 f8	jmp $f8b7	                jmp osargsEntryPoint ; FFDA
14025	.ffdd						OSFILE:
14026	.ffdd		4c fa f8	jmp $f8fa	                jmp osfileEntryPoint ; FFDD
14027	.ffe0						OSRDCH:
14028	.ffe0		6c 10 02	jmp ($0210)	                jmp (RDCHV)                  ; FFE0
14029	.ffe3						OSASCI:
14030	.ffe3		c9 0d		cmp #$0d	                cmp #$0D                     ; FFE3
14031	.ffe5		d0 07		bne $ffee	                bne OSWRCH                   ; FFE5
14032	.ffe7						OSNEWL:
14033	.ffe7		a9 0a		lda #$0a	                lda #$0A                     ; FFE7
14034	.ffe9		20 ee ff	jsr $ffee	                jsr OSWRCH                   ; FFE9
14035	.ffec		a9 0d		lda #$0d	                lda #$0D                     ; FFEC
14036	.ffee						OSWRCH:
14037	.ffee		6c 0e 02	jmp ($020e)	                jmp (WRCHV)                  ; FFEE
14038	.fff1						OSWORD:
14039	.fff1		6c 0c 02	jmp ($020c)	                jmp (WORDV)                  ; FFF1
14040	.fff4						OSBYTE:
14041	.fff4		6c 0a 02	jmp ($020a)	                jmp (BYTEV)                  ; FFF4
14042	.fff7						OSCLI:
14043	.fff7		6c 08 02	jmp ($0208)	                jmp (CLIV)                  ; FFF7

14045	.fffa						LFFFA:                                       ; FFFA NMIV
14046	>fffa		00 0d				                .word nmiEntryPoint
14047	.fffc						LFFFC:                                       ; FFFB RESETV
14048	>fffc		74 e3				                .word resetEntryPoint
14049	.fffe						LFFFE:                                       ; FFFE IRQV
14050	>fffe		ab e5				                .word irqEntryPoint


:1	;******  Return to file: mos400.s65

36							                .endsection


;******  End of listing
