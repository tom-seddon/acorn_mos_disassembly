
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass.exe --m65c02 --nostart -Wall -q --case-sensitive --line-numbers --verbose-list -Lbuild/mosautocue.full.lst --output-section mos -o build/autocue/mos.rom --output-section utils -o build/autocue/utils.rom mosautocue.s65
; Sun Feb 09 17:01:03 2025

;Line	;Offset	;Hex		;Monitor	;Source

:1	;******  Processing input file: mosautocue.s65

1						                .include "src/hardware.s65"

:2	;******  Processing file: src/hardware.s65

1						;-------------------------------------------------------------------------

3						                .virtual $fe00

5	.fe00					CRTC: .block

7						                .virtual 8
8	.0008					R8: .block
9	=$00					normalSync=%00000000
10	=$01					interlaceSync=%00000001
11	=$02					normalSyncAlt=%00000010
12	=$03					interlaceSyncAndVideo=%00000011

14	=0					displayDelay0=0<<4
15	=16					displayDelay1=1<<4
16	=32					displayDelay2=2<<4
17	=48					displayDisable=3<<4

19	=0					cursorDelay0=0<<6
20	=64					cursorDelay1=1<<6
21	=128					cursorDelay2=2<<6
22	=192					cursorDisable=3<<6
23						                .endblock
24						                .endvirtual

26						                .virtual 10
27	.000a					R10: .block
28	=$40					blink=$40
29	=$20					slowBlink=$20
30						                .endblock
31						                .endvirtual

33						                .endblock

35						                .endvirtual

37						;-------------------------------------------------------------------------
38						; ACIA=$fe08
39	=$fe10					SERPROC=$fe10
40						;HADC=$fe18
44	=$fe30					ROMSEL=$fe30
45						;ACCCON=$fe34
46						                .virtual $fe20
47	.fe20					VCONTROL: .block
48	=$01					flash=$01
49	=$02					isTeletext=$02
50	=$00					shift2MHz=$00
51	=$04					shift4MHz=$04
52	=$08					shift8MHz=$08
53	=$0c					shift16MHz=$0c
54	=$00					crtc1MHz=$00
55	=$10					crtc2MHz=$10
56	=$00					cursor____=$00
57	=$20					cursor__XX=$20
58	=$40					cursor_X__=$40
59	=$60					cursor_XXX=$60
60	=$80					cursorX___=$80
61	=$a0					cursorX_XX=$a0
62	=$c0					cursorXX__=$c0
63	=$e0					cursorXXXX=$e0
64						                .endblock
65						                .endvirtual
66	=$fe21					VPALETTE=$fe21

68						;-------------------------------------------------------------------------

70						                .virtual $fe08
71	.fe08					ACIA: .block

73	.fe08					control: .block
74	=0					counterDivide1=0<<0
75	=1					counterDivide16=1<<0
76	=2					counterDivide64=2<<0
77	=3					reset=3<<0

79	=0					word7DataEventParity2Stop=0<<2
80	=4					word7DataOddParity2Stop=1<<2
81	=8					word7DataEvenParity1Stop=2<<2
82	=12					word7DataOddParity1Stop=3<<2
83	=16					word8DataNoParity2Stop=4<<2
84	=20					word8DataNoParity1Stop=5<<2
85	=24					word8DataEvenParity1Stop=6<<2
86	=28					word8DataOddParity1Stop=7<<2

88	=0					rtsLowTXInterruptDisabled=0<<5
89	=32					rtsLowTXInterruptEnabled=1<<5
90	=64					rtsHighTXInterruptDisabled=2<<5
91	=96					rtsLowBreakTXInterruptDisabled=3<<5

93	=0					rtsRXInterruptDisabled=0<<7
94	=128					rtsRTSInterruptEnabled=1<<7

96						                .endblock
97	.fe08					status: .block
98						                .endblock

100	>fe08					                .fill 1
101	.fe09					tdr:
102	.fe09					rdr:
103	>fe09					                .fill 1
104						                .endblock
105						                .endvirtual

107						;-------------------------------------------------------------------------

109						                .virtual $fe18
110	.fe18					HADC: .block
111	.fe18					status: .block
112						                .endblock
113	.fe18					latch: .block
114						                .endblock
115	>fe18					                .fill 1

117						                .endblock
118						                .endvirtual

120						;-------------------------------------------------------------------------

122						                .virtual $fe34
123	.fe34					ACCCON: .block
124						;D=1 = display shadow RAM; D=0 = display main RAM
125	=$01					D=$01

127						;E=1 = VDU code ($c000-$dfff in MOS ROM) accesses shadow RAM; E=0 =
128						;VDU code accesses main RAM
129	=$02					E=$02

131						;X=1 = shadow RAM at $3000; X=0 = main RAM at $3000
132	=$04					X=$04

134						;Y=1 = HAZEL at $c000; Y=0 = MOS ROM at $c000
135	=$08					Y=$08

137						;ITU=1 = access internal Tube; ITU=0 = access external Tube
138	=$10					ITU=$10

140						;IFJ=1 = $fc00...$fdff accesses cartridge; IFJ=0 = $fc00...$fdff
141						;accesses 1MHz bus
142	=$20					IFJ=$20

144						; TST=1 = read MOS ROM at $fc00...$feff; TST=0 = read I/O at
145						; $fc00...$feff
146	=$40					TST=$40

148						;IRR=1 = IRQ to CPU
149	=$80					IRR=$80
150						                .bend
151						                .endv

153						                VIA: .struct                    ;
154	.0000					orb:
155	.0000					irb:
156	>0000					                .fill 1         ;0
157	.0001					ora:
158	.0001					ira:
159	>0001					                .fill 1         ;1
160	.0002					ddrb:
161	>0002					                .fill 1         ;2
162	.0003					ddra:
163	>0003					                .fill 1         ;3
164	.0004					t1cL:
165	>0004					                .fill 1         ;4
166	.0005					t1cH:
167	>0005					                .fill 1         ;5
168	.0006					t1lL:
169	>0006					                .fill 1         ;6
170	.0007					t1lH:
171	>0007					                .fill 1         ;7
172	.0008					t2cL:
173	>0008					                .fill 1         ;8
174	.0009					t2cH:
175	>0009					                .fill 1         ;9
176	.000a					sr:
177	>000a					                .fill 1         ;10
178	.000b					acr: .block
179	=0					t1OneShot=0<<6
180	=64					t1Continuous=1<<6
181	=128					t1OneShotPB7=2<<6
182	=192					t1ContinuousPB7=3<<6

184	=0					t2Timer=0<<5
185	=32					t2CountPB6=1<<5

187	=0					srDisabled=0<<2
188	=4					srShiftInT2=1<<2
189	=8					srShiftInVIAClock=2<<2
190	=12					srShiftInExtClock=3<<2
191	=16					srShiftOutT2FreeRun=4<<2
192	=20					srShiftOutT2=5<<2
193	=24					srShiftOutVIAClock=6<<2
194	=28					srShiftOutExtClock=7<<2

196	=0					pbLatchDisabled=0<<1
197	=2					pbLatchEnabled=1<<1

199	=0					paLatchDisabled=0<<0
200	=1					paLatchEnabled=1<<0

202	>000b					                .fill 1         ;11
203						                .endblock
204	.000c					pcr: .block

206	=0					cb2InputNegativeActiveEdge=0<<5
207	=32					cb2IndependentInterruptInputNegativeEdge=1<<5
208	=64					cb2InputPositiveEdge=2<<5
209	=96					cb2IndependentInterruptInputPositiveEdge=3<<5
210	=128					cb2HandshakeOutput=4<<5
211	=160					cb2PulseOutput=5<<5
212	=192					cb2LowOutput=6<<5
213	=224					cb2HighOutput=7<<5

215	=0					cb1NegativeActiveEdge=0<<4
216	=16					cb1PositiveActiveEdge=1<<4

218	=0					ca2InputNegativeActiveEdge=0<<1
219	=2					ca2IndependentInterruptInputNegativeEdge=1<<1
220	=4					ca2InputPositiveEdge=2<<1
221	=6					ca2IndependentInterruptInputPositiveEdge=3<<1
222	=8					ca2HandshakeOutput=4<<1
223	=10					ca2PulseOutput=5<<1
224	=12					ca2LowOutput=6<<1
225	=14					ca2HighOutput=7<<1

227	=0					ca1NegativeActiveEdge=0<<0
228	=1					ca1PositiveActiveEdge=1<<0

230	>000c					                .fill 1         ;12
231						                .endblock
232	.000d					ifr:
233	>000d					                .fill 1         ;13
234	.000e					ier:
235	>000e					                .fill 1         ;14
236	.000f					oraNoHandshake:
237	.000f					iraNoHandshake:
238	>000f					                .fill 1         ;15

240	.0010					irq: .block
241	=1					ca2=1
242	=2					ca1=2
243	=4					sr=4
244	=8					cb2=8
245	=16					cb1=16
246	=32					t2=32
247	=64					t1=64
248						                .endblock
249						                .ends

251						; System VIA port B bits for Master Compact
252	=$20					i2cClock=$20
253	=$10					i2cData=$10

255						; PCD8572 command codes

257						;   7   6   5   4   3   2   1   0
258						; +---+---+---+---+---+---+---+---+
259						; | 1 | 0 | 1 | 0 |A2 |A1 |A0 |RnW|
260						; +---+---+---+---+---+---+---+---+

262	=$a1					eepromRead=$a1
263	=$a0					eepromWrite=$a0
264						                                .virtual $fe40
265	.fe40					systemVIA: .dstruct VIA
154	.fe40					orb:
155	.fe40					irb:
156	>fe40					                .fill 1         ;0
157	.fe41					ora:
158	.fe41					ira:
159	>fe41					                .fill 1         ;1
160	.fe42					ddrb:
161	>fe42					                .fill 1         ;2
162	.fe43					ddra:
163	>fe43					                .fill 1         ;3
164	.fe44					t1cL:
165	>fe44					                .fill 1         ;4
166	.fe45					t1cH:
167	>fe45					                .fill 1         ;5
168	.fe46					t1lL:
169	>fe46					                .fill 1         ;6
170	.fe47					t1lH:
171	>fe47					                .fill 1         ;7
172	.fe48					t2cL:
173	>fe48					                .fill 1         ;8
174	.fe49					t2cH:
175	>fe49					                .fill 1         ;9
176	.fe4a					sr:
177	>fe4a					                .fill 1         ;10
178	.fe4b					acr: .block
179	=0					t1OneShot=0<<6
180	=64					t1Continuous=1<<6
181	=128					t1OneShotPB7=2<<6
182	=192					t1ContinuousPB7=3<<6

184	=0					t2Timer=0<<5
185	=32					t2CountPB6=1<<5

187	=0					srDisabled=0<<2
188	=4					srShiftInT2=1<<2
189	=8					srShiftInVIAClock=2<<2
190	=12					srShiftInExtClock=3<<2
191	=16					srShiftOutT2FreeRun=4<<2
192	=20					srShiftOutT2=5<<2
193	=24					srShiftOutVIAClock=6<<2
194	=28					srShiftOutExtClock=7<<2

196	=0					pbLatchDisabled=0<<1
197	=2					pbLatchEnabled=1<<1

199	=0					paLatchDisabled=0<<0
200	=1					paLatchEnabled=1<<0

202	>fe4b					                .fill 1         ;11
203						                .endblock
204	.fe4c					pcr: .block

206	=0					cb2InputNegativeActiveEdge=0<<5
207	=32					cb2IndependentInterruptInputNegativeEdge=1<<5
208	=64					cb2InputPositiveEdge=2<<5
209	=96					cb2IndependentInterruptInputPositiveEdge=3<<5
210	=128					cb2HandshakeOutput=4<<5
211	=160					cb2PulseOutput=5<<5
212	=192					cb2LowOutput=6<<5
213	=224					cb2HighOutput=7<<5

215	=0					cb1NegativeActiveEdge=0<<4
216	=16					cb1PositiveActiveEdge=1<<4

218	=0					ca2InputNegativeActiveEdge=0<<1
219	=2					ca2IndependentInterruptInputNegativeEdge=1<<1
220	=4					ca2InputPositiveEdge=2<<1
221	=6					ca2IndependentInterruptInputPositiveEdge=3<<1
222	=8					ca2HandshakeOutput=4<<1
223	=10					ca2PulseOutput=5<<1
224	=12					ca2LowOutput=6<<1
225	=14					ca2HighOutput=7<<1

227	=0					ca1NegativeActiveEdge=0<<0
228	=1					ca1PositiveActiveEdge=1<<0

230	>fe4c					                .fill 1         ;12
231						                .endblock
232	.fe4d					ifr:
233	>fe4d					                .fill 1         ;13
234	.fe4e					ier:
235	>fe4e					                .fill 1         ;14
236	.fe4f					oraNoHandshake:
237	.fe4f					iraNoHandshake:
238	>fe4f					                .fill 1         ;15

240	.fe50					irq: .block
241	=1					ca2=1
242	=2					ca1=2
243	=4					sr=4
244	=8					cb2=8
245	=16					cb1=16
246	=32					t2=32
247	=64					t1=64
248						                .endblock
249						                .ends
266						                .endv

268						                .virtual $fe60
269	.fe60					userVIA: .dstruct VIA
154	.fe60					orb:
155	.fe60					irb:
156	>fe60					                .fill 1         ;0
157	.fe61					ora:
158	.fe61					ira:
159	>fe61					                .fill 1         ;1
160	.fe62					ddrb:
161	>fe62					                .fill 1         ;2
162	.fe63					ddra:
163	>fe63					                .fill 1         ;3
164	.fe64					t1cL:
165	>fe64					                .fill 1         ;4
166	.fe65					t1cH:
167	>fe65					                .fill 1         ;5
168	.fe66					t1lL:
169	>fe66					                .fill 1         ;6
170	.fe67					t1lH:
171	>fe67					                .fill 1         ;7
172	.fe68					t2cL:
173	>fe68					                .fill 1         ;8
174	.fe69					t2cH:
175	>fe69					                .fill 1         ;9
176	.fe6a					sr:
177	>fe6a					                .fill 1         ;10
178	.fe6b					acr: .block
179	=0					t1OneShot=0<<6
180	=64					t1Continuous=1<<6
181	=128					t1OneShotPB7=2<<6
182	=192					t1ContinuousPB7=3<<6

184	=0					t2Timer=0<<5
185	=32					t2CountPB6=1<<5

187	=0					srDisabled=0<<2
188	=4					srShiftInT2=1<<2
189	=8					srShiftInVIAClock=2<<2
190	=12					srShiftInExtClock=3<<2
191	=16					srShiftOutT2FreeRun=4<<2
192	=20					srShiftOutT2=5<<2
193	=24					srShiftOutVIAClock=6<<2
194	=28					srShiftOutExtClock=7<<2

196	=0					pbLatchDisabled=0<<1
197	=2					pbLatchEnabled=1<<1

199	=0					paLatchDisabled=0<<0
200	=1					paLatchEnabled=1<<0

202	>fe6b					                .fill 1         ;11
203						                .endblock
204	.fe6c					pcr: .block

206	=0					cb2InputNegativeActiveEdge=0<<5
207	=32					cb2IndependentInterruptInputNegativeEdge=1<<5
208	=64					cb2InputPositiveEdge=2<<5
209	=96					cb2IndependentInterruptInputPositiveEdge=3<<5
210	=128					cb2HandshakeOutput=4<<5
211	=160					cb2PulseOutput=5<<5
212	=192					cb2LowOutput=6<<5
213	=224					cb2HighOutput=7<<5

215	=0					cb1NegativeActiveEdge=0<<4
216	=16					cb1PositiveActiveEdge=1<<4

218	=0					ca2InputNegativeActiveEdge=0<<1
219	=2					ca2IndependentInterruptInputNegativeEdge=1<<1
220	=4					ca2InputPositiveEdge=2<<1
221	=6					ca2IndependentInterruptInputPositiveEdge=3<<1
222	=8					ca2HandshakeOutput=4<<1
223	=10					ca2PulseOutput=5<<1
224	=12					ca2LowOutput=6<<1
225	=14					ca2HighOutput=7<<1

227	=0					ca1NegativeActiveEdge=0<<0
228	=1					ca1PositiveActiveEdge=1<<0

230	>fe6c					                .fill 1         ;12
231						                .endblock
232	.fe6d					ifr:
233	>fe6d					                .fill 1         ;13
234	.fe6e					ier:
235	>fe6e					                .fill 1         ;14
236	.fe6f					oraNoHandshake:
237	.fe6f					iraNoHandshake:
238	>fe6f					                .fill 1         ;15

240	.fe70					irq: .block
241	=1					ca2=1
242	=2					ca1=2
243	=4					sr=4
244	=8					cb2=8
245	=16					cb1=16
246	=32					t2=32
247	=64					t1=64
248						                .endblock
249						                .ends
270						                .endv

346						RTC: .struct
347	>0000					seconds: .fill 1
348	>0001					secondsAlarm: .fill 1
349	>0002					minutes: .fill 1
350	>0003					minutesAlarm: .fill 1
351	>0004					hours: .fill 1
352	>0005					hoursAlarm: .fill 1
353	>0006					dayOfWeek: .fill 1
354	>0007					dayOfMonth: .fill 1
355	>0008					month: .fill 1
356	>0009					year: .fill 1
357	.000a					a: .block
358	=7					dvMask=7
359	=4					dvShift=4
360	=0					dv4194304Hz=0<<dvShift
361	=16					dv1048576Hz=1<<dvShift
362	=32					dv32768Hz=2<<dvShift
363	>000a					                .fill 1
364						                .endblock
365	.000b					b: .block
366	=$80					set=$80
367	=$02					_24h=$02
368	=$01					dse=$01
369	>000b					                .fill 1
370						                .endblock
371	.000c					c: .block
372	=$10					uf=$10
373	>000c					                .fill 1
374						                .endblock
375	.000d					d: .block
376	>000d					                .fill 1
377						                .endblock
378	=50					ram_size=50
379	>000e					ram: .fill ram_size
380						                .endstruct

:1	;******  Return to file: mosautocue.s65

2						                .include "src/mos_workspace.s65"

:3	;******  Processing file: src/mos_workspace.s65

1						;-------------------------------------------------------------------------
2						;
3						; Disorganized jumble of constants. They'll get tidied up at some
4						; point... promise...
5						;
6						;-------------------------------------------------------------------------

8						; The version constant is not very well named: it should really be
9						; something like "acornVersion". It refers to one of the official MOS
10						; versions released for Acorn-branded hardware, and can have one of
11						; the following 6 specific values:
12						;
13						; version=320 - MOS 3.20
14						; version=350 - MOS 3.50
15						; version=400 - MOS 4.00
16						; version=500 - MOS 5.00
17						; version=510 - MOS 5.10
18						; version=511 - MOS 5.11
19						;
20						; (Strictly speaking, these are not numeric, but there's a few
21						; instances of version>=n where this coincidentally makes sense. The
22						; 5.xx series follow on from one another, some of the 4.00 changes are
23						; in 5.xx too, and some of the 4.00 changes that are in 5.xx also made
24						; it into 3.50 as well.)

28						; All other versions are considered to be variants of one of the six
29						; official versions, as per the variant flags below. These variant
30						; flags are applicable to the stated versions only, and may or may not
31						; be separable from the various version-dependent .if/.endif
32						; constructs for that version. If they're changed from these defaults
33						; for any other version, the output may not make sense.
34						;
35						; Over time I intend to (try to) turn these into feature flags,
36						; according to the actual features they control.

38						                .weak
39						                ; Set if building Olivetti MOS, a variant of 5.10.
40	=false					olivetti=false

42						                ; Set if building CFA3000 MOS, a variant of 3.50.
43	=false					CFA3000=false

45						                ; Set if building Autocue 1500 MOS, a variant of 5.11.
46	=false					autocue=false

48						                ; Set if building MOS 3.29 (Acorn FinMOS), a variant
49						                ; of 3.50.
50	=false					finmos329=false

52						                ; Clear if stripping out the terminal ROM. Applicable
53						                ; to 3.20 or 3.50.
54	=true					includeTerminalROM=true

56						                ; Set if building any of the refresh versions.
57	=false					refreshVersion=false
58						                .endweak

60						;-------------------------------------------------------------------------

62						; These feature flags can be set freely by the main driver file.

64						                .weak

66						                ; If true, include *X. Not clear what this command
67						                ; actually, does, but it's in the original ROMs, so
68						                ; there has to be the option...
69	=false					includeStarX=version<500

71						                ; For some reason, *TAPE and *MOTOR have lower-case
72						                ; command name entries in MOS 4.00.
73	="TAPE"					tapeCommandString=version==400?"tape":"TAPE"
74	="MOTOR"				motorCommandString=version==400?"motor":"MOTOR"

76						                ; If false, reproduce the OSBYTE $6B/$6C bug present
77						                ; in MOS versions prior to 3.50.
78	=false					correctOSBYTE6B6C=version==350

80						                ; Assumed century for RTC reading purposes.
81	=$19					assumedRTCCenturyBCD=$19

83						                ; If false, reproduce the relocation issue present in
84						                ; MOS 3.50. Applies to MOS 3.50 only.
85	=false					correctlyHandleMissingTubeRelocationBitmap=false

87						                ; If true, improve Tube relocation speed.
88	=false					fasterTubeRelocation=false

90						                ; If true, insert a few OSWRCH code tweaks to improve
91						                ; things. Priority given to Mode 0/3/4/6/7 when
92						                ; outputting to VDU only.
93						                ;
94						                ; This means more code in the MOS area.
95	=false					fasterOSWRCH=false

97						                ; If true, put Tube BRK handler and idle loop in main
98						                ; RAM rather than zero page.
99						                ;
100						                ; It appears to be in zero page to save 1 cycle in
101						                ; some self-modifying code in the idle loop, for which
102						                ; the 65c02 jmp (abs,x) is a valid replacement that's
103						                ; actually quicker.
104						                ;
105						                ; The Tube language ROM relocation code (which does
106						                ; benefit from being in zero page) pushes the total
107						                ; zero page usage of the Tube host code well past the
108						                ; MOS 3.50 value, a needless source of potential
109						                ; incompatibility.
110	=false					tubeHostBrkAndIdleInMainRAM=false

112						                .endweak

114						;-------------------------------------------------------------------------

116						; These feature flags are offered on a best-effort basis. They're more
117						; intended for readability than for use as toggles.

119						                .weak

121						                ; If true, include Tube support.
124						                .elif version>=500
125	=false					includeTubeSupport=false

129	=true					useTableDrivenConfigure=true

134						                ; If true, put 750-odd bytes of sound code in the ext
135						                ; ROM rather than the MOS ROM.
136						                ;
137						                ; (MOS 5.00+ has some code for having this stuff in
138						                ; the utils ROM, and MOS 3.50 has some code for having
139						                ; this stuff in the ext ROM. The MOS 3.50 code is a
140						                ; bit tighter.)
144	=false					soundStuffInExtROM=false

147						                .endweak

149						;-------------------------------------------------------------------------

151						; Some combinations are impossible. Sorry!
152						;
153						; (The code deliberately doesn't try to work around this. The driver
154						; files must avoid these cases.)

159						                ; Table-driven configuration takes up fewer bytes, so
160						                ; no point trying to switch it off for builds where it
161						                ; would be on.

164						;-------------------------------------------------------------------------

166						beword .macro value
169						                .endm

172						;-------------------------------------------------------------------------

174	=$400					tubeHostAddr=$400

205						;-------------------------------------------------------------------------

207						                ; Force word operand - a few instances of this,
208						                ; presumably due to limitations in 1980s assemblers.
209						                ;
210						                ; Refresh versions can use an 8-bit operand for time
211						                ; and space savings.

213						forcew: .macro instr,oper
219						                .endmacro

221						;-------------------------------------------------------------------------

223						                .virtual $b0
224	.00b0					sramTransferPointers: .block
225	>00b0					src: .fill 2
226	>00b2					dest: .fill 2
227						                .endblock
228						                .endvirtual

230	=$a8					osargsBuffer=$a8                ;4-byte ZP buffer for use with OSARGS
231	=$b8					printMessageAddress=$b8

233						                .virtual $bb
234	.00bb					tapeCurrentOptionsByte: .block
235						                .endblock
236						                .endvirtual

238						                .virtual $f2
239	.00f2					fsStatusByte: .block
240	=$01					inputFileOpen=$01
241	=$02					outputFileOpen=$02
242	=$08					catStatus=$08
243	=$40					eofReached=$40
244	=$80					eofWarningGiven=$80
245						                .endblock
246						                .endvirtual

248						                .virtual $e4
249	.00e4					stringInputOptions: .block
250	=$80					doubleQuotes=$80
251	=$40					spaceNotATerminator=$40
252	=$01					goodString=$01
253						                .endblock
254						                .endvirtual
255	=$e5					stringInputPlingFlag=$e5        ;bit 7 set if last char was '!'
256	=$e6					readCharacterTimedFlag=$e6
257	=$e6					commandLineY=$e6
258	=$e7					autoRepeatCountdownTimer=$e7
259	=$eb					tapeCritical=$eb
260	=$ec					lastKeyPressedInternal=$ec
261	=$ed					firstKeyPressedInternal=$ed
262	=$f2					stringInputBufferAddress=$f2    ;word

264						;-------------------------------------------------------------------------

266	=$80					romTypeHasServiceEntry=$80
267	=$40					romTypeHasLanguageEntry=$40
268	=$20					romTypeHasTubeRelocationAddress=$20
269	=$02					romType6502=$02

271						;-------------------------------------------------------------------------

273	=$01					romServiceCallAbsoluteWorkspaceClaim=$01 ; memory used only when ROM is paged in
274	=$02					romServiceCallPrivateWorkspaceClaim=$02 ; memory used even when ROM is not paged in
275	=$03					romServiceCallAutoBoot=$03              ;
276	=$04					romServiceCallUnrecognisedCommand=$04   ; star command not recognised
277	=$05					romServiceCallUnrecognisedInterrupt=$05 ;
278	=$06					romServiceCallBreakInstruction=$06      ;
279	=$07					romServiceCallUnrecognisedOSBYTE=$07    ;
280	=$08					romServiceCallUnrecognisedOSWORD=$08    ;
281	=$09					romServiceCallHelp=$09                  ;
282	=$0a					romServiceCallClaimStaticWorkspace=$0A ; (Issued by paged ROMs, not the OS)
283	=$0b					romServiceCallNMIRelease=$0B    ; (Issued by paged ROMs, not the OS)
284	=$0c					romServiceCallNMIClaim=$0C      ; (Issued by paged ROMs, not the OS)
285	=$0d					romServiceCallROMFilingSystemInitialize=$0D    ;
286	=$0e					romServiceCallROMFilingSystemByteGet=$0E    ;
287	=$0f					romServiceCallVectorsClaimed=$0F    ; Used when a filing system starts
288	=$10					romServiceCallSpoolExecClosureWarning=$10    ;
289						;romServiceCallFontImplosionExplosionWarning=$11    ;
290	=$12					romServiceCallInitialiseFilingSystem=$12    ; (Issued from paged ROMs, not the OS)
291	=$15					romServiceCallPollingInterrupt=$15
292	=$18					romServiceCallReserved=$18
293	=$21					romServiceCallAbsoluteHAZELWorkspaceClaim=$21
294	=$22					romServiceCallPrivateHAZELWorkspaceClam=$22
295	=$23					romServiceCallTopOfHAZELWorkspace=$23
296	=$24					romServiceCallCountDynamicHAZELWorkspace=$24
297	=$25					romServiceCallRequestFSInfo=$25
298	=$26					romServiceCallCloseAllOpenFiles=$26
299	=$27					romServiceCallInformReset=$27
300	=$28					romServiceCallUnknownCONFIG=$28
301	=$29					romServiceCallUnknownSTATUS=$29
302	=$2a					romServiceCallLanguageChange=$2a
303	=$2c					romServiceCallCompactJoystick=$2c
304	=$30					romServiceCall30=$30
305	=$fe					romServiceCallTubeSystemPostInitialisation=$FE    ;
306	=$ff					romServiceCallTubeMainInitialisation=$FF    ;

308						;-------------------------------------------------------------------------

310	=0					fsNone=0
311	=1					fs1200BaudTape=1
312	=2					fs300BaudTape=2
313	=3					fsROM=3

315						; max FS number for all tape/ROM FS types
316	=3					fsTapeOrROMMax=3

318						;-------------------------------------------------------------------------

320						; [MasRef D.2-24]

322	=0					eventOutputBufferEmpty=0
323	=1					eventInputBufferFull=1
324	=2					eventCharacterEnteringBuffer=2
325	=3					eventADCConversionComplete=3
326	=4					eventStartOfVerticalSync=4
327	=5					eventIntervalTimerCrossingZero=5
328	=6					eventESCAPEPressed=6
329	=7					eventRS423Error=7
330	=8					eventNetworkError=8
331	=9					eventUser=9
332	=9					eventMax=9

334						;-------------------------------------------------------------------------

336						; [MasRef D.2-27]

338						; Input buffers
339	=0					bufferKeyboard=0
340	=1					bufferRS423Input=1

342						; Output buffers
343	=2					bufferFirstOutput=2
344	=2					bufferRS423Output=2
345	=3					bufferPrinter=3
346	=4					bufferSoundChannel0=4
347	=5					bufferSoundChannel1=5
348	=6					bufferSoundChannel2=6
349	=7					bufferSoundChannel3=7
350						; What's buffer 8? Previously speech on OS 1.20. There's indices
351						; allocated for it...
352	=8					bufferMax=8

355	=$03e0					bufferKeyboardAddress=$03e0
356	=32					bufferKeyboardSize=32
357	=$0a00					bufferRS423InputAddress=$0a00
358	=256					bufferRS423InputSize=256
359	=$0900					bufferRS423OutputAddress=$0900
360	=192					bufferRS423OutputSize=192
361	=$0880					bufferPrinterAddress=$0880
362	=64					bufferPrinterSize=64
363	=$0840					bufferSoundChannel0Address=$0840
364	=16					bufferSoundChannel0Size=16
365	=$0850					bufferSoundChannel1Address=$0850
366	=16					bufferSoundChannel1Size=16
367	=$0860					bufferSoundChannel2Address=$0860
368	=16					bufferSoundChannel2Size=16
369	=$0870					bufferSoundChannel3Address=$0870
370	=16					bufferSoundChannel3Size=16
371	=$09c0					buffer8Address=$09c0
372	=64					buffer8Size=64

376						; BufferInfo: .function bufferAddress,bufferSizeByte
377						;                 .endfunction (bufferAddress,256-bufferSizeByte)

379						; ; buffer info is (base address,size)
380						;  _:=[]
381						; _..=[BufferInfo($0300,32)];bufferKeyboard=0
382						; _..=[BufferInfo($0a00,256)];bufferRS423Input=1
383						; _..=[BufferInfo($08c0,192)];bufferRS423Output=2
384						; _..=[BufferInfo($07c0,64)];bufferPrinter=3
385						; _..=[BufferInfo($0750,16)];bufferSoundChannel0=4
386						; _..=[BufferInfo($0760,16)];bufferSoundChannel1=5
387						; _..=[BufferInfo($0770,16)];bufferSoundChannel2=6
388						; _..=[BufferInfo($0780,16)];bufferSoundChannel3=7
389						; _..=[BufferInfo($0900,64)];What's buffer 8?

391						;-------------------------------------------------------------------------

393						; [MasRef C.5-5]

395	=0					printerDriverTypeSink=0
396	=1					printerDriverTypeParallel=1
397	=2					printerDriverTypeSerial=2
398	=3					printerDriverTypeUser=3
399	=4					printerDriverTypeNetwork=4

401						; AUG p259

403	=0					printerDriverPoll=0
404	=1					printerDriverActivate=1
405	=2					printerDriverVDU2=2
406	=3					printerDriverVDU3=3
407	=5					printerDriverFX5=5

409	=10					printerDriverFX3=10             ;undocumented???

411						;-------------------------------------------------------------------------

413						; AUG p261

415	=0					netPrinterRequest0=0
416	=1					netPrinterRequest1=1
417	=2					netPrinterRequest2=2
418	=3					netPrinterRequest3=3
419	=4					netWriteCharacterAttempted=4
420	=5					netPrinterRequest5=5
421	=6					netReadCharacterAttempted=6
422	=7					netOSBYTEAttempted=7
423	=8					netOSWORDAttempted=8
424	=13					netOSWORD0Complete=13

426						;-------------------------------------------------------------------------

428						; OSFIND open constants
429	=$40					findOpenForRead=$40
430	=$80					findOpenForWrite=$80

432	=0					fscOPT=0
433	=1					fscCheckEOF=1
434	=2					fscStarSlash=2
435	=3					fscUnknownCommand=3
436	=4					fscStarRUN=4
437	=5					fscStarCAT=5
438	=6					fscNewFS=6
439	=7					fscFileHandleRange=7
440	=8					fscStarCommand=8
441	=9					fscStarEX=9
442	=10					fscStarINFO=10
443	=11					fscRUNLibrary=11

445						; NAUG mentions this. But it doesn't appear to
446						; actually exist in the code.
447						;
448						; Maybe it's present in MOS 3.50 or later?
449	=12					fscRENAME=12

451	=1					gbpbPutBytesNewPTR=1            ;[AUG p340]
452	=2					gbpbPutBytesCurrentPTR=2        ;[AUG p340]
453	=3					gbpbGetBytesNewPTR=3            ;[AUG p341]
454	=4					gbpbGetBytesCurrentPTR=4        ;[AUG p341]
455	=5					gbpbGetMediaMetadata=5          ;[AUG p341]
456	=6					gbpbGetCurrentDevice=6          ;[AUG p341]
457	=7					gbpbGetLibraryDevice=7          ;[AUG p341]
458	=8					gbpbReadFileNames=8             ;[AUG p341]

460						OSGBPBParameterBlock: .struct
461	.0000					handle:
462	>0000					                .fill 1
463	.0001					address:
464	>0001					                .fill 4
465	.0005					count:
466	>0005					                .fill 4
467	.0009					ptr:
468	>0009					                .fill 4
469						                .endstruct

471	=0					argsGetFS=0                     ;[AUG p337]
472	=1					argsGetCommandLine=1            ;[AUG p338]
473	=2					argsCheckANFS=2                 ;https://beebwiki.mdfs.net/OSARGS
474	=3					argsGetLibFS=3                  ;
475	=$ff					argsFlushBuffers=$ff            ;[AUG p338]

477	=0					argsFileGetPTR=0
478	=1					argsFileSetPTR=1
479	=2					argsFileGetEXT=2
480	=$ff					argsFileFlush=$ff

482	=0					fileSave=0                      ;[AUG p336]
483	=1					fileWriteMetadata=1             ;[AUG p336]
484	=2					fileWriteLoadAddress=2          ;[AUG p336]
485	=3					fileWriteExecAddress=3          ;[AUG p336]
486	=4					fileWritettributes=4            ;[AUG p336]
487	=5					fileReadMetadata=5              ;[AUG p336]
488	=6					fileDelete=6                    ;[AUG p336]
489	=$ff					fileLoad=$ff                    ;[AUG p336]

491						OSFILEParameterBlock: .struct
492	.0000					fileName:
493	>0000					                .fill 2
494	.0002					addresses:
495	.0002					load:
496	>0002					                .fill 4
497	.0006					exec:
498	>0006					                .fill 4
499	.000a					length:
500	.000a					saveStart:
501	>000a					                .fill 4
502	.000e					attributes:
503	.000e					saveEnd:
504	>000e					                .fill 4
505						                .endstruct

507						;-------------------------------------------------------------------------

509	=0					bufferNumberKeyboard=0          ;
510	=1					bufferNumberRS423Input=1        ;
511	=2					bufferNumberRS423Output=2       ;
512	=3					bufferNumberPrinter=3           ;
513	=4					bufferNumberSound0=4            ; Noise channel
514	=5					bufferNumberSound1=5            ;
515	=6					bufferNumberSound2=6            ;
516	=7					bufferNumberSound3=7            ;
517						; bufferNumberSpeech=8            ;
518	=8					bufferNumberHighest=8           ;

520						;-------------------------------------------------------------------------

531						;-------------------------------------------------------------------------

533						; uservIndex=0
534						; brkvIndex=1
535						; irq1vIndex=2
536						; irq2vIndex=3
537						; clivIndex=4
538						; bytevIndex=5
539						; wordvIndex=6
540						; wrchvIndex=7
541						; rdchvIndex=8
542						; filevIndex=9
543						; argsvIndex=10
544						; bgetvIndex=11
545						; bputvIndex=12
546						; gbpbvIndex=13
547						; findvIndex=14
548						; fscvIndex=15
549						; eventvIndex=16
550						; uptvIndex=17
551						; netvIndex=18
552						; vduvIndex=19
553						; keyvIndex=20
554						; insvIndex=21
555						; remvIndex=22
556						; cnpvIndex=23
557						; ind1vIndex=24
558						; ind2vIndex=25
559						; ind3vIndex=26

562						                .virtual $200
563	.0200					vectors:
564	.0200					USERV:
565	>0200					                .fill 2
566	.0202					BRKV:
567	>0202					                .fill 2
568	.0204					IRQ1V:
569	>0204					                .fill 2

571	.0206					IRQ2V:
572	>0206					                .fill 2
573	.0208					CLIV:
574	>0208					                .fill 2
575	.020a					BYTEV:
576	>020a					                .fill 2
577	.020c					WORDV:
578	>020c					                .fill 2
579	.020e					WRCHV:
580	>020e					                .fill 2
581	.0210					RDCHV:
582	>0210					                .fill 2
583	.0212					FILEV:
584	>0212					                .fill 2
585	.0214					ARGSV:
586	>0214					                .fill 2
587	.0216					BGETV:
588	>0216					                .fill 2
589	.0218					BPUTV:
590	>0218					                .fill 2
591	.021a					GBPBV:
592	>021a					                .fill 2
593	.021c					FINDV:
594	>021c					                .fill 2
595	.021e					FSCV:
596	>021e					                .fill 2
597	.0220					EVENTV:
598	>0220					                .fill 2
599	.0222					UPTV:
600	>0222					                .fill 2
601	.0224					NETV:
602	>0224					                .fill 2
603	.0226					VDUV:
604	>0226					                .fill 2
605	.0228					KEYV:
606	>0228					                .fill 2
607	.022a					INSV:
608	>022a					                .fill 2
609	.022c					REMV:
610	>022c					                .fill 2
611	.022e					CNPV:
612	>022e					                .fill 2
613	.0230					IND1V:
614	>0230					                .fill 2
615	.0232					IND2V:
616	>0232					                .fill 2
617	.0234					IND3V:
618	>0234					                .fill 2
619	.0236					mosVariables:

621						; OSBYTE 166 (&A6) Read start address of MOS variables [MasRef D.2-50]
622						; OSBYTE 167 (&A7) Read start address of MOS variablespointer table  [MasRef D.2-50]
623	>0236					mosVariablesAddress: .fill 2

625						; OSBYTE 168 (&A8) Read address of ROM pointer table [MasRef D.2-51]
626						; OSBYTE 169 (&A9) Read address of ROM pointer table [MasRef D.2-51]
627	>0238					extendedVectorSpaceAddress: .fill 2

629						; OSBYTE 170 (&AA) Read address of ROM information table [MasRef D.2-51]
630						; OSBYTE 171 (&AB) Read address of ROM information table [MasRef D.2-51]
631	>023a					romInformationTableAddress: .fill 2

633						; OSBYTE 172 (&AC) Read address of keyboard translation table [MasRef D.2-52]
634						; OSBYTE 173 (&AD) Read address of keyboard translation table [MasRef D.2-52]
635	>023c					keyboardTranslationTableAddress: .fill 2

637						; OSBYTE 174 (&AE) Read address of VDU variables origin [MasRef D.2-52]
638						; OSBYTE 175 (&AF) Read address of VDU variables origin [MasRef D.2-52]
639	>023e					vduVariablesAddress: .fill 2

641						; OSBYTE 176 (&B0) Read/Write CFS timeout counter [MasRef D.2-52]
642	>0240					cfsTimeoutCounter: .fill 1

644						; OSBYTE 177 (&B1) Read/write input source [MasRef D.2-53]
645	>0241					inputSource: .fill 1

647						; OSBYTE 178 (&B2) Read/write keyboard semaphore [MasRef D.2-53]
648	>0242					keyboardSemaphore: .fill 1

650						; OSBYTE 179 (&B3) Read/write ROM polling semaphore [MasRef D.2-54]
651	>0243					romPollingSemaphore: .fill 1

653						; OSBYTE 180 (&B4) Read/write Operating System High [MasRef D.2-54]
654	>0244					oshwm: .fill 1

656						; OSBYTE 181 (&B5) Read/write RS243 input interpretation [MasRef D.2-54]
657	>0245					rs423InputInterpretationStatus: .fill 1

659						; OSBYTE 182 (&B6) Read NOIGNORE state [MasRef D.2-55]
660						;
661						; TODO - not a great name, no matter how official - should probably be usePrinterIgnoreChar or something
662	>0246					noignoreState: .fill 1

664						; OSBYTE 183 (&B7) Read/write cassette/ROM filing system [MasRef D.2-55]
665	>0247					cfsRFSFSSwitch: .fill 1

667						; OSBYTE 184 (&B8) Read OS copy of video ULA control [MasRef D.2-56]
668	>0248					vcontrolRegister: .fill 1

670						; OSBYTE 185 (&B9) Read OS copy of video ULA palette [MasRef D.2-56]
671	>0249					vpaletteRegister: .fill 1

673						; OSBYTE 186 (&BA) Read ROM number active at last BRK [MasRef D.2-56]
674	>024a					romActiveAtLastBRK: .fill 1

676						; OSBYTE 187 (&BB) Read ROM number of socket [MasRef D.2-57]
677	>024b					basicROMNumber: .fill 1

679						; OSBYTE 188 (&BC) Read current ADC channel number [MasRef D.2-57]
680	>024c					currentADCChannel: .fill 1

682						; OSBYTE 189 (&BD) Read maximum ADC channel number [MasRef D.2-57]
683	>024d					maximumADCChannel: .fill 1

685						; OSBYTE 190 (&BE) Read/write ADC conversion type [MasRef D.2-58]
686	>024e					adcConversionType: .fill 1

688						; OSBYTE 191 (&BF) Read/write RS423 busy flag [MasRef D.2-58]
689	>024f					rs423Busy: .fill 1

691						; OSBYTE 192 (&C0) Read serial ACIA control register [MasRef D.2-58]
692	>0250					aciaControlRegister: .fill 1

694						; OSBYTE 193 (&C1) Read/write flash counter [MasRef D.2-59]
695	>0251					flashCounter: .fill 1

697						; OSBYTE 194 (&C2) Read/write duration of first colour [MasRef D.2-59]
698	>0252					firstFlashColourDuration: .fill 1

700						; OSBYTE 195 (&C3) Read/write duration of second colour [MasRef D.2-60]
701	>0253					secondFlashColourDuration: .fill 1

703						; OSBYTE 196 (&C4) Read/write keyboard auto-repeat delay [MasRef D.2-60]
704	>0254					keyboardAutoRepeatDelay: .fill 1

706						; OSBYTE 197 (&C5) Read/write keyboard auto-repeat rate [MasRef D.2-60]
707	>0255					keyboardAutoRepeatRate: .fill 1

709						; OSBYTE 198 (&C6) Read/write *EXEC file handle [MasRef D.2-61]
710	>0256					execFileHandle: .fill 1

712						; OSBYTE 199 (&C7) Read/write *SPOOL file handle [MasRef D.2-62]
713	>0257					spoolFileHandle: .fill 1

715						; OSBYTE 200 (&C8) Read/write BREAK and ESCAPE effect [MasRef D.2-62]
716	>0258					breakAndESCAPEEffect: .fill 1

718						; OSBYTE 201 (&C9) Read/write keyboard status [MasRef D.2-63]
719	>0259					keyboardStatus: .fill 1

721						; OSBYTE 202 (&CA) Read/write keyboard status byte [MasRef D.2-63]
722	.025a					keyboardStatusByte: .block
723	=$8					shiftPressed=%1<<3
724	=%10000					capsLockDisengaged=%1<<4
725	=%100000				shiftLockDisengaged=%1<<5
726	=%1000000				ctrlPressed=%1<<6
727	=$80					shiftEnabled=%1<<7
728	>025a					                .fill 1
729						                .endblock

731						; OSBYTE 203 (&CB) Read/write RS423 input buffer [MasRef D.2-64]
732	>025b					rs423InputBufferMinimumSpace: .fill 1

734						; OSBYTE 204 (&CC) Read/write RS423 ignore flag [MasRef D.2-65]
735	>025c					rs423Ignore: .fill 1

737						; OSBYTE 205 (&CD) Read/write RS423 destination [MasRef D.2-65]
738	>025d					rs423Destination: .fill 1

740						; OSBYTE 206 (&CE) Read/write Econet OS call interception [MasRef D.2-66]
741	>025e					econetInterceptionStatus: .fill 1

743						; OSBYTE 207 (&CF) Read/write Econet input interpretation [MasRef D.2-66]
744	>025f					econetInputInterpretationStatus: .fill 1

746						; OSBYTE 208 (&D0) Read write Econet output [MasRef D.2-67]
747	>0260					econetOutputInterpretationStatus: .fill 1

749						; OSBYTE 209 (&D1) is reserved for the speech system [MasRef D.2-67]
750	>0261					speechSystemByte1:  .fill 1

752						; OSBYTE 210 (&D2) Read/write sound suppression status [MasRef D.2-67]
753	>0262					soundSuppressionStatus: .fill 1

755						; OSBYTE 211 (&D3) Read/write BELL channel [MasRef D.2-67]
756	>0263					bellChannel: .fill 1

758						; OSBYTE 212 (&D4) Read/write BELL sound information [MasRef D.2-68]
759	>0264					bellSound: .fill 1

761						; OSBYTE 213 (&D5) Read/write BELL frequency [MasRef D.2-69]
762	>0265					bellFrequency: .fill 1

764						; OSBYTE 214 (&D6) Read/write BELL duration [MasRef D.2-69]
765	>0266					bellDuration: .fill 1

767						; OSBYTE 215 (&D7) Read/write startup message [MasRef D.2-69]
768	>0267					startupMessageSuppressionStatus: .fill 1

770						; OSBYTE 216 (&D8) Read/write length of soft key string [MasRef D.2-70]
771	>0268					softKeyStringLength: .fill 1

773						; OSBYTE 217 (&D9) Read/write paged mode line count [MasRef D.2-71]
774	>0269					pagedModeCounter: .fill 1

776						; OSBYTE 218 (&DA) Read/write bytes in VDU queue [MasRef D.2-71]
777	>026a					vduQueueNegativeLength: .fill 1

779						; OSBYTE 219 (&DB) Read/write TAB key code [MasRef D.2-72]
780	>026b					tabKeyCode: .fill 1

782						; OSBYTE 220 (&DC) Read/write ESCAPE character [MasRef D.2-72]
783	>026c					escapeCharacter: .fill 1

785						; OSBYTE 221 (&DD) Read/write interpretation of input values 192-207 [MasRef D.2-73]
786	>026d					input192To207Interpretation: .fill 1

788						; OSBYTE 222 (&DE) Read/write interpretation of input values 208-223 [MasRef D.2-73]
789	>026e					input208To223Interpretation: .fill 1

791						; OSBYTE 223 (&DF) Read/write interpretation of input values 224-239 [MasRef D.2-73]
792	>026f					input224To239Interpretation: .fill 1

794						; OSBYTE 224 (&E0) Read/write interpretation of input values 240-255 [MasRef D.2-73]
795	>0270					input240To255Interpretation: .fill 1

797						; OSBYTE 225 (&E1) Read/write soft key interpretation [MasRef D.2-74]
798	>0271					softKeyInterpretation: .fill 1

800						; OSBYTE 226 (&E2) Read/write SHIFT+soft key interpretation [MasRef D.2-74]
801	>0272					shiftSoftKeyInterpretation: .fill 1

803						; OSBYTE 227 (&E3) Read/write CTRL+soft key interpretation [MasRef D.2-74]
804	>0273					ctrlSoftKeyInterpretation: .fill 1

806						; OSBYTE 228 (&E4) Read/write SHIFT+CTRL+soft key interpretation [MasRef D.2-74]
807	>0274					shiftCtrlSoftKeyInterpretation: .fill 1

809						; OSBYTE 229 (&E5) Read/write ESCAPE key status [MasRef D.2-75]
810	>0275					escapeKeyStatus: .fill 1

812						; OSBYTE 230 (&E6) Read/write ESCAPE effects [MasRef D.2-75]
813	>0276					escapeEffects: .fill 1

815						; OSBYTE 231 (&E7) Read/write IRQ bit mask for user 6522 [MasRef D.2-76]
816	>0277					userVIAInterruptMask: .fill 1

818						; OSBYTE 232 (&E8) Read/write IRQ bit mask for 6850 [MasRef D.2-76]
819	>0278					rs423InterruptMask: .fill 1

821						; OSBYTE 233 (&E9) Read write IRQ bit mask for system [MasRef D.2-76]
822	>0279					systemVIAInterruptMask: .fill 1

824						; OSBYTE 234 (&EA) Read flag indicating Tube presence [MasRef D.2-76]
828	>027a					tubePresenceUnused: .fill 1

831						; OSBYTE 235 (&EB) is reserved for the speech system. [MasRef D.2-77]
832	>027b					speechSystemByte2: .fill 1

834						; OSBYTE 236 (&EC) Read/write character destination status [MasRef D.2-77]
835	.027c					characterDestinationStatus: .block
836	>027c					                .fill 1
837	=1					rs423_enable=1
838	=2					vdu_disable=2
839	=4					printer_disable=4               ;printer always off
840	=8					printer_enable=8                ;printer always on
841	=16					spool_disable=16
842	=64					printer_maybe=64                ;printer on when VDU 1 only
843						                .endblock

845						; OSBYTE 237 (&ED) Read/write cursor editing status [MasRef D.2-77]
846	.027d					editKeysMode: .block
847	=0					editKeys=0                      ;edit keys do editing
848	=1					asciiKeys=1                     ;edit keys are ASCII 135-139
849	=2					functionKeys=2                  ;edit keys are F keys 11-15
850	>027d					                .fill 1
851						                .endblock

853						;-------------------------------------------------------------------------
854						; variables reset up to here on soft BREAK
855						;-------------------------------------------------------------------------

857						; OSBYTE 238 (&EE) Read/write numeric keypad [MasRef D.2-78]
858	>027e					numericKeypadInterpretation: .fill 1

860						; OSBYTE 239 (&EF) Read/write *SHADOW state [MasRef D.2-78]
861	>027f					shadowRAMState: .fill 1

863						; OSBYTE 240 (&F0) Read country flag [MasRef D.2-79]
864	>0280					countryFlag: .fill 1

866						; OSBYTE 241 (&F1) Read/write user flag [MasRef D.2-79]
867	>0281					userFlag: .fill 1

869						; OSBYTE 242 (&F2) Read copy of serial processor ULA [MasRef D.2-80]
870	>0282					serialULARegister: .fill 1

872						; OSBYTE 243 (&F3) Read timer switch state [MasRef D.2-80]
873						;
874						; The location holds either 5 (initialTimerSwitchState) or 10
875						; (initialTimerSwitchState^15) - i.e., the offset of the byte after
876						; the last of the timer.
877						;
878						; Various offsets are applied to the timer addresses to make this
879						; work.
880	>0283					timerSwitchState: .fill 1

882						; OSBYTE 244 (&F4) Read/write soft key consistency flag [MasRef D.2-81]
883	>0284					softKeyConsistencyFlag: .fill 1

885						; OSBYTE 245 (&F5) Read printer driver type [MasRef D.2-81[
886	>0285					printerDriverType: .fill 1

888						; OSBYTE 246 (&F6) Read/write printer ignore character [MasRef D.2-81]
889	>0286					printerIgnoreChar: .fill 1

891						;-------------------------------------------------------------------------
892						; variables reset up to here on hard BREAK
893						;-------------------------------------------------------------------------

895						; OSBYTE 247 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
896	>0287					breakVectorByte0: .fill 1

898						; OSBYTE 248 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
899	>0288					breakVectorByte1: .fill 1

901						; OSBYTE 249 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
902	>0289					breakVectorByte2: .fill 1

904						; OSBYTE 250 (&FA) Read memory written by VDU driver [MasRef D.2-82]
905	>028a					vduDriverMemory: .fill 1

907						; OSBYTE 251 (&FB) Read memory displayed [MasRef D.2-83]
908	>028b					displayMemory: .fill 1

910						; OSBYTE 252 (&FC) Read/write current language ROM number [MasRef D.2-83]
911	>028c					currentLanguageROM: .fill 1

913						;-------------------------------------------------------------------------
914						; variables reset up to here on power-on reset
915						;-------------------------------------------------------------------------

917						; OSBYTE 253 (&FD) Read last BREAK type [MasRef D.2-83]
918	.028d					lastBREAKType: .block
919	>028d					                .fill 1
920	=0					softBREAK=0
921	=1					powerOn=1
922	=2					hardBREAK=2
923						                .endblock
924						; OSBYTE 254 (&FE) Set effect of SHIFT on numeric keypad [MasRef D.2-84]
925	>028e					numericKeypadShiftEffect: .fill 1
926						; OSBYTE 255 (&FF) Read/write startup options [MasRef D.2-84]
927	>028f					startupOptions: .fill 1
928	=7					modeMask=7

930						                .endvirtual

932	=166					firstMOSVariableOSBYTE=166

934	=5					initialTimerSwitchState=5
935	=$290					tvOffset=$290
936	=$291					tvInterlace=$291
937	=$292					timer0=$292
938	=$297					timer1=$297
939	=$29c					intervalTimer=$29c
940	=$2a1					romInformationTable=$2a1
941	=$2b1					inkeyTimeoutCounter=$2b1
942	=$2b3					osword0MaxLineLength=$2b3
943	=$2b4					osword0MinASCIICharacter=$2b4
944	=$2b5					osword0MaxASCIICharacter=$2b5
945	=$2b6					adcResultLSBs=$2b6
946	=$2ba					adcResultMSBs=$2ba
947	=$2be					adcLastChannelRead=$2be         ;Two names for the same thing!
948	=$2be					adcLastConvertedChannel=$2be    ;Two names for the same thing!
949	=$2bf					eventEnabledFlags=$2bf
950	=$02c9					currentSoftKey=$02c9
951	=$02ca					keyboardFirstAutoRepeatCount=$02ca
952	=$2cb					previousKeyPressedWhenReadingLastKey=$2cb
953	=$2cc					previousKeyPressedWhenReadingFirstKey=$2cc

955						; Anything past $2cd is reset to $ff rather than $00

957						; Not actually a key - some kind of flag to skip double sound
958						; updates?? See LE718.
959	=$2cd					previousKeyPressedWhenReadingOSBYTE=$2cd

961						; soundIsUpdatingFlag=$2ce
962	=$2ce					bufferEmptyFlags=$2ce
963	=$2d7					bufferStartIndices=$2d7
964	=$2e0					bufferEndIndices=$2e0

966	=$2e9					tapeInputCurrentBlockSize=$2e9
967	=$2eb					blockFlagOfCurrentlyResidentBlock=$2eb
968	=$2ec					lastCharacterOfCurrentlyResidentBlock=$2ec

970						; Needs a better name, possibly more than one :(
971						;
972						; Used by various file routines to store OSGBPB and OSFILE parameter
973						; blocks.
974						;
975						; Used by the clock routines to hold a (possibly partial) mirror of
976						; the RTC time/date registers.
977						;
978						; Used when parsing hex addresses from the command line - obviously
979						; designed primarily for convenient use when building up the OSFILE
980						; parameter block for use with *LOAD and *SAVE.
981						;
982						; Used by the SRAM utilities to store working data.
983	=$2ed					osfileParameterBlock=$2ed

985						                .virtual osfileParameterBlock
986	.02ed					sramWorkspace: .block
987	>02ed					temp: .fill 1
988	>02ee					type: .fill 1
989	>02ef					length: .fill 2
990	>02f1					bank: .fill 1
991	>02f2					sramAddress: .fill 4
992	>02f6					dataAddress: .fill 4
993						                .endblock
994						                .endvirtual

996						; rtcTempData=$2ee

998						ExtendedVectorAddress: .function vectorAddress
1000						                .endfunction extendedVectorSpace+(vectorAddress-vectors)/2*3

1002						;-------------------------------------------------------------------------

1004	=$d9f					extendedVectorSpace=$d9f

1006						; internal key numbers
1007	=$62					key_space=$62
1008	=$66					key_comma=$66
1009	=$17					key_minus=$17
1010	=$67					key_stop=$67
1011	=$68					key_slash=$68
1012	=$27					key_0=$27
1013	=$30					key_1=$30
1014	=$31					key_2=$31
1015	=$11					key_3=$11
1016	=$12					key_4=$12
1017	=$13					key_5=$13
1018	=$34					key_6=$34
1019	=$24					key_7=$24
1020	=$15					key_8=$15
1021	=$26					key_9=$26
1022	=$48					key_colon=$48
1023	=$57					key_semicolon=$57
1024	=$47					key_at=$47
1025	=$41					key_a=$41
1026	=$64					key_b=$64
1027	=$52					key_c=$52
1028	=$32					key_d=$32
1029	=$22					key_e=$22
1030	=$43					key_f=$43
1031	=$53					key_g=$53
1032	=$54					key_h=$54
1033	=$25					key_i=$25
1034	=$45					key_j=$45
1035	=$46					key_k=$46
1036	=$56					key_l=$56
1037	=$65					key_m=$65
1038	=$55					key_n=$55
1039	=$36					key_o=$36
1040	=$37					key_p=$37
1041	=$10					key_q=$10
1042	=$33					key_r=$33
1043	=$51					key_s=$51
1044	=$23					key_t=$23
1045	=$35					key_u=$35
1046	=$63					key_v=$63
1047	=$21					key_w=$21
1048	=$42					key_x=$42
1049	=$44					key_y=$44
1050	=$61					key_z=$61
1051	=$38					key_left_square_bracket=$38
1052	=$78					key_backslash=$78
1053	=$58					key_right_square_bracket=$58
1054	=$18					key_caret=$18
1055	=$28					key_underline=$28
1056	=$70					key_escape=$70
1057	=$60					key_tab=$60
1058	=$40					key_caps_lock=$40
1059	=$1					key_ctrl=$1
1060	=$50					key_shift_lock=$50
1061	=$0					key_shift=$0
1062	=$59					key_delete=$59
1063	=$69					key_copy=$69
1064	=$49					key_return=$49
1065	=$39					key_up=$39
1066	=$29					key_down=$29
1067	=$19					key_left=$19
1068	=$79					key_right=$79
1069	=$20					key_f0=$20
1070	=$71					key_f1=$71
1071	=$72					key_f2=$72
1072	=$73					key_f3=$73
1073	=$14					key_f4=$14
1074	=$74					key_f5=$74
1075	=$75					key_f6=$75
1076	=$16					key_f7=$16
1077	=$76					key_f8=$76
1078	=$77					key_f9=$77
1079	=$6a					key_numpad_0=$6a
1080	=$6b					key_numpad_1=$6b
1081	=$7c					key_numpad_2=$7c
1082	=$6c					key_numpad_3=$6c
1083	=$7a					key_numpad_4=$7a
1084	=$7b					key_numpad_5=$7b
1085	=$1a					key_numpad_6=$1a
1086	=$1b					key_numpad_7=$1b
1087	=$2a					key_numpad_8=$2a
1088	=$2b					key_numpad_9=$2b
1089	=$3a					key_numpad_plus=$3a
1090	=$3b					key_numpad_minus=$3b
1091	=$4a					key_numpad_divide=$4a
1092	=$5a					key_numpad_hash=$5a
1093	=$5b					key_numpad_multiply=$5b
1094	=$5c					key_numpad_comma=$5c
1095	=$3c					key_numpad_return=$3c
1096	=$4b					key_numpad_delete=$4b
1097	=$4c					key_numpad_stop=$4c

1099						fsInfoBlock: .struct
1100	>0000					name: .fill 8
1101	>0008					minHandle: .fill 1
1102	>0009					maxHandle: .fill 1
1103	>000a					fsNumber: .fill 1
1104						                .ends

1106						osgbpbBlock: .struct
1107	>0000					handle: .fill 1
1108	>0001					addr: .fill 4
1109	>0005					numBytes: .fill 4
1110	>0009					ptr: .fill 4
1111						                .ends

1113						                ; NAUG p260
1114						                .virtual $dc00
1115	.dc00					hazel: .block
1116	.dc00					commandLine:                    ;dc00
1117	>dc00					                .fill 256
1118	.dd00					ddxx:                           ;dd00
1119	>dd00					                .fill 256
1120	.de00					dexx:
1121	>de00					                .fill 256
1122	.df00					currentFS:                      ;df00
1123	>df00					                .fill 1
1124	.df01					activeFS:                       ;df01
1125	>df01					                .fill 1
1126	.df02					libFS:                          ;df02
1127	>df02					                .fill 1
1128	.df03					currentFSROM:                   ;df03
1129	>df03					                .fill 1
1130	.df04					commandLinePointer:             ;df04
1131	>df04					                .fill 2

1133						                ; 17 info blocks in total, but everything is relative
1134						                ; to the 0th, so there's only a need to instantiate a
1135						                ; struct for that one. Don't think 64tass handles
1136						                ; arrays of structs anyway.
1137	.df06					fsInfoBlocks:   .dstruct fsInfoBlock ;df06
1100	>df06					name: .fill 8
1101	>df0e					minHandle: .fill 1
1102	>df0f					maxHandle: .fill 1
1103	>df10					fsNumber: .fill 1
1104						                .ends
1138	>df11					                .fill 16*size(fsInfoBlock)
1139	.dfc1					fsInfoBlocksTerminator:         ;dfc1
1140						                ; space reserved for the 0 terminator when the full
1141						                ; set of info blocks are filled.
1142	>dfc1					                .fill 1
1143	.dfc2					fsFlags: .block                 ;dfc2
1144	>dfc2					                .fill 1
1145	=$80					useASCII=$80
1146	=$80					isAPPEND=$80
1147	=$40					noLineNumbers=$40
1148						                .bend
1149	.dfc3					lineNumberBCD:                  ;dfc3
1150	>dfc3					                .fill 2
1151	.dfc5					lastCharPrinted:                ;dfc5
1152	>dfc5					                .fill 1
1153	.dfc6					tempFSFlag:                     ;dfc6
1154	>dfc6					                .fill 1
1155	.dfc7					moveOSGBPB: .dstruct osgbpbBlock ;dfc7
1107	>dfc7					handle: .fill 1
1108	>dfc8					addr: .fill 4
1109	>dfcc					numBytes: .fill 4
1110	>dfd0					ptr: .fill 4
1111						                .ends
1156	.dfd4					moveSrcHandle:                  ;dfd4
1157	>dfd4					                .fill 1
1158	.dfd5					moveDestHandle:                 ;dfd5
1159	>dfd5					                .fill 1
1160	.dfd6					moveBufferMSB:                  ;dfd6
1161	>dfd6					                .fill 1
1162	.dfd7					moveNumPages:                   ;dfd7
1163	>dfd7					                .fill 1
1164	.dfd8					moveDestName:                   ;dfd8
1165	>dfd8					                .fill 2
1166	.dfda					activeFSCV:                     ;dfda
1167	>dfda					                .fill 2
1168	.dfdc					oldACCCON:                      ;dfdc
1169	>dfdc					                .fill 1
1170	.dfdd					hasACCCONChanged:                ;dfdd
1171	>dfdd					                .fill 1

1174	.dfde					sramBankModes:
1175						                ; pseudo/absolute bank flags, as queried by OSBYTE $45
1177	>dfde					                .fill 1

1191						                .bend
1192						                .endv

1194						;-------------------------------------------------------------------------
1195						;
1196						; VDU variables
1197						;
1198						; MasRef E.4-1
1199						;
1200						VDUVariables: .struct
1201	.0000					graphicsWindow:
1202						;graphicsWindowLeftBottom:
1203						; &00 2 Graphics window left column. (p)
1204	>0000					graphicsWindowPixelsLeft: .fill 2
1205						; &02 2 Graphics window bottom row. (p)
1206	>0002					graphicsWindowPixelsBottom: .fill 2
1207						;graphicsWindowRightTop:
1208						; &04 2 Graphics window right column. (p)
1209	>0004					graphicsWindowPixelsRight: .fill 2
1210						; &06 2 Graphics window top row. (p)
1211	>0006					graphicsWindowPixelsTop: .fill 2
1212	.0008					textWindow:
1213						; &08 1 Text window left column.
1214	>0008					textWindowLeft: .fill 1
1215						; &09 1 Text window bottom row.
1216	>0009					textWindowBottom: .fill 1
1217						; &0A 1 Text window right column.
1218	>000a					textWindowRight: .fill 1
1219						; &0B 1 Text window top row.
1220	>000b					textWindowTop: .fill 1
1221						; &0C 2 Graphics origin X coordinate. (e)
1222	>000c					graphicsWindowOriginX: .fill 2
1223						; &0E 2 Graphics origin Y coordinate. (e)
1224	>000e					graphicsWindowOriginY: .fill 2
1225						; &10 2 Graphics cursor X coordinate. (e)
1226	>0010					graphicsCursorPositionX: .fill 2
1227						; &12 2 Graphics cursor Y coordinate. (e)
1228	>0012					graphicsCursorPositionY: .fill 2
1229						; &14 2 Previous graphics cursor X coordinate. (p)
1230	.0014					oldGraphicsCursorPixels:
1231	>0014					oldGraphicsCursorPixelsX: .fill 2
1232						; &16 2 Previous graphics cursor Y coordinate. (p)
1233	>0016					oldGraphicsCursorPixelsY: .fill 2
1234						; &18 1 Text cursor X coordinate (from left of screen) when not cursor editing. When cursor editing, normally the input cursor X coordinate, but the output cursor X coordinate within an "unknown PLOT codes" routine.
1235	>0018					textCursorXPosition: .fill 1
1236						; &19 1 Text cursor Y coordinate (from top of screen) when not cursor editing. When cursor editing, normally t.lsthe input cursor Y coordinate, but the output cursor Y coordinate within an "unknown PLOT codes" routine.
1237	>0019					textCursorYPosition: .fill 1
1238						; &1A 1 Y produced by GADDR (see next section) so that (ZMEMG),Y addresses the correct byte.
1239	>001a					graphicsAddressOffset: .fill 1
1240						; &1B-&23 VDU queue: &23 contains last byte of queue, other bytes immediately precede it.
1241	=9					queueSize=9
1242	>001b					queueBegin: .fill queueSize
1243	.0024					queueEnd:
1244	.0024					graphicsCursorPixels:
1245						; &24 2 Graphics cursor X coordinate. (p)
1246	>0024					graphicsCursorPixelsX: .fill 2
1247						; &26 2 Graphics cursor Y coordinate. (p)
1248	>0026					graphicsCursorPixelsY: .fill 2
1249						; &28-&49 Workspace. But variable &38 must not be used in a Teletext mode (mode 7 or 135).
1250						                .union
1251	.0028					ew: .dstruct EllipseWorkspaceVDUVariables
1449						                ; https://tobylobster.github.io/GXR-pages/gxr/S-s3.html#SP4
1450	.0028					aspectRatio:
1451	>0028					                .fill 3
1452	.002b					shear:
1453	>002b					                .fill 3
1454	.002e					halfHeightCounter:
1455	>002e					                .fill 2
1456	.0030					halfHeightSquared:
1457	>0030					                .fill 4
1458	.0034					pointC:
1459	>0034					                .fill 2
1460	.0036					pointD:
1461	>0036					                .fill 2
1462	.0038					leftPoint:
1463	>0038					                .fill 2
1464	.003a					rightPoint:
1465	>003a					                .fill 2
1466	.003c					pointA:
1467	>003c					                .fill 2
1468	.003e					pointB:
1469	>003e					                .fill 2
1470	.0040					pointE:
1471	>0040					                .fill 2
1472	.0042					currentOffsetX:
1473	>0042					                .fill 2
1474	.0044					plotPointX:
1475	.0044					pointF:
1476	>0044					                .fill 2
1477	.0046					plotPointY:
1478	>0046					                .fill 2
1479						                .endstruct
1252	.0028					hlfw: .dstruct HorizontalLineFillWorkspaceVDUVariables
1514	>0028					                .fill 6
1515	.002e					pixelsX:                        ;2e
1516	>002e					                .fill 2
1517	.0030					pixelsY:                        ;30
1518	>0030					                .fill 2
1519	.0032					pixelsRightEndX:
1520	>0032					                .fill 2         ;32
1521	.0034					pixelsLimitX:                   ;34
1522	>0034					                .fill 2
1523						                .endstruct
1253	.0028					mocr: .dstruct MoveOrCopyRectangleWorkspaceVDUVariables
1492	.0028					src: .dstruct VDUAABB
1373	.0028					min: .dstruct VDUCoordinate
1368	>0028					x: .fill 2
1369	>002a					y: .fill 2
1370						                .endstruct
1374	.002c					max: .dstruct VDUCoordinate
1368	>002c					x: .fill 2
1369	>002e					y: .fill 2
1370						                .endstruct
1375						                .endstruct
1493	.0030					L30:
1494	>0030					                .fill 4
1495	.0034					dest: .dstruct VDUAABB
1373	.0034					min: .dstruct VDUCoordinate
1368	>0034					x: .fill 2
1369	>0036					y: .fill 2
1370						                .endstruct
1374	.0038					max: .dstruct VDUCoordinate
1368	>0038					x: .fill 2
1369	>003a					y: .fill 2
1370						                .endstruct
1375						                .endstruct
1496	.003c					L3C:
1497	>003c					                .fill 4
1498	.0040					L40:
1499	>0040					                .fill 2
1500	.0042					shiftToNextByte:
1501	>0042					                .fill 2
1502	.0044					L44:
1503	>0044					                .fill 1
1504	.0045					copy:
1505	>0045					                .fill 1         ;0=move, 2=copy
1506	.0046					L46:
1507	>0046					                .fill 1
1508	.0047					L47:
1509	>0047					                .fill 1

1511						                .endstruct
1254	.0028					workspace: .dstruct GenericWorkspaceVDUVariables
1378	.0028					_28:
1379	>0028					                .fill 1
1380	.0029					_29:
1381	>0029					                .fill 1
1382	.002a					_2A:
1383	>002a					                .fill 1
1384	.002b					_2B:
1385	>002b					                .fill 1
1386	.002c					_2C:
1387	>002c					                .fill 1
1388	.002d					_2D:
1389	>002d					                .fill 1
1390	.002e					_2E:
1391	>002e					                .fill 1
1392	.002f					_2F:
1393	>002f					                .fill 1
1394	.0030					_30:
1395	>0030					                .fill 1
1396	.0031					_31:
1397	>0031					                .fill 1
1398	.0032					_32:
1399	>0032					                .fill 1
1400	.0033					_33:
1401	>0033					                .fill 1
1402	.0034					_34:
1403	>0034					                .fill 1
1404	.0035					_35:
1405	>0035					                .fill 1
1406	.0036					_36:
1407	>0036					                .fill 1
1408	.0037					_37:
1409	>0037					                .fill 1
1410	.0038					_38:
1411	>0038					                .fill 1
1412	.0039					_39:
1413	>0039					                .fill 1
1414	.003a					_3A:
1415	>003a					                .fill 1
1416	.003b					_3B:
1417	>003b					                .fill 1
1418	.003c					_3C:
1419	>003c					                .fill 1
1420	.003d					_3D:
1421	>003d					                .fill 1
1422	.003e					_3E:
1423	>003e					                .fill 1
1424	.003f					_3F:
1425	>003f					                .fill 1
1426	.0040					_40:
1427	>0040					                .fill 1
1428	.0041					_41:
1429	>0041					                .fill 1
1430	.0042					_42:
1431	>0042					                .fill 1
1432	.0043					_43:
1433	>0043					                .fill 1
1434	.0044					_44:
1435	>0044					                .fill 1
1436	.0045					_45:
1437	>0045					                .fill 1
1438	.0046					_46:
1439	>0046					                .fill 1
1440	.0047					_47:
1441	>0047					                .fill 1
1442	.0048					_48:
1443	>0048					                .fill 1
1444	.0049					_49:
1445	>0049					                .fill 1
1446						                .endstruct
1255						                .endunion
1256						; &4A 2 Address at which the 6845 is to display the text cursor.
1257	>004a					textCursorCRTCAddress: .fill 2
1258						; &4C 2 Number of bytes in a character row of the text window.
1259	>004c					textWindowWidthInBytes: .fill 2
1260						; &4E 1 Most significant byte of address of first byte of screen memory.
1261	>004e					startScreenAddressHighByte: .fill 1
1262						; &4F 1 Number of bytes in a character.
1263	>004f					bytesPerCharacter: .fill 1
1264						; &50 2 Address of byte in top left corner of screen display.
1265	>0050					screenTopLeftAddress: .fill 2
1266						; &52 2 Number of bytes in a character row of the whole screen.
1267	>0052					bytesPerCharacterRow: .fill 2
1268						; &54 1 Most significant byte of number of bytes of screen memory.
1269	>0054					screenSizeHighByte: .fill 1
1270						; &55 1 Current screen mode (in range 0-7, i.e. without regard to 'shadowing').
1271	>0055					currentScreenMODE: .fill 1
1272						; &56 1 Memory mode: 0 for 20K modes, 1 for 16K modes, 2 for 10K modes, 3 for 8K modes, 4 for 1K modes.
1273	>0056					currentScreenMODEGroup: .fill 1
1274						; &57 1 Foreground text colour mask.
1275	>0057					foregroundTextColour: .fill 1
1276						; &58 1 Background text colour mask.
1277	>0058					backgroundTextColour: .fill 1
1278						; &59 1 0 if plotting graphics foreground, 8 if plotting graphics background.
1279	>0059					graphicsPlotState: .fill 1
1280						; &5A 1 Current graphics plot mode (usually set to one of following two reduced mod 16).
1281	>005a					graphicsPlotMode: .fill 1
1282						; &5B 1 Current graphics foreground plot mode (as set by VDU 18).
1283	>005b					foregroundGCOLMode: .fill 1
1284						; &5C 1 Current graphics background plot mode (as set by VDU 18).
1285	>005c					backgroundGCOLMode: .fill 1
1286						; &5D 2 Address of routine to process current VDU sequence.
1287	>005d					jumpVector: .fill 2
1288						; &5F 1 Value for 6845 register 10 to revert to on leaving cursor editing.
1289	>005f					lastCursorStartRegisterValue: .fill 1
1290						; &60 1 (Number of logical colours)-1 (0 if Teletext).
1291	>0060					numberOfLogicalColoursMinusOne: .fill 1
1292						; &61 1 (Number of pixels/byte)-1 (0 if not graphics).
1293	>0061					pixelsPerByteMinusOne: .fill 1
1294						; &62 1 Mask for leftmost pixel in a byte.
1295	>0062					colourMaskLeft: .fill 1
1296						; &63 1 Mask for rightmost pixel in a byte.
1297	>0063					colourMaskRight: .fill 1
1298						; &64 1 Output cursor X coordinate when cursor editing, but input cursor X coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1299	>0064					editCursorXPosition: .fill 1
1300						; &65 1 Output cursor Y coordinate when cursor editing, but input cursor Y coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1301	>0065					editCursorYPosition: .fill 1
1302						; &66 1 Cursor control flags (as set by VDU 23 16).
1303	.0066					cursorFlags: .block
1304	>0066					                .fill 1
1305						; MasRef E.3-18
1306	=$40					noSpecialVDU5Actions=$40
1307	=$20					noMoveCursorAfterPrint=$20
1308	=$10					noVerticalScroll=$10
1309	=$08					swapAxes=$08                    ;if set, X=vert; if clear, X=horiz
1310	=$04					invertVertical=$04              ;if set, vert=up; if clear, vert=down
1311	=$02					invertHorizontal=$02            ;if set, horiz=left; if clear, horiz=right
1312	=$01					scrollProtect=$01
1313						                .endblock
1314						; &67 1 Dot pattern (as set by VDU 23 6).
1315	>0067					dotPattern: .fill 1
1316						; &68 1 Current state of dot pattern.
1317	>0068					dotPatternState: .fill 1
1318						; &69 1 0 if colour being plotted is solid, non-zero if colour is an ECF
1319	>0069					isColourECF: .fill 1
1320						; &6A 1 0 if graphics foreground colour is solid, non-zero if foreground colour is an ECF
1321	>006a					isForegroundECF: .fill 1
1322						; &6B 1 0 if graphics background colour is solid, non-zero if background colour is an ECF
1323	>006b					isBackgroundECF: .fill 1
1324						; &6C 1 Top bit set when cursor is in "column 81".
1325	>006c					column81: .fill 1
1326						; &6D 1 Current graphics foreground colour (as set by VDU 18).
1327	>006d					foregroundGraphicsColour: .fill 1
1328						; &6E 1 Current graphics background colour (as set by VDU 18)
1329	>006e					backgroundGraphicsColour: .fill 1
1330						; &6F-&7E Software copy of the current palette.
1331	>006f					currentPalette: .fill 16
1332						; &7F 1 Reserved.
1333	>007f					reserved: .fill 1
1334						                .endstruct

1336						                .virtual $300
1337	.0300					vduv: .dstruct VDUVariables
1201	.0300					graphicsWindow:
1202						;graphicsWindowLeftBottom:
1203						; &00 2 Graphics window left column. (p)
1204	>0300					graphicsWindowPixelsLeft: .fill 2
1205						; &02 2 Graphics window bottom row. (p)
1206	>0302					graphicsWindowPixelsBottom: .fill 2
1207						;graphicsWindowRightTop:
1208						; &04 2 Graphics window right column. (p)
1209	>0304					graphicsWindowPixelsRight: .fill 2
1210						; &06 2 Graphics window top row. (p)
1211	>0306					graphicsWindowPixelsTop: .fill 2
1212	.0308					textWindow:
1213						; &08 1 Text window left column.
1214	>0308					textWindowLeft: .fill 1
1215						; &09 1 Text window bottom row.
1216	>0309					textWindowBottom: .fill 1
1217						; &0A 1 Text window right column.
1218	>030a					textWindowRight: .fill 1
1219						; &0B 1 Text window top row.
1220	>030b					textWindowTop: .fill 1
1221						; &0C 2 Graphics origin X coordinate. (e)
1222	>030c					graphicsWindowOriginX: .fill 2
1223						; &0E 2 Graphics origin Y coordinate. (e)
1224	>030e					graphicsWindowOriginY: .fill 2
1225						; &10 2 Graphics cursor X coordinate. (e)
1226	>0310					graphicsCursorPositionX: .fill 2
1227						; &12 2 Graphics cursor Y coordinate. (e)
1228	>0312					graphicsCursorPositionY: .fill 2
1229						; &14 2 Previous graphics cursor X coordinate. (p)
1230	.0314					oldGraphicsCursorPixels:
1231	>0314					oldGraphicsCursorPixelsX: .fill 2
1232						; &16 2 Previous graphics cursor Y coordinate. (p)
1233	>0316					oldGraphicsCursorPixelsY: .fill 2
1234						; &18 1 Text cursor X coordinate (from left of screen) when not cursor editing. When cursor editing, normally the input cursor X coordinate, but the output cursor X coordinate within an "unknown PLOT codes" routine.
1235	>0318					textCursorXPosition: .fill 1
1236						; &19 1 Text cursor Y coordinate (from top of screen) when not cursor editing. When cursor editing, normally t.lsthe input cursor Y coordinate, but the output cursor Y coordinate within an "unknown PLOT codes" routine.
1237	>0319					textCursorYPosition: .fill 1
1238						; &1A 1 Y produced by GADDR (see next section) so that (ZMEMG),Y addresses the correct byte.
1239	>031a					graphicsAddressOffset: .fill 1
1240						; &1B-&23 VDU queue: &23 contains last byte of queue, other bytes immediately precede it.
1241	=9					queueSize=9
1242	>031b					queueBegin: .fill queueSize
1243	.0324					queueEnd:
1244	.0324					graphicsCursorPixels:
1245						; &24 2 Graphics cursor X coordinate. (p)
1246	>0324					graphicsCursorPixelsX: .fill 2
1247						; &26 2 Graphics cursor Y coordinate. (p)
1248	>0326					graphicsCursorPixelsY: .fill 2
1249						; &28-&49 Workspace. But variable &38 must not be used in a Teletext mode (mode 7 or 135).
1250						                .union
1251	.0328					ew: .dstruct EllipseWorkspaceVDUVariables
1449						                ; https://tobylobster.github.io/GXR-pages/gxr/S-s3.html#SP4
1450	.0328					aspectRatio:
1451	>0328					                .fill 3
1452	.032b					shear:
1453	>032b					                .fill 3
1454	.032e					halfHeightCounter:
1455	>032e					                .fill 2
1456	.0330					halfHeightSquared:
1457	>0330					                .fill 4
1458	.0334					pointC:
1459	>0334					                .fill 2
1460	.0336					pointD:
1461	>0336					                .fill 2
1462	.0338					leftPoint:
1463	>0338					                .fill 2
1464	.033a					rightPoint:
1465	>033a					                .fill 2
1466	.033c					pointA:
1467	>033c					                .fill 2
1468	.033e					pointB:
1469	>033e					                .fill 2
1470	.0340					pointE:
1471	>0340					                .fill 2
1472	.0342					currentOffsetX:
1473	>0342					                .fill 2
1474	.0344					plotPointX:
1475	.0344					pointF:
1476	>0344					                .fill 2
1477	.0346					plotPointY:
1478	>0346					                .fill 2
1479						                .endstruct
1252	.0328					hlfw: .dstruct HorizontalLineFillWorkspaceVDUVariables
1514	>0328					                .fill 6
1515	.032e					pixelsX:                        ;2e
1516	>032e					                .fill 2
1517	.0330					pixelsY:                        ;30
1518	>0330					                .fill 2
1519	.0332					pixelsRightEndX:
1520	>0332					                .fill 2         ;32
1521	.0334					pixelsLimitX:                   ;34
1522	>0334					                .fill 2
1523						                .endstruct
1253	.0328					mocr: .dstruct MoveOrCopyRectangleWorkspaceVDUVariables
1492	.0328					src: .dstruct VDUAABB
1373	.0328					min: .dstruct VDUCoordinate
1368	>0328					x: .fill 2
1369	>032a					y: .fill 2
1370						                .endstruct
1374	.032c					max: .dstruct VDUCoordinate
1368	>032c					x: .fill 2
1369	>032e					y: .fill 2
1370						                .endstruct
1375						                .endstruct
1493	.0330					L30:
1494	>0330					                .fill 4
1495	.0334					dest: .dstruct VDUAABB
1373	.0334					min: .dstruct VDUCoordinate
1368	>0334					x: .fill 2
1369	>0336					y: .fill 2
1370						                .endstruct
1374	.0338					max: .dstruct VDUCoordinate
1368	>0338					x: .fill 2
1369	>033a					y: .fill 2
1370						                .endstruct
1375						                .endstruct
1496	.033c					L3C:
1497	>033c					                .fill 4
1498	.0340					L40:
1499	>0340					                .fill 2
1500	.0342					shiftToNextByte:
1501	>0342					                .fill 2
1502	.0344					L44:
1503	>0344					                .fill 1
1504	.0345					copy:
1505	>0345					                .fill 1         ;0=move, 2=copy
1506	.0346					L46:
1507	>0346					                .fill 1
1508	.0347					L47:
1509	>0347					                .fill 1

1511						                .endstruct
1254	.0328					workspace: .dstruct GenericWorkspaceVDUVariables
1378	.0328					_28:
1379	>0328					                .fill 1
1380	.0329					_29:
1381	>0329					                .fill 1
1382	.032a					_2A:
1383	>032a					                .fill 1
1384	.032b					_2B:
1385	>032b					                .fill 1
1386	.032c					_2C:
1387	>032c					                .fill 1
1388	.032d					_2D:
1389	>032d					                .fill 1
1390	.032e					_2E:
1391	>032e					                .fill 1
1392	.032f					_2F:
1393	>032f					                .fill 1
1394	.0330					_30:
1395	>0330					                .fill 1
1396	.0331					_31:
1397	>0331					                .fill 1
1398	.0332					_32:
1399	>0332					                .fill 1
1400	.0333					_33:
1401	>0333					                .fill 1
1402	.0334					_34:
1403	>0334					                .fill 1
1404	.0335					_35:
1405	>0335					                .fill 1
1406	.0336					_36:
1407	>0336					                .fill 1
1408	.0337					_37:
1409	>0337					                .fill 1
1410	.0338					_38:
1411	>0338					                .fill 1
1412	.0339					_39:
1413	>0339					                .fill 1
1414	.033a					_3A:
1415	>033a					                .fill 1
1416	.033b					_3B:
1417	>033b					                .fill 1
1418	.033c					_3C:
1419	>033c					                .fill 1
1420	.033d					_3D:
1421	>033d					                .fill 1
1422	.033e					_3E:
1423	>033e					                .fill 1
1424	.033f					_3F:
1425	>033f					                .fill 1
1426	.0340					_40:
1427	>0340					                .fill 1
1428	.0341					_41:
1429	>0341					                .fill 1
1430	.0342					_42:
1431	>0342					                .fill 1
1432	.0343					_43:
1433	>0343					                .fill 1
1434	.0344					_44:
1435	>0344					                .fill 1
1436	.0345					_45:
1437	>0345					                .fill 1
1438	.0346					_46:
1439	>0346					                .fill 1
1440	.0347					_47:
1441	>0347					                .fill 1
1442	.0348					_48:
1443	>0348					                .fill 1
1444	.0349					_49:
1445	>0349					                .fill 1
1446						                .endstruct
1255						                .endunion
1256						; &4A 2 Address at which the 6845 is to display the text cursor.
1257	>034a					textCursorCRTCAddress: .fill 2
1258						; &4C 2 Number of bytes in a character row of the text window.
1259	>034c					textWindowWidthInBytes: .fill 2
1260						; &4E 1 Most significant byte of address of first byte of screen memory.
1261	>034e					startScreenAddressHighByte: .fill 1
1262						; &4F 1 Number of bytes in a character.
1263	>034f					bytesPerCharacter: .fill 1
1264						; &50 2 Address of byte in top left corner of screen display.
1265	>0350					screenTopLeftAddress: .fill 2
1266						; &52 2 Number of bytes in a character row of the whole screen.
1267	>0352					bytesPerCharacterRow: .fill 2
1268						; &54 1 Most significant byte of number of bytes of screen memory.
1269	>0354					screenSizeHighByte: .fill 1
1270						; &55 1 Current screen mode (in range 0-7, i.e. without regard to 'shadowing').
1271	>0355					currentScreenMODE: .fill 1
1272						; &56 1 Memory mode: 0 for 20K modes, 1 for 16K modes, 2 for 10K modes, 3 for 8K modes, 4 for 1K modes.
1273	>0356					currentScreenMODEGroup: .fill 1
1274						; &57 1 Foreground text colour mask.
1275	>0357					foregroundTextColour: .fill 1
1276						; &58 1 Background text colour mask.
1277	>0358					backgroundTextColour: .fill 1
1278						; &59 1 0 if plotting graphics foreground, 8 if plotting graphics background.
1279	>0359					graphicsPlotState: .fill 1
1280						; &5A 1 Current graphics plot mode (usually set to one of following two reduced mod 16).
1281	>035a					graphicsPlotMode: .fill 1
1282						; &5B 1 Current graphics foreground plot mode (as set by VDU 18).
1283	>035b					foregroundGCOLMode: .fill 1
1284						; &5C 1 Current graphics background plot mode (as set by VDU 18).
1285	>035c					backgroundGCOLMode: .fill 1
1286						; &5D 2 Address of routine to process current VDU sequence.
1287	>035d					jumpVector: .fill 2
1288						; &5F 1 Value for 6845 register 10 to revert to on leaving cursor editing.
1289	>035f					lastCursorStartRegisterValue: .fill 1
1290						; &60 1 (Number of logical colours)-1 (0 if Teletext).
1291	>0360					numberOfLogicalColoursMinusOne: .fill 1
1292						; &61 1 (Number of pixels/byte)-1 (0 if not graphics).
1293	>0361					pixelsPerByteMinusOne: .fill 1
1294						; &62 1 Mask for leftmost pixel in a byte.
1295	>0362					colourMaskLeft: .fill 1
1296						; &63 1 Mask for rightmost pixel in a byte.
1297	>0363					colourMaskRight: .fill 1
1298						; &64 1 Output cursor X coordinate when cursor editing, but input cursor X coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1299	>0364					editCursorXPosition: .fill 1
1300						; &65 1 Output cursor Y coordinate when cursor editing, but input cursor Y coordinate when cursor editing and inside an 'unknown PLOT codes' routine.
1301	>0365					editCursorYPosition: .fill 1
1302						; &66 1 Cursor control flags (as set by VDU 23 16).
1303	.0366					cursorFlags: .block
1304	>0366					                .fill 1
1305						; MasRef E.3-18
1306	=$40					noSpecialVDU5Actions=$40
1307	=$20					noMoveCursorAfterPrint=$20
1308	=$10					noVerticalScroll=$10
1309	=$08					swapAxes=$08                    ;if set, X=vert; if clear, X=horiz
1310	=$04					invertVertical=$04              ;if set, vert=up; if clear, vert=down
1311	=$02					invertHorizontal=$02            ;if set, horiz=left; if clear, horiz=right
1312	=$01					scrollProtect=$01
1313						                .endblock
1314						; &67 1 Dot pattern (as set by VDU 23 6).
1315	>0367					dotPattern: .fill 1
1316						; &68 1 Current state of dot pattern.
1317	>0368					dotPatternState: .fill 1
1318						; &69 1 0 if colour being plotted is solid, non-zero if colour is an ECF
1319	>0369					isColourECF: .fill 1
1320						; &6A 1 0 if graphics foreground colour is solid, non-zero if foreground colour is an ECF
1321	>036a					isForegroundECF: .fill 1
1322						; &6B 1 0 if graphics background colour is solid, non-zero if background colour is an ECF
1323	>036b					isBackgroundECF: .fill 1
1324						; &6C 1 Top bit set when cursor is in "column 81".
1325	>036c					column81: .fill 1
1326						; &6D 1 Current graphics foreground colour (as set by VDU 18).
1327	>036d					foregroundGraphicsColour: .fill 1
1328						; &6E 1 Current graphics background colour (as set by VDU 18)
1329	>036e					backgroundGraphicsColour: .fill 1
1330						; &6F-&7E Software copy of the current palette.
1331	>036f					currentPalette: .fill 16
1332						; &7F 1 Reserved.
1333	>037f					reserved: .fill 1
1334						                .endstruct
1338						                .endvirtual

1340						; vduQueueItemAddr: .function index
1341						;                 .cerror index<0||index>=vdu.queueSize,"bad VDU queue index"
1342						;                 .endfunction vdu.queue+vdu.queueSize-1-index

1344						; Presumed addresses in ANDY that don't happen to coincide with other
1345						; labels.
1346						;
1347						; MasRef E.4-5, MasRef F.6-10
1348						;
1349						; &8000-83FF  RAM  Soft key expansions buffer
1350						; &8400-87FF  RAM  VDU workspace.
1351						; &8800-07    RAM  ECF pattern 1 definition.
1352						; &8808-0F    RAM  ECF pattern 2 definition.
1353						; &8810-17    RAM  ECF pattern 3 definition.
1354						; &8818-1F    RAM  ECF pattern 4 definition.
1355						; &8820-27    RAM  Current foreground ECF pattern or solid colour.
1356						; &8828-2F    RAM  Current background ECF pattern or solid colour.
1357						; &8830-BF    RAM  VDU workspace.
1358						; &88C0-FF    RAM  Reserved for future expansion.
1359						; &8900-FF    RAM  Current definitions of characters &20-3F.
1360						; &8A00-FF    RAM  Current definitions of characters &40-5F.
1361						; &8B00-FF    RAM  Current definitions of characters &60-7F.
1362						; &8C00-FF    RAM  Current definitions of characters &80-9F.
1363						; &8D00-FF    RAM  Current definitions of characters &A0-BF.
1364						; &8E00-FF    RAM  Current definitions of characters &C0-DF.
1365						; &8F00-FF    RAM  Current definitions of characters &E0-FF.

1367						VDUCoordinate: .struct
1368	>0000					x: .fill 2
1369	>0002					y: .fill 2
1370						                .endstruct

1372						VDUAABB: .struct
1373	.0000					min: .dstruct VDUCoordinate
1368	>0000					x: .fill 2
1369	>0002					y: .fill 2
1370						                .endstruct
1374	.0004					max: .dstruct VDUCoordinate
1368	>0004					x: .fill 2
1369	>0006					y: .fill 2
1370						                .endstruct
1375						                .endstruct

1377						GenericWorkspaceVDUVariables: .struct
1378	.0000					_28:
1379	>0000					                .fill 1
1380	.0001					_29:
1381	>0001					                .fill 1
1382	.0002					_2A:
1383	>0002					                .fill 1
1384	.0003					_2B:
1385	>0003					                .fill 1
1386	.0004					_2C:
1387	>0004					                .fill 1
1388	.0005					_2D:
1389	>0005					                .fill 1
1390	.0006					_2E:
1391	>0006					                .fill 1
1392	.0007					_2F:
1393	>0007					                .fill 1
1394	.0008					_30:
1395	>0008					                .fill 1
1396	.0009					_31:
1397	>0009					                .fill 1
1398	.000a					_32:
1399	>000a					                .fill 1
1400	.000b					_33:
1401	>000b					                .fill 1
1402	.000c					_34:
1403	>000c					                .fill 1
1404	.000d					_35:
1405	>000d					                .fill 1
1406	.000e					_36:
1407	>000e					                .fill 1
1408	.000f					_37:
1409	>000f					                .fill 1
1410	.0010					_38:
1411	>0010					                .fill 1
1412	.0011					_39:
1413	>0011					                .fill 1
1414	.0012					_3A:
1415	>0012					                .fill 1
1416	.0013					_3B:
1417	>0013					                .fill 1
1418	.0014					_3C:
1419	>0014					                .fill 1
1420	.0015					_3D:
1421	>0015					                .fill 1
1422	.0016					_3E:
1423	>0016					                .fill 1
1424	.0017					_3F:
1425	>0017					                .fill 1
1426	.0018					_40:
1427	>0018					                .fill 1
1428	.0019					_41:
1429	>0019					                .fill 1
1430	.001a					_42:
1431	>001a					                .fill 1
1432	.001b					_43:
1433	>001b					                .fill 1
1434	.001c					_44:
1435	>001c					                .fill 1
1436	.001d					_45:
1437	>001d					                .fill 1
1438	.001e					_46:
1439	>001e					                .fill 1
1440	.001f					_47:
1441	>001f					                .fill 1
1442	.0020					_48:
1443	>0020					                .fill 1
1444	.0021					_49:
1445	>0021					                .fill 1
1446						                .endstruct

1448						EllipseWorkspaceVDUVariables: .struct
1449						                ; https://tobylobster.github.io/GXR-pages/gxr/S-s3.html#SP4
1450	.0000					aspectRatio:
1451	>0000					                .fill 3
1452	.0003					shear:
1453	>0003					                .fill 3
1454	.0006					halfHeightCounter:
1455	>0006					                .fill 2
1456	.0008					halfHeightSquared:
1457	>0008					                .fill 4
1458	.000c					pointC:
1459	>000c					                .fill 2
1460	.000e					pointD:
1461	>000e					                .fill 2
1462	.0010					leftPoint:
1463	>0010					                .fill 2
1464	.0012					rightPoint:
1465	>0012					                .fill 2
1466	.0014					pointA:
1467	>0014					                .fill 2
1468	.0016					pointB:
1469	>0016					                .fill 2
1470	.0018					pointE:
1471	>0018					                .fill 2
1472	.001a					currentOffsetX:
1473	>001a					                .fill 2
1474	.001c					plotPointX:
1475	.001c					pointF:
1476	>001c					                .fill 2
1477	.001e					plotPointY:
1478	>001e					                .fill 2
1479						                .endstruct

1481						HorizontalLineFillWorkspaceZP: .struct
1482	>0000					notByteMatch: .fill 1
1483	>0001					a: .fill 1
1484	>0002					b: .fill 2
1485						;c: .fill 2
1486	>0004					pixelsX: .fill 2
1487	>0006					d: .fill 1
1488	>0007					resultEOR: .fill 1
1489						                .endstruct

1491						MoveOrCopyRectangleWorkspaceVDUVariables: .struct
1492	.0000					src: .dstruct VDUAABB
1373	.0000					min: .dstruct VDUCoordinate
1368	>0000					x: .fill 2
1369	>0002					y: .fill 2
1370						                .endstruct
1374	.0004					max: .dstruct VDUCoordinate
1368	>0004					x: .fill 2
1369	>0006					y: .fill 2
1370						                .endstruct
1375						                .endstruct
1493	.0008					L30:
1494	>0008					                .fill 4
1495	.000c					dest: .dstruct VDUAABB
1373	.000c					min: .dstruct VDUCoordinate
1368	>000c					x: .fill 2
1369	>000e					y: .fill 2
1370						                .endstruct
1374	.0010					max: .dstruct VDUCoordinate
1368	>0010					x: .fill 2
1369	>0012					y: .fill 2
1370						                .endstruct
1375						                .endstruct
1496	.0014					L3C:
1497	>0014					                .fill 4
1498	.0018					L40:
1499	>0018					                .fill 2
1500	.001a					shiftToNextByte:
1501	>001a					                .fill 2
1502	.001c					L44:
1503	>001c					                .fill 1
1504	.001d					copy:
1505	>001d					                .fill 1         ;0=move, 2=copy
1506	.001e					L46:
1507	>001e					                .fill 1
1508	.001f					L47:
1509	>001f					                .fill 1

1511						                .endstruct

1513						HorizontalLineFillWorkspaceVDUVariables: .struct
1514	>0000					                .fill 6
1515	.0006					pixelsX:                        ;2e
1516	>0006					                .fill 2
1517	.0008					pixelsY:                        ;30
1518	>0008					                .fill 2
1519	.000a					pixelsRightEndX:
1520	>000a					                .fill 2         ;32
1521	.000c					pixelsLimitX:                   ;34
1522	>000c					                .fill 2
1523						                .endstruct

1525						HorizontalLineFillWorkspaceANDY: .struct
1526	>0000					ecfPattern: .fill 8
1527						                .endstruct

1529	=16					softKeyCount=16
1530	=$400					softKeyDataTotalSize=$400

1532						                .virtual $8000
1533	.8000					andy: .block
1534	.8000					softKeys: .block
1535	>8000					stringLSBs: .fill softKeyCount
1536	>8010					endLSB: .fill 1
1537	>8011					stringMSBs: .fill softKeyCount
1538	>8021					endMSB: .fill 1
1539	.8022					strings:
1540	>8022					                .fill softKeys+$400-*
1541	.8400					end:
1542						                .endblock
1543	>8400					                .fill $8800-*;(softKeyCount*2+1)
1544	.8800					ecfPatterns:
1545	>8800					ecfPattern1: .fill 8
1546	>8808					ecfPattern2: .fill 8
1547	>8810					ecfPattern3: .fill 8
1548	>8818					ecfPattern4: .fill 8
1549	.8820					currentECFPatterns:
1550	>8820					fgECFPattern: .fill 8
1551	>8828					bgECFPattern: .fill 8
1552	.8830					workspace:
1553						                .union
1554	.8830					hlfw: .dstruct HorizontalLineFillWorkspaceANDY
1526	>8830					ecfPattern: .fill 8
1527						                .endstruct
1555	>8830					                .fill 208
1556						                .endunion
1557	.8900					softCharacterDefinitions:
1558	>8900					                .fill (256-32)*8
1561						                .endblock
1562						                .endvirtual

1565	=$8000					L8000=$8000
1566	=$8001					L8001=$8001
1567	=$8002					L8002=$8002
1568	=$8004					L8004=$8004
1569	=$8010					L8010=$8010
1570	=$8011					L8011=$8011
1571	=$8012					L8012=$8012
1572						                ;l8011=$8011
1573						                ;l8012=$8012
1574	=$8021					L8021=$8021

1576						; see $d40d, $d4ae
1577						;
1578						; (suspect these are actually references to $8840-$104 and $8848-$104)
1579	=$873c					L873C=$873c
1580	=$8744					L8744=$8744

1582	=$8400					L8400=$8400
1583	=$8500					L8500=$8500
1584	=$8600					L8600=$8600
1585	=$8700					L8700=$8700
1586	=$87f8					L87F8=$87f8
1587	=$87ff					L87FF=$87FF
1588	=$8800					L8800=$8800
1589	=$8803					L8803=$8803
1590	=$8804					L8804=$8804
1591	=$881e					L881E=$881E
1592	=$8820					L8820=$8820
1593	=$8830					multiplicand=$8830              ; 3 bytes
1594	=$8830					L8830=$8830
1595	=$8831					L8831=$8831
1596	=$8832					L8832=$8832
1597	=$8833					L8833=$8833
1598	=$8834					multiplier=$8834                ; 3 bytes
1599	=$8834					product=$8834                   ; 6 bytes
1600	=$8834					sqrtNumber=$8834                ; 6 bytes
1601	=$8834					L8834=$8834
1602	=$8835					L8835=$8835
1603	=$8836					L8836=$8836
1604	=$8837					L8837=$8837
1605	=$8838					L8838=$8838
1606	=$8839					L8839=$8839
1607						;dividend=$883a                  ; 3 bytes
1608	=$883a					L883A=$883a
1609	=$883b					L883B=$883b
1610	=$883c					L883C=$883C
1611	=$883d					L883D=$883D
1612						;divisor=$883e                   ; 3 bytes
1613	=$883e					L883E=$883e
1614	=$883f					L883F=$883f
1615	=$8840					L8840=$8840
1616	=$8841					ellipseSignFlag=$8841           ; 1 byte
1617	=$8841					L8841=$8841
1618	=$8842					ellipseAccumulatedShear=$8842   ; 3 bytes
1619	=$8842					L8842=$8842
1620	=$8843					L8843=$8843
1621	=$8844					L8844=$8844
1622	=$8845					ellipseCountOddNumbers=$8845    ; 4 bytes
1623	=$8845					L8845=$8845
1624	=$8846					L8846=$8846
1625	=$8847					L8847=$8847
1626	=$8848					L8848=$8848
1627	=$8849					ellipseCountSquares=$8849       ; 4 bytes
1628	=$8849					L8849=$8849
1629	=$884a					L884A=$884a
1630	=$884b					L884B=$884b
1631	=$884c					L884C=$884c
1632	=$884d					ellipseCountHeight=$884d

1634						;-------------------------------------------------------------------------

1690						;-------------------------------------------------------------------------
1691						; MasRef E.4-4
1692						                .virtual $d0
1693	.00d0					STATE: .block
1694	>00d0					                .fill 1
1695						                ; D.2-32
1696	=$01					isPrinterEnabled=$01
1697	=$02					isScrollingDisabled=$02
1698	=$04					isPagedScrolling=$04
1699	=$08					isTextWindow=$08
1700	=$10					isShadowMode=$10
1701	=$20					isVDU5=$20
1702	=$40					isCursorEditing=$40
1703	=$80					isVDU21=$80
1704						                .bend

1706	>00d1					ZMASK: .fill 1                       ;Pixel mask
1707	>00d2					ZORA: .fill 1                        ;Text OR mask
1708	>00d3					ZEOR: .fill 1                        ;Text EOR mask
1709	>00d4					ZGORA: .fill 1                       ;Graphics OR mask
1710	>00d5					ZGEOR: .fill 1                       ;Graphics EOR mask
1711	>00d6					ZMEMG: .fill 2                       ;Graphics pointer
1712	>00d8					ZMEMT: .fill 2                       ;Text pointer
1713	>00da					ZTEMP: .fill 2                       ;Temporary space
1714	>00dc					ZTEMPB: .fill 2                      ;Temporary space
1715	>00de					ZTEMPC: .fill 2                      ;Temporary space
1716	>00e0					ZTEMPD: .fill 2                      ;Temporary space
1717						                .endv

1719						                .virtual ZTEMP
1720	.00da					zhlfw: .dstruct HorizontalLineFillWorkspaceZP
1482	>00da					notByteMatch: .fill 1
1483	>00db					a: .fill 1
1484	>00dc					b: .fill 2
1485						;c: .fill 2
1486	>00de					pixelsX: .fill 2
1487	>00e0					d: .fill 1
1488	>00e1					resultEOR: .fill 1
1489						                .endstruct
1721						                .endv

1724	=$f8					softKeyExpansionPtr=$f8       ;pointer to current char when expanding soft key.
1725	=$fa					SEIWKA=$fa
1726	=$fb					SEIWKB=$fb

1728	=$d8					vduWriteCursor=$d8

1730	=$d00					nmiEntryPoint=$d00

1732	=0					gcolModeOverwrite=0
1733	=1					gcolModeOR=1
1734	=2					gcolModeAND=2
1735	=3					gcolModeEOR=3
1736	=4					gcolModeInvert=4
1737	=5					gcolModeLeave=5

1739						;-------------------------------------------------------------------------

1741						StarKEYWorkspace: .struct
1742	>0000					newStringLength: .fill 1
1743	>0001					destPtr: .fill 2
1744	>0003					srcPtr: .fill 2
1745	>0005					counter: .fill 2
1746						                .endstruct

1748						OSGBPBWorkspace: .struct
1749	>0000					ptr: .fill 2
1750						                .endstruct

1752						ParseFileNameFSWorkspace: .struct
1753	>0000					fsInfoOffset: .fill 1
1754						                .endstruct

1756						OSCLIWorkspace: .struct
1757	>0000					tablePtr: .fill 2
1758						                .endstruct

1760						                ; TODO - could do being renamed, as it's used (in the
1761						                ; same way) by *UNPLUG and *INSERT.
1762						StarROMSWorkspace: .struct
1763	>0000					insertedFlagMask: .fill 1
1764						                .endstruct

1766						TerminalHELPWorkspace: .struct
1767	>0000					tablePtr: .fill 2
1768						                .endstruct

1770						                ; TODO - tediously verbose names. Acronyms work well
1771						                ; enough for the VDU variables. Do the same thing
1772						                ; here.
1773						                .virtual $b0
1774						                .union
1775	.00b0					starKEYWorkspace: .dstruct StarKEYWorkspace
1742	>00b0					newStringLength: .fill 1
1743	>00b1					destPtr: .fill 2
1744	>00b3					srcPtr: .fill 2
1745	>00b5					counter: .fill 2
1746						                .endstruct
1776	.00b0					osgbpbWorkspace: .dstruct OSGBPBWorkspace
1749	>00b0					ptr: .fill 2
1750						                .endstruct
1777	.00b0					parseFileNameFSWorkspace: .dstruct ParseFileNameFSWorkspace
1753	>00b0					fsInfoOffset: .fill 1
1754						                .endstruct
1778	.00b0					oscliWorkspace: .dstruct OSCLIWorkspace
1757	>00b0					tablePtr: .fill 2
1758						                .endstruct
1779	.00b0					starROMSWorkspace: .dstruct StarROMSWorkspace
1763	>00b0					insertedFlagMask: .fill 1
1764						                .endstruct
1780	.00b0					terminalHELPWorkspace: .dstruct TerminalHELPWorkspace
1767	>00b0					tablePtr: .fill 2
1768						                .endstruct
1781						                .endunion
1782						                .endvirtual

1784						;-------------------------------------------------------------------------

1786						; ROM number containing Terminal
1787	=15					terminalROM=15

1789						; ROM number containing the extXXXX entry points
1800	=15					extROM=15

1803						; Base page for VDU routines
1804	=$c0					vduRoutinesPage=$c0

1809	=0					cmosBytesOffset=0

1812						; The CMOSBytes struct covers all versions, to ensure that the offsets
1813						; are consistent. This means there are gaps and useless entries in
1814						; some cases!
1815						;
1816						; The 30 bytes reserved for the OS aren't currently in danger of
1817						; running out.
1818						;
1819						; Some of the labels are removed based on configuration. The offsets
1820						; and bits are still reserved.
1821						;
1822						; For allocations, see: https://beebwiki.mdfs.net/CMOS_configuration_RAM_allocation
1823						CMOSBytes: .struct
1824	>0000					econetStationNumber: .fill 1
1825	>0001					fileServerStationNumber: .fill 1
1826	>0002					fileServerNetworkNumber: .fill 1
1827	>0003					printerServerStationNumber: .fill 1
1828	>0004					printerServerNetworkNumber: .fill 1
1829	.0005					defaultROMs: .block
1830	>0005					                .fill 1
1831	=0					fsShift=0
1832	=4					languageShift=4
1833						                .endblock

1835	>0006					insertedROMs: .fill 2

1837	>0008					editROMByte: .fill 1
1838	>0009					telecommsByte: .fill 1

1840	.000a					defaults0: .block
1841	>000a					                .fill 1
1842	=0					modeShift=0
1843	=7					modeMask=7
1844	=8					shadowMask=8
1845	=16					interlaceMask=16
1846	=7					tvMask=7
1847	=5					tvShift=5
1848						                .endblock

1850	.000b					defaults1: .block
1851	>000b					                .fill 1
1852	=0					fdriveShift=0
1853	=7					fdriveMask=7
1854	=8					shiftLockMask=8
1855	=16					noLockMask=16
1856	=32					capsLockMask=32
1857	=64					adfsLoadDirMask=64
1858	=128					floppyDrive=128
1859						                .endblock

1861	>000c					keyboardAutoRepeatDelay: .fill 1
1862	>000d					keyboardAutoRepeatRate: .fill 1
1863	>000e					printerIgnoreChar: .fill 1

1865	.000f					defaults2: .block
1866	>000f					                .fill 1
1870	=2					usePrinterIgnoreCharMask=2
1871	=7					serialBaudRateIndexMask=7
1872	=2					serialBaudRateIndexShift=2
1873	=7					fx5SettingMask=7
1874	=5					fx5SettingShift=5
1875						                .endblock

1877	.0010					defaults3: .block
1878	>0010					                .fill 1
1879						; bit 0 is for Master Emulation ROM's *CONFIGURE SHADOW
1880	=2					loudMask=2
1884	=8					protectedScrollingMask=8
1885	=16					autoBootMask=16
1886	=7					serialDataFormatMask=7
1887	=5					serialDataFormatShift=5
1888						                .endblock

1891						                ; Reserved for ANFS
1892	.0011					unknown11:
1894	>0011					                .fill 1

1897	.0012					joystick: .block
1899	=$f					stickMask=$f
1905	=32					isSwitchedMask=32
1907						                .endblock
1909	>0012					                .fill 1

1912						                ; 5.11 doesn't appear to use this byte, but it does
1913						                ; get cleared as part of the CMOS reset loop. So
1914						                ; presumably there was space booked for it somewhere
1915						                ; in the original code.
1916	.0013					country:
1918	>0013					                .fill 1

1931						                .endstruct

1937						                .elif version>=511||olivetti
1938	=20					cmosBytesSize=CMOSBytes.country+1

1943	=$ef					originalA=$ef
1944	=$f0					originalX=$f0
1945	=$f1					originalY=$f1
1946	=$fc					TEMPA=$fc
1947	=$fd					errPtr=$fd                      ;REPTR in OS 1.20
1948	=$ff					escapeFlag=$ff

1950	=$8c0					envelope1Data=$8c0

1952	=$8000					sidewaysROMLanguageEntry=$8000
1953	=$8003					sidewaysROMServiceEntry=$8003
1954						                .virtual $8006
1955	.8006					sidewaysROMType: .block
1956	=32					hasRelocationAddress=32
1957	=64					hasLanguageEntry=64
1958	=128					hasServiceEntry=128
1959						                .endblock
1960						                .endvirtual
1961	=$8007					sidewaysROMCopyrightOffset=$8007
1962	=$8008					sidewaysROMVersion=$8008
1963	=$8009					sidewaysROMName=$8009

1965						;-------------------------------------------------------------------------

1967						                ; [MasRef D.3-22]
1968						ClockStringFormat: .struct
1969	.0000					ddd:
1970	>0000					                .fill 3
1971	>0003					                .fill 1                      ;','
1972	.0004					nn:
1973	>0004					                .fill 2
1974	>0006					                .fill 1                      ;' '
1975	.0007					mmm:
1976	>0007					                .fill 3
1977	>000a					                .fill 1                      ;' '
1978	.000b					yyyy:
1979	>000b					                .fill 4
1980	>000f					                .fill 1                      ;'.'
1981	.0010					hh:
1982	>0010					                .fill 2
1983	>0012					                .fill 1                      ;':'
1984	.0013					mm:
1985	>0013					                .fill 2
1986	>0015					                .fill 1                      ;':'
1987	.0016					ss:
1988	>0016					                .fill 2
1989	.0018					cr:
1990	>0018					                .fill 1                      ;'\n'
1991						                .endstruct

1993						;-------------------------------------------------------------------------

:1	;******  Return to file: mosautocue.s65

3						                .include "src/terminal_workspace.s65"

:4	;******  Processing file: src/terminal_workspace.s65

1						;-------------------------------------------------------------------------

3						; Not really MOS stuff. This is the Terminal ROM zero page workspace.

5	=$70					oldINSV=$70
6	=$72					oldREMV=$72

9						;-------------------------------------------------------------------------

11						zterm: .struct
12	=$39					numRowsMinusOne=$39
13	=$38					numColumns=$38
14	=$37					numColumnsMinusOne=$37
15						; TODO old INSV and oldREMV should probably go in here too!
16						                .endstruct

:1	;******  Return to file: mosautocue.s65

5	=511					version=511
6	="MOS 5.10i"				versionString="MOS 5.10i"
7	=true					autocue=true
8	=129					defaultMODE=129

10						*=$8000
11						                .dsection utils
12						                .cwarn *>$c000,'utils ROM is too large'

14						*=$c000
15						                .dsection mos
16						                ; there's no need for a size check here - 64tass gives
17						                ; you an error if the code would go past the 64 K
18						                ; barrier.

20						;-------------------------------------------------------------------------

22						                .section utils
23						                .include "src/terminal.s65"

:5	;******  Processing file: src/terminal.s65

1						; -*- comment-column:45; -*-

3	.8000					utilsROMHeader: .block

37						                ; Language entry point
38	.8000	00		brk #		                brk
39	.8001	00		brk #		                brk
40	.8002	00		brk #		                brk

42						                ; Service entry point
43	.8003	4c ad a2	jmp $a2ad	                jmp utilsServiceEntryPoint

45	>8006	82				                .byte $82
46	>8007	0e				                .byte copyright-1-utilsROMHeader
56	>8008	10				                .byte $10
58	>8009	55 54 49 4c 53 00		                .text "UTILS",0
59	.800f					copyright:
63	>800f	28 43 29 31 39 38 36 20		                .text "(C)1986 Acorn",0
	>8017	41 63 6f 72 6e 00
66						                .endblock

68						;-------------------------------------------------------------------------

77						;-------------------------------------------------------------------------

86						;-------------------------------------------------------------------------

95						;-------------------------------------------------------------------------

108						;-------------------------------------------------------------------------

116						;-------------------------------------------------------------------------

130						;-------------------------------------------------------------------------

132						; STARTUP
133						; =======

135						; This code is officially more than a bit gnarly, as it gets stitched
136						; together in several different ways.

145	.801d					reset:                          ;8020
146						                .include "reset.s65"

:6	;******  Processing file: src/reset.s65

5	.801d	a9 fe		lda #$fe	                lda #~ACCCON.D
6	.801f	1c 34 fe	trb $fe34	                trb ACCCON
12	.8022	1c 66 03	trb $0366	                trb vduv.cursorFlags
14	.8025	d8		cld		                cld
15	.8026	a2 ff		ldx #$ff	                ldx #$FF
16	.8028	9a		txs		                txs              ;reset stack
17	.8029	8e 63 fe	stx $fe63	                stx userVIA.ddra ;port A all outputs
18	.802c	a9 cf		lda #$cf	                lda #%11001111
19	.802e	8d 42 fe	sta $fe42	                sta systemVIA.ddrb
31	.8031	a9 0c		lda #$0c	                lda #ACCCON.Y|ACCCON.X       ; page in HAZEL+shadow
32	.8033	0c 34 fe	tsb $fe34	                tsb ACCCON
34	.8036	9c dd df	stz $dfdd	                stz hazel.hasACCCONChanged
35	.8039	20 a0 83	jsr $83a0	                jsr L8363
48	.803c	ad 4e fe	lda $fe4e	                lda systemVIA.ier
50	.803f	0a		asl a		                asl a
51	.8040	48		pha		                pha             ; save initial IER<<1. 0 if power on
134	.8041	d0 2b		bne $806e	                bne nonPowerOnReset
135	.8043	a2 07		ldx #$07	                ldx #7
136	.8045	20 d7 f8	jsr $f8d7	                jsr LF8B4
140	.8048	98		tya		                tya
143	.8049					startClearRAM:
144	.8049	a8		tay		                tay             ;Y=0
145	.804a					clearRAM:
146	.804a	98		tya		                tya             ;A=0
147	.804b	64 01		stz $01		                stz $01
148	.804d	64 00		stz $00		                stz $00         ;start at $0000
149	.804f					clearRAMPageLoop:
150	.804f	91 00		sta ($00),y	                sta ($00),y     ;clear RAM
151	.8051	c8		iny		                iny
152	.8052	d0 fb		bne $804f	                bne clearRAMPageLoop
153	.8054	e6 01		inc $01		                inc $01
154	.8056	a2 40		ldx #$40	                ldx #$40          ;$40=RTI
155	.8058	8e 00 0d	stx $0d00	                stx nmiEntryPoint ;restore the RTI previously written,
156						                                  ;as each iteration will potentially
157						                                  ;overwrite it
158	.805b	a6 01		ldx $01		                ldx $01
159	.805d	e0 e0		cpx #$e0	                cpx #$E0        ;hit the end of RAM?
160	.805f	90 ee		bcc $804f	                bcc clearRAMPageLoop ;branch taken if still more to go
161	.8061	a9 04		lda #$04	                lda #ACCCON.X   ;page out shadow RAM
162	.8063	1c 34 fe	trb $fe34	                trb ACCCON
163	.8066	d0 e2		bne $804a	                bne clearRAM    ;branch taken if shadow RAM bit
164						                             ;previously set - i.e., that was the
165						                             ;first iteration, and we need to go back
166						                             ;to do main RAM
168	.8068	ad 28 fe	lda $fe28	                lda $fe28
169	.806b	ad 2b fe	lda $fe2b	                lda $fe2b
172	.806e					nonPowerOnReset:
174	.806e	ad 58 02	lda $0258	                lda breakAndESCAPEEffect
175	.8071	4a		lsr a		                lsr a
176	.8072	3a		dec a		                dec a
177	.8073	f0 d4		beq $8049	                beq startClearRAM
179	.8075	a9 3c		lda #$3c	                lda #<emptyCommandLine
180	.8077	8d 04 df	sta $df04	                sta hazel.commandLinePointer+0
181	.807a	a9 e9		lda #$e9	                lda #>emptyCommandLine
182	.807c	8d 05 df	sta $df05	                sta hazel.commandLinePointer+1
183	.807f	a9 0c		lda #$0c	                lda #ACCCON.Y|ACCCON.X ; page in MOS ROM, page in main
184						                                       ; RAM
188	.8081	1c 34 fe	trb $fe34	                trb ACCCON
190	.8084	a9 0f		lda #$0f	                lda #$0F
191	.8086	8d 8e 02	sta $028e	                sta numericKeypadShiftEffect
199	.8089	a2 01		ldx #$01	                ldx #key_ctrl
203	.808b	20 1c f7	jsr $f71c	                jsr interrogateKeyboard
218	.808e	e0 80		cpx #$80	                cpx #$80        ; C=1 if hard reset
219	.8090	20 42 f5	jsr $f542	                jsr updateKeyboardLEDs
220	.8093	9c 8d 02	stz $028d	                stz lastBREAKType            ;assume softBREAK
221	.8096	6a		ror a		                ror a                        ;restore C=1 if hard reset
222	.8097	a2 9c		ldx #$9c	                ldx #<intervalTimer ; retain TIME, but reset everything else
223	.8099	a0 8d		ldy #$8d	                ldy #<currentLanguageROM+1 ; reset all the MOS variables
224	.809b	68		pla		                pla             ; restore initial IER<<1
225	.809c	f0 09		beq $80a7	                beq isPowerOnBREAK
226	.809e					isHardBREAK:
227	.809e	a0 7e		ldy #$7e	                ldy #<editKeysMode+1 ; assume reset the soft BREAK set
228	.80a0	90 3c		bcc $80de	                bcc L80DF            ; taken if soft reset
229	.80a2	a0 87		ldy #$87	                ldy #<printerIgnoreChar+1 ; hard reset - reset the
230						                                          ; hard BREAK set
231	.80a4	ee 8d 02	inc $028d	                inc lastBREAKType
232	.80a7					isPowerOnBREAK:
233	.80a7	ee 8d 02	inc $028d	                inc lastBREAKType
234	.80aa	5a		phy		                phy

245	.80ab	20 c9 9e	jsr $9ec9	                jsr L9E58
247	.80ae	a2 4d		ldx #$4d	                ldx #configureTable.mode.metadata-configureTable
251	.80b0	20 a1 8a	jsr $8aa1	                jsr readConfigurationByte

257	.80b3	09 08		ora #$08	                ora #CMOSBytes.defaults0.shadowMask
258	.80b5	8d 8f 02	sta $028f	                sta startupOptions
262	.80b8	20 16 9e	jsr $9e16	                jsr readDefaults3 ; Read configured BOOT
264	.80bb	29 10		and #$10	                and #CMOSBytes.defaults3.autoBootMask
265	.80bd	4a		lsr a		                lsr a         ; Reset OSBYTE 255 boot bit (b3) if BOOT
266	.80be	1c 8f 02	trb $028f	                trb startupOptions
270	.80c1	20 13 8c	jsr $8c13	                jsr readDefaultTVSettings
272	.80c4	8c 90 02	sty $0290	                sty tvOffset
273	.80c7	8e 91 02	stx $0291	                stx tvInterlace
277	.80ca	20 16 9e	jsr $9e16	                jsr readDefaults3
279	.80cd	29 08		and #$08	                and #CMOSBytes.defaults3.protectedScrollingMask
280	.80cf	f0 02		beq $80d3	                beq L80D4
281	.80d1	a9 01		lda #$01	                lda #VDUVariables.cursorFlags.scrollProtect
282	.80d3					L80D4:
283	.80d3	8d 66 03	sta $0366	                sta vduv.cursorFlags
284	.80d6	20 90 94	jsr $9490	                jsr restoreFont32To255
285	.80d9	7a		ply		                ply             ; restore Y=what is this
286	.80da	a2 92		ldx #$92	                ldx #<timer0    ; reset everything, TIME included
287	.80dc	80 1b		bra $80f9	                bra initializePage2Loop

289	.80de					L80DF:
291	.80de	20 c9 9e	jsr $9ec9	                jsr L9E58
293	.80e1	a9 87		lda #$87	                lda #$87             ; Clear MODE bits from OSBYTE 255
294	.80e3	1c 8f 02	trb $028f	                trb startupOptions
295	.80e6	ad 55 03	lda $0355	                lda vduv.currentScreenMODE ; Get current screen MODE b0-b2
296	.80e9	29 07		and #$07	                and #$07
297	.80eb	0c 8f 02	tsb $028f	                tsb startupOptions           ; Copy to OSBYTE 255
298	.80ee	a9 10		lda #$10	                lda #STATE.isShadowMode ; Test shadow screen bit in VDU flags
299	.80f0	24 d0		bit $d0		                bit STATE                      ; Not shadow screen
300	.80f2	f0 05		beq $80f9	                beq initializePage2Loop
301	.80f4	a9 80		lda #$80	                lda #$80                     ; Set shadow screen bit in OSBYTE 255
302	.80f6	0c 8f 02	tsb $028f	                tsb startupOptions

304	.80f9					initializePage2Loop:
305	.80f9	ad 8d 02	lda $028d	                lda lastBREAKType
306	.80fc	d0 08		bne $8106	                bne clearPage2Byte           ;taken unless soft BREAK

308						                ; leave the ROM information table alone on a soft
309						                ; BREAK.
310	.80fe	e0 b1		cpx #$b1	                cpx #<romInformationTable+16
311	.8100	b0 04		bcs $8106	                bcs clearPage2Byte
312	.8102	e0 a1		cpx #$a1	                cpx #<romInformationTable
313	.8104	b0 0a		bcs $8110	                bcs nextPage2Byte
314	.8106					clearPage2Byte:
315	.8106	9e 00 02	stz $0200,x	                stz $0200,x
316	.8109	e0 cd		cpx #$cd	                cpx #$CD        ; how to derive this value??
317	.810b	90 03		bcc $8110	                bcc nextPage2Byte
318	.810d	de 00 02	dec $0200,x	                dec $0200,x                  ;initialize later values to $ff
319	.8110					nextPage2Byte:
320	.8110	e8		inx		                inx
321	.8111	d0 e6		bne $80f9	                bne initializePage2Loop

327						                ; Is this a bug? This will clear $CF, part of FS
328						                ; persistent workspace. Surely it should clear all of
329						                ; it or none of it!
330	.8113	a2 cf		ldx #$cf	                ldx #$CF
331	.8115					initializeZeroPageLoop:
332	.8115	74 00		stz $00,x	                stz $00,x
333	.8117	e8		inx		                inx
334	.8118	d0 fb		bne $8115	                bne initializeZeroPageLoop

340	.811a	ad 8d 02	lda $028d	                lda lastBREAKType
341	.811d	d0 20		bne $813f	                bne L813D                    ;taken if not soft BREAK

344	.811f	ad 46 02	lda $0246	                lda noignoreState
345	.8122	48		pha		                pha
347	.8123	ad 4b 02	lda $024b	                lda basicROMNumber
348	.8126	48		pha		                pha
349	.8127	ad 44 02	lda $0244	                lda oshwm
350	.812a	48		pha		                pha
351	.812b	ad 57 02	lda $0257	                lda spoolFileHandle
352	.812e	48		pha		                pha
353	.812f	ae 56 02	ldx $0256	                ldx execFileHandle

355	.8132					L8130:
356	.8132	b9 f8 e2	lda $e2f8,y	                lda defaultVectorTable-1,y
357	.8135	99 ff 01	sta $01ff,y	                sta vectors-1,y
358	.8138	88		dey		                dey
359	.8139	c0 21		cpy #$21	                cpy #EVENTV+1-vectors
360	.813b	b0 f5		bcs $8132	                bcs L8130

362	.813d	a0 12		ldy #$12	                ldy #FILEV-vectors

364	.813f					L813D:
365	.813f	b9 f8 e2	lda $e2f8,y	                lda defaultVectorTable-1,y
366	.8142	99 ff 01	sta $01ff,y	                sta vectors-1,y
367	.8145	88		dey		                dey
368	.8146	d0 f7		bne $813f	                bne L813D

370	.8148	ad 8d 02	lda $028d	                lda lastBREAKType
371	.814b	d0 19		bne $8166	                bne L8164       ; taken if power on or hard BREAK
372	.814d	8e 56 02	stx $0256	                stx execFileHandle
373	.8150	68		pla		                pla                          ;restore *SPOOL file handle
374	.8151	c9 04		cmp #$04	                cmp #$04                     ;is it a TAPE or ROM handle?
375	.8153	b0 02		bcs $8157	                bcs L8155                    ;taken if no - keep it

380	.8155	a9 00		lda #$00	                lda #$00          ;auto-close it if TAPE or ROM handle
382	.8157					L8155:
383	.8157	8d 57 02	sta $0257	                sta spoolFileHandle
384	.815a	68		pla		                pla
385	.815b	8d 44 02	sta $0244	                sta oshwm
386	.815e	68		pla		                pla
387	.815f	8d 4b 02	sta $024b	                sta basicROMNumber
389	.8162	68		pla		                pla
390	.8163	8d 46 02	sta $0246	                sta noignoreState

393	.8166					L8164:
395	.8166	a2 0b		ldx #$0b	                ldx #cmosBytesOffset+CMOSBytes.defaults1
399	.8168	20 3a 9e	jsr $9e3a	                jsr readRTCByte
404	.816b	a2 20		ldx #$20	                ldx #keyboardStatusByte.shiftLockDisengaged
405	.816d	0a		asl a		                asl a
406	.816e	0a		asl a		                asl a                        ;N=defaultCapsLockMask
407	.816f	30 07		bmi $8178	                bmi gotKeyboardStatusByte                    ;taken if defaultCapsLock
408	.8171	a2 30		ldx #$30	                ldx #keyboardStatusByte.shiftLockDisengaged|keyboardStatusByte.capsLockDisengaged
409	.8173	0a		asl a		                asl a                        ;N=defaultNoLockMask
410	.8174	30 02		bmi $8178	                bmi gotKeyboardStatusByte
411	.8176	a2 a0		ldx #$a0	                ldx #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
412	.8178					gotKeyboardStatusByte:
413	.8178	8e 5a 02	stx $025a	                stx keyboardStatusByte
417	.817b	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM
418	.817e	20 b8 f1	jsr $f1b8	                jsr resetKeyRepeat
420	.8181	ad 8d 02	lda $028d	                lda lastBREAKType
421	.8184	f0 16		beq $819c	                beq L8196
423	.8186	a2 0e		ldx #$0e	                ldx #cmosBytesOffset+CMOSBytes.printerIgnoreChar
427	.8188	20 3a 9e	jsr $9e3a	                jsr readRTCByte
432	.818b	8d 86 02	sta $0286	                sta printerIgnoreChar
440	.818e	20 de 8b	jsr $8bde	                jsr readUsePrinterIgnoreChar
442	.8191	6e 46 02	ror $0246	                ror noignoreState

445	.8194	a2 75		ldx #$75	                ldx #configureTable.print.metadata-configureTable
449	.8196	20 a1 8a	jsr $8aa1	                jsr readConfigurationByte

455	.8199	8d 85 02	sta $0285	                sta printerDriverType
456	.819c					L8196:

462	.819c	a2 19		ldx #$19	                ldx #configureTable.data.metadata-configureTable
466	.819e	20 a1 8a	jsr $8aa1	                jsr readConfigurationByte

472	.81a1	0a		asl a		                asl a                        ;
473	.81a2	0a		asl a		                asl a       ;shift into the control registerword field
474	.81a3	09 42		ora #$42	                ora #ACIA.control.rtsHighTXInterruptDisabled|ACIA.control.counterDivide64
475	.81a5	8d 50 02	sta $0250	                sta aciaControlRegister

481	.81a8	a2 12		ldx #$12	                ldx #CMOSBytes.joystick
482	.81aa	20 3a 9e	jsr $9e3a	                jsr readRTCByte
483						                ; It looks like the noWipeSWR bit won't cause a
484						                ; problem if set, but the MOS will never set itSWR on
485						                ; Compact hardware. So no need to clear it.
486	.81ad	8d 4e 02	sta $024e	                sta adcConversionType
492	.81b0	a2 ff		ldx #$ff	                ldx #$ff
493	.81b2					L81B2:
494	.81b2	20 4a ae	jsr $ae4a	                jsr resetACIA
495	.81b5	ad 08 fe	lda $fe08	                lda $fe08
496	.81b8	d0 0e		bne $81c8	                bne L81C8
497	.81ba	a9 20		lda #$20	                lda #$20
498	.81bc	8d 08 fe	sta $fe08	                sta $fe08
499	.81bf	ad 08 fe	lda $fe08	                lda $fe08
500	.81c2	29 f7		and #$f7	                and #$f7
501	.81c4	c9 82		cmp #$82	                cmp #$82
502	.81c6	f0 07		beq $81cf	                beq L81CF
503	.81c8					L81C8:
504	.81c8	c9 08		cmp #$08	                cmp #8
505	.81ca	f0 03		beq $81cf	                beq L81CF
506	.81cc	9c 78 02	stz $0278	                stz rs423InterruptMask
507	.81cf					L81CF:
508	.81cf	ca		dex		                dex
509	.81d0	d0 e0		bne $81b2	                bne L81B2
510	.81d2	20 0e ae	jsr $ae0e	                jsr resetACIAThenRewriteControlRegister
511	.81d5	e8		inx		                inx

515	.81d6	a9 7f		lda #$7f	                lda #$7F
516	.81d8					initializeVIAInterruptsLoop:
517	.81d8	9d 4d fe	sta $fe4d,x	                sta systemVIA.ifr,x
518	.81db	9d 6d fe	sta $fe6d,x	                sta userVIA.ifr,x
519	.81de	ca		dex		                dex
520	.81df	10 f7		bpl $81d8	                bpl initializeVIAInterruptsLoop

523						                ; Let through 1 IRQ.
524	.81e1	58		cli		                cli
525	.81e2	78		sei		                sei

527						                ; TEMPA was cleared above, so if bit 6 is set, there
528						                ; must have been an IRQ (as A=$7f).
529	.81e3	24 fc		bit $fc		                bit TEMPA
530	.81e5	50 03		bvc $81ea	                bvc +
531	.81e7	20 6b f7	jsr $f76b	                jsr call1MHzBusHook
532	.81ea					+

536	.81ea	a2 d2		ldx #$d2	                ldx #$80|VIA.irq.t1|VIA.irq.cb1|VIA.irq.ca1
540	.81ec	8e 4e fe	stx $fe4e	                stx systemVIA.ier

543	.81ef	a2 98		ldx #$98	                ldx #$80|VIA.irq.cb1|VIA.irq.cb2
544	.81f1	8e 6e fe	stx $fe6e	                stx userVIA.ier

547	.81f4	a2 04		ldx #$04	                ldx #VIA.pcr.cb2InputNegativeActiveEdge|VIA.pcr.cb1NegativeActiveEdge|VIA.pcr.ca2InputPositiveEdge|VIA.pcr.ca1NegativeActiveEdge
548	.81f6	8e 4c fe	stx $fe4c	                stx systemVIA.pcr
549	.81f9	a9 40		lda #$40	                lda #VIA.acr.t1Continuous|VIA.acr.t2Timer|VIA.acr.srDisabled|VIA.acr.pbLatchDisabled|VIA.acr.paLatchDisabled
550	.81fb	8d 4b fe	sta $fe4b	                sta systemVIA.acr
551	.81fe	a9 0e		lda #$0e	                lda #$0E
552	.8200	8d 46 fe	sta $fe46	                sta systemVIA.t1lL
553	.8203	8d 6c fe	sta $fe6c	                sta userVIA.pcr              ;VIA.pcr.cb2InputNegativeActiveEdge|VIA.pcr.cb1NegativeActiveEdge|VIA.pcr.ca2HighOutput|VIA.pcr.ca1NegativeActiveEdge
559	.8206	a9 27		lda #$27	                lda #$27
560	.8208	8d 47 fe	sta $fe47	                sta systemVIA.t1lH
561	.820b	8d 45 fe	sta $fe45	                sta systemVIA.t1cH

564	.820e	20 aa 83	jsr $83aa	                jsr clearAllSoundChannelBuffers

577	.8211	20 ac f7	jsr $f7ac	                jsr osbyte7A
579	.8214	86 ed		stx $ed		                stx firstKeyPressedInternal
580	.8216	a2 00		ldx #$00	                ldx #$00
582	.8218	8e 62 fe	stx $fe62	                stx userVIA.ddrb
584	.821b	20 a8 ea	jsr $eaa8	                jsr purgeBuffer

587	.821e	ad 82 02	lda $0282	                lda serialULARegister
588	.8221	29 7f		and #$7f	                and #$7F
589	.8223	20 25 ed	jsr $ed25	                jsr LEC89

592	.8226	a2 07		ldx #$07	                ldx #configureTable.baud.metadata-configureTable
596	.8228	20 a1 8a	jsr $8aa1	                jsr readConfigurationByte

602	.822b	48		pha		                pha
603	.822c	aa		tax		                tax
604	.822d	20 07 ed	jsr $ed07	                jsr osbyte08
605	.8230	fa		plx		                plx
606	.8231	a9 07		lda #$07	                lda #$07
607	.8233	20 09 ed	jsr $ed09	                jsr osbyte07

613	.8236	20 16 9e	jsr $9e16	                jsr readDefaults3
615	.8239	89 02		bit #$02	                bit #CMOSBytes.defaults3.loudMask
616	.823b	d0 05		bne $8242	                bne L8211
617	.823d	a9 f0		lda #$f0	                lda #$F0
618	.823f	8d 64 02	sta $0264	                sta bellSound
619	.8242					L8211:
621	.8242	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM

648	.8245	ae 84 02	ldx $0284	                ldx softKeyConsistencyFlag
649	.8248	f0 03		beq $824d	                beq checkResetType
650	.824a	20 d0 f1	jsr $f1d0	                jsr osbyte12
651	.824d					checkResetType:
652	.824d	ad 8d 02	lda $028d	                lda lastBREAKType
653	.8250	f0 03		beq $8255	                beq romsScanned                    ;taken if soft BREAK

660	.8252	4c ba e3	jmp $e3ba	                jmp scanROMs

663	.8255					romsScanned:
664	.8255	ad 8f 02	lda $028f	                lda startupOptions
665	.8258	20 99 c7	jsr $c799	                jsr setStartupMODE
666	.825b	ad 8d 02	lda $028d	                lda lastBREAKType ; $00=soft; $01=power-on; $02=hard
667	.825e	3a		dec a		                dec a             ; $ff=soft; $00=power-on; $01=hard
669	.825f	f0 03		beq $8264	                beq powerOnReset ; taken if power-on reset
670	.8261	4c 10 83	jmp $8310	                jmp softReset

675	.8264					powerOnReset:
677	.8264	a2 ff		ldx #$ff	                ldx #$ff
678	.8266	20 3b 9f	jsr $9f3b	                jsr i2cReadEEPROMByte
679	.8269	b0 10		bcs $827b	                bcs checkForNVRAMReset ; taken if read failed
680	.826b	98		tya		                tya
681	.826c	29 7f		and #$7f	                and #$7f
683	.826e	c9 32		cmp #$32	                cmp #$32
687	.8270	f0 09		beq $827b	                beq checkForNVRAMReset
688	.8272	a2 00		ldx #$00	                ldx #0
689	.8274	a0 00		ldy #$00	                ldy #0
690	.8276	20 0a 9f	jsr $9f0a	                jsr L9E99
691	.8279	80 40		bra $82bb	                bra resetCMOSRAM
693	.827b					checkForNVRAMReset:

696	.827b					checkForEraseKey:
697	.827b	a5 ed		lda $ed		                lda firstKeyPressedInternal
698	.827d	c9 59		cmp #$59	                cmp #key_delete
699	.827f	d0 36		bne $82b7	                bne checkForResetKey
700	.8281	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
701	>8284	16 07				                .byte 22,7
702	>8286	0d 0a				                .byte 13,10
703	>8288	43 6c 65 61 72 69 6e 67		                .text "Clearing options...please wait",0
	>8290	20 6f 70 74 69 6f 6e 73 2e 2e 2e 70 6c 65 61 73
	>82a0	65 20 77 61 69 74 00
704	.82a7	a2 ff		ldx #$ff	                ldx #$ff
705	.82a9					L82A9:
706	.82a9	da		phx		                phx
707	.82aa	a0 00		ldy #$00	                ldy #0
708	.82ac	20 69 9e	jsr $9e69	                jsr writeCMOSByte
709	.82af	fa		plx		                plx
710	.82b0	ca		dex		                dex
711	.82b1	e0 14		cpx #$14	                cpx #cmosBytesSize
712	.82b3	b0 f4		bcs $82a9	                bcs L82A9
713	.82b5	80 04		bra $82bb	                bra resetCMOSRAM

719	.82b7					checkForResetKey:
720	.82b7	c9 33		cmp #$33	                cmp #key_r
721	.82b9	d0 55		bne $8310	                bne softReset                    ;taken if R not pressed

759	.82bb					resetCMOSRAM:                                ;82bb in MOS 5.10
760	.82bb	a2 14		ldx #$14	                ldx #cmosBytesSize
761	.82bd					resetCMOSRAMLoop:
762	.82bd	da		phx		                phx
763	.82be	ca		dex		                dex
764	.82bf	20 51 9e	jsr $9e51	                jsr readDefaultCMOSByte
765	.82c2	20 69 9e	jsr $9e69	                jsr writeCMOSByte
766	.82c5	fa		plx		                plx
767	.82c6	ca		dex		                dex
768	.82c7	d0 f4		bne $82bd	                bne resetCMOSRAMLoop

776						                ; Put values in place for EEPROM size check. See code
777						                ; in readCMOSByte.
778	.82c9	a2 7f		ldx #$7f	                ldx #$7f
779	.82cb	20 3b 9f	jsr $9f3b	                jsr i2cReadEEPROMByte
780	.82ce	98		tya		                tya
781	.82cf	29 80		and #$80	                and #$80
783	.82d1	49 b2		eor #$b2	                eor #$b2
787	.82d3	a8		tay		                tay
788	.82d4	a2 ff		ldx #$ff	                ldx #$ff
789	.82d6	20 0a 9f	jsr $9f0a	                jsr L9E99

792	.82d9	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
794	>82dc	16 07				                .byte 22,7
796	>82de	0d 0a				                .text 13,10
800	>82e0	4f 70 74 69 6f 6e 73 20		                .text "Options reset"
	>82e8	72 65 73 65 74
802	>82ed	0d 0a 50 72 65 73 73 20		                .text 13,10,"Press break to continue"
	>82f5	62 72 65 61 6b 20 74 6f 20 63 6f 6e 74 69 6e 75
	>8305	65
803	>8306	0d 0a 00			                .text 13,10,0

806	.8309	a9 03		lda #$03	                lda #$03
807	.830b	8d 58 02	sta $0258	                sta breakAndESCAPEEffect
808	.830e					hang:
809	.830e	80 fe		bra $830e	                bra hang

811						;-------------------------------------------------------------------------

857						;-------------------------------------------------------------------------

859	.8310					softReset:
864	.8310	20 47 ee	jsr $ee47	                jsr selectHAZEL
870	.8313	9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
871	.8316	9c d5 df	stz $dfd5	                stz hazel.moveDestHandle
872	.8319	a0 ca		ldy #$ca	                ldy #$CA
876	.831b	20 a9 eb	jsr $eba9	                jsr insertCharacterIntoKeyboardBuffer
881	.831e	20 1f f4	jsr $f41f	                jsr osbyte247EntryPoint
883	.8321	ad 8d 02	lda $028d	                lda lastBREAKType
884	.8324	f0 03		beq $8329	                beq L829D
888	.8326	20 5d ee	jsr $ee5d	                jsr LEDD0
890	.8329					L829D:

:5	;******  Return to file: src/terminal.s65

160	.8329					continueSoftReset:
162	.8329					handleROMWorkspace:
163	.8329	ad 8d 02	lda $028d	                lda lastBREAKType ; Soft Break, don't ask about workspace
164	.832c	f0 27		beq $8355	                beq L82FC
165	.832e	a0 dc		ldy #$dc	                ldy #$DC                     ; Start high workspace at &DC00 and work downwards
166	.8330	a2 24		ldx #$24	                ldx #romServiceCallCountDynamicHAZELWorkspace ; Ask ROMs how much private high workspace required
167	.8332	20 ff ee	jsr $eeff	                jsr makeROMServiceCall   ;
168	.8335	a2 21		ldx #$21	                ldx #romServiceCallAbsoluteHAZELWorkspaceClaim ; Ask ROMs for maximum shared high workspace required
169	.8337	20 ff ee	jsr $eeff	                jsr makeROMServiceCall   ;
170	.833a	5a		phy		                phy                          ; Save top of shared workspace
171	.833b	a2 22		ldx #$22	                ldx #romServiceCallPrivateHAZELWorkspaceClam ; Ask ROMs for private high workspace required
172	.833d	20 ff ee	jsr $eeff	                jsr makeROMServiceCall   ;
173	.8340	a0 0e		ldy #$0e	                ldy #$0E                     ; Start low workspace at &0E00
174	.8342	a2 01		ldx #$01	                ldx #romServiceCallAbsoluteWorkspaceClaim ; Ask ROMs for maximum shared workspace
175	.8344	20 ff ee	jsr $eeff	                jsr makeROMServiceCall   ;
176	.8347	a2 02		ldx #$02	                ldx #romServiceCallPrivateWorkspaceClaim ; Ask ROMs for private workspace
177	.8349	20 ff ee	jsr $eeff	                jsr makeROMServiceCall   ;
178	.834c	8c 44 02	sty $0244	                sty oshwm                    ; Set OSHWM - default PAGE
179	.834f	7a		ply		                ply                          ; Get top of shared high workspace
180	.8350	a2 23		ldx #$23	                ldx #romServiceCallTopOfHAZELWorkspace ; Tell ROMs top of shared high workspace
181	.8352	20 ff ee	jsr $eeff	                jsr makeROMServiceCall   ;
182	.8355					L82FC:
183	.8355	a2 0b		ldx #$0b	                ldx #size(defaultFsInfoBlocks)
184	.8357					L82FE:
185	.8357	bd b4 83	lda $83b4,x	                lda defaultFsInfoBlocks-1,x                ; Copy initial FS info blocks for CFS, TAPE, ROM
186	.835a	9d 05 df	sta $df05,x	                sta hazel.fsInfoBlocks-1,x
187	.835d	ca		dex		                dex
188	.835e	d0 f7		bne $8357	                bne L82FE
189	.8360	64 f2		stz $f2		                stz $F2                      ; &F2/3=>FS Info Blocks
190	.8362	a9 df		lda #$df	                lda #>hazel.fsInfoBlocks
191	.8364	85 f3		sta $f3		                sta $F3
192						                ; Y=>end of FS Info Blocks
193	.8366	a0 11		ldy #$11	                ldy #<hazel.fsInfoBlocks+size(defaultFsInfoBlocks)
194	.8368	a2 25		ldx #$25	                ldx #romServiceCallRequestFSInfo
195	.836a	20 ff ee	jsr $eeff	                jsr makeROMServiceCall   ;
196	.836d	a9 00		lda #$00	                lda #$00                     ; Terminate FS Info blocks
197	.836f	91 f2		sta ($f2),y	                sta ($F2),y

199	.8371	ad 57 02	lda $0257	                lda spoolFileHandle ; Save Spool handle and disable Spooling
200	.8374	48		pha		                pha
201	.8375	9c 57 02	stz $0257	                stz spoolFileHandle
202	.8378	a2 fe		ldx #$fe	                ldx #romServiceCallTubeSystemPostInitialisation
206	.837a	ac 7a 02	ldy $027a	                ldy tubePresenceUnused
208	.837d	20 ff ee	jsr $eeff	                jsr makeROMServiceCall   ; Tube PostInit
209	.8380	2d 67 02	and $0267	                and startupMessageSuppressionStatus
210	.8383	10 14		bpl $8399	                bpl L8340

212						                ; use +$ff rather than -1 to avoid 64tass warning.
213						                ; Only the LSB is used.
214	.8385	a0 0f		ldy #$0f	                ldy #((startupMessages.acornMOS-(startupMessages&$ff00))+$ff)&$ff
215	.8387	20 7b e7	jsr $e77b	                jsr printStartupMessage
216	.838a	ad 8d 02	lda $028d	                lda lastBREAKType            ; Skip past if Soft Break
217	.838d	f0 05		beq $8394	                beq L833B
218	.838f	a0 1a		ldy #$1a	                ldy #((startupMessages.beep-(startupMessages&$ff00))-1)&$ff
219	.8391	20 7b e7	jsr $e77b	                jsr printStartupMessage
220	.8394					L833B:
221	.8394	a0 1f		ldy #$1f	                ldy #((startupMessages.twoNewlines-(startupMessages&$ff00))-1)&$ff
222	.8396	20 7b e7	jsr $e77b	                jsr printStartupMessage
223	.8399					L8340:
224	.8399	68		pla		                pla                          ; Restore Spool handle
225	.839a	8d 57 02	sta $0257	                sta spoolFileHandle
226	.839d	4c 35 e4	jmp $e435	                jmp LE40E                ;

228						;-------------------------------------------------------------------------

231	.83a0					L8363:
232	.83a0	a9 0f		lda #$0f	                lda #$0f
233	.83a2					L8365:
234	.83a2	3a		dec a		                dec a
235	.83a3	8d 40 fe	sta $fe40	                sta $fe40
236	.83a6	c9 09		cmp #$09	                cmp #9
237	.83a8	b0 f8		bcs $83a2	                bcs L8365
240	.83aa					clearAllSoundChannelBuffers:
241	.83aa	a2 08		ldx #$08	                ldx #8
242	.83ac					L836F:
243	.83ac	ca		dex		                dex
244	.83ad	20 f9 f4	jsr $f4f9	                jsr clearSoundChannelBuffer
245	.83b0	e0 04		cpx #$04	                cpx #4
246	.83b2	d0 f8		bne $83ac	                bne L836F
247	.83b4	60		rts		                rts

250						;-------------------------------------------------------------------------

252						; Default FS Info Blocks
253						; ======================
254	.83b5					defaultFsInfoBlocks: .block
265	>83b5	52 4f 4d 20 20 20 20 20		                .text "ROM     "
266	>83bd	03				                .byte $03
267	>83be	03				                .byte $03
268	>83bf	03				                .byte $03
269						                .endblock

271						;-------------------------------------------------------------------------
272						;
273						; MOS command table

275						mos_command .macro name,routine,byte1,byte2
292						                .endm

294	.83c0					mosCommandTable:
276						                ; Name of command, compared case-insensitively.
277	>83c0	43 41 54			                .text "CAT"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>83c3	f2				                .byte >callFSCV
168	>83c4	9b				                .byte <callFSCV

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>83c5	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>83c6	05				                .byte $05
276						                ; Name of command, compared case-insensitively.
277	>83c7	41 44 46 53			                .text "ADFS"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>83cb	85				                .byte >passStarCommandThrough
168	>83cc	ff				                .byte <passStarCommandThrough

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>83cd	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>83ce	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>83cf	41 50 50 45 4e 44		                .text "APPEND"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>83d5	92				                .byte >starAPPEND
168	>83d6	1e				                .byte <starAPPEND

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>83d7	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>83d8	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>83d9	42 41 53 49 43			                .text "BASIC"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>83de	85				                .byte >starBASIC
168	>83df	f5				                .byte <starBASIC

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>83e0	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>83e1	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>83e2	42 55 49 4c 44			                .text "BUILD"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>83e7	92				                .byte >starBUILD
168	>83e8	19				                .byte <starBUILD

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>83e9	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>83ea	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>83eb	43 4c 4f 53 45			                .text "CLOSE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>83f0	96				                .byte >starCLOSE
168	>83f1	7f				                .byte <starCLOSE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>83f2	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>83f3	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>83f4	43 4f 4e 46 49 47 55 52		                .text "CONFIGURE"
	>83fc	45

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>83fd	88				                .byte >starCONFIGUREOrStarSTATUS
168	>83fe	93				                .byte <starCONFIGUREOrStarSTATUS

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>83ff	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8400	80				                .byte $80
276						                ; Name of command, compared case-insensitively.
277	>8401	43 4f 44 45			                .text "CODE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8405	96				                .byte >starCommandThroughOSBYTE
168	>8406	00				                .byte <starCommandThroughOSBYTE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8407	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8408	88				                .byte $88
276						                ; Name of command, compared case-insensitively.
277	>8409	43 52 45 41 54 45		                .text "CREATE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>840f	95				                .byte >starCommandThroughOSFILE
168	>8410	31				                .byte <starCommandThroughOSFILE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8411	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8412	07				                .byte $07
276						                ; Name of command, compared case-insensitively.
277	>8413	44 55 4d 50			                .text "DUMP"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8417	91				                .byte >starDUMP
168	>8418	4c				                .byte <starDUMP

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8419	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>841a	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>841b	44 45 4c 45 54 45		                .text "DELETE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8421	96				                .byte >starDELETE
168	>8422	95				                .byte <starDELETE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8423	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8424	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>8425	45 58 45 43			                .text "EXEC"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8429	aa				                .byte >starEXEC
168	>842a	00				                .byte <starEXEC

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>842b	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>842c	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>842d	45 58				                .text "EX"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>842f	f2				                .byte >callFSCV
168	>8430	9b				                .byte <callFSCV

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8431	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8432	09				                .byte $09
276						                ; Name of command, compared case-insensitively.
277	>8433	46 58				                .text "FX"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8435	95				                .byte >starFX
168	>8436	fa				                .byte <starFX

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8437	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8438	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>8439	47 4f 49 4f			                .text "GOIO"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>843d	95				                .byte >starGOIO
168	>843e	16				                .byte <starGOIO

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>843f	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8440	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>8441	47 4f				                .text "GO"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8443	95				                .byte >starGO
168	>8444	0e				                .byte <starGO

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8445	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8446	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>8447	48 45 4c 50			                .text "HELP"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>844b	86				                .byte >starHELP
168	>844c	1a				                .byte <starHELP

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>844d	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>844e	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>844f	49 4e 46 4f			                .text "INFO"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8453	f2				                .byte >callFSCV
168	>8454	9b				                .byte <callFSCV

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8455	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8456	0a				                .byte $0A
276						                ; Name of command, compared case-insensitively.
277	>8457	49 47 4e 4f 52 45		                .text "IGNORE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>845d	96				                .byte >starIGNORE
168	>845e	8a				                .byte <starIGNORE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>845f	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8460	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>8461	49 4e 53 45 52 54		                .text "INSERT"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8467	87				                .byte >starINSERT
168	>8468	87				                .byte <starINSERT

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8469	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>846a	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>846b	4b 45 59			                .text "KEY"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>846e	97				                .byte >starKEY
168	>846f	13				                .byte <starKEY

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8470	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8471	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>8472	4c 4f 41 44			                .text "LOAD"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8476	95				                .byte >starLOAD
168	>8477	2f				                .byte <starLOAD

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8478	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8479	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>847a	4c 49 53 54			                .text "LIST"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>847e	90				                .byte >starLIST
168	>847f	ca				                .byte <starLIST

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8480	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8481	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>8482	4c 49 4e 45			                .text "LINE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8486	ec				                .byte >callUSERV
168	>8487	de				                .byte <callUSERV

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8488	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8489	01				                .byte $01
276						                ; Name of command, compared case-insensitively.
277	>848a	4c 49 42 46 53			                .text "LIBFS"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>848f	e9				                .byte >starLIBFS
168	>8490	26				                .byte <starLIBFS

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8491	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8492	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>8493	4d 4f 54 4f 52			                .text motorCommandString

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8498	ff				                .byte >rtsFFAA
168	>8499	aa				                .byte <rtsFFAA

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>849a	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>849b	89				                .byte $89
276						                ; Name of command, compared case-insensitively.
277	>849c	4d 4f 56 45			                .text "MOVE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84a0	92				                .byte >starMOVE
168	>84a1	cb				                .byte <starMOVE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84a2	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84a3	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>84a4	4f 50 54			                .text "OPT"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84a7	96				                .byte >starCommandThroughOSBYTE
168	>84a8	00				                .byte <starCommandThroughOSBYTE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84a9	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84aa	8b				                .byte $8B
276						                ; Name of command, compared case-insensitively.
277	>84ab	50 52 49 4e 54			                .text "PRINT"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84b0	90				                .byte >starPRINT
168	>84b1	c3				                .byte <starPRINT

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84b2	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84b3	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>84b4	52 55 4e			                .text "RUN"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84b7	f2				                .byte >callFSCV
168	>84b8	9b				                .byte <callFSCV

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84b9	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84ba	04				                .byte $04
276						                ; Name of command, compared case-insensitively.
277	>84bb	52 45 4d 4f 56 45		                .text "REMOVE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84c1	95				                .byte >starREMOVE
168	>84c2	8a				                .byte <starREMOVE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84c3	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84c4	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>84c5	52 4f 4d			                .text "ROM"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84c8	96				                .byte >starCommandThroughOSBYTE
168	>84c9	00				                .byte <starCommandThroughOSBYTE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84ca	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84cb	8d				                .byte $8D
276						                ; Name of command, compared case-insensitively.
277	>84cc	52 4f 4d 53			                .text "ROMS"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84d0	86				                .byte >starROMS
168	>84d1	f6				                .byte <starROMS

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84d2	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84d3	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>84d4	53 41 56 45			                .text "SAVE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84d8	95				                .byte >starCommandThroughOSFILE
168	>84d9	31				                .byte <starCommandThroughOSFILE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84da	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84db	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>84dc	53 48 41 44 4f 57		                .text "SHADOW"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84e2	96				                .byte >starSHADOW
168	>84e3	38				                .byte <starSHADOW

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84e4	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84e5	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>84e6	53 48 4f 57			                .text "SHOW"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84ea	96				                .byte >starSHOW
168	>84eb	9e				                .byte <starSHOW

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84ec	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84ed	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>84ee	53 48 55 54			                .text "SHUT"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84f2	f4				                .byte >starSHUT
168	>84f3	50				                .byte <starSHUT

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84f4	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84f5	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>84f6	53 50 4f 4f 4c			                .text "SPOOL"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>84fb	96				                .byte >starSPOOL
168	>84fc	4c				                .byte <starSPOOL

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>84fd	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>84fe	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>84ff	53 50 4f 4f 4c 4f 4e		                .text "SPOOLON"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8506	96				                .byte >starSPOOLON
168	>8507	35				                .byte <starSPOOLON

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8508	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8509	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>850a	53 52 44 41 54 41		                .text "SRDATA"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8510	8c				                .byte >starSRDATAOrStarSRROM
168	>8511	ea				                .byte <starSRDATAOrStarSRROM

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8512	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8513	a0				                .byte $a0
276						                ; Name of command, compared case-insensitively.
277	>8514	53 52 4c 4f 41 44		                .text "SRLOAD"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>851a	8e				                .byte >starSRLOADOrStarSRSAVE
168	>851b	07				                .byte <starSRLOADOrStarSRSAVE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>851c	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>851d	60				                .byte $60
276						                ; Name of command, compared case-insensitively.
277	>851e	53 52 52 45 41 44		                .text "SRREAD"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8524	8d				                .byte >starSRREADOrStarSRWRITE
168	>8525	bc				                .byte <starSRREADOrStarSRWRITE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8526	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8527	a0				                .byte $a0
276						                ; Name of command, compared case-insensitively.
277	>8528	53 52 52 4f 4d			                .text "SRROM"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>852d	8c				                .byte >starSRDATAOrStarSRROM
168	>852e	ea				                .byte <starSRDATAOrStarSRROM

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>852f	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8530	80				                .byte $80
276						                ; Name of command, compared case-insensitively.
277	>8531	53 52 53 41 56 45		                .text "SRSAVE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8537	8e				                .byte >starSRLOADOrStarSRSAVE
168	>8538	07				                .byte <starSRLOADOrStarSRSAVE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8539	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>853a	20				                .byte $20
276						                ; Name of command, compared case-insensitively.
277	>853b	53 52 57 52 49 54 45		                .text "SRWRITE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8542	8d				                .byte >starSRREADOrStarSRWRITE
168	>8543	bc				                .byte <starSRREADOrStarSRWRITE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8544	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8545	e0				                .byte $e0
276						                ; Name of command, compared case-insensitively.
277	>8546	53 54 41 54 55 53		                .text "STATUS"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>854c	88				                .byte >starCONFIGUREOrStarSTATUS
168	>854d	93				                .byte <starCONFIGUREOrStarSTATUS

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>854e	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>854f	c0				                .byte $c0
276						                ; Name of command, compared case-insensitively.
277	>8550	54 41 50 45			                .text tapeCommandString

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8554	ff				                .byte >rtsFFAA
168	>8555	aa				                .byte <rtsFFAA

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8556	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8557	8c				                .byte $8C
276						                ; Name of command, compared case-insensitively.
277	>8558	54 56				                .text "TV"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>855a	96				                .byte >starCommandThroughOSBYTE
168	>855b	00				                .byte <starCommandThroughOSBYTE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>855c	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>855d	90				                .byte $90
276						                ; Name of command, compared case-insensitively.
277	>855e	54 49 4d 45			                .text "TIME"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8562	87				                .byte >starTIME
168	>8563	ac				                .byte <starTIME

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8564	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8565	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>8566	54 59 50 45			                .text "TYPE"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>856a	90				                .byte >starTYPE
168	>856b	d5				                .byte <starTYPE

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>856c	80				                .byte $80

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>856d	00				                .byte $00
276						                ; Name of command, compared case-insensitively.
277	>856e	55 4e 50 4c 55 47		                .text "UNPLUG"

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8574	87				                .byte >starUNPLUG
168	>8575	8a				                .byte <starUNPLUG

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>8576	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>8577	ff				                .byte $FF
276						                ; Name of command, compared case-insensitively.
277	>8578					                .text ""

279						                ; Address of command routine, big-endian so that the
280						                ; first byte always has bit 7 set.
167:3	>8578	f2				                .byte >callFSCV
168	>8579	9b				                .byte <callFSCV

283:5						                ; If bit 7 set, reset the tempFS flag before
284						                ; starting.
285	>857a	00				                .byte $00

287						                ; If bit 7 set, update string input buffer address
288						                ; before starting.
289						                ;
290						                ; A is set to this value on entry to the routine.
291	>857b	03				                .byte $03
370	>857c	00				                .byte $00

372						;-------------------------------------------------------------------------
373						;
374						; Get string input buffer address tail according to table byte.
375						;
376						; Entry:
377						;
378						; oscliWorkspace.tablePtr; = pointer to table byte
379						; (stringInputBufferAddress),y = pointer to input
380						;
381						; Exit:
382						;
383						; A = table byte
384						;
385						; if table byte bit 7 set: Y/X points to command line tail
386	.857d					maybeGetStringInputBufferAddress:
387	.857d	b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr)
388	.857f	30 0c		bmi $858d	                bmi rts84FE
389	.8581					getStringInputBufferAddressWithYOffset:
390	.8581	98		tya		                tya
391	.8582					getStringInputBufferAddressWithAOffset:
392	.8582	18		clc		                clc
393	.8583	65 f2		adc $f2		                adc stringInputBufferAddress+0
394	.8585	aa		tax		                tax
395	.8586	a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
396	.8588	90 01		bcc $858b	                bcc +
397	.858a	c8		iny		                iny
398	.858b					+
399	.858b	b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr)
400	.858d					rts84FE:
401	.858d	60		rts		                rts

403						; Prepare OSCLI command line
404						; ==========================
405	.858e					oscli:
406	.858e	86 f2		stx $f2		                stx stringInputBufferAddress+0
407	.8590	84 f3		sty $f3		                sty stringInputBufferAddress+1
408	.8592	ad 00 df	lda $df00	                lda hazel.currentFS
409	.8595	20 c0 fa	jsr $fac0	                jsr selectFS
410	.8598	a9 08		lda #$08	                lda #fscStarCommand
411	.859a	20 9b f2	jsr $f29b	                jsr callFSCV
412	.859d	a0 ff		ldy #$ff	                ldy #$FF
413	.859f					L8510:
414	.859f	20 bd f3	jsr $f3bd	                jsr incAndSkipSpaces
415	.85a2	f0 e9		beq $858d	                beq rts84FE
416	.85a4	c9 2a		cmp #$2a	                cmp #'*'
417	.85a6	f0 f7		beq $859f	                beq L8510
418	.85a8	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
419	.85ab	f0 e0		beq $858d	                beq rts84FE
420	.85ad	c9 7c		cmp #$7c	                cmp #'|'
421	.85af	f0 dc		beq $858d	                beq rts84FE
422	.85b1	9c c6 df	stz $dfc6	                stz hazel.tempFSFlag
423	.85b4	c9 2d		cmp #$2d	                cmp #'-'
424	.85b6	d0 0c		bne $85c4	                bne L8535
425	.85b8	20 19 fa	jsr $fa19	                jsr parseFileNameFS
426	.85bb	20 c0 fa	jsr $fac0	                jsr selectFS
427	.85be	38		sec		                sec
428	.85bf	6e c6 df	ror $dfc6	                ror hazel.tempFSFlag
429	.85c2	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
430	.85c4					L8535:
431	.85c4	c9 2f		cmp #$2f	                cmp #'/'
432	.85c6	d0 09		bne $85d1	                bne L8542
433	.85c8	c8		iny		                iny
434	.85c9	20 81 85	jsr $8581	                jsr getStringInputBufferAddressWithYOffset
435	.85cc	a9 02		lda #$02	                lda #fscStarSlash
436	.85ce	4c 9b f2	jmp $f29b	                jmp callFSCV

438	.85d1					L8542:
442	.85d1	a9 c0		lda #$c0	                lda #<mosCommandTable
443	.85d3	85 b0		sta $b0		                sta oscliWorkspace.tablePtr+0
444	.85d5	a9 83		lda #$83	                lda #>mosCommandTable
445	.85d7	85 b1		sta $b1		                sta oscliWorkspace.tablePtr+1
449	.85d9	b8		clv		                clv
450	.85da	20 cc 8a	jsr $8acc	                jsr findCommand
451	.85dd	90 20		bcc $85ff	                bcc passStarCommandThrough

489	.85df					L8585:
490	.85df	48		pha		                pha
491	.85e0	20 0b 8b	jsr $8b0b	                jsr fetchCommandTableByte
492	.85e3	48		pha		                pha
493	.85e4	20 0b 8b	jsr $8b0b	                jsr fetchCommandTableByte
494	.85e7	30 03		bmi $85ec	                bmi L8592
495	.85e9	9c c6 df	stz $dfc6	                stz hazel.tempFSFlag
496	.85ec					L8592:
497	.85ec	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
498	.85ef	18		clc		                clc
499	.85f0	08		php		                php
500	.85f1	20 7d 85	jsr $857d	                jsr maybeGetStringInputBufferAddress
501	.85f4	40		rti		                rti

521						;-------------------------------------------------------------------------

523						; *BASIC
524						; ======
525	.85f5					starBASIC:
526	.85f5	ae 4b 02	ldx $024b	                ldx basicROMNumber           ; Get BASIC ROM number
527	.85f8	30 05		bmi $85ff	                bmi passStarCommandThrough ; If no BASIC ROM, jump to pass to ROMs and filing system
534	.85fa	a9 8e		lda #$8e	                lda #$8e
535	.85fc	4c f4 ff	jmp $fff4	                jmp OSBYTE

538						;-------------------------------------------------------------------------

540						; *ADFS - pass straight to ROMs/Filing System
541						; ===========================================
542	.85ff					passStarCommandThrough:
543	.85ff	2c c6 df	bit $dfc6	                bit hazel.tempFSFlag      ; Check filing system flag
544	.8602	30 0c		bmi $8610	                bmi L85C0                    ; If ... skip ROM service call
545	.8604	9c c6 df	stz $dfc6	                stz hazel.tempFSFlag      ; Clear filing system flag
546	.8607	a4 e6		ldy $e6		                ldy $E6
547	.8609	a2 04		ldx #$04	                ldx #romServiceCallUnrecognisedCommand
548	.860b	20 90 ee	jsr $ee90	                jsr osbyte8F    ; Service call 4 - Unknown command
550	.860e	f0 4d		beq $865d	                beq parseDone
554	.8610					L85C0:
555	.8610	a5 e6		lda $e6		                lda $E6
556	.8612	20 82 85	jsr $8582	                jsr getStringInputBufferAddressWithAOffset
557	.8615	a9 03		lda #$03	                lda #$03
558	.8617	4c 9b f2	jmp $f29b	                jmp callFSCV ; Pass to FSCV,3 - Unknown command

560	.861a					starHELP:
561	.861a	a2 09		ldx #$09	                ldx #romServiceCallHelp      ;
562	.861c	a5 d0		lda $d0		                lda STATE                    ;
563	.861e	48		pha		                pha                          ;save STATE
564	.861f	a9 0e		lda #$0e	                lda #14
565	.8621	20 ee ff	jsr $ffee	                jsr OSWRCH                   ; paged mode ON
566	.8624	20 ff ee	jsr $eeff	                jsr makeROMServiceCall   ;
567	.8627	a2 18		ldx #$18	                ldx #romServiceCallReserved  ;???
568	.8629	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
569	.862c	68		pla		                pla                          ;restore STATE
570	.862d	89 04		bit #$04	                bit #STATE.isPagedScrolling  ;was paged mode on originally?
571	.862f	d0 2c		bne $865d	                bne parseDone   ;taken if paged mode was originally on
572						                                ;(branch target is an arbitrary nearby
573						                                ;RTS)
574	.8631	a9 0f		lda #$0f	                lda #15         ;restore non-paged mode
575	.8633	4c ee ff	jmp $ffee	                jmp OSWRCH

577						;-------------------------------------------------------------------------
578						;
579						; Read a byte value (0-255) from a string. If the number has a '&'
580						; prefix, interpret it as hex.
581						;
582						; entry:
583						;
584						; (stringInputBufferAddress),y - string
585						;
586						; exit:
587						;
588						; X = result
589						; ?$e6 = result
590						; C=0 if error
591						; Z=1 if CR encountered
592						;
593	.8636					parseNumberFromString:
594	.8636	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
595	.8639	c9 26		cmp #$26	                cmp #'&'                     ; hex value incoming?
596	.863b	d0 21		bne $865e	                bne parseDecimal             ; taken if not hex value
597	.863d					parseHex:
598	.863d	c8		iny		                iny                          ; skip '&'
599	.863e	20 98 86	jsr $8698	                jsr readHexDigit             ; read first hex digit
600	.8641	90 53		bcc $8696	                bcc errorReadingString
601	.8643	85 e6		sta $e6		                sta $E6                      ; save first hex digit
602	.8645	20 98 86	jsr $8698	                jsr readHexDigit             ; read second hex digih
603	.8648	90 0e		bcc $8658	                bcc parsedValue         ; taken if not hex digit
604						                ; The first digit read was actually the high nybble,
605						                ; and the current digit read is therefore the low
606						                ; nybble.
607						                ;
608						                ; Shift saved digit 4 bits left.
609	.864a	a2 04		ldx #$04	                ldx #$04
610	.864c					-
611	.864c	06 e6		asl $e6		                asl $E6
612	.864e	ca		dex		                dex
613	.864f	d0 fb		bne $864c	                bne -
614	.8651	04 e6		tsb $e6		                tsb $E6                      ; insert low nybble
615	.8653	20 98 86	jsr $8698	                jsr readHexDigit             ; read third hex digit
616	.8656	b0 29		bcs $8681	                bcs errorReadingString2 ; 3+-digit hex values are not valid
617	.8658					parsedValue:
618	.8658	a6 e6		ldx $e6		                ldx $E6
619	.865a	c9 0d		cmp #$0d	                cmp #$0D
620	.865c	38		sec		                sec
621	.865d					parseDone:
622	.865d	60		rts		                rts

624	.865e					parseDecimal:
625	.865e	20 84 86	jsr $8684	                jsr readDigitFromString
626	.8661	90 33		bcc $8696	                bcc errorReadingString      ;branch taken if not digit
627	.8663					parseDecimalDigit:
628	.8663	85 e6		sta $e6		                sta $E6                     ;save current value
629	.8665	20 83 86	jsr $8683	                jsr readNextDigitFromString
630	.8668	90 ee		bcc $8658	                bcc parsedValue ;branch taken if not digit, meaning number
631						                                     ;parsed successfully
632	.866a	aa		tax		                tax                         ;X=digit

634						                ; calculate (value*4+value)*2 - i.e., value*10. Carry
635						                ; at any point indicates the value was greater than
636						                ; 255, and therefore an error.
637	.866b	a5 e6		lda $e6		                lda $E6                     ;value
638	.866d	0a		asl a		                asl a                       ;value*2
639	.866e	b0 26		bcs $8696	                bcs errorReadingString
640	.8670	0a		asl a		                asl a                       ;value*4
641	.8671	b0 23		bcs $8696	                bcs errorReadingString
642	.8673	65 e6		adc $e6		                adc $E6                     ;value*5
643	.8675	b0 1f		bcs $8696	                bcs errorReadingString
644	.8677	0a		asl a		                asl a                       ;value*10
645	.8678	b0 1c		bcs $8696	                bcs errorReadingString
646	.867a	85 e6		sta $e6		                sta $E6                      ;save value*10
647	.867c	8a		txa		                txa                          ;A=digit
648	.867d	65 e6		adc $e6		                adc $E6                      ;value*10+digit
649	.867f	90 e2		bcc $8663	                bcc parseDecimalDigit
650	.8681					errorReadingString2:
651	.8681	18		clc		                clc
652	.8682	60		rts		                rts

654	.8683					readNextDigitFromString:
655	.8683	c8		iny		                iny

657						; check if current string input byte is a digit.
658						;
659						; exit: C=1 if digit; C=0 if not digit
660	.8684					readDigitFromString:
661	.8684	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
662	.8686	c9 3a		cmp #$3a	                cmp #'9'+1
663	.8688	b0 0c		bcs $8696	                bcs errorReadingString       ;taken if not ASCII decimal digit
664	.868a	c9 30		cmp #$30	                cmp #'0'
665	.868c	90 08		bcc $8696	                bcc errorReadingString       ;taken if not ASCII decimal digit
666	.868e	29 0f		and #$0f	                and #$0F         ;convert ASCII decimaldigit to number
667	.8690	60		rts		                rts

669	.8691					L8641:
670	.8691	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
672	.8694	c9 0d		cmp #$0d	                cmp #$0D
674	.8696					errorReadingString:
675	.8696	18		clc		                clc
676	.8697	60		rts		                rts

678						;-------------------------------------------------------------------------
679						;
680						; Read a hex digit from a string
681						;
682						; entry:
683						;
684						; (stringInputBufferAddress),y = next byte to read
685						;
686						; exit:
687						;
688						; C=1 if ok: A = digit read
689						;
690						; C=0 if error: A = value read, Z=1 if CR encountered
691						;
692	.8698					readHexDigit:
693	.8698	20 84 86	jsr $8684	                jsr readDigitFromString
694	.869b	b0 0d		bcs $86aa	                bcs +                        ; branch taken if digit
695	.869d	29 df		and #$df	                and #$DF                     ; convert to upper case
696	.869f	c9 47		cmp #$47	                cmp #'F'+1
697	.86a1	b0 ee		bcs $8691	                bcs L8641    ; branch taken if not ASCII A-F hex digit
698	.86a3	c9 41		cmp #$41	                cmp #'A'
699	.86a5	90 ea		bcc $8691	                bcc L8641     ;branch taken if not ASCII A-F hex digit
700						                ; convert ASCII A-F hex digit to number.
701	.86a7	49 48		eor #$48	                eor #$48
702	.86a9	1a		inc a		                inc a
703	.86aa					+
704	.86aa	c8		iny		                iny
705	.86ab	60		rts		                rts

707						;-------------------------------------------------------------------------
708						;
709						; OSWORD 0 control block for *commands
710						; ====================================
711	.86ac					commandLineUIOSWORD0Parameters:
712	>86ac	00 dc				                .word hazel.commandLine      ; address
713	>86ae	f0				                .byte $F0			; max # chars
714	>86af	20				                .byte $20			; min ASCII char
715	>86b0	7e				                .byte $7E			; max ASCII char

717						;-------------------------------------------------------------------------

719	.86b1					commandLineUI:
720	.86b1	a9 dd		lda #$dd	                lda #<commandLineUIBRKHandler
721	.86b3	8d 02 02	sta $0202	                sta BRKV+0
722	.86b6	a9 86		lda #$86	                lda #>commandLineUIBRKHandler
723	.86b8	8d 03 02	sta $0203	                sta BRKV+1
724	.86bb	a9 1f		lda #$1f	                lda #$10|terminalROM         ;????
725	.86bd	8d 8c 02	sta $028c	                sta currentLanguageROM
726	.86c0					commandLineUILoop:
727	.86c0	a2 ff		ldx #$ff	                ldx #$FF
728	.86c2	9a		txs		                txs
729	.86c3	58		cli		                cli
730	.86c4	20 47 ee	jsr $ee47	                jsr selectHAZEL
731	.86c7	a9 2a		lda #$2a	                lda #'*'
732	.86c9	20 ee ff	jsr $ffee	                jsr OSWRCH
733	.86cc	20 ed 86	jsr $86ed	                jsr readCommandLine
734	.86cf	90 03		bcc $86d4	                bcc +                     ;taken if ESCAPE not pressed
735	.86d1	4c d3 ac	jmp $acd3	                jmp escapeError
736	.86d4					+
737	.86d4	a2 00		ldx #$00	                ldx #<hazel.commandLine
738	.86d6	a0 dc		ldy #$dc	                ldy #>hazel.commandLine
739	.86d8	20 f7 ff	jsr $fff7	                jsr OSCLI
740	.86db	80 e3		bra $86c0	                bra commandLineUILoop

742	.86dd					commandLineUIBRKHandler:
743	.86dd	20 e7 ff	jsr $ffe7	                jsr OSNEWL
744	.86e0	a0 00		ldy #$00	                ldy #$00
745	.86e2	20 81 e7	jsr $e781	                jsr printBRKMessage
746	.86e5	20 e7 ff	jsr $ffe7	                jsr OSNEWL
747	.86e8	80 c7		bra $86b1	                bra commandLineUI

749	.86ea					badCommandError869A:
750	.86ea	4c 60 fb	jmp $fb60	                jmp badCommandError

752	.86ed					readCommandLine:
753	.86ed	a9 00		lda #$00	                lda #$00
754	.86ef	a2 ac		ldx #$ac	                ldx #<commandLineUIOSWORD0Parameters
755	.86f1	a0 86		ldy #$86	                ldy #>commandLineUIOSWORD0Parameters
756	.86f3	4c f1 ff	jmp $fff1	                jmp OSWORD

758						;-------------------------------------------------------------------------
759						;
760						; *ROMS [MasRef C.5-10]
761						;
762	.86f6					starROMS: .proc
763	.86f6	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
764	.86f9	d0 ef		bne $86ea	                bne badCommandError869A
765	.86fb	a0 0f		ldy #$0f	                ldy #$0F
766	.86fd					printROMsLoop:
775	.86fd	98		tya		                tya
776	.86fe	aa		tax		                tax
777	.86ff	5a		phy		                phy
778	.8700	20 bd f8	jsr $f8bd	                jsr isBankROM
779	.8703	b0 0a		bcs $870f	                bcs L86D2
780	.8705	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
781	>8708	52 4f 4d 20 00			                .text "ROM ",0
782	.870d	80 08		bra $8717	                bra L86DA
783	.870f					L86D2:
784	.870f	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
785	>8712	52 41 4d 20 00			                .text "RAM ",0
786	.8717					L86DA:
787	.8717	7a		ply		                ply
788	.8718	98		tya		                tya
790	.8719	20 b5 ac	jsr $acb5	                jsr printHexDigit            ;print ROM slot
791	.871c	20 f3 a3	jsr $a3f3	                jsr printSpace
792	.871f	a9 09		lda #$09	                lda #<sidewaysROMName
793	.8721	85 f6		sta $f6		                sta $F6
794	.8723	a9 80		lda #$80	                lda #>sidewaysROMName
795	.8725	85 f7		sta $f7		                sta $F7
799	.8727	20 a0 e5	jsr $e5a0	                jsr isROMValidThenSelectTerminalROM
803	.872a	90 49		bcc $8775	                bcc invalidROM
805	.872c	b9 a1 02	lda $02a1,y	                lda romInformationTable,y
806	.872f	3a		dec a		                dec a
807	.8730	f0 43		beq $8775	                beq invalidROM
809	.8732					printROMNameLoop:
810	.8732	20 d9 f4	jsr $f4d9	                jsr osrdscEntryPoint     ;read name byte
811	.8735	c9 20		cmp #$20	                cmp #' '
812	.8737	90 0f		bcc $8748	                bcc printROMVersion ;taken if non-printable char, including the terminating 0
813	.8739	c9 7f		cmp #$7f	                cmp #127
814	.873b	b0 38		bcs $8775	                bcs invalidROM  ;taken if bad (bit 7 set) char in name
815	.873d	20 ee ff	jsr $ffee	                jsr OSWRCH
816	.8740	e6 f6		inc $f6		                inc $F6
817	.8742	24 f6		bit $f6		                bit $F6
818	.8744	50 ec		bvc $8732	                bvc printROMNameLoop         ;taken if address<$8040
819	.8746	80 2d		bra $8775	                bra invalidROM               ;taken if name too long

821	.8748					printROMVersion:
822	.8748	aa		tax		                tax               ;Z=1 if final char was the expected 0
823	.8749	d0 2a		bne $8775	                bne invalidROM    ;taken if bad (control) char in name
824	.874b	a9 08		lda #$08	                lda #<sidewaysROMVersion
825	.874d	85 f6		sta $f6		                sta $F6
826	.874f	a9 80		lda #$80	                lda #>sidewaysROMVersion
827	.8751	85 f7		sta $f7		                sta $F7
828	.8753	20 d9 f4	jsr $f4d9	                jsr osrdscEntryPoint
829	.8756	20 a7 ac	jsr $aca7	                jsr printSpaceThenPrintHexByte
830	.8759					printInsertionStatus:
831	.8759	5a		phy		                phy
838	.875a	20 7c 87	jsr $877c	                jsr L873F
840	.875d	d0 0e		bne $876d	                bne +
841	.875f	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
842	>8762	20 75 6e 70 6c 75 67 67		                .text " unplugged",0
	>876a	65 64 00
848	.876d					+
855	.876d	7a		ply		                ply
856	.876e	20 e7 ff	jsr $ffe7	                jsr OSNEWL
857	.8771	88		dey		                dey
858	.8772	10 89		bpl $86fd	                bpl printROMsLoop
859	.8774	60		rts		                rts

861	.8775					invalidROM:
862	.8775	a9 3f		lda #$3f	                lda #'?'
863	.8777	20 ee ff	jsr $ffee	                jsr OSWRCH
864	.877a	80 dd		bra $8759	                bra printInsertionStatus

881						                .endproc

883						;-------------------------------------------------------------------------

886	.877c					L873F:
887	.877c	20 e6 ea	jsr $eae6	                jsr getROMInsertedFlagRTCAddressAndMask
888	.877f	85 b0		sta $b0		                sta starROMSWorkspace.insertedFlagMask
889	.8781	20 3a 9e	jsr $9e3a	                jsr readRTCByte
890	.8784	25 b0		and $b0		                and starROMSWorkspace.insertedFlagMask
891	.8786	60		rts		                rts

894						;-------------------------------------------------------------------------
895						;
896						; *INSERT [MasRef C.5-8]
897						;
898	.8787					starINSERT:
899	.8787	38		sec		                sec
900	.8788	80 01		bra $878b	                bra starINSERTOrStarUNPLUG

902						;-------------------------------------------------------------------------
903						;
904						; *UNPLUG [MasRef C.5-13]
905						;
906	.878a					starUNPLUG:
907	.878a	18		clc		                clc
908	.878b					starINSERTOrStarUNPLUG:
909	.878b	08		php		                php
910	.878c	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
911	.878f	20 90 89	jsr $8990	                jsr parseSingle4BitNumberFromCommandLine
912	.8792	a8		tay		                tay                          ;Y=ROM number
913	.8793	20 e6 ea	jsr $eae6	                jsr getROMInsertedFlagRTCAddressAndMask
914	.8796	48		pha		                pha
915	.8797	20 3a 9e	jsr $9e3a	                jsr readRTCByte
916	.879a	84 b0		sty $b0		                sty starROMSWorkspace.insertedFlagMask
917	.879c	68		pla		                pla
918	.879d	28		plp		                plp
919	.879e	90 04		bcc $87a4	                bcc unplug                   ;taken if it's *UNPLUG

921						                ; it's *INSERT
922	.87a0	05 b0		ora $b0		                ora starROMSWorkspace.insertedFlagMask
923	.87a2	80 04		bra $87a8	                bra +
924	.87a4					unplug:
925	.87a4	49 ff		eor #$ff	                eor #$FF
926	.87a6	25 b0		and $b0		                and starROMSWorkspace.insertedFlagMask
927	.87a8					+
928	.87a8	a8		tay		                tay
929	.87a9	4c 73 9e	jmp $9e73	                jmp writeRTCByte

931						;-------------------------------------------------------------------------
932						;
933						; *TIME [MasRef C.5-12]
934						;
935	.87ac					starTIME:
936	.87ac	9c 00 dc	stz $dc00	                stz hazel.commandLine
937	.87af	a2 00		ldx #$00	                ldx #<hazel.commandLine
938	.87b1	a0 dc		ldy #$dc	                ldy #>hazel.commandLine
939	.87b3	a9 0e		lda #$0e	                lda #$0E
940	.87b5	20 f1 ff	jsr $fff1	                jsr OSWORD
941	.87b8	a2 e7		ldx #$e7	                ldx #256-size(ClockStringFormat)
942	.87ba					L8752:
943	.87ba	bd 19 db	lda $db19,x	                lda hazel.commandLine-(256-size(ClockStringFormat)),x
944	.87bd	20 e3 ff	jsr $ffe3	                jsr OSASCI
945	.87c0	e8		inx		                inx
946	.87c1	d0 f7		bne $87ba	                bne L8752
947	.87c3	60		rts		                rts

949						;-------------------------------------------------------------------------

965						                .include "configure_table_driven.s65"

:7	;******  Processing file: src/configure_table_driven.s65

1						Sbyte2: .macro value,value350
7						                .endmacro

9						                ; Metadata layout

11						                ; +0

13						                ;   7   6   5   4   3   2   1   0
14						                ; +---+---+---+---+---+---+---+---+
15						                ; |X  |V0 |MaskCount  |Value      |
16						                ; +---+---+---+---+---+---+---+---+

18						                ; X is unused - it's generally set in the configure
19						                ; table, so that the names can be terminated by a byte
20						                ; with bit 7 set.
21						                ;
22						                ; If V0 is clear, this field is actually the address
23						                ; of a routine.
24						                ;
25						                ; Value is the value for the bitfield when this option
26						                ; is in effect.
27						                ;
28						                ; MaskCount
29						                ;

31						                ; +1

33						                ;   7   6   5   4   3   2   1   0
34						                ; +---+---+---+---+---+---+---+---+
35						                ; |N1 |RTCByteIndex   |ShiftCount |
36						                ; +---+---+---+---+---+---+---+---+
37						                ;
38						                ; N1 is tested when printing stuff. Search for "N1 set"

40						                ; The RTC byte indexes in the table are actually
41						                ; offset.
48						                ; The possible range is 5-20.
49	=5					metadataRTCByteIndexOffset=cmosBytesOffset+CMOSBytes.defaultROMs

52						                ; Entry conditions to the routine:
53						                ;
54						                ; V=1 to print value then newline

56						                ; C=1 to print help string

58						                ; Z=1 to reset value (not sure what the conditions are
59						                ; for this)
60						itemWithAddress: .macro name,addr
65						                .endmacro

67						countLS0s: .function value
87						                .endfunction n

89						;-------------------------------------------------------------------------

91						itemMaskInfo: .macro value
97						                .endmacro

99						;-------------------------------------------------------------------------

101						itemMetadata: .macro topMask,rtcByteIndex,mask,matchValue,n1
118						                .endmacro

120						itemWithMetadata: .macro name,rtcByteIndex,mask,matchValue,n1
124						                .endmacro

126						;-------------------------------------------------------------------------

128	.87c4					configureTable: .block
61	>87c4	2e				                .text "."
62	.87c5					metadata:
167:3	>87c5	89				                .byte >printConfigureOrStatusHeader-1
168	>87c6	f9				                .byte <printConfigureOrStatusHeader-1
130:7	.87c7					baud:
121	>87c7	42 61 75 64			                .text ("Baud")
122	.87cb					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.87cb					info:
92	=2					shift=countLS0s(((CMOSBytes.defaults2.serialBaudRateIndexMask<<CMOSBytes.defaults2.serialBaudRateIndexShift)))
93	=7					unshiftedMask=(((CMOSBytes.defaults2.serialBaudRateIndexMask<<CMOSBytes.defaults2.serialBaudRateIndexShift)))>>shift
95	=3					maskWidth=countLS0s(~unshiftedMask)

116	>87cb	d0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>87cc	d2				                .byte (((true))?$80:$00)|(((CMOSBytes.defaults2)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
131	.87cd					boot:
121	>87cd	42 6f 6f 74			                .text ("Boot")
122	.87d1					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.87d1					info:
92	=4					shift=countLS0s(((CMOSBytes.defaults3.autoBootMask)))
93	=1					unshiftedMask=(((CMOSBytes.defaults3.autoBootMask)))>>shift
95	=1					maskWidth=countLS0s(~unshiftedMask)

116	>87d1	c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
117	>87d2	5c				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
121	>87d3	43 61 70 73			                .text ("Caps")
122	.87d7					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.87d7					info:
92	=3					shift=countLS0s((((CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask))))
93	=7					unshiftedMask=((((CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask))))>>shift
95	=3					maskWidth=countLS0s(~unshiftedMask)

116	>87d7	d4				                .byte ($c0)|((info.maskWidth-1)<<3)|((4))
117	>87d8	33				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
136	.87d9					data:
121	>87d9	44 61 74 61			                .text ("Data")
122	.87dd					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.87dd					info:
92	=5					shift=countLS0s(((CMOSBytes.defaults3.serialDataFormatMask<<CMOSBytes.defaults3.serialDataFormatShift)))
93	=7					unshiftedMask=(((CMOSBytes.defaults3.serialDataFormatMask<<CMOSBytes.defaults3.serialDataFormatShift)))>>shift
95	=3					maskWidth=countLS0s(~unshiftedMask)

116	>87dd	d0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>87de	dd				                .byte (((true))?$80:$00)|(((CMOSBytes.defaults3)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
121	>87df	44 65 6c 61 79			                .text ("Delay")
122	.87e4					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.87e4					info:
92	=0					shift=countLS0s((($ff)))
93	=$ff					unshiftedMask=((($ff)))>>shift
95	=8					maskWidth=countLS0s(~unshiftedMask)

116	>87e4	f8				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>87e5	b8				                .byte (((true))?$80:$00)|(((CMOSBytes.keyboardAutoRepeatDelay)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
138	.87e6					dir:
121	>87e6	44 69 72			                .text ("Dir")
122	.87e9					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.87e9					info:
92	=6					shift=countLS0s(((CMOSBytes.defaults1.adfsLoadDirMask)))
93	=1					unshiftedMask=(((CMOSBytes.defaults1.adfsLoadDirMask)))>>shift
95	=1					maskWidth=countLS0s(~unshiftedMask)

116	>87e9	c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>87ea	36				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
139	=$87e8					lastDirChar=dir.metadata-1
121	>87eb	46 64 72 69 76 65		                .text ("Fdrive")
122	.87f1					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.87f1					info:
92	=0					shift=countLS0s(((CMOSBytes.defaults1.fdriveMask)))
93	=7					unshiftedMask=(((CMOSBytes.defaults1.fdriveMask)))>>shift
95	=3					maskWidth=countLS0s(~unshiftedMask)

116	>87f1	d0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>87f2	b0				                .byte (((true))?$80:$00)|(((CMOSBytes.defaults1)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
145	.87f3					file:
121	>87f3	46 69 6c 65			                .text ("File")
122	.87f7					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.87f7					info:
92	=0					shift=countLS0s((($f<<CMOSBytes.defaultROMs.fsShift)))
93	=$f					unshiftedMask=((($f<<CMOSBytes.defaultROMs.fsShift)))>>shift
95	=4					maskWidth=countLS0s(~unshiftedMask)

116	>87f7	d8				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>87f8	80				                .byte (((true))?$80:$00)|(((CMOSBytes.defaultROMs)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
152	.87f9					ignore:
61	>87f9	49 67 6e 6f 72 65		                .text "Ignore"
62	.87ff					metadata:
167:3	>87ff	89				                .byte >handlePrinterIgnoreChar-1
168	>8800	4f				                .byte <handlePrinterIgnoreChar-1
153:7						                .if includeTubeSupport
157	.8801					lang:
121	>8801	4c 61 6e 67			                .text ("Lang")
122	.8805					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8805					info:
92	=4					shift=countLS0s((($f<<CMOSBytes.defaultROMs.languageShift)))
93	=$f					unshiftedMask=((($f<<CMOSBytes.defaultROMs.languageShift)))>>shift
95	=4					maskWidth=countLS0s(~unshiftedMask)

116	>8805	d8				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>8806	84				                .byte (((true))?$80:$00)|(((CMOSBytes.defaultROMs)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
121	>8807	4c 6f 75 64			                .text ("Loud")
122	.880b					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.880b					info:
92	=1					shift=countLS0s(((CMOSBytes.defaults3.loudMask)))
93	=1					unshiftedMask=(((CMOSBytes.defaults3.loudMask)))>>shift
95	=1					maskWidth=countLS0s(~unshiftedMask)

116	>880b	c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
117	>880c	59				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
159	.880d					mode:
121	>880d	4d 6f 64 65			                .text ("Mode")
122	.8811					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8811					info:
92	=0					shift=countLS0s(((CMOSBytes.defaults0.modeMask|CMOSBytes.defaults0.shadowMask)))
93	=15					unshiftedMask=(((CMOSBytes.defaults0.modeMask|CMOSBytes.defaults0.shadowMask)))>>shift
95	=4					maskWidth=countLS0s(~unshiftedMask)

116	>8811	d8				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>8812	a8				                .byte (((true))?$80:$00)|(((CMOSBytes.defaults0)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
121	>8813	4e 6f 42 6f 6f 74		                .text ("NoBoot")
122	.8819					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8819					info:
92	=4					shift=countLS0s(((CMOSBytes.defaults3.autoBootMask)))
93	=1					unshiftedMask=(((CMOSBytes.defaults3.autoBootMask)))>>shift
95	=1					maskWidth=countLS0s(~unshiftedMask)

116	>8819	c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>881a	5c				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
121	>881b	4e 6f 43 61 70 73		                .text ("NoCaps")
122	.8821					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8821					info:
92	=3					shift=countLS0s(((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)))
93	=7					unshiftedMask=(((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)))>>shift
95	=3					maskWidth=countLS0s(~unshiftedMask)

116	>8821	d2				                .byte ($c0)|((info.maskWidth-1)<<3)|((2))
117	>8822	33				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
162	.8823					noDir:
121	>8823	4e 6f 44 69 72			                .text ("NoDir")
122	.8828					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8828					info:
92	=6					shift=countLS0s(((CMOSBytes.defaults1.adfsLoadDirMask)))
93	=1					unshiftedMask=(((CMOSBytes.defaults1.adfsLoadDirMask)))>>shift
95	=1					maskWidth=countLS0s(~unshiftedMask)

116	>8828	c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
117	>8829	36				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
163	=$8827					lastNoDirChar:=noDir.metadata-1
121	>882a	4e 6f 53 63 72 6f 6c 6c		                .text ("NoScroll")
122	.8832					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8832					info:
92	=3					shift=countLS0s(((CMOSBytes.defaults3.protectedScrollingMask)))
93	=1					unshiftedMask=(((CMOSBytes.defaults3.protectedScrollingMask)))>>shift
95	=1					maskWidth=countLS0s(~unshiftedMask)

116	>8832	c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
117	>8833	5b				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
171	.8834					print:
121	>8834	50 72 69 6e 74			                .text ("Print")
122	.8839					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8839					info:
92	=5					shift=countLS0s(((CMOSBytes.defaults2.fx5SettingMask<<CMOSBytes.defaults2.fx5SettingShift)))
93	=7					unshiftedMask=(((CMOSBytes.defaults2.fx5SettingMask<<CMOSBytes.defaults2.fx5SettingShift)))>>shift
95	=3					maskWidth=countLS0s(~unshiftedMask)

116	>8839	d0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>883a	d5				                .byte (((true))?$80:$00)|(((CMOSBytes.defaults2)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
121	>883b	51 75 69 65 74			                .text ("Quiet")
122	.8840					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8840					info:
92	=1					shift=countLS0s(((CMOSBytes.defaults3.loudMask)))
93	=1					unshiftedMask=(((CMOSBytes.defaults3.loudMask)))>>shift
95	=1					maskWidth=countLS0s(~unshiftedMask)

116	>8840	c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>8841	59				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
121	>8842	52 65 70 65 61 74		                .text ("Repeat")
122	.8848					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8848					info:
92	=0					shift=countLS0s((($ff)))
93	=$ff					unshiftedMask=((($ff)))>>shift
95	=8					maskWidth=countLS0s(~unshiftedMask)

116	>8848	f8				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>8849	c0				                .byte (((true))?$80:$00)|(((CMOSBytes.keyboardAutoRepeatRate)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
121	>884a	53 63 72 6f 6c 6c		                .text ("Scroll")
122	.8850					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8850					info:
92	=3					shift=countLS0s(((CMOSBytes.defaults3.protectedScrollingMask)))
93	=1					unshiftedMask=(((CMOSBytes.defaults3.protectedScrollingMask)))>>shift
95	=1					maskWidth=countLS0s(~unshiftedMask)

116	>8850	c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>8851	5b				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults3)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
175	.8852					shCaps:
121	>8852	53 68 43 61 70 73		                .text ("ShCaps")
122	.8858					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8858					info:
92	=3					shift=countLS0s(((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)))
93	=7					unshiftedMask=(((CMOSBytes.defaults1.shiftLockMask|CMOSBytes.defaults1.noLockMask|CMOSBytes.defaults1.capsLockMask)))>>shift
95	=3					maskWidth=countLS0s(~unshiftedMask)

116	>8858	d1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
117	>8859	33				                .byte (((false))?$80:$00)|(((CMOSBytes.defaults1)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
176	=$8853					lastShChar=shCaps+1
121	>885a	50 72 6f 70 6f 72 74 69		                .text ("Proportional")
	>8862	6f 6e 61 6c
122	.8866					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8866					info:
92	=5					shift=countLS0s(((CMOSBytes.joystick.isSwitchedMask)))
93	=1					unshiftedMask=(((CMOSBytes.joystick.isSwitchedMask)))>>shift
95	=1					maskWidth=countLS0s(~unshiftedMask)

116	>8866	c0				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>8867	6d				                .byte (((false))?$80:$00)|(((CMOSBytes.joystick)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
121	>8868	53 77 69 74 63 68 65 64		                .text ("Switched")
122	.8870					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8870					info:
92	=5					shift=countLS0s(((CMOSBytes.joystick.isSwitchedMask)))
93	=1					unshiftedMask=(((CMOSBytes.joystick.isSwitchedMask)))>>shift
95	=1					maskWidth=countLS0s(~unshiftedMask)

116	>8870	c1				                .byte ($c0)|((info.maskWidth-1)<<3)|((1))
117	>8871	6d				                .byte (((false))?$80:$00)|(((CMOSBytes.joystick)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
121	>8872	53 74 69 63 6b			                .text ("Stick")
122	.8877					metadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8877					info:
92	=0					shift=countLS0s(((CMOSBytes.joystick.stickMask)))
93	=$f					unshiftedMask=(((CMOSBytes.joystick.stickMask)))>>shift
95	=4					maskWidth=countLS0s(~unshiftedMask)

116	>8877	d8				                .byte ($c0)|((info.maskWidth-1)<<3)|((0))
117	>8878	e8				                .byte (((true))?$80:$00)|(((CMOSBytes.joystick)-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
61	>8879	54 56				                .text "TV"
62	.887b					metadata:
167:3	>887b	89				                .byte >handleTV-1
168	>887c	a1				                .byte <handleTV-1
193:7						                .if refreshVersion&&version==350
196						                ; Terminator for data-driven table
197	>887d	00				                .byte 0

199						                ; Metadata entries referred to by routines start here.
200						                ; These aren't associated with any name; code loads
201						                ; the offset so that it can reuse the generic metadata
202						                ; handling routines.
203	.887e					printerIgnoreCharMetadata:
207						                ; This must be a bug, surely? The mask looks wrong.
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.887e					info:
92	=1					shift=countLS0s((3<<1))
93	=3					unshiftedMask=((3<<1))>>shift
95	=2					maskWidth=countLS0s(~unshiftedMask)

116	>887e	08				                .byte ($00)|((info.maskWidth-1)<<3)|(0)
117	>887f	51				                .byte ((false)?$80:$00)|((CMOSBytes.defaults2-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift
210	.8880					tvMetadata:
102						                ; constants need some rationalisation here. The byte
103						                ; index is a 4-bit field.

107	=5					indexOffset=metadataRTCByteIndexOffset

114	.8880					info:
92	=4					shift=countLS0s((CMOSBytes.defaults0.interlaceMask|(CMOSBytes.defaults0.tvMask<<CMOSBytes.defaults0.tvShift)))
93	=15					unshiftedMask=((CMOSBytes.defaults0.interlaceMask|(CMOSBytes.defaults0.tvMask<<CMOSBytes.defaults0.tvShift)))>>shift
95	=4					maskWidth=countLS0s(~unshiftedMask)

116	>8880	18				                .byte ($00)|((info.maskWidth-1)<<3)|(0)
117	>8881	2c				                .byte ((false)?$80:$00)|((CMOSBytes.defaults0-(metadataRTCByteIndexOffset-cmosBytesOffset))<<3)|info.shift

223						                ; Text snippets.
224	.8882					ectory:
225	>8882	65 63 74 6f 72 79 ff		                .text "ectory",$ff
230	.8889					ift:
231	>8889	69 66 74 ff			                .text "ift",$ff

233						                ; Configure table ends. TODO: rearrange .endblock so
234						                ; this is clearer - and follow through

236						;-------------------------------------------------------------------------

238	.888d					textSnippetInsertPointOffsets:
239	>888d	24				                .text lastDirChar-configureTable   ;"Directory"
240	>888e	63				                .byte lastNoDirChar-configureTable ;"NoDirectory"
245	>888f	8f				                .byte lastShChar-configureTable    ;"Shift"
246	=3					textSnippetsCount=*-textSnippetInsertPointOffsets

248	.8890					textSnippetOffsets:
249	>8890	be				                .byte configureTable.ectory-configureTable
250	>8891	be				                .byte configureTable.ectory-configureTable
255	>8892	c5				                .byte configureTable.ift-configureTable

258						                .endblock

260						;-------------------------------------------------------------------------

262	.8893					starCONFIGUREOrStarSTATUS:
263	.8893	0a		asl a		                asl a
264	.8894	69 80		adc #$80	                adc #$80

266						                ; *STATUS: A=1 V=1 C=1
267						                ; *CONFIGURE: A=0 V=0 C=1
268	.8896	08		php		                php
269	.8897	a9 c4		lda #$c4	                lda #<configureTable
270	.8899	85 b0		sta $b0		                sta oscliWorkspace.tablePtr+0
271	.889b	a9 87		lda #$87	                lda #>configureTable
272	.889d	85 b1		sta $b1		                sta oscliWorkspace.tablePtr+1
273	.889f	a2 ff		ldx #$ff	                ldx #$FF
274	.88a1	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
275	.88a4	d0 03		bne $88a9	                bne L886C
276	.88a6	20 0b 8b	jsr $8b0b	                jsr fetchCommandTableByte

278	.88a9					L886C:
279	.88a9	2c 70 e3	bit $e370	                bit valueFF ; V=1 to indicate 2-byte metadata
280	.88ac	20 cc 8a	jsr $8acc	                jsr findCommand
281	.88af	b0 07		bcs $88b8	                bcs foundCONFIGOrSTATUSTopic
282	.88b1	28		plp		                plp
283	.88b2	20 ae 8b	jsr $8bae	                jsr unknownCONFIGOrStatus
284	.88b5	d0 71		bne $8928	                bne jmpBadCommandError8B68
285	.88b7	60		rts		                rts

287						;-------------------------------------------------------------------------

289	.88b8					foundCONFIGOrSTATUSTopic:
290	.88b8	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
291	.88bb	28		plp		                plp
292	.88bc	50 03		bvc $88c1	                bvc L8884
293	.88be	20 9a 89	jsr $899a	                jsr ensureCommandLineTailEmpty

295						;-------------------------------------------------------------------------

297	.88c1					L8884:
298	.88c1	bd c4 87	lda $87c4,x	                lda configureTable,x
299	.88c4	89 40		bit #$40	                bit #$40
300	.88c6	d0 0a		bne $88d2	                bne L8895       ;taken if V0 clear
301	.88c8	48		pha		                pha
302	.88c9	bd c5 87	lda $87c5,x	                lda configureTable+1,x
303	.88cc	48		pha		                pha
304	.88cd	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
305	.88cf	49 0d		eor #$0d	                eor #$D         ;A=0 Z=1 if command line tail is empty
306	.88d1	60		rts		                rts             ;call routine, in effect

308						;-------------------------------------------------------------------------

310	.88d2					L8895:
311	.88d2	29 07		and #$07	                and #7
315	.88d4	fe c5 87	inc $87c5,x	                inc configureTable+1,x
317	.88d7	70 3d		bvs $8916	                bvs L88D9
318	.88d9	b0 30		bcs $890b	                bcs print1NumberHelp
319	.88db	30 05		bmi $88e2	                bmi L88A5
320	.88dd	20 9a 89	jsr $899a	                jsr ensureCommandLineTailEmpty
321	.88e0	80 26		bra $8908	                bra jmpSetConfigurationBitfield

323						;-------------------------------------------------------------------------

325	.88e2					L88A5:
326	.88e2	da		phx		                phx
327	.88e3	20 f2 89	jsr $89f2	                jsr L89B5
328	.88e6	fa		plx		                plx
329	.88e7	e0 07		cpx #$07	                cpx #7
330	.88e9	d0 06		bne $88f1	                bne L88B4
331	.88eb	a8		tay		                tay
332	.88ec	d0 02		bne $88f0	                bne L88B3
333	.88ee	a9 07		lda #$07	                lda #7

335	.88f0					L88B3:
336	.88f0	3a		dec a		                dec a

338	.88f1					L88B4:
339	.88f1	e0 4d		cpx #$4d	                cpx #configureTable.mode.metadata-configureTable
340	.88f3	d0 09		bne $88fe	                bne L88C1
341	.88f5	89 78		bit #$78	                bit #$78
342	.88f7	d0 2f		bne $8928	                bne jmpBadCommandError8B68
343	.88f9	a8		tay		                tay
344	.88fa	10 02		bpl $88fe	                bpl L88C1
345	.88fc	49 88		eor #$88	                eor #$88

347	.88fe					L88C1:
348	.88fe	20 ca 8b	jsr $8bca	                jsr getMaskCount
349	.8901	d9 d6 8b	cmp $8bd6,y	                cmp maskByBitCount,y
350	.8904	f0 02		beq $8908	                beq jmpSetConfigurationBitfield
351	.8906	b0 20		bcs $8928	                bcs jmpBadCommandError8B68

354	.8908					jmpSetConfigurationBitfield:
355	.8908	4c 2b 89	jmp $892b	                jmp setConfigurationBitfield

357						;-------------------------------------------------------------------------

359	.890b					print1NumberHelp:
360	.890b	10 08		bpl $8915	                bpl L88D8
361	.890d					print1NumberHelp2: ; haven't quite figured out the logic for this yet
362	.890d	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
363	>8910	3c 44 3e 0d 00			                .text "<D>",13,0
364	.8915					L88D8:
365	.8915	60		rts		                rts

367						;-------------------------------------------------------------------------

369	.8916					L88D9:
370	.8916	30 07		bmi $891f	                bmi printDecimalConfigurationByte
371	.8918	bd c5 87	lda $87c5,x	                lda configureTable+1,x
372	.891b	18		clc		                clc
373	.891c	4c 17 8b	jmp $8b17	                jmp L8ADA

375						;-------------------------------------------------------------------------

377	.891f					printDecimalConfigurationByte:
378	.891f	20 a1 8a	jsr $8aa1	                jsr readConfigurationByte

380	.8922					printDecimalByteAThenNewLine:
381	.8922	20 e7 8b	jsr $8be7	                jsr printDecimalByteA
382	.8925	4c e7 ff	jmp $ffe7	                jmp OSNEWL

384						;-------------------------------------------------------------------------

386	.8928					jmpBadCommandError8B68:
387	.8928	4c 60 fb	jmp $fb60	                jmp badCommandError

389						;-------------------------------------------------------------------------
390						;
391						; Insert value into bitfield for an item and write the value to NVRAM.
392						;
393						; Entry:
394						;
395						; A = value to insert
396						; X = offset into configure table for item's metadata
397						;
398						; Exit:
399						;
400						; NVRAM byte updated appropriately

402	.892b					setConfigurationBitfield: .block;L88EE: .block
403	.892b	85 b0		sta $b0		                sta $B0         ;save value
404	.892d	20 ca 8b	jsr $8bca	                jsr getMaskCount ; get mask bit count in Y
405	.8930	b9 d6 8b	lda $8bd6,y	                lda maskByBitCount,y ; get appropriate bit mask
406	.8933	20 c1 8b	jsr $8bc1	                jsr getShiftCount    ; get shift count in Y
407	.8936	80 03		bra $893b	                bra shift            ; start shifting as required
408	.8938					shiftLoop:
409	.8938	0a		asl a		                asl a           ;shift mask
410	.8939	06 b0		asl $b0		                asl $B0         ;shift value

412	.893b					shift:
413	.893b	88		dey		                dey
414	.893c	10 fa		bpl $8938	                bpl shiftLoop

416						                ; A = shifted mask, ?$B0=shifted value
417	.893e	85 b1		sta $b1		                sta $B1         ;store shifted mask
418	.8940	20 b5 8b	jsr $8bb5	                jsr getRTCByteIndex ; get actual RTC byte index in X
419	.8943	20 3a 9e	jsr $9e3a	                jsr readRTCByte ;get previous value
420	.8946	05 b1		ora $b1		                ora $B1         ;set all field's bits to 1
421	.8948	45 b1		eor $b1		                eor $B1         ;set all field's bits to 0
422	.894a	05 b0		ora $b0		                ora $B0         ;insert field's value
423	.894c	a8		tay		                tay             ;Y=byte to write
424						                .endblock

426	.894d					jmpWriteRTCByte:
427	.894d	4c 73 9e	jmp $9e73	                jmp writeRTCByte

429						;-------------------------------------------------------------------------

431	.8950					handlePrinterIgnoreChar:
432	.8950	70 18		bvs $896a	                bvs printDefaultPrinterIgnoreChar ;taken if *STATUS
433	.8952	b0 31		bcs $8985	                bcs print1OptionalNumberHelp
434	.8954	f0 0e		beq $8964	                beq L8927
435	.8956	20 f2 89	jsr $89f2	                jsr L89B5
436	.8959	da		phx		                phx
437	.895a	a9 00		lda #$00	                lda #0
438	.895c	20 66 89	jsr $8966	                jsr L8929
439	.895f	7a		ply		                ply
440	.8960	a2 0e		ldx #$0e	                ldx #CMOSBytes.printerIgnoreChar+cmosBytesOffset
441	.8962	80 e9		bra $894d	                bra jmpWriteRTCByte

443						;-------------------------------------------------------------------------

445	.8964					L8927:
446	.8964	a9 01		lda #$01	                lda #1
447	.8966					L8929:
448	.8966	a2 ba		ldx #$ba	                ldx #configureTable.printerIgnoreCharMetadata-configureTable
449	.8968					L892B:
450	.8968	80 9e		bra $8908	                bra jmpSetConfigurationBitfield

452						;-------------------------------------------------------------------------

454	.896a					printDefaultPrinterIgnoreChar:
455	.896a	20 de 8b	jsr $8bde	                jsr readUsePrinterIgnoreChar
456	.896d	90 0f		bcc $897e	                bcc gotPrinterIgnoreChar
457	.896f	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
458	>8972	4e 6f 20 49 67 6e 6f 72		                .text "No Ignore",13,0
	>897a	65 0d 00
459	.897d	60		rts		                rts

461						;-------------------------------------------------------------------------

463	.897e					gotPrinterIgnoreChar:
464	.897e	a2 0e		ldx #$0e	                ldx #CMOSBytes.printerIgnoreChar+cmosBytesOffset
465	.8980	20 3a 9e	jsr $9e3a	                jsr readRTCByte
466	.8983					L8946:
467	.8983	80 9d		bra $8922	                bra printDecimalByteAThenNewLine

469						;-------------------------------------------------------------------------

471	.8985					print1OptionalNumberHelp:
472	.8985	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
473	>8988	5b 3c 44 3e 5d 0d 00		                .text "[<D>]",13,0
474	.898f	60		rts		                rts

476						;-------------------------------------------------------------------------

478	.8990					parseSingle4BitNumberFromCommandLine:
479	.8990	20 36 86	jsr $8636	                jsr parseNumberFromString
480	.8993					bccBadCommandError:
481	.8993	90 93		bcc $8928	                bcc jmpBadCommandError8B68
482	.8995	8a		txa		                txa
483	.8996	c9 10		cmp #$10	                cmp #$10
484	.8998					bcsBadCommandError:
485	.8998	b0 8e		bcs $8928	                bcs jmpBadCommandError8B68
486	.899a					ensureCommandLineTailEmpty:
487	.899a	48		pha		                pha
488	.899b	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
489	.899e					bneBadCommandError:
490	.899e	d0 88		bne $8928	                bne jmpBadCommandError8B68
491	.89a0	68		pla		                pla
492	.89a1	60		rts		                rts

494						;-------------------------------------------------------------------------

496	.89a2					handleTV:
497	.89a2	70 2f		bvs $89d3	                bvs L8996
498	.89a4	b0 3b		bcs $89e1	                bcs printTVHelp
499	.89a6	f0 27		beq $89cf	                beq L8992
500	.89a8	20 36 86	jsr $8636	                jsr parseNumberFromString
501	.89ab	90 e6		bcc $8993	                bcc bccBadCommandError
502	.89ad	e0 fc		cpx #$fc	                cpx #$FC
503	.89af	b0 04		bcs $89b5	                bcs L8978
504	.89b1	e0 04		cpx #$04	                cpx #4
505	.89b3	b0 e3		bcs $8998	                bcs bcsBadCommandError

507	.89b5					L8978:
508	.89b5	8a		txa		                txa
509	.89b6	0a		asl a		                asl a
510	.89b7	85 b1		sta $b1		                sta $B1
511	.89b9	a2 00		ldx #$00	                ldx #0
512	.89bb	20 c9 f3	jsr $f3c9	                jsr LF30A
513	.89be	f0 08		beq $89c8	                beq L898B
514	.89c0	20 f2 89	jsr $89f2	                jsr L89B5
515	.89c3	c9 02		cmp #$02	                cmp #2
516	.89c5	b0 d1		bcs $8998	                bcs bcsBadCommandError
517	.89c7	aa		tax		                tax

519	.89c8					L898B:
520	.89c8	8a		txa		                txa
521	.89c9	05 b1		ora $b1		                ora $B1

523	.89cb					L898E:
524	.89cb	a2 bc		ldx #$bc	                ldx #configureTable.tvMetadata-configureTable
525	.89cd	80 99		bra $8968	                bra L892B

527						;-------------------------------------------------------------------------

529	.89cf					L8992:
530	.89cf	a9 00		lda #$00	                lda #0
531	.89d1	80 f8		bra $89cb	                bra L898E

533						;-------------------------------------------------------------------------

535	.89d3					L8996:
536	.89d3	20 13 8c	jsr $8c13	                jsr readDefaultTVSettings
537	.89d6	20 e6 8b	jsr $8be6	                jsr printDecimalByteY
538	.89d9	a9 2c		lda #$2c	                lda #','
539	.89db	20 ee ff	jsr $ffee	                jsr OSWRCH
540	.89de	8a		txa		                txa
541	.89df	80 a2		bra $8983	                bra L8946

543						;-------------------------------------------------------------------------

545	.89e1					printTVHelp:
546	.89e1	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
547	>89e4	5b 3c 44 3e 5b 2c 3c 44		                .text "[<D>[,<D>]]",13,0
	>89ec	3e 5d 5d 0d 00
548	.89f1	60		rts		                rts

550						;-------------------------------------------------------------------------

552	.89f2					L89B5:
553	.89f2	20 36 86	jsr $8636	                jsr parseNumberFromString
554	.89f5	90 9c		bcc $8993	                bcc bccBadCommandError
555	.89f7	8a		txa		                txa
556	.89f8	80 a0		bra $899a	                bra ensureCommandLineTailEmpty

559						;-------------------------------------------------------------------------

561	.89fa					printConfigureOrStatusHeader: .block
562	.89fa	d0 a2		bne $899e	                bne bneBadCommandError
563	.89fc	08		php		                php
564	.89fd	5a		phy		                phy
565	.89fe	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
566	>8a01	43 6f 6e 66 69 67 75 72		                .text "Configuration ",0
	>8a09	61 74 69 6f 6e 20 00
567	.8a10	70 0f		bvs $8a21	                bvs printStatusHeader ;taken if *STATUS
568	.8a12	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
569	>8a15	6f 70 74 69 6f 6e 73 3a		                .text "options:",13,0
	>8a1d	0d 00
570	.8a1f	80 0c		bra $8a2d	                bra printItems
571	.8a21					printStatusHeader:
572	.8a21	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
573	>8a24	73 74 61 74 75 73 3a 0d		                .text "status:",13,0
	>8a2c	00
574	.8a2d					printItems:
575	.8a2d	38		sec		                sec
576	.8a2e	20 17 8b	jsr $8b17	                jsr L8ADA
577	.8a31	7a		ply		                ply
578	.8a32	28		plp		                plp
579	.8a33	08		php		                php
580	.8a34	20 ae 8b	jsr $8bae	                jsr unknownCONFIGOrStatus
581	.8a37	28		plp		                plp
582	.8a38	70 66		bvs $8aa0	                bvs done        ;taken if *STATUS
583	.8a3a	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
584	>8a3d	57 68 65 72 65 3a 0d		                .text "Where:",13
585	>8a44	44 20 69 73 20 61 20 64		                .text "D is a decimal number, or",13
	>8a4c	65 63 69 6d 61 6c 20 6e 75 6d 62 65 72 2c 20 6f
	>8a5c	72 0d
586	>8a5e	61 20 68 65 78 61 64 65		                .text "a hexadecimal number preceded by &",13
	>8a66	63 69 6d 61 6c 20 6e 75 6d 62 65 72 20 70 72 65
	>8a76	63 65 64 65 64 20 62 79 20 26 0d
587	>8a81	49 74 65 6d 73 20 77 69		                .text "Items within [ ] are optional",13
	>8a89	74 68 69 6e 20 5b 20 5d 20 61 72 65 20 6f 70 74
	>8a99	69 6f 6e 61 6c 0d
588	>8a9f	00				                .byte 0
589	.8aa0					done:
590	.8aa0	60		rts		                rts
591						                .endblock

593						;-------------------------------------------------------------------------
594						;
595						; Read configuration byte, given offset of metadata in the configure
596						; table.
597						;
598						; Entry:
599						;
600						; X = offset of metadata in the configure table
601						;
602						; Exit:
603						;
604						; A = value read
605						;
606						; Preserves: X/Y/P

612	.8aa1					readConfigurationByte: .block
613	.8aa1	08		php		                php
614	.8aa2	5a		phy		                phy
615	.8aa3	da		phx		                phx
616	.8aa4	20 b5 8b	jsr $8bb5	                jsr getRTCByteIndex ;
617	.8aa7	20 3a 9e	jsr $9e3a	                jsr readRTCByte
618	.8aaa	fa		plx		                plx
619	.8aab	20 c1 8b	jsr $8bc1	                jsr getShiftCount
620	.8aae	80 01		bra $8ab1	                bra shift

622						;-------------------------------------------------------------------------

624	.8ab0					shiftLoop:
625	.8ab0	4a		lsr a		                lsr a

627	.8ab1					shift:
628	.8ab1	88		dey		                dey
629	.8ab2	10 fc		bpl $8ab0	                bpl shiftLoop

631	.8ab4	20 ca 8b	jsr $8bca	                jsr getMaskCount
632	.8ab7	39 d6 8b	and $8bd6,y	                and maskByBitCount,y
633	.8aba	e0 07		cpx #$07	                cpx #configureTable.baud.metadata-configureTable
634	.8abc	d0 01		bne $8abf	                bne gotMaskedByte
635	.8abe	1a		inc a		                inc a

637	.8abf					gotMaskedByte:
638						                ; If retrieving the MODE value, rearrange things so
639						                ; the shadow modes are 128-135.
640	.8abf	e0 4d		cpx #$4d	                cpx #configureTable.mode.metadata-configureTable
641	.8ac1	d0 06		bne $8ac9	                bne done        ;taken if not MODE
642	.8ac3	89 08		bit #$08	                bit #CMOSBytes.defaults0.shadowMask ;test shadow bit
643	.8ac5	f0 02		beq $8ac9	                beq done                                   ;taken if not shadow mode
644	.8ac7	49 88		eor #$88	                eor #$80|CMOSBytes.defaults0.shadowMask ;turn mode|flag into mode|$80

646	.8ac9					done:
647	.8ac9	7a		ply		                ply
648	.8aca	28		plp		                plp
649	.8acb	60		rts		                rts
650						                .endblock

652						;-------------------------------------------------------------------------
653						;
654						; Find command in command table.
655						;
656						; Entry:
657						;
658						; (stringInputBufferAddress),y = input
659						; oscliWorkspace.tablePtr; = address of command table
660						; V = 0 if commands have 4 bytes of metadata
661						;     1 if commands have 2 bytes of metadata
662						;
663						; Exit:
664						;
665						; C=0 = no match
666						;
667						; C=1 = match;
668						;       A holds 1st byte of metadata
669						;       oscliWorkspace.tablePtr; = address of 2nd and following metadata bytes
670						;       (stringInputBufferAddress),y = input following command
671						;
672						; Preserves: X/V

674	.8acc					findCommand: .block
675	.8acc	84 e6		sty $e6		                sty commandLineY ;save Y
676	.8ace	80 0a		bra $8ada	                bra checkInput       ;get going...

678	.8ad0					checkLetter:
679	.8ad0	52 b0		eor ($b0)	                eor (oscliWorkspace.tablePtr)
680	.8ad2	29 df		and #$df	                and #$DF
681	.8ad4	d0 15		bne $8aeb	                bne noMatch    ; taken if char didn't match
682	.8ad6	20 0b 8b	jsr $8b0b	                jsr fetchCommandTableByte
683	.8ad9	c8		iny		                iny

685	.8ada					checkInput:
686	.8ada	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
687	.8adc	20 9c eb	jsr $eb9c	                jsr isLetter
688	.8adf	90 ef		bcc $8ad0	                bcc checkLetter ; taken if letter

690						                ; Non-letter input means potentially end of command
691						                ; name.
692	.8ae1	b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr) ; next table byte
693	.8ae3	30 21		bmi $8b06	                bmi commandMatch ; taken if end of string - a match
694	.8ae5	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
695	.8ae7	c9 2e		cmp #$2e	                cmp #'.'        ; '.' is the abbreviation char
696	.8ae9	f0 04		beq $8aef	                beq abbreviationMatch ;taken with C=1 if match

698	.8aeb					noMatch:
699	.8aeb	18		clc		                clc             ;indicate no match
700	.8aec	a4 e6		ldy $e6		                ldy commandLineY ;restore Y
701	.8aee	88		dey		                dey             ;compensate for upcoming iny

703	.8aef					abbreviationMatch:
704	.8aef	c8		iny		                iny             ; skip the '.'

706	.8af0					findCommandMetadataLoop:
707	.8af0	20 0b 8b	jsr $8b0b	                jsr fetchCommandTableByte
708	.8af3	f0 15		beq $8b0a	                beq rts8ACD
709	.8af5	10 f9		bpl $8af0	                bpl findCommandMetadataLoop ; keep looping through chars if necessary
710	.8af7	b0 11		bcs $8b0a	                bcs rts8ACD                 ;taken if it was a match
711	.8af9	20 0b 8b	jsr $8b0b	                jsr fetchCommandTableByte   ;discard 2nd metadata byte
712	.8afc	70 dc		bvs $8ada	                bvs checkInput ; if V=1, 2-byte metadata; if V=0, 4-byte metadata
713	.8afe	20 0b 8b	jsr $8b0b	                jsr fetchCommandTableByte ;discard 3rd metadata byte
714	.8b01	20 0b 8b	jsr $8b0b	                jsr fetchCommandTableByte ;discard 4th metadata byte
715	.8b04	80 d4		bra $8ada	                bra checkInput

717						;-------------------------------------------------------------------------

719	.8b06					commandMatch:
720	.8b06	20 0b 8b	jsr $8b0b	                jsr fetchCommandTableByte
721	.8b09	38		sec		                sec

723	.8b0a					rts8ACD:
724	.8b0a	60		rts		                rts
725						                .endblock

727						;-------------------------------------------------------------------------
728						;
729						; Fetch byte from command table with postincrement.
730						;
731						; Entry:
732						;
733						; oscliWorkspace.tablePtr; = address of byte to fetch
734						;
735						; Exit:
736						;
737						; A = byte fetched
738						; oscliWorkspace.tablePtr; incremented
739						;
740						; Preserves: X/Y/C/V

742	.8b0b					fetchCommandTableByte:
743	.8b0b	e8		inx		                inx
744	.8b0c	b2 b0		lda ($b0)	                lda (oscliWorkspace.tablePtr)
745	.8b0e	48		pha		                pha
746	.8b0f	e6 b0		inc $b0		                inc oscliWorkspace.tablePtr+0
747	.8b11	d0 02		bne $8b15	                bne L8AD8
748	.8b13	e6 b1		inc $b1		                inc oscliWorkspace.tablePtr+1

750	.8b15					L8AD8:
751	.8b15	68		pla		                pla
752	.8b16	60		rts		                rts

754						;-------------------------------------------------------------------------
755						;
756						; Print configure table items.
757						;
758						; Entry:
759						;
760						; C = ???
761						;
762						; V=0 if *CONFIGURE; V=1 if *STATUS
763						;
764	.8b17					L8ADA: .block
765	.8b17	48		pha		                pha
766	.8b18	a0 03		ldy #$03	                ldy #configureTable.baud-configureTable
767	.8b1a	a2 02		ldx #$02	                ldx #(configureTable.baud-configureTable)-1

769	.8b1c					loop:
770	.8b1c	e8		inx		                inx
771	.8b1d	bd c4 87	lda $87c4,x	                lda configureTable,x ;get name byte
772	.8b20	f0 5a		beq $8b7c	                beq done            ;all done if 0
773	.8b22	10 f8		bpl $8b1c	                bpl loop            ;keep going until end of name
774						                                     ;reached
775	.8b24	50 1f		bvc $8b45	                bvc L8B08            ;taken if *CONFIGURE

777						                ; A = metadata byte 0
778	.8b26	29 40		and #$40	                and #$40
779	.8b28	f0 10		beq $8b3a	                beq L8AFD       ;taken if V0 clear

781	.8b2a	bd c5 87	lda $87c5,x	                lda configureTable+1,x ;A = metadata byte 1
782	.8b2d	30 0b		bmi $8b3a	                bmi L8AFD              ;taken if N1 set

784	.8b2f	20 a1 8a	jsr $8aa1	                jsr readConfigurationByte ;Read the actual value
785	.8b32	5d c4 87	eor $87c4,x	                eor configureTable,x      ;eor with MatchValue
786	.8b35	29 07		and #$07	                and #7                    ;A=0 if value matches MatchValue
787	.8b37	d0 3d		bne $8b76	                bne next                  ;taken if value isn't MatchValue
788	.8b39	3a		dec a		                dec a                     ;A=$ff

790	.8b3a					L8AFD:
791	.8b3a	b0 09		bcs $8b45	                bcs L8B08       ;
792	.8b3c	10 38		bpl $8b76	                bpl next        ;
793	.8b3e	68		pla		                pla
794	.8b3f	48		pha		                pha
795	.8b40	5d c5 87	eor $87c5,x	                eor configureTable+1,x
796	.8b43	d0 31		bne $8b76	                bne next

798	.8b45					L8B08:
799	.8b45	08		php		                php
800	.8b46	da		phx		                phx
801	.8b47	50 09		bvc $8b52	                bvc printOrdinaryItem
802	.8b49	c0 35		cpy #$35	                cpy #configureTable.ignore-configureTable
803	.8b4b	d0 05		bne $8b52	                bne printOrdinaryItem
804	.8b4d	20 de 8b	jsr $8bde	                jsr readUsePrinterIgnoreChar
805	.8b50	b0 1b		bcs $8b6d	                bcs L8B30

807	.8b52					printOrdinaryItem:
811	.8b52	a2 09		ldx #$09	                ldx #9
813	.8b54	20 a8 8b	jsr $8ba8	                jsr printConfigureTableString
814	.8b57	29 40		and #$40	                and #$40
815	.8b59	f0 0f		beq $8b6a	                beq printSpaces       ;taken if V0 clear
816	.8b5b	b9 c5 87	lda $87c5,y	                lda configureTable+1,y
817	.8b5e	30 0a		bmi $8b6a	                bmi printSpaces ;taken if N1 set

819						                ; V0 set, N1 clear = newline and next item
820	.8b60	20 e7 ff	jsr $ffe7	                jsr OSNEWL
821	.8b63	80 0f		bra $8b74	                bra next2

823	.8b65					printSpacesLoop:
824	.8b65	a9 20		lda #$20	                lda #' '
825	.8b67	20 ee ff	jsr $ffee	                jsr OSWRCH

827	.8b6a					printSpaces:
828	.8b6a	ca		dex		                dex
829	.8b6b	10 f8		bpl $8b65	                bpl printSpacesLoop

831	.8b6d					L8B30:
832	.8b6d	fa		plx		                plx
833	.8b6e	28		plp		                plp
834	.8b6f	08		php		                php
835	.8b70	da		phx		                phx
836	.8b71	20 c1 88	jsr $88c1	                jsr L8884

838	.8b74					next2:
839	.8b74	fa		plx		                plx
840	.8b75	28		plp		                plp

842	.8b76					next:
843	.8b76	e8		inx		                inx             ;point X just before next item
844	.8b77	8a		txa		                txa
845	.8b78	a8		tay		                tay
846	.8b79	c8		iny		                iny             ;point Y at next item
847	.8b7a	80 a0		bra $8b1c	                bra loop

849	.8b7c					done:
850	.8b7c	68		pla		                pla
851	.8b7d	60		rts		                rts
852						                .endblock

854						;-------------------------------------------------------------------------

856	.8b7e					printConfigureTableStringLoop:
857	.8b7e	20 ee ff	jsr $ffee	                jsr OSWRCH      ;print char
858	.8b81	48		pha		                pha             ;save A (char to print)
859	.8b82	5a		phy		                phy             ;save Y (table offset)
860	.8b83	98		tya		                tya             ;get table offset in A

862						                ; If we're at a snippet insert point, insert the
863						                ; snippet, recursively.
864	.8b84	a0 02		ldy #$02	                ldy #configureTable.textSnippetsCount-1
865	.8b86					findSnippetInsertPointLoop:
866	.8b86	d9 8d 88	cmp $888d,y	                cmp configureTable.textSnippetInsertPointOffsets,y
867	.8b89	d0 07		bne $8b92	                bne nextSnippetInsertPoint

869						                ; Insert a snippet here. Load the new snippet's offset
870						                ; in Y and repeat.
871	.8b8b	b9 90 88	lda $8890,y	                lda configureTable.textSnippetOffsets,y
872	.8b8e	a8		tay		                tay
873	.8b8f	20 a8 8b	jsr $8ba8	                jsr printConfigureTableString
874	.8b92					nextSnippetInsertPoint
875	.8b92	88		dey		                dey
876	.8b93	10 f1		bpl $8b86	                bpl findSnippetInsertPointLoop
877	.8b95	7a		ply		                ply             ;restore Y (table offset)
878	.8b96	68		pla		                pla             ;restore A (char to print)
879	.8b97	c8		iny		                iny             ;next byte in table
880	.8b98	ca		dex		                dex             ;
881	.8b99	49 20		eor #$20	                eor #$20
882	.8b9b	19 c4 87	ora $87c4,y	                ora configureTable,y
883	.8b9e	29 a0		and #$a0	                and #%10100000
884	.8ba0	d0 06		bne $8ba8	                bne printConfigureTableString

886						                ; if char case changed, but it wasn't the end of the
887						                ; string, pop a space in.
888	.8ba2	a9 20		lda #$20	                lda #' '
889	.8ba4	20 ee ff	jsr $ffee	                jsr OSWRCH
890	.8ba7	ca		dex		                dex

893						;-------------------------------------------------------------------------
894						;
895						; Print string from configure table, with snippets inserted as
896						; required.
897						;
898						; Entry:
899						;
900						; X = column counter start value
901						; Y = configure table offset
902						;
903						; Exit:
904						;
905						; A = item's metadata byte 0
906						; X decremented for each char printed
907						;
908	.8ba8					printConfigureTableString:
909	.8ba8	b9 c4 87	lda $87c4,y	                lda configureTable,y
910	.8bab	10 d1		bpl $8b7e	                bpl printConfigureTableStringLoop
911	.8bad	60		rts		                rts

914						;-------------------------------------------------------------------------
915						;
916						; Issue ROM service call romServiceCallUnknownCONFIG ($28) or
917						; romServiceCallUnknownSTATUS ($29).
918						;
919						; Entry:
920						;
921						; C=0 for unknown CONFIG, or C=1 for unknown STATUS
922						;
923						; Exit:
924						;
925						; as per appropriate ROM service call
926						;
927	.8bae					unknownCONFIGOrStatus:
930	.8bae	a9 14		lda #$14	                lda #romServiceCallUnknownCONFIG>>1
931	.8bb0	2a		rol a		                rol a           ;form $28 or $29 according to C
932	.8bb1	aa		tax		                tax
933	.8bb2	4c ff ee	jmp $eeff	                jmp makeROMServiceCall

935						;-------------------------------------------------------------------------
936						;
937						; Get actual RTC byte index for configure item, given offset in
938						; configure table to its metadata.
939						;
940						; Entry:
941						;
942						; X = offset into configure table for item's metadata
943						;
944						; Exit:
945						;
946						; X = index of byte
947						;
948						; Preserves: Y/C

950	.8bb5					getRTCByteIndex:
951	.8bb5	bd c5 87	lda $87c5,x	                lda configureTable+1,x
952	.8bb8	29 78		and #$78	                and #%01111000
953	.8bba	4a		lsr a		                lsr a
954	.8bbb	4a		lsr a		                lsr a
955	.8bbc	4a		lsr a		                lsr a           ; C=0
956	.8bbd	69 05		adc #$05	                adc #metadataRTCByteIndexOffset
957	.8bbf	aa		tax		                tax
958	.8bc0	60		rts		                rts

960						;-------------------------------------------------------------------------
961						;
962						; Get shift count for configure item's data, given offset in configure
963						; table for its metadata.
964						;
965						; Entry:
966						;
967						; X = offset into configure table for item's metadata
968						;
969						; Exit:
970						;
971						; Y = shift count
972						;
973						; Preserves: A/X/C
974						;
975	.8bc1					getShiftCount:
976	.8bc1	48		pha		                pha
977	.8bc2	bd c5 87	lda $87c5,x	                lda configureTable+1,x
978	.8bc5	29 07		and #$07	                and #%00000111
979	.8bc7	a8		tay		                tay
980	.8bc8	68		pla		                pla
981	.8bc9	60		rts		                rts

983						;-------------------------------------------------------------------------
984						;
985						; Get mask bit count for configure item's data, given offset in
986						; configure table for its metadata.
987						;
988						; Entry:
989						;
990						; X = offset into configure table for item's metadata
991						;
992						; Exit:
993						;
994						; Y = mask bit count, -1 (0 = 1 bits ... 7 = 8 bits)
995						;
996						; Preserves: A/X
997						;
998	.8bca					getMaskCount:
999	.8bca	48		pha		                pha
1000	.8bcb	bd c4 87	lda $87c4,x	                lda configureTable+0,x; "."
1001	.8bce	4a		lsr a		                lsr a                 ; MaskCount<<2|(other stuff)
1002	.8bcf	4a		lsr a		                lsr a                 ; MaskCount<<1|(other stuff)
1003	.8bd0	4a		lsr a		                lsr a                 ; MaskCount<<0|(other stuff)
1004	.8bd1	29 07		and #$07	                and #7                ; MaskCount
1005	.8bd3	a8		tay		                tay
1006	.8bd4	68		pla		                pla
1007	.8bd5	60		rts		                rts

1009	.8bd6					maskByBitCount:
1010	>8bd6	01				                .byte %00000001
1011	>8bd7	03				                .byte %00000011
1012	>8bd8	07				                .byte %00000111
1013	>8bd9	0f				                .byte %00001111
1014	>8bda	1f				                .byte %00011111
1015	>8bdb	3f				                .byte %00111111
1016	>8bdc	7f				                .byte %01111111
1017	>8bdd	ff				                .byte %11111111

1019						;-------------------------------------------------------------------------
1020						;
1021						; Read the use printer ignore char flag.
1022						;
1023						; Exit:
1024						;
1025						; C=0 if using printer ignore char; C=1 if not.
1026						;
1027						; Preserves: Y

1033	.8bde					readUsePrinterIgnoreChar:
1034	.8bde	5a		phy		                phy
1035	.8bdf	20 12 9e	jsr $9e12	                jsr readDefaults2
1036	.8be2	4a		lsr a		                lsr a
1037	.8be3	4a		lsr a		                lsr a
1038	.8be4	7a		ply		                ply
1039	.8be5	60		rts		                rts

1041						;-------------------------------------------------------------------------
1042						;
1043						; Print decimal byte.
1044						;
1045						; Entry:
1046						;
1047						; (printDecimalByteA) A = value to print
1048						;
1049						; (printDecimalByteY) Y = value to print
1050						;
1051	.8be6					printDecimalByteY:
1052	.8be6	98		tya		                tya
1053	.8be7					printDecimalByteA:
1054	.8be7	38		sec		                sec             ;set leading zeros flag
1055	.8be8	a0 ff		ldy #$ff	                ldy #$FF        ;reset digit counter
1056	.8bea	08		php		                php             ;save leading zeros flag

1058	.8beb					countHundredsLoop:
1059	.8beb	c8		iny		                iny
1060	.8bec	e9 64		sbc #$64	                sbc #100
1061	.8bee	b0 fb		bcs $8beb	                bcs countHundredsLoop

1063	.8bf0	69 64		adc #$64	                adc #100        ;put 0 back in the hundreds column
1064	.8bf2	28		plp		                plp             ;restore leading zeros flag
1065	.8bf3	20 07 8c	jsr $8c07	                jsr maybePrintHexDigit

1067	.8bf6	a0 ff		ldy #$ff	                ldy #$FF        ;reset digit counter
1068	.8bf8	08		php		                php             ;save leading zeros flag
1069	.8bf9	38		sec		                sec

1071	.8bfa					countTensLoop:
1072	.8bfa	c8		iny		                iny
1073	.8bfb	e9 0a		sbc #$0a	                sbc #10
1074	.8bfd	b0 fb		bcs $8bfa	                bcs countTensLoop

1076	.8bff	69 0a		adc #$0a	                adc #10         ;put 0 back in the tens column
1077	.8c01	28		plp		                plp             ;restore leading zeros flag
1078	.8c02	20 07 8c	jsr $8c07	                jsr maybePrintHexDigit
1079	.8c05	18		clc		                clc             ;always clear leading zeros flag for
1080						                                ;units
1081	.8c06	a8		tay		                tay             ;Y=3rd digit

1083	.8c07					maybePrintHexDigit:
1084	.8c07	48		pha		                pha
1085	.8c08	98		tya		                tya
1086	.8c09	d0 02		bne $8c0d	                bne L8BD0       ;always print if non-zero
1087	.8c0b	b0 04		bcs $8c11	                bcs L8BD4       ;print non-leading zeros
1088	.8c0d					L8BD0:
1089	.8c0d	20 b5 ac	jsr $acb5	                jsr printHexDigit
1090	.8c10	18		clc		                clc             ;indicate non-zero digit printed
1091	.8c11					L8BD4:
1092	.8c11	68		pla		                pla
1093	.8c12	60		rts		                rts

1095						;-------------------------------------------------------------------------

1101	.8c13					readDefaultTVSettings:
1102	.8c13	a2 bc		ldx #$bc	                ldx #configureTable.tvMetadata-configureTable
1103	.8c15	20 a1 8a	jsr $8aa1	                jsr readConfigurationByte
1104	.8c18	4a		lsr a		                lsr a
1105	.8c19	89 04		bit #$04	                bit #%00000100
1106	.8c1b	f0 02		beq $8c1f	                beq L8BE2
1107	.8c1d	09 fc		ora #$fc	                ora #%11111100
1108	.8c1f					L8BE2:
1109	.8c1f	a8		tay		                tay
1110	.8c20	a9 00		lda #$00	                lda #0
1111	.8c22	2a		rol a		                rol a
1112	.8c23	aa		tax		                tax
1113	.8c24	60		rts		                rts

1115						;-------------------------------------------------------------------------

:5	;******  Return to file: src/terminal.s65

966						                .include "sram_utils.s65"

:8	;******  Processing file: src/sram_utils.s65

1						;-------------------------------------------------------------------------

3						; osword42SetupTable[i] is offset into sramWorkspace for OSWORD
4						; parameter block byte i

6	.8c25					osword42SetupTable:
8	>8c25	01				                .byte sramWorkspace.type-sramWorkspace
10	>8c26	09				                .byte sramWorkspace.dataAddress+0-sramWorkspace
11	>8c27	0a				                .byte sramWorkspace.dataAddress+1-sramWorkspace
12	>8c28	0b				                .byte sramWorkspace.dataAddress+2-sramWorkspace
13	>8c29	0c				                .byte sramWorkspace.dataAddress+3-sramWorkspace
14	>8c2a	02				                .byte sramWorkspace.length+0-sramWorkspace
15	>8c2b	03				                .byte sramWorkspace.length+1-sramWorkspace
16	>8c2c	04				                .byte sramWorkspace.bank-sramWorkspace
17	>8c2d	05				                .byte sramWorkspace.sramAddress+0-sramWorkspace
18	>8c2e	06				                .byte sramWorkspace.sramAddress+1-sramWorkspace

20						;-------------------------------------------------------------------------
21						;
22						; OSWORD $42 - Sideways RAM Block Transfor (G.7-7)
23						;
24						; Entry: parameter block like this:
25						;
26						;    block?0 - bit 7 clear=sram->memory, set=memory->sram
27						;              bit 6 clear=absolute, set=pseudo
28						;    block!1 - data address
29						;    (block+5); - block length
30						;    block?7 - ROM ID 0-$0f, or $10-$13 for W/X/Y/Z
31						;    (block+8); - sideways RAM address
32						;
33	.8c2f					osword42: .proc
39	.8c2f	a0 09		ldy #$09	                ldy #9

41	.8c31					copyFromParameterBlockLoop:
42	.8c31	b1 f0		lda ($f0),y	                lda (originalX),y
46	.8c33	be 25 8c	ldx $8c25,y	                ldx osword42SetupTable,y
48	.8c36	9d ed 02	sta $02ed,x	                sta sramWorkspace,x
49	.8c39	88		dey		                dey
53	.8c3a	10 f5		bpl $8c31	                bpl copyFromParameterBlockLoop
54	.8c3c	c8		iny		                iny             ; Y=0

57	.8c3d					saveTransferPointersLoop:
58	.8c3d	b9 b0 00	lda $00b0,y	                lda sramTransferPointers,y
59	.8c40	48		pha		                pha
60	.8c41	c8		iny		                iny
61	.8c42	c0 04		cpy #$04	                cpy #size(sramTransferPointers)
62	.8c44	90 f7		bcc $8c3d	                bcc saveTransferPointersLoop

64	.8c46	20 f4 8d	jsr $8df4	                jsr doSidewaysRAMBlockTransfer

66	.8c49	a0 03		ldy #$03	                ldy #size(sramTransferPointers)-1
67	.8c4b					restoreTransferPointersLoop:
68	.8c4b	68		pla		                pla
69	.8c4c	99 b0 00	sta $00b0,y	                sta sramTransferPointers,y
70	.8c4f	88		dey		                dey
71	.8c50	10 f9		bpl $8c4b	                bpl restoreTransferPointersLoop
72	.8c52	60		rts		                rts
73						                .endproc

75						;-------------------------------------------------------------------------

77	.8c53					convertSidewaysRAMPseudoAddress:
78	.8c53	2c ee 02	bit $02ee	                bit sramWorkspace.type
79	.8c56	50 30		bvc $8c88	                bvc checkROMID ;taken if absolute addressing - nothing to do

81						                ; Sort out pseudo address - see MasRef G.7-5
82	.8c58	a0 04		ldy #$04	                ldy #4          ; 4=first SRAM bank
83	.8c5a	ad f2 02	lda $02f2	                lda sramWorkspace.sramAddress+0 ; pseudo address
84	.8c5d	ae f3 02	ldx $02f3	                ldx sramWorkspace.sramAddress+1 ; pseudo address
85	.8c60					findStartBankLoop:
86	.8c60	e0 3f		cpx #$3f	                cpx #>dataBankSize
87	.8c62	90 16		bcc $8c7a	                bcc foundStartBank ; taken if MSB $00-$3e
88	.8c64	d0 04		bne $8c6a	                bne nextBank       ; taken if MSB >=$40

90						                ; Address is 16 KB-the dummy header size
91	.8c66	c9 f0		cmp #$f0	                cmp #<dataBankSize
92	.8c68	90 10		bcc $8c7a	                bcc foundStartBank ; taken if address<$3ff0

94	.8c6a					nextBank:
95	.8c6a	e9 f0		sbc #$f0	                sbc #<dataBankSize
96	.8c6c	48		pha		                pha
97	.8c6d	8a		txa		                txa
98	.8c6e	e9 3f		sbc #$3f	                sbc #>dataBankSize
99	.8c70	aa		tax		                tax
100	.8c71	68		pla		                pla
101	.8c72	c8		iny		                iny
102	.8c73	c0 08		cpy #$08	                cpy #8          ; 8=last SRAM bank
103	.8c75	90 e9		bcc $8c60	                bcc findStartBankLoop ; taken if more banks to go
104	.8c77	4c 64 95	jmp $9564	                jmp badAddressError ; taken if pseudo address out of range

106	.8c7a					foundStartBank:
107						                ; form actual address in sramAddress!5
108	.8c7a	69 10		adc #$10	                adc #<dataBankStart
109	.8c7c	8d f2 02	sta $02f2	                sta sramWorkspace.sramAddress+0
110	.8c7f	8a		txa		                txa
111	.8c80	69 80		adc #$80	                adc #>dataBankStart
112	.8c82	8d f3 02	sta $02f3	                sta sramWorkspace.sramAddress+1
113	.8c85	8c f1 02	sty $02f1	                sty sramWorkspace.bank ; save ROM number

116						;-------------------------------------------------------------------------
117						;
118						; Check ROM ID (as read by readROMID) is valid.
119						;
120						; Entry:
121						;
122						; sramWorkspace.bank = ROM ID
123						;
124						; Exit:
125						;
126						; A=$40 Z=0 if operation addressing mode/bank addressing mode mismatch
127						;
128						; May also generate a "Bad id" error.

130	.8c88					checkROMID: .proc
131	.8c88	ad f1 02	lda $02f1	                lda sramWorkspace.bank
132	.8c8b	c9 10		cmp #$10	                cmp #$10
133	.8c8d	90 09		bcc $8c98	                bcc gotValidROMID       ; if <16, use as-is

135						                ; convert W/X/Y/Z to 4-7
136	.8c8f	c9 14		cmp #$14	                cmp #$14
137	.8c91	b0 1e		bcs $8cb1	                bcs badIdError  ; bad id if >=$14
138	.8c93	49 14		eor #$14	                eor #$14        ; $10->$04, $11->$05, $12->$06, $13->$07
139	.8c95	8d f1 02	sta $02f1	                sta sramWorkspace.bank

141	.8c98					gotValidROMID:
142	.8c98	aa		tax		                tax
143	.8c99	20 bd f8	jsr $f8bd	                jsr isBankROM
144	.8c9c	b0 07		bcs $8ca5	                bcs gotValidBank ; taken if RAM
145	.8c9e	2c ee 02	bit $02ee	                bit sramWorkspace.type

147						                ; Don't understand the logic here?
148	.8ca1	10 0e		bpl $8cb1	                bpl badIdError  ; taken if read operation
149	.8ca3	70 0c		bvs $8cb1	                bvs badIdError  ; taken if pseudo addressing

151	.8ca5					gotValidBank:
152	.8ca5	20 c1 8f	jsr $8fc1	                jsr sramGetBankMode        ; A=$40 if pseudo
153	.8ca8	ae f1 02	ldx $02f1	                ldx sramWorkspace.bank
154	.8cab	4d ee 02	eor $02ee	                eor sramWorkspace.type
155	.8cae	29 40		and #$40	                and #$40
156	.8cb0	60		rts		                rts
157						                .endproc

159						;-------------------------------------------------------------------------

161	.8cb1					badIdError:
162	.8cb1	20 ff ae	jsr $aeff	                jsr doFollowingError
163	>8cb4	80				                .byte $80
164	>8cb5	42 61 64 20 69 64		                .text "Bad id"
165	>8cbb	00				                .byte 0

167						;-------------------------------------------------------------------------
168						;
169						; Read ROM ID from command line.
170						;
171						; Entry:
172						;
173						; ($f2),y = command line input pointer
174						;
175						; Exit:
176						;
177						; V=1 if invalid
178						;
179						; V=0 if valid
180						;    osfileParameterBlock?1 bit 6 cleared
181						;    osfileParameterBlock?4 is ROM ID
182						;
183						; May also generate a "Bad id" error.
184						;
185	.8cbc					readROMID: .proc
186	.8cbc	20 98 86	jsr $8698	                jsr readHexDigit ; get char, possibly hex
187	.8cbf	2c 70 e3	bit $e370	                bit valueFF      ; V=1
188	.8cc2	b0 0d		bcs $8cd1	                bcs got1CharROMID  ; taken if hex digit encountered
189	.8cc4	29 df		and #$df	                and #$DF         ; redundantly convert to upper case
190	.8cc6	c9 5b		cmp #$5b	                cmp #'Z'+1
191	.8cc8	b0 1d		bcs $8ce7	                bcs done        ; taken if >'Z' - not valid
192	.8cca	c9 57		cmp #$57	                cmp #'W'
193	.8ccc	90 19		bcc $8ce7	                bcc done        ; taken if <'W' - not valid
194	.8cce	e9 53		sbc #$53	                sbc #'W'-4      ; adjust: W=4, X=5, Y=6, Z=7
195	.8cd0	c8		iny		                iny             ; consume command line char

197	.8cd1					got1CharROMID:
198						                ; Handle decimal numbers: if the bank was 1, it might
199						                ; be "1" or the first char of "10", "11", etc. Handle
200						                ; accordingly.
201						                ;
202						                ; (If using the W/X/Y/Z syntax, the banks are 4-7.)
203	.8cd1	c9 01		cmp #$01	                cmp #1
204	.8cd3	d0 09		bne $8cde	                bne gotROMID
205	.8cd5	88		dey		                dey             ; go back to the got char
206	.8cd6	20 36 86	jsr $8636	                jsr parseNumberFromString ; read as number
207	.8cd9	8a		txa		                txa                       ; A = result
208	.8cda	c9 10		cmp #$10	                cmp #$10
209	.8cdc	b0 d3		bcs $8cb1	                bcs badIdError  ; bad id if >15

211	.8cde					gotROMID:
212						                ; +4 = romid
213	.8cde	8d f1 02	sta $02f1	                sta sramWorkspace.bank

215						                ; clear +1 bit 6 - indicate valid rom id?
216	.8ce1	a9 40		lda #$40	                lda #$40
217	.8ce3	1c ee 02	trb $02ee	                trb sramWorkspace.type
218	.8ce6	b8		clv		                clv             ; V=0

220	.8ce7					done:
221	.8ce7	4c be f3	jmp $f3be	                jmp skipSpacesAndCheckForCRInStringInput
222						                .endproc

224						;-------------------------------------------------------------------------

226	.8cea					starSRDATAOrStarSRROM:
227	.8cea	48		pha		                pha
228	.8ceb	20 bc 8c	jsr $8cbc	                jsr readROMID
229	.8cee	70 23		bvs $8d13	                bvs jmpBadCommandError8CD6 ; taken if invalid ROM ID
230	.8cf0	d0 21		bne $8d13	                bne jmpBadCommandError8CD6 ; taken if bad command line
231						                                           ; contents
232	.8cf2	68		pla		                pla

234						                ; $80 if *SRDATA; $00 if *SRROM
238	.8cf3	0a		asl a		                asl a
239	.8cf4	8d ee 02	sta $02ee	                sta sramWorkspace.type
241	.8cf7	20 88 8c	jsr $8c88	                jsr checkROMID
242	.8cfa	b0 b5		bcs $8cb1	                bcs badIdError  ; taken if bank could never be used
243						                                ; with pseudo addressing
244	.8cfc	d0 06		bne $8d04	                bne toggleModeAndInitBank ; taken if switching to other bank mode

246						                ; If bank mode didn't change, but there's nothing in
247						                ; the bank already, set up the dummy ROM header for
248						                ; it.
249	.8cfe	1d a1 02	ora $02a1,x	                ora romInformationTable,x
250	.8d01	f0 0a		beq $8d0d	                beq initBank
251	.8d03	60		rts		                rts

253	.8d04					toggleModeAndInitBank:
254	.8d04	ad de df	lda $dfde	                lda hazel.sramBankModes
255	.8d07	5d 89 8f	eor $8f89,x	                eor sramBank4567ModeMasks-4,x
256	.8d0a	8d de df	sta $dfde	                sta hazel.sramBankModes

258	.8d0d					initBank:
259	.8d0d	20 87 8f	jsr $8f87	                jsr setROMXType6502
260	.8d10	4c 9f f8	jmp $f89f	                jmp initDummyROMHeader

262						;-------------------------------------------------------------------------

264	.8d13					jmpBadCommandError8CD6:
265	.8d13	4c 60 fb	jmp $fb60	                jmp badCommandError

267						;-------------------------------------------------------------------------

269	.8d16					L8CD9:
270	.8d16	20 27 8d	jsr $8d27	                jsr L8CEA
271	.8d19	b0 0b		bcs $8d26	                bcs locret_8CE9
272	.8d1b	20 69 f8	jsr $f869	                jsr transferBetweenSidewaysRAMAndRAM
273	.8d1e	8c f2 02	sty $02f2	                sty sramWorkspace.sramAddress+0
274	.8d21	b5 01		lda $01,x	                lda 1,x
275	.8d23	8d f3 02	sta $02f3	                sta sramWorkspace.sramAddress+1

277	.8d26					locret_8CE9:
278	.8d26	60		rts		                rts

281						;-------------------------------------------------------------------------

283	.8d27					L8CEA:
284						                ; get sram transfer sram pointer address in X - src if
285						                ; reading from sideways RAM, dest if writing to
286						                ; sideways RAM
287	.8d27	a2 b0		ldx #$b0	                ldx #sramTransferPointers.src
288	.8d29	2c ee 02	bit $02ee	                bit sramWorkspace.type
289	.8d2c	10 02		bpl $8d30	                bpl +           ; taken if reading from sideways RAM
290	.8d2e	a2 b2		ldx #$b2	                ldx #sramTransferPointers.dest
291	.8d30					+
292	.8d30	74 00		stz $00,x	                stz 0,x
293	.8d32	ac f2 02	ldy $02f2	                ldy sramWorkspace.sramAddress+0 ; sram address LSB
294	.8d35	98		tya		                tya                        ; Y=sram address LSB
295	.8d36	18		clc		                clc
296	.8d37	6d ef 02	adc $02ef	                adc sramWorkspace.length+0 ; form end address LSB
297	.8d3a	8d ef 02	sta $02ef	                sta sramWorkspace.length+0
298	.8d3d	ad f3 02	lda $02f3	                lda sramWorkspace.sramAddress+1 ; sram address MSB
299	.8d40	95 01		sta $01,x	                sta 1,x                    ;
300	.8d42	6d f0 02	adc $02f0	                adc sramWorkspace.length+1 ; form end address MSB
301	.8d45	8d f0 02	sta $02f0	                sta sramWorkspace.length+1
302	.8d48	38		sec		                sec
303	.8d49	20 9f 8f	jsr $8f9f	                jsr initSRAMTransferDataPointer
304	.8d4c					L8D0F:
305	.8d4c	cc ef 02	cpy $02ef	                cpy sramWorkspace.length+0
306	.8d4f	d0 08		bne $8d59	                bne L8D1C
307	.8d51	b5 01		lda $01,x	                lda 1,x
308	.8d53	cd f0 02	cmp $02f0	                cmp sramWorkspace.length+1
309	.8d56	d0 01		bne $8d59	                bne L8D1C
310	.8d58	60		rts		                rts

312	.8d59					L8D1C:
313	.8d59	2c ee 02	bit $02ee	                bit sramWorkspace.type
314	.8d5c	50 32		bvc $8d90	                bvc L8D53       ; taken if absolute addressing
315	.8d5e	b5 01		lda $01,x	                lda 1,x         ; get sideways RAM pointer
316	.8d60	c9 c0		cmp #$c0	                cmp #>(dataBankStart+dataBankSize) ; gone past end of bank?
317	.8d62	90 2c		bcc $8d90	                bcc L8D53       ; taken if not past end of bank
318	.8d64	a9 80		lda #$80	                lda #>dataBankStart
319	.8d66	95 01		sta $01,x	                sta 1,x                    ; reset pointer MSB
320	.8d68	ee f1 02	inc $02f1	                inc sramWorkspace.bank ; move to next bank
321	.8d6b	ad f1 02	lda $02f1	                lda sramWorkspace.bank
322	.8d6e	c9 08		cmp #$08	                cmp #8
323	.8d70	b0 2e		bcs $8da0	                bcs jmpBadAddressError ; bad address error if definitely past end of pseudo-addressable area
324	.8d72	da		phx		                phx
325	.8d73	20 88 8c	jsr $8c88	                jsr checkROMID  ; perform other ROM ID checks
326	.8d76	d0 28		bne $8da0	                bne jmpBadAddressError ; bad address error if bad
327	.8d78	fa		plx		                plx
328	.8d79	a0 10		ldy #$10	                ldy #<dataBankStart

330						                ; Subtract dataBankSize from count of bytes remaining
331	.8d7b	ad ef 02	lda $02ef	                lda sramWorkspace.length+0
332	.8d7e	38		sec		                sec
333	.8d7f	e9 f0		sbc #$f0	                sbc #<dataBankSize
334	.8d81	8d ef 02	sta $02ef	                sta sramWorkspace.length+0
335	.8d84	ad f0 02	lda $02f0	                lda sramWorkspace.length+1
336	.8d87	e9 3f		sbc #$3f	                sbc #>dataBankSize
337	.8d89	8d f0 02	sta $02f0	                sta sramWorkspace.length+1
338	.8d8c	18		clc		                clc
339	.8d8d	20 9f 8f	jsr $8f9f	                jsr initSRAMTransferDataPointer

341	.8d90					L8D53:
342	.8d90	ad f1 02	lda $02f1	                lda sramWorkspace.bank
343	.8d93	18		clc		                clc

345	.8d94					locret_8D57:
346	.8d94	60		rts		                rts

348						;-------------------------------------------------------------------------

350	.8d95					parse16BitHexAddressFromCommandLine:
351	.8d95	20 74 95	jsr $9574	                jsr parseHexAddressFromCommandLine
352	.8d98					checkParameterBlockAddressIs16Bit:
353	.8d98	bd ef 02	lda $02ef,x	                lda sramWorkspace.length+0,x
354	.8d9b	1d f0 02	ora $02f0,x	                ora sramWorkspace.length+1,x
355	.8d9e	f0 f4		beq $8d94	                beq locret_8D57

357	.8da0					jmpBadAddressError:
358	.8da0	4c 64 95	jmp $9564	                jmp badAddressError

360						;-------------------------------------------------------------------------
361						;
362						; Read I from command line. From Master Compact app note: ``A facility
363						; to load an SRAM image and update the MOS ROM type table has been
364						; added. An "I" should be added to the *SRLOAD command.''
365						;
367	.8da3					readImmediateFlag:
368	.8da3	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
369	.8da6	29 df		and #$df	                and #$DF
370	.8da8	c9 49		cmp #$49	                cmp #'I'
371	.8daa	d0 0d		bne $8db9	                bne L8D7C
372	.8dac	c8		iny		                iny
373	.8dad	ad ee 02	lda $02ee	                lda sramWorkspace.type
374	.8db0	c9 80		cmp #$80	                cmp #$80
375	.8db2	d0 3d		bne $8df1	                bne jmpBadCommandError8DB4 ; "Bad command" if not *SRLOAD
376	.8db4	09 20		ora #$20	                ora #$20                   ; set bit 5 to indicate I
377	.8db6	8d ee 02	sta $02ee	                sta sramWorkspace.type

379	.8db9					L8D7C:
380	.8db9	4c be f3	jmp $f3be	                jmp skipSpacesAndCheckForCRInStringInput

383						;-------------------------------------------------------------------------
384						;
385						; C=0 for *SRREAD
386						;
387	.8dbc					starSRREADOrStarSRWRITE:
391	.8dbc	0a		asl a		                asl a
392	.8dbd	8d ee 02	sta $02ee	                sta sramWorkspace.type

395	.8dc0	a2 09		ldx #$09	                ldx #sramWorkspace.dataAddress-osfileParameterBlock
396	.8dc2	20 74 95	jsr $9574	                jsr parseHexAddressFromCommandLine
397	.8dc5	20 91 8f	jsr $8f91	                jsr checkForPlusInCommandLine
398	.8dc8	a2 02		ldx #$02	                ldx #sramWorkspace.length-osfileParameterBlock
399	.8dca	20 74 95	jsr $9574	                jsr parseHexAddressFromCommandLine
400	.8dcd	70 10		bvs $8ddf	                bvs L8DA2 ; taken if + encountered, so +2 is already the length

402						                ; sramWorkspace.length is actually the end address -
403						                ; substract start address to turn it into the length.
404	.8dcf	a2 fc		ldx #$fc	                ldx #$FC

406	.8dd1					L8D94:
407	.8dd1	bd f3 01	lda $01f3,x	                lda sramWorkspace.length-$FC,x
408	.8dd4	fd fa 01	sbc $01fa,x	                sbc sramWorkspace.dataAddress-$FC,x
409	.8dd7	9d f3 01	sta $01f3,x	                sta sramWorkspace.length-$FC,x
410	.8dda	e8		inx		                inx
411	.8ddb	d0 f4		bne $8dd1	                bne L8D94
412	.8ddd	90 c1		bcc $8da0	                bcc jmpBadAddressError ; taken if end<start

414	.8ddf					L8DA2:
415						                ; Check length is a 16 bit quantity
416	.8ddf	a2 02		ldx #$02	                ldx #sramWorkspace.length-osfileParameterBlock
417	.8de1	20 98 8d	jsr $8d98	                jsr checkParameterBlockAddressIs16Bit

419						                ; Parse SRAM address
420	.8de4	a2 05		ldx #$05	                ldx #sramWorkspace.sramAddress-osfileParameterBlock
421	.8de6	20 95 8d	jsr $8d95	                jsr parse16BitHexAddressFromCommandLine

423						                ; Read ROM ID
424	.8de9	20 bc 8c	jsr $8cbc	                jsr readROMID

427	.8dec	20 a3 8d	jsr $8da3	                jsr readImmediateFlag
429	.8def	f0 03		beq $8df4	                beq doSidewaysRAMBlockTransfer

431	.8df1					jmpBadCommandError8DB4:
432	.8df1	4c 60 fb	jmp $fb60	                jmp badCommandError

434	.8df4					doSidewaysRAMBlockTransfer:
435	.8df4	08		php		                php
436	.8df5	20 53 8c	jsr $8c53	                jsr convertSidewaysRAMPseudoAddress
437	.8df8	f0 03		beq $8dfd	                beq L8DC0
438	.8dfa	20 b1 8c	jsr $8cb1	                jsr badIdError  ; should be a jmp; will never return
439	.8dfd					L8DC0:
440	.8dfd	20 7d 8f	jsr $8f7d	                jsr L8F40
448	.8e00	20 16 8d	jsr $8d16	                jsr L8CD9
449	.8e03	28		plp		                plp
453	.8e04	4c f4 f8	jmp $f8f4	                jmp LF8D1

456						;-------------------------------------------------------------------------

481						;-------------------------------------------------------------------------

483	.8e07					starSRLOADOrStarSRSAVE:
487	.8e07	0a		asl a		                asl a
488	.8e08	8d ee 02	sta $02ee	                sta sramWorkspace.type
490	.8e0b	4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
491	.8e0e	86 f2		stx $f2		                stx stringInputBufferAddress
492	.8e10	84 f3		sty $f3		                sty stringInputBufferAddress+1
493	.8e12	8e ef 02	stx $02ef	                stx sramWorkspace.length+0
494	.8e15	8c f0 02	sty $02f0	                sty sramWorkspace.length+1
495	.8e18	a0 00		ldy #$00	                ldy #0
496	.8e1a	20 2c f3	jsr $f32c	                jsr gsinitForFilenameParsing

498	.8e1d					L8DE0:
499	.8e1d	20 3e f3	jsr $f33e	                jsr gsreadEntryPoint
500	.8e20	90 fb		bcc $8e1d	                bcc L8DE0
501	.8e22	a2 05		ldx #$05	                ldx #5
502	.8e24	20 95 8d	jsr $8d95	                jsr parse16BitHexAddressFromCommandLine
503	.8e27	2c ee 02	bit $02ee	                bit sramWorkspace.type
504	.8e2a	30 1e		bmi $8e4a	                bmi L8E0D
505	.8e2c	20 91 8f	jsr $8f91	                jsr checkForPlusInCommandLine
506	.8e2f	a2 07		ldx #$07	                ldx #7
507	.8e31	20 95 8d	jsr $8d95	                jsr parse16BitHexAddressFromCommandLine
508	.8e34	70 14		bvs $8e4a	                bvs L8E0D
509	.8e36	38		sec		                sec
510	.8e37	a2 fe		ldx #$fe	                ldx #$FE

512	.8e39					L8DFC:
513	.8e39	bd f6 01	lda $01f6,x	                lda sramWorkspace.sramAddress+2-$FE,x
514	.8e3c	fd f4 01	sbc $01f4,x	                sbc sramWorkspace.sramAddress+0-$FE,x
515	.8e3f	9d f6 01	sta $01f6,x	                sta sramWorkspace.sramAddress+2-$FE,x
516	.8e42	e8		inx		                inx
517	.8e43	d0 f4		bne $8e39	                bne L8DFC
518	.8e45	b0 03		bcs $8e4a	                bcs L8E0D
519	.8e47	4c a0 8d	jmp $8da0	                jmp jmpBadAddressError

521						;-------------------------------------------------------------------------

523	.8e4a					L8E0D:
524	.8e4a	20 bc 8c	jsr $8cbc	                jsr readROMID
525	.8e4d	9c f8 02	stz $02f8	                stz sramWorkspace.dataAddress+2
529	.8e50	a2 00		ldx #$00	                ldx #0
532	.8e52	20 a3 8d	jsr $8da3	                jsr readImmediateFlag
534	.8e55	29 df		and #$df	                and #$DF
538	.8e57	c9 51		cmp #$51	                cmp #'Q'
542	.8e59	d0 02		bne $8e5d	                bne L8E20
553	.8e5b	ca		dex		                dex
554	.8e5c	c8		iny		                iny

557	.8e5d					L8E20:
558	.8e5d	8e f9 02	stx $02f9	                stx sramWorkspace.dataAddress+3
559	.8e60	ae 34 fe	ldx $fe34	                ldx ACCCON
563	.8e63	20 a3 8d	jsr $8da3	                jsr readImmediateFlag
565	.8e66	f0 16		beq $8e7e	                beq L8E41
566	.8e68	4c f1 8d	jmp $8df1	                jmp jmpBadCommandError8DB4

568						;-------------------------------------------------------------------------

570	.8e6b					osword43:
571	.8e6b	ae 34 fe	ldx $fe34	                ldx ACCCON
572	.8e6e	20 47 ee	jsr $ee47	                jsr selectHAZEL
573	.8e71	9c c6 df	stz $dfc6	                stz hazel.tempFSFlag
574	.8e74	a0 0b		ldy #$0b	                ldy #$B

576	.8e76					L8E39:
577	.8e76	b1 f0		lda ($f0),y	                lda (originalX),y
578	.8e78	99 ee 02	sta $02ee,y	                sta sramWorkspace.type,y
579	.8e7b	88		dey		                dey
580	.8e7c	10 f8		bpl $8e76	                bpl L8E39

586	.8e7e					L8E41:
587	.8e7e	08		php		                php
588	.8e7f	da		phx		                phx
589	.8e80	20 53 8c	jsr $8c53	                jsr convertSidewaysRAMPseudoAddress
590	.8e83	f0 03		beq $8e88	                beq L8E4B
591	.8e85	4c b1 8c	jmp $8cb1	                jmp badIdError
592	.8e88					L8E4B:
593	.8e88	ad f9 02	lda $02f9	                lda sramWorkspace.dataAddress+3
594	.8e8b	30 0b		bmi $8e98	                bmi L8E5B
595	.8e8d	0d f8 02	ora $02f8	                ora sramWorkspace.dataAddress+2
596	.8e90	d0 1d		bne $8eaf	                bne L8E72
597	.8e92	a9 02		lda #$02	                lda #2
598	.8e94	a0 dd		ldy #$dd	                ldy #>hazel.ddxx
599	.8e96	80 0b		bra $8ea3	                bra L8E66

601						;-------------------------------------------------------------------------

603	.8e98					L8E5B:
604	.8e98	20 70 f2	jsr $f270	                jsr osbyte84
605	.8e9b	98		tya		                tya
606	.8e9c	38		sec		                sec
607	.8e9d	ed 44 02	sbc $0244	                sbc oshwm
608	.8ea0	ac 44 02	ldy $0244	                ldy oshwm

610	.8ea3					L8E66:
611	.8ea3	9c f6 02	stz $02f6	                stz sramWorkspace.dataAddress+0
612	.8ea6	8c f7 02	sty $02f7	                sty sramWorkspace.dataAddress+1
613	.8ea9	9c f8 02	stz $02f8	                stz sramWorkspace.dataAddress+2
614	.8eac	8d f9 02	sta $02f9	                sta sramWorkspace.dataAddress+3

616	.8eaf					L8E72:
617	.8eaf	2c ee 02	bit $02ee	                bit sramWorkspace.type
618	.8eb2	10 38		bpl $8eec	                bpl L8EAF
619	.8eb4	a9 40		lda #$40	                lda #findOpenForRead
620	.8eb6	20 58 8f	jsr $8f58	                jsr sramOpenFile

622	.8eb9					L8E7C:
623	.8eb9	38		sec		                sec
624	.8eba	20 2a 8f	jsr $8f2a	                jsr L8EED
625	.8ebd	a9 04		lda #$04	                lda #gbpbGetBytesCurrentPTR
626	.8ebf	20 51 8f	jsr $8f51	                jsr sramOSGBPB
627	.8ec2	08		php		                php
628	.8ec3	90 0e		bcc $8ed3	                bcc L8E96
629	.8ec5	a2 fe		ldx #$fe	                ldx #$FE

631	.8ec7					L8E8A:
632	.8ec7	bd f1 01	lda $01f1,x	                lda sramWorkspace.length+0-$FE,x

634	.8eca					L8E8D:
635	.8eca	fd ce de	sbc $dece,x	                sbc hazel.moveOSGBPB+OSGBPBParameterBlock.count+0-$fe,x
636	.8ecd	9d f1 01	sta $01f1,x	                sta sramWorkspace.length+0-$FE,x
637	.8ed0	e8		inx		                inx
638	.8ed1	d0 f4		bne $8ec7	                bne L8E8A

640	.8ed3					L8E96:
641	.8ed3	20 16 8d	jsr $8d16	                jsr L8CD9
642	.8ed6	28		plp		                plp
643	.8ed7	90 e0		bcc $8eb9	                bcc L8E7C

645	.8ed9					L8E9C:
646	.8ed9	ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle
647	.8edc	9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
648	.8edf	a9 00		lda #$00	                lda #0
649	.8ee1	20 ce ff	jsr $ffce	                jsr OSFIND
650	.8ee4	68		pla		                pla
651	.8ee5	8d 34 fe	sta $fe34	                sta ACCCON
652	.8ee8	28		plp		                plp
656	.8ee9	4c f4 f8	jmp $f8f4	                jmp LF8D1

659						;-------------------------------------------------------------------------

661	.8eec					L8EAF:
662	.8eec	a9 80		lda #$80	                lda #findOpenForWrite
663	.8eee	20 58 8f	jsr $8f58	                jsr sramOpenFile

665	.8ef1					L8EB4:
666	.8ef1	38		sec		                sec
667	.8ef2	a2 fe		ldx #$fe	                ldx #$FE

669	.8ef4					L8EB7:
670	.8ef4	bd f6 01	lda $01f6,x	                lda sramWorkspace.sramAddress+2-$FE,x
671	.8ef7	9d b2 ff	sta $ffb2,x	                sta @w sramTransferPointers-$fe,x
672	.8efa	fd fa 01	sbc $01fa,x	                sbc sramWorkspace.dataAddress+2-$FE,x
673	.8efd	9d f6 01	sta $01f6,x	                sta sramWorkspace.sramAddress+2-$FE,x
674	.8f00	e8		inx		                inx
675	.8f01	d0 f1		bne $8ef4	                bne L8EB7
676	.8f03	0d f4 02	ora $02f4	                ora sramWorkspace.sramAddress+2
677	.8f06	08		php		                php
678	.8f07	20 2a 8f	jsr $8f2a	                jsr L8EED
679	.8f0a	20 16 8d	jsr $8d16	                jsr L8CD9
680	.8f0d	a9 02		lda #$02	                lda #gbpbPutBytesCurrentPTR
681	.8f0f	20 51 8f	jsr $8f51	                jsr sramOSGBPB
682	.8f12	28		plp		                plp
683	.8f13	90 c4		bcc $8ed9	                bcc L8E9C
684	.8f15	f0 c2		beq $8ed9	                beq L8E9C
685	.8f17	80 d8		bra $8ef1	                bra L8EB4

687						;-------------------------------------------------------------------------

696						;-------------------------------------------------------------------------
697						;
698						; OSBYTE 68 (&44) - Test RAM presence [MasRef D.2-28]
699						;
700	.8f19					osbyte44:
701	.8f19	a9 00		lda #$00	                lda #0
702	.8f1b	a2 07		ldx #$07	                ldx #7
703	.8f1d					osbyte44Loop:
704	.8f1d	48		pha		                pha
705	.8f1e	20 bd f8	jsr $f8bd	                jsr isBankROM
706	.8f21	68		pla		                pla
707	.8f22	2a		rol a		                rol a
708	.8f23	ca		dex		                dex
709	.8f24	e0 04		cpx #$04	                cpx #4
710	.8f26	b0 f5		bcs $8f1d	                bcs osbyte44Loop
711	.8f28	aa		tax		                tax
712	.8f29	60		rts		                rts

714						;-------------------------------------------------------------------------

716	.8f2a					L8EED:
717	.8f2a	ad d4 df	lda $dfd4	                lda hazel.moveSrcHandle
718	.8f2d	8d c7 df	sta $dfc7	                sta hazel.moveOSGBPB.handle
719	.8f30	a2 01		ldx #$01	                ldx #1

721	.8f32					L8EF5:
722	.8f32	bd f6 02	lda $02f6,x	                lda sramWorkspace.dataAddress+0,x
723	.8f35	9d c8 df	sta $dfc8,x	                sta hazel.moveOSGBPB.addr,x
724	.8f38	bd f8 02	lda $02f8,x	                lda sramWorkspace.dataAddress+2,x
725	.8f3b	b0 02		bcs $8f3f	                bcs L8F02
726	.8f3d	b5 b0		lda $b0,x	                lda sramTransferPointers.src,x

728	.8f3f					L8F02:
729	.8f3f	9d cc df	sta $dfcc,x	                sta hazel.moveOSGBPB.numBytes,x
730	.8f42	9d ef 02	sta $02ef,x	                sta sramWorkspace.length+0,x
731	.8f45	a9 ff		lda #$ff	                lda #$FF
732	.8f47	9d ca df	sta $dfca,x	                sta hazel.moveOSGBPB.addr+2,x ; address is in I/O processor
733	.8f4a	9e ce df	stz $dfce,x	                stz hazel.moveOSGBPB.numBytes+2,x ; size is 16-bit quantity
734	.8f4d	ca		dex		                dex
735	.8f4e	10 e2		bpl $8f32	                bpl L8EF5
736	.8f50	60		rts		                rts

739						;-------------------------------------------------------------------------

741	.8f51					sramOSGBPB:
742	.8f51	a2 c7		ldx #$c7	                ldx #<hazel.moveOSGBPB
743	.8f53	a0 df		ldy #$df	                ldy #>hazel.moveOSGBPB
744	.8f55	4c d1 ff	jmp $ffd1	                jmp OSGBPB

747						;-------------------------------------------------------------------------

749	.8f58					sramOpenFile:
750	.8f58	0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
751	.8f5b	ae ef 02	ldx $02ef	                ldx sramWorkspace.length+0
752	.8f5e	ac f0 02	ldy $02f0	                ldy sramWorkspace.length+1
753	.8f61	20 ce ff	jsr $ffce	                jsr OSFIND
754	.8f64	aa		tax		                tax
755	.8f65	d0 13		bne $8f7a	                bne sramFileFound
756	.8f67	20 ff ae	jsr $aeff	                jsr doFollowingError
757	>8f6a	d6				                .byte $D6
758	>8f6b	46 69 6c 65 20 6e 6f 74		                .text "File not found"
	>8f73	20 66 6f 75 6e 64
759	>8f79	00				                .byte 0

761	.8f7a					sramFileFound:
762	.8f7a	8d d4 df	sta $dfd4	                sta hazel.moveSrcHandle
763	.8f7d					L8F40:
764	.8f7d	ae f1 02	ldx $02f1	                ldx sramWorkspace.bank ; ROM number of interest
765	.8f80	2c ee 02	bit $02ee	                bit sramWorkspace.type
766	.8f83	10 07		bpl $8f8c	                bpl rts8F4F ; taken if reading
767	.8f85	70 05		bvs $8f8c	                bvs rts8F4F ; taken if pseudo addressing

769						                ; writing, absolute addressing
770	.8f87					setROMXType6502:
771	.8f87	a9 02		lda #$02	                lda #romType6502
772	.8f89	9d a1 02	sta $02a1,x	                sta romInformationTable,x

774	.8f8c					rts8F4F:
775	.8f8c	60		rts		                rts

778						;-------------------------------------------------------------------------

780	.8f8d					sramBank4567ModeMasks:
781	>8f8d	01				                .byte 1         ; bank 4
782	>8f8e	02				                .byte 2         ; bank 5
783	>8f8f	04				                .byte 4         ; bank 6
784	>8f90	08				                .byte 8         ; bank 7

786						;-------------------------------------------------------------------------
787						;
788						; Check to see if next char on command line is +.
789						;
790						; Entry:
791						;
792						; (stringInputBufferAddress),y = next char on command line
793						;
794						; Exit:
795						;
796						; V=0 if not +
797						;
798						; V=1 if +. (stringInputBufferAddress),y = next non-space after the +

800	.8f91					checkForPlusInCommandLine:
801	.8f91	b8		clv		                clv
802	.8f92	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
803	.8f94	c9 2b		cmp #$2b	                cmp #'+'
804	.8f96	d0 06		bne $8f9e	                bne locret_8F61
805	.8f98	2c 70 e3	bit $e370	                bit valueFF
806	.8f9b	20 bd f3	jsr $f3bd	                jsr incAndSkipSpaces

808	.8f9e					locret_8F61:
809	.8f9e	60		rts		                rts

812						;-------------------------------------------------------------------------
813						;
814						; Adjust sram transfer data pointer so that the same Y register can be
815						; used for both sram pointer and data pointer.
816						;
817						; Entry:
818						;
819						; X = offset of sram transfer sram pointer (0=src, 2=dest)
820						; Y = value to subtract from sram transfer data pointer
821						;
822						; C=1 = initialise sram transfer data pointer from data address
823						;
824						; Exit:
825						;
826						; sram transfer data pointer has had Y subtracted
827						;
828	.8f9f					initSRAMTransferDataPointer: .proc
829	.8f9f	da		phx		                phx
830						                ; select the non-sram data pointer
831	.8fa0	8a		txa		                txa
832	.8fa1	49 02		eor #$02	                eor #sramTransferPointers.src^sramTransferPointers.dest
833	.8fa3	aa		tax		                tax
834	.8fa4	90 0a		bcc $8fb0	                bcc subtractY

836						                ; store data address in the non-sram pointer
837	.8fa6	ad f6 02	lda $02f6	                lda sramWorkspace.dataAddress+0
838	.8fa9	95 00		sta $00,x	                sta 0,x
839	.8fab	ad f7 02	lda $02f7	                lda sramWorkspace.dataAddress+1
840	.8fae	95 01		sta $01,x	                sta 1,x

842	.8fb0					subtractY:
843	.8fb0	8c ed 02	sty $02ed	                sty sramWorkspace.temp ; sram address LSB
844	.8fb3	b5 00		lda $00,x	                lda 0,x
845	.8fb5	38		sec		                sec
846	.8fb6	ed ed 02	sbc $02ed	                sbc sramWorkspace.temp
847	.8fb9	95 00		sta $00,x	                sta 0,x
848	.8fbb	b0 02		bcs $8fbf	                bcs +
849	.8fbd	d6 01		dec $01,x	                dec 1,x
850	.8fbf					+
851	.8fbf	fa		plx		                plx
852	.8fc0	60		rts		                rts
853						                .endproc

855						;-------------------------------------------------------------------------
856						;
857						; Get bank mode: pseudo, or absolute.
858						;
859						; (Only banks 4-7 can be used with pseudo addressing, but you can test
860						; any.)
861						;
862						; Entry:
863						;
864						; X = bank of interest
865						;
866						; Exit:
867						;
868						; A=$00 if absolute (C=1 as well, if bank could only ever be absolute)
869						;
870						; A=$40 if pseudo

872	.8fc1					sramGetBankMode:
873	.8fc1	e0 04		cpx #$04	                cpx #4
874	.8fc3	90 1c		bcc $8fe1	                bcc bankModeIsInherentlyAbsolute ; taken if <4
875	.8fc5	e0 08		cpx #$08	                cpx #8
876	.8fc7	b0 18		bcs $8fe1	                bcs bankModeIsInherentlyAbsolute ; taken if >=8

878	.8fc9					osbyte45:
879						                ; When entered as OSBYTE $45, the X register is bogus,
880						                ; so the table lookup could read junk and the AND
881						                ; could end up meaningless. But that doesn't matter:
882						                ; it's only the value in X on exit that's important.
883	.8fc9	ac 34 fe	ldy $fe34	                ldy ACCCON
884	.8fcc	20 47 ee	jsr $ee47	                jsr selectHAZEL ; engage HAZEL
885	.8fcf	bd 89 8f	lda $8f89,x	                lda sramBank4567ModeMasks-4,x ; acquire mask: 1/2/4/8 for banks
886						                                 ; 4/5/6/7 respectively
887	.8fd2	ae de df	ldx $dfde	                ldx hazel.sramBankModes ; load current settings into X, in case this is OSBYTE $45
888	.8fd5	2d de df	and $dfde	                and hazel.sramBankModes
889	.8fd8	f0 02		beq $8fdc	                beq +           ; taken with A=$00 if bank of interest
890						                                ; is absolute
891	.8fda	a9 40		lda #$40	                lda #$40        ; indicate pseudo
892	.8fdc					+
893	.8fdc	8c 34 fe	sty $fe34	                sty ACCCON
894	.8fdf	18		clc		                clc
895	.8fe0	60		rts		                rts

897	.8fe1					bankModeIsInherentlyAbsolute:
898	.8fe1	38		sec		                sec
899	.8fe2	a9 00		lda #$00	                lda #0
900	.8fe4	60		rts		                rts

:5	;******  Return to file: src/terminal.s65

967						                .include "osbyte_osword_table.s65"

:9	;******  Processing file: src/osbyte_osword_table.s65

1						; OSBYTE Dispatch Table
2						; =====================

4						; TODO structure probably the same as
5						; https://tobylobster.github.io/mos/mos/S-s15.html#SP1...

7						; entry:
8						;
9						; A = OSBYTE A
10						;
11						; X = OSBYTE X
12						;
13						; Y = OSBYTE Y
14						;
15						; ?originalA, ?originalX, ?originalY = OSBYTE arguments
16						;
17						; C=1
18						;
19						; N/Z set as per X
20						;

22	.8fe5					osbyteAndOSWORDRoutineTable:
23						                ;Display MOS version D.2-18
24	>8fe5	1e f0				                .word osbyte00

26						                ;Write user flag D.2-18
27	>8fe7	7f f1				                .word osbyte01

29						                ;Specify input stream D.2-18
33	>8fe9	50 ed				                .word osbyte02

36						                ;Specify output stream D.2-19
37	>8feb	54 f1				                .word osbyte03

39						                ;Enable/disable cursor editing
40	>8fed	87 f1				                .word osbyte04

42						                ;Write printer driver type D.2-20
43	>8fef	6d f1				                .word osbyte05

45						                ;Write printer ignore character D.2-21
46	>8ff1	64 f1				                .word osbyte06

48						                ;Write RS423 receive rate D.2-21
52	>8ff3	09 ed				                .word osbyte07

55						                ;Write RS423 transmit rate D.2-22
59	>8ff5	07 ed				                .word osbyte08

62						                ;Write duration of first colour D.2-22
63	>8ff7	2e ed				                .word osbyte09

65						                ;Write duration of second colour D.2-22
66	>8ff9	30 ed				                .word osbyte0A

68						                ;Write keyboard auto-repeat delay D.2-22
69	>8ffb	85 f1				                .word osbyte0B

71						                ;Write keyboard auto-repeat rate D.2-23
72	>8ffd	83 f1				                .word osbyte0C

74						                ;Disable event D.2-23
75	>8fff	76 ed				                .word osbyte0D

77						                ;Enable event D.2-24
78	>9001	77 ed				                .word osbyte0E

80						                ;Flush buffer D.2-24
81	>9003	70 ea				                .word osbyte0F

83						                ;Write number of ADC channels D.2-25
87	>9005	83 ed				                .word osbyte10

90						                ;Write next ADC channel to be sampled D.2-25
94	>9007	76 e7				                .word osbyte11

97						                ;Reset soft keys D.2-26
98	>9009	d0 f1				                .word osbyte12

100						                ;Wait for vertical sync D.2-26
101	>900b	a6 f1				                .word osbyte13

103						                ;Restore default font definitions D.2-26
104	>900d	d2 f2				                .word osbyte14

106						                ;Flush selected buffer D.2-27
107	>900f	7c ea				                .word osbyte15

109						                ;Increment ROM polling semaphore D.2-27
110	>9011	e7 f2				                .word osbyte16

112						                ;Decrement ROM polling semaphore D.2-27
113	>9013	eb f2				                .word osbyte17

115						                ; Reserved
116	>9015	11 ee				                .word osbyteUnused

118						                ;Restore a group of font definitions D.2-28
119	>9017	d8 f2				                .word selectTerminalROMAndOSBYTE19

121						                ; Test RAM presence D.2-28
125	>9019	0d f9				                .word selectTerminalROMAndOSBYTE44

128						                ; Test pseudo/absolute use of bank D.2-29
132	>901b	13 f9				                .word selectTerminalROMAndOSBYTE45

135						                ;Write 1MHz bus selection status D.2-29
136	>901d	2b ef				                .word osbyte6B

138						                ;Write usage of main/shadow memory D.2-30
139	>901f	2f ef				                .word osbyte6C

141						                ;Make temporary Filing System permanent D.2-30
142	>9021	c5 f2				                .word osbyte6D

144						                ;Unused
145	>9023	11 ee				                .word osbyteUnused

147						                ;Unused
148	>9025	11 ee				                .word osbyteUnused

150						                ;Select main/shadow memory for VDU access D.2-31
151	>9027	e5 ed				                .word osbyte70

153						                ;Select main/shadow memory for display D.2-31
154	>9029	f5 ed				                .word osbyte71

156						                ;Write usage of shadow memory D.2-31
157	>902b	69 f1				                .word osbyte72

159						                ;Unused
160	>902d	aa ff				                .word rtsFFAA

162						                ;Unused
163	>902f	aa ff				                .word rtsFFAA

165						                ;Read VDU status D.2-32
166	>9031	64 f0				                .word osbyte75

168						                ;Reflect keyboard status in keyboard LEDs D.2-33
169	>9033	ef f2				                .word osbyte76

171						                ;Close all *SPOOL/*SPOOLON or *EXEC files D.2-33
175	>9035	e0 ea				                .word selectTerminalROMAndOSBYTE77

178						                ;Write keys pressed information D.2-33
179	>9037	a7 f7				                .word osbyte78

181						                ;Keyboard scan D.2-33
182	>9039	9e f7				                .word callKEYV

184						                ;Keyboard scan from 16 decimal
185	>903b	ac f7				                .word osbyte7A

187						                ;Inform MOS of printer driver going dormant
188	>903d	5a ea				                .word osbyte7B

190						                ;Clear escape condition
191	>903f	fb ec				                .word osbyte7C

193						                ;Set escape condition
194	>9041	fc ec				                .word osbyte7D

196						                ;Acknowledge escape condition
197	>9043	e1 ec				                .word osbyte7E

199						                ;Check for end of file on an opened file
200	>9045	99 f2				                .word osbyte7F

202						                ;Read ADC channel or get buffer status
206	>9047	cc ed				                .word osbyte80

209						                ;Read key with time limit
210	>9049	8b ed				                .word osbyte81

212						                ;Read machine high order address
213	>904b	a2 ed				                .word osbyte82

215						                ;Read Operating System High Water Mark (OSHWM)
216	>904d	a1 f7				                .word osbyte83

218						                ;Read top of user RAM
219	>904f	70 f2				                .word osbyte84

221						                ;Read top of user RAM for given mode
222	>9051	86 f2				                .word osbyte85

224						                ;Read text cursor position
225	>9053	79 e2				                .word osbyte86

227						                ;Read screen mode and character at text cursor position
228	>9055	92 f2				                .word osbyte87

230						                ;Execute user code
231	>9057	dc ec				                .word osbyte88

238	>9059	11 ee				                .word osbyteUnused

241						                ;Insert character code into buffer
242	>905b	6a eb				                .word osbyte8A

244						                ;Write Filing System options
245	>905d	98 f2				                .word osbyte8B

250	>905f	11 ee				                .word osbyteUnused

254						                ;Select ROM Filing System
255	>9061	27 ee				                .word osbyte8C8D

257						                ;Enter language ROM
258	>9063	e9 e4				                .word osbyte8E

260						                ;Issue paged ROM service request
261	>9065	90 ee				                .word osbyte8F

263						                ;Set vertical screen shift and interlace option
264	>9067	30 f4				                .word osbyte90

266						                ;Get character from buffer
267	>9069	1f eb				                .word osbyte91

269						                ;Read from FRED (&FC00 - &FCFF)
270	>906b	3a f7				                .word osbyte92

272						                ;Write to FRED (&FC00 - &FCFF)
273	>906d	4b f4				                .word osbyte93

275						                ;Read from JIM (&FD00 - &FDFF)
276	>906f	4a f7				                .word osbyte94

278						                ;Write to JIM (&FD00 - &FDFF)
279	>9071	41 f4				                .word osbyte95

281						                ;Read from SHEILA (&FE00 - &FEFF)
282	>9073	ab ff				                .word osbyte96

284						                ;Write to SHEILA (&FE00 - &FEFF)
285	>9075	46 f4				                .word osbyte97

287						                ;Examine buffer status
288	>9077	1a eb				                .word osbyte98

290						                ;Insert character code into buffer checking for escape
294	>9079	ab eb				                .word osbyte99

297						                ;Write video ULA control register
298	>907b	0e f3				                .word osbyte9A

300						                ;Write to video ULA palette register and copy
301	>907d	1f f3				                .word osbyte9B

303						                ;Read/write serial ACIA control register and copy
307	>907f	3f ea				                .word osbyte9C

310						                ;Write byte across Tube
311	>9081	af ff				                .word osbyte9D

313						                ;reserved for the speech system
314	>9083	11 ee				                .word osbyteUnused

316						                ;reserved for the speech system
317	>9085	11 ee				                .word osbyteUnused

319						                ;Read VDU variable value
320	>9087	b0 f1				                .word osbyteA0

322						                ;Read CMOS RAM
326	>9089	1b ee				                .word osbyteA1

329						                ;Write CMOS RAM
333	>908b	21 ee				                .word osbyteA2

336						                ;reserved for applications software
337	>908d	11 ee				                .word osbyteUnused

339						                ;Check processor type
340	>908f	60 e5				                .word osbyteA4

342						                ;Read output cursor position
343	>9091	4d e2				                .word osbyteA5

345						                ;handle osbyte A6-FF
346	>9093	8c f1				                .word osbyteA6

348						                ;*LINE - not part of the above table???
349	>9095	de ec				                .word callUSERV

351						;-------------------------------------------------------------------------
352						;
353						; OSWORD dispatch table. Must follow on from the OSBYTE table.
354						;
355						; entry:
356						;
357						; A = 0th byte of parameter block
358						;
359						; X = OSWORD X
360						;
361						; Y = 0
362						;
363						; ?originalA, ?originalX, ?originalY = OSWORD arguments
364						;
365						; C=1
366						;
367						; N/Z set as per X
368						;
369	.9097					oswordRoutineTable:

371						;Read line from input stream to memory
372	>9097	e0 f0				                .word osword00

374						                ;Read system clock
375	>9099	b3 f0				                .word osword01

377						                ;Write system clock
378	>909b	c6 f0				                .word osword02

380						                ;Read interval timer
381	>909d	af f0				                .word osword03

383						                ;Write interval timer
384	>909f	c2 f0				                .word osword04

386						                ;Read byte from I/O processor memory
387	>90a1	0a f0				                .word osword05

389						                ;Write byte to I/O processor memory
390	>90a3	3e ef				                .word osword06

392						                ;Generate a sound
393	>90a5	2c f0				                .word osword07

395						                ;Define a sound envelope
396	>90a7	8d f0				                .word osword08

398						                ;Read pixel logical colour
399	>90a9	06 f2				                .word osword09

401						                ;Read a character definition
402	>90ab	2b f2				                .word osword0A

404						                ;Read the palette
405	>90ad	f5 f1				                .word osword0B

407						                ;Write the palette
408	>90af	43 f2				                .word osword0C

410						                ;Read current and previous graphics cursor positions
411	>90b1	51 f2				                .word osword0D

413						                ;Read CMOS clock
414	>90b3	82 ef				                .word selectTerminalROMAndOSWORD0E

416						                ;Write CMOS clock
420	>90b5	9e f2				                .word selectTerminalROMAndOSWORD0F

424	.90b7					osword42AndAboveRoutineTable:
425						                ; Sideways RAM Block Transfer
429	>90b7	19 f9				                .word selectTerminalROMAndOSWORD42

432						                ; Sideways RAM Load/Save
436	>90b9	1f f9				                .word selectTerminalROMAndOSWORD43

:5	;******  Return to file: src/terminal.s65

970						;-------------------------------------------------------------------------

973	.90bb					i2cTestReadEEPROMByte:
974	.90bb	da		phx		                phx
975	.90bc	5a		phy		                phy
976	.90bd	20 3b 9f	jsr $9f3b	                jsr i2cReadEEPROMByte
977	.90c0	7a		ply		                ply
978	.90c1	fa		plx		                plx
979	.90c2	60		rts		                rts

982						;-------------------------------------------------------------------------

1104						;-------------------------------------------------------------------------
1105						;
1106						; [MasRef G.5-8]
1107						;
1108	.90c3					starPRINT:
1109	.90c3	a9 c0		lda #$c0	                lda #$C0
1110	.90c5	8d c2 df	sta $dfc2	                sta hazel.fsFlags
1111	.90c8	80 12		bra $90dc	                bra L8ED2

1113						;-------------------------------------------------------------------------

1115	.90ca					starLIST:
1116	.90ca	4e c2 df	lsr $dfc2	                lsr hazel.fsFlags
1117	.90cd	9c c3 df	stz $dfc3	                stz hazel.lineNumberBCD+0
1118	.90d0	9c c4 df	stz $dfc4	                stz hazel.lineNumberBCD+1
1119	.90d3	80 04		bra $90d9	                bra L8ECF

1121						;-------------------------------------------------------------------------

1123	.90d5					starTYPE:
1124	.90d5	38		sec		                sec
1125	.90d6	6e c2 df	ror $dfc2	                ror hazel.fsFlags
1126	.90d9					L8ECF:
1127	.90d9	4e c2 df	lsr $dfc2	                lsr hazel.fsFlags
1128	.90dc					L8ED2:
1129	.90dc	9c c5 df	stz $dfc5	                stz hazel.lastCharPrinted
1130	.90df	20 b4 a9	jsr $a9b4	                jsr openFileForReading
1131	.90e2					L8ED8:
1132	.90e2	24 ff		bit $ff		                bit $FF
1133	.90e4	30 52		bmi $9138	                bmi handleESCAPEWithFileOpen
1134	.90e6	20 d7 ff	jsr $ffd7	                jsr OSBGET
1135	.90e9	b0 2e		bcs $9119	                bcs closeFile
1136	.90eb	2c c2 df	bit $dfc2	                bit hazel.fsFlags
1137	.90ee	70 05		bvs $90f5	                bvs L8EEB
1138	.90f0	48		pha		                pha
1139	.90f1	20 00 94	jsr $9400	                jsr printLineNumber
1140	.90f4	68		pla		                pla
1141	.90f5					L8EEB:
1142	.90f5	2c c2 df	bit $dfc2	                bit hazel.fsFlags
1143	.90f8	30 14		bmi $910e	                bmi L8F04
1144	.90fa	c9 0d		cmp #$0d	                cmp #$0D
1145	.90fc	f0 20		beq $911e	                beq L8F14
1146	.90fe	c9 0a		cmp #$0a	                cmp #$0A
1147	.9100	f0 1c		beq $911e	                beq L8F14
1148	.9102	8d c5 df	sta $dfc5	                sta hazel.lastCharPrinted
1149	.9105	c9 22		cmp #$22	                cmp #'"'
1150	.9107	f0 05		beq $910e	                beq L8F04
1151	.9109	20 52 98	jsr $9852	                jsr printGSREADChar
1152	.910c	80 03		bra $9111	                bra L8F07

1154	.910e					L8F04:
1155	.910e	20 ee ff	jsr $ffee	                jsr OSWRCH
1156	.9111					L8F07:
1157	.9111	20 44 91	jsr $9144	                jsr bgetAndCheckForESCAPE
1158	.9114	90 df		bcc $90f5	                bcc L8EEB
1159	.9116					printNewLineThenCloseFile:
1160	.9116	20 e7 ff	jsr $ffe7	                jsr OSNEWL
1161	.9119					closeFile:
1162	.9119	a9 00		lda #$00	                lda #$00
1163	.911b	4c ce ff	jmp $ffce	                jmp OSFIND

1165	.911e					L8F14:
1166	.911e	cd c5 df	cmp $dfc5	                cmp hazel.lastCharPrinted
1167	.9121	f0 10		beq $9133	                beq L8F29
1168	.9123	48		pha		                pha
1169	.9124	ad c5 df	lda $dfc5	                lda hazel.lastCharPrinted
1170	.9127	c9 0d		cmp #$0d	                cmp #$0D
1171	.9129	f0 13		beq $913e	                beq L8F34
1172	.912b	c9 0a		cmp #$0a	                cmp #$0A
1173	.912d	f0 0f		beq $913e	                beq L8F34
1174	.912f	68		pla		                pla
1175	.9130	8d c5 df	sta $dfc5	                sta hazel.lastCharPrinted
1176	.9133					L8F29:
1177	.9133	20 e7 ff	jsr $ffe7	                jsr OSNEWL
1178	.9136	80 aa		bra $90e2	                bra L8ED8

1180						;-------------------------------------------------------------------------
1181						;
1182						; Tidily handle ESCAPE when a file is open during *DUMP or whatever.
1183						; Prints a new line, closes the file, then does an Escape error.
1184						;
1185						; entry:
1186						;
1187						; Y = file handle
1188						;
1189	.9138					handleESCAPEWithFileOpen:
1190	.9138	20 16 91	jsr $9116	                jsr printNewLineThenCloseFile
1191	.913b	4c d3 ac	jmp $acd3	                jmp escapeError

1193						;-------------------------------------------------------------------------

1195	.913e					L8F34:
1196	.913e	68		pla		                pla
1197	.913f	9c c5 df	stz $dfc5	                stz hazel.lastCharPrinted
1198	.9142	80 cd		bra $9111	                bra L8F07

1200						;-------------------------------------------------------------------------
1201						;
1202						; Does an OSBGET and handles ESCAPE.
1203						;
1204						; entry:
1205						;
1206						; Y = file handle
1207						;
1208						; exit:
1209						;
1210						; A = byte read
1211						; C=1 if EOF
1212						; (as per OSBGET)
1213						;
1214	.9144					bgetAndCheckForESCAPE:
1215	.9144	20 d7 ff	jsr $ffd7	                jsr OSBGET
1216	.9147	24 ff		bit $ff		                bit $FF
1217	.9149	30 ed		bmi $9138	                bmi handleESCAPEWithFileOpen
1218	.914b	60		rts		                rts

1220						;-------------------------------------------------------------------------
1221						;
1222						; *DUMP [MasRef G.5-4]
1223						;
1224	.914c					starDUMP:
1225	.914c	86 f2		stx $f2		                stx stringInputBufferAddress+0
1226	.914e	84 f3		sty $f3		                sty stringInputBufferAddress+1
1227	.9150	a2 00		ldx #$00	                ldx #$00
1228	.9152	20 d5 94	jsr $94d5	                jsr clearOSFILEParameterBlockDWORD
1229	.9155	a2 04		ldx #$04	                ldx #$04
1230	.9157	20 d5 94	jsr $94d5	                jsr clearOSFILEParameterBlockDWORD
1231	.915a	a0 00		ldy #$00	                ldy #$00
1232	.915c	4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
1233	.915f	20 2c f3	jsr $f32c	                jsr gsinitForFilenameParsing
1234	.9162					L8F58:
1235	.9162	20 3e f3	jsr $f33e	                jsr gsreadEntryPoint
1236	.9165	90 fb		bcc $9162	                bcc L8F58
1237	.9167	f0 1a		beq $9183	                beq L8F79
1238	.9169	a2 00		ldx #$00	                ldx #$00
1239	.916b	20 74 95	jsr $9574	                jsr parseHexAddressFromCommandLine

1241	.916e	a2 03		ldx #$03	                ldx #$03
1242	.9170					-
1243	.9170	bd ed 02	lda $02ed,x	                lda osfileParameterBlock+0,x
1244	.9173	9d f1 02	sta $02f1,x	                sta osfileParameterBlock+4,x
1245	.9176	ca		dex		                dex
1246	.9177	10 f7		bpl $9170	                bpl -

1248	.9179	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
1249	.917c	f0 05		beq $9183	                beq L8F79
1250	.917e	a2 04		ldx #$04	                ldx #$04
1251	.9180	20 74 95	jsr $9574	                jsr parseHexAddressFromCommandLine
1252	.9183					L8F79:
1253	.9183	a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
1254	.9185	a6 f2		ldx $f2		                ldx stringInputBufferAddress+0
1255	.9187	0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
1256	.918a	20 b4 a9	jsr $a9b4	                jsr openFileForReading

1258	.918d	a9 02		lda #$02	                lda #argsFileGetEXT
1259	.918f	20 7a 96	jsr $967a	                jsr callOSARGSWithBuffer

1261	.9192	a2 03		ldx #$03	                ldx #$03
1262	.9194					L8F8A:
1263	.9194	b5 a8		lda $a8,x	                lda osargsBuffer,x
1264	.9196	dd ed 02	cmp $02ed,x	                cmp osfileParameterBlock+0,x
1265	.9199	90 6a		bcc $9205	                bcc L8FFB
1266	.919b	d0 03		bne $91a0	                bne L8F96
1267	.919d	ca		dex		                dex
1268	.919e	10 f4		bpl $9194	                bpl L8F8A
1269	.91a0					L8F96:
1270	.91a0	a2 03		ldx #$03	                ldx #$03
1271	.91a2					-
1272	.91a2	bd ed 02	lda $02ed,x	                lda osfileParameterBlock+0,x
1273	.91a5	95 a8		sta $a8,x	                sta osargsBuffer,x
1274	.91a7	ca		dex		                dex
1275	.91a8	10 f8		bpl $91a2	                bpl -
1276	.91aa	20 78 96	jsr $9678	                jsr setFilePointerFromOSARGSBuffer
1277	.91ad					L8FA3:
1278	.91ad	a2 00		ldx #$00	                ldx #$00
1279	.91af	20 d7 ff	jsr $ffd7	                jsr OSBGET
1280	.91b2	b0 46		bcs $91fa	                bcs L8FF0
1281	.91b4	20 4e 94	jsr $944e	                jsr L9239
1282	.91b7	48		pha		                pha
1283	.91b8	ad f1 02	lda $02f1	                lda osfileParameterBlock+4
1284	.91bb	29 07		and #$07	                and #$07
1285	.91bd	f0 15		beq $91d4	                beq L8FCA
1286	.91bf	5a		phy		                phy
1287	.91c0	a8		tay		                tay
1288	.91c1					L8FB7:
1289	.91c1	5a		phy		                phy
1290	.91c2	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
1291	>91c5	20 20 20 00			                .text "   ",0
1292	.91c9	7a		ply		                ply
1293	.91ca	a9 20		lda #$20	                lda #$20
1294	.91cc	9d f5 02	sta $02f5,x	                sta osfileParameterBlock+8,x
1295	.91cf	e8		inx		                inx
1296	.91d0	88		dey		                dey
1297	.91d1	d0 ee		bne $91c1	                bne L8FB7
1298	.91d3	7a		ply		                ply
1299	.91d4					L8FCA:
1300	.91d4	68		pla		                pla
1301	.91d5					L8FCB:
1302	.91d5	48		pha		                pha
1303	.91d6	c9 20		cmp #$20	                cmp #32
1304	.91d8	90 04		bcc $91de	                bcc nonPrintable
1305	.91da	c9 7f		cmp #$7f	                cmp #127
1306	.91dc	90 02		bcc $91e0	                bcc L8FD6                    ;taken if printable
1307	.91de					nonPrintable:
1308	.91de	a9 2e		lda #$2e	                lda #'.'          ;placeholder for non-printable chars
1309	.91e0					L8FD6:
1310	.91e0	9d f5 02	sta $02f5,x	                sta osfileParameterBlock+8,x
1311	.91e3	68		pla		                pla
1312	.91e4	20 a7 ac	jsr $aca7	                jsr printSpaceThenPrintHexByte
1313	.91e7	e8		inx		                inx
1314	.91e8	20 5d 94	jsr $945d	                jsr L9248
1315	.91eb	ad f1 02	lda $02f1	                lda osfileParameterBlock+4
1316	.91ee	29 07		and #$07	                and #$07
1317	.91f0	f0 0b		beq $91fd	                beq L8FF3
1318	.91f2	20 44 91	jsr $9144	                jsr bgetAndCheckForESCAPE
1319	.91f5	90 de		bcc $91d5	                bcc L8FCB
1320	.91f7	20 6c 94	jsr $946c	                jsr L9257
1321	.91fa					L8FF0:
1322	.91fa	4c 19 91	jmp $9119	                jmp closeFile

1324	.91fd					L8FF3:
1325	.91fd	20 6c 94	jsr $946c	                jsr L9257
1326	.9200	80 ab		bra $91ad	                bra L8FA3

1328	.9202					L8FF8:
1329	.9202	4c bc a9	jmp $a9bc	                jmp notFoundError

1331	.9205					L8FFB:
1332	.9205	20 19 91	jsr $9119	                jsr closeFile
1333	.9208	20 ff ae	jsr $aeff	                jsr doFollowingError
1334	>920b	b7 4f 75 74 73 69 64 65		                .text $b7,"Outside file",0
	>9213	20 66 69 6c 65 00

1336						;-------------------------------------------------------------------------
1337						;
1338						; *BUILD
1339						;
1340	.9219					starBUILD:
1341	.9219	4e c2 df	lsr $dfc2	                lsr hazel.fsFlags            ;clear bit 7 of fsFlags
1342	.921c	80 04		bra $9222	                bra starBUILDOrAPPEND

1344						;-------------------------------------------------------------------------
1345						;
1346						; *APPEND
1347						;
1348	.921e					starAPPEND:
1349	.921e	38		sec		                sec
1350	.921f	6e c2 df	ror $dfc2	                ror hazel.fsFlags            ;set bit 7 of fsFlags
1351	.9222					starBUILDOrAPPEND:
1352						                ; bit 7 of fsFlags indicates *BUILD (clear) or *APPEND
1353						                ; (set).
1354	.9222	9c c3 df	stz $dfc3	                stz hazel.lineNumberBCD+0    ;reset line number
1355	.9225	9c c4 df	stz $dfc4	                stz hazel.lineNumberBCD+1    ;reset line number
1356	.9228	a9 80		lda #$80	                lda #$80                     ;open for output. Assume *BUILD
1357	.922a	2c c2 df	bit $dfc2	                bit hazel.fsFlags            ;test *BUILD/*APPEND
1358	.922d	10 02		bpl $9231	                bpl +                        ;branch taken if *BUILD
1359	.922f	a9 c0		lda #$c0	                lda #$C0                     ;*APPEND, so open for update
1360	.9231					+
1361	.9231	20 ce ff	jsr $ffce	                jsr OSFIND                   ;open the file
1362	.9234	a8		tay		                tay                          ;Y=file handle
1363	.9235	f0 cb		beq $9202	                beq L8FF8                    ;branch taken if open failed
1364	.9237	8c ed 02	sty $02ed	                sty osfileParameterBlock+0   ;save file handle
1365	.923a	20 73 96	jsr $9673	                jsr setPTRToEOF ;move to EOF (effective no-op when *BUILD)
1366	.923d					L9033:
1367	.923d	20 00 94	jsr $9400	                jsr printLineNumber
1368	.9240					L9036:
1372	.9240	a9 00		lda #$00	                lda #0
1373	.9242	a2 c6		ldx #$c6	                ldx #<starBuildOrAPPENDOSWORD0Parameters
1374	.9244	a0 92		ldy #$92	                ldy #>starBuildOrAPPENDOSWORD0Parameters
1375	.9246	20 f1 ff	jsr $fff1	                jsr OSWORD
1377	.9249	08		php		                php
1378	.924a	90 0f		bcc $925b	                bcc L904B
1379						                ; Handle ESCAPE
1380	.924c	20 e7 ff	jsr $ffe7	                jsr OSNEWL
1381	.924f	a9 0d		lda #$0d	                lda #$0D
1382	.9251	99 00 dc	sta $dc00,y	                sta hazel.commandLine,y      ;terminate current line
1383	.9254					L9044:
1384	.9254	5a		phy		                phy                          ;save line length
1385	.9255	a9 7e		lda #$7e	                lda #$7E
1386	.9257	20 f4 ff	jsr $fff4	                jsr OSBYTE                   ;acknowledge ESCAPE
1387	.925a	7a		ply		                ply                          ;restore line length
1388	.925b					L904B:
1389	.925b	98		tya		                tya                          ;A=line length
1390	.925c	f0 50		beq $92ae	                beq L909E                    ;taken if line empty
1391	.925e	20 bb 92	jsr $92bb	                jsr setStringInputBufferToCommandLine
1392	.9261	a0 00		ldy #$00	                ldy #$00
1393	.9263	a2 00		ldx #$00	                ldx #$00
1394	.9265					L9055:
1395	.9265	20 5b f3	jsr $f35b	                jsr LF29C
1396	.9268	9d 00 dc	sta $dc00,x	                sta hazel.commandLine,x
1397	.926b	a9 01		lda #$01	                lda #stringInputOptions.goodString
1398	.926d	24 e4		bit $e4		                bit stringInputOptions
1399	.926f	d0 0b		bne $927c	                bne L906C
1400	.9271	a9 07		lda #$07	                lda #7
1401	.9273	20 ee ff	jsr $ffee	                jsr OSWRCH                   ;beep
1402	.9276	20 0a 94	jsr $940a	                jsr L91F5
1403	.9279	28		plp		                plp
1404	.927a	80 c4		bra $9240	                bra L9036

1406	.927c					L906C:
1407	.927c	e8		inx		                inx
1408	.927d	90 e6		bcc $9265	                bcc L9055
1409	.927f	28		plp		                plp
1410	.9280	90 01		bcc $9283	                bcc L9073
1411	.9282	ca		dex		                dex
1412	.9283					L9073:
1413	.9283	08		php		                php
1414	.9284	da		phx		                phx
1415	.9285	a2 0b		ldx #$0b	                ldx #size(OSGBPBParameterBlock)-2
1416	.9287					L9077:
1417	.9287	9e ee 02	stz $02ee,x	                stz osfileParameterBlock+1,x
1418	.928a	ca		dex		                dex
1419	.928b	10 fa		bpl $9287	                bpl L9077
1420	.928d	fa		plx		                plx
1421	.928e	8e f2 02	stx $02f2	                stx osfileParameterBlock+OSGBPBParameterBlock.count+0
1423	.9291	a9 dc		lda #$dc	                lda #>hazel.commandLine
1424	.9293	8d ef 02	sta $02ef	                sta osfileParameterBlock+OSGBPBParameterBlock.address+1
1425	.9296	ce f0 02	dec $02f0	                dec osfileParameterBlock+OSGBPBParameterBlock.address+2
1426	.9299	ce f1 02	dec $02f1	                dec osfileParameterBlock+OSGBPBParameterBlock.address+3
1427	.929c	a9 02		lda #$02	                lda #gbpbPutBytesCurrentPTR
1428	.929e	a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
1429	.92a0	a0 02		ldy #$02	                ldy #>osfileParameterBlock
1430	.92a2	20 d1 ff	jsr $ffd1	                jsr OSGBPB
1431	.92a5	28		plp		                plp
1432	.92a6	90 95		bcc $923d	                bcc L9033
1433	.92a8					L9098:
1434	.92a8	ac ed 02	ldy $02ed	                ldy osfileParameterBlock+0
1435	.92ab	4c 19 91	jmp $9119	                jmp closeFile

1437	.92ae					L909E:
1438	.92ae	28		plp		                plp
1439	.92af	b0 f7		bcs $92a8	                bcs L9098
1440	.92b1	a9 0d		lda #$0d	                lda #13
1441	.92b3	ac ed 02	ldy $02ed	                ldy osfileParameterBlock
1442	.92b6	20 d4 ff	jsr $ffd4	                jsr OSBPUT
1443	.92b9	80 82		bra $923d	                bra L9033

1445	.92bb					setStringInputBufferToCommandLine:
1446	.92bb	a9 41		lda #$41	                lda #$41
1447	.92bd	85 e4		sta $e4		                sta $E4
1449	.92bf	64 f2		stz $f2		                stz stringInputBufferAddress+0
1450	.92c1	a9 dc		lda #$dc	                lda #>hazel.commandLine
1451	.92c3	85 f3		sta $f3		                sta stringInputBufferAddress+1
1452	.92c5	60		rts		                rts

1454						;-------------------------------------------------------------------------

1457	.92c6					starBuildOrAPPENDOSWORD0Parameters:
1458	>92c6	00 dc				                .word hazel.commandLine      ;address
1459	>92c8	f0				                .byte $f0                    ;max # chars
1460	>92c9	00				                .byte 0                      ;min char
1461	>92ca	ff				                .byte 255                    ;max char

1464						;-------------------------------------------------------------------------
1465						;
1466						; *MOVE
1467						;
1468	.92cb					starMOVE:
1469	.92cb	ad 34 fe	lda $fe34	                lda ACCCON                    ; Save ACCCON
1470	.92ce	8d dc df	sta $dfdc	                sta hazel.oldACCCON
1471	.92d1	48		pha		                pha                          ; Save ACCCON and command line pointer
1472	.92d2	da		phx		                phx
1473	.92d3	5a		phy		                phy
1474	.92d4	a0 80		ldy #$80	                ldy #$80                     ; Top of available shadow memory at &8000
1475	.92d6	a5 d0		lda $d0		                lda STATE                      ; Get VDU status
1476	.92d8	89 10		bit #$10	                bit #$10                     ; Jump if not shadow screen, spare up to &8000
1477	.92da	f0 07		beq $92e3	                beq L90CE
1478						; Shadow screen selected
1479	.92dc	20 76 f2	jsr $f276	                jsr LF1C0                ; Get screen bottom to XY
1480	.92df	c0 30		cpy #$30	                cpy #$30                     ; Screen at &3000, no spare memory, jump to use Hazel
1481	.92e1	f0 14		beq $92f7	                beq L90E2

1483						; Non-shadow or small shadow screen selected
1484						; Y=top of available memory in shadow memory
1485	.92e3					L90CE:
1486	.92e3	a9 30		lda #$30	                lda #$30                     ; &3000=start of shadow memory
1487	.92e5	8d d6 df	sta $dfd6	                sta hazel.moveBufferMSB
1488	.92e8	a9 04		lda #$04	                lda #ACCCON.X
1489	.92ea	0c 34 fe	tsb $fe34	                tsb ACCCON
1490	.92ed	8d dd df	sta $dfdd	                sta hazel.hasACCCONChanged      ; set 'ACCCON changed'
1491	.92f0	98		tya		                tya                          ; A=length of space in shadow memory
1492	.92f1	38		sec		                sec
1493	.92f2	ed d6 df	sbc $dfd6	                sbc hazel.moveBufferMSB
1494	.92f5	80 07		bra $92fe	                bra L90E9

1496						; No shadow memory available, use Hazel
1497	.92f7					L90E2:
1498	.92f7	a9 dd		lda #$dd	                lda #$DD                     ; Buffer at &DD00
1499	.92f9	8d d6 df	sta $dfd6	                sta hazel.moveBufferMSB
1500	.92fc	a9 02		lda #$02	                lda #$02                     ; Buffer length=&200

1502						; &DFD6=high byte of buffer address
1503						; A=high byte of buffer length
1504	.92fe					L90E9:
1505	.92fe	8d d7 df	sta $dfd7	                sta hazel.moveNumPages      ; Store buffer length
1506	.9301	7a		ply		                ply                          ; Get command line pointer
1507	.9302	fa		plx		                plx
1508	.9303	da		phx		                phx
1509	.9304	5a		phy		                phy
1510	.9305	a9 40		lda #$40	                lda #$40                     ; Open source file
1511	.9307	20 ce ff	jsr $ffce	                jsr OSFIND
1512	.930a	a8		tay		                tay                          ; Store source handle, jump if not found
1513	.930b	8c d4 df	sty $dfd4	                sty hazel.moveSrcHandle
1514	.930e	f0 39		beq $9349	                beq L9134
1515	.9310	7a		ply		                ply                          ; Get command line back again
1516	.9311	fa		plx		                plx
1517	.9312	86 f2		stx $f2		                stx $F2
1518	.9314	84 f3		sty $f3		                sty $F3
1519	.9316	da		phx		                phx                          ; And save it again
1520	.9317	5a		phy		                phy
1521	.9318	a0 00		ldy #$00	                ldy #$00                     ; Step past first parameter
1522	.931a	20 2c f3	jsr $f32c	                jsr gsinitForFilenameParsing
1523	.931d					L9108:
1524	.931d	20 3e f3	jsr $f33e	                jsr gsreadEntryPoint     ;
1525	.9320	90 fb		bcc $931d	                bcc L9108
1526	.9322	98		tya		                tya                          ; Save address of dest filename
1527	.9323	18		clc		                clc
1528	.9324	65 f2		adc $f2		                adc $F2
1529	.9326	8d d8 df	sta $dfd8	                sta hazel.moveDestName+0
1530	.9329	aa		tax		                tax
1531	.932a	a5 f3		lda $f3		                lda $F3
1532	.932c	69 00		adc #$00	                adc #$00
1533	.932e	8d d9 df	sta $dfd9	                sta hazel.moveDestName+1
1534	.9331	a8		tay		                tay                          ; Temporary filing system flag
1535	.9332	0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
1536	.9335	a9 80		lda #$80	                lda #$80                     ; Open destination file
1537	.9337	20 ce ff	jsr $ffce	                jsr OSFIND
1538	.933a	a8		tay		                tay                          ; Store dest handle, jump if opened
1539	.933b	8c d5 df	sty $dfd5	                sty hazel.moveDestHandle
1540	.933e	d0 0c		bne $934c	                bne L9137

1542						; Couldn't open destination
1543	.9340	ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle      ; Get source handle and clear it
1544	.9343	9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
1545	.9346	20 ce ff	jsr $ffce	                jsr OSFIND                   ; Close source file
1546	.9349					L9134:
1547	.9349	4c bc a9	jmp $a9bc	                jmp notFoundError                    ; Jump to 'Not found' error

1549						; Source and dest opened
1550						; ----------------------
1551						; Build OSGBPB source file control block at &02ED
1552						; and destination control block at &DFC7
1553	.934c					L9137:
1554	.934c	a2 07		ldx #$07	                ldx #$07
1555	.934e					L9139:
1556	.934e	9e ee 02	stz $02ee,x	                stz @w osfileParameterBlock+OSGBPBParameterBlock.address,x ; Addr=0, Num=0
1557	.9351	9e c8 df	stz $dfc8,x	                stz hazel.moveOSGBPB+1,x
1558	.9354	ca		dex		                dex
1559	.9355	10 f7		bpl $934e	                bpl L9139
1560	.9357	ad d4 df	lda $dfd4	                lda hazel.moveSrcHandle      ; Source handle
1561	.935a	8d ed 02	sta $02ed	                sta osfileParameterBlock+OSGBPBParameterBlock.handle
1562	.935d	ad d6 df	lda $dfd6	                lda hazel.moveBufferMSB      ; Buffer address
1563	.9360	8d ef 02	sta $02ef	                sta osfileParameterBlock+OSGBPBParameterBlock.address+1
1564	.9363	8d c9 df	sta $dfc9	                sta hazel.moveOSGBPB.addr+1
1565	.9366	ad d7 df	lda $dfd7	                lda hazel.moveNumPages
1566	.9369	8d f3 02	sta $02f3	                sta osfileParameterBlock+OSGBPBParameterBlock.count+1
1567	.936c	8d cd df	sta $dfcd	                sta hazel.moveOSGBPB.numBytes+1
1568	.936f	ce f0 02	dec $02f0	                dec osfileParameterBlock+OSGBPBParameterBlock.address+2 ; Source addr=&FFFFxxxx
1569	.9372	ce f1 02	dec $02f1	                dec osfileParameterBlock+OSGBPBParameterBlock.address+3
1570	.9375	ce ca df	dec $dfca	                dec hazel.moveOSGBPB.addr+2
1571	.9378	ce cb df	dec $dfcb	                dec hazel.moveOSGBPB.addr+3

1573						; Should use &FFFExxxx and let filing system select correct memory
1574						; Unfortunately, CFS/RFS and DFS do not recognise &FFFExxxx, so
1575						; *MOVE has to do it itself, causing problems for filing systems
1576						; that /do/ recognise &FFFExxxx where they have to remember to
1577						; *do* *nothing* for &FFFFxxxx instead of select main memory as
1578						; &FFFFxxxx implies.

1580	.937b	a2 ed		ldx #$ed	                ldx #<osfileParameterBlock                     ; XY=>source OSGBPB block
1581	.937d	a0 02		ldy #$02	                ldy #>osfileParameterBlock
1582	.937f	a9 04		lda #$04	                lda #$04                     ; Read data from source
1583	.9381	20 d1 ff	jsr $ffd1	                jsr OSGBPB
1584	.9384	08		php		                php                          ; Jump if not at end of file
1585	.9385	90 11		bcc $9398	                bcc L9183
1586						; End of file, adjust destination buffer length for final part
1587	.9387	a9 00		lda #$00	                lda #$00
1588	.9389	ed f2 02	sbc $02f2	                sbc osfileParameterBlock+OSGBPBParameterBlock.count+0
1589	.938c	8d cc df	sta $dfcc	                sta hazel.moveOSGBPB.numBytes+0
1590	.938f	ad cd df	lda $dfcd	                lda hazel.moveOSGBPB.numBytes+1
1591	.9392	ed f3 02	sbc $02f3	                sbc osfileParameterBlock+OSGBPBParameterBlock.count+1
1592	.9395	8d cd df	sta $dfcd	                sta hazel.moveOSGBPB.numBytes+1
1593	.9398					L9183:
1594	.9398	ad d5 df	lda $dfd5	                lda hazel.moveDestHandle      ; Destination handle
1595	.939b	8d c7 df	sta $dfc7	                sta hazel.moveOSGBPB.handle
1596	.939e	a9 02		lda #$02	                lda #$02                     ; XY=>control block, A=write
1597	.93a0	a2 c7		ldx #$c7	                ldx #<hazel.moveOSGBPB
1598	.93a2	a0 df		ldy #$df	                ldy #>hazel.moveOSGBPB
1599	.93a4	20 d1 ff	jsr $ffd1	                jsr OSGBPB
1600	.93a7	28		plp		                plp                          ; Loop until end of file
1601	.93a8	90 a2		bcc $934c	                bcc L9137
1602	.93aa	a9 00		lda #$00	                lda #$00
1603	.93ac	ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle      ; Get and clear source handle
1604	.93af	9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
1605	.93b2	5a		phy		                phy                          ; Close source file
1606	.93b3	20 ce ff	jsr $ffce	                jsr OSFIND
1607	.93b6	a9 00		lda #$00	                lda #$00                     ; Get dest handle
1608	.93b8	ac d5 df	ldy $dfd5	                ldy hazel.moveDestHandle
1609	.93bb	5a		phy		                phy                          ; Clear dest handle and close file
1610	.93bc	9c d5 df	stz $dfd5	                stz hazel.moveDestHandle
1611	.93bf	20 ce ff	jsr $ffce	                jsr OSFIND
1612	.93c2	7a		ply		                ply                          ; Dest not CFS/RFS, jump to...
1613	.93c3	c0 04		cpy #$04	                cpy #$04
1614	.93c5	b0 0b		bcs $93d2	                bcs L91BD
1615	.93c7	7a		ply		                ply                          ; Pop source handle
1616	.93c8					L91B3:
1617	.93c8	7a		ply		                ply                          ; Restore XY
1618	.93c9	fa		plx		                plx
1619	.93ca					L91B5:
1620	.93ca	68		pla		                pla                          ; Clear 'ACCCON changed', restore ACCCON
1621	.93cb	9c dd df	stz $dfdd	                stz hazel.hasACCCONChanged
1622	.93ce	8d 34 fe	sta $fe34	                sta ACCCON
1623	.93d1	60		rts		                rts

1625	.93d2					L91BD:
1626	.93d2	7a		ply		                ply                          ; Source was CFS/RFS, jump to exit
1627	.93d3	c0 04		cpy #$04	                cpy #$04
1628	.93d5	90 f1		bcc $93c8	                bcc L91B3
1629	.93d7	7a		ply		                ply                          ; Point to first parameter
1630	.93d8	8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
1631	.93db	fa		plx		                plx
1632	.93dc	8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
1633	.93df	a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
1634	.93e1	a0 02		ldy #$02	                ldy #>osfileParameterBlock
1635	.93e3	a9 05		lda #$05	                lda #$05                     ; Read info on source file
1636	.93e5	20 dd ff	jsr $ffdd	                jsr OSFILE
1637	.93e8	ad d8 df	lda $dfd8	                lda hazel.moveDestName+0      ; Get address of dest filename
1638	.93eb	8d ed 02	sta $02ed	                sta osfileParameterBlock+OSFILEParameterBlock.fileName+0
1639	.93ee	ad d9 df	lda $dfd9	                lda hazel.moveDestName+1      ;  and put in control block
1640	.93f1	8d ee 02	sta $02ee	                sta osfileParameterBlock+OSFILEParameterBlock.fileName+1
1641	.93f4	a9 f0		lda #$f0	                lda #$F0                     ; Mask out 'public' access bits
1642	.93f6	1c fb 02	trb $02fb	                trb osfileParameterBlock+OSFILEParameterBlock.attributes+0
1643	.93f9	a9 01		lda #$01	                lda #$01                     ; Write info on dest file
1644	.93fb	20 dd ff	jsr $ffdd	                jsr OSFILE
1645	.93fe	80 ca		bra $93ca	                bra L91B5                    ; Jump to restore ACCCON and exit

1647	.9400					printLineNumber:
1648	.9400	a2 00		ldx #$00	                ldx #$00
1649	.9402	38		sec		                sec
1650	.9403	20 43 94	jsr $9443	                jsr adcLineNumberBCDX        ;increment line number LSB
1651	.9406	e8		inx		                inx
1652	.9407	20 43 94	jsr $9443	                jsr adcLineNumberBCDX        ;carry into line number MSB
1653	.940a					L91F5:
1654	.940a	38		sec		                sec                          ;printing leading 0s
1655	.940b	ad c4 df	lda $dfc4	                lda hazel.lineNumberBCD+1    ;get line number MSB
1656	.940e	20 26 94	jsr $9426	                jsr printPossiblyLeading0s
1657	.9411	ad c3 df	lda $dfc3	                lda hazel.lineNumberBCD+0    ;get line number LSB
1658	.9414	48		pha		                pha                          ;save line number LSB
1659	.9415	08		php		                php                          ;save C
1663	.9416	4a		lsr a		                lsr a
1664	.9417	4a		lsr a		                lsr a
1665	.9418	4a		lsr a		                lsr a
1666	.9419	4a		lsr a		                lsr a
1668	.941a	28		plp		                plp                          ;restore  C
1669	.941b	20 31 94	jsr $9431	                jsr printPossiblyLeading0    ;print line number 3rd digit
1670	.941e	68		pla		                pla                          ;restore line number LSB
1671	.941f	18		clc		                clc                ;always print line number 4th digit
1672	.9420	20 31 94	jsr $9431	                jsr printPossiblyLeading0    ;
1673	.9423	4c f3 a3	jmp $a3f3	                jmp printSpace                    ;

1675	.9426					printPossiblyLeading0s:
1676	.9426	48		pha		                pha                          ;save value
1677	.9427	08		php		                php                          ;save C
1681	.9428	4a		lsr a		                lsr a
1682	.9429	4a		lsr a		                lsr a
1683	.942a	4a		lsr a		                lsr a
1684	.942b	4a		lsr a		                lsr a
1686	.942c	28		plp		                plp                          ;restore C
1687	.942d	20 31 94	jsr $9431	                jsr printPossiblyLeading0    ;print 1st digit
1688	.9430	68		pla		                pla                          ;restore value
1689	.9431					printPossiblyLeading0:
1690	.9431	29 0f		and #$0f	                and #$0F                     ;get digit to print
1691	.9433	d0 09		bne $943e	                bne printNonLeading0         ;always print if non-0
1692	.9435	90 07		bcc $943e	                bcc printNonLeading0 ;branch taken if not leading 0
1693	.9437	a9 20		lda #$20	                lda #$20             ;print space instead of leading 0
1694	.9439	20 ee ff	jsr $ffee	                jsr OSWRCH
1695	.943c	38		sec		                sec                ;indicate still in leading 0s state
1696	.943d	60		rts		                rts

1698	.943e					printNonLeading0:
1699	.943e	20 b5 ac	jsr $acb5	                jsr printHexDigit            ;print digit
1700	.9441	18		clc		                clc                          ;no longer in leading 0s state
1701	.9442	60		rts		                rts                          ;

1703	.9443					adcLineNumberBCDX:
1704	.9443	a9 00		lda #$00	                lda #$00
1705	.9445	f8		sed		                sed
1706	.9446	7d c3 df	adc $dfc3,x	                adc hazel.lineNumberBCD,x
1707	.9449	9d c3 df	sta $dfc3,x	                sta hazel.lineNumberBCD,x
1708	.944c	d8		cld		                cld
1709	.944d					rts9238:
1710	.944d	60		rts		                rts

1712						;-------------------------------------------------------------------------

1714	.944e					L9239:
1715	.944e	da		phx		                phx
1716	.944f	48		pha		                pha
1717	.9450	a2 02		ldx #$02	                ldx #$02
1718	.9452					L923D:
1719	.9452	bd f1 02	lda $02f1,x	                lda osfileParameterBlock+4,x
1720	.9455	20 ac ac	jsr $acac	                jsr printHexByte
1721	.9458	ca		dex		                dex
1722	.9459	10 f7		bpl $9452	                bpl L923D
1723	.945b	80 0c		bra $9469	                bra L9254

1725						;-------------------------------------------------------------------------

1727	.945d					L9248:
1728	.945d	da		phx		                phx
1729	.945e	48		pha		                pha
1730	.945f	a2 fc		ldx #$fc	                ldx #256-4
1731	.9461					L924C:
1732	.9461	fe f5 01	inc $01f5,x	                inc osfileParameterBlock+4-(256-4),x
1733	.9464	d0 03		bne $9469	                bne L9254
1734	.9466	e8		inx		                inx
1735	.9467	d0 f8		bne $9461	                bne L924C
1736	.9469					L9254:
1737	.9469	68		pla		                pla
1738	.946a	fa		plx		                plx
1739	.946b	60		rts		                rts

1741	.946c					L9257:
1742	.946c	5a		phy		                phy
1743	.946d	da		phx		                phx
1744	.946e					L9259:
1745	.946e	e0 08		cpx #$08	                cpx #$08
1746	.9470	f0 0a		beq $947c	                beq L9267
1747	.9472	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
1748	>9475	20 20 20 00			                .text "   ",0
1749	.9479	e8		inx		                inx
1750	.947a	80 f2		bra $946e	                bra L9259

1752	.947c					L9267:
1753	.947c	fa		plx		                plx
1754	.947d	20 f3 a3	jsr $a3f3	                jsr printSpace
1755	.9480	a0 00		ldy #$00	                ldy #$00
1756	.9482					L926D:
1757	.9482	b9 f5 02	lda $02f5,y	                lda osfileParameterBlock+8,y
1758	.9485	20 ee ff	jsr $ffee	                jsr OSWRCH
1759	.9488	c8		iny		                iny
1760	.9489	ca		dex		                dex
1761	.948a	d0 f6		bne $9482	                bne L926D
1762	.948c	7a		ply		                ply
1763	.948d	4c e7 ff	jmp $ffe7	                jmp OSNEWL

1765						;-------------------------------------------------------------------------

1771	=$94e1					osbyte19Done=rts94A4
1772						                .include "restore_font.s65"

:10	;******  Processing file: src/restore_font.s65

1						;-------------------------------------------------------------------------
2						;
3						; restore entire font.
4						;
5	.9490					restoreFont32To255:
6	.9490	a2 07		ldx #$07	                ldx #$07                     ;224 chars - 32-255
8						                ; fall through to restoreFont32ToN

10						;-------------------------------------------------------------------------
11						;
12						; Restore part of the font, starting from char 32.
13						;
14						; entry:
15						;
16						; X = number of pages of font data to restore - X*32 chars will be
17						; restored
18						;
19	.9492					restoreFont32ToN:
20	.9492	08		php		                php
21	.9493	78		sei		                sei
22	.9494	a9 b9		lda #$b9	                lda #>LB900                ;start at beginning of font
23	.9496	85 f1		sta $f1		                sta $F1
24	.9498	a9 89		lda #$89	                lda #>andy.softCharacterDefinitions ;write to beginning of soft character definitions
26						                ; fall through to restoreFontPart

28						;-------------------------------------------------------------------------
29						;
30						; Restore part of the font.
31						;
32						; entry:
33						;
34						; ?$f1 = MSB of font data
35						;
36						; A = MSB of dest page in ANDY - should be part of the soft character
37						; definitions!
38						;
39						; X = number of pages of font data to restore - X*32 chars will be
40						; restored
41						;
42						; preserves: Y

44	.949a					restoreFontPart:
45	.949a	85 fb		sta $fb		                sta $FB                      ;save MSB of dest
46	.949c	20 b1 e5	jsr $e5b1	                jsr selectTerminalROMAndANDY2
47						                .cwarn *<$9000,format("Code inside ANDY at: $%04x",*) ; following code can't be inside the ANDY region!
48	.949f	5a		phy		                phy                          ;
49	.94a0	a0 00		ldy #$00	                ldy #$00                     ;
50	.94a2	64 fa		stz $fa		                stz $FA                      ;initialize LSB of src
51	.94a4	64 f0		stz $f0		                stz $F0                      ;initialize LSB of dest
52	.94a6					-
53	.94a6	b1 f0		lda ($f0),y	                lda ($F0),y
54	.94a8	91 fa		sta ($fa),y	                sta ($FA),y
55	.94aa	c8		iny		                iny
56	.94ab	d0 f9		bne $94a6	                bne -
57	.94ad	e6 f1		inc $f1		                inc $F1
58	.94af	e6 fb		inc $fb		                inc $FB
59	.94b1	ca		dex		                dex
60	.94b2	d0 f2		bne $94a6	                bne -
61	.94b4	7a		ply		                ply
62	.94b5	28		plp		                plp
63	.94b6	4c a9 e5	jmp $e5a9	                jmp selectTerminalROM

65						;-------------------------------------------------------------------------

70	.94b9					restoreFont32To126:
71	.94b9	a2 03		ldx #$03	                ldx #$03                     ;96 chars - 32-126
72	.94bb	80 d5		bra $9492	                bra restoreFont32ToN

74						;-------------------------------------------------------------------------
75						;
76						; OSBYTE 25 (&19) Restore a group of font definitions
77						;
78						; MasRef D.2-28
79						;
80	.94bd					osbyte19:
81	.94bd	8a		txa		                txa                          ;A=group identifier
82	.94be	f0 d0		beq $9490	                beq restoreFont32To255   ;taken if group 0 - all chars
84	.94c0	c9 10		cmp #$10	                cmp #$10
88	.94c2	b0 1d		bcs $94e1	                bcs osbyte19Done
90	.94c4	29 07		and #$07	                and #7
91	.94c6	f0 c8		beq $9490	                beq restoreFont32To255
93	.94c8	08		php		                php
94	.94c9	78		sei		                sei
95	.94ca	69 b8		adc #$b8	                adc #(>LB900)-1 ;form address of ROM font data for group
96	.94cc	85 f1		sta $f1		                sta $F1
97	.94ce	8a		txa		                txa
98	.94cf	a2 01		ldx #$01	                ldx #$01                   ;copy 1 page, 32 chars
99	.94d1	69 88		adc #$88	                adc #(>andy.softCharacterDefinitions)-1 ;get page in ANDY for group
100	.94d3	80 c5		bra $949a	                bra restoreFontPart

:5	;******  Return to file: src/terminal.s65

1775						;-------------------------------------------------------------------------
1776						;
1777						; Clear 4 bytes in the OSFILE parameter block.
1778						;
1779						; entry:
1780						;
1781						; X = offset of the 4 bytes to clear
1782						;
1783	.94d5					clearOSFILEParameterBlockDWORD:
1784	.94d5	9e ed 02	stz $02ed,x	                stz osfileParameterBlock+0,x
1785	.94d8	9e ee 02	stz $02ee,x	                stz osfileParameterBlock+1,x
1786	.94db	9e ef 02	stz $02ef,x	                stz osfileParameterBlock+2,x
1787	.94de	9e f0 02	stz $02f0,x	                stz osfileParameterBlock+3,x
1788	.94e1					rts94A4:
1789	.94e1	60		rts		                rts

1791						;-------------------------------------------------------------------------
1792						;
1793						; Read a 32-bit hex value from a string.
1794						;
1795						; entry:
1796						;
1797						; X = offset into osfileParameterBlock to store the value
1798						;
1799						; exit:
1800						;
1801						; C=0 if error
1802						;
1803						; preserves: V
1804						;
1805	.94e2					parseHexAddressFromString:
1806	.94e2	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
1807	.94e5	20 98 86	jsr $8698	                jsr readHexDigit
1808	.94e8	90 23		bcc $950d	                bcc rts92F4
1809	.94ea	20 d5 94	jsr $94d5	                jsr clearOSFILEParameterBlockDWORD
1810	.94ed					readDigitsLoop:
1811	.94ed	5a		phy		                phy
1812	.94ee	2a		rol a		                rol a
1813	.94ef	2a		rol a		                rol a
1814	.94f0	2a		rol a		                rol a
1815	.94f1	2a		rol a		                rol a                        ;put digit in top 4 bits
1816	.94f2	a0 04		ldy #$04	                ldy #$04
1817	.94f4					shiftIn1DigitLoop:
1818	.94f4	2a		rol a		                rol a
1819	.94f5	3e ed 02	rol $02ed,x	                rol osfileParameterBlock+0,x
1820	.94f8	3e ee 02	rol $02ee,x	                rol osfileParameterBlock+1,x
1821	.94fb	3e ef 02	rol $02ef,x	                rol osfileParameterBlock+2,x
1822	.94fe	3e f0 02	rol $02f0,x	                rol osfileParameterBlock+3,x
1823	.9501	b0 61		bcs $9564	                bcs badAddressError ;carry out of bit 31 implies too many digits
1824	.9503	88		dey		                dey
1825	.9504	d0 ee		bne $94f4	                bne shiftIn1DigitLoop
1826	.9506	7a		ply		                ply
1827	.9507	20 98 86	jsr $8698	                jsr readHexDigit
1828	.950a	b0 e1		bcs $94ed	                bcs readDigitsLoop   ;keep going until hex digits stop
1829	.950c	38		sec		                sec       ;got at least 1 hex digit, so result is good
1830	.950d					rts92F4:
1831	.950d	60		rts		                rts

1833						;-------------------------------------------------------------------------
1834						;
1835						; *GO (<addr>) [MasRef C.5-6]
1836						;
1837	.950e					starGO:
1838	.950e	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
1839	.9511	d0 03		bne $9516	                bne starGOIO             ; Jump to read parameters
1840	.9513	4c b1 86	jmp $86b1	                jmp commandLineUI        ; No parameters, enter CLICOM

1842						;-------------------------------------------------------------------------
1843						;
1844						; *GOIO <addr> [MasRef C.5-7]
1845						;
1846	.9516					starGOIO:
1847	.9516	a2 00		ldx #$00	                ldx #$00
1848	.9518	20 74 95	jsr $9574	                jsr parseHexAddressFromCommandLine ; Read hex address
1849	.951b	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
1850	.951e	08		php		                php  ; Update &F2/3 to point to any further parameters
1851	.951f	98		tya		                tya
1852	.9520	18		clc		                clc
1853	.9521	65 f2		adc $f2		                adc stringInputBufferAddress+0
1854	.9523	85 f2		sta $f2		                sta stringInputBufferAddress+0
1855	.9525	90 02		bcc $9529	                bcc +
1856	.9527	e6 f3		inc $f3		                inc stringInputBufferAddress+1
1857	.9529					+
1858	.9529	a0 00		ldy #$00	                ldy #$00    ; (&F2),y=>parameters, EQ if no parameters
1859	.952b	28		plp		                plp
1860	.952c	6c ed 02	jmp ($02ed)	                jmp (osfileParameterBlock+0) ; Jump to address

1862						;-------------------------------------------------------------------------

1864	.952f					starLOAD:
1865	.952f	a9 ff		lda #$ff	                lda #fileLoad
1866	.9531					starCommandThroughOSFILE:
1867	.9531	4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
1868	.9534					L931B:
1869	.9534	86 f2		stx $f2		                stx stringInputBufferAddress+0
1870	.9536	84 f3		sty $f3		                sty stringInputBufferAddress+1
1871	.9538	8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
1872	.953b	8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
1873	.953e	48		pha		                pha                          ;save OSFILE reason
1874	.953f	a2 02		ldx #$02	                ldx #OSFILEParameterBlock.load
1875	.9541	20 d5 94	jsr $94d5	                jsr clearOSFILEParameterBlockDWORD
1876	.9544	a2 0a		ldx #$0a	                ldx #OSFILEParameterBlock.length
1877	.9546	20 d5 94	jsr $94d5	                jsr clearOSFILEParameterBlockDWORD
1878	.9549	a0 ff		ldy #$ff	                ldy #$FF
1879	.954b	8c f3 02	sty $02f3	                sty osfileParameterBlock+OSFILEParameterBlock.exec+0 ;by default, load to file's load address
1880	.954e	c8		iny		                iny                                                  ;Y=0
1881	.954f	20 2c f3	jsr $f32c	                jsr gsinitForFilenameParsing
1882	.9552					L9339:
1883	.9552	20 3e f3	jsr $f33e	                jsr gsreadEntryPoint
1884	.9555	90 fb		bcc $9552	                bcc L9339
1885	.9557	68		pla		                pla                          ;restore OSFILE reason
1886	.9558	48		pha		                pha                          ;save OSFILE reason
1887	.9559	10 4c		bpl $95a7	                bpl finishStarSAVE                    ;taken if *SAVE
1888	.955b	a2 02		ldx #$02	                ldx #OSFILEParameterBlock.load
1889	.955d	20 e2 94	jsr $94e2	                jsr parseHexAddressFromString ;parse *LOAD address
1890	.9560	b0 18		bcs $957a	                bcs doStarLOADWithExplicitAddress ;taken if good address
1891	.9562	f0 1b		beq $957f	                beq L9366        ;taken if CR encountered (this is ok)
1892	.9564					badAddressError:
1893	.9564	20 ff ae	jsr $aeff	                jsr doFollowingError
1894	>9567	fc 42 61 64 20 61 64 64		                .text $fc,"Bad address",0
	>956f	72 65 73 73 00

1896						;-------------------------------------------------------------------------
1897						;
1898						; Parse hex address from command line.
1899						;
1900	.9574					parseHexAddressFromCommandLine:
1901	.9574	20 e2 94	jsr $94e2	                jsr parseHexAddressFromString ; Read hex address
1902	.9577	90 eb		bcc $9564	                bcc badAddressError           ; Jump with bad address
1903	.9579	60		rts		                rts

1905						;-------------------------------------------------------------------------

1907	.957a					doStarLOADWithExplicitAddress:
1908	.957a	d0 7b		bne $95f7	                bne badCommandError93E2
1909	.957c	ee f3 02	inc $02f3	                inc osfileParameterBlock+OSFILEParameterBlock.exec+0 ;load to parameter block load address
1910	.957f					L9366:
1911	.957f	0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
1912	.9582					callOSFILEWithOSFILEParameterBlock:
1913	.9582	a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
1914	.9584	a0 02		ldy #$02	                ldy #>osfileParameterBlock
1915	.9586	68		pla		                pla
1916	.9587	4c dd ff	jmp $ffdd	                jmp OSFILE

1918						;-------------------------------------------------------------------------
1919						;
1920						; *REMOVE [MasRef G.5-9]
1921						;
1922	.958a					starREMOVE:
1923	.958a	8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
1924	.958d	8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
1926	.9590	86 f2		stx $f2		                stx stringInputBufferAddress+0
1927	.9592	84 f3		sty $f3		                sty stringInputBufferAddress+1
1928	.9594	a0 ff		ldy #$ff	                ldy #$ff
1929	.9596					L9596:
1930	.9596	c8		iny		                iny
1931	.9597	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
1932	.9599	c9 21		cmp #$21	                cmp #'!'
1933	.959b	b0 f9		bcs $9596	                bcs L9596
1934	.959d	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
1935	.95a0	d0 55		bne $95f7	                bne badCommandError93E2
1937	.95a2	a9 06		lda #$06	                lda #fileDelete
1938	.95a4	48		pha		                pha
1939	.95a5	80 db		bra $9582	                bra callOSFILEWithOSFILEParameterBlock

1941						;-------------------------------------------------------------------------
1953						;-------------------------------------------------------------------------
1968						;-------------------------------------------------------------------------

1970	.95a7					finishStarSAVE:
1971	.95a7	d0 07		bne $95b0	                bne L939B
1972	.95a9	a2 0a		ldx #$0a	                ldx #OSFILEParameterBlock.saveStart
1973	.95ab	20 e2 94	jsr $94e2	                jsr parseHexAddressFromString
1974	.95ae	90 47		bcc $95f7	                bcc badCommandError93E2
1975	.95b0					L939B:
1976	.95b0	b8		clv		                clv
1977	.95b1	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
1978	.95b3	c9 2b		cmp #$2b	                cmp #'+'
1979	.95b5	d0 04		bne $95bb	                bne L93A6                    ;taken if "*SAVE START END..."
1980	.95b7	2c 70 e3	bit $e370	                bit valueFF              ;V=1
1981	.95ba	c8		iny		                iny
1982	.95bb					L93A6:
1983	.95bb	a2 0e		ldx #$0e	                ldx #OSFILEParameterBlock.saveEnd
1984	.95bd	20 e2 94	jsr $94e2	                jsr parseHexAddressFromString
1985	.95c0	90 35		bcc $95f7	                bcc badCommandError93E2
1986	.95c2	08		php		                php
1987	.95c3	50 0f		bvc $95d4	                bvc L93BF                    ;taken if "*SAVE START END"

1989						                ; Get the save end address.
1990	.95c5	a2 fc		ldx #$fc	                ldx #256-4
1991	.95c7	18		clc		                clc
1992	.95c8					-
1993						                ; TODO - not sure why the @w notation is required here?
1994	.95c8	bd fb 01	lda $01fb,x	                lda@w osfileParameterBlock+OSFILEParameterBlock.saveStart-(256-4),x
1995	.95cb	7d ff 01	adc $01ff,x	                adc@w osfileParameterBlock+OSFILEParameterBlock.saveEnd-(256-4),x
1996	.95ce	9d ff 01	sta $01ff,x	                sta@w osfileParameterBlock+OSFILEParameterBlock.saveEnd-(256-4),x
1997	.95d1	e8		inx		                inx
1998	.95d2	d0 f4		bne $95c8	                bne -
1999	.95d4					L93BF:

2001						                ; Initialize load and exec addresses to save start
2002						                ; address.
2003	.95d4	a2 03		ldx #$03	                ldx #$03
2004	.95d6					-
2005	.95d6	bd f7 02	lda $02f7,x	                lda@w osfileParameterBlock+OSFILEParameterBlock.saveStart,x
2006	.95d9	9d f3 02	sta $02f3,x	                sta@w osfileParameterBlock+OSFILEParameterBlock.exec,x
2007	.95dc	9d ef 02	sta $02ef,x	                sta@w osfileParameterBlock+OSFILEParameterBlock.load,x
2008	.95df	ca		dex		                dex
2009	.95e0	10 f4		bpl $95d6	                bpl -

2011	.95e2	28		plp		                plp
2012	.95e3	f0 9a		beq $957f	                beq L9366

2014	.95e5	a2 06		ldx #$06	                ldx #OSFILEParameterBlock.exec
2015	.95e7	20 e2 94	jsr $94e2	                jsr parseHexAddressFromString
2016	.95ea	90 0b		bcc $95f7	                bcc badCommandError93E2
2017	.95ec	f0 91		beq $957f	                beq L9366

2019	.95ee	a2 02		ldx #$02	                ldx #OSFILEParameterBlock.load
2020	.95f0	20 e2 94	jsr $94e2	                jsr parseHexAddressFromString
2021	.95f3	90 02		bcc $95f7	                bcc badCommandError93E2
2022	.95f5	f0 88		beq $957f	                beq L9366

2024	.95f7					badCommandError93E2:
2025	.95f7	4c 60 fb	jmp $fb60	                jmp badCommandError

2027						;-------------------------------------------------------------------------

2029	.95fa					starFX:
2030	.95fa	20 36 86	jsr $8636	                jsr parseNumberFromString
2031	.95fd	90 f8		bcc $95f7	                bcc badCommandError93E2
2032	.95ff	8a		txa		                txa
2033	.9600					starCommandThroughOSBYTE:
2034	.9600	08		php		                php
2035	.9601	4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
2036	.9604	28		plp		                plp
2037	.9605	48		pha		                pha
2038	.9606	64 e5		stz $e5		                stz $E5
2039	.9608	64 e4		stz $e4		                stz $E4
2040	.960a	20 c7 f3	jsr $f3c7	                jsr LF308
2041	.960d	f0 18		beq $9627	                beq L9412
2042	.960f	20 36 86	jsr $8636	                jsr parseNumberFromString
2043	.9612	90 e3		bcc $95f7	                bcc badCommandError93E2
2044	.9614	86 e5		stx $e5		                stx $E5
2045	.9616	20 c9 f3	jsr $f3c9	                jsr LF30A
2046	.9619	f0 0c		beq $9627	                beq L9412
2047	.961b	20 36 86	jsr $8636	                jsr parseNumberFromString
2048	.961e	90 d7		bcc $95f7	                bcc badCommandError93E2
2049	.9620	86 e4		stx $e4		                stx $E4
2050	.9622	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
2051	.9625					L9625:
2052	.9625	d0 d0		bne $95f7	                bne badCommandError93E2
2053	.9627					L9412:
2054	.9627	a4 e4		ldy $e4		                ldy $E4
2055	.9629	a6 e5		ldx $e5		                ldx $E5
2056	.962b	68		pla		                pla
2057	.962c	0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
2058	.962f	20 f4 ff	jsr $fff4	                jsr OSBYTE
2059	.9632	70 c3		bvs $95f7	                bvs badCommandError93E2
2060	.9634					rts941F:
2061	.9634	60		rts		                rts

2063						;-------------------------------------------------------------------------

2065	.9635					starSPOOLON:
2066	.9635	38		sec		                sec
2067	.9636	80 14		bra $964c	                bra starSPOOL

2069						;-------------------------------------------------------------------------

2072	.9638					starSHADOW:
2073	.9638	a9 72		lda #$72	                lda #$72
2074	.963a					L963A:
2075	.963a	80 c4		bra $9600	                bra starCommandThroughOSBYTE

2078						;-------------------------------------------------------------------------

2080	.963c					osbyte77:
2081	.963c	a2 10		ldx #$10	                ldx #romServiceCallSpoolExecClosureWarning
2082	.963e	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
2083	.9641	f0 f1		beq $9634	                beq rts941F
2084	.9643	20 fa a9	jsr $a9fa	                jsr LA58B
2085	.9646	ad 57 02	lda $0257	                lda spoolFileHandle
2086	.9649	20 da a9	jsr $a9da	                jsr LA56B
2087	.964c					starSPOOL:
2088	.964c	08		php		                php
2089	.964d	5a		phy		                phy
2090	.964e	ac 57 02	ldy $0257	                ldy spoolFileHandle
2091	.9651	8d 57 02	sta $0257	                sta spoolFileHandle
2092	.9654	f0 03		beq $9659	                beq L9440
2093	.9656	20 ce ff	jsr $ffce	                jsr OSFIND
2094	.9659					L9440:
2095	.9659	4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
2096	.965c	7a		ply		                ply
2097	.965d	28		plp		                plp
2098	.965e	f0 d4		beq $9634	                beq rts941F
2099	.9660	a9 80		lda #$80	                lda #$80
2100	.9662	90 02		bcc $9666	                bcc L944D
2101	.9664	a9 c0		lda #$c0	                lda #$C0
2102	.9666					L944D:
2103	.9666	0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
2104	.9669	20 ce ff	jsr $ffce	                jsr OSFIND
2105	.966c	a8		tay		                tay
2106	.966d	f0 88		beq $95f7	                beq badCommandError93E2
2107	.966f	8d 57 02	sta $0257	                sta spoolFileHandle
2108	.9672	a8		tay		                tay
2109	.9673					setPTRToEOF:
2110	.9673	a9 02		lda #$02	                lda #argsFileGetEXT
2111	.9675	20 7a 96	jsr $967a	                jsr callOSARGSWithBuffer
2112	.9678					setFilePointerFromOSARGSBuffer:
2113	.9678	a9 01		lda #$01	                lda #argsFileSetPTR
2114	.967a					callOSARGSWithBuffer:
2115	.967a	a2 a8		ldx #$a8	                ldx #osargsBuffer
2116	.967c	4c da ff	jmp $ffda	                jmp OSARGS

2118						;-------------------------------------------------------------------------

2126						;-------------------------------------------------------------------------

2129	.967f					starCLOSE:
2130	.967f	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
2131	.9682	d0 a1		bne $9625	                bne L9625
2132	.9684	a9 00		lda #$00	                lda #$00
2133	.9686	a8		tay		                tay
2134	.9687	6c 1c 02	jmp ($021c)	                jmp (FINDV)                  ;OSFIND A=0 Y=0

2137						;-------------------------------------------------------------------------

2140	.968a					starIGNORE:
2141	.968a	d0 05		bne $9691	                bne L938E
2142	.968c	38		sec		                sec
2143	.968d	6e 46 02	ror $0246	                ror noignoreState
2144	.9690	60		rts		                rts

2146	.9691					L938E:
2147	.9691	a9 06		lda #$06	                lda #$06
2148	.9693	80 a5		bra $963a	                bra L963A

2151						;-------------------------------------------------------------------------
2152						;
2153	.9695					starDELETE:
2154	.9695	20 8a 95	jsr $958a	                jsr starREMOVE
2155	.9698	a8		tay		                tay
2156	.9699	d0 99		bne $9634	                bne rts941F
2157	.969b	4c bc a9	jmp $a9bc	                jmp notFoundError

2159						;-------------------------------------------------------------------------

2174						;-------------------------------------------------------------------------

2193						;-------------------------------------------------------------------------

2196	.969e					starSHOW:
2197	.969e	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
2198	.96a0	49 0d		eor #$0d	                eor #13
2199	.96a2	d0 1b		bne $96bf	                bne L96BF
2200	.96a4	aa		tax		                tax
2201	.96a5					L96A5:
2202	.96a5	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
2203	>96a8	4b 65 79 20 00			                .text "Key ",0

2205	.96ad	da		phx		                phx
2206	.96ae	8a		txa		                txa
2207	.96af	20 b5 ac	jsr $acb5	                jsr printHexDigit
2208	.96b2	20 f3 a3	jsr $a3f3	                jsr printSpace
2209	.96b5	20 c7 96	jsr $96c7	                jsr printKeyDefinition
2210	.96b8	fa		plx		                plx
2211	.96b9	e8		inx		                inx
2212	.96ba	e0 10		cpx #$10	                cpx #$10
2213	.96bc	90 e7		bcc $96a5	                bcc L96A5
2214	.96be					L96BE:
2215	.96be	60		rts		                rts

2217	.96bf					L96BF:
2218	.96bf	20 fe 96	jsr $96fe	                jsr parseSoftKeyNumberFromCommandLine
2219	.96c2	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
2220	.96c5					L96C5:
2221	.96c5	d0 40		bne $9707	                bne badKeyError

2224						;-------------------------------------------------------------------------

2243						;-------------------------------------------------------------------------
2244						;
2245						; [MasRef C.5-11]
2246						;

2254	.96c7					printKeyDefinition:
2256	.96c7	a9 22		lda #$22	                lda #'"'
2257	.96c9	20 ee ff	jsr $ffee	                jsr OSWRCH
2258	.96cc	a5 f4		lda $f4		                lda $F4
2259	.96ce	48		pha		                pha
2260	.96cf	20 b1 e5	jsr $e5b1	                jsr selectTerminalROMAndANDY2
2261						                .cwarn *<$9000,format("Code inside ANDY at: $%04x",*)
2262	.96d2	bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2263	.96d5	85 f2		sta $f2		                sta stringInputBufferAddress+0
2264	.96d7	bd 11 80	lda $8011,x	                lda andy.softKeys.stringMSBs,x
2265	.96da	85 f3		sta $f3		                sta stringInputBufferAddress+1
2269	.96dc	8a		txa		                txa
2270	.96dd	a8		tay		                tay
2272	.96de	20 c8 ec	jsr $ecc8	                jsr getSoftKeyStringLength
2273	.96e1	a8		tay		                tay                          ;Y = string length
2274	.96e2	f0 0e		beq $96f2	                beq starSHOWDone                    ;done if length=0
2275	.96e4					-
2276	.96e4	b2 f2		lda ($f2)	                lda (stringInputBufferAddress)
2277	.96e6	20 52 98	jsr $9852	                jsr printGSREADChar
2278	.96e9	e6 f2		inc $f2		                inc stringInputBufferAddress+0
2279	.96eb	d0 02		bne $96ef	                bne +
2280	.96ed	e6 f3		inc $f3		                inc stringInputBufferAddress+1
2281	.96ef					+
2282	.96ef	88		dey		                dey
2283	.96f0	d0 f2		bne $96e4	                bne -
2284	.96f2					starSHOWDone:
2285	.96f2	68		pla		                pla
2286	.96f3	20 ab e5	jsr $e5ab	                jsr selectROMA
2287	.96f6	a9 22		lda #$22	                lda #'"'
2288	.96f8	20 ee ff	jsr $ffee	                jsr OSWRCH
2289	.96fb	4c e7 ff	jmp $ffe7	                jmp OSNEWL

2291						;-------------------------------------------------------------------------

2294	.96fe					parseSoftKeyNumberFromCommandLine:
2295	.96fe	20 36 86	jsr $8636	                jsr parseNumberFromString
2296	.9701	90 04		bcc $9707	                bcc badKeyError
2297	.9703	e0 10		cpx #$10	                cpx #softKeyCount
2298	.9705	90 b7		bcc $96be	                bcc L96BE
2299	.9707					badKeyError:
2300	.9707	20 ff ae	jsr $aeff	                jsr doFollowingError
2301	>970a	fb				                .byte $FB
2302	>970b	42 61 64 20 6b 65 79		                .text "Bad key"
2303	>9712	00				                .byte 0

2306						;-------------------------------------------------------------------------
2307						;
2308						; [MasRef C.5-8]
2309						;
2310	.9713					starKEY: .proc
2311	.9713	20 fe 96	jsr $96fe	                jsr parseSoftKeyNumberFromCommandLine
2312	.9716	a5 f4		lda $f4		                lda $F4
2313	.9718	48		pha		                pha
2314	.9719	20 98 e5	jsr $e598	                jsr selectTerminalROMAndANDY
2315	.971c	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
2316	.971f	64 b0		stz $b0		                stz starKEYWorkspace.newStringLength
2317	.9721	f0 15		beq $9738	                beq commandLineTailEmpty
2318	.9723	a2 00		ldx #$00	                ldx #$00
2319	.9725	38		sec		                sec
2320	.9726	20 2d f3	jsr $f32d	                jsr gsinitEntryPoint
2321	.9729					-
2322	.9729	20 3e f3	jsr $f33e	                jsr gsreadEntryPoint
2323	.972c	b0 06		bcs $9734	                bcs bneBadKeyError
2324	.972e	9d 00 dc	sta $dc00,x	                sta hazel.commandLine,x
2325	.9731	e8		inx		                inx
2326	.9732	80 f5		bra $9729	                bra -

2328	.9734					bneBadKeyError:
2332	.9734	d0 d1		bne $9707	                bne badKeyError
2334	.9736	86 b0		stx $b0		                stx starKEYWorkspace.newStringLength
2335	.9738					commandLineTailEmpty:
2336	.9738	a4 e6		ldy $e6		                ldy $E6                        ;Y = soft key number
2337	.973a	20 c8 ec	jsr $ecc8	                jsr getSoftKeyStringLength
2338	.973d	85 b5		sta $b5		                sta starKEYWorkspace.counter+0
2339	.973f	38		sec		                sec
2340	.9740	e5 b0		sbc $b0		                sbc starKEYWorkspace.newStringLength ;A=existing len-new len
2341	.9742	b0 16		bcs $975a	                bcs newStringWillFit            ;taken if new string shorter, meaning it'll definitely fit

2343	.9744	49 ff		eor #$ff	                eor #$FF
2344	.9746	69 01		adc #$01	                adc #$01                     ;A=new len-existing len
2345	.9748	6d 10 80	adc $8010	                adc andy.softKeys.endLSB
2346	.974b	aa		tax		                tax
2347	.974c	ad 21 80	lda $8021	                lda andy.softKeys.endMSB
2348	.974f	69 00		adc #$00	                adc #$00
2349	.9751	c9 84		cmp #$84	                cmp #>(andy.softKeys.end)
2350	.9753	90 05		bcc $975a	                bcc newStringWillFit

2352						                ; Produce slightly cryptic "Bad key" if string won't
2353						                ; fit.
2354	.9755	d0 dd		bne $9734	                bne bneBadKeyError
2355	.9757	8a		txa		                txa
2356	.9758	d0 da		bne $9734	                bne bneBadKeyError
2357	.975a					newStringWillFit:
2358	.975a	ad 68 02	lda $0268	                lda softKeyStringLength
2359	.975d	f0 32		beq $9791	                beq storeNewString          ;taken if new string empty
2360	.975f	ad c9 02	lda $02c9	                lda currentSoftKey
2361	.9762	c5 e6		cmp $e6		                cmp $E6
2362	.9764	90 2b		bcc $9791	                bcc storeNewString ;taken if current soft key<key - expansion will not need to relocate
2363	.9766	d0 0f		bne $9777	                bne relocateCurrentSoftKeyExpansion ;taken if current soft key>key - expansion must relocate
2364	.9768	20 ff ae	jsr $aeff	                jsr doFollowingError
2365	>976b	fa 4b 65 79 20 69 6e 20		                .text $fa,"Key in use",0
	>9773	75 73 65 00
2366	.9777					relocateCurrentSoftKeyExpansion:
2367	.9777	64 b2		stz $b2		                stz starKEYWorkspace.destPtr+1
2368	.9779	38		sec		                sec
2369	.977a	a5 b0		lda $b0		                lda starKEYWorkspace.newStringLength
2370	.977c	e5 b5		sbc $b5		                sbc starKEYWorkspace.counter+0
2371	.977e	85 b1		sta $b1		                sta starKEYWorkspace.destPtr+0
2372	.9780	b0 02		bcs $9784	                bcs +
2373	.9782	c6 b2		dec $b2		                dec starKEYWorkspace.destPtr+1
2374	.9784					+
2375	.9784	18		clc		                clc
2376	.9785	a5 f8		lda $f8		                lda softKeyExpansionPtr+0
2377	.9787	65 b1		adc $b1		                adc starKEYWorkspace.destPtr+0
2378	.9789	85 f8		sta $f8		                sta softKeyExpansionPtr+0
2379	.978b	a5 f9		lda $f9		                lda softKeyExpansionPtr+1
2380	.978d	65 b2		adc $b2		                adc starKEYWorkspace.destPtr+1
2381	.978f	85 f9		sta $f9		                sta softKeyExpansionPtr+1
2382	.9791					storeNewString:
2383	.9791	ce 84 02	dec $0284	                dec softKeyConsistencyFlag   ;mark soft keys inconsistent
2384	.9794	a6 e6		ldx $e6		                ldx $E6                      ;X=key number
2385	.9796	a5 b5		lda $b5		                lda starKEYWorkspace.counter+0
2386	.9798	f0 45		beq $97df	                beq makeSpaceForNewString ;taken if no existing string for this soft key

2388						                ; delete existing string
2389	.979a	bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2390	.979d	85 b1		sta $b1		                sta starKEYWorkspace.destPtr+0
2391	.979f	bd 11 80	lda $8011,x	                lda andy.softKeys.stringMSBs,x
2392	.97a2	85 b2		sta $b2		                sta starKEYWorkspace.destPtr+1
2393	.97a4	bd 01 80	lda $8001,x	                lda andy.softKeys.stringLSBs+1,x
2394	.97a7	85 b3		sta $b3		                sta starKEYWorkspace.srcPtr+0
2395	.97a9	bd 12 80	lda $8012,x	                lda andy.softKeys.stringMSBs+1,x
2396	.97ac	85 b4		sta $b4		                sta starKEYWorkspace.srcPtr+1
2397	.97ae					deleteExistingStringLoop:
2398						                ; copy byte (with postincrement)
2399	.97ae	b2 b3		lda ($b3)	                lda (starKEYWorkspace.srcPtr)
2400	.97b0	92 b1		sta ($b1)	                sta (starKEYWorkspace.destPtr)

2402						                ; increment destPtr
2403	.97b2	e6 b1		inc $b1		                inc starKEYWorkspace.destPtr+0
2404	.97b4	d0 02		bne $97b8	                bne +
2405	.97b6	e6 b2		inc $b2		                inc starKEYWorkspace.destPtr+1
2406	.97b8					+

2408						                ; increment srcPtr
2409	.97b8	e6 b3		inc $b3		                inc starKEYWorkspace.srcPtr+0
2410	.97ba	d0 02		bne $97be	                bne +
2411	.97bc	e6 b4		inc $b4		                inc starKEYWorkspace.srcPtr+1
2412	.97be					+

2414						                ; keep copying until end of buffer reached.
2415	.97be	a5 b3		lda $b3		                lda starKEYWorkspace.srcPtr+0
2416	.97c0	cd 10 80	cmp $8010	                cmp andy.softKeys.endLSB
2417	.97c3	a5 b4		lda $b4		                lda starKEYWorkspace.srcPtr+1
2418	.97c5	ed 21 80	sbc $8021	                sbc andy.softKeys.endMSB
2419	.97c8	90 e4		bcc $97ae	                bcc deleteExistingStringLoop

2421						                ; update following strings' start addresses, which all
2422						                ; move down by the old string's length.
2423	.97ca					updateAddressesLoop:
2424	.97ca	e8		inx		                inx
2425	.97cb	e0 11		cpx #$11	                cpx #softKeyCount+1
2426	.97cd	b0 10		bcs $97df	                bcs makeSpaceForNewString
2427	.97cf	38		sec		                sec
2428	.97d0	bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2429	.97d3	e5 b5		sbc $b5		                sbc starKEYWorkspace.counter+0
2430	.97d5	9d 00 80	sta $8000,x	                sta andy.softKeys.stringLSBs,x
2431	.97d8	b0 f0		bcs $97ca	                bcs updateAddressesLoop
2432	.97da	de 11 80	dec $8011,x	                dec andy.softKeys.stringMSBs,x
2433	.97dd	80 eb		bra $97ca	                bra updateAddressesLoop

2435	.97df					makeSpaceForNewString:
2436	.97df	a6 e6		ldx $e6		                ldx $E6
2437	.97e1	a5 b0		lda $b0		                lda starKEYWorkspace.newStringLength
2438	.97e3	f0 66		beq $984b	                beq done
2439	.97e5	ad 10 80	lda $8010	                lda andy.softKeys.endLSB
2440	.97e8	85 b3		sta $b3		                sta starKEYWorkspace.srcPtr+0
2441	.97ea	18		clc		                clc
2442	.97eb	65 b0		adc $b0		                adc starKEYWorkspace.newStringLength
2443	.97ed	85 b1		sta $b1		                sta starKEYWorkspace.destPtr+0 ;new end ptr LSB
2444	.97ef	ad 21 80	lda $8021	                lda andy.softKeys.endMSB
2445	.97f2	85 b4		sta $b4		                sta starKEYWorkspace.srcPtr+1
2446	.97f4	69 00		adc #$00	                adc #$00
2447	.97f6	85 b2		sta $b2		                sta starKEYWorkspace.destPtr+1 ;new end ptr MSB
2448	.97f8	a5 b3		lda $b3		                lda starKEYWorkspace.srcPtr+0
2449	.97fa	38		sec		                sec
2450	.97fb	fd 00 80	sbc $8000,x	                sbc andy.softKeys.stringLSBs,x
2451	.97fe	85 b5		sta $b5		                sta starKEYWorkspace.counter+0
2452	.9800	a5 b4		lda $b4		                lda starKEYWorkspace.srcPtr+1
2453	.9802	fd 11 80	sbc $8011,x	                sbc andy.softKeys.stringMSBs,x
2454	.9805	85 b6		sta $b6		                sta starKEYWorkspace.counter+1
2455	.9807					makeSpaceForNewStringLoop:
2456						                ; loop while counter>0
2457	.9807	a5 b5		lda $b5		                lda starKEYWorkspace.counter+0
2458	.9809	05 b6		ora $b6		                ora starKEYWorkspace.counter+1
2459	.980b	f0 1e		beq $982b	                beq updateAddressesLoop2

2461						                ; decrement destPtr
2462	.980d	a5 b1		lda $b1		                lda starKEYWorkspace.destPtr+0
2463	.980f	d0 02		bne $9813	                bne +
2464	.9811	c6 b2		dec $b2		                dec starKEYWorkspace.destPtr+1
2465	.9813					+
2466	.9813	c6 b1		dec $b1		                dec starKEYWorkspace.destPtr+0

2468						                ; decrement srcPtr
2469	.9815	a5 b3		lda $b3		                lda starKEYWorkspace.srcPtr+0
2470	.9817	d0 02		bne $981b	                bne +
2471	.9819	c6 b4		dec $b4		                dec starKEYWorkspace.srcPtr+1
2472	.981b					+
2473	.981b	c6 b3		dec $b3		                dec starKEYWorkspace.srcPtr+0

2475						                ; copy byte (with predecrement)
2476	.981d	b2 b3		lda ($b3)	                lda (starKEYWorkspace.srcPtr)
2477	.981f	92 b1		sta ($b1)	                sta (starKEYWorkspace.destPtr)

2479						                ; decrement counter
2480	.9821	a5 b5		lda $b5		                lda starKEYWorkspace.counter+0
2481	.9823	d0 02		bne $9827	                bne +
2482	.9825	c6 b6		dec $b6		                dec starKEYWorkspace.counter+1
2483	.9827					+
2484	.9827	c6 b5		dec $b5		                dec starKEYWorkspace.counter+0

2486	.9829	80 dc		bra $9807	                bra makeSpaceForNewStringLoop

2488						                ; update following strings' start addresses, which all
2489						                ; move up by the new string's length.
2490	.982b					updateAddressesLoop2:
2491	.982b	e8		inx		                inx
2492	.982c	e0 11		cpx #$11	                cpx #softKeyCount+1
2493	.982e	b0 0f		bcs $983f	                bcs copyNewString
2494	.9830	bd 00 80	lda $8000,x	                lda andy.softKeys.stringLSBs,x
2495	.9833	65 b0		adc $b0		                adc starKEYWorkspace.newStringLength
2496	.9835	9d 00 80	sta $8000,x	                sta andy.softKeys.stringLSBs,x
2497	.9838	90 f1		bcc $982b	                bcc updateAddressesLoop2
2498	.983a	fe 11 80	inc $8011,x	                inc andy.softKeys.stringMSBs,x
2499	.983d	80 ec		bra $982b	                bra updateAddressesLoop2

2501	.983f					copyNewString:
2502	.983f	a0 00		ldy #$00	                ldy #$00
2503	.9841					copyNewStringLoop:
2504	.9841	b9 00 dc	lda $dc00,y	                lda hazel.commandLine,y
2505	.9844	91 b3		sta ($b3),y	                sta (starKEYWorkspace.srcPtr),y
2506	.9846	c8		iny		                iny
2507	.9847	c6 b0		dec $b0		                dec starKEYWorkspace.newStringLength
2508	.9849	d0 f6		bne $9841	                bne copyNewStringLoop
2509	.984b					done:
2510	.984b	ee 84 02	inc $0284	                inc softKeyConsistencyFlag   ;mark soft keys consistent
2511	.984e	68		pla		                pla
2512	.984f	4c ab e5	jmp $e5ab	                jmp selectROMA
2513						                .endproc

2515						;-------------------------------------------------------------------------
2516						;
2517						; Print char, printing control codes using the string reader escape
2518						; syntax. [MasRef C.5-8]
2519						;
2520	.9852					printGSREADChar: .proc
2521	.9852	aa		tax		                tax                          ;X=char
2522	.9853	30 28		bmi $987d	                bmi printHighBitChar
2523	.9855	c9 20		cmp #$20	                cmp #$20
2524	.9857	90 1f		bcc $9878	                bcc printControlChar
2525	.9859	e8		inx		                inx
2526	.985a	30 0f		bmi $986b	                bmi vdu127
2527	.985c	ca		dex		                dex                          ;restore old char
2528	.985d	c9 22		cmp #$22	                cmp #'"'
2529	.985f	f0 11		beq $9872	                beq printEscapedX
2530	.9861	c9 7c		cmp #$7c	                cmp #'|'
2531	.9863	d0 03		bne $9868	                bne printA
2532						                ; print "||"
2533	.9865	20 ee ff	jsr $ffee	                jsr OSWRCH
2534	.9868					printA:
2535	.9868	4c ee ff	jmp $ffee	                jmp OSWRCH

2537	.986b					vdu127:
2538						                ; print "|?"
2539	.986b	20 88 98	jsr $9888	                jsr printEscapeChar
2540	.986e	a9 3f		lda #$3f	                lda #'?'
2541	.9870	80 f6		bra $9868	                bra printA

2543	.9872					printEscapedX:
2544	.9872	20 88 98	jsr $9888	                jsr printEscapeChar
2545	.9875	8a		txa		                txa
2546	.9876	80 f0		bra $9868	                bra printA

2548	.9878					printControlChar:
2549	.9878	09 40		ora #$40	                ora #$40
2550	.987a	aa		tax		                tax
2551	.987b	80 f5		bra $9872	                bra printEscapedX

2553	.987d					printHighBitChar:
2554	.987d	48		pha		                pha
2555	.987e	a2 21		ldx #$21	                ldx #'!'
2556	.9880	20 72 98	jsr $9872	                jsr printEscapedX
2557	.9883	68		pla		                pla
2558	.9884	29 7f		and #$7f	                and #$7F
2559	.9886	80 ca		bra $9852	                bra printGSREADChar

2561	.9888					printEscapeChar:
2562	.9888	a9 7c		lda #$7c	                lda #'|'
2563	.988a	80 dc		bra $9868	                bra printA
2564						                .endproc

2566						;-------------------------------------------------------------------------

2569						                .include "rtc.s65"

:11	;******  Processing file: src/rtc.s65

213						;-------------------------------------------------------------------------

215						; TODO - is this necessary?
216						;
217						; There's a reference to dayOfWeekStrings-4, but that seems to be
218						; because days are 1-based. The data here is presumably never
219						; accesssed.
220	>988c	20 20 20 00			                .text "   ",0

222						;-------------------------------------------------------------------------

224	.9890					dayOfWeekStrings: .block
225	>9890	53 75 6e 01			                .text "Sun",$01
226	>9894	4d 6f 6e 02			                .text "Mon",$02
227	>9898	54 75 65 03			                .text "Tue",$03
228	>989c	57 65 64 04			                .text "Wed",$04
229	>98a0	54 68 75 05			                .text "Thu",$05
230	>98a4	46 72 69 06			                .text "Fri",$06
231	>98a8	53 61 74 07			                .text "Sat",$07
232						                .endblock

234						;-------------------------------------------------------------------------

236	.98ac					monthStrings: .block
237	>98ac	4a 61 6e 01			                .text "Jan",$01
238	>98b0	46 65 62 02			                .text "Feb",$02
239	>98b4	4d 61 72 03			                .text "Mar",$03
240	>98b8	41 70 72 04			                .text "Apr",$04
241	>98bc	4d 61 79 05			                .text "May",$05
242	>98c0	4a 75 6e 06			                .text "Jun",$06
243	>98c4	4a 75 6c 07			                .text "Jul",$07
244	>98c8	41 75 67 08			                .text "Aug",$08
245	>98cc	53 65 70 09			                .text "Sep",$09
246	>98d0	4f 63 74 10			                .text "Oct",$10
247	>98d4	4e 6f 76 11			                .text "Nov",$11
248	>98d8	44 65 63 12			                .text "Dec",$12
249						                .endblock

251						;-------------------------------------------------------------------------

254	.98dc					L986C:
255	>98dc	99				                .byte $99
256	>98dd	12				                .byte $12
257	>98de	31				                .byte $31
258	>98df	06				                .byte $06
259	>98e0	23				                .byte $23
260	>98e1	59				                .byte $59
261	>98e2	59				                .byte $59

264						;-------------------------------------------------------------------------

267	.98e3					osword0F:
268	.98e3	a2 08		ldx #$08	                ldx #romServiceCallUnrecognisedOSWORD
269	.98e5	4c ff ee	jmp $eeff	                jmp makeROMServiceCall

272						;-------------------------------------------------------------------------
273						;
274						; OSWORD 14 (&0E) Read CMOS clock [MasRef D.3-22]
275						;

277	.98e8					osword0E:
283	.98e8	c9 02		cmp #$02	                cmp #2
284	.98ea	f0 2c		beq $9918	                beq L98A8
285	.98ec	48		pha		                pha
286	.98ed	a5 f0		lda $f0		                lda originalX
287	.98ef	48		pha		                pha
288	.98f0	a5 f1		lda $f1		                lda originalY
289	.98f2	48		pha		                pha
290	.98f3	a2 08		ldx #$08	                ldx #romServiceCallUnrecognisedOSWORD
291	.98f5	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
292	.98f8	c9 01		cmp #$01	                cmp #1
293	.98fa	68		pla		                pla
294	.98fb	85 f1		sta $f1		                sta originalY
295	.98fd	68		pla		                pla
296	.98fe	85 f0		sta $f0		                sta originalX
297	.9900	90 1e		bcc $9920	                bcc L98B0
298	.9902	a0 07		ldy #$07	                ldy #7
299	.9904	68		pla		                pla
300	.9905	48		pha		                pha
301	.9906	f0 01		beq $9909	                beq L9899
302	.9908	88		dey		                dey
303	.9909					L9899:
304	.9909	a2 07		ldx #$07	                ldx #7
305	.990b					L989B:
306	.990b	bd db 98	lda $98db,x	                lda L986C-1,x
307	.990e	91 f0		sta ($f0),y	                sta (originalX),y
308	.9910	88		dey		                dey
309	.9911	ca		dex		                dex
310	.9912	d0 f7		bne $990b	                bne L989B
311	.9914	68		pla		                pla
312	.9915	3a		dec a		                dec a
313	.9916	f0 07		beq $991f	                beq L98AF
314	.9918					L98A8:
315	.9918	a2 08		ldx #$08	                ldx #romServiceCallUnrecognisedOSWORD
316	.991a	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
317	.991d	d0 03		bne $9922	                bne L98B2
318	.991f					L98AF:
319	.991f	48		pha		                pha
320	.9920					L98B0:
321	.9920	68		pla		                pla
322	.9921	60		rts		                rts

324	.9922					L98B2:

327						                ; Convert given time to string. Fill out the RTC temp
328						                ; data with the info from the parameter block, then
329						                ; pass on to the common code.
330	.9922	a0 07		ldy #$07	                ldy #$07

332						                ; Copy hours, mins, secs.
333	.9924	a2 00		ldx #$00	                ldx #$00
334	.9926					-
335	.9926	b1 f0		lda ($f0),y	                lda ($F0),y
336	.9928	9d ee 02	sta $02ee,x	                sta osfileParameterBlock+1,x
337	.992b	88		dey		                dey
338	.992c	e8		inx		                inx
339	.992d	e8		inx		                inx
340	.992e	e0 06		cpx #$06	                cpx #$06
341	.9930	90 f4		bcc $9926	                bcc -

343						                ; Copy day of week, day of month, month, year.
344	.9932					-
345	.9932	b1 f0		lda ($f0),y	                lda (originalX),y
346	.9934	9d ee 02	sta $02ee,x	                sta osfileParameterBlock+1,x
347	.9937	e8		inx		                inx
348	.9938	88		dey		                dey
349	.9939	d0 f7		bne $9932	                bne -

413	.993b					convertTimeToString:
414						                ; Store terminating CR.
415	.993b	a0 18		ldy #$18	                ldy #ClockStringFormat.cr
416	.993d	a9 0d		lda #$0d	                lda #13
417	.993f	91 f0		sta ($f0),y	                sta (originalX),y
418	.9941	a2 00		ldx #$00	                ldx #$00
419	.9943	88		dey		                dey
420	.9944	20 a9 99	jsr $99a9	                jsr storeRTCDataByteString
421	.9947	a9 3a		lda #$3a	                lda #':'
422	.9949	91 f0		sta ($f0),y	                sta (originalX),y
423	.994b	a0 12		ldy #$12	                ldy #ClockStringFormat.hh+2
424	.994d	91 f0		sta ($f0),y	                sta (originalX),y
425	.994f	a2 02		ldx #$02	                ldx #RTC.minutes
426	.9951	a0 14		ldy #$14	                ldy #ClockStringFormat.mm+1
427	.9953	20 a9 99	jsr $99a9	                jsr storeRTCDataByteString
428	.9956	a2 04		ldx #$04	                ldx #RTC.hours
429	.9958	a0 11		ldy #$11	                ldy #ClockStringFormat.hh+1
430	.995a	20 a9 99	jsr $99a9	                jsr storeRTCDataByteString
431	.995d	a9 2e		lda #$2e	                lda #'.'
432	.995f	91 f0		sta ($f0),y	                sta (originalX),y
433	.9961	ad f4 02	lda $02f4	                lda osfileParameterBlock+1+RTC.dayOfWeek;
434	.9964	0a		asl a		                asl a
435	.9965	0a		asl a		                asl a
436	.9966	a0 00		ldy #$00	                ldy #$00
437	.9968	aa		tax		                tax
438	.9969					-
439	.9969	bd 8c 98	lda $988c,x	                lda dayOfWeekStrings-4,x     ;-4 as 1=Sunday
440	.996c	91 f0		sta ($f0),y	                sta (originalX),y
441	.996e	e8		inx		                inx
442	.996f	c8		iny		                iny
443	.9970	c0 03		cpy #$03	                cpy #$03
444	.9972	90 f5		bcc $9969	                bcc -
445	.9974	a9 2c		lda #$2c	                lda #','
446	.9976	91 f0		sta ($f0),y	                sta (originalX),y
447	.9978	ad f6 02	lda $02f6	                lda osfileParameterBlock+1+RTC.month
448	.997b	c9 10		cmp #$10	                cmp #$10
449	.997d	90 02		bcc $9981	                bcc +
450	.997f	e9 06		sbc #$06	                sbc #$06            ;convert $10, $11 and $12 from BCD
451	.9981					+
452	.9981	3a		dec a		                dec a                        ;make month 0-based
453	.9982	0a		asl a		                asl a
454	.9983	0a		asl a		                asl a
455	.9984	aa		tax		                tax
456	.9985	a0 07		ldy #$07	                ldy #ClockStringFormat.mmm
457	.9987					-
458	.9987	bd ac 98	lda $98ac,x	                lda monthStrings,x
459	.998a	91 f0		sta ($f0),y	                sta ($F0),y
460	.998c	e8		inx		                inx
461	.998d	c8		iny		                iny
462	.998e	c0 0a		cpy #$0a	                cpy #ClockStringFormat.mmm+3
463	.9990	90 f5		bcc $9987	                bcc -
464	.9992	a2 09		ldx #$09	                ldx #RTC.year
465	.9994	a0 0e		ldy #$0e	                ldy #ClockStringFormat.yyyy+3
466	.9996	20 a9 99	jsr $99a9	                jsr storeRTCDataByteString
467	.9999	a9 19		lda #$19	                lda #assumedRTCCenturyBCD
468	.999b	20 ac 99	jsr $99ac	                jsr storeBCDByteString
469	.999e	a9 20		lda #$20	                lda #$20
470	.99a0	91 f0		sta ($f0),y	                sta ($F0),y
471	.99a2	a0 06		ldy #$06	                ldy #ClockStringFormat.nn+2
472	.99a4	91 f0		sta ($f0),y	                sta ($F0),y
473	.99a6	88		dey		                dey
474	.99a7	a2 07		ldx #$07	                ldx #RTC.dayOfMonth
475	.99a9					storeRTCDataByteString:
476	.99a9	bd ee 02	lda $02ee,x	                lda osfileParameterBlock+1,x
477	.99ac					storeBCDByteString:
478	.99ac	48		pha		                pha
479	.99ad	20 b5 99	jsr $99b5	                jsr storeNybbleString
480	.99b0	68		pla		                pla
484	.99b1	4a		lsr a		                lsr a
485	.99b2	4a		lsr a		                lsr a
486	.99b3	4a		lsr a		                lsr a
487	.99b4	4a		lsr a		                lsr a
489	.99b5					storeNybbleString:
490	.99b5	29 0f		and #$0f	                and #$0F
491	.99b7	09 30		ora #$30	                ora #'0'
492	.99b9	c9 3a		cmp #$3a	                cmp #'9'+1
493	.99bb	90 02		bcc $99bf	                bcc +
494	.99bd	69 06		adc #$06	                adc #('A'-'9'-1)-1           ;(-1 because C set)
495	.99bf					+
496	.99bf	91 f0		sta ($f0),y	                sta (originalX),y
497	.99c1	88		dey		                dey
498	.99c2	60		rts		                rts

500						;-------------------------------------------------------------------------

512						;-------------------------------------------------------------------------

524						;-------------------------------------------------------------------------
525						;
526						; Read byte from RTC, either by 0-based CMOS RAM offset (readCMOSByte)
527						; or by RTC register index (readRTCByte).
528						;
529						; entry:
530						;
531						; X = address to read from
532						;
533						; exit:
534						;
535						; A = byte read
536						;
537						; N,Z = set as per byte read
538						;

574						;-------------------------------------------------------------------------
575						;
576						; Write byte to RTC, either by 0-based CMOS RAM offset (writeCMOSByte)
577						; or by RTC register index (writeRTCByte).
578						;
579						; (For some reason, writeCMOSByte can't be used to write to CMOS RAM
580						; offset 0.)
581						;
582						; entry:
583						;
584						; X = address to write to
585						;
586						; Y = value to write
587						;

608						;-------------------------------------------------------------------------
609						;
610						; Convert CMOS byte offset to actual RTC address.
611						;
612						; entry:
613						;
614						; X = CMOS byte offset - 0-49
615						;
616						; exit:
617						;
618						; C=1 = invalid address
619						;
620						; C=0 = valid address: X = register index
621						;

633						;-------------------------------------------------------------------------
634						;
635						; set RTC address for future read/write operation.
636						;
637						; entry:
638						;
639						; X = address to set
640						;
641						; preserves: Y
642						;

:5	;******  Return to file: src/terminal.s65

2572						;-------------------------------------------------------------------------

2574	.99c3					L9923:
2575	.99c3	a9 03		lda #$03	                lda #$03
2576	.99c5	20 98 d2	jsr $d298	                jsr LD298
2577	.99c8	90 12		bcc $99dc	                bcc L993C
2578	.99ca	20 d0 99	jsr $99d0	                jsr L9930
2579	.99cd	20 a9 d8	jsr $d8a9	                jsr LD8A9
2580	.99d0					L9930:
2581	.99d0	a2 20		ldx #$20	                ldx #$20
2582	.99d2	4c c8 e2	jmp $e2c8	                jmp LE2B8

2584	.99d5					L9935:
2585	.99d5	a9 02		lda #$02	                lda #$02
2586	.99d7	20 98 d2	jsr $d298	                jsr LD298
2587	.99da	b0 64		bcs $9a40	                bcs L99A0
2588	.99dc					L993C:
2589	.99dc	20 d2 d3	jsr $d3d2	                jsr LD3D2
2590	.99df	20 5f 9b	jsr $9b5f	                jsr L9ABF
2591	.99e2	80 08		bra $99ec	                bra L994C

2593	.99e4					L9944:
2594	.99e4	20 1a d4	jsr $d41a	                jsr LD41A
2595	.99e7	f0 57		beq $9a40	                beq L99A0
2596	.99e9	20 d2 d3	jsr $d3d2	                jsr LD3D2
2597	.99ec					L994C:
2598	.99ec	a5 e1		lda $e1		                lda $E1
2599	.99ee	89 20		bit #$20	                bit #$20
2600	.99f0	f0 05		beq $99f7	                beq L9957
2601	.99f2	48		pha		                pha
2602	.99f3	20 a3 d6	jsr $d6a3	                jsr LD6A3
2603	.99f6	68		pla		                pla
2604	.99f7					L9957:
2605	.99f7	89 10		bit #$10	                bit #$10
2606	.99f9	f0 03		beq $99fe	                beq L995E
2607	.99fb	20 98 d6	jsr $d698	                jsr LD698
2608	.99fe					L995E:
2609	.99fe	20 9c 9a	jsr $9a9c	                jsr L99FC
2610	.9a01	08		php		                php
2611	.9a02	20 fa 9a	jsr $9afa	                jsr L9A5A
2612	.9a05	a2 42		ldx #$42	                ldx #$42
2613	.9a07	a0 46		ldy #$46	                ldy #$46
2614	.9a09	a9 20		lda #$20	                lda #$20
2615	.9a0b	2c 49 88	bit $8849	                bit L8849
2616	.9a0e	f0 1c		beq $9a2c	                beq L998C
2617	.9a10	30 18		bmi $9a2a	                bmi L998A
2618	.9a12	ad 2c 03	lda $032c	                lda $032C
2619	.9a15	cd 37 03	cmp $0337	                cmp $0337
2620	.9a18	d0 08		bne $9a22	                bne L9982
2621	.9a1a	ad 2d 03	lda $032d	                lda $032D
2622	.9a1d	cd 38 03	cmp $0338	                cmp $0338
2623	.9a20	f0 10		beq $9a32	                beq L9992
2624	.9a22					L9982:
2625	.9a22	a2 37		ldx #$37	                ldx #$37
2626	.9a24	20 4d d2	jsr $d24d	                jsr LD24D
2627	.9a27	a2 42		ldx #$42	                ldx #$42
2628	.9a29	b8		clv		                clv
2629	.9a2a					L998A:
2630	.9a2a	a0 2c		ldy #$2c	                ldy #$2C
2631	.9a2c					L998C:
2632	.9a2c	30 07		bmi $9a35	                bmi L9995
2633	.9a2e	50 02		bvc $9a32	                bvc L9992
2634	.9a30	a2 37		ldx #$37	                ldx #$37
2635	.9a32					L9992:
2636	.9a32	20 4d d2	jsr $d24d	                jsr LD24D
2637	.9a35					L9995:
2638	.9a35	28		plp		                plp
2639	.9a36	90 b4		bcc $99ec	                bcc L994C
2640	.9a38	60		rts		                rts

2642	.9a39					L9999:
2643	.9a39	a9 01		lda #$01	                lda #$01
2644	.9a3b	20 98 d2	jsr $d298	                jsr LD298
2645	.9a3e	90 09		bcc $9a49	                bcc L99A9
2646	.9a40					L99A0:
2647	.9a40	a2 24		ldx #$24	                ldx #$24
2648	.9a42	80 37		bra $9a7b	                bra L99DB

2650	.9a44					L99A4:
2651	.9a44	20 1a d4	jsr $d41a	                jsr LD41A
2652	.9a47	f0 f7		beq $9a40	                beq L99A0
2653	.9a49					L99A9:
2654	.9a49	20 d2 d3	jsr $d3d2	                jsr LD3D2
2655	.9a4c	20 69 9a	jsr $9a69	                jsr L99C9
2656	.9a4f					L99AF:
2657	.9a4f	20 e6 d5	jsr $d5e6	                jsr LD5E6
2658	.9a52	20 69 9a	jsr $9a69	                jsr L99C9
2659	.9a55	ad 30 88	lda $8830	                lda L8830
2660	.9a58	0d 31 88	ora $8831	                ora L8831
2661	.9a5b	f0 3e		beq $9a9b	                beq L99FB
2662	.9a5d	2c 48 88	bit $8848	                bit L8848
2663	.9a60	70 ed		bvs $9a4f	                bvs L99AF
2664	.9a62	a2 42		ldx #$42	                ldx #$42
2665	.9a64	20 76 9a	jsr $9a76	                jsr L99D6
2666	.9a67	80 e6		bra $9a4f	                bra L99AF

2668	.9a69					L99C9:
2669	.9a69	20 34 d3	jsr $d334	                jsr LD334
2670	.9a6c	20 7e 9a	jsr $9a7e	                jsr L99DE
2671	.9a6f	2c 48 88	bit $8848	                bit L8848
2672	.9a72	30 27		bmi $9a9b	                bmi L99FB
2673	.9a74	a2 46		ldx #$46	                ldx #$46
2674	.9a76					L99D6:
2675	.9a76	da		phx		                phx
2676	.9a77	20 80 d2	jsr $d280	                jsr LD280
2677	.9a7a	fa		plx		                plx
2678	.9a7b					L99DB:
2679	.9a7b	4c 4c db	jmp $db4c	                jmp plotPointInternal

2681	.9a7e					L99DE:
2682	.9a7e	a2 03		ldx #$03	                ldx #$03
2683	.9a80					L99E0:
2684	.9a80	bd 30 88	lda $8830,x	                lda L8830,x
2685	.9a83	9d 42 03	sta $0342,x	                sta $0342,x
2686	.9a86	9d 46 03	sta $0346,x	                sta $0346,x
2687	.9a89	ca		dex		                dex
2688	.9a8a	10 f4		bpl $9a80	                bpl L99E0
2689	.9a8c					L99EC:
2690	.9a8c	ac 42 03	ldy $0342	                ldy $0342
2691	.9a8f	ad 43 03	lda $0343	                lda $0343
2692	.9a92	20 2e c9	jsr $c92e	                jsr negateAY
2693	.9a95	8c 42 03	sty $0342	                sty $0342
2694	.9a98	8d 43 03	sta $0343	                sta $0343
2695	.9a9b					L99FB:
2696	.9a9b	60		rts		                rts

2698	.9a9c					L99FC:
2699	.9a9c	a5 e1		lda $e1		                lda $E1
2700	.9a9e	8d 49 88	sta $8849	                sta L8849
2701	.9aa1	20 7e 9a	jsr $9a7e	                jsr L99DE
2702	.9aa4	a2 01		ldx #$01	                ldx #$01
2703	.9aa6					L9A06:
2704	.9aa6	9e 42 03	stz $0342,x	                stz $0342,x
2705	.9aa9	9e 46 03	stz $0346,x	                stz $0346,x
2706	.9aac	ca		dex		                dex
2707	.9aad	10 f7		bpl $9aa6	                bpl L9A06
2708	.9aaf					L9A0F:
2709	.9aaf	20 ce 9a	jsr $9ace	                jsr L9A2E
2710	.9ab2	ad 30 88	lda $8830	                lda L8830
2711	.9ab5	0d 31 88	ora $8831	                ora L8831
2712	.9ab8	d0 06		bne $9ac0	                bne L9A20
2713	.9aba	38		sec		                sec
2714	.9abb	ad 47 88	lda $8847	                lda L8847
2715	.9abe	d0 cc		bne $9a8c	                bne L99EC
2716	.9ac0					L9A20:
2717	.9ac0	20 e6 d5	jsr $d5e6	                jsr LD5E6
2718	.9ac3	ad 32 88	lda $8832	                lda L8832
2719	.9ac6	cd 44 03	cmp $0344	                cmp $0344
2720	.9ac9	f0 e4		beq $9aaf	                beq L9A0F
2721	.9acb	18		clc		                clc
2722	.9acc	80 be		bra $9a8c	                bra L99EC

2724	.9ace					L9A2E:
2725	.9ace	20 34 d3	jsr $d334	                jsr LD334
2726	.9ad1	2c 48 88	bit $8848	                bit L8848
2727	.9ad4	30 07		bmi $9add	                bmi L9A3D
2728	.9ad6	08		php		                php
2729	.9ad7	a2 46		ldx #$46	                ldx #$46
2730	.9ad9	20 e1 9a	jsr $9ae1	                jsr L9A41
2731	.9adc	28		plp		                plp
2732	.9add					L9A3D:
2733	.9add	70 1a		bvs $9af9	                bvs L9A59
2734	.9adf	a2 42		ldx #$42	                ldx #$42
2735	.9ae1					L9A41:
2736	.9ae1	ad 30 88	lda $8830	                lda L8830
2737	.9ae4	a8		tay		                tay
2738	.9ae5	dd 00 03	cmp $0300,x	                cmp $0300,x
2739	.9ae8	ad 31 88	lda $8831	                lda L8831
2740	.9aeb	48		pha		                pha
2741	.9aec	fd 01 03	sbc $0301,x	                sbc $0301,x
2742	.9aef	68		pla		                pla
2743	.9af0	90 07		bcc $9af9	                bcc L9A59
2744	.9af2	9d 01 03	sta $0301,x	                sta $0301,x
2745	.9af5	98		tya		                tya
2746	.9af6	9d 00 03	sta $0300,x	                sta $0300,x
2747	.9af9					L9A59:
2748	.9af9	60		rts		                rts

2750	.9afa					L9A5A:
2751	.9afa	ad 44 03	lda $0344	                lda $0344
2752	.9afd	0d 45 03	ora $0345	                ora $0345
2753	.9b00	d0 5c		bne $9b5e	                bne L9ABE
2754	.9b02	a5 e1		lda $e1		                lda $E1
2755	.9b04	1a		inc a		                inc a
2756	.9b05	29 03		and #$03	                and #$03
2757	.9b07	d0 55		bne $9b5e	                bne L9ABE
2758	.9b09	a9 20		lda #$20	                lda #$20
2759	.9b0b	2c 49 88	bit $8849	                bit L8849
2760	.9b0e	10 09		bpl $9b19	                bpl L9A79
2761	.9b10	f0 07		beq $9b19	                beq L9A79
2762	.9b12	a2 2c		ldx #$2c	                ldx #$2C
2763	.9b14	a0 46		ldy #$46	                ldy #$46
2764	.9b16	20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
2765	.9b19					L9A79:
2766	.9b19	a9 10		lda #$10	                lda #$10
2767	.9b1b	2c 49 88	bit $8849	                bit L8849
2768	.9b1e	50 09		bvc $9b29	                bvc L9A89
2769	.9b20	f0 07		beq $9b29	                beq L9A89
2770	.9b22	a2 37		ldx #$37	                ldx #$37
2771	.9b24	a0 42		ldy #$42	                ldy #$42
2772	.9b26	20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
2773	.9b29					L9A89:
2774	.9b29	20 5f 9b	jsr $9b5f	                jsr L9ABF
2775	.9b2c	a5 e1		lda $e1		                lda $E1
2776	.9b2e	49 3c		eor #$3c	                eor #$3C
2777	.9b30	2a		rol a		                rol a
2778	.9b31	20 6f c6	jsr $c66f	                jsr fixUpVPALETTEFor4Colours
2779	.9b34	6a		ror a		                ror a
2780	.9b35	85 e1		sta $e1		                sta $E1
2781	.9b37	89 20		bit #$20	                bit #$20
2782	.9b39	f0 10		beq $9b4b	                beq L9AAB
2783	.9b3b	48		pha		                pha
2784	.9b3c	a2 2c		ldx #$2c	                ldx #$2C
2785	.9b3e	a0 46		ldy #$46	                ldy #$46
2786	.9b40	20 cc d5	jsr $d5cc	                jsr sortVDUVariableWords
2787	.9b43	98		tya		                tya
2788	.9b44	aa		tax		                tax
2789	.9b45	a0 46		ldy #$46	                ldy #$46
2790	.9b47	20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
2791	.9b4a	68		pla		                pla
2792	.9b4b					L9AAB:
2793	.9b4b	89 10		bit #$10	                bit #$10
2794	.9b4d	f0 0c		beq $9b5b	                beq L9ABB
2795	.9b4f	a2 37		ldx #$37	                ldx #$37
2796	.9b51	a0 42		ldy #$42	                ldy #$42
2797	.9b53	20 cc d5	jsr $d5cc	                jsr sortVDUVariableWords
2798	.9b56	a0 42		ldy #$42	                ldy #$42
2799	.9b58	20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
2800	.9b5b					L9ABB:
2801	.9b5b	9c 49 88	stz $8849	                stz L8849
2802	.9b5e					L9ABE:
2803	.9b5e	60		rts		                rts

2805	.9b5f					L9ABF:
2806	.9b5f	a2 03		ldx #$03	                ldx #$03
2807	.9b61					L9AC1:
2808	.9b61	9e 3b 03	stz $033b,x	                stz $033B,x
2809	.9b64	ca		dex		                dex
2810	.9b65	10 fa		bpl $9b61	                bpl L9AC1
2811	.9b67	a0 28		ldy #$28	                ldy #$28
2812	.9b69	a2 1b		ldx #$1b	                ldx #$1B
2813	.9b6b	a9 2c		lda #$2c	                lda #$2C
2814	.9b6d	20 7f 9b	jsr $9b7f	                jsr L9ADF
2815	.9b70	20 a8 d6	jsr $d6a8	                jsr LD6A8
2816	.9b73	a0 1b		ldy #$1b	                ldy #$1B
2817	.9b75	a2 28		ldx #$28	                ldx #$28
2818	.9b77	a9 37		lda #$37	                lda #$37
2819	.9b79	20 7f 9b	jsr $9b7f	                jsr L9ADF
2820	.9b7c	4c 9d d6	jmp $d69d	                jmp LD69D

2822	.9b7f					L9ADF:
2823	.9b7f	48		pha		                pha
2824	.9b80	a5 e1		lda $e1		                lda $E1
2825	.9b82	4a		lsr a		                lsr a
2826	.9b83	90 0b		bcc $9b90	                bcc L9AF0
2827	.9b85	ad 47 88	lda $8847	                lda L8847
2828	.9b88	d0 04		bne $9b8e	                bne L9AEE
2829	.9b8a	a2 3b		ldx #$3b	                ldx #$3B
2830	.9b8c	80 02		bra $9b90	                bra L9AF0

2832	.9b8e					L9AEE:
2833	.9b8e	a0 3b		ldy #$3b	                ldy #$3B
2834	.9b90					L9AF0:
2835	.9b90	8a		txa		                txa
2836	.9b91	fa		plx		                plx
2837	.9b92	da		phx		                phx
2838	.9b93	48		pha		                pha
2839	.9b94	5a		phy		                phy
2840	.9b95	a8		tay		                tay
2841	.9b96	a9 03		lda #$03	                lda #$03
2842	.9b98	85 da		sta $da		                sta $DA
2843	.9b9a					L9AFA:
2844	.9b9a	b9 00 03	lda $0300,y	                lda $0300,y
2845	.9b9d	9d 1e 88	sta $881e,x	                sta L881E,x
2846	.9ba0	c8		iny		                iny
2847	.9ba1	e8		inx		                inx
2848	.9ba2	c6 da		dec $da		                dec $DA
2849	.9ba4	10 f4		bpl $9b9a	                bpl L9AFA
2850	.9ba6	7a		ply		                ply
2851	.9ba7	68		pla		                pla
2852	.9ba8	fa		plx		                plx
2853	.9ba9					L9B09:
2854	.9ba9	48		pha		                pha
2855	.9baa	5a		phy		                phy
2856	.9bab	20 01 9c	jsr $9c01	                jsr L9B61
2857	.9bae	ca		dex		                dex
2858	.9baf	7a		ply		                ply
2859	.9bb0	68		pla		                pla
2860	.9bb1	da		phx		                phx
2861	.9bb2	c8		iny		                iny
2862	.9bb3	c8		iny		                iny
2863	.9bb4	1a		inc a		                inc a
2864	.9bb5	1a		inc a		                inc a
2865	.9bb6	e8		inx		                inx
2866	.9bb7	e8		inx		                inx
2867	.9bb8	20 01 9c	jsr $9c01	                jsr L9B61
2868	.9bbb	fa		plx		                plx
2869	.9bbc	20 30 9c	jsr $9c30	                jsr L9B90
2870	.9bbf	08		php		                php
2871	.9bc0	48		pha		                pha
2872	.9bc1	bd 05 03	lda $0305,x	                lda $0305,x
2873	.9bc4	0a		asl a		                asl a
2874	.9bc5	7e 0a 03	ror $030a,x	                ror $030A,x
2875	.9bc8	10 03		bpl $9bcd	                bpl L9B2D
2876	.9bca	20 1f 9c	jsr $9c1f	                jsr L9B7F
2877	.9bcd					L9B2D:
2878	.9bcd	68		pla		                pla
2879	.9bce	0a		asl a		                asl a
2880	.9bcf	7e 0a 03	ror $030a,x	                ror $030A,x
2881	.9bd2	10 07		bpl $9bdb	                bpl L9B3B
2882	.9bd4	e8		inx		                inx
2883	.9bd5	e8		inx		                inx
2884	.9bd6	20 1f 9c	jsr $9c1f	                jsr L9B7F
2885	.9bd9	ca		dex		                dex
2886	.9bda	ca		dex		                dex
2887	.9bdb					L9B3B:
2888	.9bdb	20 30 9c	jsr $9c30	                jsr L9B90
2889	.9bde	10 06		bpl $9be6	                bpl L9B46
2890	.9be0	bd 05 03	lda $0305,x	                lda $0305,x
2891	.9be3	bc 04 03	ldy $0304,x	                ldy $0304,x
2892	.9be6					L9B46:
2893	.9be6	28		plp		                plp
2894	.9be7	30 06		bmi $9bef	                bmi L9B4F
2895	.9be9	c0 00		cpy #$00	                cpy #$00
2896	.9beb	d0 01		bne $9bee	                bne L9B4E
2897	.9bed	3a		dec a		                dec a
2898	.9bee					L9B4E:
2899	.9bee	88		dey		                dey
2900	.9bef					L9B4F:
2901	.9bef	4a		lsr a		                lsr a
2902	.9bf0	48		pha		                pha
2903	.9bf1	98		tya		                tya
2904	.9bf2	6a		ror a		                ror a
2905	.9bf3	38		sec		                sec
2906	.9bf4	ca		dex		                dex
2907	.9bf5	20 fa 9b	jsr $9bfa	                jsr L9B5A
2908	.9bf8	e8		inx		                inx
2909	.9bf9	68		pla		                pla
2910	.9bfa					L9B5A:
2911	.9bfa	fd 07 03	sbc $0307,x	                sbc $0307,x
2912	.9bfd	9d 09 03	sta $0309,x	                sta $0309,x
2913	.9c00	60		rts		                rts

2915	.9c01					L9B61:
2916	.9c01	48		pha		                pha
2917	.9c02	b9 00 03	lda $0300,y	                lda $0300,y
2918	.9c05	9d 00 03	sta $0300,x	                sta $0300,x
2919	.9c08	b9 01 03	lda $0301,y	                lda $0301,y
2920	.9c0b	9d 01 03	sta $0301,x	                sta $0301,x
2921	.9c0e	7a		ply		                ply
2922	.9c0f	38		sec		                sec
2923	.9c10	20 15 9c	jsr $9c15	                jsr L9B75
2924	.9c13	e8		inx		                inx
2925	.9c14	c8		iny		                iny
2926	.9c15					L9B75:
2927	.9c15	b9 00 03	lda $0300,y	                lda $0300,y
2928	.9c18	fd 00 03	sbc $0300,x	                sbc $0300,x
2929	.9c1b	9d 04 03	sta $0304,x	                sta $0304,x
2930	.9c1e	60		rts		                rts

2932	.9c1f					L9B7F:
2933	.9c1f	bd 05 03	lda $0305,x	                lda $0305,x
2934	.9c22	bc 04 03	ldy $0304,x	                ldy $0304,x
2935	.9c25	20 2e c9	jsr $c92e	                jsr negateAY
2936	.9c28	9d 05 03	sta $0305,x	                sta $0305,x
2937	.9c2b	98		tya		                tya
2938	.9c2c	9d 04 03	sta $0304,x	                sta $0304,x
2939	.9c2f	60		rts		                rts

2941	.9c30					L9B90:
2942	.9c30	bd 06 03	lda $0306,x	                lda $0306,x
2943	.9c33	a8		tay		                tay
2944	.9c34	dd 04 03	cmp $0304,x	                cmp $0304,x
2945	.9c37	bd 07 03	lda $0307,x	                lda $0307,x
2946	.9c3a	fd 05 03	sbc $0305,x	                sbc $0305,x
2947	.9c3d	08		php		                php
2948	.9c3e	bd 07 03	lda $0307,x	                lda $0307,x
2949	.9c41	28		plp		                plp
2950	.9c42	60		rts		                rts

2952						;-------------------------------------------------------------------------
2953						;
2954						; 112-119 = Plot parallelogram [MasRef E.3-27]
2955						;
2956	.9c43					plotParallelogram:
2957	.9c43	a2 28		ldx #$28	                ldx #$28
2958	.9c45	86 da		stx $da		                stx $DA
2959	.9c47	a2 14		ldx #$14	                ldx #$14
2960	.9c49	a0 20		ldy #$20	                ldy #$20
2961	.9c4b	a9 24		lda #$24	                lda #$24
2962	.9c4d	20 80 d5	jsr $d580	                jsr addRegionDimensionsToVDUVariableCoordinates
2963	.9c50	a0 14		ldy #$14	                ldy #$14
2964	.9c52	a2 24		ldx #$24	                ldx #$24
2965	.9c54	20 b7 d5	jsr $d5b7	                jsr sortVDUVariableCoordinates
2966	.9c57	8e 30 88	stx $8830	                stx L8830
2967	.9c5a	a2 20		ldx #$20	                ldx #$20
2968	.9c5c	20 b7 d5	jsr $d5b7	                jsr sortVDUVariableCoordinates
2969	.9c5f	8e 31 88	stx $8831	                stx L8831
2970	.9c62	a2 28		ldx #$28	                ldx #$28
2971	.9c64	20 b7 d5	jsr $d5b7	                jsr sortVDUVariableCoordinates
2972	.9c67	8c 33 88	sty $8833	                sty L8833
2973	.9c6a	ac 31 88	ldy $8831	                ldy L8831
2974	.9c6d	20 b7 d5	jsr $d5b7	                jsr sortVDUVariableCoordinates
2975	.9c70	8c 32 88	sty $8832	                sty L8832
2976	.9c73	ac 30 88	ldy $8830	                ldy L8830
2977	.9c76	20 af 9c	jsr $9caf	                jsr L9C0F
2978	.9c79	ad 33 88	lda $8833	                lda L8833
2979	.9c7c	85 e0		sta $e0		                sta $E0
2980	.9c7e	a2 2c		ldx #$2c	                ldx #$2C
2981	.9c80	20 a9 9b	jsr $9ba9	                jsr L9B09
2982	.9c83	a4 e1		ldy $e1		                ldy $E1
2983	.9c85	20 f6 9c	jsr $9cf6	                jsr L9C56
2984	.9c88	ac 32 88	ldy $8832	                ldy L8832
2985	.9c8b	ad 33 88	lda $8833	                lda L8833
2986	.9c8e	85 e1		sta $e1		                sta $E1
2987	.9c90	a2 37		ldx #$37	                ldx #$37
2988	.9c92	20 f1 9c	jsr $9cf1	                jsr L9C51
2989	.9c95	80 15		bra $9cac	                bra L9C0C

2991	.9c97					L9BF7;
2992	.9c97	a0 14		ldy #$14	                ldy #$14
2993	.9c99	a2 24		ldx #$24	                ldx #$24
2994	.9c9b	20 b7 d5	jsr $d5b7	                jsr sortVDUVariableCoordinates
2995	.9c9e	8c 32 88	sty $8832	                sty L8832
2996	.9ca1	a0 20		ldy #$20	                ldy #$20
2997	.9ca3	20 af 9c	jsr $9caf	                jsr L9C0F
2998	.9ca6	ad 32 88	lda $8832	                lda L8832
2999	.9ca9	20 ed 9c	jsr $9ced	                jsr L9C4D
3000	.9cac					L9C0C:
3001	.9cac	4c e4 da	jmp $dae4	                jmp LDAE4

3003	.9caf					L9C0F:
3004	.9caf	20 b7 d5	jsr $d5b7	                jsr sortVDUVariableCoordinates
3005	.9cb2	8e 30 88	stx $8830	                stx L8830
3006	.9cb5	ae 32 88	ldx $8832	                ldx L8832
3007	.9cb8	20 b7 d5	jsr $d5b7	                jsr sortVDUVariableCoordinates
3008	.9cbb	8c 32 88	sty $8832	                sty L8832
3009	.9cbe	8e 31 88	stx $8831	                stx L8831
3010	.9cc1	ac 30 88	ldy $8830	                ldy L8830
3011	.9cc4	a2 fc		ldx #$fc	                ldx #$FC
3012	.9cc6					L9C26:
3013	.9cc6	b9 00 03	lda $0300,y	                lda $0300,y
3014	.9cc9	9d 46 02	sta $0246,x	                sta vduv.workspace._42-$fc,x
3015	.9ccc	9d 4a 02	sta $024a,x	                sta vduv.workspace._46-$fc,x
3016	.9ccf	c8		iny		                iny
3017	.9cd0	e8		inx		                inx
3018	.9cd1	d0 f3		bne $9cc6	                bne L9C26
3019	.9cd3	ac 30 88	ldy $8830	                ldy L8830
3020	.9cd6	ad 32 88	lda $8832	                lda L8832
3021	.9cd9	85 e1		sta $e1		                sta $E1
3022	.9cdb	a2 37		ldx #$37	                ldx #$37
3023	.9cdd	20 a9 9b	jsr $9ba9	                jsr L9B09
3024	.9ce0	ac 30 88	ldy $8830	                ldy L8830
3025	.9ce3	ad 31 88	lda $8831	                lda L8831
3026	.9ce6	20 ed 9c	jsr $9ced	                jsr L9C4D
3027	.9ce9	ac 31 88	ldy $8831	                ldy L8831
3028	.9cec	60		rts		                rts

3030	.9ced					L9C4D:
3031	.9ced	85 e0		sta $e0		                sta $E0
3032	.9cef	a2 2c		ldx #$2c	                ldx #$2C
3033	.9cf1					L9C51:
3034	.9cf1	20 a9 9b	jsr $9ba9	                jsr L9B09
3035	.9cf4	a4 e0		ldy $e0		                ldy $E0
3036	.9cf6					L9C56:
3037	.9cf6	5a		phy		                phy
3038	.9cf7	b9 02 03	lda $0302,y	                lda $0302,y
3039	.9cfa	cd 44 03	cmp $0344	                cmp $0344
3040	.9cfd	d0 08		bne $9d07	                bne L9C67
3041	.9cff	b9 03 03	lda $0303,y	                lda $0303,y
3042	.9d02	cd 45 03	cmp $0345	                cmp $0345
3043	.9d05	f0 39		beq $9d40	                beq L9CA0
3044	.9d07					L9C67:
3045	.9d07	a2 2c		ldx #$2c	                ldx #$2C
3046	.9d09	20 60 9d	jsr $9d60	                jsr L9CC0
3047	.9d0c	a2 37		ldx #$37	                ldx #$37
3048	.9d0e	20 60 9d	jsr $9d60	                jsr L9CC0
3049	.9d11	20 e4 da	jsr $dae4	                jsr LDAE4
3050	.9d14	a2 37		ldx #$37	                ldx #$37
3051	.9d16	20 26 d7	jsr $d726	                jsr LD726
3052	.9d19	a2 2c		ldx #$2c	                ldx #$2C
3053	.9d1b	20 26 d7	jsr $d726	                jsr LD726
3054	.9d1e	a0 37		ldy #$37	                ldy #$37
3055	.9d20	20 cc d5	jsr $d5cc	                jsr sortVDUVariableWords
3056	.9d23	da		phx		                phx
3057	.9d24	a2 fc		ldx #$fc	                ldx #$FC
3058	.9d26					L9C86:
3059	.9d26	b9 00 03	lda $0300,y	                lda $0300,y
3060	.9d29	9d 4a 02	sta $024a,x	                sta vduv.workspace._46-$fc,x
3061	.9d2c	c8		iny		                iny
3062	.9d2d	e8		inx		                inx
3063	.9d2e	d0 f6		bne $9d26	                bne L9C86
3064	.9d30	fa		plx		                plx
3065	.9d31	a0 fc		ldy #$fc	                ldy #$FC
3066	.9d33					L9C93:
3067	.9d33	bd 00 03	lda $0300,x	                lda $0300,x
3068	.9d36	99 46 02	sta $0246,y	                sta vduv.workspace._42-$fc,y
3069	.9d39	e8		inx		                inx
3070	.9d3a	c8		iny		                iny
3071	.9d3b	d0 f6		bne $9d33	                bne L9C93
3072	.9d3d	7a		ply		                ply
3073	.9d3e	80 b6		bra $9cf6	                bra L9C56

3075	.9d40					L9CA0:
3076	.9d40	a9 2c		lda #$2c	                lda #$2C
3077	.9d42	a6 e0		ldx $e0		                ldx $E0
3078	.9d44	20 4c 9d	jsr $9d4c	                jsr L9CAC
3079	.9d47	7a		ply		                ply
3080	.9d48	a9 37		lda #$37	                lda #$37
3081	.9d4a	a6 e1		ldx $e1		                ldx $E1
3082	.9d4c					L9CAC:
3083	.9d4c	85 de		sta $de		                sta $DE
3084	.9d4e	bd 02 03	lda $0302,x	                lda vduv.graphicsWindowPixelsBottom+0,x
3085	.9d51	d9 02 03	cmp $0302,y	                cmp vduv.graphicsWindowPixelsBottom+0,y
3086	.9d54	d0 08		bne $9d5e	                bne L9CBE
3087	.9d56	bd 03 03	lda $0303,x	                lda vduv.graphicsWindowPixelsBottom+1,x
3088	.9d59	d9 03 03	cmp $0303,y	                cmp vduv.graphicsWindowPixelsBottom+1,y
3089	.9d5c	f0 05		beq $9d63	                beq L9CC3
3090	.9d5e					L9CBE:
3091	.9d5e	a6 de		ldx $de		                ldx $DE
3092	.9d60					L9CC0:
3093	.9d60	20 1d d7	jsr $d71d	                jsr LD71D
3094	.9d63					L9CC3:
3095	.9d63	bd 00 03	lda $0300,x	                lda $0300,x
3096	.9d66	cd 42 03	cmp $0342	                cmp $0342
3097	.9d69	bd 01 03	lda $0301,x	                lda $0301,x
3098	.9d6c	ed 43 03	sbc $0343	                sbc $0343
3099	.9d6f	10 0d		bpl $9d7e	                bpl L9CDE
3100	.9d71	bd 00 03	lda $0300,x	                lda $0300,x
3101	.9d74	8d 42 03	sta $0342	                sta $0342
3102	.9d77	bd 01 03	lda $0301,x	                lda $0301,x
3103	.9d7a	8d 43 03	sta $0343	                sta $0343
3104	.9d7d	60		rts		                rts

3106	.9d7e					L9CDE:
3107	.9d7e	ad 46 03	lda $0346	                lda $0346
3108	.9d81	dd 00 03	cmp $0300,x	                cmp $0300,x
3109	.9d84	ad 47 03	lda $0347	                lda $0347
3110	.9d87	fd 01 03	sbc $0301,x	                sbc $0301,x
3111	.9d8a	10 0c		bpl $9d98	                bpl L9CF8
3112	.9d8c	bd 00 03	lda $0300,x	                lda $0300,x
3113	.9d8f	8d 46 03	sta $0346	                sta $0346
3114	.9d92	bd 01 03	lda $0301,x	                lda $0301,x
3115	.9d95	8d 47 03	sta $0347	                sta $0347
3116	.9d98					L9CF8:
3117	.9d98	60		rts		                rts

3119	.9d99					L9CF9:
3120	.9d99	20 a1 dd	jsr $dda1	                jsr LDDA1
3121	.9d9c	9c 36 03	stz $0336	                stz $0336
3122	.9d9f	9c 37 03	stz $0337	                stz $0337
3123	.9da2	20 b0 dc	jsr $dcb0	                jsr LDCB0
3124	.9da5	d0 4f		bne $9df6	                bne L9D56
3125	.9da7	20 1c dc	jsr $dc1c	                jsr LDC1C
3126	.9daa					L9D0A:
3127	.9daa	24 ff		bit $ff		                bit $FF
3128	.9dac	30 48		bmi $9df6	                bmi L9D56
3129	.9dae	ad 36 03	lda $0336	                lda $0336
3130	.9db1	cd 37 03	cmp $0337	                cmp $0337
3131	.9db4	f0 40		beq $9df6	                beq L9D56
3132	.9db6	1a		inc a		                inc a
3133	.9db7	8d 36 03	sta $0336	                sta $0336
3134	.9dba	aa		tax		                tax
3135	.9dbb	bd 00 84	lda $8400,x	                lda L8400,x
3136	.9dbe	8d 28 03	sta $0328	                sta $0328
3137	.9dc1	bd 00 85	lda $8500,x	                lda L8500,x
3138	.9dc4	8d 2c 03	sta $032c	                sta $032C
3139	.9dc7	bd 00 86	lda $8600,x	                lda L8600,x
3140	.9dca	48		pha		                pha
3141	.9dcb	4a		lsr a		                lsr a
3142	.9dcc	4a		lsr a		                lsr a
3143	.9dcd	8d 29 03	sta $0329	                sta $0329
3144	.9dd0	68		pla		                pla
3145	.9dd1	29 03		and #$03	                and #$03
3146	.9dd3	8d 2d 03	sta $032d	                sta $032D
3147	.9dd6	bd 00 87	lda $8700,x	                lda L8700,x
3148	.9dd9	9c 2b 03	stz $032b	                stz $032B
3149	.9ddc	cd 06 03	cmp $0306	                cmp $0306
3150	.9ddf	f0 0a		beq $9deb	                beq L9D4B
3151	.9de1	85 e0		sta $e0		                sta $E0
3152	.9de3	1a		inc a		                inc a
3153	.9de4	20 48 dc	jsr $dc48	                jsr LDC48
3154	.9de7	b0 0d		bcs $9df6	                bcs L9D56
3155	.9de9	a5 e0		lda $e0		                lda $E0
3156	.9deb					L9D4B:
3157	.9deb	cd 02 03	cmp $0302	                cmp $0302
3158	.9dee	f0 ba		beq $9daa	                beq L9D0A
3159	.9df0	3a		dec a		                dec a
3160	.9df1	20 48 dc	jsr $dc48	                jsr LDC48
3161	.9df4	90 b4		bcc $9daa	                bcc L9D0A
3162	.9df6					L9D56:
3163	.9df6	60		rts		                rts

3165	.9df7					L9D57:
3166	.9df7	ad 32 03	lda $0332	                lda $0332
3167	.9dfa	a8		tay		                tay
3168	.9dfb	cd 2c 03	cmp $032c	                cmp $032C
3169	.9dfe	ad 33 03	lda $0333	                lda $0333
3170	.9e01	aa		tax		                tax
3171	.9e02	ed 2d 03	sbc $032d	                sbc $032D
3172	.9e05	b0 0a		bcs $9e11	                bcs L9D71
3173	.9e07	c8		iny		                iny
3174	.9e08	d0 01		bne $9e0b	                bne L9D6B
3175	.9e0a	e8		inx		                inx
3176	.9e0b					L9D6B:
3177	.9e0b	8c 2e 03	sty $032e	                sty $032E
3178	.9e0e	8e 2f 03	stx $032f	                stx $032F
3179	.9e11					L9D71:
3180	.9e11	60		rts		                rts

3182						;-------------------------------------------------------------------------

3185	.9e12					readDefaults2:
3186	.9e12	a2 0f		ldx #$0f	                ldx #CMOSBytes.defaults2
3187	.9e14	80 24		bra $9e3a	                bra readRTCByte

3190						;-------------------------------------------------------------------------

3193	.9e16					readDefaults3:
3194	.9e16	a2 10		ldx #$10	                ldx #CMOSBytes.defaults3
3195	.9e18	80 20		bra $9e3a	                bra readRTCByte

3198						;-------------------------------------------------------------------------
3199						;
3200						; Read byte from EEPROM by 0-based CMOS RAM offset (readCMOSByte) or
3201						; RTC register index (readRTCByte).
3202						;
3203						; (The number of RTC registers on the Compact is 0, so readRTCByte and
3204						; readCMOSByte use the same indexes. Nevertheless, the two routines
3205						; behave differently... presumably I still haven't quite got this bit
3206						; right.)
3207						;
3208						; entry:
3209						;
3210						; X = address to read from
3211						;
3212						; exit:
3213						;
3214						; A = Y = byte read

3217	.9e1a					readCMOSByte:
3218	.9e1a	e0 ff		cpx #$ff	                cpx #$ff
3219	.9e1c	d0 1c		bne $9e3a	                bne readRTCByte              ; taken if address not $ff

3221						                ; Read address $ff to query the size.
3222	.9e1e	20 bb 90	jsr $90bb	                jsr i2cTestReadEEPROMByte    ; do an experimental read
3223	.9e21	a0 00		ldy #$00	                ldy #0                       ; failure result is 0
3224	.9e23	b0 2b		bcs $9e50	                bcs rts9DE0 ; taken if read failed - no EEPROM present
3225	.9e25	a2 7f		ldx #$7f	                ldx #$7f
3226	.9e27	20 3b 9f	jsr $9f3b	                jsr i2cReadEEPROMByte        ; read the byte at $7f
3227	.9e2a	5a		phy		                phy                          ; save the byte read
3228	.9e2b	a2 ff		ldx #$ff	                ldx #$ff
3229	.9e2d	20 3b 9f	jsr $9f3b	                jsr i2cReadEEPROMByte        ; read the byte at $ff
3230	.9e30	98		tya		                tya                          ; A = byte from $ff
3231	.9e31	ba		tsx		                tsx

3233	.9e32	5d 01 01	eor $0101,x	                eor $101,x
3234						                ; The EEPROM contents reset code EORs the byte at +$7f
3235						                ; with $80, and stores that at +$ff. So either the
3236						                ; result is 0 (+$7f and +$ff are the same byte: it's a
3237						                ; 128-byte EEPROM) or it's a value with bit 8 clear
3238						                ; (+$7f and +$ff are not the same byte: it's a
3239						                ; 256-byte EEPROM).
3240	.9e35	09 7f		ora #$7f	                ora #$7f ; 127 if 128-byte EEPROM; 255 if 256-byte EEPROM
3241	.9e37	a8		tay		                tay
3242	.9e38	80 15		bra $9e4f	                bra plx_rts9DDF

3246	.9e3a					readRTCByte: .block
3247	.9e3a	da		phx		                phx
3248	.9e3b	20 bb 90	jsr $90bb	                jsr i2cTestReadEEPROMByte
3249	.9e3e	90 0b		bcc $9e4b	                bcc addressIsValid           ; taken if read succeeded
3250	.9e40					readDefaultByte:
3251	.9e40	a0 00		ldy #$00	                ldy #0                 ; default failure result is 0
3252	.9e42	e0 14		cpx #$14	                cpx #cmosBytesSize     ; trying to read a known value?
3253	.9e44	b0 08		bcs $9e4e	                bcs gotResult   ; taken if failed to read an unknown value
3254	.9e46	bc 54 9e	ldy $9e54,x	                ldy defaultEEPROMContents,x ; use a default value for failed read
3255	.9e49	80 03		bra $9e4e	                bra gotResult

3257	.9e4b					addressIsValid:
3258	.9e4b	20 3b 9f	jsr $9f3b	                jsr i2cReadEEPROMByte
3259	.9e4e					gotResult:
3260	.9e4e	98		tya		                tya
3262						                .endblock
3263	.9e4f					plx_rts9DDF:
3264	.9e4f	fa		plx		                plx
3265	.9e50					rts9DE0:
3266	.9e50	60		rts		                rts

3268	.9e51					readDefaultCMOSByte:
3269	.9e51	da		phx		                phx
3270	.9e52	80 ec		bra $9e40	                bra readRTCByte.readDefaultByte

3272	.9e54					defaultEEPROMContents:
3273						                ; Default EEPROM contents - for use if the EEPROM runs
3274						                ; out of write cycles?
3275	>9e54	00				                .byte 0                      ; econetStationNumber
3276	>9e55	fe				                .byte 254                    ; fileServerStationNumber
3277	>9e56	00				                .byte 0                      ; fileServerNetworkNumber
3278	>9e57	eb				                .byte $EB                    ; printerServerStationNumber
3279	>9e58	00				                .byte 0                      ; printerServerNetworkNumber
3280	>9e59	ed				                .byte 14<<CMOSBytes.defaultROMs.languageShift|13<<CMOSBytes.defaultROMs.fsShift
3281	>9e5a	ff				                .byte $FF                    ; insertedROMS 8-15
3282	>9e5b	ff				                .byte $FF                    ; insertedROMS 0-7
3283	>9e5c	00				                .byte 0                      ; editROMBytes
3284	>9e5d	00				                .byte 0                      ; telecommsByte
3286	>9e5e	f9				                .byte (defaultMODE&7)<<CMOSBytes.defaults0.modeShift|((defaultMODE&$80)!=0?CMOSBytes.defaults0.shadowMask:0)|CMOSBytes.defaults0.interlaceMask|7<<CMOSBytes.defaults0.tvShift ; defaults0
3287	>9e5f	e3				                .byte 3<<CMOSBytes.defaults1.fdriveShift|CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.adfsLoadDirMask|CMOSBytes.defaults1.floppyDrive ; defaults1
3288	>9e60	20				                .byte 32                     ; keyboardAutoRepeatDelay
3289	>9e61	08				                .byte 8                      ; keyboardAutoRepeatRate
3290	>9e62	0a				                .byte $A                     ; printerIgnoreChar
3291	>9e63	2c				                .byte 1<<CMOSBytes.defaults2.fx5SettingShift|3<<CMOSBytes.defaults2.serialBaudRateIndexShift ; defaults2
3292	>9e64	80				                .byte 4<<CMOSBytes.defaults3.serialDataFormatShift ; defaults3
3293	>9e65	00				                .byte 0                      ; unknown11
3294	>9e66	03				                .byte 3                      ; joystick
3296	>9e67	04				                .byte 4                      ; country
3301						                .cwarn *-defaultEEPROMContents!=cmosBytesSize

3304						;-------------------------------------------------------------------------

3307	.9e68					rts9DF7:
3308	.9e68	60		rts		                rts
3309	.9e69					writeCMOSByte:
3310	.9e69	8a		txa		                txa
3311						                ; The app note says a 256-byte EEPROM could be fitted,
3312						                ; and there's the size test code to check for it, but
3313						                ; looks the last 128 bytes would never get used.
3314	.9e6a	29 7f		and #$7f	                and #$7f
3315						                ; Location 0 is protected - see Master Reference
3316						                ; Manual D.2-49.
3317	.9e6c	f0 fa		beq $9e68	                beq rts9DF7              ; taken if address $00 (or $80)
3318	.9e6e	09 80		ora #$80	                ora #$80
3319						                ; Location 127 is protected - see Compact Application
3320						                ; Note.
3321	.9e70	1a		inc a		                inc a
3322	.9e71	f0 f5		beq $9e68	                beq rts9DF7              ; taken if address $7f (or $ff)
3323	.9e73					writeRTCByte:
3324	.9e73	da		phx		                phx
3325	.9e74	5a		phy		                phy
3326	.9e75	20 0a 9f	jsr $9f0a	                jsr L9E99
3327	.9e78	7a		ply		                ply
3328	.9e79	fa		plx		                plx
3329	.9e7a	60		rts		                rts

3332						;-------------------------------------------------------------------------
3333						;
3334						; Transmit 1 bit over the I2C bus.
3335						;
3336						; preserves: P
3337						;
3339	.9e7b					i2cTransmitBit:
3340	.9e7b	08		php		                php
3341	.9e7c	78		sei		                sei
3342	.9e7d	20 98 9e	jsr $9e98	                jsr i2cSetClockLow
3343	.9e80	20 f1 9e	jsr $9ef1	                jsr i2cSetData
3344	.9e83	20 8b 9e	jsr $9e8b	                jsr i2cSetClockHigh
3345	.9e86	20 98 9e	jsr $9e98	                jsr i2cSetClockLow
3346	.9e89	28		plp		                plp
3347	.9e8a	60		rts		                rts

3350						;-------------------------------------------------------------------------
3351						;
3352						; Set the I2C clock line high.
3353						;
3354						; preserves: A/X/Y/C
3355						;
3357	.9e8b					i2cSetClockHigh:
3358	.9e8b	48		pha		                pha
3359	.9e8c	ad 40 fe	lda $fe40	                lda systemVIA.irb
3360	.9e8f	29 df		and #$df	                and #~i2cClock               ; seems needless?
3361	.9e91	09 20		ora #$20	                ora #i2cClock
3362	.9e93	8d 40 fe	sta $fe40	                sta systemVIA.orb
3363	.9e96	68		pla		                pla
3364	.9e97	60		rts		                rts

3367						;-------------------------------------------------------------------------
3368						;
3369						; Set the I2C clock line low.
3370						;
3371						; preserves: A/X/Y/C
3372						;
3374	.9e98					i2cSetClockLow:
3375	.9e98	48		pha		                pha
3376	.9e99	ad 40 fe	lda $fe40	                lda systemVIA.irb
3377	.9e9c	29 df		and #$df	                and #~i2cClock
3378	.9e9e	8d 40 fe	sta $fe40	                sta systemVIA.orb
3379	.9ea1	68		pla		                pla
3380	.9ea2	60		rts		                rts

3383						;-------------------------------------------------------------------------
3384						;
3385						; "A change in the state of the data line, from HIGH to LOW, while the
3386						; clock is HIGH, defines the START condition."
3387						;
3388						; preserves: X/Y/P
3390	.9ea3					i2cStartDataTransfer:
3391	.9ea3	08		php		                php
3392	.9ea4	78		sei		                sei
3393	.9ea5	ad 42 fe	lda $fe42	                lda systemVIA.ddrb
3394	.9ea8	09 30		ora #$30	                ora #i2cClock|i2cData        ; I2C lines are outputs
3395	.9eaa	8d 42 fe	sta $fe42	                sta systemVIA.ddrb
3396	.9ead	20 98 9e	jsr $9e98	                jsr i2cSetClockLow
3397	.9eb0	20 f3 9e	jsr $9ef3	                jsr i2cSetDataHigh
3398	.9eb3	20 8b 9e	jsr $9e8b	                jsr i2cSetClockHigh
3399	.9eb6	20 be 9e	jsr $9ebe	                jsr i2cSetDataLow
3400	.9eb9	20 98 9e	jsr $9e98	                jsr i2cSetClockLow
3401	.9ebc	28		plp		                plp
3402	.9ebd	60		rts		                rts

3405						;-------------------------------------------------------------------------
3406						;
3407						; Set the I2C data line low.
3408						;
3409						; preserves: A/X/Y/C
3410						;
3412	.9ebe					i2cSetDataLow:
3413	.9ebe	48		pha		                pha
3414	.9ebf	ad 40 fe	lda $fe40	                lda systemVIA.irb
3415	.9ec2	29 ef		and #$ef	                and #~i2cData
3416	.9ec4	8d 40 fe	sta $fe40	                sta systemVIA.orb
3417	.9ec7	68		pla		                pla
3418	.9ec8	60		rts		                rts

3421						;-------------------------------------------------------------------------

3424	.9ec9					L9E58:
3425	.9ec9	20 a3 9e	jsr $9ea3	                jsr i2cStartDataTransfer
3426	.9ecc	a9 00		lda #$00	                lda #0                       ; What is this value?
3427	.9ece	20 94 9f	jsr $9f94	                jsr i2cTransmitByteAndReceiveBit
3428	.9ed1	a9 06		lda #$06	                lda #6                       ; What is this value?
3429	.9ed3	20 94 9f	jsr $9f94	                jsr i2cTransmitByteAndReceiveBit

3432						;-------------------------------------------------------------------------
3433						;
3434						; "A change in the state of the data line, from LOW to HIGH, while the
3435						; clock is HIGH, defines the STOP condition."
3436						;
3437						; preserves: C
3438						;
3439	.9ed6					i2cStopDataTransfer:
3440	.9ed6	08		php		                php
3441	.9ed7	78		sei		                sei
3442	.9ed8	20 98 9e	jsr $9e98	                jsr i2cSetClockLow
3443	.9edb	20 be 9e	jsr $9ebe	                jsr i2cSetDataLow
3444	.9ede	20 8b 9e	jsr $9e8b	                jsr i2cSetClockHigh
3445	.9ee1	20 f3 9e	jsr $9ef3	                jsr i2cSetDataHigh
3446	.9ee4	20 98 9e	jsr $9e98	                jsr i2cSetClockLow
3447	.9ee7	ad 42 fe	lda $fe42	                lda systemVIA.ddrb
3448	.9eea	29 cf		and #$cf	                and #~(i2cData|i2cClock)     ; I2C lines are inputs
3449	.9eec	8d 42 fe	sta $fe42	                sta systemVIA.ddrb
3450	.9eef	28		plp		                plp
3451	.9ef0	60		rts		                rts

3454						;-------------------------------------------------------------------------
3455						;
3456						; Set the I2C data line to a particular value.
3457						;
3458						; entry:
3459						;
3460						; C = state of signal: 1 = high, 0 = low
3461						;
3462						; preserves: C

3465	.9ef1					i2cSetData:
3466	.9ef1	90 cb		bcc $9ebe	                bcc i2cSetDataLow

3470						;-------------------------------------------------------------------------
3471						;
3472						; Set the I2C data line high.
3473						;
3474						; preserves: A/X/Y/C
3475						;
3477	.9ef3					i2cSetDataHigh:
3478	.9ef3	48		pha		                pha
3479	.9ef4	ad 40 fe	lda $fe40	                lda systemVIA.irb
3480	.9ef7	09 10		ora #$10	                ora #i2cData
3481	.9ef9	8d 40 fe	sta $fe40	                sta systemVIA.orb
3482	.9efc	68		pla		                pla
3483	.9efd	60		rts		                rts

3486						;-------------------------------------------------------------------------
3487						;
3488						; Transmits 1 byte/8 bits over the I2C bus.
3489						;
3490						; entry: A = byte to transmit

3493	.9efe					i2cTransmitByte: .block
3494	.9efe	08		php		                php
3495	.9eff	78		sei		                sei
3496	.9f00	38		sec		                sec
3497	.9f01	2a		rol a		                rol a
3498	.9f02					loop:
3499	.9f02	20 7b 9e	jsr $9e7b	                jsr i2cTransmitBit
3500	.9f05	0a		asl a		                asl a
3501	.9f06	d0 fa		bne $9f02	                bne loop
3502	.9f08	28		plp		                plp
3503	.9f09	60		rts		                rts
3504						                .endblock

3507						;-------------------------------------------------------------------------

3510	.9f0a					L9E99: .block
3511	.9f0a	da		phx		                phx                          ; X
3512	.9f0b	5a		phy		                phy                          ; Y X
3513	.9f0c	20 3b 9f	jsr $9f3b	                jsr i2cReadEEPROMByte
3514	.9f0f	b0 07		bcs $9f18	                bcs writeIfCarry ; taken if read failed. Attempt write anyawy

3516						                ; Compare new value to old value, and write only if
3517						                ; different. Don't use up the EEPROM write cycles
3518						                ; unnecessarily.
3519	.9f11	98		tya		                tya
3520	.9f12	ba		tsx		                tsx                          ; | Y X
3521	.9f13	5d 01 01	eor $0101,x	                eor $101,x                   ; Y^(old Y)
3522	.9f16	c9 01		cmp #$01	                cmp #1  ; C set if new value is different, so attempt write
3523	.9f18					writeIfCarry:
3524	.9f18	7a		ply		                ply
3525	.9f19	fa		plx		                plx
3526	.9f1a	b0 01		bcs $9f1d	                bcs write
3527	.9f1c	60		rts		                rts

3529	.9f1d					write:
3530	.9f1d	20 a3 9e	jsr $9ea3	                jsr i2cStartDataTransfer
3531	.9f20	a9 a0		lda #$a0	                lda #eepromWrite
3532	.9f22	20 94 9f	jsr $9f94	                jsr i2cTransmitByteAndReceiveBit ; initiate write mode
3533	.9f25	8a		txa		                txa
3534	.9f26	20 94 9f	jsr $9f94	                jsr i2cTransmitByteAndReceiveBit ; send address
3535	.9f29	98		tya		                tya
3536	.9f2a	20 94 9f	jsr $9f94	                jsr i2cTransmitByteAndReceiveBit ; send value
3537	.9f2d	20 d6 9e	jsr $9ed6	                jsr i2cStopDataTransfer

3539						                ; After writing 1 or 2 bytes and entering the STOP
3540						                ; state, the write process begins, Delay ~100 ms to
3541						                ; wait for it. (The data sheet implies 20 ms/byte is
3542						                ; sufficient, but surely no harm in waiting longer.)
3543	.9f30	a0 a0		ldy #$a0	                ldy #$a0
3544	.9f32	a2 00		ldx #$00	                ldx #0
3545	.9f34					delayLoop:
3546	.9f34	ca		dex		                dex
3547	.9f35	d0 fd		bne $9f34	                bne delayLoop
3548	.9f37	88		dey		                dey
3549	.9f38	d0 fa		bne $9f34	                bne delayLoop
3550	.9f3a	60		rts		                rts
3551						                .endblock

3553						;-------------------------------------------------------------------------
3554						;
3555						; Read 1 byte from EEPROM
3556						;
3557						; entry:
3558						;
3559						; X = address to read from
3560						;
3561						; exit:
3562						;
3563						; C=0 = success
3564						;       Y = byte read
3565						; C=1 = failure
3566						;
3567	.9f3b					i2cReadEEPROMByte:
3568	.9f3b	20 a3 9e	jsr $9ea3	                jsr i2cStartDataTransfer

3570						                ; Send %1010, I2C address, and not-write flag
3571	.9f3e	a9 a0		lda #$a0	                lda #eepromWrite
3572	.9f40	20 94 9f	jsr $9f94	                jsr i2cTransmitByteAndReceiveBit

3574						                ; Send word address
3575	.9f43	8a		txa		                txa
3576	.9f44	20 94 9f	jsr $9f94	                jsr i2cTransmitByteAndReceiveBit
3577	.9f47	b0 36		bcs $9f7f	                bcs L9F0E_500              ; taken if not acknowledged

3579						                ; And again, this time in read mode
3580	.9f49	20 a3 9e	jsr $9ea3	                jsr i2cStartDataTransfer
3581	.9f4c	a9 a1		lda #$a1	                lda #eepromRead
3582	.9f4e	20 94 9f	jsr $9f94	                jsr i2cTransmitByteAndReceiveBit
3583	.9f51	b0 2c		bcs $9f7f	                bcs L9F0E_500                ; taken if not acknowledged

3585	.9f53	20 98 9e	jsr $9e98	                jsr i2cSetClockLow
3586	.9f56	ad 42 fe	lda $fe42	                lda systemVIA.ddrb
3587	.9f59	48		pha		                pha                          ; save old DDRB
3588	.9f5a	29 ef		and #$ef	                and #~i2cData
3589	.9f5c	8d 42 fe	sta $fe42	                sta systemVIA.ddrb           ; set I2C data line as input
3590	.9f5f	a9 01		lda #$01	                lda #1                 ; add terminating bit to result
3591	.9f61					L9EF0:
3592	.9f61	48		pha		                pha                          ; save current result
3593	.9f62	20 8b 9e	jsr $9e8b	                jsr i2cSetClockHigh
3594	.9f65	ea		nop		                nop                          ; wait +1 microsecond
3595	.9f66	ea		nop		                nop                          ; wait +1 microsecond
3596	.9f67	ad 40 fe	lda $fe40	                lda systemVIA.irb
3597	.9f6a	29 10		and #$10	                and #i2cData
3598	.9f6c	c9 01		cmp #$01	                cmp #1                       ; C=1 if data received
3599	.9f6e	20 98 9e	jsr $9e98	                jsr i2cSetClockLow
3600	.9f71	68		pla		                pla                          ; restore current result
3601	.9f72	2a		rol a		                rol a                        ; shift new bit in
3602	.9f73	90 ec		bcc $9f61	                bcc L9EF0                    ; keep going until 8 bits
3603						                                             ; shifted in
3604	.9f75	a8		tay		                tay
3605	.9f76	68		pla		                pla                          ; restore old DDRB
3606	.9f77	8d 42 fe	sta $fe42	                sta systemVIA.ddrb
3607	.9f7a	38		sec		                sec
3608	.9f7b	20 7b 9e	jsr $9e7b	                jsr i2cTransmitBit           ; transmit acknowledge bit
3609	.9f7e	18		clc		                clc                          ; success - clear carry
3610	.9f7f					L9F0E_500:
3611	.9f7f	4c d6 9e	jmp $9ed6	                jmp i2cStopDataTransfer

3614						;-------------------------------------------------------------------------

3617	.9f82					L9F11:
3618	.9f82	20 a3 9e	jsr $9ea3	                jsr i2cStartDataTransfer
3619	.9f85	a9 a0		lda #$a0	                lda #eepromWrite
3620	.9f87	20 94 9f	jsr $9f94	                jsr i2cTransmitByteAndReceiveBit
3621	.9f8a	8a		txa		                txa
3622	.9f8b	20 94 9f	jsr $9f94	                jsr i2cTransmitByteAndReceiveBit
3623	.9f8e	08		php		                php
3624	.9f8f	20 d6 9e	jsr $9ed6	                jsr i2cStopDataTransfer
3625	.9f92	28		plp		                plp
3626	.9f93	60		rts		                rts

3629						;-------------------------------------------------------------------------

3632	.9f94					i2cTransmitByteAndReceiveBit: .block
3633	.9f94	08		php		                php
3634	.9f95	78		sei		                sei
3635	.9f96	20 fe 9e	jsr $9efe	                jsr i2cTransmitByte
3636	.9f99	20 98 9e	jsr $9e98	                jsr i2cSetClockLow
3637	.9f9c	ad 42 fe	lda $fe42	                lda systemVIA.ddrb
3638	.9f9f	48		pha		                pha
3639	.9fa0	29 ef		and #$ef	                and #~i2cData
3640	.9fa2	8d 42 fe	sta $fe42	                sta systemVIA.ddrb           ; set data line as input
3641	.9fa5	20 8b 9e	jsr $9e8b	                jsr i2cSetClockHigh
3642	.9fa8	ea		nop		                nop
3643	.9fa9	ea		nop		                nop
3644	.9faa	ad 40 fe	lda $fe40	                lda systemVIA.irb
3645	.9fad	29 10		and #$10	                and #i2cData
3646	.9faf	c9 01		cmp #$01	                cmp #1                       ; C=bit read
3647	.9fb1	20 98 9e	jsr $9e98	                jsr i2cSetClockLow
3648	.9fb4	68		pla		                pla
3649	.9fb5	8d 42 fe	sta $fe42	                sta systemVIA.ddrb
3650	.9fb8	b0 03		bcs $9fbd	                bcs returnWithCarrySet
3651	.9fba	28		plp		                plp
3652	.9fbb	18		clc		                clc
3653	.9fbc	60		rts		                rts

3655	.9fbd					returnWithCarrySet:
3656	.9fbd	28		plp		                plp
3657	.9fbe	38		sec		                sec
3658	.9fbf	60		rts		                rts
3659						                .endblock

3662						;-------------------------------------------------------------------------

3665						                .include "sound_stuff.s65"

:12	;******  Processing file: src/sound_stuff.s65

1						; Table to convert channel number to the bits required by the chip
2	.9fc0					soundParameterTable:
3	>9fc0	e0 c0 a0 80			                .byte $e0,$c0,$a0,$80

5						;-------------------------------------------------------------------------

7	.9fc4					LF413:
8	.9fc4	4c d1 a0	jmp $a0d1	                jmp LF520

10						;-------------------------------------------------------------------------

13	.9fc7					LF416Internal:                 ; need a better naming convention here.
17	.9fc7	a2 00		ldx #$00	                ldx #$00
18	.9fc9	ad 38 08	lda $0838	                lda $0838
19	.9fcc	d0 04		bne $9fd2	                bne LF421
20	.9fce	e8		inx		                inx
21	.9fcf	ce 38 08	dec $0838	                dec $0838
22	.9fd2					LF421:
23	.9fd2	8e 3b 08	stx $083b	                stx $083B
24	.9fd5	a2 08		ldx #$08	                ldx #$08
25	.9fd7					LF426:
26	.9fd7	ca		dex		                dex
27	.9fd8	bd 00 08	lda $0800,x	                lda $0800,x
28	.9fdb	f0 e7		beq $9fc4	                beq LF413
29	.9fdd	bd ce 02	lda $02ce,x	                lda bufferEmptyFlags,x
30	.9fe0	30 05		bmi $9fe7	                bmi LF436
31	.9fe2	bd 18 08	lda $0818,x	                lda $0818,x
32	.9fe5	d0 08		bne $9fef	                bne LF43E
33	.9fe7					LF436:
34	.9fe7	20 d9 a0	jsr $a0d9	                jsr LF528
35	.9fea	bd 18 08	lda $0818,x	                lda $0818,x
36	.9fed	f0 12		beq $a001	                beq LF450
37	.9fef					LF43E:
38	.9fef	1a		inc a		                inc a
39	.9ff0	f0 12		beq $a004	                beq LF453
40	.9ff2	de 1c 08	dec $081c,x	                dec $081C,x
41	.9ff5	d0 0d		bne $a004	                bne LF453
42	.9ff7	a9 05		lda #$05	                lda #$05
43	.9ff9	9d 1c 08	sta $081c,x	                sta $081C,x
44	.9ffc	de 18 08	dec $0818,x	                dec $0818,x
45	.9fff	d0 03		bne $a004	                bne LF453
46	.a001					LF450:
47	.a001	20 d9 a0	jsr $a0d9	                jsr LF528
48	.a004					LF453:
49	.a004	bd 24 08	lda $0824,x	                lda $0824,x
50	.a007	f0 05		beq $a00e	                beq LF45D
51	.a009	de 24 08	dec $0824,x	                dec $0824,x
52	.a00c	d0 b6		bne $9fc4	                bne LF413
53	.a00e					LF45D:
54	.a00e	bc 20 08	ldy $0820,x	                ldy $0820,x
55	.a011	c0 ff		cpy #$ff	                cpy #$FF
56	.a013	f0 af		beq $9fc4	                beq LF413
57	.a015	b9 c0 08	lda $08c0,y	                lda $08C0,y
58	.a018	29 7f		and #$7f	                and #$7F
59	.a01a	9d 24 08	sta $0824,x	                sta $0824,x
60	.a01d	bd 08 08	lda $0808,x	                lda $0808,x
61	.a020	c9 04		cmp #$04	                cmp #$04
62	.a022	f0 5d		beq $a081	                beq LF4D0
63	.a024	18		clc		                clc
64	.a025	7d 20 08	adc $0820,x	                adc $0820,x
65	.a028	a8		tay		                tay
66	.a029	b9 cb 08	lda $08cb,y	                lda $08CB,y
67	.a02c	38		sec		                sec
68	.a02d	e9 3f		sbc #$3f	                sbc #$3F
69	.a02f	8d 3a 08	sta $083a	                sta $083A
70	.a032	b9 c7 08	lda $08c7,y	                lda $08C7,y
71	.a035	8d 39 08	sta $0839	                sta $0839
72	.a038	bd 04 08	lda $0804,x	                lda $0804,x
73	.a03b					LF48A:
74	.a03b	48		pha		                pha
75	.a03c	18		clc		                clc
76	.a03d	6d 39 08	adc $0839	                adc $0839
77	.a040	50 07		bvc $a049	                bvc LF498
78	.a042	2a		rol a		                rol a
79	.a043	a9 3f		lda #$3f	                lda #$3F
80	.a045	b0 02		bcs $a049	                bcs LF498
81	.a047	49 ff		eor #$ff	                eor #$FF
82	.a049					LF498:
83	.a049	9d 04 08	sta $0804,x	                sta $0804,x
84	.a04c	2a		rol a		                rol a
85	.a04d	5d 04 08	eor $0804,x	                eor $0804,x
86	.a050	10 09		bpl $a05b	                bpl LF4AA
87	.a052	a9 3f		lda #$3f	                lda #$3F
88	.a054	90 02		bcc $a058	                bcc LF4A7
89	.a056	49 ff		eor #$ff	                eor #$FF
90	.a058					LF4A7:
91	.a058	9d 04 08	sta $0804,x	                sta $0804,x
92	.a05b					LF4AA:
93	.a05b	ce 39 08	dec $0839	                dec $0839
94	.a05e	bd 04 08	lda $0804,x	                lda $0804,x
95	.a061	38		sec		                sec
96	.a062	ed 3a 08	sbc $083a	                sbc $083A
97	.a065	4d 39 08	eor $0839	                eor $0839
98	.a068	30 09		bmi $a073	                bmi LF4C2
99	.a06a	ad 3a 08	lda $083a	                lda $083A
100	.a06d	9d 04 08	sta $0804,x	                sta $0804,x
101	.a070	fe 08 08	inc $0808,x	                inc $0808,x
102	.a073					LF4C2:
103	.a073	68		pla		                pla
104	.a074	5d 04 08	eor $0804,x	                eor $0804,x
105	.a077	29 f8		and #$f8	                and #$F8
106	.a079	f0 06		beq $a081	                beq LF4D0
107	.a07b	bd 04 08	lda $0804,x	                lda $0804,x
108	.a07e	20 4a a1	jsr $a14a	                jsr LF599
109	.a081					LF4D0:
110	.a081	bd 10 08	lda $0810,x	                lda $0810,x
111	.a084	c9 03		cmp #$03	                cmp #$03
112	.a086	f0 49		beq $a0d1	                beq LF520
113	.a088	bd 14 08	lda $0814,x	                lda $0814,x
114	.a08b	d0 28		bne $a0b5	                bne LF504
115	.a08d	fe 10 08	inc $0810,x	                inc $0810,x
116	.a090	bd 10 08	lda $0810,x	                lda $0810,x
117	.a093	c9 03		cmp #$03	                cmp #$03
118	.a095	d0 0e		bne $a0a5	                bne LF4F4
119	.a097	bc 20 08	ldy $0820,x	                ldy $0820,x
120	.a09a	b9 c0 08	lda $08c0,y	                lda $08C0,y
121	.a09d	30 32		bmi $a0d1	                bmi LF520
122	.a09f	9e 30 08	stz $0830,x	                stz $0830,x
123	.a0a2	9e 10 08	stz $0810,x	                stz $0810,x
124	.a0a5					LF4F4:
125	.a0a5	bd 10 08	lda $0810,x	                lda $0810,x
126	.a0a8	18		clc		                clc
127	.a0a9	7d 20 08	adc $0820,x	                adc $0820,x
128	.a0ac	a8		tay		                tay
129	.a0ad	b9 c4 08	lda $08c4,y	                lda $08C4,y
130	.a0b0	9d 14 08	sta $0814,x	                sta $0814,x
131	.a0b3	f0 1c		beq $a0d1	                beq LF520
132	.a0b5					LF504:
133	.a0b5	de 14 08	dec $0814,x	                dec $0814,x
134	.a0b8	bd 20 08	lda $0820,x	                lda $0820,x
135	.a0bb	18		clc		                clc
136	.a0bc	7d 10 08	adc $0810,x	                adc $0810,x
137	.a0bf	a8		tay		                tay
138	.a0c0	b9 c1 08	lda $08c1,y	                lda $08C1,y
139	.a0c3	18		clc		                clc
140	.a0c4	7d 30 08	adc $0830,x	                adc $0830,x
141	.a0c7	9d 30 08	sta $0830,x	                sta $0830,x
142	.a0ca	18		clc		                clc
143	.a0cb	7d 0c 08	adc $080c,x	                adc $080C,x
144	.a0ce	20 86 a1	jsr $a186	                jsr LF5D5
145	.a0d1					LF520:
146	.a0d1	e0 04		cpx #$04	                cpx #$04
147	.a0d3	f0 03		beq $a0d8	                beq LF527
148	.a0d5	4c d7 9f	jmp $9fd7	                jmp LF426

150	.a0d8					LF527:
151	.a0d8	60		rts		                rts

153	.a0d9					LF528:
154	.a0d9	bd 08 08	lda $0808,x	                lda $0808,x
155	.a0dc	c9 04		cmp #$04	                cmp #$04
156	.a0de	f0 05		beq $a0e5	                beq LF534
157	.a0e0	a9 03		lda #$03	                lda #$03
158	.a0e2	9d 08 08	sta $0808,x	                sta $0808,x
159	.a0e5					LF534:
160	.a0e5	bd ce 02	lda $02ce,x	                lda bufferEmptyFlags,x
161	.a0e8	f0 14		beq $a0fe	                beq LF54D
162	.a0ea	a9 00		lda #$00	                lda #$00
163	.a0ec	9e ce 02	stz $02ce,x	                stz bufferEmptyFlags,x
164	.a0ef	a0 04		ldy #$04	                ldy #$04
165	.a0f1					LF540:
166	.a0f1	99 2b 08	sta $082b,y	                sta $082B,y
167	.a0f4	88		dey		                dey
168	.a0f5	d0 fa		bne $a0f1	                bne LF540
169	.a0f7	9e 18 08	stz $0818,x	                stz $0818,x
170	.a0fa	88		dey		                dey
171	.a0fb	8c 38 08	sty $0838	                sty $0838
172	.a0fe					LF54D:
173	.a0fe	bd 28 08	lda $0828,x	                lda $0828,x
174	.a101	f0 60		beq $a163	                beq LF5B2
175	.a103	ad 3b 08	lda $083b	                lda $083B
176	.a106	f0 34		beq $a13c	                beq LF58B
177	.a108	9e 28 08	stz $0828,x	                stz $0828,x
178	.a10b					LF55A:
179	.a10b	4c 36 a2	jmp $a236	                jmp LF685

181						;-------------------------------------------------------------------------
182						;
183						; Clear a buffer that's a sound channel.
184						;
185						; https://tobylobster.github.io/mos/mos/S-s16.html#SP7
186						;
187						; Entry:
188						;
189						; X = buffer number (must be a sound channel buffer)
190						;
192						                ; All this stuff is in the top-level namespace in
193						                ; 3.50. Needs a rethink!
194	.a10e					clearSoundChannelBufferInternal:
198						                .block
199	.a10e	20 43 a1	jsr $a143	                jsr LF592
200	.a111	98		tya		                tya
201	.a112	9e 18 08	stz $0818,x	                stz $0818,x
202	.a115	9e ce 02	stz $02ce,x	                stz bufferEmptyFlags,x
203	.a118	9e 00 08	stz $0800,x	                stz $0800,x
204	.a11b	a0 03		ldy #$03	                ldy #$03
205	.a11d					loop:
206	.a11d	99 2c 08	sta $082c,y	                sta $082C,y
207	.a120	88		dey		                dey
208	.a121	10 fa		bpl $a11d	                bpl loop
209	.a123	8c 38 08	sty $0838	                sty $0838
210	.a126	80 63		bra $a18b	                bra LF5DA
211						                .endblock

213						;-------------------------------------------------------------------------

215	.a128					LF577:
216	.a128	08		php		                php
217	.a129	78		sei		                sei
218	.a12a	bd 08 08	lda $0808,x	                lda $0808,x
219	.a12d	c9 04		cmp #$04	                cmp #$04
220	.a12f	d0 0a		bne $a13b	                bne LF58A
221	.a131	20 1a eb	jsr $eb1a	                jsr osbyte98
222	.a134	90 05		bcc $a13b	                bcc LF58A
223	.a136	a9 00		lda #$00	                lda #$00
224	.a138	9e 00 08	stz $0800,x	                stz $0800,x
225	.a13b					LF58A:
226	.a13b	28		plp		                plp
227	.a13c					LF58B:
228	.a13c	bc 20 08	ldy $0820,x	                ldy $0820,x
229	.a13f	c0 ff		cpy #$ff	                cpy #$FF
230	.a141	d0 72		bne $a1b5	                bne LF604

232						                ; https://tobylobster.github.io/mos/mos/S-s16.html#SP2
233	.a143					LF592:
234	.a143	a9 04		lda #$04	                lda #$04
235	.a145	9d 08 08	sta $0808,x	                sta $0808,x
236	.a148	a9 c0		lda #$c0	                lda #$C0
237	.a14a					LF599:
238	.a14a	9d 04 08	sta $0804,x	                sta $0804,x
239	.a14d	ac 62 02	ldy $0262	                ldy soundSuppressionStatus
240	.a150	f0 02		beq $a154	                beq LF5A3
241	.a152	a9 c0		lda #$c0	                lda #$C0
242	.a154					LF5A3:
243	.a154	38		sec		                sec
244	.a155	e9 40		sbc #$40	                sbc #$40
245	.a157	4a		lsr a		                lsr a
246	.a158	4a		lsr a		                lsr a
247	.a159	4a		lsr a		                lsr a
248	.a15a	49 0f		eor #$0f	                eor #$0F
249	.a15c	1d bc 9f	ora $9fbc,x	                ora soundParameterTable-bufferNumberSound0,x
250	.a15f	09 10		ora #$10	                ora #$10
251	.a161	80 34		bra $a197	                bra LF5E6

253	.a163					LF5B2:
254	.a163	20 1a eb	jsr $eb1a	                jsr osbyte98
255	.a166	b0 c0		bcs $a128	                bcs LF577
256	.a168	29 03		and #$03	                and #$03
257	.a16a	f0 9f		beq $a10b	                beq LF55A
258	.a16c	ad 38 08	lda $0838	                lda $0838
259	.a16f	f0 cb		beq $a13c	                beq LF58B
260	.a171	fe 28 08	inc $0828,x	                inc $0828,x
261	.a174	a8		tay		                tay
262	.a175	10 0a		bpl $a181	                bpl LF5D0
263	.a177	20 1a eb	jsr $eb1a	                jsr osbyte98
264	.a17a	29 03		and #$03	                and #$03
265	.a17c	8d 38 08	sta $0838	                sta $0838
266	.a17f	80 bb		bra $a13c	                bra LF58B

268	.a181					LF5D0:
269	.a181	ce 38 08	dec $0838	                dec $0838
270	.a184	80 b6		bra $a13c	                bra LF58B

272	.a186					LF5D5:
273	.a186	dd 2c 08	cmp $082c,x	                cmp $082C,x
274	.a189	f0 2a		beq $a1b5	                beq LF604
275	.a18b					LF5DA:
276	.a18b	9d 2c 08	sta $082c,x	                sta $082C,x
277	.a18e	e0 04		cpx #$04	                cpx #$04
278	.a190	d0 24		bne $a1b6	                bne LF605
279	.a192	29 0f		and #$0f	                and #$0F
280	.a194	1d bc 9f	ora $9fbc,x	                ora soundParameterTable-bufferNumberSound0,x
281	.a197					LF5E6:
282	.a197	08		php		                php
283	.a198					LF5E7:
284	.a198	78		sei		                sei
285	.a199	a0 ff		ldy #$ff	                ldy #$FF
286	.a19b	8c 43 fe	sty $fe43	                sty systemVIA.ddra
287	.a19e	8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake
288	.a1a1	c8		iny		                iny
289	.a1a2	8c 40 fe	sty $fe40	                sty systemVIA.orb
290	.a1a5	a0 02		ldy #$02	                ldy #$02
291	.a1a7					LF5F6:
292	.a1a7	88		dey		                dey
293	.a1a8	d0 fd		bne $a1a7	                bne LF5F6
294	.a1aa	a0 08		ldy #$08	                ldy #$08
295	.a1ac	8c 40 fe	sty $fe40	                sty systemVIA.orb
296	.a1af	a0 04		ldy #$04	                ldy #$04
297	.a1b1					LF600:
298	.a1b1	88		dey		                dey
299	.a1b2	d0 fd		bne $a1b1	                bne LF600
300	.a1b4	28		plp		                plp
301	.a1b5					LF604:
302	.a1b5	60		rts		                rts

304	.a1b6					LF605:
305	.a1b6	48		pha		                pha
306	.a1b7	29 03		and #$03	                and #$03
307	.a1b9	8d 3c 08	sta $083c	                sta $083C
308	.a1bc	9c 3d 08	stz $083d	                stz $083D
309	.a1bf	68		pla		                pla
310	.a1c0	4a		lsr a		                lsr a
311	.a1c1	4a		lsr a		                lsr a
312	.a1c2					LF611:
313	.a1c2	c9 0c		cmp #$0c	                cmp #$0C
314	.a1c4	90 07		bcc $a1cd	                bcc LF61C
315	.a1c6	ee 3d 08	inc $083d	                inc $083D
316	.a1c9	e9 0c		sbc #$0c	                sbc #$0C
317	.a1cb	d0 f5		bne $a1c2	                bne LF611
318	.a1cd					LF61C:
319	.a1cd	a8		tay		                tay
320	.a1ce	ad 3d 08	lda $083d	                lda $083D
321	.a1d1	48		pha		                pha
322	.a1d2	b9 95 a2	lda $a295,y	                lda LF6E4,y
323	.a1d5	8d 3d 08	sta $083d	                sta $083D
324	.a1d8	b9 a1 a2	lda $a2a1,y	                lda LF6F0,y
325	.a1db	48		pha		                pha
326	.a1dc	29 03		and #$03	                and #$03
327	.a1de	8d 3e 08	sta $083e	                sta $083E
328	.a1e1	68		pla		                pla
332	.a1e2	4a		lsr a		                lsr a
333	.a1e3	4a		lsr a		                lsr a
334	.a1e4	4a		lsr a		                lsr a
335	.a1e5	4a		lsr a		                lsr a
337	.a1e6	8d 3f 08	sta $083f	                sta $083F
338	.a1e9	ad 3d 08	lda $083d	                lda $083D
339	.a1ec	ac 3c 08	ldy $083c	                ldy $083C
340	.a1ef	f0 0c		beq $a1fd	                beq LF64C
341	.a1f1					LF640:
342	.a1f1	38		sec		                sec
343	.a1f2	ed 3f 08	sbc $083f	                sbc $083F
344	.a1f5	b0 03		bcs $a1fa	                bcs LF649
345	.a1f7	ce 3e 08	dec $083e	                dec $083E
346	.a1fa					LF649:
347	.a1fa	88		dey		                dey
348	.a1fb	d0 f4		bne $a1f1	                bne LF640
349	.a1fd					LF64C:
350	.a1fd	8d 3d 08	sta $083d	                sta $083D
351	.a200	68		pla		                pla
352	.a201	a8		tay		                tay
353	.a202	f0 09		beq $a20d	                beq LF65C
354	.a204					LF653:
355	.a204	4e 3e 08	lsr $083e	                lsr $083E
356	.a207	6e 3d 08	ror $083d	                ror $083D
357	.a20a	88		dey		                dey
358	.a20b	d0 f7		bne $a204	                bne LF653
359	.a20d					LF65C:
360	.a20d	ad 3d 08	lda $083d	                lda $083D
361	.a210	18		clc		                clc
362	.a211	7d 75 e1	adc $e175,x	                adc LE165,x
363	.a214	8d 3d 08	sta $083d	                sta $083D
364	.a217	90 03		bcc $a21c	                bcc LF66B
365	.a219	ee 3e 08	inc $083e	                inc $083E
366	.a21c					LF66B:
367	.a21c	29 0f		and #$0f	                and #$0F
368	.a21e	1d bc 9f	ora $9fbc,x	                ora soundParameterTable-bufferNumberSound0,x
369	.a221	08		php		                php
370	.a222	78		sei		                sei
371	.a223	20 97 a1	jsr $a197	                jsr LF5E6
372	.a226	ad 3d 08	lda $083d	                lda $083D
373	.a229	4e 3e 08	lsr $083e	                lsr $083E
374	.a22c	6a		ror a		                ror a
375	.a22d	4e 3e 08	lsr $083e	                lsr $083E
376	.a230	6a		ror a		                ror a
377	.a231	4a		lsr a		                lsr a
378	.a232	4a		lsr a		                lsr a
379	.a233	4c 98 a1	jmp $a198	                jmp LF5E7

381	.a236					LF685:
382	.a236	08		php		                php
383	.a237	78		sei		                sei
384	.a238	20 1f eb	jsr $eb1f	                jsr osbyte91
385	.a23b	48		pha		                pha
386	.a23c	29 04		and #$04	                and #$04
387	.a23e	f0 13		beq $a253	                beq LF6A2
388	.a240	68		pla		                pla
389	.a241	bc 20 08	ldy $0820,x	                ldy $0820,x
390	.a244	c8		iny		                iny
391	.a245	d0 03		bne $a24a	                bne LF699Sound
392	.a247	20 43 a1	jsr $a143	                jsr LF592
393	.a24a					LF699Sound:
394	.a24a	20 1f eb	jsr $eb1f	                jsr osbyte91
395	.a24d	20 1f eb	jsr $eb1f	                jsr osbyte91
396	.a250	28		plp		                plp
397	.a251	80 3e		bra $a291	                bra LF6E0

399	.a253					LF6A2:
400	.a253	68		pla		                pla
401	.a254	29 f8		and #$f8	                and #$F8
402	.a256	0a		asl a		                asl a
403	.a257	90 0b		bcc $a264	                bcc LF6B3Sound
404	.a259	49 ff		eor #$ff	                eor #$FF
405	.a25b	4a		lsr a		                lsr a
406	.a25c	38		sec		                sec
407	.a25d	e9 40		sbc #$40	                sbc #$40
408	.a25f	20 4a a1	jsr $a14a	                jsr LF599
409	.a262	a9 ff		lda #$ff	                lda #$FF
410	.a264					LF6B3Sound:
411	.a264	9d 20 08	sta $0820,x	                sta $0820,x
412	.a267	a9 05		lda #$05	                lda #$05
413	.a269	9d 1c 08	sta $081c,x	                sta $081C,x
414	.a26c	a9 01		lda #$01	                lda #$01
415	.a26e	9d 24 08	sta $0824,x	                sta $0824,x
416	.a271	9e 14 08	stz $0814,x	                stz $0814,x
417	.a274	9e 08 08	stz $0808,x	                stz $0808,x
418	.a277	9e 30 08	stz $0830,x	                stz $0830,x
419	.a27a	a9 ff		lda #$ff	                lda #$FF
420	.a27c	9d 10 08	sta $0810,x	                sta $0810,x
421	.a27f	20 1f eb	jsr $eb1f	                jsr osbyte91
422	.a282	9d 0c 08	sta $080c,x	                sta $080C,x
423	.a285	20 1f eb	jsr $eb1f	                jsr osbyte91
424	.a288	28		plp		                plp
425	.a289	48		pha		                pha
426	.a28a	bd 0c 08	lda $080c,x	                lda $080C,x
427	.a28d	20 86 a1	jsr $a186	                jsr LF5D5
428	.a290	68		pla		                pla
429	.a291					LF6E0:
430	.a291	9d 18 08	sta $0818,x	                sta $0818,x
431	.a294	60		rts		                rts

433	.a295					LF6E4:
434	>a295	f0				                .byte $F0
435	>a296	b7				                .byte $B7
436	>a297	82				                .byte $82
437	>a298	4f				                .byte $4F
438	>a299	20				                .byte $20
439	>a29a	f3				                .byte $F3
440	>a29b	c8				                .byte $C8
441	>a29c	a0				                .byte $A0
442	>a29d	7b				                .byte $7B
443	>a29e	57				                .byte $57
444	>a29f	35				                .byte $35
445	>a2a0	16				                .byte $16
446	.a2a1					LF6F0:
447	>a2a1	e7				                .byte $E7
448	>a2a2	d7				                .byte $D7
449	>a2a3	cb				                .byte $CB
450	>a2a4	c3				                .byte $C3
451	>a2a5	b7				                .byte $B7
452	>a2a6	aa				                .byte $AA
453	>a2a7	a2				                .byte $A2
454	>a2a8	9a				                .byte $9a
455	>a2a9	92				                .byte $92
456	>a2aa	8a				                .byte $8a
457	>a2ab	82				                .byte $82
458	>a2ac	7a				                .byte $7a

:5	;******  Return to file: src/terminal.s65

3668						;-------------------------------------------------------------------------

3674						;-------------------------------------------------------------------------
3675						;
3676						; Utils/Terminal ROM service entry point.
3677						;
3678	.a2ad					utilsServiceEntryPoint:
3756	.a2ad	e0 0f		cpx #$0f	                cpx #terminalROM
3757	.a2af	f0 01		beq $a2b2	                beq utilsInCorrectBank
3758	.a2b1	60		rts		                rts
3759	.a2b2					utilsInCorrectBank:
3760	.a2b2	80 02		bra $a2b6	                bra handleInitialiseFilingSystem
3761	.a2b4					L9DCA:
3762	.a2b4	a9 00		lda #$00	                lda #$00
3763	.a2b6					handleInitialiseFilingSystem:
3765	.a2b6	c9 12		cmp #$12	                cmp #romServiceCallInitialiseFilingSystem
3766	.a2b8	d0 1a		bne $a2d4	                bne handleBreakInstruction
3771	.a2ba	c0 04		cpy #$04	                cpy #fsTapeOrROMMax+1
3772	.a2bc	b0 42		bcs $a300	                bcs L9E16                    ; taken if not tape/rom
3773	.a2be	c0 00		cpy #$00	                cpy #fsNone
3774	.a2c0	f0 3e		beq $a300	                beq L9E16                    ; taken if no FS
3775	.a2c2	a2 03		ldx #$03	                ldx #3                       ; assume tape, 300 baud tape
3776	.a2c4	98		tya		                tya                          ; Y = FS number
3777	.a2c5	c9 02		cmp #$02	                cmp #fs300BaudTape
3778	.a2c7	b0 04		bcs $a2cd	                bcs L9DE3              ; taken if 300 baud tape or ROM
3779	.a2c9	a2 00		ldx #$00	                ldx #$00               ; X=0 for 1200 baud
3780	.a2cb	69 02		adc #$02	                adc #$02            ; adjust so that the result of the
3781						                                    ; following adc will be $8c
3782	.a2cd					L9DE3:
3783	.a2cd	69 89		adc #$89	                adc #$89                     ; Convert to TAPE/ROM select value
3785	.a2cf	20 4d ee	jsr $ee4d	                jsr selectROMOrTAPEByOSBYTE
3786	.a2d2	80 e0		bra $a2b4	                bra L9DCA                    ; Jump to claim and return

3788	.a2d4					handleBreakInstruction:
3789	.a2d4	c9 06		cmp #$06	                cmp #romServiceCallBreakInstruction
3790	.a2d6	d0 29		bne $a301	                bne handleCloseAllOpenFiles
3791	.a2d8	ad dd df	lda $dfdd	                lda hazel.hasACCCONChanged ; Skip if ACCCON not changed
3792	.a2db	f0 09		beq $a2e6	                beq closeMoveSrcHandle
3793	.a2dd	9c dd df	stz $dfdd	                stz hazel.hasACCCONChanged ; Clear ACCCON changed flag
3794	.a2e0	ad dc df	lda $dfdc	                lda hazel.oldACCCON        ; Restore ACCCON
3795	.a2e3	8d 34 fe	sta $fe34	                sta ACCCON
3796	.a2e6					closeMoveSrcHandle:
3797	.a2e6	5a		phy		                phy
3798	.a2e7	ac d4 df	ldy $dfd4	                ldy hazel.moveSrcHandle
3799	.a2ea	f0 06		beq $a2f2	                beq closeMoveDestHandle
3800	.a2ec	9c d4 df	stz $dfd4	                stz hazel.moveSrcHandle
3801	.a2ef	20 19 91	jsr $9119	                jsr closeFile
3802	.a2f2					closeMoveDestHandle:
3803	.a2f2	ac d5 df	ldy $dfd5	                ldy hazel.moveDestHandle
3804	.a2f5	f0 06		beq $a2fd	                beq L9E13
3805	.a2f7	9c d5 df	stz $dfd5	                stz hazel.moveDestHandle
3806	.a2fa	20 19 91	jsr $9119	                jsr closeFile
3807	.a2fd					L9E13:
3808	.a2fd	7a		ply		                ply
3809	.a2fe	a9 06		lda #$06	                lda #romServiceCallBreakInstruction ; restore A
3810	.a300					L9E16:
3811	.a300	60		rts		                rts
3812	.a301					handleCloseAllOpenFiles:
3813	.a301	c9 26		cmp #$26	                cmp #romServiceCallCloseAllOpenFiles
3814	.a303	d0 1d		bne $a322	                bne handleHelp
3816	.a305	a9 8d		lda #$8d	                lda #$8D
3817	.a307	20 16 a3	jsr $a316	                jsr L9E2C
3818	.a30a	a2 03		ldx #$03	                ldx #$03
3819	.a30c	a9 04		lda #$04	                lda #$04
3820	.a30e	24 c6		bit $c6		                bit $C6
3821	.a310	f0 02		beq $a314	                beq L9E2A
3822	.a312	a2 00		ldx #$00	                ldx #$00
3823	.a314					L9E2A:
3824	.a314	a9 8c		lda #$8c	                lda #$8C
3825	.a316					L9E2C:
3827	.a316	20 4d ee	jsr $ee4d	                jsr selectROMOrTAPEByOSBYTE
3828	.a319	a9 00		lda #$00	                lda #$00
3829	.a31b	a8		tay		                tay
3830	.a31c	20 bf a6	jsr $a6bf	                jsr osfindTapeOrROM
3831	.a31f	a9 26		lda #$26	                lda #$26
3832	.a321	60		rts		                rts

3834	.a322					handleHelp
3835	.a322	c9 09		cmp #$09	                cmp #romServiceCallHelp
3839	.a324	d0 50		bne $a376	                bne LA304
3841	.a326	5a		phy		                phy
3842	.a327	b1 f2		lda ($f2),y	                lda ($F2),y
3843	.a329	c9 0d		cmp #$0d	                cmp #$0D
3844	.a32b	d0 1c		bne $a349	                bne L9E61
3845	.a32d	20 e1 a3	jsr $a3e1	                jsr L9EFC
3846	.a330	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
3847	>a333	20 20 4d 4f 53 0d		                .text "  MOS",13
3859	>a339	0d 55 54 49 4c 53 20 31		                .text 13,"UTILS 1.10C",13
	>a341	2e 31 30 43 0d
3861	>a346	00				                .text 0
3862	.a347	80 2a		bra $a373	                bra L9E8B
3863	.a349					L9E61:
3864	.a349	a2 02		ldx #$02	                ldx #size(mosHelpSubject)-1
3865	.a34b					L9E63:
3866	.a34b	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
3867	.a34d	c9 2e		cmp #$2e	                cmp #'.'
3868	.a34f	f0 29		beq $a37a	                beq L9E95
3869	.a351	29 df		and #$df	                and #$DF
3870	.a353	dd 77 a3	cmp $a377,x	                cmp mosHelpSubject,x
3871	.a356	d0 0b		bne $a363	                bne L9E7B
3872	.a358	c8		iny		                iny
3873	.a359	ca		dex		                dex
3874	.a35a	10 ef		bpl $a34b	                bpl L9E63
3875	.a35c	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
3876	.a35e	20 9c eb	jsr $eb9c	                jsr isLetter
3877	.a361	b0 17		bcs $a37a	                bcs L9E95
3878	.a363					L9E7B:
3879	.a363	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
3880	.a365	c9 0d		cmp #$0d	                cmp #13
3881	.a367	f0 0a		beq $a373	                beq L9E8B
3882	.a369	c8		iny		                iny
3883	.a36a	c9 20		cmp #$20	                cmp #' '
3884	.a36c	d0 f5		bne $a363	                bne L9E7B
3885	.a36e	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
3886	.a371	d0 d6		bne $a349	                bne L9E61
3887	.a373					L9E8B:
3888	.a373	7a		ply		                ply
3889	.a374	a9 09		lda #$09	                lda #romServiceCallHelp
3890	.a376					LA304:
3891	.a376	60		rts		                rts

3898	>a377	53 4f 4d			mosHelpSubject: .text "SOM"

3900	.a37a					L9E95:
3901	.a37a	20 e1 a3	jsr $a3e1	                jsr L9EFC
3902	.a37d	a9 c0		lda #$c0	                lda #<mosCommandTable
3903	.a37f	85 b0		sta $b0		                sta terminalHELPWorkspace.tablePtr+0
3904	.a381	a9 83		lda #$83	                lda #>mosCommandTable
3905	.a383	85 b1		sta $b1		                sta terminalHELPWorkspace.tablePtr+1
3906	.a385					L9EA0:
3907	.a385	b2 b0		lda ($b0)	                lda (terminalHELPWorkspace.tablePtr)
3908	.a387	30 50		bmi $a3d9	                bmi L9EF4
3913	.a389	20 f3 a3	jsr $a3f3	                jsr printSpace
3914	.a38c	20 f3 a3	jsr $a3f3	                jsr printSpace
3915	.a38f	b2 b0		lda ($b0)	                lda (terminalHELPWorkspace.tablePtr)
3916	.a391					L9EAC:
3921	.a391	20 f5 a3	jsr $a3f5	                jsr L9F0E
3922	.a394					LA711:
3923	.a394	e6 b0		inc $b0		                inc terminalHELPWorkspace.tablePtr+0
3924	.a396	d0 02		bne $a39a	                bne L9EB5
3925	.a398	e6 b1		inc $b1		                inc terminalHELPWorkspace.tablePtr+1
3926	.a39a					L9EB5:
3927	.a39a	b2 b0		lda ($b0)	                lda (terminalHELPWorkspace.tablePtr)
3928	.a39c	10 f3		bpl $a391	                bpl L9EAC

3930						                ; add 4 to tablePtr
3931	.a39e	a9 04		lda #$04	                lda #$04
3932	.a3a0	18		clc		                clc
3933	.a3a1	65 b0		adc $b0		                adc terminalHELPWorkspace.tablePtr+0
3934	.a3a3	85 b0		sta $b0		                sta terminalHELPWorkspace.tablePtr+0
3935	.a3a5	90 02		bcc $a3a9	                bcc +
3936	.a3a7	e6 b1		inc $b1		                inc terminalHELPWorkspace.tablePtr+1
3937	.a3a9					+
3938	.a3a9	20 6c e2	jsr $e26c	                jsr LE25C
3939	.a3ac	e0 13		cpx #$13	                cpx #19
3940	.a3ae	f0 24		beq $a3d4	                beq L9EEF
3941	.a3b0					L9ECB:
3942	.a3b0	20 62 e2	jsr $e262	                jsr getTextCursorPositionWithColumn81
3943	.a3b3	8a		txa		                txa
3944	.a3b4	f0 cf		beq $a385	                beq L9EA0
3945	.a3b6	e0 14		cpx #$14	                cpx #20
3946	.a3b8	f0 cb		beq $a385	                beq L9EA0
3947	.a3ba	90 0d		bcc $a3c9	                bcc L9EE4
3948	.a3bc	e0 28		cpx #$28	                cpx #40
3949	.a3be	f0 c5		beq $a385	                beq L9EA0
3950	.a3c0	b0 0c		bcs $a3ce	                bcs L9EE9
3951	.a3c2	20 6c e2	jsr $e26c	                jsr LE25C
3952	.a3c5	e0 27		cpx #$27	                cpx #39
3953	.a3c7	f0 0b		beq $a3d4	                beq L9EEF
3954	.a3c9					L9EE4:
3955	.a3c9	20 f3 a3	jsr $a3f3	                jsr printSpace
3956	.a3cc	80 e2		bra $a3b0	                bra L9ECB

3958	.a3ce					L9EE9:
3959	.a3ce	e0 3c		cpx #$3c	                cpx #60
3960	.a3d0	90 f7		bcc $a3c9	                bcc L9EE4
3961	.a3d2	f0 b1		beq $a385	                beq L9EA0
3962	.a3d4					L9EEF:
3963	.a3d4	20 05 a4	jsr $a405	                jsr printNewLine
3964	.a3d7	80 ac		bra $a385	                bra L9EA0

3966	.a3d9					L9EF4:
3967	.a3d9	20 62 e2	jsr $e262	                jsr getTextCursorPositionWithColumn81
3968	.a3dc	8a		txa		                txa
3969	.a3dd	f0 94		beq $a373	                beq L9E8B
3970	.a3df	80 f3		bra $a3d4	                bra L9EEF

3972	.a3e1					L9EFC:
3973	.a3e1	5a		phy		                phy
3974	.a3e2	20 9a ad	jsr $ad9a	                jsr alwaysPrintFollowingMessage
3975	>a3e5	0d 4d 4f 53 20 35 2e 31		                .text 13,versionString,13,0
	>a3ed	30 69 0d 00
3976	.a3f1	7a		ply		                ply
3977	.a3f2	60		rts		                rts

3979						;-------------------------------------------------------------------------
3980						;
3981	.a3f3					printSpace:
3982	.a3f3	a9 20		lda #$20	                lda #$20
3983	.a3f5					L9F0E:
3984	.a3f5	da		phx		                phx
3985	.a3f6	a6 b0		ldx $b0		                ldx $B0
3986	.a3f8	da		phx		                phx
3987	.a3f9	a6 b1		ldx $b1		                ldx $B1
3988	.a3fb	20 ee ff	jsr $ffee	                jsr OSWRCH
3989	.a3fe					restoreB1AndB0:
3990	.a3fe	86 b1		stx $b1		                stx $B1
3991	.a400	fa		plx		                plx
3992	.a401	86 b0		stx $b0		                stx $B0
3993	.a403	fa		plx		                plx
3994	.a404	60		rts		                rts

3996						;-------------------------------------------------------------------------

3998	.a405					printNewLine:
3999	.a405	da		phx		                phx
4000	.a406	a6 b0		ldx $b0		                ldx $B0
4001	.a408	da		phx		                phx
4002	.a409	a6 b1		ldx $b1		                ldx $B1
4003	.a40b	20 e7 ff	jsr $ffe7	                jsr OSNEWL
4004	.a40e	80 ee		bra $a3fe	                bra restoreB1AndB0

4006						;-------------------------------------------------------------------------

4008						; TAPE/ROM OSARGS handler
4009						; =======================
4010	.a410					osargsTapeOrROM:
4011	.a410	c0 00		cpy #$00	                cpy #$00       ; Handle<>0 - read/write open file info
4012	.a412	d0 0e		bne $a422	                bne L9F3B
4013	.a414	09 00		ora #$00	                ora #$00 ; A<>0 - read/write filing system info - exit
4014	.a416	d0 09		bne $a421	                bne L9F3A

4016						; A=0, Y=0 - read current filing system
4017						; -------------------------------------
4018	.a418	a9 03		lda #$03	                lda #$03                     ; Prepare A=ROMFS
4020	.a41a	2c 47 02	bit $0247	                bit cfsRFSFSSwitch           ; If TAPE/ROM switch
4021	.a41d	d0 02		bne $a421	                bne L9F3A
4022	.a41f	25 c6		and $c6		                and $C6           ; Mask with speed to give A=2 or A=1

4025						; TAPE/ROM FSC 6 - shut down FS
4026						; TAPE/ROM FSC 8 - OS command
4027						; TAPE/ROM FSC 10 - *INFO
4028						; -----------------------------
4029	.a421					L9F3A:
4030	.a421	60		rts		                rts

4032						; OSARGS handle<>0 - red/write open file info
4033						; -------------------------------------------
4034	.a422					L9F3B:
4035	.a422	c9 00		cmp #$00	                cmp #$00                     ; Not =PTR, exit unsupported
4036	.a424	d0 fb		bne $a421	                bne L9F3A
4037	.a426	c0 02		cpy #$02	                cpy #$02                     ; =PTR#2 - read PTR on output handle
4038	.a428	f0 1d		beq $a447	                beq L9F60

4040						; Read PTR on CFS/RFS input file
4041						; ------------------------------
4042	.a42a	a9 01		lda #$01	                lda #$01                     ; Check if this is input channel and is open
4043	.a42c	20 a0 ae	jsr $aea0	                jsr LAA68
4044	.a42f	ad 9e 03	lda $039e	                lda $039E
4045	.a432	95 00		sta $00,x	                sta $00,x
4046	.a434	5a		phy		                phy
4047	.a435	ad de 03	lda $03de	                lda $03DE
4048	.a438	ac dd 03	ldy $03dd	                ldy $03DD
4049	.a43b	d0 01		bne $a43e	                bne L9F57
4050	.a43d	3a		dec a		                dec a
4051	.a43e					L9F57:
4052	.a43e	88		dey		                dey
4053	.a43f	94 01		sty $01,x	                sty $01,x
4054	.a441	7a		ply		                ply
4055	.a442					L9F5B:
4056	.a442	95 02		sta $02,x	                sta $02,x
4057	.a444	74 03		stz $03,x	                stz $03,x
4058	.a446	60		rts		                rts

4060						; Read PTR on TAPE output file
4061						; ----------------------------
4062	.a447					L9F60:
4063	.a447	a9 02		lda #$02	                lda #$02                     ; Check if this is output channel and is open
4064	.a449	20 a0 ae	jsr $aea0	                jsr LAA68
4065	.a44c	ad 9d 03	lda $039d	                lda $039D                    ; Copy PTR to control block
4066	.a44f	95 00		sta $00,x	                sta $00,x
4067	.a451	ad 94 03	lda $0394	                lda $0394
4068	.a454	95 01		sta $01,x	                sta $01,x
4069	.a456	ad 95 03	lda $0395	                lda $0395
4070	.a459	80 e7		bra $a442	                bra L9F5B

4072						;-------------------------------------------------------------------------

4074						; TAPE/ROM FSC dispatch table
4075						; ---------------------------

4077						tapeAndROMFSCRoutine: .macro addr,shift
4079						                .endmacro

4081						tapeAndROMFSCRoutinesTable: .macro shift
4094						                .endmacro

4096	.a45b					L9F74:
4078	>a45b	9b				                .byte ((LA422)-1)>>(0)&$ff
4078	>a45c	5f				                .byte ((LA4F1)-1)>>(0)&$ff
4078	>a45d	ec				                .byte ((LA110)-1)>>(0)&$ff
4078	>a45e	05				                .byte ((LA129)-1)>>(0)&$ff
4078	>a45f	ec				                .byte ((LA110)-1)>>(0)&$ff
4078	>a460	2d				                .byte ((LA168)-1)>>(0)&$ff
4078	>a461	20				                .byte ((L9F3A)-1)>>(0)&$ff
4078	>a462	84				                .byte ((L9F9E)-1)>>(0)&$ff
4078	>a463	20				                .byte ((L9F3A)-1)>>(0)&$ff
4078	>a464	1a				                .byte ((LA155)-1)>>(0)&$ff
4078	>a465	20				                .byte ((L9F3A)-1)>>(0)&$ff
4078	>a466	ef				                .byte ((LA113)-1)>>(0)&$ff
4098	.a467					L9F80:
4078	>a467	a8				                .byte ((LA422)-1)>>(8)&$ff
4078	>a468	a9				                .byte ((LA4F1)-1)>>(8)&$ff
4078	>a469	a5				                .byte ((LA110)-1)>>(8)&$ff
4078	>a46a	a6				                .byte ((LA129)-1)>>(8)&$ff
4078	>a46b	a5				                .byte ((LA110)-1)>>(8)&$ff
4078	>a46c	a6				                .byte ((LA168)-1)>>(8)&$ff
4078	>a46d	a4				                .byte ((L9F3A)-1)>>(8)&$ff
4078	>a46e	a4				                .byte ((L9F9E)-1)>>(8)&$ff
4078	>a46f	a4				                .byte ((L9F3A)-1)>>(8)&$ff
4078	>a470	a6				                .byte ((LA155)-1)>>(8)&$ff
4078	>a471	a4				                .byte ((L9F3A)-1)>>(8)&$ff
4078	>a472	a5				                .byte ((LA113)-1)>>(8)&$ff

4101						;-------------------------------------------------------------------------

4103						; TAPE/ROM FSC
4104						; ============
4105	.a473					fscTapeOrROM:
4106	.a473	c9 0c		cmp #$0c	                cmp #$0C                     ; function<12 - exit unchanged
4107	.a475	b0 aa		bcs $a421	                bcs L9F3A
4108	.a477	86 bc		stx $bc		                stx $BC                      ; Index into dispatch table
4109	.a479	aa		tax		                tax
4110	.a47a	bd 67 a4	lda $a467,x	                lda L9F80,x
4111	.a47d	48		pha		                pha
4112	.a47e	bd 5b a4	lda $a45b,x	                lda L9F74,x
4113	.a481	48		pha		                pha
4114	.a482	a6 bc		ldx $bc		                ldx $BC
4115	.a484	60		rts		                rts

4117						; TAPE/ROM FSC 7 - obtain file handle range
4118						; -----------------------------------------
4119	.a485					L9F9E:
4120	.a485	a2 03		ldx #$03	                ldx #$03
4121	.a487	a0 03		ldy #$03	                ldy #$03
4123	.a489	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4124	.a48c	d0 93		bne $a421	                bne L9F3A
4125	.a48e	88		dey		                dey
4126	.a48f	a2 01		ldx #$01	                ldx #$01
4128	.a491	60		rts		                rts

4130	.a492					L9FAB:
4131	.a492	68		pla		                pla
4132	.a493	28		plp		                plp
4133	.a494	38		sec		                sec
4134	.a495	60		rts		                rts

4136	.a496					L9FAF:
4137	.a496	08		php		                php
4138	.a497	48		pha		                pha
4139	.a498	20 2b ae	jsr $ae2b	                jsr LA9F3
4140	.a49b	ad c2 03	lda $03c2	                lda $03C2
4141	.a49e	48		pha		                pha
4142	.a49f	20 71 a9	jsr $a971	                jsr LA502
4143	.a4a2	68		pla		                pla
4144	.a4a3	b0 ed		bcs $a492	                bcs L9FAB
4145	.a4a5	f0 19		beq $a4c0	                beq L9FD9
4146	.a4a7	a2 03		ldx #$03	                ldx #$03
4147	.a4a9	a9 ff		lda #$ff	                lda #$FF
4148	.a4ab					L9FC4:
4149	.a4ab	48		pha		                pha
4150	.a4ac	bd be 03	lda $03be,x	                lda $03BE,x
4151	.a4af	95 b0		sta $b0,x	                sta $B0,x
4152	.a4b1	68		pla		                pla
4153	.a4b2	35 b0		and $b0,x	                and $B0,x
4154	.a4b4	ca		dex		                dex
4155	.a4b5	10 f4		bpl $a4ab	                bpl L9FC4
4156	.a4b7	1a		inc a		                inc a
4157	.a4b8	d0 06		bne $a4c0	                bne L9FD9
4158	.a4ba	20 f3 ad	jsr $adf3	                jsr LA9B1
4159	.a4bd	4c 64 95	jmp $9564	                jmp badAddressError

4161	.a4c0					L9FD9:
4162	.a4c0	ad ca 03	lda $03ca	                lda $03CA
4163	.a4c3	4a		lsr a		                lsr a
4164	.a4c4	68		pla		                pla
4165	.a4c5	48		pha		                pha
4166	.a4c6	f0 10		beq $a4d8	                beq L9FF1
4167	.a4c8	90 15		bcc $a4df	                bcc L9FF8
4168	.a4ca					L9FE3:
4169	.a4ca	20 fd ad	jsr $adfd	                jsr LA9BB
4170	.a4cd	20 ff ae	jsr $aeff	                jsr doFollowingError
4171	>a4d0	d5 4c 6f 63 6b 65 64 00		                .text $d5,"Locked",0
4172	.a4d8					L9FF1:
4173	.a4d8	90 05		bcc $a4df	                bcc L9FF8
4174	.a4da	a9 03		lda #$03	                lda #$03
4175	.a4dc	8d 58 02	sta $0258	                sta breakAndESCAPEEffect
4176	.a4df					L9FF8:
4177	.a4df	a9 30		lda #$30	                lda #$30
4178	.a4e1	25 bb		and $bb		                and $BB
4179	.a4e3	f0 04		beq $a4e9	                beq LA002
4180	.a4e5	a5 c1		lda $c1		                lda $C1
4181	.a4e7					LA000:
4182	.a4e7	d0 03		bne $a4ec	                bne LA00A
4183	.a4e9					LA002:
4189	.a4e9	20 1e ab	jsr $ab1e	                jsr LA6D2
4190	.a4ec					LA00A:
4191	.a4ec	20 e3 ac	jsr $ace3	                jsr LA8A1
4192	.a4ef	d0 57		bne $a548	                bne LA066
4193	.a4f1	20 6d ae	jsr $ae6d	                jsr LAA35
4194	.a4f4	2c ca 03	bit $03ca	                bit $03CA
4195	.a4f7	30 08		bmi $a501	                bmi LA01F
4196	.a4f9	20 9d ac	jsr $ac9d	                jsr LA85B
4197	.a4fc	20 e7 aa	jsr $aae7	                jsr LA678
4198	.a4ff	80 de		bra $a4df	                bra L9FF8

4200	.a501					LA01F:
4201	.a501	68		pla		                pla                          ; RUN, no control block to update
4202	.a502	f0 33		beq $a537	                beq LA055
4203	.a504	a0 02		ldy #$02	                ldy #$02
4204	.a506					LA024:
4205	.a506	b9 bc 03	lda $03bc,y	                lda $03BC,y                  ; Copy load/exec to control block
4206	.a509	91 c8		sta ($c8),y	                sta ($C8),y
4207	.a50b	c8		iny		                iny
4208	.a50c	c0 0a		cpy #$0a	                cpy #$0A
4209	.a50e	d0 f6		bne $a506	                bne LA024
4210	.a510	ad c8 03	lda $03c8	                lda $03C8                    ; Length b0-b7=Block Length b0-b7
4211	.a513	91 c8		sta ($c8),y	                sta ($C8),y
4212	.a515	c8		iny		                iny
4213	.a516	ad c9 03	lda $03c9	                lda $03C9
4214	.a519	18		clc		                clc
4215	.a51a	6d c6 03	adc $03c6	                adc $03C6                    ; Length b8-b15=Block Number+Block Length b8-b15
4216	.a51d	91 c8		sta ($c8),y	                sta ($C8),y
4217	.a51f	c8		iny		                iny
4218	.a520	a9 00		lda #$00	                lda #$00
4219	.a522	6d c7 03	adc $03c7	                adc $03C7                    ; Length b16-b23=overflow
4220	.a525	91 c8		sta ($c8),y	                sta ($C8),y
4221	.a527	c8		iny		                iny                          ; Length b24-b31=&00
4222	.a528	a9 00		lda #$00	                lda #$00
4223	.a52a	91 c8		sta ($c8),y	                sta ($C8),y
4224	.a52c	c8		iny		                iny
4225	.a52d					LA04B:
4226	.a52d	b9 bd 03	lda $03bd,y	                lda $03BD,y                  ; Attrs=&00000000
4227	.a530	91 c8		sta ($c8),y	                sta ($C8),y
4228	.a532	c8		iny		                iny
4229	.a533	c0 12		cpy #$12	                cpy #$12
4230	.a535	d0 f6		bne $a52d	                bne LA04B
4231	.a537					LA055:
4232	.a537	28		plp		                plp
4233	.a538					LA056:
4234	.a538	20 f3 ad	jsr $adf3	                jsr LA9B1
4235	.a53b					LA059:
4236	.a53b	24 ba		bit $ba		                bit $BA                      ; If flag set, skip printing newline
4237	.a53d	30 07		bmi $a546	                bmi LA064
4238	.a53f					LA05D:
4239	.a53f	08		php		                php                          ; Print inline text
4240	.a540	20 65 ad	jsr $ad65	                jsr LA923
4241	>a543	0d				                .byte 13                     ; Could just do JSR OSNEWL
4242	>a544	00				                .byte 0
4243	.a545	28		plp		                plp
4244	.a546					LA064:
4245	.a546	18		clc		                clc
4246	.a547	60		rts		                rts

4248	.a548					LA066:
4249	.a548	20 75 a9	jsr $a975	                jsr LA506
4250	.a54b	d0 92		bne $a4df	                bne L9FF8
4251	.a54d					LA06B:
4252	.a54d	86 f2		stx $f2		                stx $F2
4253	.a54f	84 f3		sty $f3		                sty $F3
4254	.a551	a0 00		ldy #$00	                ldy #$00
4255	.a553	20 2c f3	jsr $f32c	                jsr gsinitForFilenameParsing
4256	.a556	a2 00		ldx #$00	                ldx #$00
4257	.a558					LA076:
4258	.a558	20 3e f3	jsr $f33e	                jsr gsreadEntryPoint
4259	.a55b	b0 0d		bcs $a56a	                bcs LA088
4260	.a55d	f0 08		beq $a567	                beq LA085
4261	.a55f	9d d2 03	sta $03d2,x	                sta $03D2,x
4262	.a562	e8		inx		                inx
4263	.a563	e0 0b		cpx #$0b	                cpx #$0B
4264	.a565	d0 f1		bne $a558	                bne LA076
4265	.a567					LA085:
4266	.a567	4c 4e f3	jmp $f34e	                jmp badStringError

4268	.a56a					LA088:
4269	.a56a	9e d2 03	stz $03d2,x	                stz $03D2,x
4270	.a56d	60		rts		                rts

4272						; CFS/RFS OSFILE
4273						; ==============
4274	.a56e					osfileTapeOrROM:
4275	.a56e	48		pha		                pha
4276	.a56f	86 c8		stx $c8		                stx $C8                      ; C8/9=>control block
4277	.a571	84 c9		sty $c9		                sty $C9
4278	.a573	b2 c8		lda ($c8)	                lda ($C8)                    ; Get XY=>filename
4279	.a575	aa		tax		                tax
4280	.a576	a0 01		ldy #$01	                ldy #$01
4281	.a578	b1 c8		lda ($c8),y	                lda ($C8),y
4282	.a57a	a8		tay		                tay
4283	.a57b	20 4d a5	jsr $a54d	                jsr LA06B                    ; Parse filename
4284	.a57e	a0 02		ldy #$02	                ldy #$02
4285	.a580					LA09E:
4286	.a580	b1 c8		lda ($c8),y	                lda ($C8),y
4287	.a582	99 bc 03	sta $03bc,y	                sta $03BC,y
4288	.a585	99 ae 00	sta $00ae,y	                sta $00AE,y
4289	.a588	c8		iny		                iny
4290	.a589	c0 0a		cpy #$0a	                cpy #$0A
4291	.a58b	d0 f3		bne $a580	                bne LA09E
4292	.a58d	68		pla		                pla
4293	.a58e	f0 07		beq $a597	                beq LA0B5
4294	.a590	c9 ff		cmp #$ff	                cmp #$FF
4295	.a592	d0 b2		bne $a546	                bne LA064
4296	.a594	4c 96 a4	jmp $a496	                jmp L9FAF

4298	.a597					LA0B5:
4302	.a597	8d c6 03	sta $03c6	                sta $03C6
4303	.a59a	8d c7 03	sta $03c7	                sta $03C7
4304	.a59d					LA0BB:
4305	.a59d	b1 c8		lda ($c8),y	                lda ($C8),y
4306	.a59f	99 a6 00	sta $00a6,y	                sta $00A6,y
4307	.a5a2	c8		iny		                iny
4308	.a5a3	c0 12		cpy #$12	                cpy #$12
4309	.a5a5	d0 f6		bne $a59d	                bne LA0BB
4310	.a5a7	8a		txa		                txa
4311	.a5a8	f0 bd		beq $a567	                beq LA085
4312	.a5aa	20 2b ae	jsr $ae2b	                jsr LA9F3
4313	.a5ad	20 64 ac	jsr $ac64	                jsr LA822
4318	.a5b0					LA0D3:
4319	.a5b0	38		sec		                sec
4320	.a5b1	a2 fd		ldx #$fd	                ldx #$fd                     ;-3
4321	.a5b3					LA0D6:
4322	.a5b3	bd b7 ff	lda $ffb7,x	                lda ($b4-$fd)&$ffff,x
4323	.a5b6	fd b3 ff	sbc $ffb3,x	                sbc ($b0-$fd)&$ffff,x
4324	.a5b9	9d cb 02	sta $02cb,x	                sta $3c8-$fd,x
4325	.a5bc	e8		inx		                inx
4326	.a5bd	d0 f4		bne $a5b3	                bne LA0D6
4327	.a5bf	a8		tay		                tay
4328	.a5c0	d0 0e		bne $a5d0	                bne LA0F3
4329	.a5c2	ec c8 03	cpx $03c8	                cpx $03C8
4330	.a5c5	a9 01		lda #$01	                lda #$01
4331	.a5c7	ed c9 03	sbc $03c9	                sbc $03C9
4332	.a5ca	90 04		bcc $a5d0	                bcc LA0F3
4333	.a5cc	a2 80		ldx #$80	                ldx #$80
4334	.a5ce	80 08		bra $a5d8	                bra LA0FB

4336	.a5d0					LA0F3:
4337	.a5d0	a9 01		lda #$01	                lda #$01
4338	.a5d2	8d c9 03	sta $03c9	                sta $03C9
4339	.a5d5	8e c8 03	stx $03c8	                stx $03C8
4340	.a5d8					LA0FB:
4341	.a5d8	8e ca 03	stx $03ca	                stx $03CA
4342	.a5db	20 35 ab	jsr $ab35	                jsr LA6E9
4343	.a5de	30 61		bmi $a641	                bmi LA17B
4344	.a5e0	20 9d ac	jsr $ac9d	                jsr LA85B
4345	.a5e3	ee c6 03	inc $03c6	                inc $03C6
4346	.a5e6	d0 c8		bne $a5b0	                bne LA0D3
4347	.a5e8	ee c7 03	inc $03c7	                inc $03C7
4348	.a5eb	80 c3		bra $a5b0	                bra LA0D3

4351						; TAPE/ROM FSC 2 - */
4352						; TAPE/ROM FSC 4 - *RUN
4353						; ---------------------
4354	.a5ed					LA110:
4355	.a5ed	38		sec		                sec
4356	.a5ee	66 ce		ror $ce		                ror $CE
4357						; TAPE/ROM FSC 11 - *RUN command for library
4358						; ------------------------------------------
4359	.a5f0					LA113:
4360	.a5f0	da		phx		                phx
4361	.a5f1	5a		phy		                phy
4362	.a5f2	20 4d a5	jsr $a54d	                jsr LA06B
4363	.a5f5	a9 00		lda #$00	                lda #$00
4364	.a5f7	a2 ff		ldx #$ff	                ldx #$FF
4365	.a5f9	8e c2 03	stx $03c2	                stx $03C2
4366	.a5fc	20 96 a4	jsr $a496	                jsr L9FAF
4367	.a5ff	7a		ply		                ply
4368	.a600	fa		plx		                plx
4369	.a601	90 08		bcc $a60b	                bcc LA12E
4371	.a603	20 02 ae	jsr $ae02	                jsr LA9CA

4374						; TAPE/ROM FSC 3 - unknown * command
4375						; ----------------------------------
4376	.a606					LA129:
4377	.a606	a9 0b		lda #$0b	                lda #$0B
4378	.a608	6c 1e 02	jmp ($021e)	                jmp (FSCV)

4380	.a60b					LA12E:

4391	.a60b	ae c2 03	ldx $03c2	                ldx $03C2
4392	.a60e	ac c3 03	ldy $03c3	                ldy $03C3
4393	.a611	a9 a4		lda #$a4	                lda #$A4
4394	.a613	20 f4 ff	jsr $fff4	                jsr OSBYTE
4395	.a616	a9 01		lda #$01	                lda #$01
4396	.a618	6c c2 03	jmp ($03c2)	                jmp ($03C2)

4406						; TAPE/ROM FSC 9 - *EX
4407						; --------------------
4408	.a61b					LA155:
4409	.a61b	a9 08		lda #$08	                lda #$08
4410	.a61d	04 e2		tsb $e2		                tsb $E2
4411	.a61f	a5 e3		lda $e3		                lda $E3
4412	.a621	48		pha		                pha
4413	.a622	09 cc		ora #$cc	                ora #$CC
4414	.a624	85 e3		sta $e3		                sta $E3
4415	.a626	20 2b ae	jsr $ae2b	                jsr LA9F3
4416	.a629	68		pla		                pla
4417	.a62a	85 e3		sta $e3		                sta $E3
4418	.a62c	80 07		bra $a635	                bra LA16F

4420						; TAPE/ROM FSC 5 - *CAT
4421						; ---------------------
4422	.a62e					LA168:
4423	.a62e	a9 08		lda #$08	                lda #$08
4424	.a630	04 e2		tsb $e2		                tsb $E2
4425	.a632	20 2b ae	jsr $ae2b	                jsr LA9F3
4426	.a635					LA16F:
4427	.a635	a9 00		lda #$00	                lda #$00
4428	.a637	20 42 a6	jsr $a642	                jsr LA17C
4430	.a63a	20 02 ae	jsr $ae02	                jsr LA9CA
4432	.a63d					LA177:
4433	.a63d	a9 08		lda #$08	                lda #$08
4434	.a63f	14 e2		trb $e2		                trb $E2
4435	.a641					LA17B:
4436	.a641	60		rts		                rts

4438	.a642					LA17C:
4439	.a642	48		pha		                pha
4441	.a643	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4442	.a646	f0 09		beq $a651	                beq LA18B
4444	.a648	20 09 f5	jsr $f509	                jsr LF6FC
4445	.a64b	20 0e f5	jsr $f50e	                jsr LF701
4446	.a64e	b8		clv		                clv
4447	.a64f	b0 50		bcs $a6a1	                bcs LA1DB
4448	.a651					LA18B:
4449	.a651	20 e7 aa	jsr $aae7	                jsr LA678
4450	.a654	ad c6 03	lda $03c6	                lda $03C6
4451	.a657	85 b4		sta $b4		                sta $B4
4452	.a659	ad c7 03	lda $03c7	                lda $03C7
4453	.a65c	85 b5		sta $b5		                sta $B5
4454	.a65e	a2 ff		ldx #$ff	                ldx #$FF
4455	.a660	8e df 03	stx $03df	                stx $03DF
4456	.a663	64 ba		stz $ba		                stz $BA
4457	.a665	80 16		bra $a67d	                bra LA1B7

4459	.a667					LA1A1:
4461	.a667	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4462	.a66a	f0 37		beq $a6a3	                beq LA1DD
4464	.a66c					LA1A6:
4465	.a66c	20 24 f5	jsr $f524	                jsr LF717
4466	.a66f					LA1A9:
4467	.a66f	a9 ff		lda #$ff	                lda #$FF
4468	.a671	8d c6 03	sta $03c6	                sta $03C6
4469	.a674	8d c7 03	sta $03c7	                sta $03C7
4470	.a677					LA1B1:
4471	.a677	20 6d ae	jsr $ae6d	                jsr LAA35
4472	.a67a	20 e7 aa	jsr $aae7	                jsr LA678
4473	.a67d					LA1B7:
4475	.a67d	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4476	.a680	f0 02		beq $a684	                beq LA1BE
4478	.a682	50 1d		bvc $a6a1	                bvc LA1DB
4479	.a684					LA1BE:
4480	.a684	68		pla		                pla
4481	.a685	48		pha		                pha
4482	.a686	f0 1b		beq $a6a3	                beq LA1DD
4483	.a688	20 9e ad	jsr $ad9e	                jsr LA95C
4484	.a68b	d0 da		bne $a667	                bne LA1A1
4485	.a68d	a9 30		lda #$30	                lda #$30
4486	.a68f	25 bb		and $bb		                and $BB
4487	.a691	f0 0e		beq $a6a1	                beq LA1DB
4488	.a693	ad c6 03	lda $03c6	                lda $03C6
4489	.a696	c5 b6		cmp $b6		                cmp $B6
4490	.a698	d0 cd		bne $a667	                bne LA1A1
4491	.a69a	ad c7 03	lda $03c7	                lda $03C7
4492	.a69d	c5 b7		cmp $b7		                cmp $B7
4493	.a69f	d0 c6		bne $a667	                bne LA1A1
4494	.a6a1					LA1DB:
4495	.a6a1	68		pla		                pla
4496	.a6a2	60		rts		                rts

4498	.a6a3					LA1DD:
4499	.a6a3	50 05		bvc $a6aa	                bvc LA1E4
4500	.a6a5	a9 ff		lda #$ff	                lda #$FF
4501	.a6a7	20 20 ab	jsr $ab20	                jsr LA6D4
4502	.a6aa					LA1E4:
4503	.a6aa	a2 00		ldx #$00	                ldx #$00
4504	.a6ac	20 06 ad	jsr $ad06	                jsr LA8C4
4506	.a6af	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4507	.a6b2	f0 04		beq $a6b8	                beq LA1F2
4509	.a6b4	24 bb		bit $bb		                bit $BB
4510	.a6b6	50 b4		bvc $a66c	                bvc LA1A6
4511	.a6b8					LA1F2:
4512	.a6b8	2c ca 03	bit $03ca	                bit $03CA
4513	.a6bb	30 b2		bmi $a66f	                bmi LA1A9
4514	.a6bd	80 b8		bra $a677	                bra LA1B1

4516						; CFS/RFS OSFIND HANDLER
4517						; ======================
4518	.a6bf					osfindTapeOrROM:
4519	.a6bf	85 bc		sta $bc		                sta $BC
4520	.a6c1	da		phx		                phx
4521	.a6c2	5a		phy		                phy
4522	.a6c3	09 00		ora #$00	                ora #$00
4523	.a6c5	d0 1f		bne $a6e6	                bne LA220
4524	.a6c7	98		tya		                tya
4525	.a6c8	d0 0e		bne $a6d8	                bne LA212
4527	.a6ca	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
4528	.a6cd	d0 03		bne $a6d2	                bne LA20C
4529	.a6cf	20 62 a7	jsr $a762	                jsr LA29C
4531	.a6d2					LA20C:
4532	.a6d2	a9 01		lda #$01	                lda #$01
4533	.a6d4	14 e2		trb $e2		                trb $E2
4537	.a6d6	80 0c		bra $a6e4	                bra LA21E
4539	.a6d8					LA212:
4540	.a6d8	4a		lsr a		                lsr a
4541	.a6d9	b0 f7		bcs $a6d2	                bcs LA20C
4543	.a6db	4a		lsr a		                lsr a
4544	.a6dc	b0 03		bcs $a6e1	                bcs LA21B
4546	.a6de	4c b9 ae	jmp $aeb9	                jmp LAA81

4549	.a6e1					LA21B:
4550	.a6e1	20 62 a7	jsr $a762	                jsr LA29C
4551	.a6e4					LA21E:
4552	.a6e4	80 77		bra $a75d	                bra LA297

4555	.a6e6					LA220:
4556	.a6e6	20 4d a5	jsr $a54d	                jsr LA06B
4557	.a6e9	24 bc		bit $bc		                bit $BC
4558	.a6eb	50 39		bvc $a726	                bvc LA260
4559	.a6ed	9c 9e 03	stz $039e	                stz $039E
4560	.a6f0	9c dd 03	stz $03dd	                stz $03DD
4561	.a6f3	9c de 03	stz $03de	                stz $03DE
4562	.a6f6	a9 c1		lda #$c1	                lda #$C1
4563	.a6f8	14 e2		trb $e2		                trb $E2
4564	.a6fa	20 1e ae	jsr $ae1e	                jsr LA9E6
4565	.a6fd	08		php		                php
4566	.a6fe	20 71 a9	jsr $a971	                jsr LA502
4567	.a701	20 26 aa	jsr $aa26	                jsr LA5B7
4568	.a704	28		plp		                plp
4569	.a705	a2 ff		ldx #$ff	                ldx #$FF
4570	.a707					LA241:
4571	.a707	e8		inx		                inx
4572	.a708	bd b2 03	lda $03b2,x	                lda $03B2,x
4573	.a70b	9d a7 03	sta $03a7,x	                sta $03A7,x
4574	.a70e	d0 f7		bne $a707	                bne LA241
4575	.a710	1a		inc a		                inc a
4576	.a711	04 e2		tsb $e2		                tsb $E2
4577	.a713	ad e9 02	lda $02e9	                lda tapeInputCurrentBlockSize+0
4578	.a716	0d ea 02	ora $02ea	                ora tapeInputCurrentBlockSize+1
4579	.a719	d0 04		bne $a71f	                bne LA259
4580	.a71b	a9 40		lda #$40	                lda #$40
4581	.a71d	04 e2		tsb $e2		                tsb $E2
4582	.a71f					LA259:
4589	.a71f	a9 01		lda #$01	                lda #$01
4590	.a721	0d 47 02	ora $0247	                ora cfsRFSFSSwitch
4591	.a724	d0 35		bne $a75b	                bne LA295
4592	.a726					LA260:
4593	.a726	8a		txa		                txa
4594	.a727	d0 03		bne $a72c	                bne LA266
4595	.a729	4c 4e f3	jmp $f34e	                jmp badStringError

4597	.a72c					LA266:
4598	.a72c	a2 ff		ldx #$ff	                ldx #$FF
4599	.a72e					LA268:
4600	.a72e	e8		inx		                inx
4601	.a72f	bd d2 03	lda $03d2,x	                lda $03D2,x
4602	.a732	9d 80 03	sta $0380,x	                sta $0380,x
4603	.a735	d0 f7		bne $a72e	                bne LA268
4604	.a737	3a		dec a		                dec a
4605	.a738	a2 08		ldx #$08	                ldx #$08
4606	.a73a					LA274:
4607	.a73a	9d 8b 03	sta $038b,x	                sta $038B,x
4608	.a73d	ca		dex		                dex
4609	.a73e	d0 fa		bne $a73a	                bne LA274
4610	.a740	8a		txa		                txa
4611	.a741	a2 14		ldx #$14	                ldx #$14
4612	.a743					LA27D:
4613	.a743	9d 80 03	sta $0380,x	                sta $0380,x
4614	.a746	e8		inx		                inx
4615	.a747	e0 1e		cpx #$1e	                cpx #$1E
4616	.a749	d0 f8		bne $a743	                bne LA27D
4617	.a74b	2e 97 03	rol $0397	                rol $0397
4618	.a74e	20 2b ae	jsr $ae2b	                jsr LA9F3
4619	.a751	20 64 ac	jsr $ac64	                jsr LA822
4620	.a754	20 fd ad	jsr $adfd	                jsr LA9BB
4621	.a757	a9 02		lda #$02	                lda #$02
4622	.a759	04 e2		tsb $e2		                tsb $E2
4624	.a75b					LA295:
4625	.a75b	85 bc		sta $bc		                sta $BC
4626	.a75d					LA297:
4627	.a75d	7a		ply		                ply
4628	.a75e	fa		plx		                plx
4629	.a75f	a5 bc		lda $bc		                lda $BC
4630	.a761					LA29B:
4631	.a761	60		rts		                rts

4634	.a762					LA29C:
4635	.a762	a9 02		lda #$02	                lda #$02
4636	.a764	25 e2		and $e2		                and $E2
4637	.a766	f0 f9		beq $a761	                beq LA29B
4638	.a768	9c 97 03	stz $0397	                stz $0397
4639	.a76b	a9 80		lda #$80	                lda #$80
4640	.a76d	ae 9d 03	ldx $039d	                ldx $039D
4641	.a770	8e 96 03	stx $0396	                stx $0396
4642	.a773	8d 98 03	sta $0398	                sta $0398
4643	.a776	20 7e a7	jsr $a77e	                jsr LA2B8
4644	.a779	a9 02		lda #$02	                lda #$02
4645	.a77b	14 e2		trb $e2		                trb $E2
4646	.a77d	60		rts		                rts

4648	.a77e					LA2B8:
4649	.a77e	20 1e ae	jsr $ae1e	                jsr LA9E6
4650	.a781	a2 11		ldx #$11	                ldx #$11
4651	.a783					LA2BD:
4652	.a783	bd 8c 03	lda $038c,x	                lda $038C,x
4653	.a786	9d be 03	sta $03be,x	                sta $03BE,x
4654	.a789	ca		dex		                dex
4655	.a78a	10 f7		bpl $a783	                bpl LA2BD
4656	.a78c	86 b2		stx $b2		                stx $B2
4657	.a78e	86 b3		stx $b3		                stx $B3
4658	.a790	64 b0		stz $b0		                stz $B0
4659	.a792	a9 09		lda #$09	                lda #$09
4660	.a794	85 b1		sta $b1		                sta $B1
4661	.a796	a2 7f		ldx #$7f	                ldx #$7F
4662	.a798	20 85 ae	jsr $ae85	                jsr LAA4D
4663	.a79b	8d df 03	sta $03df	                sta $03DF
4664	.a79e	20 92 ae	jsr $ae92	                jsr LAA5A
4665	.a7a1	20 d8 ae	jsr $aed8	                jsr LAAA0
4666	.a7a4	20 35 ab	jsr $ab35	                jsr LA6E9
4667	.a7a7	ee 94 03	inc $0394	                inc $0394
4668	.a7aa	d0 03		bne $a7af	                bne LA2E9
4669	.a7ac	ee 95 03	inc $0395	                inc $0395
4670	.a7af					LA2E9:
4671	.a7af	60		rts		                rts

4674	.a7b0					bputTapeOrROM:
4675	.a7b0	da		phx		                phx
4676	.a7b1	5a		phy		                phy
4677	.a7b2	a9 01		lda #$01	                lda #$01
4678	.a7b4					LA2EE:
4679	.a7b4	20 a0 ae	jsr $aea0	                jsr LAA68
4680	.a7b7	a5 e2		lda $e2		                lda $E2
4681	.a7b9	0a		asl a		                asl a
4682	.a7ba	b0 4d		bcs $a809	                bcs LA343
4683	.a7bc	0a		asl a		                asl a
4684	.a7bd	90 08		bcc $a7c7	                bcc LA301
4685	.a7bf	a9 80		lda #$80	                lda #$80
4686	.a7c1	04 e2		tsb $e2		                tsb $E2
4687	.a7c3	a9 fe		lda #$fe	                lda #$FE
4688	.a7c5	b0 3a		bcs $a801	                bcs LA33B
4689	.a7c7					LA301:
4690	.a7c7	ae 9e 03	ldx $039e	                ldx $039E
4691	.a7ca	e8		inx		                inx
4692	.a7cb	ec e9 02	cpx $02e9	                cpx tapeInputCurrentBlockSize+0
4693	.a7ce	d0 2c		bne $a7fc	                bne LA336
4694	.a7d0	2c eb 02	bit $02eb	                bit blockFlagOfCurrentlyResidentBlock
4695	.a7d3	30 23		bmi $a7f8	                bmi LA332
4696	.a7d5	ad ec 02	lda $02ec	                lda lastCharacterOfCurrentlyResidentBlock
4697	.a7d8	48		pha		                pha
4698	.a7d9	20 1e ae	jsr $ae1e	                jsr LA9E6
4699	.a7dc	08		php		                php
4700	.a7dd	20 1e aa	jsr $aa1e	                jsr LA5AF
4701	.a7e0	28		plp		                plp
4702	.a7e1	68		pla		                pla
4703	.a7e2	85 bc		sta $bc		                sta $BC
4704	.a7e4	18		clc		                clc
4705	.a7e5	2c eb 02	bit $02eb	                bit blockFlagOfCurrentlyResidentBlock
4706	.a7e8	10 19		bpl $a803	                bpl LA33D
4707	.a7ea	ad e9 02	lda $02e9	                lda tapeInputCurrentBlockSize+0
4708	.a7ed	0d ea 02	ora $02ea	                ora tapeInputCurrentBlockSize+1
4709	.a7f0	d0 11		bne $a803	                bne LA33D
4710	.a7f2	a9 40		lda #$40	                lda #$40
4711	.a7f4	04 e2		tsb $e2		                tsb $E2
4712	.a7f6	80 0b		bra $a803	                bra LA33D

4714	.a7f8					LA332:
4715	.a7f8	a9 40		lda #$40	                lda #$40
4716	.a7fa	04 e2		tsb $e2		                tsb $E2
4717	.a7fc					LA336:
4718	.a7fc	ca		dex		                dex
4719	.a7fd	18		clc		                clc
4720	.a7fe	bd 00 0a	lda $0a00,x	                lda $0A00,x
4721	.a801					LA33B:
4722	.a801	85 bc		sta $bc		                sta $BC
4723	.a803					LA33D:
4724	.a803	ee 9e 03	inc $039e	                inc $039E
4725	.a806	4c 5d a7	jmp $a75d	                jmp LA297

4727	.a809					LA343:
4728	.a809	20 ff ae	jsr $aeff	                jsr doFollowingError
4729	>a80c	df 45 4f 46 00			                .text $df,"EOF",0

4742	.a811					bgetTapeOrROM:
4743	.a811	85 c4		sta $c4		                sta $C4
4744	.a813	da		phx		                phx
4745	.a814	5a		phy		                phy
4746	.a815	a9 02		lda #$02	                lda #$02
4747	.a817	20 a0 ae	jsr $aea0	                jsr LAA68
4748	.a81a	ae 9d 03	ldx $039d	                ldx $039D
4749	.a81d	a5 c4		lda $c4		                lda $C4
4750	.a81f	9d 00 09	sta $0900,x	                sta $0900,x
4751	.a822	e8		inx		                inx
4752	.a823	d0 06		bne $a82b	                bne LA365
4753	.a825	20 7e a7	jsr $a77e	                jsr LA2B8
4754	.a828	20 fd ad	jsr $adfd	                jsr LA9BB
4755	.a82b					LA365:
4756	.a82b	ee 9d 03	inc $039d	                inc $039D
4757	.a82e	a5 c4		lda $c4		                lda $C4
4758	.a830	4c 5b a7	jmp $a75b	                jmp LA295

4762						; TAPE/ROM OSGBPB handler
4763						; =======================
4764	.a833					osgbpbTapeOrROM:
4765	.a833	4a		lsr a		                lsr a                        ; Odd numbered calls - change PTR - exit with A=changed, SEC
4766	.a834	b0 06		bcs $a83c	                bcs LA376
4767	.a836	f0 04		beq $a83c	                beq LA376                    ; OSGBPB 0 - exit with A=unchanged, SEC
4768	.a838	c9 03		cmp #$03	                cmp #$03                     ; function/2<3 - function<6 - function 2 and 4 - jump to do
4769	.a83a	90 02		bcc $a83e	                bcc LA378
4770	.a83c					LA376:
4771	.a83c	38		sec		                sec
4772	.a83d	60		rts		                rts

4775						; Call Return
4776						;  0    A=0   SEC                        - unsupported
4777						;  1    A=0   SEC  Write using new PTR   - unsupported
4778						;  2    A=         Write with current PTR
4779						;  3    A=1   SEC  Read with new PTR     - unsupported
4780						;  4    A=         Read with current PTR
4781						;  5+   A=A/2 SEC                        - unsupported

4783						; TAPE/ROM OSGBPB 2 and 4 - read/write with current PTR
4784						; -----------------------------------------------------
4785	.a83e					LA378:
4787	.a83e	4a		lsr a		                lsr a
4789	.a83f	86 cc		stx $cc		                stx $CC
4790	.a841	84 cd		sty $cd		                sty $CD
4791	.a843	a0 01		ldy #$01	                ldy #$01
4792	.a845	b1 cc		lda ($cc),y	                lda ($CC),y
4793	.a847	85 c8		sta $c8		                sta $C8                      ; address LSB
4794	.a849	c8		iny		                iny
4795	.a84a	b1 cc		lda ($cc),y	                lda ($CC),y
4796	.a84c	85 c9		sta $c9		                sta $C9                      ; address MSB
4832	.a84e	b2 cc		lda ($cc)	                lda ($CC)                    ; A=handle
4833	.a850	a8		tay		                tay                          ; Y=handle
4834	.a851	a9 01		lda #$01	                lda #$01
4839	.a853	08		php		                php                          ; save C
4840	.a854	69 00		adc #$00	                adc #$00
4842	.a856	20 c5 ae	jsr $aec5	                jsr LAA8D
4843	.a859	b0 04		bcs $a85f	                bcs LA3C1
4845	.a85b	28		plp		                plp                          ; restore C
4854	.a85c	4c b9 ae	jmp $aeb9	                jmp LAA81

4856	.a85f					LA3C1:
4858	.a85f	28		plp		                plp
4859	.a860	b0 22		bcs $a884	                bcs LA401
4861	.a862	24 e2		bit $e2		                bit $E2
4862	.a864	10 03		bpl $a869	                bpl LA3D3
4870	.a866	4c 09 a8	jmp $a809	                jmp LA343

4872	.a869					LA3D3:
4873	.a869	20 f2 ae	jsr $aef2	                jsr LAAE0
4874	.a86c	f0 15		beq $a883	                beq LA3F6
4875	.a86e	b2 cc		lda ($cc)	                lda ($CC)
4876	.a870	a8		tay		                tay
4877	.a871	20 b0 a7	jsr $a7b0	                jsr bputTapeOrROM
4878	.a874	b0 0d		bcs $a883	                bcs LA3F6
4888	.a876	92 c8		sta ($c8)	                sta ($C8)                    ; store the byte to I/O RAM
4889	.a878	e6 c8		inc $c8		                inc $C8                      ; next address...
4890	.a87a	d0 02		bne $a87e	                bne LA3F1
4891	.a87c	e6 c9		inc $c9		                inc $C9
4892	.a87e					LA3F1:
4893	.a87e	20 dc ae	jsr $aedc	                jsr LAACA
4894	.a881	80 e6		bra $a869	                bra LA3D3

4896	.a883					LA3F6:
4906	.a883	60		rts		                rts

4909	.a884					LA401:
4910	.a884	20 f2 ae	jsr $aef2	                jsr LAAE0
4911	.a887	f0 fa		beq $a883	                beq LA3F6
4912	.a889	b2 cc		lda ($cc)	                lda ($CC)
4913	.a88b	a8		tay		                tay

4923	.a88c	b2 c8		lda ($c8)	                lda ($C8)                    ; read the byte from I/O RAM
4924	.a88e	e6 c8		inc $c8		                inc $C8                      ; next address...
4925	.a890	d0 02		bne $a894	                bne LA41A
4926	.a892	e6 c9		inc $c9		                inc $C9
4927	.a894					LA41A:
4928	.a894	20 11 a8	jsr $a811	                jsr bgetTapeOrROM
4929	.a897	20 dc ae	jsr $aedc	                jsr LAACA
4930	.a89a	80 e8		bra $a884	                bra LA401

4933						; TAPE/ROM FSC 0 - *OPT
4934						; ---------------------
4935	.a89c					LA422:
4936	.a89c	8a		txa		                txa                          ; *OPT 0
4937	.a89d	f0 2e		beq $a8cd	                beq LA453
4938	.a89f	e0 03		cpx #$03	                cpx #$03                     ; *OPT 3
4939	.a8a1	f0 1f		beq $a8c2	                beq LA448
4940	.a8a3	c0 03		cpy #$03	                cpy #$03                     ; *OPT n,3+ - error Bad command (*BUG* should be Bad option)
4941	.a8a5	b0 06		bcs $a8ad	                bcs LA433
4942	.a8a7	ca		dex		                dex                          ; *OPT 1
4943	.a8a8	f0 06		beq $a8b0	                beq LA436
4944	.a8aa	ca		dex		                dex                          ; *OPT 2
4945	.a8ab	f0 0a		beq $a8b7	                beq LA43D
4946	.a8ad					LA433:
4947	.a8ad	4c 60 fb	jmp $fb60	                jmp badCommandError ; *OPT 4+ - error Bad command (*BUG* should be Bad option)

4949						; *OPT 1 - set message level
4950						; --------------------------
4951	.a8b0					LA436:
4952	.a8b0	a9 33		lda #$33	                lda #$33
4953	.a8b2	c8		iny		                iny
4954	.a8b3	c8		iny		                iny
4955	.a8b4	c8		iny		                iny
4956	.a8b5	80 02		bra $a8b9	                bra LA43F

4958						; *OPT 2 - set error response level
4959						; ---------------------------------
4960	.a8b7					LA43D:
4961	.a8b7	a9 cc		lda #$cc	                lda #$CC
4962	.a8b9					LA43F:
4963	.a8b9	c8		iny		                iny
4964	.a8ba	25 e3		and $e3		                and $E3
4965	.a8bc					LA442:
4966	.a8bc	19 d0 a8	ora $a8d0,y	                ora LA456,y
4967	.a8bf	85 e3		sta $e3		                sta $E3
4968	.a8c1	60		rts		                rts

4970						; *OPT 3 - set interblock gap
4971						; ---------------------------
4972	.a8c2					LA448:
4973	.a8c2	98		tya		                tya                          ; *OPT 3,128+ - set to default
4974	.a8c3	30 02		bmi $a8c7	                bmi LA44D    ;
4975	.a8c5	d0 02		bne $a8c9	                bne LA44F                    ; *OPT 3,<>0 - use setting
4976	.a8c7					LA44D:
4977	.a8c7	a9 19		lda #$19	                lda #$19                     ; *OPT 3,0 or *OPT 3,128+ - use default of 2.5 sec
4978	.a8c9					LA44F:
4979	.a8c9	8d d1 03	sta $03d1	                sta $03D1                    ; Set inter-block gap
4980	.a8cc	60		rts		                rts

4982	.a8cd					LA453:
4983	.a8cd	a8		tay		                tay
4984	.a8ce	80 ec		bra $a8bc	                bra LA442

4986	.a8d0					LA456:
4987						                ; LDA ($00,x)
4988						                ; EQUB $22
4989						                ; ORA ($00),y
4990						                ; DEY
4991						                ; CPY LC0C6
4992	>a8d0	a1				                .byte $A1
4993	>a8d1	00				                .byte $00
4994	>a8d2	22				                .byte $22
4995	>a8d3	11				                .byte $11
4996	>a8d4	00				                .byte $00
4997	>a8d5	88				                .byte $88
4998	>a8d6	cc				                .byte $CC

5001	.a8d7					LA45D:
5002	.a8d7	c6 c0		dec $c0		                dec $C0
5003	.a8d9	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5004	.a8dc	f0 07		beq $a8e5	                beq LA46B
5005	.a8de	20 1d f5	jsr $f51d	                jsr LF710
5006	.a8e1	a8		tay		                tay
5007	.a8e2	18		clc		                clc
5008	.a8e3	80 1a		bra $a8ff	                bra LA485

5010	.a8e5					LA46B:
5011	.a8e5	ad 08 fe	lda $fe08	                lda ACIA+0
5012	.a8e8	48		pha		                pha
5013	.a8e9	29 02		and #$02	                and #$02
5014	.a8eb	f0 0b		beq $a8f8	                beq LA47E
5015	.a8ed	a4 ca		ldy $ca		                ldy $CA
5016	.a8ef	f0 07		beq $a8f8	                beq LA47E
5017	.a8f1	68		pla		                pla
5018	.a8f2	a5 bd		lda $bd		                lda $BD
5019	.a8f4	8d 09 fe	sta $fe09	                sta ACIA+1
5020	.a8f7	60		rts		                rts

5022	.a8f8					LA47E:
5023	.a8f8	ac 09 fe	ldy $fe09	                ldy ACIA+1
5024	.a8fb	68		pla		                pla
5025	.a8fc	4a		lsr a		                lsr a
5026	.a8fd	4a		lsr a		                lsr a
5027	.a8fe	4a		lsr a		                lsr a
5028	.a8ff					LA485:
5029	.a8ff	a6 c2		ldx $c2		                ldx $C2
5030	.a901	f0 5c		beq $a95f	                beq LA4F0
5031	.a903	ca		dex		                dex
5032	.a904	d0 06		bne $a90c	                bne LA492
5033	.a906	90 57		bcc $a95f	                bcc LA4F0
5034	.a908	a0 02		ldy #$02	                ldy #$02
5035	.a90a	80 51		bra $a95d	                bra LA4EE

5038	.a90c					LA492:
5049	.a90c	ca		dex		                dex
5050	.a90d	d0 13		bne $a922	                bne LA4A8
5051	.a90f	b0 4e		bcs $a95f	                bcs LA4F0
5053	.a911	98		tya		                tya
5054	.a912	20 7c ae	jsr $ae7c	                jsr LAA44
5055	.a915	a0 03		ldy #$03	                ldy #$03
5056	.a917	c9 2a		cmp #$2a	                cmp #$2A
5057	.a919	f0 42		beq $a95d	                beq LA4EE
5058	.a91b	20 54 ae	jsr $ae54	                jsr LAA1C
5059	.a91e	a0 01		ldy #$01	                ldy #$01
5060	.a920	80 3b		bra $a95d	                bra LA4EE

5062	.a922					LA4A8:
5063	.a922	ca		dex		                dex
5064	.a923	d0 0a		bne $a92f	                bne LA4B5
5066	.a925	b0 03		bcs $a92a	                bcs LA4B0
5068	.a927	84 bd		sty $bd		                sty $BD
5069	.a929	60		rts		                rts

5072	.a92a					LA4B0:
5073	.a92a	a9 80		lda #$80	                lda #$80
5074	.a92c	85 c0		sta $c0		                sta $C0
5075	.a92e	60		rts		                rts

5078	.a92f					LA4B5:
5079	.a92f	ca		dex		                dex
5080	.a930	d0 1e		bne $a950	                bne LA4E1
5082	.a932	b0 24		bcs $a958	                bcs LA4E9
5084	.a934	98		tya		                tya
5085	.a935	20 18 ab	jsr $ab18	                jsr LA6A9
5086	.a938	a4 bc		ldy $bc		                ldy $BC
5087	.a93a	e6 bc		inc $bc		                inc $BC
5088	.a93c	24 bd		bit $bd		                bit $BD
5089	.a93e	30 02		bmi $a942	                bmi LA4D3
5099	.a940	91 b0		sta ($b0),y	                sta ($B0),y                  ; store byte to I/O RAM
5100	.a942					LA4D3:
5101	.a942	c8		iny		                iny
5102	.a943	cc c8 03	cpy $03c8	                cpy $03C8
5103	.a946	d0 17		bne $a95f	                bne LA4F0
5104	.a948	a9 01		lda #$01	                lda #$01
5105	.a94a	85 bc		sta $bc		                sta $BC
5106	.a94c	a0 05		ldy #$05	                ldy #$05
5107	.a94e	80 0d		bra $a95d	                bra LA4EE

5109	.a950					LA4E1:
5110	.a950	98		tya		                tya
5111	.a951	20 18 ab	jsr $ab18	                jsr LA6A9
5112	.a954	c6 bc		dec $bc		                dec $BC
5113	.a956	10 07		bpl $a95f	                bpl LA4F0
5115	.a958					LA4E9:
5116	.a958	20 4a ae	jsr $ae4a	                jsr resetACIA
5118	.a95b	a0 00		ldy #$00	                ldy #$00
5119	.a95d					LA4EE:
5120	.a95d	84 c2		sty $c2		                sty $C2
5121	.a95f					LA4F0:
5122	.a95f	60		rts		                rts

5124						; TAPE/ROM FSC 1 - =EOF
5125						; ---------------------
5126	.a960					LA4F1:
5127	.a960	48		pha		                pha
5128	.a961	5a		phy		                phy
5129	.a962	8a		txa		                txa
5130	.a963	a8		tay		                tay
5131	.a964	a9 03		lda #$03	                lda #$03                     ; Check if this channel is open for anything
5132	.a966	20 a0 ae	jsr $aea0	                jsr LAA68
5133	.a969	a5 e2		lda $e2		                lda $E2                      ; Get EOF flag
5134	.a96b	29 40		and #$40	                and #$40
5135	.a96d	aa		tax		                tax                          ; Return in X
5136	.a96e	7a		ply		                ply
5137	.a96f	68		pla		                pla
5138	.a970	60		rts		                rts

5140	.a971					LA502:
5141	.a971	64 b4		stz $b4		                stz $B4
5142	.a973	64 b5		stz $b5		                stz $B5
5143	.a975					LA506:
5144	.a975	46 ce		lsr $ce		                lsr $CE
5145	.a977	a5 b4		lda $b4		                lda $B4
5146	.a979	48		pha		                pha
5147	.a97a	85 b6		sta $b6		                sta $B6
5148	.a97c	a5 b5		lda $b5		                lda $B5
5149	.a97e	48		pha		                pha
5150	.a97f	85 b7		sta $b7		                sta $B7
5151	.a981	20 65 ad	jsr $ad65	                jsr LA923
5152	>a984	53 65 61 72 63 68 69 6e		                .text "Searching",13,0
	>a98c	67 0d 00
5153	.a98f	a9 ff		lda #$ff	                lda #$ff
5154	.a991	20 42 a6	jsr $a642	                jsr LA17C
5155	.a994	68		pla		                pla
5156	.a995	85 b5		sta $b5		                sta $B5
5157	.a997	68		pla		                pla
5158	.a998	85 b4		sta $b4		                sta $B4
5159	.a99a	a5 b6		lda $b6		                lda $B6
5160	.a99c	05 b7		ora $b7		                ora $B7
5161	.a99e	d0 33		bne $a9d3	                bne LA564
5162	.a9a0	64 b4		stz $b4		                stz $B4
5163	.a9a2	64 b5		stz $b5		                stz $B5
5165	.a9a4	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5166	.a9a7	f0 21		beq $a9ca	                beq LA55B
5168	.a9a9	70 1f		bvs $a9ca	                bvs LA55B
5170	.a9ab	20 02 ae	jsr $ae02	                jsr LA9CA
5172	.a9ae	24 ce		bit $ce		                bit $CE
5173	.a9b0	50 0a		bvc $a9bc	                bvc notFoundError
5174	.a9b2	38		sec		                sec
5175	.a9b3					rtsA544:
5176	.a9b3	60		rts		                rts

5178						;-------------------------------------------------------------------------

5180	.a9b4					openFileForReading:
5181	.a9b4	a9 40		lda #$40	                lda #$40                     ;open for reading
5182	.a9b6	20 ce ff	jsr $ffce	                jsr OSFIND
5183	.a9b9	a8		tay		                tay
5184	.a9ba	d0 f7		bne $a9b3	                bne rtsA544
5185	.a9bc					notFoundError:
5186	.a9bc	20 ff ae	jsr $aeff	                jsr doFollowingError
5187	>a9bf	d6 4e 6f 74 20 66 6f 75		                .text $d6,"Not found",0
	>a9c7	6e 64 00

5189						;-------------------------------------------------------------------------

5191	.a9ca					LA55B:
5192	.a9ca	a5 c1		lda $c1		                lda $C1
5193	.a9cc	d0 05		bne $a9d3	                bne LA564
5194	.a9ce	a2 b1		ldx #$b1	                ldx #$B1
5195	.a9d0	20 85 ae	jsr $ae85	                jsr LAA4D
5196	.a9d3					LA564:
5197	.a9d3	a0 ff		ldy #$ff	                ldy #$FF
5198	.a9d5	8c df 03	sty $03df	                sty $03DF
5199	.a9d8	18		clc		                clc
5200	.a9d9	60		rts		                rts

5202	.a9da					LA56B:
5203	.a9da	f0 17		beq $a9f3	                beq LA584
5204	.a9dc	48		pha		                pha
5205	.a9dd	a9 07		lda #$07	                lda #fscFileHandleRange
5206	.a9df	20 9b f2	jsr $f29b	                jsr callFSCV
5207	.a9e2	68		pla		                pla
5208	.a9e3	18		clc		                clc
5209	.a9e4	08		php		                php
5210	.a9e5	78		sei		                sei
5211	.a9e6	85 fa		sta $fa		                sta $FA
5212	.a9e8	c4 fa		cpy $fa		                cpy $FA
5213	.a9ea	90 06		bcc $a9f2	                bcc LA583
5214	.a9ec	e4 fa		cpx $fa		                cpx $FA
5215	.a9ee	90 06		bcc $a9f6	                bcc LA587
5216	.a9f0	f0 04		beq $a9f6	                beq LA587
5217	.a9f2					LA583:
5218	.a9f2	28		plp		                plp
5219	.a9f3					LA584:
5220	.a9f3	68		pla		                pla
5221	.a9f4	68		pla		                pla
5222	.a9f5	60		rts		                rts

5224	.a9f6					LA587:
5225	.a9f6	28		plp		                plp
5226	.a9f7	a9 00		lda #$00	                lda #$00
5227	.a9f9	60		rts		                rts

5229	.a9fa					LA58B:
5230	.a9fa	ad 56 02	lda $0256	                lda execFileHandle
5231	.a9fd	20 da a9	jsr $a9da	                jsr LA56B
5232	.aa00					starEXEC:
5233	.aa00	08		php		                php
5234	.aa01	5a		phy		                phy
5235	.aa02	ac 56 02	ldy $0256	                ldy execFileHandle
5236	.aa05	8d 56 02	sta $0256	                sta execFileHandle
5237	.aa08	f0 03		beq $aa0d	                beq LA59E
5238	.aa0a	20 ce ff	jsr $ffce	                jsr OSFIND
5239	.aa0d					LA59E:
5240	.aa0d	4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
5241	.aa10	7a		ply		                ply
5242	.aa11	28		plp		                plp
5243	.aa12	f0 09		beq $aa1d	                beq LA5AE
5244	.aa14	0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
5245	.aa17	20 b4 a9	jsr $a9b4	                jsr openFileForReading
5246	.aa1a	8d 56 02	sta $0256	                sta execFileHandle
5247	.aa1d					LA5AE:
5248	.aa1d	60		rts		                rts

5250	.aa1e					LA5AF:
5251	.aa1e	a2 a6		ldx #$a6	                ldx #$A6
5252	.aa20	20 85 ae	jsr $ae85	                jsr LAA4D
5253	.aa23	20 e7 aa	jsr $aae7	                jsr LA678
5254	.aa26					LA5B7:
5255	.aa26	ad ca 03	lda $03ca	                lda $03CA
5256	.aa29	4a		lsr a		                lsr a
5257	.aa2a	90 03		bcc $aa2f	                bcc LA5C0
5258	.aa2c	4c ca a4	jmp $a4ca	                jmp L9FE3

5260	.aa2f					LA5C0:
5261	.aa2f	ad dd 03	lda $03dd	                lda $03DD
5262	.aa32	85 b4		sta $b4		                sta $B4
5263	.aa34	ad de 03	lda $03de	                lda $03DE
5264	.aa37	85 b5		sta $b5		                sta $B5
5265	.aa39	64 b0		stz $b0		                stz $B0
5266	.aa3b	a9 0a		lda #$0a	                lda #$0A
5267	.aa3d	85 b1		sta $b1		                sta $B1
5268	.aa3f	a9 ff		lda #$ff	                lda #$FF
5269	.aa41	85 b2		sta $b2		                sta $B2
5270	.aa43	85 b3		sta $b3		                sta $B3
5271	.aa45	20 1e ab	jsr $ab1e	                jsr LA6D2
5272	.aa48	20 e3 ac	jsr $ace3	                jsr LA8A1
5273	.aa4b	d0 25		bne $aa72	                bne LA603
5274	.aa4d	ad ff 0a	lda $0aff	                lda $0AFF
5275	.aa50	8d ec 02	sta $02ec	                sta lastCharacterOfCurrentlyResidentBlock
5276	.aa53	20 6d ae	jsr $ae6d	                jsr LAA35
5277	.aa56	8e dd 03	stx $03dd	                stx $03DD
5278	.aa59	8c de 03	sty $03de	                sty $03DE
5279	.aa5c	a2 02		ldx #$02	                ldx #$02
5280	.aa5e					LA5EF:
5281	.aa5e	bd c8 03	lda $03c8,x	                lda $03C8,x
5282	.aa61	9d e9 02	sta $02e9,x	                sta tapeInputCurrentBlockSize+0,x
5283	.aa64	ca		dex		                dex
5284	.aa65	10 f7		bpl $aa5e	                bpl LA5EF
5285	.aa67	2c eb 02	bit $02eb	                bit blockFlagOfCurrentlyResidentBlock
5286	.aa6a	10 03		bpl $aa6f	                bpl LA600
5287	.aa6c	20 3b a5	jsr $a53b	                jsr LA059
5288	.aa6f					LA600:
5289	.aa6f	4c fd ad	jmp $adfd	                jmp LA9C5

5291	.aa72					LA603:
5292	.aa72	20 75 a9	jsr $a975	                jsr LA506
5293	.aa75	80 af		bra $aa26	                bra LA5B7

5295	.aa77					LA608:
5296	.aa77	c9 2a		cmp #$2a	                cmp #'*'
5297	.aa79	f0 37		beq $aab2	                beq LA643
5298	.aa7b	c9 23		cmp #$23	                cmp #'#'
5299	.aa7d	d0 0f		bne $aa8e	                bne LA61F
5300	.aa7f	ee c6 03	inc $03c6	                inc $03C6
5301	.aa82	d0 03		bne $aa87	                bne LA618
5302	.aa84	ee c7 03	inc $03c7	                inc $03C7
5303	.aa87					LA618:
5304	.aa87	a2 ff		ldx #$ff	                ldx #$FF
5305	.aa89	2c 70 e3	bit $e370	                bit valueFF
5306	.aa8c	80 51		bra $aadf	                bra LA670

5308	.aa8e					LA61F:
5309	.aa8e	20 3d a6	jsr $a63d	                jsr LA177
5310	.aa91	20 ff ae	jsr $aeff	                jsr doFollowingError
5311	>aa94	d7				                .byte $D7
5312	>aa95	42 61 64 20 52 4f 4d		                .text "Bad ROM"
5313	>aa9c	00				                .byte 0

5315	.aa9d					LA62E:
5317	.aa9d	a0 ff		ldy #$ff	                ldy #$FF
5318	.aa9f	20 94 ae	jsr $ae94	                jsr LAA5C
5319	.aaa2	a9 01		lda #$01	                lda #$01
5320	.aaa4	85 c2		sta $c2		                sta $C2
5321	.aaa6	20 54 ae	jsr $ae54	                jsr LAA1C
5322	.aaa9					LA63A:
5323	.aaa9	20 c2 ac	jsr $acc2	                jsr LA880
5324	.aaac	a9 03		lda #$03	                lda #$03
5325	.aaae	c5 c2		cmp $c2		                cmp $C2
5326	.aab0	d0 f7		bne $aaa9	                bne LA63A
5328	.aab2					LA643:
5329	.aab2	20 7e ae	jsr $ae7e	                jsr LAA46
5330	.aab5					LA646:
5331	.aab5	20 03 ab	jsr $ab03	                jsr LA694
5332	.aab8	50 1a		bvc $aad4	                bvc LA665
5333	.aaba	99 b2 03	sta $03b2,y	                sta $03B2,y
5334	.aabd	f0 06		beq $aac5	                beq LA656
5335	.aabf	c8		iny		                iny
5336	.aac0	c0 0b		cpy #$0b	                cpy #$0B
5337	.aac2	d0 f1		bne $aab5	                bne LA646
5338	.aac4	88		dey		                dey
5339	.aac5					LA656:
5340	.aac5	a2 0c		ldx #$0c	                ldx #$0C
5341	.aac7					LA658:
5342	.aac7	20 03 ab	jsr $ab03	                jsr LA694
5343	.aaca	50 08		bvc $aad4	                bvc LA665
5344	.aacc	9d b2 03	sta $03b2,x	                sta $03B2,x
5345	.aacf	e8		inx		                inx
5346	.aad0	e0 1f		cpx #$1f	                cpx #$1F
5347	.aad2	d0 f3		bne $aac7	                bne LA658
5348	.aad4					LA665:
5349	.aad4	98		tya		                tya
5350	.aad5	aa		tax		                tax
5351	.aad6	9e b2 03	stz $03b2,x	                stz $03B2,x
5352	.aad9	a5 be		lda $be		                lda $BE
5353	.aadb	05 bf		ora $bf		                ora $BF
5354	.aadd	85 c1		sta $c1		                sta $C1
5355	.aadf					LA670:
5356	.aadf	20 7c ae	jsr $ae7c	                jsr LAA44
5357	.aae2	84 c2		sty $c2		                sty $C2
5358	.aae4	8a		txa		                txa
5362	.aae5	d0 4d		bne $ab34	                bne rtsAAC1
5364	.aae7					LA678:
5366	.aae7	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5367	.aaea	f0 b1		beq $aa9d	                beq LA62E
5369	.aaec					LA67D:
5370	.aaec	20 1d f5	jsr $f51d	                jsr LF710
5371	.aaef	c9 2b		cmp #$2b	                cmp #$2B
5372	.aaf1	d0 84		bne $aa77	                bne LA608
5373	.aaf3	a9 08		lda #$08	                lda #$08
5374	.aaf5	25 e2		and $e2		                and $E2
5375	.aaf7	f0 03		beq $aafc	                beq LA68D
5376	.aaf9	20 3f a5	jsr $a53f	                jsr LA05D
5377	.aafc					LA68D:
5378	.aafc	20 0e f5	jsr $f50e	                jsr LF701
5379	.aaff	90 eb		bcc $aaec	                bcc LA67D
5380	.ab01	b8		clv		                clv
5381	.ab02	60		rts		                rts

5383	.ab03					LA694:
5385	.ab03	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5386	.ab06	f0 0d		beq $ab15	                beq LA6A6
5388	.ab08	da		phx		                phx
5389	.ab09	5a		phy		                phy
5390	.ab0a	20 1d f5	jsr $f51d	                jsr LF710
5391	.ab0d	85 bd		sta $bd		                sta $BD
5392	.ab0f	a9 ff		lda #$ff	                lda #$FF
5393	.ab11	85 c0		sta $c0		                sta $C0
5394	.ab13	7a		ply		                ply
5395	.ab14	fa		plx		                plx
5396	.ab15					LA6A6:
5397	.ab15	20 ba ab	jsr $abba	                jsr LA778
5398	.ab18					LA6A9:
5424	.ab18					LA6CC:
5425	.ab18	60		rts		                rts

5428	.ab19					LA6CD:                                       ;AAA6 in MOS 5.00
5429	.ab19	20 b8 ab	jsr $abb8	                jsr LA776
5430	.ab1c	80 fa		bra $ab18	                bra LA6A9

5433	.ab1e					LA6D2:                                       ;AAAB in MOS 5.00
5434	.ab1e	a9 00		lda #$00	                lda #$00
5435	.ab20					LA6D4:
5436	.ab20	85 bd		sta $bd		                sta $BD
5437	.ab22	a2 00		ldx #$00	                ldx #$00
5438	.ab24	64 bc		stz $bc		                stz $BC
5439	.ab26	50 0a		bvc $ab32	                bvc LA6E6
5440	.ab28	ad c8 03	lda $03c8	                lda $03C8
5441	.ab2b	0d c9 03	ora $03c9	                ora $03C9
5442	.ab2e	f0 02		beq $ab32	                beq LA6E6
5443	.ab30	a2 04		ldx #$04	                ldx #$04
5444	.ab32					LA6E6:
5445	.ab32	86 c2		stx $c2		                stx $C2
5446	.ab34					rtsAAC1:
5447	.ab34	60		rts		                rts

5450	.ab35					LA6E9:                                       ;AAC2 in MOS 5.00
5451	.ab35	08		php		                php
5452	.ab36	a2 03		ldx #$03	                ldx #$03
5453	.ab38					LA6EC:
5454	.ab38	9e cb 03	stz $03cb,x	                stz $03CB,x
5455	.ab3b	ca		dex		                dex
5456	.ab3c	10 fa		bpl $ab38	                bpl LA6EC
5457	.ab3e	ad c6 03	lda $03c6	                lda $03C6
5458	.ab41	0d c7 03	ora $03c7	                ora $03C7
5459	.ab44	d0 05		bne $ab4b	                bne LA6FF
5460	.ab46	20 c6 ab	jsr $abc6	                jsr LA784
5461	.ab49	80 03		bra $ab4e	                bra LA702

5463	.ab4b					LA6FF:
5464	.ab4b	20 ca ab	jsr $abca	                jsr LA788
5465	.ab4e					LA702:
5466	.ab4e	a9 2a		lda #$2a	                lda #$2A
5467	.ab50	85 bd		sta $bd		                sta $BD
5468	.ab52	20 7c ae	jsr $ae7c	                jsr LAA44
5469	.ab55	20 4e ae	jsr $ae4e	                jsr LAA16
5470	.ab58	20 ba ab	jsr $abba	                jsr LA778
5471	.ab5b	88		dey		                dey
5472	.ab5c					LA710:
5473	.ab5c	c8		iny		                iny
5474	.ab5d	b9 d2 03	lda $03d2,y	                lda $03D2,y
5475	.ab60	99 b2 03	sta $03b2,y	                sta $03B2,y
5476	.ab63	20 19 ab	jsr $ab19	                jsr LA6CD
5477	.ab66	d0 f4		bne $ab5c	                bne LA710
5478	.ab68	a2 0c		ldx #$0c	                ldx #$0C
5479	.ab6a					LA71E:
5480	.ab6a	bd b2 03	lda $03b2,x	                lda $03B2,x
5481	.ab6d	20 19 ab	jsr $ab19	                jsr LA6CD
5482	.ab70	e8		inx		                inx
5483	.ab71	e0 1d		cpx #$1d	                cpx #$1D
5484	.ab73	d0 f5		bne $ab6a	                bne LA71E
5485	.ab75	20 b1 ab	jsr $abb1	                jsr LA76F
5486	.ab78	ad c8 03	lda $03c8	                lda $03C8
5487	.ab7b	0d c9 03	ora $03c9	                ora $03C9
5488	.ab7e	f0 11		beq $ab91	                beq LA74F
5489	.ab80	20 7e ae	jsr $ae7e	                jsr LAA46
5490	.ab83					LA737:
5498	.ab83	b1 b0		lda ($b0),y	                lda ($B0),y                  ; load from I/O RAM
5499	.ab85					LA743:
5500	.ab85	20 19 ab	jsr $ab19	                jsr LA6CD
5501	.ab88	c8		iny		                iny
5502	.ab89	cc c8 03	cpy $03c8	                cpy $03C8
5503	.ab8c	d0 f5		bne $ab83	                bne LA737
5504	.ab8e	20 b1 ab	jsr $abb1	                jsr LA76F
5505	.ab91					LA74F:
5506	.ab91	20 ba ab	jsr $abba	                jsr LA778
5507	.ab94	20 ba ab	jsr $abba	                jsr LA778
5508	.ab97	20 4a ae	jsr $ae4a	                jsr resetACIA
5509	.ab9a	a9 01		lda #$01	                lda #$01
5510	.ab9c	20 cc ab	jsr $abcc	                jsr LA78A
5511	.ab9f	28		plp		                plp
5512	.aba0	20 ed ab	jsr $abed	                jsr LA7AB
5513	.aba3	2c ca 03	bit $03ca	                bit $03CA
5514	.aba6	10 08		bpl $abb0	                bpl LA76E
5515	.aba8	08		php		                php
5516	.aba9	20 c6 ab	jsr $abc6	                jsr LA784
5517	.abac	20 38 a5	jsr $a538	                jsr LA056
5518	.abaf	28		plp		                plp
5519	.abb0					LA76E:
5520	.abb0	60		rts		                rts

5522	.abb1					LA76F:
5526	.abb1	a9 00		lda #$00	                lda #0
5528	.abb3	20 b8 ab	jsr $abb8	                jsr LA776
5532	.abb6	a9 00		lda #$00	                lda #0
5534	.abb8					LA776:
5535	.abb8	85 bd		sta $bd		                sta $BD

5538	.abba					LA778:
5539	.abba	20 c2 ac	jsr $acc2	                jsr LA880
5540	.abbd	24 c0		bit $c0		                bit $C0
5541	.abbf	10 f9		bpl $abba	                bpl LA778
5542	.abc1	64 c0		stz $c0		                stz $C0
5543	.abc3	a5 bd		lda $bd		                lda $BD
5544	.abc5	60		rts		                rts

5547	.abc6					LA784:
5548	.abc6	a9 32		lda #$32	                lda #$32
5549	.abc8	80 02		bra $abcc	                bra LA78A

5551	.abca					LA788:
5552	.abca	a5 c7		lda $c7		                lda $C7
5553	.abcc					LA78A:
5554	.abcc	a2 05		ldx #$05	                ldx #$05
5555	.abce					LA78C:
5556	.abce	8d 40 02	sta $0240	                sta cfsTimeoutCounter
5557	.abd1					LA78F:
5558	.abd1	20 c2 ac	jsr $acc2	                jsr LA880
5559	.abd4	2c 40 02	bit $0240	                bit cfsTimeoutCounter
5560	.abd7	10 f8		bpl $abd1	                bpl LA78F
5561	.abd9	ca		dex		                dex
5562	.abda	d0 f2		bne $abce	                bne LA78C
5563	.abdc	60		rts		                rts

5566	.abdd					LA79B:
5567	.abdd	ad c6 03	lda $03c6	                lda $03C6
5568	.abe0	0d c7 03	ora $03c7	                ora $03C7
5569	.abe3	f0 05		beq $abea	                beq LA7A8
5570	.abe5	2c df 03	bit $03df	                bit $03DF
5571	.abe8	10 03		bpl $abed	                bpl LA7AB
5572	.abea					LA7A8:
5573	.abea	20 3b a5	jsr $a53b	                jsr LA059
5574	.abed					LA7AB:
5575	.abed	a0 00		ldy #$00	                ldy #$00
5576	.abef	64 ba		stz $ba		                stz $BA
5577	.abf1	ad ca 03	lda $03ca	                lda $03CA
5578	.abf4	8d df 03	sta $03df	                sta $03DF
5579	.abf7	20 48 ef	jsr $ef48	                jsr LEF1B
5580	.abfa	f0 67		beq $ac63	                beq LA821
5581	.abfc	a9 0d		lda #$0d	                lda #$0D
5582	.abfe	20 ee ff	jsr $ffee	                jsr OSWRCH
5583	.ac01					LA7BF:
5584	.ac01	b9 b2 03	lda $03b2,y	                lda $03B2,y
5585	.ac04	f0 10		beq $ac16	                beq LA7D4
5586	.ac06	c9 20		cmp #$20	                cmp #$20
5587	.ac08	90 04		bcc $ac0e	                bcc LA7CC
5588	.ac0a	c9 7f		cmp #$7f	                cmp #$7F
5589	.ac0c	90 02		bcc $ac10	                bcc LA7CE
5590	.ac0e					LA7CC:
5591	.ac0e	a9 3f		lda #$3f	                lda #$3F
5592	.ac10					LA7CE:
5593	.ac10	20 ee ff	jsr $ffee	                jsr OSWRCH
5594	.ac13	c8		iny		                iny
5595	.ac14	d0 eb		bne $ac01	                bne LA7BF

5597	.ac16					LA7D4:
5599	.ac16	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5600	.ac19	f0 04		beq $ac1f	                beq LA7DD
5602	.ac1b	24 bb		bit $bb		                bit $BB
5603	.ac1d	50 44		bvc $ac63	                bvc LA821
5604	.ac1f					LA7DD:
5605	.ac1f	20 f3 a3	jsr $a3f3	                jsr printSpace
5606	.ac22	c8		iny		                iny
5607	.ac23	c0 0b		cpy #$0b	                cpy #$0B
5608	.ac25	90 ef		bcc $ac16	                bcc LA7D4
5609	.ac27	ad c6 03	lda $03c6	                lda $03C6
5610	.ac2a	aa		tax		                tax
5611	.ac2b	20 ac ac	jsr $acac	                jsr printHexByte
5612	.ac2e	2c ca 03	bit $03ca	                bit $03CA
5613	.ac31	10 30		bpl $ac63	                bpl LA821
5614	.ac33	8a		txa		                txa
5615	.ac34	18		clc		                clc
5616	.ac35	6d c9 03	adc $03c9	                adc $03C9
5617	.ac38	20 a7 ac	jsr $aca7	                jsr printSpaceThenPrintHexByte
5618	.ac3b					LA7F9:
5619	.ac3b	ad c8 03	lda $03c8	                lda $03C8
5620	.ac3e	20 ac ac	jsr $acac	                jsr printHexByte
5621	.ac41	24 bb		bit $bb		                bit $BB
5622	.ac43	50 1e		bvc $ac63	                bvc LA821
5623	.ac45	a2 04		ldx #$04	                ldx #$04
5624	.ac47					LA805:
5625	.ac47	20 f3 a3	jsr $a3f3	                jsr printSpace
5626	.ac4a	ca		dex		                dex
5627	.ac4b	d0 fa		bne $ac47	                bne LA805
5628	.ac4d	a2 0f		ldx #$0f	                ldx #$0F
5629	.ac4f	20 57 ac	jsr $ac57	                jsr LA815
5630	.ac52	20 f3 a3	jsr $a3f3	                jsr printSpace
5631	.ac55	a2 13		ldx #$13	                ldx #$13
5632	.ac57					LA815:
5633	.ac57	a0 04		ldy #$04	                ldy #$04
5634	.ac59					LA817:
5635	.ac59	bd b2 03	lda $03b2,x	                lda $03B2,x
5636	.ac5c	20 ac ac	jsr $acac	                jsr printHexByte
5637	.ac5f	ca		dex		                dex
5638	.ac60	88		dey		                dey
5639	.ac61	d0 f6		bne $ac59	                bne LA817
5640	.ac63					LA821:
5641	.ac63	60		rts		                rts

5644	.ac64					LA822:
5645	.ac64	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5646	.ac67	f0 06		beq $ac6f	                beq LA82D
5647	.ac69	20 02 ae	jsr $ae02	                jsr LA9CA
5648	.ac6c	4c 60 fb	jmp $fb60	                jmp badCommandError

5650	.ac6f					LA82D:
5651	.ac6f	20 92 ae	jsr $ae92	                jsr LAA5A
5652	.ac72	20 d8 ae	jsr $aed8	                jsr LAAA0
5653	.ac75	20 48 ef	jsr $ef48	                jsr LEF1B
5654	.ac78	f0 e9		beq $ac63	                beq LA821
5655	.ac7a	20 65 ad	jsr $ad65	                jsr LA923
5656	>ac7d	52 45 43 4f 52 44 20 74		                .text "RECORD then RETURN"
	>ac85	68 65 6e 20 52 45 54 55 52 4e
5657	>ac8f	00				                .byte $00

5659	.ac90					LA84E:
5660	.ac90	20 c2 ac	jsr $acc2	                jsr LA880
5661	.ac93	20 e0 ff	jsr $ffe0	                jsr OSRDCH
5662	.ac96	c9 0d		cmp #$0d	                cmp #$0D
5663	.ac98	d0 f6		bne $ac90	                bne LA84E
5664	.ac9a	4c e7 ff	jmp $ffe7	                jmp OSNEWL

5667						;-------------------------------------------------------------------------

5673						;-------------------------------------------------------------------------

5676	.ac9d					LA85B:
5677	.ac9d	a2 fd		ldx #$fd	                ldx #$FD
5678	.ac9f					LA85D:
5679	.ac9f	f6 b4		inc $b4,x	                inc $B4,x
5680	.aca1	d0 03		bne $aca6	                bne LA864
5681	.aca3	e8		inx		                inx
5682	.aca4	d0 f9		bne $ac9f	                bne LA85D
5683	.aca6					LA864:
5684	.aca6	60		rts		                rts

5686						;-------------------------------------------------------------------------

5688	.aca7					printSpaceThenPrintHexByte:
5689	.aca7	48		pha		                pha
5690	.aca8	20 f3 a3	jsr $a3f3	                jsr printSpace
5691	.acab	68		pla		                pla
5692	.acac					printHexByte:
5693	.acac	48		pha		                pha
5697	.acad	4a		lsr a		                lsr a
5698	.acae	4a		lsr a		                lsr a
5699	.acaf	4a		lsr a		                lsr a
5700	.acb0	4a		lsr a		                lsr a
5702	.acb1	20 b5 ac	jsr $acb5	                jsr printHexDigit
5703	.acb4	68		pla		                pla
5704	.acb5					printHexDigit:
5705	.acb5	29 0f		and #$0f	                and #$0F
5706	.acb7	09 30		ora #$30	                ora #'0'                     ;+'0'
5707	.acb9	c9 3a		cmp #$3a	                cmp #'9'+1
5708	.acbb	90 02		bcc $acbf	                bcc LA87D                    ;taken if <='9'
5709	.acbd	69 06		adc #$06	                adc #'A'-('9'+1)-1           ;adjust - -1 because C set
5710	.acbf					LA87D:
5711	.acbf	4c ee ff	jmp $ffee	                jmp OSWRCH

5713						;-------------------------------------------------------------------------

5715	.acc2					LA880:
5716	.acc2	08		php		                php
5717	.acc3	24 eb		bit $eb		                bit $EB
5718	.acc5	30 04		bmi $accb	                bmi LA889
5719	.acc7	24 ff		bit $ff		                bit $FF
5720	.acc9	30 02		bmi $accd	                bmi LA88B
5721	.accb					LA889:
5722	.accb	28		plp		                plp
5723	.accc	60		rts		                rts

5725	.accd					LA88B:
5726	.accd	20 3d a6	jsr $a63d	                jsr LA177
5727	.acd0	20 fd ad	jsr $adfd	                jsr LA9BB
5728	.acd3					escapeError:
5729	.acd3	a9 7e		lda #$7e	                lda #$7E
5730	.acd5	20 f4 ff	jsr $fff4	                jsr OSBYTE
5731	.acd8	20 ff ae	jsr $aeff	                jsr doFollowingError
5732	>acdb	11				                .byte $11
5733	>acdc	45 73 63 61 70 65		                .text "Escape"
5734	>ace2	00				                .byte $00

5736						;-------------------------------------------------------------------------

5738	.ace3					LA8A1:
5739	.ace3	98		tya		                tya
5740	.ace4	f0 0d		beq $acf3	                beq LA8B1
5741	.ace6	20 65 ad	jsr $ad65	                jsr LA923
5742	>ace9	0d				                .byte $0D
5743	>acea	4c 6f 61 64 69 6e 67		                .text "Loading"
5744	>acf1	0d				                .byte $0D
5745	>acf2	00				                .byte $00
5746	.acf3					LA8B1:
5747	.acf3	64 ba		stz $ba		                stz $BA                      ; :
5748	.acf5	a2 ff		ldx #$ff	                ldx #$FF
5749	.acf7	a5 c1		lda $c1		                lda $C1
5750	.acf9	d0 0b		bne $ad06	                bne LA8C4
5751	.acfb	20 9e ad	jsr $ad9e	                jsr LA95C
5752	.acfe	08		php		                php
5753	.acff	a2 ff		ldx #$ff	                ldx #$FF
5754	.ad01	a0 23		ldy #$23	                ldy #<fileError
5755						                .cwarn (>fileError)!=(>dataError),"must be on same page"
5756	.ad03	28		plp		                plp
5757	.ad04	d0 16		bne $ad1c	                bne LA8DA
5758	.ad06					LA8C4:
5759	.ad06	a0 16		ldy #$16	                ldy #<dataError
5760	.ad08	a5 c1		lda $c1		                lda $C1
5761	.ad0a	d0 10		bne $ad1c	                bne LA8DA
5762	.ad0c	ad c6 03	lda $03c6	                lda $03C6
5763	.ad0f	c5 b4		cmp $b4		                cmp $B4
5764	.ad11	d0 07		bne $ad1a	                bne LA8D8
5765	.ad13	ad c7 03	lda $03c7	                lda $03C7
5766	.ad16	c5 b5		cmp $b5		                cmp $B5
5767	.ad18	f0 0b		beq $ad25	                beq LA8E3
5768	.ad1a					LA8D8:
5769	.ad1a	a0 30		ldy #$30	                ldy #<blockError
5770						                .cwarn (>blockError)!=(>dataError),"must be on same page"
5771	.ad1c					LA8DA:
5772	.ad1c	5a		phy		                phy
5773	.ad1d	da		phx		                phx
5774	.ad1e	20 ea ab	jsr $abea	                jsr LA7A8
5775	.ad21	fa		plx		                plx
5776	.ad22	7a		ply		                ply
5777	.ad23	80 10		bra $ad35	                bra LA8F3

5779	.ad25					LA8E3:
5780	.ad25	da		phx		                phx
5781	.ad26	20 dd ab	jsr $abdd	                jsr LA79B
5782	.ad29	20 e2 ad	jsr $ade2	                jsr LA9A0
5783	.ad2c	fa		plx		                plx
5784	.ad2d	a5 be		lda $be		                lda $BE
5785	.ad2f	05 bf		ora $bf		                ora $BF
5786	.ad31	f0 79		beq $adac	                beq LA96A
5787	.ad33	a0 16		ldy #$16	                ldy #<dataError
5788	.ad35					LA8F3:
5789	.ad35	a9 af		lda #$af	                lda #>dataError
5790	.ad37	c6 ba		dec $ba		                dec $BA
5791	.ad39	48		pha		                pha
5792	.ad3a	24 eb		bit $eb		                bit $EB
5793	.ad3c	30 0d		bmi $ad4b	                bmi LA909
5794	.ad3e	8a		txa		                txa
5796	.ad3f	2d 47 02	and $0247	                and cfsRFSFSSwitch
5797	.ad42					LA900:
5799	.ad42	d0 07		bne $ad4b	                bne LA909
5800	.ad44	8a		txa		                txa
5801	.ad45	29 11		and #$11	                and #$11
5802	.ad47	25 bb		and $bb		                and $BB
5803	.ad49	f0 0f		beq $ad5a	                beq LA918
5804	.ad4b					LA909:
5805	.ad4b	68		pla		                pla
5806	.ad4c	85 b9		sta $b9		                sta $B9
5807	.ad4e	84 b8		sty $b8		                sty $B8
5808	.ad50	20 fa a9	jsr $a9fa	                jsr LA58B
5809	.ad53	46 eb		lsr $eb		                lsr $EB
5810	.ad55	20 f3 ad	jsr $adf3	                jsr LA9B1
5811	.ad58	80 3d		bra $ad97	                bra LA955

5813	.ad5a					LA918:
5814	.ad5a	98		tya		                tya
5815	.ad5b	18		clc		                clc
5816	.ad5c	69 03		adc #$03	                adc #$03
5817	.ad5e	a8		tay		                tay
5818	.ad5f	90 03		bcc $ad64	                bcc LA922
5819	.ad61	68		pla		                pla
5820	.ad62	1a		inc a		                inc a
5821	.ad63	48		pha		                pha
5822	.ad64					LA922:
5823	.ad64	5a		phy		                phy
5824	.ad65					LA923:
5825	.ad65	20 48 ef	jsr $ef48	                jsr LEF1B
5826	.ad68	a8		tay		                tay

5828						;-------------------------------------------------------------------------
5829						;
5830						; Print 0-terminated message using address from stack.
5831						;
5832						; entry:
5833						;
5834						; S=[StrL; StrH] - where Str = (address of string)-1
5835						; Y = 0 to print message; otherwise, don't print message
5836						;
5837	.ad69					printFollowingMessage:                       ;
5838	.ad69	68		pla		                pla
5839	.ad6a	85 b8		sta $b8		                sta printMessageAddress+0
5840	.ad6c	68		pla		                pla
5841	.ad6d	85 b9		sta $b9		                sta printMessageAddress+1
5842	.ad6f	5a		phy		                phy                          ;save initial Y
5843	.ad70	98		tya		                tya                          ;Z=1 if Y=0
5844	.ad71	08		php		                php                          ;save Y=0 state
5845	.ad72					fetchNextChar:
5846	.ad72	e6 b8		inc $b8		                inc printMessageAddress+0
5847	.ad74	d0 02		bne $ad78	                bne +
5848	.ad76	e6 b9		inc $b9		                inc printMessageAddress+1
5849	.ad78					+
5850	.ad78	b2 b8		lda ($b8)	                lda (printMessageAddress)   ;fetch next char to print
5851	.ad7a	f0 13		beq $ad8f	                beq printingFinished        ;branch taken if last char
5852	.ad7c	28		plp		                plp                         ;restore Y=0 state
5853	.ad7d	08		php		                php                         ;save Y=0 state
5854	.ad7e	f0 f2		beq $ad72	                beq fetchNextChar ;branch taken if Y=0 - i.e., skip the
5855						                                  ;printing

5857						                ; printMessageAddress is in the $b0-$bf area, so it
5858						                ; needs saving in case there's a *SPOOL going on.
5859	.ad80	a4 b8		ldy $b8		                ldy printMessageAddress+0
5860	.ad82	5a		phy		                phy
5861	.ad83	a4 b9		ldy $b9		                ldy printMessageAddress+1
5862	.ad85	20 e3 ff	jsr $ffe3	                jsr OSASCI
5863	.ad88	84 b9		sty $b9		                sty printMessageAddress+1
5864	.ad8a	7a		ply		                ply
5865	.ad8b	84 b8		sty $b8		                sty printMessageAddress+0

5867	.ad8d	80 e3		bra $ad72	                bra fetchNextChar

5869	.ad8f					printingFinished:
5870	.ad8f	28		plp		                plp                          ;discard Y=0 state
5871	.ad90	e6 b8		inc $b8		                inc printMessageAddress+0
5872	.ad92	d0 02		bne $ad96	                bne +
5873	.ad94	e6 b9		inc $b9		                inc printMessageAddress+1
5874	.ad96					+
5875	.ad96	7a		ply		                ply                          ;restore initial Y
5876	.ad97					LA955:
5877	.ad97	6c b8 00	jmp ($00b8)	                jmp (printMessageAddress)

5879	.ad9a					alwaysPrintFollowingMessage:
5880	.ad9a	a0 01		ldy #$01	                ldy #$01
5881	.ad9c	80 cb		bra $ad69	                bra printFollowingMessage

5883						;-------------------------------------------------------------------------

5885	.ad9e					LA95C:
5886	.ad9e	a2 ff		ldx #$ff	                ldx #$FF
5887	.ada0					LA95E:
5888	.ada0	e8		inx		                inx
5889	.ada1	bd d2 03	lda $03d2,x	                lda $03D2,x
5890	.ada4	d0 07		bne $adad	                bne LA96B
5891	.ada6	8a		txa		                txa
5892	.ada7	f0 03		beq $adac	                beq LA96A
5893	.ada9	bd b2 03	lda $03b2,x	                lda $03B2,x
5894	.adac					LA96A:
5895	.adac	60		rts		                rts

5897	.adad					LA96B:
5898	.adad	20 9c eb	jsr $eb9c	                jsr isLetter
5899	.adb0	5d b2 03	eor $03b2,x	                eor $03B2,x
5900	.adb3	b0 02		bcs $adb7	                bcs LA975
5901	.adb5	29 df		and #$df	                and #$DF
5902	.adb7					LA975:
5903	.adb7	f0 e7		beq $ada0	                beq LA95E
5904	.adb9					LA977:
5905	.adb9	60		rts		                rts

5907	.adba					LA978:
5908	.adba	a5 ba		lda $ba		                lda $BA
5909	.adbc	f0 21		beq $addf	                beq LA99D
5910	.adbe	8a		txa		                txa
5911	.adbf	f0 1e		beq $addf	                beq LA99D
5912	.adc1	a9 22		lda #$22	                lda #$22
5913	.adc3	24 bb		bit $bb		                bit $BB
5914	.adc5	f0 18		beq $addf	                beq LA99D
5916	.adc7	20 4a ae	jsr $ae4a	                jsr resetACIA
5918	.adca	a8		tay		                tay
5919	.adcb	20 69 ad	jsr $ad69	                jsr printFollowingMessage
5920	>adce	0d				                .byte $0D
5921	>adcf	07				                .byte $07
5922	>add0	52 65 77 69 6e 64 20 74		                .text "Rewind tape"
	>add8	61 70 65
5923	>addb	0d				                .byte $0D
5924	>addc	0d				                .byte $0D
5925	>addd	00				                .byte $00
5926	.adde	60		rts		                rts

5928	.addf					LA99D:
5929	.addf	20 3f a5	jsr $a53f	                jsr LA05D
5930	.ade2					LA9A0:
5931	.ade2	a5 c2		lda $c2		                lda $C2
5932	.ade4	f0 d3		beq $adb9	                beq LA977
5933	.ade6	20 c2 ac	jsr $acc2	                jsr LA880
5935	.ade9	ad 47 02	lda $0247	                lda cfsRFSFSSwitch
5936	.adec	f0 f4		beq $ade2	                beq LA9A0
5941	.adee	20 d7 a8	jsr $a8d7	                jsr LA45D
5943	.adf1	80 ef		bra $ade2	                bra LA9A0

5945	.adf3					LA9B1:
5946	.adf3	20 48 ef	jsr $ef48	                jsr LEF1B
5947	.adf6	f0 05		beq $adfd	                beq LA9BB
5948	.adf8					LA9B6:
5949	.adf8	a9 07		lda #$07	                lda #$07
5950	.adfa	20 ee ff	jsr $ffee	                jsr OSWRCH
5951	.adfd					LA9BB:
5958	.adfd					LA9C5:
5960	.adfd	a2 00		ldx #$00	                ldx #$00
5961	.adff	20 99 ae	jsr $ae99	                jsr LAA61
5962	.ae02					LA9CA:
5963	.ae02	08		php		                php
5964	.ae03	78		sei		                sei
5965	.ae04	ad 82 02	lda $0282	                lda serialULARegister
5966	.ae07	8d 10 fe	sta $fe10	                sta SERPROC+0
5967	.ae0a	64 ea		stz $ea		                stz $EA
5968	.ae0c	80 01		bra $ae0f	                bra LA9D7

5970						;-------------------------------------------------------------------------

5972	.ae0e					resetACIAThenRewriteControlRegister:
5973	.ae0e	08		php		                php
5974	.ae0f					LA9D7:
5975	.ae0f	20 4a ae	jsr $ae4a	                jsr resetACIA
5976	.ae12	ad 50 02	lda $0250	                lda aciaControlRegister
5977	.ae15	4c 4c ea	jmp $ea4c	                jmp writeACIAControlRegisterAndCopy

5979						;-------------------------------------------------------------------------

5981	.ae18					LA9E0:
5982	.ae18	28		plp		                plp
5983	.ae19	24 ff		bit $ff		                bit $FF
5984	.ae1b	10 18		bpl $ae35	                bpl LA9FD
5986	.ae1d	60		rts		                rts

5988	.ae1e					LA9E6:
5989	.ae1e	a5 e3		lda $e3		                lda $E3
5990	.ae20	0a		asl a		                asl a
5991	.ae21	0a		asl a		                asl a
5992	.ae22	0a		asl a		                asl a
5993	.ae23	0a		asl a		                asl a
5994	.ae24	85 bb		sta $bb		                sta $BB
5998	.ae26	ad d1 03	lda $03d1	                lda $03D1
5999	.ae29	80 08		bra $ae33	                bra LA9FB

6002	.ae2b					LA9F3:
6003	.ae2b	a5 e3		lda $e3		                lda $E3
6004	.ae2d	29 f0		and #$f0	                and #$F0
6005	.ae2f	85 bb		sta $bb		                sta $BB
6007	.ae31	a9 06		lda #$06	                lda #$06
6008	.ae33					LA9FB:
6009	.ae33	85 c7		sta $c7		                sta $C7
6010	.ae35					LA9FD:
6011	.ae35	58		cli		                cli
6012	.ae36					LA9FE:
6013	.ae36	08		php		                php
6014	.ae37	78		sei		                sei
6015	.ae38					LAA00:
6016	.ae38	2c 4f 02	bit $024f	                bit rs423Busy
6017	.ae3b	10 db		bpl $ae18	                bpl LA9E0
6018	.ae3d	a5 ea		lda $ea		                lda $EA
6019	.ae3f	30 d7		bmi $ae18	                bmi LA9E0
6020	.ae41	a9 01		lda #$01	                lda #$01
6021	.ae43	85 ea		sta $ea		                sta $EA
6022	.ae45	20 4a ae	jsr $ae4a	                jsr resetACIA
6023	.ae48	28		plp		                plp
6025	.ae49	60		rts		                rts

6027						;-------------------------------------------------------------------------

6030	.ae4a					resetACIA:
6031	.ae4a	a9 03		lda #$03	                lda #ACIA.control.reset
6032	.ae4c	80 1b		bra $ae69	                bra writeACIAControlRegister

6035						;-------------------------------------------------------------------------

6037	.ae4e					LAA16:
6039	.ae4e	a9 30		lda #$30	                lda #$30
6040	.ae50	85 ca		sta $ca		                sta $CA
6041	.ae52	80 13		bra $ae67	                bra LAA2F
6043	.ae54					LAA1C:
6045	.ae54	a9 05		lda #$05	                lda #$05
6046	.ae56	8d 10 fe	sta $fe10	                sta SERPROC+0
6047	.ae59	a2 ff		ldx #$ff	                ldx #$FF
6048	.ae5b					LAA23:
6049	.ae5b	ca		dex		                dex
6050	.ae5c	d0 fd		bne $ae5b	                bne LAA23
6052	.ae5e	64 ca		stz $ca		                stz $CA
6054	.ae60	a9 d0		lda #$d0	                lda #$D0
6055	.ae62					LAA2A:
6056	.ae62	a0 85		ldy #$85	                ldy #$85
6057	.ae64	8c 10 fe	sty $fe10	                sty SERPROC+0
6058	.ae67					LAA2F:
6059	.ae67	05 c6		ora $c6		                ora $C6
6060	.ae69					writeACIAControlRegister:
6061	.ae69	8d 08 fe	sta $fe08	                sta ACIA+0
6063	.ae6c	60		rts		                rts

6065						;-------------------------------------------------------------------------

6067	.ae6d					LAA35:
6068	.ae6d	ae c6 03	ldx $03c6	                ldx $03C6
6069	.ae70	ac c7 03	ldy $03c7	                ldy $03C7
6070	.ae73	e8		inx		                inx
6071	.ae74	86 b4		stx $b4		                stx $B4
6072	.ae76	d0 01		bne $ae79	                bne LAA41
6073	.ae78	c8		iny		                iny
6074	.ae79					LAA41:
6075	.ae79	84 b5		sty $b5		                sty $B5
6076	.ae7b	60		rts		                rts

6078	.ae7c					LAA44:
6079	.ae7c	64 c0		stz $c0		                stz $C0
6080	.ae7e					LAA46:
6081	.ae7e	a0 00		ldy #$00	                ldy #$00
6082	.ae80	64 be		stz $be		                stz $BE
6083	.ae82	64 bf		stz $bf		                stz $BF
6084	.ae84	60		rts		                rts

6086	.ae85					LAA4D:
6087	.ae85	a0 ff		ldy #$ff	                ldy #$FF
6088	.ae87					LAA4F:
6089	.ae87	c8		iny		                iny
6090	.ae88	e8		inx		                inx
6091	.ae89	bd 00 03	lda $0300,x	                lda $0300,x
6092	.ae8c	99 d2 03	sta $03d2,y	                sta $03D2,y
6093	.ae8f	d0 f6		bne $ae87	                bne LAA4F
6094	.ae91	60		rts		                rts

6097	.ae92					LAA5A:
6098	.ae92	a0 00		ldy #$00	                ldy #$00
6099	.ae94					LAA5C:
6100	.ae94	58		cli		                cli
6101	.ae95	a2 01		ldx #$01	                ldx #$01
6102	.ae97	84 c3		sty $c3		                sty $C3
6103	.ae99					LAA61:
6104	.ae99	a9 89		lda #$89	                lda #$89
6105	.ae9b	a4 c3		ldy $c3		                ldy $C3
6106	.ae9d	4c f4 ff	jmp $fff4	                jmp OSBYTE

6109						; Check if TAPE/ROM channel is open
6110						; ---------------------------------
6111						; Y=handle to check, A=status mask to use
6112	.aea0					LAA68:
6113	.aea0	5a		phy		                phy
6114	.aea1	20 c5 ae	jsr $aec5	                jsr LAA8D
6115	.aea4	7a		ply		                ply
6119	.aea5	b0 30		bcs $aed7	                bcs rtsAA9F
6121	.aea7	cc 57 02	cpy $0257	                cpy spoolFileHandle                    ; Not SPOOL handle
6122	.aeaa	d0 05		bne $aeb1	                bne LAA79
6123	.aeac	9c 57 02	stz $0257	                stz spoolFileHandle                    ; Clear the SPOOL handle
6124	.aeaf	80 08		bra $aeb9	                bra LAA81
6125	.aeb1					LAA79:
6126	.aeb1	cc 56 02	cpy $0256	                cpy execFileHandle                    ; Not EXEC handle
6127	.aeb4	d0 03		bne $aeb9	                bne LAA81
6128	.aeb6	9c 56 02	stz $0256	                stz execFileHandle                    ; Clear the EXEC handle
6129	.aeb9					LAA81:
6130	.aeb9	20 ff ae	jsr $aeff	                jsr doFollowingError                    ; Generate error
6131	>aebc	de				                .byte $DE
6132	>aebd	43 68 61 6e 6e 65 6c		                .text "Channel"
6133	.aec4	00		brk #		                brk

6135	.aec5					LAA8D:
6136	.aec5	48		pha		                pha                          ; Toggle channel with CFS/RFS switch
6137	.aec6	98		tya		                tya
6141	.aec7	4d 47 02	eor $0247	                eor cfsRFSFSSwitch
6143	.aeca	a8		tay		                tay                          ; If CFS=unchanged, if RFS 1/2/3->3/0/1
6144	.aecb	68		pla		                pla
6145	.aecc	25 e2		and $e2		                and $E2                      ; Mask with open channels bitmask
6146	.aece	4a		lsr a		                lsr a                        ; Move 'input open if tested' into Carry
6147	.aecf	88		dey		                dey                          ; Exit if testing CFS#1 or RFS#3
6148	.aed0	f0 05		beq $aed7	                beq rtsAA9F
6149	.aed2	4a		lsr a		                lsr a                        ; Move 'output open if tested' into Carry
6150	.aed3	88		dey		                dey                          ; Exit if testing CFS#2
6151	.aed4	f0 01		beq $aed7	                beq rtsAA9F
6152	.aed6	18		clc		                clc                          ; Otherwise, Carry=Not Open
6153	.aed7					rtsAA9F:
6154	.aed7	60		rts		                rts

6157	.aed8					LAAA0:
6158	.aed8	a9 10		lda #$10	                lda #$10
6159	.aeda	80 86		bra $ae62	                bra LAA2A

6192	.aedc					LAACA:
6193	.aedc	a0 05		ldy #$05	                ldy #$05
6194	.aede					LAACC:
6195	.aede	b1 cc		lda ($cc),y	                lda ($CC),y
6196	.aee0	d0 07		bne $aee9	                bne LAAD7
6197	.aee2	c8		iny		                iny
6198	.aee3	c0 08		cpy #$08	                cpy #$08
6199	.aee5	90 f7		bcc $aede	                bcc LAACC
6200	.aee7					LAAD5:
6201	.aee7	b1 cc		lda ($cc),y	                lda ($CC),y
6202	.aee9					LAAD7:
6203	.aee9	3a		dec a		                dec a
6204	.aeea	91 cc		sta ($cc),y	                sta ($CC),y
6205	.aeec	88		dey		                dey
6206	.aeed	c0 05		cpy #$05	                cpy #$05
6207	.aeef	b0 f6		bcs $aee7	                bcs LAAD5
6208	.aef1	60		rts		                rts

6210	.aef2					LAAE0:
6211	.aef2	a0 08		ldy #$08	                ldy #$08
6212	.aef4	a9 00		lda #$00	                lda #$00
6213	.aef6					LAAE4:
6214	.aef6	11 cc		ora ($cc),y	                ora ($CC),y
6215	.aef8	88		dey		                dey
6216	.aef9	c0 05		cpy #$05	                cpy #$05
6217	.aefb	b0 f9		bcs $aef6	                bcs LAAE4
6218	.aefd	aa		tax		                tax
6219	.aefe	60		rts		                rts

6221	.aeff					doFollowingError:
6222	.aeff	78		sei		                sei
6223	.af00	68		pla		                pla
6224	.af01	85 fa		sta $fa		                sta SEIWKA+0
6225	.af03	68		pla		                pla
6226	.af04	85 fb		sta $fb		                sta SEIWKA+1
6227	.af06	9c 00 01	stz $0100	                stz $0100
6228	.af09	a0 00		ldy #$00	                ldy #$00
6229	.af0b					-
6230	.af0b	c8		iny		                iny
6231	.af0c	b1 fa		lda ($fa),y	                lda (SEIWKA),y
6232	.af0e	99 00 01	sta $0100,y	                sta $0100,y
6233	.af11	d0 f8		bne $af0b	                bne -
6234	.af13	4c 00 01	jmp $0100	                jmp $0100

6238						                .include "cfs_errors.s65"

:13	;******  Processing file: src/cfs_errors.s65

1						                ; The MOS code assumes all these error routines have
2						                ; the same MSB of their start address. (There's a
3						                ; .cerror that checks for this.) They all just fit
4						                ; into 32 bytes, so 32-byte alignment will do the
5						                ; trick.
6						                ;
7						                ; (The alignment directive doesn't take effect in any
8						                ; of the default MOS builds. It springs into action to
9						                ; accommodate modifications to other parts of the
10						                ; code.)

15	.af16					dataError:
16	.af16	20 ff ae	jsr $aeff	                jsr doFollowingError
17	>af19	d8 0d 44 61 74 61 3f 00		                .text $d8,13,"Data?",0
18	.af21	80 19		bra $af3c	                bra LAB2A

20	.af23					fileError:
21	.af23	20 ff ae	jsr $aeff	                jsr doFollowingError
22	>af26	db 0d 46 69 6c 65 3f 00		                .text $db,13,"File?",0
23	.af2e	80 0c		bra $af3c	                bra LAB2A

25	.af30					blockError:
26	.af30	20 ff ae	jsr $aeff	                jsr doFollowingError
27	>af33	da 0d 42 6c 6f 63 6b 3f		                .text $da,13,"Block?",0
	>af3b	00
28	.af3c					LAB2A:
29	.af3c	4c ba ad	jmp $adba	                jmp LA978

:5	;******  Return to file: src/terminal.s65

7042						                .include "ext.s65"

:14	;******  Processing file: src/ext.s65

1						; -*- comment-column:45; -*-

3	.af3f					plotEllipseOutline:
4						                ; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP1
5	.af3f	20 8a b0	jsr $b08a	                jsr     ellipseInitialisation
9	.af42	4c 48 af	jmp $af48	                jmp startEllipseOutline

12	.af45					ellipseOutlineLoop:
13	.af45	20 44 b1	jsr $b144	                jsr     updateEllipseIncrementally

15	.af48					startEllipseOutline:
16	.af48	a2 34		ldx #$34	                ldx     #VDUVariables.ew.pointC
17	.af4a	a0 3c		ldy #$3c	                ldy     #VDUVariables.ew.pointA
18	.af4c	20 cc d5	jsr $d5cc	                jsr     sortVDUVariableWords
20	.af4f	a2 38		ldx #$38	                ldx     #VDUVariables.ew.leftPoint
25	.af51	ad 39 03	lda $0339	                lda vduv.ew.leftPoint+1
27	.af54	8d 43 03	sta $0343	                sta     vduv.ew.currentOffsetX+1
32	.af57	ae 38 03	ldx $0338	                ldx vduv.ew.leftPoint+0

35	.af5a					ellipseOutlineContinueRowLoop:
36	.af5a	8e 42 03	stx $0342	                stx     vduv.ew.currentOffsetX+0
37	.af5d	20 7b b2	jsr $b27b	                jsr     outlineEllipsePlotOnePointAndReflection
38	.af60	e8		inx		                inx
39	.af61	d0 03		bne $af66	                bne     +
40	.af63	ee 43 03	inc $0343	                inc     vduv.ew.currentOffsetX+1
41	.af66					+
42	.af66	8a		txa		                txa
43	.af67	d9 00 03	cmp $0300,y	                cmp     vduv+0,y
44	.af6a	ad 43 03	lda $0343	                lda     vduv.ew.currentOffsetX+1
45	.af6d	f9 01 03	sbc $0301,y	                sbc     vduv+1,y
46	.af70	30 e8		bmi $af5a	                bmi     ellipseOutlineContinueRowLoop

78	.af72	ac 43 03	ldy $0343	                ldy vduv.ew.currentOffsetX+1
79	.af75	8a		txa		                txa
80	.af76	d0 01		bne $af79	                bne +
81	.af78	88		dey		                dey
82	.af79					+
83	.af79	ca		dex		                dex
84	.af7a	8e 34 03	stx $0334	                stx vduv.ew.pointC+0
85	.af7d	8c 35 03	sty $0335	                sty vduv.ew.pointC+1
86	.af80	8a		txa		                txa
87	.af81	cd 3a 03	cmp $033a	                cmp vduv.ew.rightPoint+0
88	.af84	98		tya		                tya
89	.af85	ed 3b 03	sbc $033b	                sbc vduv.ew.rightPoint+1
90	.af88	10 30		bpl $afba	                bpl LAF47
91	.af8a	a2 36		ldx #$36	                ldx #VDUVariables.ew.pointD
92	.af8c	a0 3e		ldy #$3e	                ldy #VDUVariables.ew.pointB
93	.af8e	20 cc d5	jsr $d5cc	                jsr sortVDUVariableWords
94	.af91	a0 34		ldy #$34	                ldy #VDUVariables.ew.pointC
95	.af93	20 cc d5	jsr $d5cc	                jsr sortVDUVariableWords
96	.af96	ad 3b 03	lda $033b	                lda vduv.ew.rightPoint+1
97	.af99	8d 43 03	sta $0343	                sta vduv.ew.currentOffsetX+1
98	.af9c	ad 3a 03	lda $033a	                lda vduv.ew.rightPoint+0
99	.af9f	aa		tax		                tax
100	.afa0					LAF2D:
101	.afa0	8e 42 03	stx $0342	                stx vduv.ew.currentOffsetX+0
102	.afa3					LAF30:
103	.afa3	20 7b b2	jsr $b27b	                jsr outlineEllipsePlotOnePointAndReflection
104	.afa6	8a		txa		                txa
105	.afa7	d0 03		bne $afac	                bne +
106	.afa9	ce 43 03	dec $0343	                dec vduv.ew.currentOffsetX+1
107	.afac					+
108	.afac	ca		dex		                dex
109	.afad	18		clc		                clc
110	.afae	8a		txa		                txa
111	.afaf	f9 00 03	sbc $0300,y	                sbc vduv+0,y
112	.afb2	ad 43 03	lda $0343	                lda vduv.ew.currentOffsetX+1
113	.afb5	f9 01 03	sbc $0301,y	                sbc vduv+1,y
114	.afb8	10 e6		bpl $afa0	                bpl LAF2D

116	.afba					LAF47:
117	.afba	ad 2f 03	lda $032f	                lda vduv.ew.halfHeightCounter+1 ; TODO can merge with
118						                                                ; code above...
119						                                                ; probably?
120	.afbd	10 86		bpl $af45	                bpl ellipseOutlineLoop
124	.afbf	4c d6 af	jmp $afd6	                jmp LBA7B

129						;-------------------------------------------------------------------------

131	.afc2					plotEllipseFilled:
132	.afc2	20 8a b0	jsr $b08a	                jsr     ellipseInitialisation
133	.afc5	80 03		bra $afca	                bra     startFilledEllipse

136	.afc7					filledEllipseLoop:
137	.afc7	20 44 b1	jsr $b144	                jsr     updateEllipseIncrementally

139	.afca					startFilledEllipse:
140	.afca	a2 3a		ldx #$3a	                ldx     #VDUVariables.ew.rightPoint
141	.afcc	a0 38		ldy #$38	                ldy     #VDUVariables.ew.leftPoint
142	.afce	20 e2 af	jsr $afe2	                jsr     fillEllipseOneRowAndReflection
143	.afd1	ad 2f 03	lda $032f	                lda     vduv.ew.halfHeightCounter+1
144	.afd4	10 f1		bpl $afc7	                bpl     filledEllipseLoop

146	.afd6					LBA7B:
147	.afd6	ee 4d 88	inc $884d	                inc     ellipseCountHeight+0
148	.afd9	d0 03		bne $afde	                bne     LBA83
149	.afdb	ee 4e 88	inc $884e	                inc     ellipseCountHeight+1

151	.afde					LBA83:
152	.afde	a2 3e		ldx #$3e	                ldx     #VDUVariables.ew.pointB
153	.afe0	a0 3c		ldy #$3c	                ldy     #VDUVariables.ew.pointA

155						; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP9
156	.afe2					fillEllipseOneRowAndReflection:
157	.afe2	da		phx		                phx
158	.afe3	5a		phy		                phy
159	.afe4	18		clc		                clc
160	.afe5	ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
161	.afe8	79 00 03	adc $0300,y	                adc     vduv+0,y
162	.afeb	8d 40 03	sta $0340	                sta     vduv.ew.pointE+0
163	.afee	ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
164	.aff1	79 01 03	adc $0301,y	                adc     vduv+1,y
165	.aff4	8d 41 03	sta $0341	                sta     vduv.ew.pointE+1
166	.aff7	18		clc		                clc
167	.aff8	ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
168	.affb	7d 00 03	adc $0300,x	                adc     vduv+0,x
169	.affe	8d 44 03	sta $0344	                sta     vduv.ew.plotPointX+0
170	.b001	ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
171	.b004	7d 01 03	adc $0301,x	                adc     vduv+1,x
172	.b007	8d 45 03	sta $0345	                sta     vduv.ew.plotPointX+1
173	.b00a	18		clc		                clc
174	.b00b	ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
175	.b00e	6d 4d 88	adc $884d	                adc     ellipseCountHeight+0
176	.b011	a8		tay		                tay
177	.b012	ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
178	.b015	6d 4e 88	adc $884e	                adc     ellipseCountHeight+1
179	.b018	20 59 b0	jsr $b059	                jsr     LBAFE
180	.b01b	7a		ply		                ply
181	.b01c	fa		plx		                plx
182	.b01d	ad 4d 88	lda $884d	                lda     ellipseCountHeight+0
183	.b020	0d 4e 88	ora $884e	                ora     ellipseCountHeight+1
184	.b023	f0 47		beq $b06c	                beq     rtsBB11
185	.b025	38		sec		                sec
186	.b026	ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
187	.b029	fd 00 03	sbc $0300,x	                sbc     vduv+0,x
188	.b02c	8d 40 03	sta $0340	                sta     vduv.ew.pointE+0
189	.b02f	ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
190	.b032	fd 01 03	sbc $0301,x	                sbc     vduv+1,x
191	.b035	8d 41 03	sta $0341	                sta     vduv.ew.pointE+1
192	.b038	38		sec		                sec
193	.b039	ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
194	.b03c	f9 00 03	sbc $0300,y	                sbc     vduv+0,y
195	.b03f	8d 44 03	sta $0344	                sta     vduv.ew.pointF+0
196	.b042	ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
197	.b045	f9 01 03	sbc $0301,y	                sbc     vduv+1,y
198	.b048	8d 45 03	sta $0345	                sta     vduv.ew.pointF+1
199	.b04b	38		sec		                sec
200	.b04c	ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
201	.b04f	ed 4d 88	sbc $884d	                sbc     ellipseCountHeight+0
202	.b052	a8		tay		                tay
203	.b053	ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
204	.b056	ed 4e 88	sbc $884e	                sbc     ellipseCountHeight+1

206	.b059					LBAFE:
207	.b059	8c 46 03	sty $0346	                sty     vduv.ew.plotPointY+0
208	.b05c	8c 42 03	sty $0342	                sty     vduv.ew.currentOffsetX+0
209	.b05f	8d 47 03	sta $0347	                sta     vduv.ew.plotPointY+1
210	.b062	8d 43 03	sta $0343	                sta     vduv.ew.currentOffsetX+1
211	.b065	a2 44		ldx #$44	                ldx     #VDUVariables.ew.pointF
212	.b067	a0 40		ldy #$40	                ldy     #VDUVariables.ew.pointE
213	.b069	4c e8 da	jmp $dae8	                jmp     LDAE8

219	.b06c					rtsBB11:
220	.b06c	60		rts		                rts

225	.b06d					LBB12:
226	.b06d	68		pla		                pla
227	.b06e	68		pla		                pla
228	.b06f	9c 4d 88	stz $884d	                stz     ellipseCountHeight+0
229	.b072	9c 4e 88	stz $884e	                stz     ellipseCountHeight+1
230	.b075	a2 29		ldx #$29	                ldx     #VDUVariables.ew.aspectRatio+1
231	.b077	a0 40		ldy #$40	                ldy     #VDUVariables.ew.pointE
232	.b079	20 55 b3	jsr $b355	                jsr     negateVDUVariableXIntoY
233	.b07c	a2 29		ldx #$29	                ldx     #VDUVariables.ew.aspectRatio+1
234	.b07e	a0 44		ldy #$44	                ldy     #VDUVariables.ew.pointF
235	.b080	20 0c c9	jsr $c90c	                jsr     copyTwoBytesWithinVDUVariables
236	.b083	a2 44		ldx #$44	                ldx     #VDUVariables.ew.pointF
237	.b085	a0 40		ldy #$40	                ldy     #VDUVariables.ew.pointE
238	.b087	4c e2 af	jmp $afe2	                jmp     fillEllipseOneRowAndReflection

240	.b08a					ellipseInitialisation:
241						                ; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP5
242	.b08a	a0 24		ldy #$24	                ldy     #VDUVariables.graphicsCursorPixelsX
243	.b08c	a2 14		ldx #$14	                ldx     #VDUVariables.oldGraphicsCursorPixelsX
244	.b08e	a9 29		lda #$29	                lda     #VDUVariables.ew.aspectRatio+1
245	.b090	20 78 d6	jsr $d678	                jsr     LD678
246	.b093	9c 28 03	stz $0328	                stz     vduv.ew.aspectRatio+0
247	.b096	a0 22		ldy #$22	                ldy     #VDUVariables.queueEnd-2
248	.b098	a2 16		ldx #$16	                ldx     #VDUVariables.oldGraphicsCursorPixelsY
249	.b09a	a9 2e		lda #$2e	                lda     #VDUVariables.ew.halfHeightCounter
250	.b09c	20 78 d6	jsr $d678	                jsr     LD678
251	.b09f	ad 2e 03	lda $032e	                lda     vduv.ew.halfHeightCounter+0
252	.b0a2	0d 2f 03	ora $032f	                ora     vduv.ew.halfHeightCounter+1
253	.b0a5	f0 c6		beq $b06d	                beq     LBB12
254	.b0a7	2a		rol a		                rol     a
255	.b0a8	8d 41 88	sta $8841	                sta     L8841
256	.b0ab	a0 20		ldy #$20	                ldy     #VDUVariables.queueEnd-4
257	.b0ad	a2 14		ldx #$14	                ldx     #VDUVariables.oldGraphicsCursorPixelsX
258	.b0af	a9 2c		lda #$2c	                lda     #VDUVariables.ew.shear+1
259	.b0b1	20 78 d6	jsr $d678	                jsr     LD678
260	.b0b4	9c 2b 03	stz $032b	                stz     vduv.ew.shear+0
261	.b0b7	2a		rol a		                rol     a
262	.b0b8	4d 41 88	eor $8841	                eor     ellipseSignFlag
263	.b0bb	29 01		and #$01	                and     #1
264	.b0bd	8d 41 88	sta $8841	                sta     ellipseSignFlag
265	.b0c0	a2 28		ldx #$28	                ldx     #VDUVariables.ew.aspectRatio
266	.b0c2	a0 2e		ldy #$2e	                ldy     #VDUVariables.ew.halfHeightCounter
267	.b0c4	20 de b2	jsr $b2de	                jsr     divide24By16Bits
268	.b0c7	a2 2b		ldx #$2b	                ldx     #VDUVariables.ew.shear
269	.b0c9	a0 2e		ldy #$2e	                ldy     #VDUVariables.ew.halfHeightCounter
270	.b0cb	20 de b2	jsr $b2de	                jsr     divide24By16Bits
271	.b0ce	ad 41 88	lda $8841	                lda     L8841
272	.b0d1	f0 0e		beq $b0e1	                beq     LBB86
273	.b0d3	38		sec		                sec
274	.b0d4	a0 fd		ldy #$fd	                ldy     #$fd

276	.b0d6					LBB7B:
277	.b0d6	a9 00		lda #$00	                lda     #0
278	.b0d8	f9 2e 02	sbc $022e,y	                sbc     vduv.ew.shear-$fd,y
279	.b0db	99 2e 02	sta $022e,y	                sta     vduv.ew.shear-$fd,y
280	.b0de	c8		iny		                iny
281	.b0df	d0 f5		bne $b0d6	                bne     LBB7B

283	.b0e1					LBB86:
284	.b0e1	ad 2e 03	lda $032e	                lda     vduv.ew.halfHeightCounter+0
285	.b0e4	8d 3c 88	sta $883c	                sta     L883C
286	.b0e7	ad 2f 03	lda $032f	                lda     vduv.ew.halfHeightCounter+1
287	.b0ea	20 ce d4	jsr $d4ce	                jsr     LD4CE
288	.b0ed	a0 03		ldy #$03	                ldy     #3

290	.b0ef					LBB94:
291	.b0ef	b9 40 88	lda $8840,y	                lda     L8840,y
292	.b0f2	99 30 03	sta $0330,y	                sta     vduv.ew.halfHeightSquared+0,y
293	.b0f5	88		dey		                dey
294	.b0f6	10 f7		bpl $b0ef	                bpl     LBB94
295	.b0f8	a2 0a		ldx #$0a	                ldx     #$a

297	.b0fa					LBB9F:
298	.b0fa	9e 42 88	stz $8842,x	                stz     ellipseAccumulatedShear,x
299	.b0fd	ca		dex		                dex
300	.b0fe	10 fa		bpl $b0fa	                bpl     LBB9F
301	.b100	ee 45 88	inc $8845	                inc     ellipseCountOddNumbers+0
302	.b103	20 73 b1	jsr $b173	                jsr     updateEllipse
303	.b106	20 73 b1	jsr $b173	                jsr     updateEllipse
304	.b109	9c 4d 88	stz $884d	                stz     ellipseCountHeight+0
305	.b10c	9c 4e 88	stz $884e	                stz     ellipseCountHeight+1
306	.b10f	a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
307	.b111	a0 36		ldy #$36	                ldy     #VDUVariables.ew.pointD
308	.b113	20 55 b3	jsr $b355	                jsr     negateVDUVariableXIntoY
309	.b116	a2 3e		ldx #$3e	                ldx     #VDUVariables.ew.pointB
310	.b118	a0 34		ldy #$34	                ldy     #VDUVariables.ew.pointC
311	.b11a	20 55 b3	jsr $b355	                jsr     negateVDUVariableXIntoY
312	.b11d	a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
313	.b11f	a0 3a		ldy #$3a	                ldy     #VDUVariables.ew.rightPoint
314	.b121	20 d6 d5	jsr $d5d6	                jsr     compareVDUVariableWords
315	.b124	10 07		bpl $b12d	                bpl     LBBD2
316	.b126	20 0c c9	jsr $c90c	                jsr     copyTwoBytesWithinVDUVariables
317	.b129	a2 36		ldx #$36	                ldx     #VDUVariables.ew.pointD
318	.b12b	80 12		bra $b13f	                bra     LBBE4

321	.b12d					LBBD2:
322	.b12d	a2 38		ldx #$38	                ldx     #VDUVariables.ew.leftPoint
323	.b12f	a0 3e		ldy #$3e	                ldy     #VDUVariables.ew.pointB
324	.b131	20 d6 d5	jsr $d5d6	                jsr     compareVDUVariableWords
325	.b134	10 3c		bpl $b172	                bpl     rtsBC17
326	.b136	a2 34		ldx #$34	                ldx     #VDUVariables.ew.pointC
327	.b138	a0 3a		ldy #$3a	                ldy     #VDUVariables.ew.rightPoint
328	.b13a	20 0c c9	jsr $c90c	                jsr     copyTwoBytesWithinVDUVariables
329	.b13d	a2 3e		ldx #$3e	                ldx     #VDUVariables.ew.pointB

331	.b13f					LBBE4:
332	.b13f	a0 38		ldy #$38	                ldy     #VDUVariables.ew.leftPoint
333	.b141	4c 0c c9	jmp $c90c	                jmp     copyTwoBytesWithinVDUVariables

335						;-------------------------------------------------------------------------
336						;
337						; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP6
338						;

340	.b144					updateEllipseIncrementally:
341	.b144	20 73 b1	jsr $b173	                jsr     updateEllipse
342	.b147	a0 3a		ldy #$3a	                ldy     #VDUVariables.ew.rightPoint
343	.b149	a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
344	.b14b	20 d6 d5	jsr $d5d6	                jsr     compareVDUVariableWords
345	.b14e	10 0d		bpl $b15d	                bpl     LBC02
346	.b150	ad 3c 03	lda $033c	                lda     vduv.ew.pointA+0
347	.b153	8d 3a 03	sta $033a	                sta     vduv.ew.rightPoint+0
348	.b156	ad 3d 03	lda $033d	                lda     vduv.ew.pointA+1
349	.b159	8d 3b 03	sta $033b	                sta     vduv.ew.rightPoint+1
350	.b15c	60		rts		                rts

352	.b15d					LBC02:
353	.b15d	a2 38		ldx #$38	                ldx     #VDUVariables.ew.leftPoint
354	.b15f	a0 3e		ldy #$3e	                ldy     #VDUVariables.ew.pointB
355	.b161	20 d6 d5	jsr $d5d6	                jsr     compareVDUVariableWords
356	.b164	10 0c		bpl $b172	                bpl     rtsBC17
357	.b166	ad 3e 03	lda $033e	                lda     vduv.ew.pointB+0
358	.b169	8d 38 03	sta $0338	                sta     vduv.ew.leftPoint+0
359	.b16c	ad 3f 03	lda $033f	                lda     vduv.ew.pointB+1
360	.b16f	8d 39 03	sta $0339	                sta     vduv.ew.leftPoint+1

362	.b172					rtsBC17:
363	.b172	60		rts		                rts

365						;-------------------------------------------------------------------------
366						;
367						; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP7
368						;

370	.b173					updateEllipse:
371	.b173	a2 38		ldx #$38	                ldx     #VDUVariables.ew.leftPoint
372	.b175	a0 34		ldy #$34	                ldy     #VDUVariables.ew.pointC
373	.b177	20 1e c9	jsr $c91e	                jsr     copyFourBytesWithinVDUVariables
374	.b17a	a2 3c		ldx #$3c	                ldx     #VDUVariables.ew.pointA
375	.b17c	a0 38		ldy #$38	                ldy     #VDUVariables.ew.leftPoint
376	.b17e	20 1e c9	jsr $c91e	                jsr     copyFourBytesWithinVDUVariables

378	.b181	38		sec		                sec
379	.b182	ad 30 03	lda $0330	                lda     vduv.ew.halfHeightSquared+0
380	.b185	ed 49 88	sbc $8849	                sbc     ellipseCountSquares+0
381	.b188	8d 36 88	sta $8836	                sta     sqrtNumber+2
382	.b18b	ad 31 03	lda $0331	                lda     vduv.ew.halfHeightSquared+1
383	.b18e	ed 4a 88	sbc $884a	                sbc     ellipseCountSquares+1
384	.b191	8d 37 88	sta $8837	                sta     sqrtNumber+3
385	.b194	ad 32 03	lda $0332	                lda     vduv.ew.halfHeightSquared+2
386	.b197	ed 4b 88	sbc $884b	                sbc     ellipseCountSquares+2
387	.b19a	8d 38 88	sta $8838	                sta     sqrtNumber+4
388	.b19d	ad 33 03	lda $0333	                lda     vduv.ew.halfHeightSquared+3
389	.b1a0	ed 4c 88	sbc $884c	                sbc     ellipseCountSquares+3
390	.b1a3	8d 39 88	sta $8839	                sta     sqrtNumber+5
391	.b1a6	9c 35 88	stz $8835	                stz     sqrtNumber+1
392	.b1a9	9c 34 88	stz $8834	                stz     sqrtNumber+0
393	.b1ac	20 a6 b3	jsr $b3a6	                jsr     LBE4B

395	.b1af	ad 28 03	lda $0328	                lda     vduv.ew.aspectRatio+0
396	.b1b2	8d 34 88	sta $8834	                sta     multiplier+0
397	.b1b5	ad 29 03	lda $0329	                lda     vduv.ew.aspectRatio+1
398	.b1b8	8d 35 88	sta $8835	                sta     multiplier+1
399	.b1bb	ad 2a 03	lda $032a	                lda     vduv.ew.aspectRatio+2
400	.b1be	8d 36 88	sta $8836	                sta     multiplier+2
401	.b1c1	20 67 b3	jsr $b367	                jsr     multiply24x24

403	.b1c4	18		clc		                clc
404	.b1c5	ad 42 88	lda $8842	                lda     ellipseAccumulatedShear+0
405	.b1c8	6d 35 88	adc $8835	                adc     product+1
406	.b1cb	08		php		                php
407	.b1cc	ad 43 88	lda $8843	                lda     ellipseAccumulatedShear+1
408	.b1cf	6d 36 88	adc $8836	                adc     product+2
409	.b1d2	8d 3e 03	sta $033e	                sta     vduv.ew.pointB+0
410	.b1d5	ad 44 88	lda $8844	                lda     ellipseAccumulatedShear+2
411	.b1d8	6d 37 88	adc $8837	                adc     product+3
412	.b1db	8d 3f 03	sta $033f	                sta     vduv.ew.pointB+1
413	.b1de	28		plp		                plp
414	.b1df	10 08		bpl $b1e9	                bpl     +
415	.b1e1	ee 3e 03	inc $033e	                inc     vduv.ew.pointB+0
416	.b1e4	d0 03		bne $b1e9	                bne     +
417	.b1e6	ee 3f 03	inc $033f	                inc     vduv.ew.pointB+1
418	.b1e9					+
419	.b1e9	38		sec		                sec
420	.b1ea	ad 42 88	lda $8842	                lda     ellipseAccumulatedShear+0
421	.b1ed	ed 35 88	sbc $8835	                sbc     product+1
422	.b1f0	08		php		                php
423	.b1f1	ad 43 88	lda $8843	                lda     ellipseAccumulatedShear+1
424	.b1f4	ed 36 88	sbc $8836	                sbc     product+2
425	.b1f7	8d 3c 03	sta $033c	                sta     vduv.ew.pointA+0
426	.b1fa	ad 44 88	lda $8844	                lda     ellipseAccumulatedShear+2
427	.b1fd	ed 37 88	sbc $8837	                sbc     product+3
428	.b200	8d 3d 03	sta $033d	                sta     vduv.ew.pointA+1
429	.b203	28		plp		                plp
430	.b204	10 08		bpl $b20e	                bpl     +
431	.b206	ee 3c 03	inc $033c	                inc     vduv.ew.pointA+0
432	.b209	d0 03		bne $b20e	                bne     +
433	.b20b	ee 3d 03	inc $033d	                inc     vduv.ew.pointA+1
434	.b20e					+

436	.b20e	18		clc		                clc
437	.b20f	ad 45 88	lda $8845	                lda     ellipseCountOddNumbers+0
438	.b212	6d 49 88	adc $8849	                adc     ellipseCountSquares+0
439	.b215	8d 49 88	sta $8849	                sta     ellipseCountSquares+0
440	.b218	ad 46 88	lda $8846	                lda     ellipseCountOddNumbers+1
441	.b21b	6d 4a 88	adc $884a	                adc     ellipseCountSquares+1
442	.b21e	8d 4a 88	sta $884a	                sta     ellipseCountSquares+1
443	.b221	ad 47 88	lda $8847	                lda     ellipseCountOddNumbers+2
444	.b224	6d 4b 88	adc $884b	                adc     ellipseCountSquares+2
445	.b227	8d 4b 88	sta $884b	                sta     ellipseCountSquares+2
446	.b22a	ad 48 88	lda $8848	                lda     ellipseCountOddNumbers+3
447	.b22d	6d 4c 88	adc $884c	                adc     ellipseCountSquares+3
448	.b230	8d 4c 88	sta $884c	                sta     ellipseCountSquares+3
449	.b233	18		clc		                clc
450	.b234	a9 02		lda #$02	                lda     #2
451	.b236	6d 45 88	adc $8845	                adc     ellipseCountOddNumbers+0
452	.b239	8d 45 88	sta $8845	                sta     ellipseCountOddNumbers+0
453	.b23c	90 0d		bcc $b24b	                bcc     +
454	.b23e	ee 46 88	inc $8846	                inc     ellipseCountOddNumbers+1
455	.b241	d0 08		bne $b24b	                bne     +
456	.b243	ee 47 88	inc $8847	                inc     ellipseCountOddNumbers+2
457	.b246	d0 03		bne $b24b	                bne     +
458	.b248	ee 48 88	inc $8848	                inc     ellipseCountOddNumbers+3
459	.b24b					+
460	.b24b	18		clc		                clc
461	.b24c	ad 42 88	lda $8842	                lda     ellipseAccumulatedShear+0
462	.b24f	6d 2b 03	adc $032b	                adc     vduv.ew.shear+0
463	.b252	8d 42 88	sta $8842	                sta     ellipseAccumulatedShear+0
464	.b255	ad 43 88	lda $8843	                lda     ellipseAccumulatedShear+1
465	.b258	6d 2c 03	adc $032c	                adc     vduv.ew.shear+1
466	.b25b	8d 43 88	sta $8843	                sta     ellipseAccumulatedShear+1
467	.b25e	ad 44 88	lda $8844	                lda     ellipseAccumulatedShear+2
468	.b261	6d 2d 03	adc $032d	                adc     vduv.ew.shear+2
469	.b264	8d 44 88	sta $8844	                sta     ellipseAccumulatedShear+2
470	.b267	ee 4d 88	inc $884d	                inc     ellipseCountHeight+0
471	.b26a	d0 03		bne $b26f	                bne     +
472	.b26c	ee 4e 88	inc $884e	                inc     ellipseCountHeight+1
473	.b26f					+
474	.b26f	ad 2e 03	lda $032e	                lda     vduv.ew.halfHeightCounter+0
475	.b272	d0 03		bne $b277	                bne     +
476	.b274	ce 2f 03	dec $032f	                dec     vduv.ew.halfHeightCounter+1
477	.b277					+
478	.b277	ce 2e 03	dec $032e	                dec     vduv.ew.halfHeightCounter+0
479	.b27a	60		rts		                rts

481						;-------------------------------------------------------------------------
482						;
483						; https://tobylobster.github.io/GXR-pages/gxr/S-s23.html#SP8
484						;
485	.b27b					outlineEllipsePlotOnePointAndReflection: .block
486	.b27b	da		phx		                phx
487	.b27c	5a		phy		                phy

489	.b27d	18		clc		                clc
490	.b27e	ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
491	.b281	6d 42 03	adc $0342	                adc     vduv.ew.currentOffsetX+0
492	.b284	8d 44 03	sta $0344	                sta     vduv.ew.plotPointX+0
493	.b287	ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
494	.b28a	6d 43 03	adc $0343	                adc     vduv.ew.currentOffsetX+1
495	.b28d	8d 45 03	sta $0345	                sta     vduv.ew.plotPointX+1

497	.b290	18		clc		                clc
498	.b291	ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
499	.b294	6d 4d 88	adc $884d	                adc     ellipseCountHeight+0
500	.b297	8d 46 03	sta $0346	                sta     vduv.ew.plotPointY+0
501	.b29a	ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
502	.b29d	6d 4e 88	adc $884e	                adc     ellipseCountHeight+1
503	.b2a0	8d 47 03	sta $0347	                sta     vduv.ew.plotPointY+1

505	.b2a3	a2 44		ldx #$44	                ldx     #VDUVariables.ew.plotPointX
506	.b2a5	20 4c db	jsr $db4c	                jsr     plotPointInternal

508	.b2a8	ad 4d 88	lda $884d	                lda     ellipseCountHeight+0
509	.b2ab	0d 4e 88	ora $884e	                ora     ellipseCountHeight+1
510	.b2ae	f0 2b		beq $b2db	                beq     done

512	.b2b0	38		sec		                sec
513	.b2b1	ad 14 03	lda $0314	                lda     vduv.oldGraphicsCursorPixelsX+0
514	.b2b4	ed 42 03	sbc $0342	                sbc     vduv.ew.currentOffsetX+0
515	.b2b7	8d 44 03	sta $0344	                sta     vduv.ew.plotPointX+0
516	.b2ba	ad 15 03	lda $0315	                lda     vduv.oldGraphicsCursorPixelsX+1
517	.b2bd	ed 43 03	sbc $0343	                sbc     vduv.ew.currentOffsetX+1
518	.b2c0	8d 45 03	sta $0345	                sta     vduv.ew.plotPointX+1

520	.b2c3	38		sec		                sec
521	.b2c4	ad 16 03	lda $0316	                lda     vduv.oldGraphicsCursorPixelsY+0
522	.b2c7	ed 4d 88	sbc $884d	                sbc     ellipseCountHeight+0
523	.b2ca	8d 46 03	sta $0346	                sta     vduv.ew.plotPointY+0
524	.b2cd	ad 17 03	lda $0317	                lda     vduv.oldGraphicsCursorPixelsY+1
525	.b2d0	ed 4e 88	sbc $884e	                sbc     ellipseCountHeight+1
526	.b2d3	8d 47 03	sta $0347	                sta     vduv.ew.plotPointY+1

528	.b2d6	a2 44		ldx #$44	                ldx     #VDUVariables.ew.plotPointX
529	.b2d8	20 4c db	jsr $db4c	                jsr     plotPointInternal
530	.b2db					done:
531	.b2db	7a		ply		                ply
532	.b2dc	fa		plx		                plx
533	.b2dd	60		rts		                rts
534						                .endblock

536						;-------------------------------------------------------------------------
537						;
538						; https://tobylobster.github.io/GXR-pages/gxr/S-s24.html#SP1 ?
539						;
540	.b2de					divide24By16Bits:
541	.b2de	da		phx		                phx

543						                ; Copy 16-bit value into workspace
544	.b2df	b9 00 03	lda $0300,y	                lda     vduv+0,y
545	.b2e2	8d 3f 88	sta $883f	                sta     L883F
546	.b2e5	b9 01 03	lda $0301,y	                lda     vduv+1,y
547	.b2e8	8d 40 88	sta $8840	                sta     L8840

549						                ; 24 bits...?
550	.b2eb	a0 18		ldy #$18	                ldy     #24

552						                ; Copy 24-bit value into workspace
553	.b2ed	bd 00 03	lda $0300,x	                lda     vduv+0,x
554	.b2f0	8d 3a 88	sta $883a	                sta     L883A
555	.b2f3	bd 01 03	lda $0301,x	                lda     vduv+1,x
556	.b2f6	8d 3b 88	sta $883b	                sta     L883B
557	.b2f9	bd 02 03	lda $0302,x	                lda     vduv+2,x
558	.b2fc	30 0c		bmi $b30a	                bmi     LBDAF

560	.b2fe					LBDA3:
561	.b2fe	88		dey		                dey
562	.b2ff	f0 52		beq $b353	                beq     LBDF8

564						                ; shift 24-bit value left 1
565	.b301	0e 3a 88	asl $883a	                asl     L883A
566	.b304	2e 3b 88	rol $883b	                rol     L883B
567	.b307	2a		rol a		                rol     a
568	.b308	10 f4		bpl $b2fe	                bpl     LBDA3

570	.b30a					LBDAF:
571	.b30a	8d 3c 88	sta $883c	                sta     L883C
572	.b30d	9c 3d 88	stz $883d	                stz     L883D
573	.b310	9c 3e 88	stz $883e	                stz     L883E
574	.b313	18		clc		                clc

576	.b314					LBDB9:
577						                ; shift 40-bit value left 1
578	.b314	2e 3a 88	rol $883a	                rol     L883A
579	.b317	2e 3b 88	rol $883b	                rol     L883B
580	.b31a	2e 3c 88	rol $883c	                rol     L883C
581	.b31d	2e 3d 88	rol $883d	                rol     L883D
582	.b320	2e 3e 88	rol $883e	                rol     L883E
583	.b323	38		sec		                sec
584	.b324	ad 3d 88	lda $883d	                lda     L883D
585	.b327	ed 3f 88	sbc $883f	                sbc     L883F
586	.b32a	aa		tax		                tax
587	.b32b	ad 3e 88	lda $883e	                lda     L883E
588	.b32e	ed 40 88	sbc $8840	                sbc     L8840
589	.b331	90 06		bcc $b339	                bcc     LBDDE
590	.b333	8e 3d 88	stx $883d	                stx     L883D
591	.b336	8d 3e 88	sta $883e	                sta     L883E

593	.b339					LBDDE:
594	.b339	88		dey		                dey
595	.b33a	d0 d8		bne $b314	                bne     LBDB9
596	.b33c	fa		plx		                plx
597	.b33d	ad 3a 88	lda $883a	                lda     L883A
598	.b340	2a		rol a		                rol     a
599	.b341	9d 00 03	sta $0300,x	                sta     vduv+0,x
600	.b344	ad 3b 88	lda $883b	                lda     L883B
601	.b347	2a		rol a		                rol     a
602	.b348	9d 01 03	sta $0301,x	                sta     vduv+1,x
603	.b34b	ad 3c 88	lda $883c	                lda     L883C
604	.b34e	2a		rol a		                rol     a
605	.b34f	9d 02 03	sta $0302,x	                sta     vduv+2,x
606	.b352	60		rts		                rts

609	.b353					LBDF8:
610	.b353	fa		plx		                plx
611	.b354	60		rts		                rts

616						;-------------------------------------------------------------------------
617						;
618						; https://tobylobster.github.io/GXR-pages/gxr/S-s24.html#SP3
619						;

621	.b355					negateVDUVariableXIntoY:
622	.b355	38		sec		                sec
623	.b356	a9 00		lda #$00	                lda     #0
624	.b358	fd 00 03	sbc $0300,x	                sbc     vduv+0,x
625	.b35b	99 00 03	sta $0300,y	                sta     vduv+0,y
626	.b35e	a9 00		lda #$00	                lda     #0
627	.b360	fd 01 03	sbc $0301,x	                sbc     vduv+1,x
628	.b363	99 01 03	sta $0301,y	                sta     vduv+1,y
629	.b366	60		rts		                rts

631						;-------------------------------------------------------------------------

633	.b367					multiply24x24:
634	.b367	a0 17		ldy #$17	                ldy     #23
635	.b369	9c 39 88	stz $8839	                stz     product+5
636	.b36c	9c 38 88	stz $8838	                stz     product+4
637	.b36f	9c 37 88	stz $8837	                stz     product+3
638	.b372	4e 36 88	lsr $8836	                lsr     multiplier+2
639	.b375	6e 35 88	ror $8835	                ror     multiplier+1
640	.b378	6e 34 88	ror $8834	                ror     multiplier+0

642	.b37b					LBE20:
643	.b37b	90 1c		bcc $b399	                bcc     LBE3E
644	.b37d	18		clc		                clc
645	.b37e	ad 30 88	lda $8830	                lda     multiplicand+0
646	.b381	6d 37 88	adc $8837	                adc     product+3
647	.b384	8d 37 88	sta $8837	                sta     product+3
648	.b387	ad 31 88	lda $8831	                lda     multiplicand+1
649	.b38a	6d 38 88	adc $8838	                adc     product+4
650	.b38d	8d 38 88	sta $8838	                sta     product+4
651	.b390	ad 32 88	lda $8832	                lda     multiplicand+2
652	.b393	6d 39 88	adc $8839	                adc     product+5
653	.b396	8d 39 88	sta $8839	                sta     product+5

655	.b399					LBE3E:
656	.b399	18		clc		                clc
657	.b39a	a2 05		ldx #$05	                ldx     #5

659	.b39c					LBE41:
660	.b39c	7e 34 88	ror $8834,x	                ror     product,x
661	.b39f	ca		dex		                dex
662	.b3a0	10 fa		bpl $b39c	                bpl     LBE41
663	.b3a2	88		dey		                dey
664	.b3a3	10 d6		bpl $b37b	                bpl     LBE20
665	.b3a5	60		rts		                rts

667						;-------------------------------------------------------------------------

669	.b3a6					LBE4B:
670	.b3a6	a2 03		ldx #$03	                ldx     #3

672	.b3a8					LBE4D:
673	.b3a8	9e 30 88	stz $8830,x	                stz     $8830,x
674	.b3ab	74 dc		stz $dc,x	                stz     ZTEMPB,x
675	.b3ad	ca		dex		                dex
676	.b3ae	10 f8		bpl $b3a8	                bpl     LBE4D
677	.b3b0	a0 05		ldy #$05	                ldy     #5

679	.b3b2					LBE57:
680	.b3b2	b9 34 88	lda $8834,y	                lda     $8834,y
681	.b3b5	85 da		sta $da		                sta     ZTEMP+0
682	.b3b7	5a		phy		                phy
683	.b3b8	a0 03		ldy #$03	                ldy     #3

685	.b3ba					LBE5F:
686	.b3ba	5a		phy		                phy
687	.b3bb	38		sec		                sec
688	.b3bc	2e 30 88	rol $8830	                rol     L8830
689	.b3bf	2e 31 88	rol $8831	                rol     L8831
690	.b3c2	2e 32 88	rol $8832	                rol     L8832
691	.b3c5	2e 33 88	rol $8833	                rol     L8833
692	.b3c8	a2 01		ldx #$01	                ldx     #1
693	.b3ca	a5 dc		lda $dc		                lda     ZTEMPB+0

695	.b3cc					LBE71:
696	.b3cc	06 da		asl $da		                asl     ZTEMP+0
697	.b3ce	2a		rol a		                rol     a
698	.b3cf	26 dd		rol $dd		                rol     ZTEMPB+1
699	.b3d1	26 de		rol $de		                rol     ZTEMPC+0
700	.b3d3	26 df		rol $df		                rol     ZTEMPC+1
701	.b3d5	ca		dex		                dex
702	.b3d6	10 f4		bpl $b3cc	                bpl     LBE71
703	.b3d8	85 dc		sta $dc		                sta     ZTEMPB+0
704	.b3da	38		sec		                sec
705	.b3db	ed 30 88	sbc $8830	                sbc     L8830
706	.b3de	48		pha		                pha
707	.b3df	a5 dd		lda $dd		                lda     ZTEMPB+1
708	.b3e1	ed 31 88	sbc $8831	                sbc     L8831
709	.b3e4	aa		tax		                tax
710	.b3e5	a5 de		lda $de		                lda     ZTEMPC+0
711	.b3e7	ed 32 88	sbc $8832	                sbc     L8832
712	.b3ea	a8		tay		                tay
713	.b3eb	a5 df		lda $df		                lda     ZTEMPC+1
714	.b3ed	ed 33 88	sbc $8833	                sbc     L8833
715	.b3f0	90 0e		bcc $b400	                bcc     LBEA5
716	.b3f2	85 df		sta $df		                sta     ZTEMPC+1
717	.b3f4	84 de		sty $de		                sty     ZTEMPC+0
718	.b3f6	86 dd		stx $dd		                stx     ZTEMPB+1
719	.b3f8	68		pla		                pla
720	.b3f9	85 dc		sta $dc		                sta     ZTEMPB+0
721	.b3fb	ee 30 88	inc $8830	                inc     L8830
722	.b3fe	80 04		bra $b404	                bra     LBEA9

725	.b400					LBEA5:
726	.b400	68		pla		                pla
727	.b401	ce 30 88	dec $8830	                dec     L8830

729	.b404					LBEA9:
730	.b404	7a		ply		                ply
731	.b405	88		dey		                dey
732	.b406	10 b2		bpl $b3ba	                bpl     LBE5F
733	.b408	7a		ply		                ply
734	.b409	88		dey		                dey
735	.b40a	10 a6		bpl $b3b2	                bpl     LBE57
736	.b40c	4e 33 88	lsr $8833	                lsr     L8833
737	.b40f	6e 32 88	ror $8832	                ror     L8832
738	.b412	6e 31 88	ror $8831	                ror     L8831
739	.b415	6e 30 88	ror $8830	                ror     L8830
740	.b418	60		rts		                rts

742						;-------------------------------------------------------------------------
743						;
744						; 184-191 = Move/copy rectangle [MasRef E.3-31]
745						;
746						; The normal interpretation of <p> does not apply in this group of
747						; plot codes and the meanings are as follows:
748						;
749						; 184, 185 - %1011100x - Move rectangle, relative
750						; 186, 187 - %1011101x - Copy rectangle, relative
751						; 188, 189 - %1011110x - Move rectangle, absolute
752						; 190, 191 - %1011111x - Copy rectangle, absolute
753						;
754	.b419					plotMoveOrCopyRectangle:
755	.b419	29 02		and #$02	                and     #2
756	.b41b	8d 45 03	sta $0345	                sta     vduv.mocr.copy

758	.b41e	20 51 c9	jsr $c951	                jsr     prepareForPlotBackground

760	.b421	a2 14		ldx #$14	                ldx     #VDUVariables.oldGraphicsCursorPixels
761	.b423	20 e6 c8	jsr $c8e6	                jsr     prepareAABB

763						                ; mocr.dest.min = PLOT coordinate
764	.b426	a0 34		ldy #$34	                ldy     #VDUVariables.mocr.dest.min
765	.b428	20 16 c9	jsr $c916	                jsr     copyLastFourVDUQueueBytes
766	.b42b	84 da		sty $da		                sty     ZTEMP+0              ;Y=VDUVariables.mocr.dest.max

768						                ; dest.max = dest.min + (src.max - src.min)
769	.b42d	a2 34		ldx #$34	                ldx     #VDUVariables.mocr.dest.min
770	.b42f	a0 2c		ldy #$2c	                ldy     #VDUVariables.mocr.src.max
771	.b431	a9 28		lda #$28	                lda     #VDUVariables.mocr.src.min
772	.b433	20 80 d5	jsr $d580	                jsr     addRegionDimensionsToVDUVariableCoordinates

774						                ;
775	.b436	a2 28		ldx #$28	                ldx     #VDUVariables.mocr.src.min
776	.b438	a0 34		ldy #$34	                ldy     #VDUVariables.mocr.dest
777	.b43a	20 cc d5	jsr $d5cc	                jsr     sortVDUVariableWords

779	.b43d	5a		phy		                phy
780	.b43e	da		phx		                phx
781	.b43f	a0 00		ldy #$00	                ldy     #0                   ;get outcode for X axis
782	.b441	20 b7 d1	jsr $d1b7	                jsr     getOutcodeForAxis
783	.b444	f0 08		beq $b44e	                beq     LBEF3                ;taken if
784	.b446	4a		lsr a		                lsr     a
785	.b447	f0 03		beq $b44c	                beq     LBEF1
786	.b449	68		pla		                pla

788	.b44a					LBEEF:
789	.b44a	68		pla		                pla
790	.b44b	60		rts		                rts

793	.b44c					LBEF1:
794	.b44c	a2 00		ldx #$00	                ldx     #0

796	.b44e					LBEF3:
797	.b44e	68		pla		                pla

799	.b44f	a0 30		ldy #$30	                ldy     #VDUVariables.mocr.L30
800	.b451	84 da		sty $da		                sty     ZTEMP+0
801	.b453	a0 28		ldy #$28	                ldy     #VDUVariables.mocr.src.min
802	.b455	20 8d d5	jsr $d58d	                jsr     addRegionDimensionToVDUVariableCoordinate

804	.b458	a0 3c		ldy #$3c	                ldy     #VDUVariables.ew.pointA
805	.b45a	84 da		sty $da		                sty     ZTEMP+0

807	.b45c	a0 34		ldy #$34	                ldy     #VDUVariables.mocr.dest.min
808	.b45e	20 8d d5	jsr $d58d	                jsr     addRegionDimensionToVDUVariableCoordinate

810	.b461	68		pla		                pla
811	.b462	18		clc		                clc
812	.b463	69 04		adc #$04	                adc     #4
813	.b465	aa		tax		                tax
814	.b466	da		phx		                phx
815	.b467	a0 00		ldy #$00	                ldy     #0
816	.b469	20 b7 d1	jsr $d1b7	                jsr     getOutcodeForAxis
817	.b46c	f0 05		beq $b473	                beq     LBF18
818	.b46e	4a		lsr a		                lsr     a
819	.b46f	f0 d9		beq $b44a	                beq     LBEEF
820	.b471	a2 04		ldx #$04	                ldx     #4

822	.b473					LBF18:
823	.b473	68		pla		                pla
824	.b474	a0 40		ldy #$40	                ldy     #VDUVariables.mocr.L40
825	.b476	84 da		sty $da		                sty     ZTEMP+0
826	.b478	a0 38		ldy #$38	                ldy     #VDUVariables.mocr.dest.max.x
827	.b47a	20 8d d5	jsr $d58d	                jsr     addRegionDimensionToVDUVariableCoordinate
828	.b47d	ad 40 03	lda $0340	                lda     vduv.mocr.L40
829	.b480	cd 3c 03	cmp $033c	                cmp     vduv.mocr.L3C
830	.b483	ad 41 03	lda $0341	                lda     vduv.mocr.L40+1
831	.b486	ed 3d 03	sbc $033d	                sbc     vduv.mocr.L3C+1
832	.b489	10 10		bpl $b49b	                bpl     LBF40
833	.b48b	ad 45 03	lda $0345	                lda     vduv.mocr.copy
834	.b48e	d0 03		bne $b493	                bne     LBF38
835	.b490	20 20 c4	jsr $c420	                jsr     LC420

837	.b493					LBF38:
838	.b493	a2 34		ldx #$34	                ldx     #VDUVariables.mocr.dest
839	.b495	20 02 c9	jsr $c902	                jsr     copyEightBytesToWorkspace28
840	.b498	4c 20 c4	jmp $c420	                jmp     LC420

843	.b49b					LBF40:
844	.b49b	9c 47 03	stz $0347	                stz     vduv.mocr.L47
845	.b49e	ad 30 03	lda $0330	                lda     vduv.mocr.L30
846	.b4a1	2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne
847	.b4a4	85 da		sta $da		                sta     ZTEMP+0
848	.b4a6	ad 3c 03	lda $033c	                lda     vduv.mocr.L3C
849	.b4a9	2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne
850	.b4ac	38		sec		                sec
851	.b4ad	e5 da		sbc $da		                sbc     ZTEMP+0
852	.b4af	10 06		bpl $b4b7	                bpl     LBF5C
853	.b4b1	ce 47 03	dec $0347	                dec     vduv.mocr.L47
854	.b4b4	2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne

856	.b4b7					LBF5C:
857	.b4b7	8d 43 03	sta $0343	                sta     vduv.ew.currentOffsetX+1
858	.b4ba	48		pha		                pha
859	.b4bb	49 ff		eor #$ff	                eor     #$ff
860	.b4bd	1a		inc a		                inc     a
861	.b4be	2d 61 03	and $0361	                and     vduv.pixelsPerByteMinusOne
862	.b4c1	8d 42 03	sta $0342	                sta     vduv.mocr.shiftToNextByte
863	.b4c4	68		pla		                pla
864	.b4c5	18		clc		                clc
865	.b4c6	6d 61 03	adc $0361	                adc     vduv.pixelsPerByteMinusOne
866	.b4c9	aa		tax		                tax
867	.b4ca	bd 30 e1	lda $e130,x	                lda     LE120,x
868	.b4cd	85 e1		sta $e1		                sta     ZTEMPD+1
869	.b4cf	a2 3c		ldx #$3c	                ldx     #VDUVariables.mocr.L3C
870	.b4d1	a0 40		ldy #$40	                ldy     #VDUVariables.mocr.L40
871	.b4d3	20 9c da	jsr $da9c	                jsr     LDA9C
872	.b4d6	8d 44 03	sta $0344	                sta     vduv.mocr.L44
873	.b4d9	a5 d1		lda $d1		                lda     ZMASK
874	.b4db	8d 46 03	sta $0346	                sta     vduv.mocr.L46
875	.b4de	a5 dc		lda $dc		                lda     ZTEMPB+0
876	.b4e0	85 e0		sta $e0		                sta     ZTEMPD+0
877	.b4e2	a2 00		ldx #$00	                ldx     #0
878	.b4e4	20 41 b5	jsr $b541	                jsr     LBFE6
879	.b4e7	f0 40		beq $b529	                beq     LBFCE
880	.b4e9	ad 2a 03	lda $032a	                lda     vduv.mocr.src.min.y+0
881	.b4ec	cd 36 03	cmp $0336	                cmp     vduv.mocr.dest.min.y+0
882	.b4ef	ad 2b 03	lda $032b	                lda     vduv.mocr.src.min.y+1
883	.b4f2	ed 37 03	sbc $0337	                sbc     vduv.mocr.dest.min.y+1
884	.b4f5	50 02		bvc $b4f9	                bvc     LBF9E
885	.b4f7	49 80		eor #$80	                eor     #$80

887	.b4f9					LBF9E:
888	.b4f9	30 11		bmi $b50c	                bmi     LBFB1

890	.b4fb					LBFA0:
891	.b4fb	20 62 db	jsr $db62	                jsr     LDB62
892	.b4fe	a2 00		ldx #$00	                ldx     #0
893	.b500	20 2c b5	jsr $b52c	                jsr     LBFD1
894	.b503	a2 0c		ldx #$0c	                ldx     #$c
895	.b505	20 2c b5	jsr $b52c	                jsr     LBFD1
896	.b508	d0 f1		bne $b4fb	                bne     LBFA0
897	.b50a	80 1d		bra $b529	                bra     LBFCE

900	.b50c					LBFB1:
901	.b50c	a2 2a		ldx #$2a	                ldx     #VDUVariables.mocr.src.min.y
902	.b50e	a0 2e		ldy #$2e	                ldy     #VDUVariables.mocr.src.max.y
903	.b510	20 c2 e2	jsr $e2c2	                jsr     exchangeTwoVDUBytes
904	.b513	a2 36		ldx #$36	                ldx     #VDUVariables.mocr.dest.min.y
905	.b515	a0 3a		ldy #$3a	                ldy     #VDUVariables.mocr.dest.max.y
906	.b517	20 c2 e2	jsr $e2c2	                jsr     exchangeTwoVDUBytes

908	.b51a					LBFBF:
909	.b51a	20 62 db	jsr $db62	                jsr     LDB62
910	.b51d	a2 00		ldx #$00	                ldx     #0
911	.b51f	20 36 b5	jsr $b536	                jsr     LBFDB
912	.b522	a2 0c		ldx #$0c	                ldx     #$c
913	.b524	20 36 b5	jsr $b536	                jsr     LBFDB
914	.b527	d0 f1		bne $b51a	                bne     LBFBF

916	.b529					LBFCE:
917	.b529	4c 62 db	jmp $db62	                jmp     LDB62

919	.b52c					LBFD1:
920	.b52c	fe 2a 03	inc $032a,x	                inc     vduv.mocr.src.min.y+0,x
921	.b52f	d0 10		bne $b541	                bne     LBFE6
922	.b531	fe 2b 03	inc $032b,x	                inc     vduv.mocr.src.min.y+1,x
923	.b534	80 0b		bra $b541	                bra     LBFE6

925	.b536					LBFDB:
926	.b536	bd 2a 03	lda $032a,x	                lda     vduv.mocr.src.min.y+0,x
927	.b539	d0 03		bne $b53e	                bne     LBFE3
928	.b53b	de 2b 03	dec $032b,x	                dec     vduv.mocr.src.min.y+1,x

930	.b53e					LBFE3:
931	.b53e	de 2a 03	dec $032a,x	                dec     vduv.mocr.src.min.y+0,x
932	.b541					LBFE6:
933	.b541	bd 2a 03	lda $032a,x	                lda     vduv.mocr.src.min.y+0,x
934	.b544	dd 2e 03	cmp $032e,x	                cmp     vduv.mocr.src.max.y+0,x
935	.b547	d0 06		bne $b54f	                bne     rtsBFF4
936	.b549	bd 2b 03	lda $032b,x	                lda     vduv.mocr.src.min.y+1,x
937	.b54c	dd 2f 03	cmp $032f,x	                cmp     vduv.mocr.src.max.y+1,x

939	.b54f					rtsBFF4:
940	.b54f	60		rts		                rts

943						; Hmm. What even is this???
944	>b550	ff				                .byte $ff
945	>b551	ff				                .byte $ff
946	>b552	ff				                .byte $ff
947	>b553	ff				                .byte $ff
948	>b554	ff				                .byte $ff
949	>b555	ff				                .byte $ff
950	>b556	ff				                .byte $ff
951	>b557	ff				                .byte $ff
952	>b558	ff				                .byte $ff
953	>b559	ff				                .byte $ff
954	>b55a	ff				                .byte $ff

:5	;******  Return to file: src/terminal.s65

7045						;-------------------------------------------------------------------------

7047						; Unused space
7048						; ============
7049	.b55b					terminalUnusedBegin:
7050	>b55b	ff ff ff ff ff ff ff ff		                .fill $b900-*,$ff
	>b563	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b573	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b583	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b593	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5a3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5b3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5c3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5d3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5e3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b5f3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b603	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b613	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b623	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b633	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b643	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b653	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b663	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b673	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b683	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b693	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6a3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6b3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6c3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6d3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6e3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b6f3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b703	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b713	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b723	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b733	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b743	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b753	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b763	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b773	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b783	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b793	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7a3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7b3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7c3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7d3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7e3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b7f3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b803	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b813	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b823	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b833	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b843	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b853	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b863	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b873	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b883	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b893	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8a3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8b3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8c3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8d3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8e3	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>b8f3	ff ff ff ff ff ff ff ff ff ff ff ff ff
7051	=933					terminalUnusedSize=*-terminalUnusedBegin

7053						; Default font
7054						; ============
7055	.b900					LB900:
7057						                ; CHR$32 -
7058	>b900	00				                .byte %00000000
7059	>b901	00				                .byte %00000000
7060	>b902	00				                .byte %00000000
7061	>b903	00				                .byte %00000000
7062	>b904	00				                .byte %00000000
7063	>b905	00				                .byte %00000000
7064	>b906	00				                .byte %00000000
7065	>b907	00				                .byte %00000000

7067						                ; CHR$33 - !
7068	>b908	18				                .byte %00011000
7069	>b909	18				                .byte %00011000
7070	>b90a	18				                .byte %00011000
7071	>b90b	18				                .byte %00011000
7072	>b90c	18				                .byte %00011000
7073	>b90d	00				                .byte %00000000
7074	>b90e	18				                .byte %00011000
7075	>b90f	00				                .byte %00000000

7077						                ; CHR$34 - "
7078	>b910	6c				                .byte %01101100
7079	>b911	6c				                .byte %01101100
7080	>b912	6c				                .byte %01101100
7081	>b913	00				                .byte %00000000
7082	>b914	00				                .byte %00000000
7083	>b915	00				                .byte %00000000
7084	>b916	00				                .byte %00000000
7085	>b917	00				                .byte %00000000

7087						                ; CHR$35 - #
7088	>b918	36				                .byte %00110110
7089	>b919	36				                .byte %00110110
7090	>b91a	7f				                .byte %01111111
7091	>b91b	36				                .byte %00110110
7092	>b91c	7f				                .byte %01111111
7093	>b91d	36				                .byte %00110110
7094	>b91e	36				                .byte %00110110
7095	>b91f	00				                .byte %00000000

7097						                ; CHR$36 - $
7098	>b920	0c				                .byte %00001100
7099	>b921	3f				                .byte %00111111
7100	>b922	68				                .byte %01101000
7101	>b923	3e				                .byte %00111110
7102	>b924	0b				                .byte %00001011
7103	>b925	7e				                .byte %01111110
7104	>b926	18				                .byte %00011000
7105	>b927	00				                .byte %00000000

7107						                ; CHR$37 - %
7108	>b928	60				                .byte %01100000
7109	>b929	66				                .byte %01100110
7110	>b92a	0c				                .byte %00001100
7111	>b92b	18				                .byte %00011000
7112	>b92c	30				                .byte %00110000
7113	>b92d	66				                .byte %01100110
7114	>b92e	06				                .byte %00000110
7115	>b92f	00				                .byte %00000000

7117						                ; CHR$38 - &
7118	>b930	38				                .byte %00111000
7119	>b931	6c				                .byte %01101100
7120	>b932	6c				                .byte %01101100
7121	>b933	38				                .byte %00111000
7122	>b934	6d				                .byte %01101101
7123	>b935	66				                .byte %01100110
7124	>b936	3b				                .byte %00111011
7125	>b937	00				                .byte %00000000

7127						                ; CHR$39 - '
7128	>b938	0c				                .byte %00001100
7129	>b939	18				                .byte %00011000
7130	>b93a	30				                .byte %00110000
7131	>b93b	00				                .byte %00000000
7132	>b93c	00				                .byte %00000000
7133	>b93d	00				                .byte %00000000
7134	>b93e	00				                .byte %00000000
7135	>b93f	00				                .byte %00000000

7137						                ; CHR$40 - (
7138	>b940	0c				                .byte %00001100
7139	>b941	18				                .byte %00011000
7140	>b942	30				                .byte %00110000
7141	>b943	30				                .byte %00110000
7142	>b944	30				                .byte %00110000
7143	>b945	18				                .byte %00011000
7144	>b946	0c				                .byte %00001100
7145	>b947	00				                .byte %00000000

7147						                ; CHR$41 - )
7148	>b948	30				                .byte %00110000
7149	>b949	18				                .byte %00011000
7150	>b94a	0c				                .byte %00001100
7151	>b94b	0c				                .byte %00001100
7152	>b94c	0c				                .byte %00001100
7153	>b94d	18				                .byte %00011000
7154	>b94e	30				                .byte %00110000
7155	>b94f	00				                .byte %00000000

7157						                ; CHR$42 - *
7158	>b950	00				                .byte %00000000
7159	>b951	18				                .byte %00011000
7160	>b952	7e				                .byte %01111110
7161	>b953	3c				                .byte %00111100
7162	>b954	7e				                .byte %01111110
7163	>b955	18				                .byte %00011000
7164	>b956	00				                .byte %00000000
7165	>b957	00				                .byte %00000000

7167						                ; CHR$43 - +
7168	>b958	00				                .byte %00000000
7169	>b959	18				                .byte %00011000
7170	>b95a	18				                .byte %00011000
7171	>b95b	7e				                .byte %01111110
7172	>b95c	18				                .byte %00011000
7173	>b95d	18				                .byte %00011000
7174	>b95e	00				                .byte %00000000
7175	>b95f	00				                .byte %00000000

7177						                ; CHR$44 - ,
7178	>b960	00				                .byte %00000000
7179	>b961	00				                .byte %00000000
7180	>b962	00				                .byte %00000000
7181	>b963	00				                .byte %00000000
7182	>b964	00				                .byte %00000000
7183	>b965	18				                .byte %00011000
7184	>b966	18				                .byte %00011000
7185	>b967	30				                .byte %00110000

7187						                ; CHR$45 - -
7188	>b968	00				                .byte %00000000
7189	>b969	00				                .byte %00000000
7190	>b96a	00				                .byte %00000000
7191	>b96b	7e				                .byte %01111110
7192	>b96c	00				                .byte %00000000
7193	>b96d	00				                .byte %00000000
7194	>b96e	00				                .byte %00000000
7195	>b96f	00				                .byte %00000000

7197						                ; CHR$46 - .
7198	>b970	00				                .byte %00000000
7199	>b971	00				                .byte %00000000
7200	>b972	00				                .byte %00000000
7201	>b973	00				                .byte %00000000
7202	>b974	00				                .byte %00000000
7203	>b975	18				                .byte %00011000
7204	>b976	18				                .byte %00011000
7205	>b977	00				                .byte %00000000

7207						                ; CHR$47 - /
7208	>b978	00				                .byte %00000000
7209	>b979	06				                .byte %00000110
7210	>b97a	0c				                .byte %00001100
7211	>b97b	18				                .byte %00011000
7212	>b97c	30				                .byte %00110000
7213	>b97d	60				                .byte %01100000
7214	>b97e	00				                .byte %00000000
7215	>b97f	00				                .byte %00000000

7217						                ; CHR$48 - 0
7218	>b980	3c				                .byte %00111100
7219	>b981	66				                .byte %01100110
7220	>b982	6e				                .byte %01101110
7221	>b983	7e				                .byte %01111110
7222	>b984	76				                .byte %01110110
7223	>b985	66				                .byte %01100110
7224	>b986	3c				                .byte %00111100
7225	>b987	00				                .byte %00000000

7227						                ; CHR$49 - 1
7228	>b988	18				                .byte %00011000
7229	>b989	38				                .byte %00111000
7230	>b98a	18				                .byte %00011000
7231	>b98b	18				                .byte %00011000
7232	>b98c	18				                .byte %00011000
7233	>b98d	18				                .byte %00011000
7234	>b98e	7e				                .byte %01111110
7235	>b98f	00				                .byte %00000000

7237						                ; CHR$50 - 2
7238	>b990	3c				                .byte %00111100
7239	>b991	66				                .byte %01100110
7240	>b992	06				                .byte %00000110
7241	>b993	0c				                .byte %00001100
7242	>b994	18				                .byte %00011000
7243	>b995	30				                .byte %00110000
7244	>b996	7e				                .byte %01111110
7245	>b997	00				                .byte %00000000

7247						                ; CHR$51 - 3
7248	>b998	3c				                .byte %00111100
7249	>b999	66				                .byte %01100110
7250	>b99a	06				                .byte %00000110
7251	>b99b	1c				                .byte %00011100
7252	>b99c	06				                .byte %00000110
7253	>b99d	66				                .byte %01100110
7254	>b99e	3c				                .byte %00111100
7255	>b99f	00				                .byte %00000000

7257						                ; CHR$52 - 4
7258	>b9a0	0c				                .byte %00001100
7259	>b9a1	1c				                .byte %00011100
7260	>b9a2	3c				                .byte %00111100
7261	>b9a3	6c				                .byte %01101100
7262	>b9a4	7e				                .byte %01111110
7263	>b9a5	0c				                .byte %00001100
7264	>b9a6	0c				                .byte %00001100
7265	>b9a7	00				                .byte %00000000

7267						                ; CHR$53 - 5
7268	>b9a8	7e				                .byte %01111110
7269	>b9a9	60				                .byte %01100000
7270	>b9aa	7c				                .byte %01111100
7271	>b9ab	06				                .byte %00000110
7272	>b9ac	06				                .byte %00000110
7273	>b9ad	66				                .byte %01100110
7274	>b9ae	3c				                .byte %00111100
7275	>b9af	00				                .byte %00000000

7277						                ; CHR$54 - 6
7278	>b9b0	1c				                .byte %00011100
7279	>b9b1	30				                .byte %00110000
7280	>b9b2	60				                .byte %01100000
7281	>b9b3	7c				                .byte %01111100
7282	>b9b4	66				                .byte %01100110
7283	>b9b5	66				                .byte %01100110
7284	>b9b6	3c				                .byte %00111100
7285	>b9b7	00				                .byte %00000000

7287						                ; CHR$55 - 7
7288	>b9b8	7e				                .byte %01111110
7289	>b9b9	06				                .byte %00000110
7290	>b9ba	0c				                .byte %00001100
7291	>b9bb	18				                .byte %00011000
7292	>b9bc	30				                .byte %00110000
7293	>b9bd	30				                .byte %00110000
7294	>b9be	30				                .byte %00110000
7295	>b9bf	00				                .byte %00000000

7297						                ; CHR$56 - 8
7298	>b9c0	3c				                .byte %00111100
7299	>b9c1	66				                .byte %01100110
7300	>b9c2	66				                .byte %01100110
7301	>b9c3	3c				                .byte %00111100
7302	>b9c4	66				                .byte %01100110
7303	>b9c5	66				                .byte %01100110
7304	>b9c6	3c				                .byte %00111100
7305	>b9c7	00				                .byte %00000000

7307						                ; CHR$57 - 9
7308	>b9c8	3c				                .byte %00111100
7309	>b9c9	66				                .byte %01100110
7310	>b9ca	66				                .byte %01100110
7311	>b9cb	3e				                .byte %00111110
7312	>b9cc	06				                .byte %00000110
7313	>b9cd	0c				                .byte %00001100
7314	>b9ce	38				                .byte %00111000
7315	>b9cf	00				                .byte %00000000

7317						                ; CHR$58 - :
7318	>b9d0	00				                .byte %00000000
7319	>b9d1	00				                .byte %00000000
7320	>b9d2	18				                .byte %00011000
7321	>b9d3	18				                .byte %00011000
7322	>b9d4	00				                .byte %00000000
7323	>b9d5	18				                .byte %00011000
7324	>b9d6	18				                .byte %00011000
7325	>b9d7	00				                .byte %00000000

7327						                ; CHR$59 - ;
7328	>b9d8	00				                .byte %00000000
7329	>b9d9	00				                .byte %00000000
7330	>b9da	18				                .byte %00011000
7331	>b9db	18				                .byte %00011000
7332	>b9dc	00				                .byte %00000000
7333	>b9dd	18				                .byte %00011000
7334	>b9de	18				                .byte %00011000
7335	>b9df	30				                .byte %00110000

7337						                ; CHR$60 - <
7338	>b9e0	0c				                .byte %00001100
7339	>b9e1	18				                .byte %00011000
7340	>b9e2	30				                .byte %00110000
7341	>b9e3	60				                .byte %01100000
7342	>b9e4	30				                .byte %00110000
7343	>b9e5	18				                .byte %00011000
7344	>b9e6	0c				                .byte %00001100
7345	>b9e7	00				                .byte %00000000

7347						                ; CHR$61 - =
7348	>b9e8	00				                .byte %00000000
7349	>b9e9	00				                .byte %00000000
7350	>b9ea	7e				                .byte %01111110
7351	>b9eb	00				                .byte %00000000
7352	>b9ec	7e				                .byte %01111110
7353	>b9ed	00				                .byte %00000000
7354	>b9ee	00				                .byte %00000000
7355	>b9ef	00				                .byte %00000000

7357						                ; CHR$62 - >
7358	>b9f0	30				                .byte %00110000
7359	>b9f1	18				                .byte %00011000
7360	>b9f2	0c				                .byte %00001100
7361	>b9f3	06				                .byte %00000110
7362	>b9f4	0c				                .byte %00001100
7363	>b9f5	18				                .byte %00011000
7364	>b9f6	30				                .byte %00110000
7365	>b9f7	00				                .byte %00000000

7367						                ; CHR$63 - ?
7368	>b9f8	3c				                .byte %00111100
7369	>b9f9	66				                .byte %01100110
7370	>b9fa	0c				                .byte %00001100
7371	>b9fb	18				                .byte %00011000
7372	>b9fc	18				                .byte %00011000
7373	>b9fd	00				                .byte %00000000
7374	>b9fe	18				                .byte %00011000
7375	>b9ff	00				                .byte %00000000

7377						                ; CHR$64 - @
7378	>ba00	3c				                .byte %00111100
7379	>ba01	66				                .byte %01100110
7380	>ba02	6e				                .byte %01101110
7381	>ba03	6a				                .byte %01101010
7382	>ba04	6e				                .byte %01101110
7383	>ba05	60				                .byte %01100000
7384	>ba06	3c				                .byte %00111100
7385	>ba07	00				                .byte %00000000

7387						                ; CHR$65 - A
7388	>ba08	3c				                .byte %00111100
7389	>ba09	66				                .byte %01100110
7390	>ba0a	66				                .byte %01100110
7391	>ba0b	7e				                .byte %01111110
7392	>ba0c	66				                .byte %01100110
7393	>ba0d	66				                .byte %01100110
7394	>ba0e	66				                .byte %01100110
7395	>ba0f	00				                .byte %00000000

7397						                ; CHR$66 - B
7398	>ba10	7c				                .byte %01111100
7399	>ba11	66				                .byte %01100110
7400	>ba12	66				                .byte %01100110
7401	>ba13	7c				                .byte %01111100
7402	>ba14	66				                .byte %01100110
7403	>ba15	66				                .byte %01100110
7404	>ba16	7c				                .byte %01111100
7405	>ba17	00				                .byte %00000000

7407						                ; CHR$67 - C
7408	>ba18	3c				                .byte %00111100
7409	>ba19	66				                .byte %01100110
7410	>ba1a	60				                .byte %01100000
7411	>ba1b	60				                .byte %01100000
7412	>ba1c	60				                .byte %01100000
7413	>ba1d	66				                .byte %01100110
7414	>ba1e	3c				                .byte %00111100
7415	>ba1f	00				                .byte %00000000

7417						                ; CHR$68 - D
7418	>ba20	78				                .byte %01111000
7419	>ba21	6c				                .byte %01101100
7420	>ba22	66				                .byte %01100110
7421	>ba23	66				                .byte %01100110
7422	>ba24	66				                .byte %01100110
7423	>ba25	6c				                .byte %01101100
7424	>ba26	78				                .byte %01111000
7425	>ba27	00				                .byte %00000000

7427						                ; CHR$69 - E
7428	>ba28	7e				                .byte %01111110
7429	>ba29	60				                .byte %01100000
7430	>ba2a	60				                .byte %01100000
7431	>ba2b	7c				                .byte %01111100
7432	>ba2c	60				                .byte %01100000
7433	>ba2d	60				                .byte %01100000
7434	>ba2e	7e				                .byte %01111110
7435	>ba2f	00				                .byte %00000000

7437						                ; CHR$70 - F
7438	>ba30	7e				                .byte %01111110
7439	>ba31	60				                .byte %01100000
7440	>ba32	60				                .byte %01100000
7441	>ba33	7c				                .byte %01111100
7442	>ba34	60				                .byte %01100000
7443	>ba35	60				                .byte %01100000
7444	>ba36	60				                .byte %01100000
7445	>ba37	00				                .byte %00000000

7447						                ; CHR$71 - G
7448	>ba38	3c				                .byte %00111100
7449	>ba39	66				                .byte %01100110
7450	>ba3a	60				                .byte %01100000
7451	>ba3b	6e				                .byte %01101110
7452	>ba3c	66				                .byte %01100110
7453	>ba3d	66				                .byte %01100110
7454	>ba3e	3c				                .byte %00111100
7455	>ba3f	00				                .byte %00000000

7457						                ; CHR$72 - H
7458	>ba40	66				                .byte %01100110
7459	>ba41	66				                .byte %01100110
7460	>ba42	66				                .byte %01100110
7461	>ba43	7e				                .byte %01111110
7462	>ba44	66				                .byte %01100110
7463	>ba45	66				                .byte %01100110
7464	>ba46	66				                .byte %01100110
7465	>ba47	00				                .byte %00000000

7467						                ; CHR$73 - I
7468	>ba48	7e				                .byte %01111110
7469	>ba49	18				                .byte %00011000
7470	>ba4a	18				                .byte %00011000
7471	>ba4b	18				                .byte %00011000
7472	>ba4c	18				                .byte %00011000
7473	>ba4d	18				                .byte %00011000
7474	>ba4e	7e				                .byte %01111110
7475	>ba4f	00				                .byte %00000000

7477						                ; CHR$74 - J
7478	>ba50	3e				                .byte %00111110
7479	>ba51	0c				                .byte %00001100
7480	>ba52	0c				                .byte %00001100
7481	>ba53	0c				                .byte %00001100
7482	>ba54	0c				                .byte %00001100
7483	>ba55	6c				                .byte %01101100
7484	>ba56	38				                .byte %00111000
7485	>ba57	00				                .byte %00000000

7487						                ; CHR$75 - K
7488	>ba58	66				                .byte %01100110
7489	>ba59	6c				                .byte %01101100
7490	>ba5a	78				                .byte %01111000
7491	>ba5b	70				                .byte %01110000
7492	>ba5c	78				                .byte %01111000
7493	>ba5d	6c				                .byte %01101100
7494	>ba5e	66				                .byte %01100110
7495	>ba5f	00				                .byte %00000000

7497						                ; CHR$76 - L
7498	>ba60	60				                .byte %01100000
7499	>ba61	60				                .byte %01100000
7500	>ba62	60				                .byte %01100000
7501	>ba63	60				                .byte %01100000
7502	>ba64	60				                .byte %01100000
7503	>ba65	60				                .byte %01100000
7504	>ba66	7e				                .byte %01111110
7505	>ba67	00				                .byte %00000000

7507						                ; CHR$77 - M
7508	>ba68	63				                .byte %01100011
7509	>ba69	77				                .byte %01110111
7510	>ba6a	7f				                .byte %01111111
7511	>ba6b	6b				                .byte %01101011
7512	>ba6c	6b				                .byte %01101011
7513	>ba6d	63				                .byte %01100011
7514	>ba6e	63				                .byte %01100011
7515	>ba6f	00				                .byte %00000000

7517						                ; CHR$78 - N
7518	>ba70	66				                .byte %01100110
7519	>ba71	66				                .byte %01100110
7520	>ba72	76				                .byte %01110110
7521	>ba73	7e				                .byte %01111110
7522	>ba74	6e				                .byte %01101110
7523	>ba75	66				                .byte %01100110
7524	>ba76	66				                .byte %01100110
7525	>ba77	00				                .byte %00000000

7527						                ; CHR$79 - O
7528	>ba78	3c				                .byte %00111100
7529	>ba79	66				                .byte %01100110
7530	>ba7a	66				                .byte %01100110
7531	>ba7b	66				                .byte %01100110
7532	>ba7c	66				                .byte %01100110
7533	>ba7d	66				                .byte %01100110
7534	>ba7e	3c				                .byte %00111100
7535	>ba7f	00				                .byte %00000000

7537						                ; CHR$80 - P
7538	>ba80	7c				                .byte %01111100
7539	>ba81	66				                .byte %01100110
7540	>ba82	66				                .byte %01100110
7541	>ba83	7c				                .byte %01111100
7542	>ba84	60				                .byte %01100000
7543	>ba85	60				                .byte %01100000
7544	>ba86	60				                .byte %01100000
7545	>ba87	00				                .byte %00000000

7547						                ; CHR$81 - Q
7548	>ba88	3c				                .byte %00111100
7549	>ba89	66				                .byte %01100110
7550	>ba8a	66				                .byte %01100110
7551	>ba8b	66				                .byte %01100110
7552	>ba8c	6a				                .byte %01101010
7553	>ba8d	6c				                .byte %01101100
7554	>ba8e	36				                .byte %00110110
7555	>ba8f	00				                .byte %00000000

7557						                ; CHR$82 - R
7558	>ba90	7c				                .byte %01111100
7559	>ba91	66				                .byte %01100110
7560	>ba92	66				                .byte %01100110
7561	>ba93	7c				                .byte %01111100
7562	>ba94	6c				                .byte %01101100
7563	>ba95	66				                .byte %01100110
7564	>ba96	66				                .byte %01100110
7565	>ba97	00				                .byte %00000000

7567						                ; CHR$83 - S
7568	>ba98	3c				                .byte %00111100
7569	>ba99	66				                .byte %01100110
7570	>ba9a	60				                .byte %01100000
7571	>ba9b	3c				                .byte %00111100
7572	>ba9c	06				                .byte %00000110
7573	>ba9d	66				                .byte %01100110
7574	>ba9e	3c				                .byte %00111100
7575	>ba9f	00				                .byte %00000000

7577						                ; CHR$84 - T
7578	>baa0	7e				                .byte %01111110
7579	>baa1	18				                .byte %00011000
7580	>baa2	18				                .byte %00011000
7581	>baa3	18				                .byte %00011000
7582	>baa4	18				                .byte %00011000
7583	>baa5	18				                .byte %00011000
7584	>baa6	18				                .byte %00011000
7585	>baa7	00				                .byte %00000000

7587						                ; CHR$85 - U
7588	>baa8	66				                .byte %01100110
7589	>baa9	66				                .byte %01100110
7590	>baaa	66				                .byte %01100110
7591	>baab	66				                .byte %01100110
7592	>baac	66				                .byte %01100110
7593	>baad	66				                .byte %01100110
7594	>baae	3c				                .byte %00111100
7595	>baaf	00				                .byte %00000000

7597						                ; CHR$86 - V
7598	>bab0	66				                .byte %01100110
7599	>bab1	66				                .byte %01100110
7600	>bab2	66				                .byte %01100110
7601	>bab3	66				                .byte %01100110
7602	>bab4	66				                .byte %01100110
7603	>bab5	3c				                .byte %00111100
7604	>bab6	18				                .byte %00011000
7605	>bab7	00				                .byte %00000000

7607						                ; CHR$87 - W
7608	>bab8	63				                .byte %01100011
7609	>bab9	63				                .byte %01100011
7610	>baba	6b				                .byte %01101011
7611	>babb	6b				                .byte %01101011
7612	>babc	7f				                .byte %01111111
7613	>babd	77				                .byte %01110111
7614	>babe	63				                .byte %01100011
7615	>babf	00				                .byte %00000000

7617						                ; CHR$88 - X
7618	>bac0	66				                .byte %01100110
7619	>bac1	66				                .byte %01100110
7620	>bac2	3c				                .byte %00111100
7621	>bac3	18				                .byte %00011000
7622	>bac4	3c				                .byte %00111100
7623	>bac5	66				                .byte %01100110
7624	>bac6	66				                .byte %01100110
7625	>bac7	00				                .byte %00000000

7627						                ; CHR$89 - Y
7628	>bac8	66				                .byte %01100110
7629	>bac9	66				                .byte %01100110
7630	>baca	66				                .byte %01100110
7631	>bacb	3c				                .byte %00111100
7632	>bacc	18				                .byte %00011000
7633	>bacd	18				                .byte %00011000
7634	>bace	18				                .byte %00011000
7635	>bacf	00				                .byte %00000000

7637						                ; CHR$90 - Z
7638	>bad0	7e				                .byte %01111110
7639	>bad1	06				                .byte %00000110
7640	>bad2	0c				                .byte %00001100
7641	>bad3	18				                .byte %00011000
7642	>bad4	30				                .byte %00110000
7643	>bad5	60				                .byte %01100000
7644	>bad6	7e				                .byte %01111110
7645	>bad7	00				                .byte %00000000

7647						                ; CHR$91 - [
7648	>bad8	7c				                .byte %01111100
7649	>bad9	60				                .byte %01100000
7650	>bada	60				                .byte %01100000
7651	>badb	60				                .byte %01100000
7652	>badc	60				                .byte %01100000
7653	>badd	60				                .byte %01100000
7654	>bade	7c				                .byte %01111100
7655	>badf	00				                .byte %00000000

7657						                ; CHR$92 - \
7658	>bae0	00				                .byte %00000000
7659	>bae1	60				                .byte %01100000
7660	>bae2	30				                .byte %00110000
7661	>bae3	18				                .byte %00011000
7662	>bae4	0c				                .byte %00001100
7663	>bae5	06				                .byte %00000110
7664	>bae6	00				                .byte %00000000
7665	>bae7	00				                .byte %00000000

7667						                ; CHR$93 - ]
7668	>bae8	3e				                .byte %00111110
7669	>bae9	06				                .byte %00000110
7670	>baea	06				                .byte %00000110
7671	>baeb	06				                .byte %00000110
7672	>baec	06				                .byte %00000110
7673	>baed	06				                .byte %00000110
7674	>baee	3e				                .byte %00111110
7675	>baef	00				                .byte %00000000

7677						                ; CHR$94 - ^
7678	>baf0	18				                .byte %00011000
7679	>baf1	3c				                .byte %00111100
7680	>baf2	66				                .byte %01100110
7681	>baf3	42				                .byte %01000010
7682	>baf4	00				                .byte %00000000
7683	>baf5	00				                .byte %00000000
7684	>baf6	00				                .byte %00000000
7685	>baf7	00				                .byte %00000000

7687						                ; CHR$95 - _
7688	>baf8	00				                .byte %00000000
7689	>baf9	00				                .byte %00000000
7690	>bafa	00				                .byte %00000000
7691	>bafb	00				                .byte %00000000
7692	>bafc	00				                .byte %00000000
7693	>bafd	00				                .byte %00000000
7694	>bafe	00				                .byte %00000000
7695	>baff	ff				                .byte %11111111

7697						                ; CHR$96
7698	>bb00	1c				                .byte %00011100
7699	>bb01	36				                .byte %00110110
7700	>bb02	30				                .byte %00110000
7701	>bb03	7c				                .byte %01111100
7702	>bb04	30				                .byte %00110000
7703	>bb05	30				                .byte %00110000
7704	>bb06	7e				                .byte %01111110
7705	>bb07	00				                .byte %00000000

7707						                ; CHR$97 - a
7708	>bb08	00				                .byte %00000000
7709	>bb09	00				                .byte %00000000
7710	>bb0a	3c				                .byte %00111100
7711	>bb0b	06				                .byte %00000110
7712	>bb0c	3e				                .byte %00111110
7713	>bb0d	66				                .byte %01100110
7714	>bb0e	3e				                .byte %00111110
7715	>bb0f	00				                .byte %00000000

7717						                ; CHR$98 - b
7718	>bb10	60				                .byte %01100000
7719	>bb11	60				                .byte %01100000
7720	>bb12	7c				                .byte %01111100
7721	>bb13	66				                .byte %01100110
7722	>bb14	66				                .byte %01100110
7723	>bb15	66				                .byte %01100110
7724	>bb16	7c				                .byte %01111100
7725	>bb17	00				                .byte %00000000

7727						                ; CHR$99 - c
7728	>bb18	00				                .byte %00000000
7729	>bb19	00				                .byte %00000000
7730	>bb1a	3c				                .byte %00111100
7731	>bb1b	66				                .byte %01100110
7732	>bb1c	60				                .byte %01100000
7733	>bb1d	66				                .byte %01100110
7734	>bb1e	3c				                .byte %00111100
7735	>bb1f	00				                .byte %00000000

7737						                ; CHR$100 - d
7738	>bb20	06				                .byte %00000110
7739	>bb21	06				                .byte %00000110
7740	>bb22	3e				                .byte %00111110
7741	>bb23	66				                .byte %01100110
7742	>bb24	66				                .byte %01100110
7743	>bb25	66				                .byte %01100110
7744	>bb26	3e				                .byte %00111110
7745	>bb27	00				                .byte %00000000

7747						                ; CHR$101 - e
7748	>bb28	00				                .byte %00000000
7749	>bb29	00				                .byte %00000000
7750	>bb2a	3c				                .byte %00111100
7751	>bb2b	66				                .byte %01100110
7752	>bb2c	7e				                .byte %01111110
7753	>bb2d	60				                .byte %01100000
7754	>bb2e	3c				                .byte %00111100
7755	>bb2f	00				                .byte %00000000

7757						                ; CHR$102 - f
7758	>bb30	1c				                .byte %00011100
7759	>bb31	30				                .byte %00110000
7760	>bb32	30				                .byte %00110000
7761	>bb33	7c				                .byte %01111100
7762	>bb34	30				                .byte %00110000
7763	>bb35	30				                .byte %00110000
7764	>bb36	30				                .byte %00110000
7765	>bb37	00				                .byte %00000000

7767						                ; CHR$103 - g
7768	>bb38	00				                .byte %00000000
7769	>bb39	00				                .byte %00000000
7770	>bb3a	3e				                .byte %00111110
7771	>bb3b	66				                .byte %01100110
7772	>bb3c	66				                .byte %01100110
7773	>bb3d	3e				                .byte %00111110
7774	>bb3e	06				                .byte %00000110
7775	>bb3f	3c				                .byte %00111100

7777						                ; CHR$104 - h
7778	>bb40	60				                .byte %01100000
7779	>bb41	60				                .byte %01100000
7780	>bb42	7c				                .byte %01111100
7781	>bb43	66				                .byte %01100110
7782	>bb44	66				                .byte %01100110
7783	>bb45	66				                .byte %01100110
7784	>bb46	66				                .byte %01100110
7785	>bb47	00				                .byte %00000000

7787						                ; CHR$105 - i
7788	>bb48	18				                .byte %00011000
7789	>bb49	00				                .byte %00000000
7790	>bb4a	38				                .byte %00111000
7791	>bb4b	18				                .byte %00011000
7792	>bb4c	18				                .byte %00011000
7793	>bb4d	18				                .byte %00011000
7794	>bb4e	3c				                .byte %00111100
7795	>bb4f	00				                .byte %00000000

7797						                ; CHR$106 - j
7798	>bb50	18				                .byte %00011000
7799	>bb51	00				                .byte %00000000
7800	>bb52	38				                .byte %00111000
7801	>bb53	18				                .byte %00011000
7802	>bb54	18				                .byte %00011000
7803	>bb55	18				                .byte %00011000
7804	>bb56	18				                .byte %00011000
7805	>bb57	70				                .byte %01110000

7807						                ; CHR$107 - k
7808	>bb58	60				                .byte %01100000
7809	>bb59	60				                .byte %01100000
7810	>bb5a	66				                .byte %01100110
7811	>bb5b	6c				                .byte %01101100
7812	>bb5c	78				                .byte %01111000
7813	>bb5d	6c				                .byte %01101100
7814	>bb5e	66				                .byte %01100110
7815	>bb5f	00				                .byte %00000000

7817						                ; CHR$108 - l
7818	>bb60	38				                .byte %00111000
7819	>bb61	18				                .byte %00011000
7820	>bb62	18				                .byte %00011000
7821	>bb63	18				                .byte %00011000
7822	>bb64	18				                .byte %00011000
7823	>bb65	18				                .byte %00011000
7824	>bb66	3c				                .byte %00111100
7825	>bb67	00				                .byte %00000000

7827						                ; CHR$109 - m
7828	>bb68	00				                .byte %00000000
7829	>bb69	00				                .byte %00000000
7830	>bb6a	36				                .byte %00110110
7831	>bb6b	7f				                .byte %01111111
7832	>bb6c	6b				                .byte %01101011
7833	>bb6d	6b				                .byte %01101011
7834	>bb6e	63				                .byte %01100011
7835	>bb6f	00				                .byte %00000000

7837						                ; CHR$110 - n
7838	>bb70	00				                .byte %00000000
7839	>bb71	00				                .byte %00000000
7840	>bb72	7c				                .byte %01111100
7841	>bb73	66				                .byte %01100110
7842	>bb74	66				                .byte %01100110
7843	>bb75	66				                .byte %01100110
7844	>bb76	66				                .byte %01100110
7845	>bb77	00				                .byte %00000000

7847						                ; CHR$111 - o
7848	>bb78	00				                .byte %00000000
7849	>bb79	00				                .byte %00000000
7850	>bb7a	3c				                .byte %00111100
7851	>bb7b	66				                .byte %01100110
7852	>bb7c	66				                .byte %01100110
7853	>bb7d	66				                .byte %01100110
7854	>bb7e	3c				                .byte %00111100
7855	>bb7f	00				                .byte %00000000

7857						                ; CHR$112 - p
7858	>bb80	00				                .byte %00000000
7859	>bb81	00				                .byte %00000000
7860	>bb82	7c				                .byte %01111100
7861	>bb83	66				                .byte %01100110
7862	>bb84	66				                .byte %01100110
7863	>bb85	7c				                .byte %01111100
7864	>bb86	60				                .byte %01100000
7865	>bb87	60				                .byte %01100000

7867						                ; CHR$113 - q
7868	>bb88	00				                .byte %00000000
7869	>bb89	00				                .byte %00000000
7870	>bb8a	3e				                .byte %00111110
7871	>bb8b	66				                .byte %01100110
7872	>bb8c	66				                .byte %01100110
7873	>bb8d	3e				                .byte %00111110
7874	>bb8e	06				                .byte %00000110
7875	>bb8f	07				                .byte %00000111

7877						                ; CHR$114 - r
7878	>bb90	00				                .byte %00000000
7879	>bb91	00				                .byte %00000000
7880	>bb92	6c				                .byte %01101100
7881	>bb93	76				                .byte %01110110
7882	>bb94	60				                .byte %01100000
7883	>bb95	60				                .byte %01100000
7884	>bb96	60				                .byte %01100000
7885	>bb97	00				                .byte %00000000

7887						                ; CHR$115 - s
7888	>bb98	00				                .byte %00000000
7889	>bb99	00				                .byte %00000000
7890	>bb9a	3e				                .byte %00111110
7891	>bb9b	60				                .byte %01100000
7892	>bb9c	3c				                .byte %00111100
7893	>bb9d	06				                .byte %00000110
7894	>bb9e	7c				                .byte %01111100
7895	>bb9f	00				                .byte %00000000

7897						                ; CHR$116 - t
7898	>bba0	30				                .byte %00110000
7899	>bba1	30				                .byte %00110000
7900	>bba2	7c				                .byte %01111100
7901	>bba3	30				                .byte %00110000
7902	>bba4	30				                .byte %00110000
7903	>bba5	30				                .byte %00110000
7904	>bba6	1c				                .byte %00011100
7905	>bba7	00				                .byte %00000000

7907						                ; CHR$117 - u
7908	>bba8	00				                .byte %00000000
7909	>bba9	00				                .byte %00000000
7910	>bbaa	66				                .byte %01100110
7911	>bbab	66				                .byte %01100110
7912	>bbac	66				                .byte %01100110
7913	>bbad	66				                .byte %01100110
7914	>bbae	3e				                .byte %00111110
7915	>bbaf	00				                .byte %00000000

7917						                ; CHR$118 - v
7918	>bbb0	00				                .byte %00000000
7919	>bbb1	00				                .byte %00000000
7920	>bbb2	66				                .byte %01100110
7921	>bbb3	66				                .byte %01100110
7922	>bbb4	66				                .byte %01100110
7923	>bbb5	3c				                .byte %00111100
7924	>bbb6	18				                .byte %00011000
7925	>bbb7	00				                .byte %00000000

7927						                ; CHR$119 - w
7928	>bbb8	00				                .byte %00000000
7929	>bbb9	00				                .byte %00000000
7930	>bbba	63				                .byte %01100011
7931	>bbbb	6b				                .byte %01101011
7932	>bbbc	6b				                .byte %01101011
7933	>bbbd	7f				                .byte %01111111
7934	>bbbe	36				                .byte %00110110
7935	>bbbf	00				                .byte %00000000

7937						                ; CHR$120 - x
7938	>bbc0	00				                .byte %00000000
7939	>bbc1	00				                .byte %00000000
7940	>bbc2	66				                .byte %01100110
7941	>bbc3	3c				                .byte %00111100
7942	>bbc4	18				                .byte %00011000
7943	>bbc5	3c				                .byte %00111100
7944	>bbc6	66				                .byte %01100110
7945	>bbc7	00				                .byte %00000000

7947						                ; CHR$121 - y
7948	>bbc8	00				                .byte %00000000
7949	>bbc9	00				                .byte %00000000
7950	>bbca	66				                .byte %01100110
7951	>bbcb	66				                .byte %01100110
7952	>bbcc	66				                .byte %01100110
7953	>bbcd	3e				                .byte %00111110
7954	>bbce	06				                .byte %00000110
7955	>bbcf	3c				                .byte %00111100

7957						                ; CHR$122 - z
7958	>bbd0	00				                .byte %00000000
7959	>bbd1	00				                .byte %00000000
7960	>bbd2	7e				                .byte %01111110
7961	>bbd3	0c				                .byte %00001100
7962	>bbd4	18				                .byte %00011000
7963	>bbd5	30				                .byte %00110000
7964	>bbd6	7e				                .byte %01111110
7965	>bbd7	00				                .byte %00000000

7967						                ; CHR$123 - {
7968	>bbd8	0c				                .byte %00001100
7969	>bbd9	18				                .byte %00011000
7970	>bbda	18				                .byte %00011000
7971	>bbdb	70				                .byte %01110000
7972	>bbdc	18				                .byte %00011000
7973	>bbdd	18				                .byte %00011000
7974	>bbde	0c				                .byte %00001100
7975	>bbdf	00				                .byte %00000000

7977						                ; CHR$124 - |
7978	>bbe0	18				                .byte %00011000
7979	>bbe1	18				                .byte %00011000
7980	>bbe2	18				                .byte %00011000
7981	>bbe3	00				                .byte %00000000
7982	>bbe4	18				                .byte %00011000
7983	>bbe5	18				                .byte %00011000
7984	>bbe6	18				                .byte %00011000
7985	>bbe7	00				                .byte %00000000

7987						                ; CHR$125 - }
7988	>bbe8	30				                .byte %00110000
7989	>bbe9	18				                .byte %00011000
7990	>bbea	18				                .byte %00011000
7991	>bbeb	0e				                .byte %00001110
7992	>bbec	18				                .byte %00011000
7993	>bbed	18				                .byte %00011000
7994	>bbee	30				                .byte %00110000
7995	>bbef	00				                .byte %00000000

7997						                ; CHR$126 - ~
7998	>bbf0	31				                .byte %00110001
7999	>bbf1	6b				                .byte %01101011
8000	>bbf2	46				                .byte %01000110
8001	>bbf3	00				                .byte %00000000
8002	>bbf4	00				                .byte %00000000
8003	>bbf5	00				                .byte %00000000
8004	>bbf6	00				                .byte %00000000
8005	>bbf7	00				                .byte %00000000

8007						                ; CHR$127
8008	.bbf8					chr127:
8009	>bbf8	ff				                .byte %11111111
8010	>bbf9	ff				                .byte %11111111
8011	>bbfa	ff				                .byte %11111111
8012	>bbfb	ff				                .byte %11111111
8013	>bbfc	ff				                .byte %11111111
8014	>bbfd	ff				                .byte %11111111
8015	>bbfe	ff				                .byte %11111111
8016	>bbff	ff				                .byte %11111111

8018						                ; CHR$128
8029	>bc00	66				                .byte %01100110
8030	>bc01	00				                .byte %00000000
8031	>bc02	3c				                .byte %00111100
8032	>bc03	66				                .byte %01100110
8033	>bc04	7e				                .byte %01111110
8034	>bc05	66				                .byte %01100110
8035	>bc06	66				                .byte %01100110
8036	>bc07	00				                .byte %00000000

8039						                ; CHR$129
8050	>bc08	3c				                .byte %00111100
8051	>bc09	66				                .byte %01100110
8052	>bc0a	3c				                .byte %00111100
8053	>bc0b	66				                .byte %01100110
8054	>bc0c	7e				                .byte %01111110
8055	>bc0d	66				                .byte %01100110
8056	>bc0e	66				                .byte %01100110
8057	>bc0f	00				                .byte %00000000

8060						                ; CHR$130
8061	>bc10	3f				                .byte %00111111
8062	>bc11	66				                .byte %01100110
8063	>bc12	66				                .byte %01100110
8064	>bc13	7f				                .byte %01111111
8065	>bc14	66				                .byte %01100110
8066	>bc15	66				                .byte %01100110
8067	>bc16	67				                .byte %01100111
8068	>bc17	00				                .byte %00000000

8070						                ; CHR$131
8081	>bc18	3c				                .byte %00111100
8082	>bc19	66				                .byte %01100110
8083	>bc1a	60				                .byte %01100000
8084	>bc1b	60				                .byte %01100000
8085	>bc1c	60				                .byte %01100000
8086	>bc1d	66				                .byte %01100110
8087	>bc1e	3c				                .byte %00111100
8088	>bc1f	60				                .byte %01100000

8091						                ; CHR$132
8092	>bc20	0c				                .byte %00001100
8093	>bc21	18				                .byte %00011000
8094	>bc22	7e				                .byte %01111110
8095	>bc23	60				                .byte %01100000
8096	>bc24	7c				                .byte %01111100
8097	>bc25	60				                .byte %01100000
8098	>bc26	7e				                .byte %01111110
8099	>bc27	00				                .byte %00000000

8101						                ; CHR$133
8112	>bc28	66				                .byte %01100110
8113	>bc29	3c				                .byte %00111100
8114	>bc2a	66				                .byte %01100110
8115	>bc2b	66				                .byte %01100110
8116	>bc2c	66				                .byte %01100110
8117	>bc2d	66				                .byte %01100110
8118	>bc2e	3c				                .byte %00111100
8119	>bc2f	00				                .byte %00000000

8122						                ; CHR$134
8123	>bc30	66				                .byte %01100110
8124	>bc31	00				                .byte %00000000
8125	>bc32	66				                .byte %01100110
8126	>bc33	66				                .byte %01100110
8127	>bc34	66				                .byte %01100110
8128	>bc35	66				                .byte %01100110
8129	>bc36	3c				                .byte %00111100
8130	>bc37	00				                .byte %00000000

8132						                ; CHR$135
8143	>bc38	7e				                .byte %01111110
8144	>bc39	c3				                .byte %11000011
8145	>bc3a	9d				                .byte %10011101
8146	>bc3b	b1				                .byte %10110001
8147	>bc3c	9d				                .byte %10011101
8148	>bc3d	c3				                .byte %11000011
8149	>bc3e	7e				                .byte %01111110
8150	>bc3f	00				                .byte %00000000

8153						                ; CHR$136
8154	>bc40	00				                .byte %00000000
8155	>bc41	18				                .byte %00011000
8156	>bc42	38				                .byte %00111000
8157	>bc43	7f				                .byte %01111111
8158	>bc44	38				                .byte %00111000
8159	>bc45	18				                .byte %00011000
8160	>bc46	00				                .byte %00000000
8161	>bc47	00				                .byte %00000000

8163						                ; CHR$137
8164	>bc48	00				                .byte %00000000
8165	>bc49	18				                .byte %00011000
8166	>bc4a	1c				                .byte %00011100
8167	>bc4b	fe				                .byte %11111110
8168	>bc4c	1c				                .byte %00011100
8169	>bc4d	18				                .byte %00011000
8170	>bc4e	00				                .byte %00000000
8171	>bc4f	00				                .byte %00000000

8173						                ; CHR$138
8174	>bc50	18				                .byte %00011000
8175	>bc51	18				                .byte %00011000
8176	>bc52	18				                .byte %00011000
8177	>bc53	18				                .byte %00011000
8178	>bc54	7e				                .byte %01111110
8179	>bc55	3c				                .byte %00111100
8180	>bc56	18				                .byte %00011000
8181	>bc57	00				                .byte %00000000

8183						                ; CHR$139
8184	>bc58	00				                .byte %00000000
8185	>bc59	18				                .byte %00011000
8186	>bc5a	3c				                .byte %00111100
8187	>bc5b	7e				                .byte %01111110
8188	>bc5c	18				                .byte %00011000
8189	>bc5d	18				                .byte %00011000
8190	>bc5e	18				                .byte %00011000
8191	>bc5f	18				                .byte %00011000

8193						                ; CHR$140
8194	>bc60	30				                .byte %00110000
8195	>bc61	18				                .byte %00011000
8196	>bc62	3c				                .byte %00111100
8197	>bc63	06				                .byte %00000110
8198	>bc64	3e				                .byte %00111110
8199	>bc65	66				                .byte %01100110
8200	>bc66	3e				                .byte %00111110
8201	>bc67	00				                .byte %00000000

8203						                ; CHR$141
8204	>bc68	30				                .byte %00110000
8205	>bc69	18				                .byte %00011000
8206	>bc6a	3c				                .byte %00111100
8207	>bc6b	66				                .byte %01100110
8208	>bc6c	7e				                .byte %01111110
8209	>bc6d	60				                .byte %01100000
8210	>bc6e	3c				                .byte %00111100
8211	>bc6f	00				                .byte %00000000

8213						                ; CHR$142
8214	>bc70	66				                .byte %01100110
8215	>bc71	00				                .byte %00000000
8216	>bc72	3c				                .byte %00111100
8217	>bc73	66				                .byte %01100110
8218	>bc74	7e				                .byte %01111110
8219	>bc75	60				                .byte %01100000
8220	>bc76	3c				                .byte %00111100
8221	>bc77	00				                .byte %00000000

8223						                ; CHR$143
8224	>bc78	3c				                .byte %00111100
8225	>bc79	66				                .byte %01100110
8226	>bc7a	3c				                .byte %00111100
8227	>bc7b	66				                .byte %01100110
8228	>bc7c	7e				                .byte %01111110
8229	>bc7d	60				                .byte %01100000
8230	>bc7e	3c				                .byte %00111100
8231	>bc7f	00				                .byte %00000000

8233						                ; CHR$144
8234	>bc80	66				                .byte %01100110
8235	>bc81	00				                .byte %00000000
8236	>bc82	3c				                .byte %00111100
8237	>bc83	06				                .byte %00000110
8238	>bc84	3e				                .byte %00111110
8239	>bc85	66				                .byte %01100110
8240	>bc86	3e				                .byte %00111110
8241	>bc87	00				                .byte %00000000

8243						                ; CHR$145
8244	>bc88	3c				                .byte %00111100
8245	>bc89	66				                .byte %01100110
8246	>bc8a	3c				                .byte %00111100
8247	>bc8b	06				                .byte %00000110
8248	>bc8c	3e				                .byte %00111110
8249	>bc8d	66				                .byte %01100110
8250	>bc8e	3e				                .byte %00111110
8251	>bc8f	00				                .byte %00000000

8253						                ; CHR$146
8254	>bc90	00				                .byte %00000000
8255	>bc91	00				                .byte %00000000
8256	>bc92	3f				                .byte %00111111
8257	>bc93	0d				                .byte %00001101
8258	>bc94	3f				                .byte %00111111
8259	>bc95	6c				                .byte %01101100
8260	>bc96	3f				                .byte %00111111
8261	>bc97	00				                .byte %00000000

8263						                ; CHR$147
8264	>bc98	00				                .byte %00000000
8265	>bc99	00				                .byte %00000000
8266	>bc9a	3c				                .byte %00111100
8267	>bc9b	66				                .byte %01100110
8268	>bc9c	60				                .byte %01100000
8269	>bc9d	66				                .byte %01100110
8270	>bc9e	3c				                .byte %00111100
8271	>bc9f	60				                .byte %01100000

8273						                ; CHR$148
8274	>bca0	0c				                .byte %00001100
8275	>bca1	18				                .byte %00011000
8276	>bca2	3c				                .byte %00111100
8277	>bca3	66				                .byte %01100110
8278	>bca4	7e				                .byte %01111110
8279	>bca5	60				                .byte %01100000
8280	>bca6	3c				                .byte %00111100
8281	>bca7	00				                .byte %00000000

8283						                ; CHR$149
8294	>bca8	66				                .byte %01100110
8295	>bca9	00				                .byte %00000000
8296	>bcaa	3c				                .byte %00111100
8297	>bcab	66				                .byte %01100110
8298	>bcac	66				                .byte %01100110
8299	>bcad	66				                .byte %01100110
8300	>bcae	3c				                .byte %00111100
8301	>bcaf	00				                .byte %00000000

8304						                ; CHR$150
8315	>bcb0	66				                .byte %01100110
8316	>bcb1	00				                .byte %00000000
8317	>bcb2	66				                .byte %01100110
8318	>bcb3	66				                .byte %01100110
8319	>bcb4	66				                .byte %01100110
8320	>bcb5	66				                .byte %01100110
8321	>bcb6	3e				                .byte %00111110
8322	>bcb7	00				                .byte %00000000

8325						                ; CHR$151
8326	>bcb8	30				                .byte %00110000
8327	>bcb9	18				                .byte %00011000
8328	>bcba	00				                .byte %00000000
8329	>bcbb	38				                .byte %00111000
8330	>bcbc	18				                .byte %00011000
8331	>bcbd	18				                .byte %00011000
8332	>bcbe	3c				                .byte %00111100
8333	>bcbf	00				                .byte %00000000

8335						                ; CHR$152
8336	>bcc0	3c				                .byte %00111100
8337	>bcc1	66				                .byte %01100110
8338	>bcc2	00				                .byte %00000000
8339	>bcc3	38				                .byte %00111000
8340	>bcc4	18				                .byte %00011000
8341	>bcc5	18				                .byte %00011000
8342	>bcc6	3c				                .byte %00111100
8343	>bcc7	00				                .byte %00000000

8345						                ; CHR$153
8346	>bcc8	30				                .byte %00110000
8347	>bcc9	18				                .byte %00011000
8348	>bcca	00				                .byte %00000000
8349	>bccb	3c				                .byte %00111100
8350	>bccc	66				                .byte %01100110
8351	>bccd	66				                .byte %01100110
8352	>bcce	3c				                .byte %00111100
8353	>bccf	00				                .byte %00000000

8355						                ; CHR$154
8356	>bcd0	3c				                .byte %00111100
8357	>bcd1	66				                .byte %01100110
8358	>bcd2	00				                .byte %00000000
8359	>bcd3	3c				                .byte %00111100
8360	>bcd4	66				                .byte %01100110
8361	>bcd5	66				                .byte %01100110
8362	>bcd6	3c				                .byte %00111100
8363	>bcd7	00				                .byte %00000000

8365						                ; CHR$155
8366	>bcd8	30				                .byte %00110000
8367	>bcd9	18				                .byte %00011000
8368	>bcda	00				                .byte %00000000
8369	>bcdb	66				                .byte %01100110
8370	>bcdc	66				                .byte %01100110
8371	>bcdd	66				                .byte %01100110
8372	>bcde	3e				                .byte %00111110
8373	>bcdf	00				                .byte %00000000

8375						                ; CHR$156
8376	>bce0	3c				                .byte %00111100
8377	>bce1	66				                .byte %01100110
8378	>bce2	00				                .byte %00000000
8379	>bce3	66				                .byte %01100110
8380	>bce4	66				                .byte %01100110
8381	>bce5	66				                .byte %01100110
8382	>bce6	3e				                .byte %00111110
8383	>bce7	00				                .byte %00000000

8385						                ; CHR$157
8386	>bce8	66				                .byte %01100110
8387	>bce9	00				                .byte %00000000
8388	>bcea	66				                .byte %01100110
8389	>bceb	66				                .byte %01100110
8390	>bcec	66				                .byte %01100110
8391	>bced	3e				                .byte %00111110
8392	>bcee	06				                .byte %00000110
8393	>bcef	3c				                .byte %00111100

8395						                ; CHR$158
8396	>bcf0	00				                .byte %00000000
8397	>bcf1	66				                .byte %01100110
8398	>bcf2	3c				                .byte %00111100
8399	>bcf3	66				                .byte %01100110
8400	>bcf4	66				                .byte %01100110
8401	>bcf5	3c				                .byte %00111100
8402	>bcf6	66				                .byte %01100110
8403	>bcf7	00				                .byte %00000000

8405						                ; CHR$159
8406	>bcf8	3c				                .byte %00111100
8407	>bcf9	60				                .byte %01100000
8408	>bcfa	3c				                .byte %00111100
8409	>bcfb	66				                .byte %01100110
8410	>bcfc	3c				                .byte %00111100
8411	>bcfd	06				                .byte %00000110
8412	>bcfe	3c				                .byte %00111100
8413	>bcff	00				                .byte %00000000

8415						                ; CHR$160
8416	>bd00	3c				                .byte %00111100
8417	>bd01	66				                .byte %01100110
8418	>bd02	3c				                .byte %00111100
8419	>bd03	00				                .byte %00000000
8420	>bd04	00				                .byte %00000000
8421	>bd05	00				                .byte %00000000
8422	>bd06	00				                .byte %00000000
8423	>bd07	00				                .byte %00000000

8425						                ; CHR$161
8426	>bd08	00				                .byte %00000000
8427	>bd09	00				                .byte %00000000
8428	>bd0a	00				                .byte %00000000
8429	>bd0b	18				                .byte %00011000
8430	>bd0c	18				                .byte %00011000
8431	>bd0d	18				                .byte %00011000
8432	>bd0e	18				                .byte %00011000
8433	>bd0f	18				                .byte %00011000

8435						                ; CHR$162
8436	>bd10	00				                .byte %00000000
8437	>bd11	00				                .byte %00000000
8438	>bd12	00				                .byte %00000000
8439	>bd13	1f				                .byte %00011111
8440	>bd14	00				                .byte %00000000
8441	>bd15	00				                .byte %00000000
8442	>bd16	00				                .byte %00000000
8443	>bd17	00				                .byte %00000000

8445						                ; CHR$163
8446	>bd18	00				                .byte %00000000
8447	>bd19	00				                .byte %00000000
8448	>bd1a	00				                .byte %00000000
8449	>bd1b	1f				                .byte %00011111
8450	>bd1c	18				                .byte %00011000
8451	>bd1d	18				                .byte %00011000
8452	>bd1e	18				                .byte %00011000
8453	>bd1f	18				                .byte %00011000

8455						                ; CHR$164
8456	>bd20	00				                .byte %00000000
8457	>bd21	00				                .byte %00000000
8458	>bd22	00				                .byte %00000000
8459	>bd23	f8				                .byte %11111000
8460	>bd24	00				                .byte %00000000
8461	>bd25	00				                .byte %00000000
8462	>bd26	00				                .byte %00000000
8463	>bd27	00				                .byte %00000000

8465						                ; CHR$165
8466	>bd28	00				                .byte %00000000
8467	>bd29	00				                .byte %00000000
8468	>bd2a	00				                .byte %00000000
8469	>bd2b	f8				                .byte %11111000
8470	>bd2c	18				                .byte %00011000
8471	>bd2d	18				                .byte %00011000
8472	>bd2e	18				                .byte %00011000
8473	>bd2f	18				                .byte %00011000

8475						                ; CHR$166
8476	>bd30	00				                .byte %00000000
8477	>bd31	00				                .byte %00000000
8478	>bd32	00				                .byte %00000000
8479	>bd33	ff				                .byte %11111111
8480	>bd34	00				                .byte %00000000
8481	>bd35	00				                .byte %00000000
8482	>bd36	00				                .byte %00000000
8483	>bd37	00				                .byte %00000000

8485						                ; CHR$167
8486	>bd38	00				                .byte %00000000
8487	>bd39	00				                .byte %00000000
8488	>bd3a	00				                .byte %00000000
8489	>bd3b	ff				                .byte %11111111
8490	>bd3c	18				                .byte %00011000
8491	>bd3d	18				                .byte %00011000
8492	>bd3e	18				                .byte %00011000
8493	>bd3f	18				                .byte %00011000

8495						                ; CHR$168
8496	>bd40	18				                .byte %00011000
8497	>bd41	18				                .byte %00011000
8498	>bd42	18				                .byte %00011000
8499	>bd43	18				                .byte %00011000
8500	>bd44	00				                .byte %00000000
8501	>bd45	00				                .byte %00000000
8502	>bd46	00				                .byte %00000000
8503	>bd47	00				                .byte %00000000

8505						                ; CHR$169
8506	>bd48	18				                .byte %00011000
8507	>bd49	18				                .byte %00011000
8508	>bd4a	18				                .byte %00011000
8509	>bd4b	18				                .byte %00011000
8510	>bd4c	18				                .byte %00011000
8511	>bd4d	18				                .byte %00011000
8512	>bd4e	18				                .byte %00011000
8513	>bd4f	18				                .byte %00011000

8515						                ; CHR$170
8516	>bd50	18				                .byte %00011000
8517	>bd51	18				                .byte %00011000
8518	>bd52	18				                .byte %00011000
8519	>bd53	1f				                .byte %00011111
8520	>bd54	00				                .byte %00000000
8521	>bd55	00				                .byte %00000000
8522	>bd56	00				                .byte %00000000
8523	>bd57	00				                .byte %00000000

8525						                ; CHR$171
8526	>bd58	18				                .byte %00011000
8527	>bd59	18				                .byte %00011000
8528	>bd5a	18				                .byte %00011000
8529	>bd5b	1f				                .byte %00011111
8530	>bd5c	18				                .byte %00011000
8531	>bd5d	18				                .byte %00011000
8532	>bd5e	18				                .byte %00011000
8533	>bd5f	18				                .byte %00011000

8535						                ; CHR$172
8536	>bd60	18				                .byte %00011000
8537	>bd61	18				                .byte %00011000
8538	>bd62	18				                .byte %00011000
8539	>bd63	f8				                .byte %11111000
8540	>bd64	00				                .byte %00000000
8541	>bd65	00				                .byte %00000000
8542	>bd66	00				                .byte %00000000
8543	>bd67	00				                .byte %00000000

8545						                ; CHR$173
8546	>bd68	18				                .byte %00011000
8547	>bd69	18				                .byte %00011000
8548	>bd6a	18				                .byte %00011000
8549	>bd6b	f8				                .byte %11111000
8550	>bd6c	18				                .byte %00011000
8551	>bd6d	18				                .byte %00011000
8552	>bd6e	18				                .byte %00011000
8553	>bd6f	18				                .byte %00011000

8555						                ; CHR$174
8556	>bd70	18				                .byte %00011000
8557	>bd71	18				                .byte %00011000
8558	>bd72	18				                .byte %00011000
8559	>bd73	ff				                .byte %11111111
8560	>bd74	00				                .byte %00000000
8561	>bd75	00				                .byte %00000000
8562	>bd76	00				                .byte %00000000
8563	>bd77	00				                .byte %00000000

8565						                ; CHR$175
8566	>bd78	18				                .byte %00011000
8567	>bd79	18				                .byte %00011000
8568	>bd7a	18				                .byte %00011000
8569	>bd7b	ff				                .byte %11111111
8570	>bd7c	18				                .byte %00011000
8571	>bd7d	18				                .byte %00011000
8572	>bd7e	18				                .byte %00011000
8573	>bd7f	18				                .byte %00011000

8575						                ; CHR$176
8576	>bd80	00				                .byte %00000000
8577	>bd81	00				                .byte %00000000
8578	>bd82	00				                .byte %00000000
8579	>bd83	07				                .byte %00000111
8580	>bd84	0c				                .byte %00001100
8581	>bd85	18				                .byte %00011000
8582	>bd86	18				                .byte %00011000
8583	>bd87	18				                .byte %00011000

8585						                ; CHR$177
8586	>bd88	00				                .byte %00000000
8587	>bd89	00				                .byte %00000000
8588	>bd8a	00				                .byte %00000000
8589	>bd8b	e0				                .byte %11100000
8590	>bd8c	30				                .byte %00110000
8591	>bd8d	18				                .byte %00011000
8592	>bd8e	18				                .byte %00011000
8593	>bd8f	18				                .byte %00011000

8595						                ; CHR$178
8596	>bd90	18				                .byte %00011000
8597	>bd91	18				                .byte %00011000
8598	>bd92	0c				                .byte %00001100
8599	>bd93	07				                .byte %00000111
8600	>bd94	00				                .byte %00000000
8601	>bd95	00				                .byte %00000000
8602	>bd96	00				                .byte %00000000
8603	>bd97	00				                .byte %00000000

8605						                ; CHR$179
8606	>bd98	18				                .byte %00011000
8607	>bd99	18				                .byte %00011000
8608	>bd9a	30				                .byte %00110000
8609	>bd9b	e0				                .byte %11100000
8610	>bd9c	00				                .byte %00000000
8611	>bd9d	00				                .byte %00000000
8612	>bd9e	00				                .byte %00000000
8613	>bd9f	00				                .byte %00000000

8615						                ; CHR$180
8616	>bda0	18				                .byte %00011000
8617	>bda1	00				                .byte %00000000
8618	>bda2	18				                .byte %00011000
8619	>bda3	18				                .byte %00011000
8620	>bda4	30				                .byte %00110000
8621	>bda5	66				                .byte %01100110
8622	>bda6	3c				                .byte %00111100
8623	>bda7	00				                .byte %00000000

8625						                ; CHR$181
8626	>bda8	18				                .byte %00011000
8627	>bda9	00				                .byte %00000000
8628	>bdaa	18				                .byte %00011000
8629	>bdab	18				                .byte %00011000
8630	>bdac	18				                .byte %00011000
8631	>bdad	18				                .byte %00011000
8632	>bdae	18				                .byte %00011000
8633	>bdaf	00				                .byte %00000000

8635						                ; CHR$182
8636	>bdb0	36				                .byte %00110110
8637	>bdb1	6c				                .byte %01101100
8638	>bdb2	00				                .byte %00000000
8639	>bdb3	66				                .byte %01100110
8640	>bdb4	76				                .byte %01110110
8641	>bdb5	6e				                .byte %01101110
8642	>bdb6	66				                .byte %01100110
8643	>bdb7	00				                .byte %00000000

8645						                ; CHR$183
8646	>bdb8	36				                .byte %00110110
8647	>bdb9	6c				                .byte %01101100
8648	>bdba	00				                .byte %00000000
8649	>bdbb	7c				                .byte %01111100
8650	>bdbc	66				                .byte %01100110
8651	>bdbd	66				                .byte %01100110
8652	>bdbe	66				                .byte %01100110
8653	>bdbf	00				                .byte %00000000

8655						                ; CHR$184
8656	>bdc0	18				                .byte %00011000
8657	>bdc1	7e				                .byte %01111110
8658	>bdc2	18				                .byte %00011000
8659	>bdc3	18				                .byte %00011000
8660	>bdc4	18				                .byte %00011000
8661	>bdc5	18				                .byte %00011000
8662	>bdc6	18				                .byte %00011000
8663	>bdc7	00				                .byte %00000000

8665						                ; CHR$185
8666	>bdc8	18				                .byte %00011000
8667	>bdc9	7e				                .byte %01111110
8668	>bdca	18				                .byte %00011000
8669	>bdcb	18				                .byte %00011000
8670	>bdcc	18				                .byte %00011000
8671	>bdcd	7e				                .byte %01111110
8672	>bdce	18				                .byte %00011000
8673	>bdcf	00				                .byte %00000000

8675						                ; CHR$186
8686	>bdd0	18				                .byte %00011000
8687	>bdd1	18				                .byte %00011000
8688	>bdd2	18				                .byte %00011000
8689	>bdd3	00				                .byte %00000000
8690	>bdd4	00				                .byte %00000000
8691	>bdd5	00				                .byte %00000000
8692	>bdd6	00				                .byte %00000000
8693	>bdd7	00				                .byte %00000000

8696						                ; CHR$187
8707	>bdd8	30				                .byte %00110000
8708	>bdd9	18				                .byte %00011000
8709	>bdda	0c				                .byte %00001100
8710	>bddb	00				                .byte %00000000
8711	>bddc	00				                .byte %00000000
8712	>bddd	00				                .byte %00000000
8713	>bdde	00				                .byte %00000000
8714	>bddf	00				                .byte %00000000

8717						                ; CHR$188
8728	>bde0	3f				                .byte %00111111
8729	>bde1	7b				                .byte %01111011
8730	>bde2	7b				                .byte %01111011
8731	>bde3	3b				                .byte %00111011
8732	>bde4	1b				                .byte %00011011
8733	>bde5	1b				                .byte %00011011
8734	>bde6	1f				                .byte %00011111
8735	>bde7	00				                .byte %00000000

8738						                ; CHR$189
8739	>bde8	00				                .byte %00000000
8740	>bde9	00				                .byte %00000000
8741	>bdea	00				                .byte %00000000
8742	>bdeb	18				                .byte %00011000
8743	>bdec	18				                .byte %00011000
8744	>bded	00				                .byte %00000000
8745	>bdee	00				                .byte %00000000
8746	>bdef	00				                .byte %00000000

8748						                ; CHR$190
8749	>bdf0	03				                .byte %00000011
8750	>bdf1	03				                .byte %00000011
8751	>bdf2	06				                .byte %00000110
8752	>bdf3	06				                .byte %00000110
8753	>bdf4	76				                .byte %01110110
8754	>bdf5	1c				                .byte %00011100
8755	>bdf6	0c				                .byte %00001100
8756	>bdf7	00				                .byte %00000000

8758						                ; CHR$191
8759	>bdf8	aa				                .byte %10101010
8760	>bdf9	55				                .byte %01010101
8761	>bdfa	aa				                .byte %10101010
8762	>bdfb	55				                .byte %01010101
8763	>bdfc	aa				                .byte %10101010
8764	>bdfd	55				                .byte %01010101
8765	>bdfe	aa				                .byte %10101010
8766	>bdff	55				                .byte %01010101

8768						                ; CHR$192
8769	>be00	3e				                .byte %00111110
8770	>be01	63				                .byte %01100011
8771	>be02	67				                .byte %01100111
8772	>be03	6b				                .byte %01101011
8773	>be04	73				                .byte %01110011
8774	>be05	63				                .byte %01100011
8775	>be06	3e				                .byte %00111110
8776	>be07	00				                .byte %00000000

8778						                ; CHR$193
8779	>be08	1c				                .byte %00011100
8780	>be09	36				                .byte %00110110
8781	>be0a	63				                .byte %01100011
8782	>be0b	63				                .byte %01100011
8783	>be0c	7f				                .byte %01111111
8784	>be0d	63				                .byte %01100011
8785	>be0e	63				                .byte %01100011
8786	>be0f	00				                .byte %00000000

8788						                ; CHR$194
8789	>be10	7e				                .byte %01111110
8790	>be11	33				                .byte %00110011
8791	>be12	33				                .byte %00110011
8792	>be13	3e				                .byte %00111110
8793	>be14	33				                .byte %00110011
8794	>be15	33				                .byte %00110011
8795	>be16	7e				                .byte %01111110
8796	>be17	00				                .byte %00000000

8798						                ; CHR$195
8799	>be18	7f				                .byte %01111111
8800	>be19	63				                .byte %01100011
8801	>be1a	60				                .byte %01100000
8802	>be1b	60				                .byte %01100000
8803	>be1c	60				                .byte %01100000
8804	>be1d	60				                .byte %01100000
8805	>be1e	60				                .byte %01100000
8806	>be1f	00				                .byte %00000000

8808						                ; CHR$196
8809	>be20	1c				                .byte %00011100
8810	>be21	1c				                .byte %00011100
8811	>be22	36				                .byte %00110110
8812	>be23	36				                .byte %00110110
8813	>be24	63				                .byte %01100011
8814	>be25	63				                .byte %01100011
8815	>be26	7f				                .byte %01111111
8816	>be27	00				                .byte %00000000

8818						                ; CHR$197
8819	>be28	7f				                .byte %01111111
8820	>be29	33				                .byte %00110011
8821	>be2a	30				                .byte %00110000
8822	>be2b	3e				                .byte %00111110
8823	>be2c	30				                .byte %00110000
8824	>be2d	33				                .byte %00110011
8825	>be2e	7f				                .byte %01111111
8826	>be2f	00				                .byte %00000000

8828						                ; CHR$198
8829	>be30	7e				                .byte %01111110
8830	>be31	66				                .byte %01100110
8831	>be32	0c				                .byte %00001100
8832	>be33	18				                .byte %00011000
8833	>be34	30				                .byte %00110000
8834	>be35	66				                .byte %01100110
8835	>be36	7e				                .byte %01111110
8836	>be37	00				                .byte %00000000

8838						                ; CHR$199
8839	>be38	77				                .byte %01110111
8840	>be39	33				                .byte %00110011
8841	>be3a	33				                .byte %00110011
8842	>be3b	3f				                .byte %00111111
8843	>be3c	33				                .byte %00110011
8844	>be3d	33				                .byte %00110011
8845	>be3e	77				                .byte %01110111
8846	>be3f	00				                .byte %00000000

8848						                ; CHR$200
8849	>be40	3e				                .byte %00111110
8850	>be41	63				                .byte %01100011
8851	>be42	63				                .byte %01100011
8852	>be43	7f				                .byte %01111111
8853	>be44	63				                .byte %01100011
8854	>be45	63				                .byte %01100011
8855	>be46	3e				                .byte %00111110
8856	>be47	00				                .byte %00000000

8858						                ; CHR$201
8859	>be48	3c				                .byte %00111100
8860	>be49	18				                .byte %00011000
8861	>be4a	18				                .byte %00011000
8862	>be4b	18				                .byte %00011000
8863	>be4c	18				                .byte %00011000
8864	>be4d	18				                .byte %00011000
8865	>be4e	3c				                .byte %00111100
8866	>be4f	00				                .byte %00000000

8868						                ; CHR$202
8869	>be50	63				                .byte %01100011
8870	>be51	66				                .byte %01100110
8871	>be52	6c				                .byte %01101100
8872	>be53	78				                .byte %01111000
8873	>be54	6c				                .byte %01101100
8874	>be55	66				                .byte %01100110
8875	>be56	63				                .byte %01100011
8876	>be57	00				                .byte %00000000

8878						                ; CHR$203
8879	>be58	1c				                .byte %00011100
8880	>be59	1c				                .byte %00011100
8881	>be5a	36				                .byte %00110110
8882	>be5b	36				                .byte %00110110
8883	>be5c	63				                .byte %01100011
8884	>be5d	63				                .byte %01100011
8885	>be5e	63				                .byte %01100011
8886	>be5f	00				                .byte %00000000

8888						                ; CHR$204
8889	>be60	63				                .byte %01100011
8890	>be61	77				                .byte %01110111
8891	>be62	7f				                .byte %01111111
8892	>be63	6b				                .byte %01101011
8893	>be64	63				                .byte %01100011
8894	>be65	63				                .byte %01100011
8895	>be66	63				                .byte %01100011
8896	>be67	00				                .byte %00000000

8898						                ; CHR$205
8899	>be68	63				                .byte %01100011
8900	>be69	73				                .byte %01110011
8901	>be6a	7b				                .byte %01111011
8902	>be6b	6f				                .byte %01101111
8903	>be6c	67				                .byte %01100111
8904	>be6d	63				                .byte %01100011
8905	>be6e	63				                .byte %01100011
8906	>be6f	00				                .byte %00000000

8908						                ; CHR$206
8909	>be70	7e				                .byte %01111110
8910	>be71	00				                .byte %00000000
8911	>be72	00				                .byte %00000000
8912	>be73	3c				                .byte %00111100
8913	>be74	00				                .byte %00000000
8914	>be75	00				                .byte %00000000
8915	>be76	7e				                .byte %01111110
8916	>be77	00				                .byte %00000000

8918						                ; CHR$207
8919	>be78	3e				                .byte %00111110
8920	>be79	63				                .byte %01100011
8921	>be7a	63				                .byte %01100011
8922	>be7b	63				                .byte %01100011
8923	>be7c	63				                .byte %01100011
8924	>be7d	63				                .byte %01100011
8925	>be7e	3e				                .byte %00111110
8926	>be7f	00				                .byte %00000000

8928						                ; CHR$208
8929	>be80	7f				                .byte %01111111
8930	>be81	36				                .byte %00110110
8931	>be82	36				                .byte %00110110
8932	>be83	36				                .byte %00110110
8933	>be84	36				                .byte %00110110
8934	>be85	36				                .byte %00110110
8935	>be86	36				                .byte %00110110
8936	>be87	00				                .byte %00000000

8938						                ; CHR$209
8939	>be88	7e				                .byte %01111110
8940	>be89	33				                .byte %00110011
8941	>be8a	33				                .byte %00110011
8942	>be8b	3e				                .byte %00111110
8943	>be8c	30				                .byte %00110000
8944	>be8d	30				                .byte %00110000
8945	>be8e	78				                .byte %01111000
8946	>be8f	00				                .byte %00000000

8948						                ; CHR$210
8949	>be90	7f				                .byte %01111111
8950	>be91	63				                .byte %01100011
8951	>be92	30				                .byte %00110000
8952	>be93	18				                .byte %00011000
8953	>be94	30				                .byte %00110000
8954	>be95	63				                .byte %01100011
8955	>be96	7f				                .byte %01111111
8956	>be97	00				                .byte %00000000

8958						                ; CHR$211
8959	>be98	7e				                .byte %01111110
8960	>be99	5a				                .byte %01011010
8961	>be9a	18				                .byte %00011000
8962	>be9b	18				                .byte %00011000
8963	>be9c	18				                .byte %00011000
8964	>be9d	18				                .byte %00011000
8965	>be9e	18				                .byte %00011000
8966	>be9f	00				                .byte %00000000

8968						                ; CHR$212
8969	>bea0	66				                .byte %01100110
8970	>bea1	66				                .byte %01100110
8971	>bea2	66				                .byte %01100110
8972	>bea3	3c				                .byte %00111100
8973	>bea4	18				                .byte %00011000
8974	>bea5	18				                .byte %00011000
8975	>bea6	3c				                .byte %00111100
8976	>bea7	00				                .byte %00000000

8978						                ; CHR$213
8979	>bea8	3e				                .byte %00111110
8980	>bea9	08				                .byte %00001000
8981	>beaa	3e				                .byte %00111110
8982	>beab	6b				                .byte %01101011
8983	>beac	3e				                .byte %00111110
8984	>bead	08				                .byte %00001000
8985	>beae	3e				                .byte %00111110
8986	>beaf	00				                .byte %00000000

8988						                ; CHR$214
8989	>beb0	63				                .byte %01100011
8990	>beb1	63				                .byte %01100011
8991	>beb2	36				                .byte %00110110
8992	>beb3	1c				                .byte %00011100
8993	>beb4	36				                .byte %00110110
8994	>beb5	63				                .byte %01100011
8995	>beb6	63				                .byte %01100011
8996	>beb7	00				                .byte %00000000

8998						                ; CHR$215
8999	>beb8	3e				                .byte %00111110
9000	>beb9	08				                .byte %00001000
9001	>beba	6b				                .byte %01101011
9002	>bebb	6b				                .byte %01101011
9003	>bebc	3e				                .byte %00111110
9004	>bebd	08				                .byte %00001000
9005	>bebe	3e				                .byte %00111110
9006	>bebf	00				                .byte %00000000

9008						                ; CHR$216
9009	>bec0	3e				                .byte %00111110
9010	>bec1	63				                .byte %01100011
9011	>bec2	63				                .byte %01100011
9012	>bec3	63				                .byte %01100011
9013	>bec4	36				                .byte %00110110
9014	>bec5	36				                .byte %00110110
9015	>bec6	63				                .byte %01100011
9016	>bec7	00				                .byte %00000000

9018						                ; CHR$217
9019	>bec8	7f				                .byte %01111111
9020	>bec9	63				                .byte %01100011
9021	>beca	63				                .byte %01100011
9022	>becb	36				                .byte %00110110
9023	>becc	36				                .byte %00110110
9024	>becd	1c				                .byte %00011100
9025	>bece	1c				                .byte %00011100
9026	>becf	00				                .byte %00000000

9028						                ; CHR$218
9029	>bed0	18				                .byte %00011000
9030	>bed1	18				                .byte %00011000
9031	>bed2	7e				                .byte %01111110
9032	>bed3	18				                .byte %00011000
9033	>bed4	18				                .byte %00011000
9034	>bed5	00				                .byte %00000000
9035	>bed6	7e				                .byte %01111110
9036	>bed7	00				                .byte %00000000

9038						                ; CHR$219
9039	>bed8	00				                .byte %00000000
9040	>bed9	7e				                .byte %01111110
9041	>beda	00				                .byte %00000000
9042	>bedb	18				                .byte %00011000
9043	>bedc	18				                .byte %00011000
9044	>bedd	7e				                .byte %01111110
9045	>bede	18				                .byte %00011000
9046	>bedf	18				                .byte %00011000

9048						                ; CHR$220
9049	>bee0	18				                .byte %00011000
9050	>bee1	18				                .byte %00011000
9051	>bee2	18				                .byte %00011000
9052	>bee3	18				                .byte %00011000
9053	>bee4	18				                .byte %00011000
9054	>bee5	18				                .byte %00011000
9055	>bee6	18				                .byte %00011000
9056	>bee7	00				                .byte %00000000

9058						                ; CHR$221
9059	>bee8	36				                .byte %00110110
9060	>bee9	36				                .byte %00110110
9061	>beea	36				                .byte %00110110
9062	>beeb	36				                .byte %00110110
9063	>beec	36				                .byte %00110110
9064	>beed	36				                .byte %00110110
9065	>beee	36				                .byte %00110110
9066	>beef	00				                .byte %00000000

9068						                ; CHR$222
9069	>bef0	00				                .byte %00000000
9070	>bef1	66				                .byte %01100110
9071	>bef2	66				                .byte %01100110
9072	>bef3	66				                .byte %01100110
9073	>bef4	66				                .byte %01100110
9074	>bef5	66				                .byte %01100110
9075	>bef6	3c				                .byte %00111100
9076	>bef7	00				                .byte %00000000

9078						                ; CHR$223
9079	>bef8	00				                .byte %00000000
9080	>bef9	3c				                .byte %00111100
9081	>befa	66				                .byte %01100110
9082	>befb	66				                .byte %01100110
9083	>befc	66				                .byte %01100110
9084	>befd	66				                .byte %01100110
9085	>befe	66				                .byte %01100110
9086	>beff	00				                .byte %00000000

9088						                ; CHR$224
9099	>bf00	00				                .byte %00000000
9100	>bf01	03				                .byte %00000011
9101	>bf02	3e				                .byte %00111110
9102	>bf03	67				                .byte %01100111
9103	>bf04	6b				                .byte %01101011
9104	>bf05	73				                .byte %01110011
9105	>bf06	3e				                .byte %00111110
9106	>bf07	60				                .byte %01100000

9109						                ; CHR$225
9110	>bf08	00				                .byte %00000000
9111	>bf09	00				                .byte %00000000
9112	>bf0a	3b				                .byte %00111011
9113	>bf0b	6e				                .byte %01101110
9114	>bf0c	66				                .byte %01100110
9115	>bf0d	6e				                .byte %01101110
9116	>bf0e	3b				                .byte %00111011
9117	>bf0f	00				                .byte %00000000

9119						                ; CHR$226
9120	>bf10	1e				                .byte %00011110
9121	>bf11	33				                .byte %00110011
9122	>bf12	33				                .byte %00110011
9123	>bf13	3e				                .byte %00111110
9124	>bf14	33				                .byte %00110011
9125	>bf15	33				                .byte %00110011
9126	>bf16	3e				                .byte %00111110
9127	>bf17	60				                .byte %01100000

9129						                ; CHR$227
9130	>bf18	00				                .byte %00000000
9131	>bf19	00				                .byte %00000000
9132	>bf1a	66				                .byte %01100110
9133	>bf1b	36				                .byte %00110110
9134	>bf1c	1c				                .byte %00011100
9135	>bf1d	18				                .byte %00011000
9136	>bf1e	30				                .byte %00110000
9137	>bf1f	30				                .byte %00110000

9139						                ; CHR$228
9140	>bf20	3c				                .byte %00111100
9141	>bf21	60				                .byte %01100000
9142	>bf22	30				                .byte %00110000
9143	>bf23	3c				                .byte %00111100
9144	>bf24	66				                .byte %01100110
9145	>bf25	66				                .byte %01100110
9146	>bf26	3c				                .byte %00111100
9147	>bf27	00				                .byte %00000000

9149						                ; CHR$229
9150	>bf28	00				                .byte %00000000
9151	>bf29	00				                .byte %00000000
9152	>bf2a	1e				                .byte %00011110
9153	>bf2b	30				                .byte %00110000
9154	>bf2c	1c				                .byte %00011100
9155	>bf2d	30				                .byte %00110000
9156	>bf2e	1e				                .byte %00011110
9157	>bf2f	00				                .byte %00000000

9159						                ; CHR$230
9160	>bf30	3e				                .byte %00111110
9161	>bf31	0c				                .byte %00001100
9162	>bf32	18				                .byte %00011000
9163	>bf33	30				                .byte %00110000
9164	>bf34	60				                .byte %01100000
9165	>bf35	60				                .byte %01100000
9166	>bf36	3e				                .byte %00111110
9167	>bf37	06				                .byte %00000110

9169						                ; CHR$231
9170	>bf38	00				                .byte %00000000
9171	>bf39	00				                .byte %00000000
9172	>bf3a	7c				                .byte %01111100
9173	>bf3b	66				                .byte %01100110
9174	>bf3c	66				                .byte %01100110
9175	>bf3d	66				                .byte %01100110
9176	>bf3e	06				                .byte %00000110
9177	>bf3f	06				                .byte %00000110

9179						                ; CHR$232
9180	>bf40	3c				                .byte %00111100
9181	>bf41	66				                .byte %01100110
9182	>bf42	66				                .byte %01100110
9183	>bf43	7e				                .byte %01111110
9184	>bf44	66				                .byte %01100110
9185	>bf45	66				                .byte %01100110
9186	>bf46	3c				                .byte %00111100
9187	>bf47	00				                .byte %00000000

9189						                ; CHR$233
9190	>bf48	00				                .byte %00000000
9191	>bf49	00				                .byte %00000000
9192	>bf4a	18				                .byte %00011000
9193	>bf4b	18				                .byte %00011000
9194	>bf4c	18				                .byte %00011000
9195	>bf4d	18				                .byte %00011000
9196	>bf4e	0c				                .byte %00001100
9197	>bf4f	00				                .byte %00000000

9199						                ; CHR$234
9200	>bf50	00				                .byte %00000000
9201	>bf51	00				                .byte %00000000
9202	>bf52	66				                .byte %01100110
9203	>bf53	6c				                .byte %01101100
9204	>bf54	78				                .byte %01111000
9205	>bf55	6c				                .byte %01101100
9206	>bf56	66				                .byte %01100110
9207	>bf57	00				                .byte %00000000

9209						                ; CHR$235
9210	>bf58	60				                .byte %01100000
9211	>bf59	30				                .byte %00110000
9212	>bf5a	18				                .byte %00011000
9213	>bf5b	1c				                .byte %00011100
9214	>bf5c	36				                .byte %00110110
9215	>bf5d	63				                .byte %01100011
9216	>bf5e	63				                .byte %01100011
9217	>bf5f	00				                .byte %00000000

9219						                ; CHR$236
9220	>bf60	00				                .byte %00000000
9221	>bf61	00				                .byte %00000000
9222	>bf62	33				                .byte %00110011
9223	>bf63	33				                .byte %00110011
9224	>bf64	33				                .byte %00110011
9225	>bf65	33				                .byte %00110011
9226	>bf66	3e				                .byte %00111110
9227	>bf67	60				                .byte %01100000

9229						                ; CHR$237
9230	>bf68	00				                .byte %00000000
9231	>bf69	00				                .byte %00000000
9232	>bf6a	63				                .byte %01100011
9233	>bf6b	33				                .byte %00110011
9234	>bf6c	1b				                .byte %00011011
9235	>bf6d	1e				                .byte %00011110
9236	>bf6e	1c				                .byte %00011100
9237	>bf6f	00				                .byte %00000000

9239						                ; CHR$238
9250	>bf70	3c				                .byte %00111100
9251	>bf71	60				                .byte %01100000
9252	>bf72	60				                .byte %01100000
9253	>bf73	3c				                .byte %00111100
9254	>bf74	60				                .byte %01100000
9255	>bf75	60				                .byte %01100000
9256	>bf76	3e				                .byte %00111110
9257	>bf77	06				                .byte %00000110

9260						                ; CHR$239
9261	>bf78	00				                .byte %00000000
9262	>bf79	00				                .byte %00000000
9263	>bf7a	3e				                .byte %00111110
9264	>bf7b	63				                .byte %01100011
9265	>bf7c	63				                .byte %01100011
9266	>bf7d	63				                .byte %01100011
9267	>bf7e	3e				                .byte %00111110
9268	>bf7f	00				                .byte %00000000

9270						                ; CHR$240
9271	>bf80	00				                .byte %00000000
9272	>bf81	00				                .byte %00000000
9273	>bf82	7f				                .byte %01111111
9274	>bf83	36				                .byte %00110110
9275	>bf84	36				                .byte %00110110
9276	>bf85	36				                .byte %00110110
9277	>bf86	36				                .byte %00110110
9278	>bf87	00				                .byte %00000000

9280						                ; CHR$241
9281	>bf88	00				                .byte %00000000
9282	>bf89	00				                .byte %00000000
9283	>bf8a	3c				                .byte %00111100
9284	>bf8b	66				                .byte %01100110
9285	>bf8c	66				                .byte %01100110
9286	>bf8d	7c				                .byte %01111100
9287	>bf8e	60				                .byte %01100000
9288	>bf8f	60				                .byte %01100000

9290						                ; CHR$242
9291	>bf90	00				                .byte %00000000
9292	>bf91	00				                .byte %00000000
9293	>bf92	3f				                .byte %00111111
9294	>bf93	66				                .byte %01100110
9295	>bf94	66				                .byte %01100110
9296	>bf95	66				                .byte %01100110
9297	>bf96	3c				                .byte %00111100
9298	>bf97	00				                .byte %00000000

9300						                ; CHR$243
9301	>bf98	00				                .byte %00000000
9302	>bf99	00				                .byte %00000000
9303	>bf9a	7e				                .byte %01111110
9304	>bf9b	18				                .byte %00011000
9305	>bf9c	18				                .byte %00011000
9306	>bf9d	18				                .byte %00011000
9307	>bf9e	0c				                .byte %00001100
9308	>bf9f	00				                .byte %00000000

9310						                ; CHR$244
9311	>bfa0	00				                .byte %00000000
9312	>bfa1	00				                .byte %00000000
9313	>bfa2	73				                .byte %01110011
9314	>bfa3	33				                .byte %00110011
9315	>bfa4	33				                .byte %00110011
9316	>bfa5	33				                .byte %00110011
9317	>bfa6	1e				                .byte %00011110
9318	>bfa7	00				                .byte %00000000

9320						                ; CHR$245
9321	>bfa8	00				                .byte %00000000
9322	>bfa9	00				                .byte %00000000
9323	>bfaa	3e				                .byte %00111110
9324	>bfab	6b				                .byte %01101011
9325	>bfac	6b				                .byte %01101011
9326	>bfad	3e				                .byte %00111110
9327	>bfae	18				                .byte %00011000
9328	>bfaf	18				                .byte %00011000

9330						                ; CHR$246
9331	>bfb0	00				                .byte %00000000
9332	>bfb1	00				                .byte %00000000
9333	>bfb2	66				                .byte %01100110
9334	>bfb3	36				                .byte %00110110
9335	>bfb4	1c				                .byte %00011100
9336	>bfb5	1c				                .byte %00011100
9337	>bfb6	36				                .byte %00110110
9338	>bfb7	33				                .byte %00110011

9340						                ; CHR$247
9341	>bfb8	00				                .byte %00000000
9342	>bfb9	00				                .byte %00000000
9343	>bfba	63				                .byte %01100011
9344	>bfbb	6b				                .byte %01101011
9345	>bfbc	6b				                .byte %01101011
9346	>bfbd	3e				                .byte %00111110
9347	>bfbe	18				                .byte %00011000
9348	>bfbf	18				                .byte %00011000

9350						                ; CHR$248
9361	>bfc0	00				                .byte %00000000
9362	>bfc1	00				                .byte %00000000
9363	>bfc2	36				                .byte %00110110
9364	>bfc3	63				                .byte %01100011
9365	>bfc4	6b				                .byte %01101011
9366	>bfc5	7f				                .byte %01111111
9367	>bfc6	36				                .byte %00110110
9368	>bfc7	00				                .byte %00000000

9371						                ; CHR$249
9372	>bfc8	38				                .byte %00111000
9373	>bfc9	0c				                .byte %00001100
9374	>bfca	06				                .byte %00000110
9375	>bfcb	3e				                .byte %00111110
9376	>bfcc	66				                .byte %01100110
9377	>bfcd	66				                .byte %01100110
9378	>bfce	3c				                .byte %00111100
9379	>bfcf	00				                .byte %00000000

9381						                ; CHR$250
9382	>bfd0	00				                .byte %00000000
9383	>bfd1	31				                .byte %00110001
9384	>bfd2	6b				                .byte %01101011
9385	>bfd3	46				                .byte %01000110
9386	>bfd4	00				                .byte %00000000
9387	>bfd5	7f				                .byte %01111111
9388	>bfd6	00				                .byte %00000000
9389	>bfd7	00				                .byte %00000000

9391						                ; CHR$251
9392	>bfd8	00				                .byte %00000000
9393	>bfd9	7e				                .byte %01111110
9394	>bfda	00				                .byte %00000000
9395	>bfdb	7e				                .byte %01111110
9396	>bfdc	00				                .byte %00000000
9397	>bfdd	7e				                .byte %01111110
9398	>bfde	00				                .byte %00000000
9399	>bfdf	00				                .byte %00000000

9401						                ; CHR$252
9402	>bfe0	07				                .byte %00000111
9403	>bfe1	1c				                .byte %00011100
9404	>bfe2	70				                .byte %01110000
9405	>bfe3	1c				                .byte %00011100
9406	>bfe4	07				                .byte %00000111
9407	>bfe5	00				                .byte %00000000
9408	>bfe6	7f				                .byte %01111111
9409	>bfe7	00				                .byte %00000000

9411						                ; CHR$253
9412	>bfe8	06				                .byte %00000110
9413	>bfe9	0c				                .byte %00001100
9414	>bfea	7e				                .byte %01111110
9415	>bfeb	18				                .byte %00011000
9416	>bfec	7e				                .byte %01111110
9417	>bfed	30				                .byte %00110000
9418	>bfee	60				                .byte %01100000
9419	>bfef	00				                .byte %00000000

9421						                ; CHR$254
9422	>bff0	70				                .byte %01110000
9423	>bff1	1c				                .byte %00011100
9424	>bff2	07				                .byte %00000111
9425	>bff3	1c				                .byte %00011100
9426	>bff4	70				                .byte %01110000
9427	>bff5	00				                .byte %00000000
9428	>bff6	7f				                .byte %01111111
9429	>bff7	00				                .byte %00000000

9431						                ; CHR$255
9432	>bff8	ff				                .byte %11111111
9433	>bff9	ff				                .byte %11111111
9434	>bffa	ff				                .byte %11111111
9435	>bffb	ff				                .byte %11111111
9436	>bffc	ff				                .byte %11111111
9437	>bffd	ff				                .byte %11111111
9438	>bffe	ff				                .byte %11111111
9439	>bfff	ff				                .byte %11111111

:1	;******  Return to file: mosautocue.s65

24						                .endsection

26						                .section mos
27						                .include "src/mos.s65"

:15	;******  Processing file: src/mos.s65

1						; -*- comment-column:45; -*-

3						testVDU5State: .macro
10						                .endmacro

12						; VDU driver entry block
13						; ======================
14	.c000					LC000:                                       ; Read from VDU memory
15	.c000	b1 d6		lda ($d6),y	                lda (ZMEMG),y
16	.c002	60		rts		                rts
17	.c003					LC003:                                       ; Write to VDU memory
18	.c003	91 d6		sta ($d6),y	                sta (ZMEMG),y
19	.c005	60		rts		                rts

21						; MasRef E.4-6
22						;
23						; JSR PLBYTE plots the mask held in ZMASK into the byte pointed to by
24						; (ZMEMG),y, using ZGORA and ZGEOR as colour masks. See GADDR below
25						; for an example of its use.
26						;
27						; PLBYTE uses ZTEMP as workspace and preserves X, Y, V and C.
28	.c006					PLBYTE:
29	.c006	4c 51 db	jmp $db51	                jmp plbyteEntryPoint

31						; MasRef E.4-6
32						;
33						; JSR HPLOT plots a fast horizontal line in the current graphics
34						; colour or ECF and the current graphics mode (all as set by VDU 18)
35						; between two specified points. It is the low level primitive used by
36						; all the MOS area fill commands.
37						;
38						; On entry, two 4 byte areas at &300+X and &300+Y contain the
39						; coordinates of the two endpoints, in the standard
40						; lowX,highX,lowY,highY order. Should the Y coordinates differ, the Y
41						; coordinate of the line plotted is taken from the leftmost of the two
42						; points specified.
43						;
44						; Only portions of the line inside the graphics window are plotted.
45						; Subject to this, both endpoints of the line are plotted.
46						;
47						; HPLOT uses ZGORA, ZGEOR, ZMASK, ZMEMG, ZTEMP (but not ZTEMP+1),
48						; ZTEMPB, ZTEMPB+1, ZTEMPC and ZTEMPC+1 as workspace. No registers or
49						; flags are preserved.
50	.c009					HPLOT:
51	.c009	4c e8 da	jmp $dae8	                jmp LDAE8

53						; MasRef E.4-6
54						;
55						; JSR EIGABS converts the 4 byte pair of external coordinates at
56						; &300+X where X>=2 (in standard lowX,highX,lowY,highY order) into the
57						; corresponding pair of pixel coordinates by offsetting by the
58						; graphics origin, then dividing by an appropriate power of 2.
59						;
60						; EIGABS uses ZTEMP as workspace, and corrupts all registers and
61						; flags.
62	.c00c					EIGABS:
63	.c00c	4c de d1	jmp $d1de	                jmp eigabsEntryPoint

65						; MasRef E.4-7
66						;
67						; JSR WIND windows the 4 byte pair of pixel coordinates (in standard
68						; lowX,highX,lowY,highY order) at &300+X, and returns a result in A
69						; according to its position with respect to the window:

71						; 9 | 8 | 10
72						; --+---+---
73						; 1 | 0 | 2
74						; --+---+---
75						; 5 | 4 | 6

77						; WIND uses ZTEMP as workspace, preserves X and sets N and Z according
78						; to A.
79	.c00f					WIND:
80	.c00f	4c a8 d1	jmp $d1a8	                jmp windEntryPoint

82						; MasRef E.4-7
83						;
84						; JSR GADDR addresses the pixel whose 4 byte pair of pixel coordinates
85						; (in standard lowX,highX,lowY,highY order) is at &300+X. GADDR should
86						; not be called without first ensuring (typically by means of WIND)
87						; that the point concerned does lie within the screen.
88						;
89						; GADDR initialises the following variables:
90						;
91						; . ZMEMG to the start of the page of memory containing the pixel.
92						;
93						; . Y and VDU variable &1A (i.e. location &31A) to contain the offset
94						; of the byte containing the pixel within this page - i.e. (ZMEMG),y
95						; points to the byte containing the pixel.
96						;
97						; . ZMASK to a mask indicating which bits of this byte constitute the
98						; pixel.
99						;
100						; . ZGORA and ZGEOR to the correct colour masks for the current
101						; graphics plot mode (found in VDU variable &5A) and colour/ECF
102						;
103						; . X to Y MOD 7, i.e. the scan line within a character row of the
104						; pixel.
105						;
106						; Additionally, GADDR uses ZTEMP as workspace and returns A=0, Z=1.
107						;
108						; An example of the use of PLBYTE, WIND and GADDR is the following
109						; code, which effectively re-implements the VDU 25 64-71 (plot a
110						; point) calls. It assumes that the routine addresses have been
111						; previously defined and that the graphics plot mode, etc. were set up
112						; by the VDU 25 code before the unknown PLOT codes vector was entered:

114						; .POINT
115						;  LDX #&20   ;Addresses new point within VDU queue, as
116						;             ;left on entry to the unknown PLOT codes
117						;             ;vector.
118						;  JSR WIND   ;Is the point inside the window?
119						;  BNE END    ;Return if not.
120						;  JSR GADDR  ;Address the point now we know it's on
121						;             ;screen.
122						;  JSR PLBYTE ;And plot the point.
123						; .END
124						;  RTS
125	.c012					GADDR:
126	.c012	4c c8 de	jmp $dec8	                jmp gaddrEntryPoint

128						; MasRef E.4-8
129						;
130						; JSR IEG takes the internal pixel coordinates of the graphics cursor
131						; (in VDU variables &24-&27), converts it back to external coordinates
132						; and stores the result in VDU variables &10-&13.
133						;
134						; It should be called whenever the graphics code generates a new
135						; graphics cursor position (e.g. in the VDU drivers, it is called
136						; after a character is printed in VDU 5 mode). Its purpose is to make
137						; the two versions of the graphics cursor agree again, and thus
138						; prevent errors occurring with relative plots.
139						;
140						; IEG uses no page zero locations and corrupts all registers and
141						; flags.
142	.c015					IEG:
143	.c015	4c df c4	jmp $c4df	                jmp LC4DF

145						;-------------------------------------------------------------------------

147	.c018					LC018:                                       ; Fetch byte from ROM Y
148	.c018	a6 f4		ldx $f4		                ldx $F4                      ; Get current ROM
149	.c01a	84 f4		sty $f4		                sty $F4                      ; Select ROM in Y
150	.c01c	8c 30 fe	sty $fe30	                sty ROMSEL
151	.c01f	b2 f6		lda ($f6)	                lda ($F6)                    ; Get byte with ROM Y paged in
152	.c021	4c 9a e5	jmp $e59a	                jmp selectROMX                    ; Page in ROM X and return

154	.c024					LC024:
155	.c024	6c 5d 03	jmp ($035d)	                jmp (vduv.jumpVector)

157						;-------------------------------------------------------------------------
158						;
159						; VDU driver entry point
160						;
161						; Output to VDU.
162						;
163	.c027					outputToVDU:
164	.c027	ae 6a 02	ldx $026a	                ldx vduQueueNegativeLength  ;get VDU queue length
165	.c02a	f0 2d		beq $c059	                beq outputCharToVDU         ;taken if empty
166	.c02c	9d 24 02	sta $0224,x	                sta vduv.queueEnd-1-255,x   ;add to queue
167	.c02f	ee 6a 02	inc $026a	                inc vduQueueNegativeLength  ;one more in the queue...
168	.c032	f0 02		beq $c036	                beq outputQueueToVDU        ;taken if queue now filled
169	.c034					clc_rts_c034:
170	.c034	18		clc		                clc

172						;-------------------------------------------------------------------------
173						;
174						; VDU 0 (&00) Null [MasRef E.3-1]
175						; VDU 6 (&06) Enable VDU driver [MasRef E.3-3]
176						; VDU 27 (&1B) Null [MasRef E.3-34]
177						;
178	.c035					vdu0EntryPoint:
179	.c035					vdu6EntryPoint:
180	.c035					vdu27EntryPoint:
181	.c035					rtsC035:
182	.c035	60		rts		                rts

184						;-------------------------------------------------------------------------

186	.c036					outputQueueToVDU:
187	.c036	24 d0		bit $d0		                bit STATE
188	.c038	10 19		bpl $c053	                bpl LC053              ;branch taken if not VDU21 mode

190						                ; VDU disabled. But if outputting to printer
191						                ; specifically with VDU1, let the char through,
192	.c03a	ac 5e 03	ldy $035e	                ldy vduv.jumpVector+1
193	.c03d	c0 c0		cpy #$c0	                cpy #>vdu1EntryPoint
194	.c03f	d0 f3		bne $c034	                bne clc_rts_c034
195	.c041	ac 5d 03	ldy $035d	                ldy vduv.jumpVector+0
196	.c044	c0 e2		cpy #$e2	                cpy #<vdu1EntryPoint
197	.c046	d0 ec		bne $c034	                bne clc_rts_c034

199	.c048					outputCharToPrinter:
200	.c048	aa		tax		                tax                          ;save char to print
201	.c049	a5 d0		lda $d0		                lda STATE
202	.c04b	4a		lsr a		                lsr a                       ;C set if isPrinterEnabled
203	.c04c	90 e7		bcc $c035	                bcc rtsC035 ;taken if printer disabled - VDU 1 then a no-op
204	.c04e	8a		txa		                txa                          ;restore char to print
205	.c04f	18		clc		                clc
209	.c050	4c ed e2	jmp $e2ed	                jmp LE2ED

212	.c053					LC053:
213	.c053	20 fa c0	jsr $c0fa	                jsr stopCursorEditing
214	.c056	18		clc		                clc
215	.c057	80 67		bra $c0c0	                bra LC0C0

217	.c059					outputCharToVDU:
223	.c059	20 fa c0	jsr $c0fa	                jsr stopCursorEditing
227	.c05c	50 0f		bvc $c06d	                bvc LC06D             ;taken if not previously editing
229	.c05e	30 0d		bmi $c06d	                bmi LC06D             ;taken if VDU 21
230	.c060	c9 0d		cmp #$0d	                cmp #$0D
231	.c062	d0 09		bne $c06d	                bne LC06D                  ;taken if not printing a CR
232	.c064	48		pha		                pha                        ;save char to print
233	.c065	a9 42		lda #$42	                lda #STATE.isCursorEditing|STATE.isScrollingDisabled
234	.c067	14 d0		trb $d0		                trb STATE
235	.c069	20 50 cf	jsr $cf50	                jsr showCursor
236	.c06c	68		pla		                pla                          ;restore char to print
237	.c06d					LC06D:
238	.c06d	c9 20		cmp #$20	                cmp #$20
239	.c06f	90 06		bcc $c077	                bcc handleControlChar
240	.c071	c9 7f		cmp #$7f	                cmp #$7F
241	.c073	d0 21		bne $c096	                bne handlePrintableChar       ;taken if not backspace
242	.c075	a9 20		lda #$20	                lda #$20 ;backspace is entry 32 in the VDU routines table
243	.c077					handleControlChar:
244	.c077	a8		tay		                tay                          ;Y=index in table
245	.c078	b9 37 e0	lda $e037,y	                lda vduRoutinesLSBTable,y
246	.c07b	8d 5d 03	sta $035d	                sta vduv.jumpVector+0 ; Store jump address LSB (see MasRef E.4-3)
247	.c07e	b9 58 e0	lda $e058,y	                lda vduRoutinesMSBTable,y
248	.c081	30 30		bmi $c0b3	                bmi LC0B3           ;branch taken if MSB directly
249	.c083	aa		tax		                tax                          ; Save original MSB value
250	.c084	09 f0		ora #$f0	                ora #$F0
251	.c086	8d 6a 02	sta $026a	                sta vduQueueNegativeLength ;initialise initial VDU queue length
252	.c089	8a		txa		                txa                          ; Restore original MSB value
256	.c08a	4a		lsr a		                lsr a                        ;
257	.c08b	4a		lsr a		                lsr a                        ;
258	.c08c	4a		lsr a		                lsr a                        ;
259	.c08d	4a		lsr a		                lsr a                        ; Extract value in top 4 bits
261	.c08e	18		clc		                clc                          ;
262	.c08f	69 c0		adc #$c0	                adc #vduRoutinesPage         ; form MSB
263	.c091	8d 5e 03	sta $035e	                sta vduv.jumpVector+1
264	.c094	80 34		bra $c0ca	                bra reinstateCursorEditing                    ; Continue

266	.c096					handlePrintableChar:
267	.c096	24 d0		bit $d0		                bit STATE
268	.c098	30 2d		bmi $c0c7	                bmi LC0C7                    ;taken if VDU21
269	.c09a	20 0c ce	jsr $ce0c	                jsr plotCharAtTextCursor
270	.c09d	a9 20		lda #$20	                lda #vduv.cursorFlags.noMoveCursorAfterPrint
271	.c09f	2c 66 03	bit $0366	                bit vduv.cursorFlags
272	.c0a2	d0 23		bne $c0c7	                bne LC0C7                    ; taken if not moving cursor
277	.c0a4	20 76 c2	jsr $c276	                jsr LC276
279	.c0a7	80 1e		bra $c0c7	                bra LC0C7

281	.c0a9					LC0A9:
282	.c0a9	49 06		eor #$06	                eor #$06                     ; compare to VDU6?
283	.c0ab	d0 18		bne $c0c5	                bne LC0C5                    ; taken if not VUD6
284	.c0ad	a9 80		lda #$80	                lda #STATE.isVDU21
285	.c0af	14 d0		trb $d0		                trb STATE                    ; reset VDU21 flag
286	.c0b1	80 17		bra $c0ca	                bra reinstateCursorEditing

288	.c0b3					LC0B3:
289	.c0b3	8d 5e 03	sta $035e	                sta vduv.jumpVector+1

292	.c0b6	98		tya		                tya
293	.c0b7	49 f7		eor #$f7	                eor #$F7
294	.c0b9	c9 fa		cmp #$fa	                cmp #$FA

297	.c0bb	98		tya		                tya
298	.c0bc	24 d0		bit $d0		                bit STATE
299	.c0be	30 e9		bmi $c0a9	                bmi LC0A9             ;branch taken if VDU21 in effect
300	.c0c0					LC0C0:
301	.c0c0	08		php		                php
302	.c0c1	20 24 c0	jsr $c024	                jsr LC024
303	.c0c4	28		plp		                plp
304	.c0c5					LC0C5:
305	.c0c5	90 03		bcc $c0ca	                bcc reinstateCursorEditing
306	.c0c7					LC0C7:
307	.c0c7	a5 d0		lda $d0		                lda STATE
308	.c0c9	4a		lsr a		                lsr a                          ;C=1 if printer enabled
309	.c0ca					reinstateCursorEditing:
310	.c0ca	24 d0		bit $d0		                bit STATE
311	.c0cc	50 13		bvc $c0e1	                bvc rtsC0E1               ;taken if not cursor editing
312	.c0ce	20 05 c1	jsr $c105	                jsr activateEditCursor
313	.c0d1					exchangeCursors:
314	.c0d1	08		php		                php
315	.c0d2	48		pha		                pha
316	.c0d3	a5 d0		lda $d0		                lda STATE
317	.c0d5	49 02		eor #$02	                eor #STATE.isScrollingDisabled
318	.c0d7	85 d0		sta $d0		                sta STATE
319	.c0d9	20 be e2	jsr $e2be	                jsr exchangeEditCursorPositionAndTextCursorPosition
320	.c0dc	20 d8 c6	jsr $c6d8	                jsr updateCRTCTextCursor
321	.c0df	68		pla		                pla
322	.c0e0	28		plp		                plp
323	.c0e1					rtsC0E1:
324	.c0e1	60		rts		                rts

326						;-------------------------------------------------------------------------
327						;
328						; VDU 1 (&01) Send next character to printer only [MasRef E.3-2]
329						;
330	.c0e2					vdu1EntryPoint:
331	.c0e2	20 ca c0	jsr $c0ca	                jsr reinstateCursorEditing
332	.c0e5	20 48 c0	jsr $c048	                jsr outputCharToPrinter
333	.c0e8	80 10		bra $c0fa	                bra stopCursorEditing

335						;-------------------------------------------------------------------------
336						;
337						; VDU 2 (&02) Enable printer [MasRef E.3-2]
338						; VDU 3 (&03) Disable printer [MasRef E.3-3]
339						;
340	.c0ea					vdu2EntryPoint:
341	.c0ea					vdu3EntryPoint:
342	.c0ea	48		pha		                pha                          ;
343	.c0eb	20 ca c0	jsr $c0ca	                jsr reinstateCursorEditing
347	.c0ee	20 e7 e2	jsr $e2e7	                jsr LE2E7
349	.c0f1	a9 01		lda #$01	                lda #STATE.isPrinterEnabled  ;
350	.c0f3	04 d0		tsb $d0		                tsb STATE
351	.c0f5	68		pla		                pla
352	.c0f6	29 01		and #$01	                and #STATE.isPrinterEnabled
353	.c0f8	14 d0		trb $d0		                trb STATE

355						;-------------------------------------------------------------------------
356						;
357						; Stop cursor editing, if it's on.
358						;
359						; exit:
360						;
361						; V=1 if cursor editing previous on
362						; N=1 if VDU 21 on
363						;
364	.c0fa					stopCursorEditing:
365	.c0fa	24 d0		bit $d0		                bit STATE
366	.c0fc	50 e3		bvc $c0e1	                bvc rtsC0E1                    ;taken if not cursor editing
367	.c0fe	20 d1 c0	jsr $c0d1	                jsr exchangeCursors
368	.c101	08		php		                php
369	.c102					deactivateEditCursor:
370	.c102	38		sec		                sec
371	.c103	80 02		bra $c107	                bra updateEditCursorState

373						;-------------------------------------------------------------------------

375	.c105					activateEditCursor:
376	.c105	08		php		                php
377	.c106	18		clc		                clc

379						;-------------------------------------------------------------------------
380						;
381						; Handle cursor editing on/off.
382						;
383						; entry:
384						;
385						; C=0 - cursor editing on; add fake cursor
386						;
387						; C=1 = cursor editing off; remove fake cursor and restore screen
388						;
389	.c107					updateEditCursorState: .proc
390	.c107	48		pha		                pha
391	.c108	a5 d8		lda $d8		                lda ZMEMT+0
392	.c10a	85 e0		sta $e0		                sta ZTEMPD+0
393	.c10c	a5 d9		lda $d9		                lda ZMEMT+1
394	.c10e	85 e1		sta $e1		                sta ZTEMPD+1
395	.c110	ac 4f 03	ldy $034f	                ldy vduv.bytesPerCharacter
396	.c113	88		dey		                dey
397	.c114	d0 0e		bne $c124	                bne bitmap

399	.c116					teletext:
400	.c116	ad 38 03	lda $0338	                lda vduv.workspace._38 ;get old byte under fake cursor (may be bogus)
401	.c119	b0 17		bcs $c132	                bcs storeToScreen      ;taken if switching off
402	.c11b	b2 d8		lda ($d8)	                lda (ZMEMT)            ;get screen byte
403	.c11d	8d 38 03	sta $0338	                sta vduv.workspace._38 ;store old byte
404	.c120	a9 7f		lda #$7f	                lda #$7F               ;store solid block to screen
405	.c122	80 0e		bra $c132	                bra storeToScreen

407	.c124					bitmap:
408	.c124	a9 ff		lda #$ff	                lda #%11111111          ;invert all bits
409	.c126	c0 1f		cpy #$1f	                cpy #$1F      ;check for 32 chars/byte - i.e., MODE 2
410	.c128	d0 02		bne $c12c	                bne +         ;taken if not MODE 2
411	.c12a	a9 3f		lda #$3f	                lda #%00111111       ;avoid flashing colours in MODE 2
412	.c12c					+
413	.c12c	85 da		sta $da		                sta ZTEMP
414	.c12e					loop:
415	.c12e	b2 e0		lda ($e0)	                lda (ZTEMPD)
416	.c130	45 da		eor $da		                eor ZTEMP
417	.c132					storeToScreen:
418	.c132	92 e0		sta ($e0)	                sta (ZTEMPD)
419	.c134	e6 e0		inc $e0		                inc ZTEMPD+0
420	.c136	d0 09		bne $c141	                bne +                    ;taken if no carry out of LSB
421	.c138	e6 e1		inc $e1		                inc ZTEMPD+1
422	.c13a	10 05		bpl $c141	                bpl +                 ;taken if no screen address wrap
423	.c13c	ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
424	.c13f	85 e1		sta $e1		                sta ZTEMPD+1
425	.c141					+
426	.c141	88		dey		                dey               ;Y=$ff after 1 iteration in teletext
427	.c142	10 ea		bpl $c12e	                bpl loop
428	.c144	68		pla		                pla
429	.c145	28		plp		                plp
430	.c146	60		rts		                rts
431						                .endproc

433						;-------------------------------------------------------------------------

435	.c147					LC147:
436	>c147	be c1				                .word LC1BE
437	>c149	b1 c1				                .word LC1B1
438	>c14b	be c1				                .word LC1BE
439	>c14d	b1 c1				                .word LC1B1
440	>c14f	95 c1				                .word LC195
441	>c151	95 c1				                .word LC195
442	>c153	a2 c1				                .word LC1A2
443	>c155	a2 c1				                .word LC1A2

445						;-------------------------------------------------------------------------

447	.c157					LC157:
448	>c157	01 c2				                .word LC201
449	>c159	ee c1				                .word LC1EE
450	>c15b	01 c2				                .word LC201
451	>c15d	ee c1				                .word LC1EE
452	>c15f	21 c2				                .word LC221
453	>c161	21 c2				                .word LC221
454	>c163	10 c2				                .word LC210
455	>c165	10 c2				                .word LC210

457						;-------------------------------------------------------------------------
458						;
459						; Indexed by the swapAxes, invertVertical and invertHorizontal cursor
460						; flags bits.
461						;
462	.c167					setTextCursorXPositionRoutinesTable:
463	>c167	d3 c2				                .word setTextCursorXPosition           ;0
464	>c169	cb c2				                .word setTextCursorXPositionInvertHorizontal ;invertHorizontal
465	>c16b	d3 c2				                .word setTextCursorXPosition ;invertVertical
466	>c16d	cb c2				                .word setTextCursorXPositionInvertHorizontal ;invertVertical|invertHorizontal
467	>c16f	e2 c2				                .word setTextCursorXPositionSwapAxes         ;swapAxes
468	>c171	e2 c2				                .word setTextCursorXPositionSwapAxes ;swapAxes|invertHorizontal
469	>c173	da c2				                .word setTextCursorXPositionSwapAxesInvertVertical ;swapAxes|invertVertical
470	>c175	da c2				                .word setTextCursorXPositionSwapAxesInvertVertical ;swapAxes|invertVertical|invertHorizontal

472						;-------------------------------------------------------------------------

474	.c177					moveTextCursorRoutinesTable:
475	>c177	10 c3				                .word moveTextCursorPositiveX
476	>c179	f2 c2				                .word moveTextCursorNegativeX
477	>c17b	10 c3				                .word moveTextCursorPositiveX
478	>c17d	f2 c2				                .word moveTextCursorNegativeX
479	>c17f	5a c3				                .word moveTextCursorPositiveY
480	>c181	5a c3				                .word moveTextCursorPositiveY
481	>c183	38 c3				                .word moveTextCursorNegativeY
482	>c185	38 c3				                .word moveTextCursorNegativeY

484						;-------------------------------------------------------------------------

486	.c187					LC187:
487	.c187	4d 66 03	eor $0366	                eor vduv.cursorFlags
488	.c18a	29 0e		and #$0e	                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal)
489	.c18c	48		pha		                pha
490	.c18d	20 a6 d1	jsr $d1a6	                jsr LD1A6
491	.c190	fa		plx		                plx
492	.c191	38		sec		                sec
493	.c192	7c 47 c1	jmp ($c147,x)	                jmp (LC147,x)

495	.c195					LC195:
496	.c195	ad 26 03	lda $0326	                lda $0326
497	.c198	e9 08		sbc #$08	                sbc #$08
498	.c19a	8d 26 03	sta $0326	                sta $0326
499	.c19d	ce 27 03	dec $0327	                dec $0327
500	.c1a0	80 08		bra $c1aa	                bra LC1AA

502	.c1a2					LC1A2:
503	.c1a2	ad 26 03	lda $0326	                lda $0326
504	.c1a5	69 07		adc #$07	                adc #$07
505	.c1a7	8d 26 03	sta $0326	                sta $0326
506	.c1aa					LC1AA:
507	.c1aa	90 1f		bcc $c1cb	                bcc LC1CB
508	.c1ac	ee 27 03	inc $0327	                inc $0327
509	.c1af	80 1a		bra $c1cb	                bra LC1CB

511	.c1b1					LC1B1:
512	.c1b1	ad 24 03	lda $0324	                lda $0324
513	.c1b4	e9 08		sbc #$08	                sbc #$08
514	.c1b6	8d 24 03	sta $0324	                sta $0324
515	.c1b9	ce 25 03	dec $0325	                dec $0325
516	.c1bc	80 08		bra $c1c6	                bra LC1C6

518	.c1be					LC1BE:
519	.c1be	ad 24 03	lda $0324	                lda $0324
520	.c1c1	69 07		adc #$07	                adc #$07
521	.c1c3	8d 24 03	sta $0324	                sta $0324
522	.c1c6					LC1C6:
523	.c1c6	90 03		bcc $c1cb	                bcc LC1CB
524	.c1c8	ee 25 03	inc $0325	                inc $0325
525	.c1cb					LC1CB:
526	.c1cb	a5 da		lda $da		                lda $DA
527	.c1cd	d0 0c		bne $c1db	                bne LC1DB
528	.c1cf	2c 66 03	bit $0366	                bit $0366
529	.c1d2	70 07		bvs $c1db	                bvs LC1DB
530	.c1d4	da		phx		                phx
531	.c1d5	20 a6 d1	jsr $d1a6	                jsr LD1A6
532	.c1d8	fa		plx		                plx
533	.c1d9	a8		tay		                tay
534	.c1da	60		rts		                rts

536	.c1db					LC1DB:
537	.c1db	a9 00		lda #$00	                lda #$00
538	.c1dd	60		rts		                rts

540	.c1de					LC1DE:
541	.c1de	a9 00		lda #$00	                lda #$00
542	.c1e0					LC1E0:
543	.c1e0	64 da		stz $da		                stz $DA
544	.c1e2	0a		asl a		                asl a
545	.c1e3	26 da		rol $da		                rol $DA
546	.c1e5	0a		asl a		                asl a
547	.c1e6	26 da		rol $da		                rol $DA
548	.c1e8	0a		asl a		                asl a
549	.c1e9	26 da		rol $da		                rol $DA
550	.c1eb	7c 57 c1	jmp ($c157,x)	                jmp (LC157,x)

552	.c1ee					LC1EE:
553	.c1ee	49 f9		eor #$f9	                eor #$F9
554	.c1f0	6d 04 03	adc $0304	                adc $0304
555	.c1f3	8d 24 03	sta $0324	                sta $0324
556	.c1f6	a5 da		lda $da		                lda $DA
557	.c1f8	49 ff		eor #$ff	                eor #$FF
558	.c1fa	6d 05 03	adc $0305	                adc $0305
559	.c1fd	8d 25 03	sta $0325	                sta $0325
560	.c200	60		rts		                rts

562	.c201					LC201:
563	.c201	6d 00 03	adc $0300	                adc $0300
564	.c204	8d 24 03	sta $0324	                sta $0324
565	.c207	a5 da		lda $da		                lda $DA
566	.c209	6d 01 03	adc $0301	                adc $0301
567	.c20c	8d 25 03	sta $0325	                sta $0325
568	.c20f	60		rts		                rts

570	.c210					LC210:
571	.c210	49 07		eor #$07	                eor #$07
572	.c212	6d 02 03	adc $0302	                adc $0302
573	.c215	8d 26 03	sta $0326	                sta $0326
574	.c218	a5 da		lda $da		                lda $DA
575	.c21a	6d 03 03	adc $0303	                adc $0303
576	.c21d	8d 27 03	sta $0327	                sta $0327
577	.c220	60		rts		                rts

579	.c221					LC221:
580	.c221	38		sec		                sec
581	.c222	49 ff		eor #$ff	                eor #$FF
582	.c224	6d 06 03	adc $0306	                adc $0306
583	.c227	8d 26 03	sta $0326	                sta $0326
584	.c22a	a5 da		lda $da		                lda $DA
585	.c22c	49 ff		eor #$ff	                eor #$FF
586	.c22e	6d 07 03	adc $0307	                adc $0307
587	.c231	8d 27 03	sta $0327	                sta $0327
588	.c234	60		rts		                rts

590	.c235					LC235:
591	.c235	a9 00		lda #$00	                lda #$00
592	.c237	20 87 c1	jsr $c187	                jsr LC187
593	.c23a	f0 0d		beq $c249	                beq LC249
594	.c23c	20 de c1	jsr $c1de	                jsr LC1DE
595	.c23f					LC23F:
596	.c23f	a9 08		lda #$08	                lda #$08
597	.c241					LC241:
598	.c241	20 87 c1	jsr $c187	                jsr LC187
599	.c244	f0 03		beq $c249	                beq LC249
600	.c246	20 de c1	jsr $c1de	                jsr LC1DE
601	.c249					LC249:
602	.c249	4c df c4	jmp $c4df	                jmp LC4DF

604	.c24c					vdu9EntryPoint:
605	.c24c	20 2d d1	jsr $d12d	                jsr handleColumn81
606	.c24f	b0 e4		bcs $c235	                bcs LC235
607	.c251	a9 00		lda #$00	                lda #$00                     ; X+
608	.c253	20 e9 c2	jsr $c2e9	                jsr moveTextCursor
609	.c256	90 1b		bcc $c273	                bcc LC273
610	.c258					LC258:
611	.c258	20 8f c3	jsr $c38f	                jsr LC38F
612	.c25b					vdu10EntryPoint:
8	.c25b	20 e2 e2	jsr $e2e2	                jsr testVDU5StateNonInlined
614	.c25e	d0 df		bne $c23f	                bne LC23F
615	.c260	18		clc		                clc
616	.c261	20 8e c8	jsr $c88e	                jsr LC88E
617	.c264	a9 08		lda #$08	                lda #$08
618	.c266	20 e9 c2	jsr $c2e9	                jsr moveTextCursor           ; Y-
619	.c269					LC269:
620	.c269	90 08		bcc $c273	                bcc LC273
621	.c26b	20 7b c3	jsr $c37b	                jsr LC37B
622	.c26e	90 03		bcc $c273	                bcc LC273
623	.c270	4c 51 d0	jmp $d051	                jmp LD051

625	.c273					LC273:
626	.c273	4c ed c6	jmp $c6ed	                jmp updateCRTCCursorAddress

628	.c276					LC276:
635	.c276	20 e2 e2	jsr $e2e2	                jsr testVDU5StateNonInlined
637						                ; .testVDU5State
638	.c279	d0 ba		bne $c235	                bne LC235                    ; taken if VDU5
639	.c27b	20 e9 c2	jsr $c2e9	                jsr moveTextCursor           ; A=0, so X+
640	.c27e	90 f3		bcc $c273	                bcc LC273
641	.c280	a9 01		lda #$01	                lda #vduv.cursorFlags.scrollProtect
642	.c282	2c 66 03	bit $0366	                bit vduv.cursorFlags
643	.c285	f0 d1		beq $c258	                beq LC258
644	.c287	38		sec		                sec
645	.c288	6e 6c 03	ror $036c	                ror vduv.column81
646	.c28b					LC28B:
647	.c28b	60		rts		                rts

649	.c28c					LC28C:
650	.c28c	a9 06		lda #$06	                lda #$06
651	.c28e	20 87 c1	jsr $c187	                jsr LC187
652	.c291	f0 b6		beq $c249	                beq LC249
653	.c293	20 de c1	jsr $c1de	                jsr LC1DE
654	.c296					LC296:
655	.c296	a9 0e		lda #$0e	                lda #$0E
656	.c298	80 a7		bra $c241	                bra LC241

658	.c29a					vdu8EntryPoint:
8	.c29a	20 e2 e2	jsr $e2e2	                jsr testVDU5StateNonInlined
660	.c29d	d0 ed		bne $c28c	                bne LC28C
661	.c29f	4e 6c 03	lsr $036c	                lsr $036C
662	.c2a2	2c 6c 03	bit $036c	                bit $036C
663	.c2a5	70 e4		bvs $c28b	                bvs LC28B
664	.c2a7	a9 06		lda #$06	                lda #$06
665	.c2a9	20 e9 c2	jsr $c2e9	                jsr moveTextCursor           ; X-
666	.c2ac	90 c5		bcc $c273	                bcc LC273
667	.c2ae	20 8f c3	jsr $c38f	                jsr LC38F
668	.c2b1					vdu11EntryPoint:
8	.c2b1	20 e2 e2	jsr $e2e2	                jsr testVDU5StateNonInlined
670	.c2b4	d0 e0		bne $c296	                bne LC296
671	.c2b6	ce 69 02	dec $0269	                dec pagedModeCounter
672	.c2b9	10 03		bpl $c2be	                bpl LC2BE
673	.c2bb	ee 69 02	inc $0269	                inc pagedModeCounter
674	.c2be					LC2BE:
675	.c2be	a9 0e		lda #$0e	                lda #$0E
676	.c2c0	20 e9 c2	jsr $c2e9	                jsr moveTextCursor           ; Y+
677	.c2c3	80 a4		bra $c269	                bra LC269

679						;-------------------------------------------------------------------------
680						;
681						; Set/reset cursor position, taking cursor flags into account.
682						;
683						; entry:
684						;
685						; (set only) A = cursor position
686						;
687						; X = cursorFlags bits: swapAxes, invertVertical, invertHorizontal
688						;
689	.c2c5					resetTextCursorXPositionWithCursorFlags:
690	.c2c5	a9 00		lda #$00	                lda #$00
691	.c2c7					setTextCursorXPositionWithCursorFlags:
692	.c2c7	18		clc		                clc
693	.c2c8	7c 67 c1	jmp ($c167,x)	                jmp (setTextCursorXPositionRoutinesTable,x)

695						;-------------------------------------------------------------------------

697	.c2cb					setTextCursorXPositionInvertHorizontal:
698	.c2cb	38		sec		                sec                          ;+1
699	.c2cc	49 ff		eor #$ff	                eor #$FF          ;^$ff+1 (i.e., adc will add the -ve)
700	.c2ce	6d 0a 03	adc $030a	                adc vduv.textWindowRight
701	.c2d1	80 03		bra $c2d6	                bra staTextCursorXPosition

703						;-------------------------------------------------------------------------

705	.c2d3					setTextCursorXPosition:
706	.c2d3	6d 08 03	adc $0308	                adc vduv.textWindowLeft
707	.c2d6					staTextCursorXPosition:
708	.c2d6	8d 18 03	sta $0318	                sta vduv.textCursorXPosition
709	.c2d9	60		rts		                rts

711						;-------------------------------------------------------------------------

713	.c2da					setTextCursorXPositionSwapAxesInvertVertical:
714	.c2da	38		sec		                sec
715	.c2db	49 ff		eor #$ff	                eor #$FF
716	.c2dd	6d 09 03	adc $0309	                adc vduv.textWindowBottom
717	.c2e0	80 03		bra $c2e5	                bra staTextCursorYPosition

719	.c2e2					setTextCursorXPositionSwapAxes:
720	.c2e2	6d 0b 03	adc $030b	                adc vduv.textWindowTop
721	.c2e5					staTextCursorYPosition:
722	.c2e5	8d 19 03	sta $0319	                sta vduv.textCursorYPosition
723	.c2e8	60		rts		                rts

725						;-------------------------------------------------------------------------
726						;
727						; Move text cursor.
728						;
729						; Entry:
730						;
731						; A = direction to move: 0 = X+
732						;                        2 = X-
733						;                        4 = X+
734						;                        6 = X-
735						;                        8 = Y-
736						;                        10 = Y-
737						;                        12 = Y+
738						;                        14 = Y+
739						;
740						; Exit:
741						;
742						; X = actual jump table index
743						; C = something...

746	.c2e9					moveTextCursor:
747	.c2e9	4d 66 03	eor $0366	                eor vduv.cursorFlags
748	.c2ec	29 0e		and #$0e	                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal)
749	.c2ee	aa		tax		                tax
752	.c2ef					callMoveTextCursorRoutine:
753	.c2ef	7c 77 c1	jmp ($c177,x)	                jmp (moveTextCursorRoutinesTable,x)

755						;-------------------------------------------------------------------------

757	.c2f2					moveTextCursorNegativeX:
758	.c2f2	ad 08 03	lda $0308	                lda vduv.textWindowLeft
759	.c2f5	cd 18 03	cmp $0318	                cmp vduv.textCursorXPosition
760	.c2f8	b0 3d		bcs $c337	                bcs rtsC337
761	.c2fa	ce 18 03	dec $0318	                dec vduv.textCursorXPosition
762	.c2fd	38		sec		                sec
763	.c2fe	ad 4a 03	lda $034a	                lda vduv.textCursorCRTCAddress+0
764	.c301	ed 4f 03	sbc $034f	                sbc vduv.bytesPerCharacter
765	.c304	8d 4a 03	sta $034a	                sta vduv.textCursorCRTCAddress+0
766	.c307	85 d8		sta $d8		                sta ZMEMT+0
767	.c309	b0 2b		bcs $c336	                bcs clc_rts_C336
768	.c30b	ce 4b 03	dec $034b	                dec vduv.textCursorCRTCAddress+1
769	.c30e	80 1b		bra $c32b	                bra fixUpZMEMTHiFromTextCursorCRTCAddressHi

771						;-------------------------------------------------------------------------

782	.c310					moveTextCursorPositiveX:
783	.c310	ad 18 03	lda $0318	                lda vduv.textCursorXPosition
784	.c313	cd 0a 03	cmp $030a	                cmp vduv.textWindowRight
785	.c316	b0 1f		bcs $c337	                bcs rtsC337
786	.c318	ee 18 03	inc $0318	                inc vduv.textCursorXPosition
787	.c31b	ad 4a 03	lda $034a	                lda vduv.textCursorCRTCAddress+0
788	.c31e	6d 4f 03	adc $034f	                adc vduv.bytesPerCharacter
789	.c321	8d 4a 03	sta $034a	                sta vduv.textCursorCRTCAddress+0
790	.c324	85 d8		sta $d8		                sta ZMEMT+0
791	.c326	90 0f		bcc $c337	                bcc rtsC337
792	.c328	ee 4b 03	inc $034b	                inc vduv.textCursorCRTCAddress+1
793	.c32b					fixUpZMEMTHiFromTextCursorCRTCAddressHi:
794	.c32b	ad 4b 03	lda $034b	                lda vduv.textCursorCRTCAddress+1
795	.c32e					fixUpZMEMTHi:
796	.c32e	10 04		bpl $c334	                bpl LC334
797	.c330	38		sec		                sec
798	.c331	ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte
799	.c334					LC334:
800	.c334	85 d9		sta $d9		                sta ZMEMT+1
801	.c336					clc_rts_C336:
802	.c336	18		clc		                clc
803	.c337					rtsC337:
804	.c337	60		rts		                rts

806						;-------------------------------------------------------------------------

808	.c338					moveTextCursorNegativeY:
809	.c338	ad 0b 03	lda $030b	                lda vduv.textWindowTop
810	.c33b	cd 19 03	cmp $0319	                cmp vduv.textCursorYPosition
811	.c33e	b0 f7		bcs $c337	                bcs rtsC337
812	.c340	ce 19 03	dec $0319	                dec vduv.textCursorYPosition
813	.c343	38		sec		                sec
814	.c344	ad 4a 03	lda $034a	                lda vduv.textCursorCRTCAddress+0
815	.c347	ed 52 03	sbc $0352	                sbc $0352
816	.c34a	8d 4a 03	sta $034a	                sta vduv.textCursorCRTCAddress+0
817	.c34d	85 d8		sta $d8		                sta ZMEMT+0
818	.c34f	ad 4b 03	lda $034b	                lda vduv.textCursorCRTCAddress+1
819	.c352	ed 53 03	sbc $0353	                sbc $0353
820	.c355	8d 4b 03	sta $034b	                sta vduv.textCursorCRTCAddress+1
821	.c358	80 d4		bra $c32e	                bra fixUpZMEMTHi

823						;-------------------------------------------------------------------------

825	.c35a					moveTextCursorPositiveY:
826	.c35a	ad 19 03	lda $0319	                lda vduv.textCursorYPosition
827	.c35d	cd 09 03	cmp $0309	                cmp vduv.textWindowBottom
828	.c360	b0 d5		bcs $c337	                bcs rtsC337
829	.c362	ee 19 03	inc $0319	                inc vduv.textCursorYPosition
830	.c365	ad 4a 03	lda $034a	                lda vduv.textCursorCRTCAddress+0
831	.c368	6d 52 03	adc $0352	                adc vduv.bytesPerCharacterRow+0
832	.c36b	8d 4a 03	sta $034a	                sta vduv.textCursorCRTCAddress+0
833	.c36e	85 d8		sta $d8		                sta ZMEMT+0
834	.c370	ad 4b 03	lda $034b	                lda vduv.textCursorCRTCAddress+1
835	.c373	6d 53 03	adc $0353	                adc vduv.bytesPerCharacterRow+1
836	.c376	8d 4b 03	sta $034b	                sta vduv.textCursorCRTCAddress+1
837	.c379	80 b3		bra $c32e	                bra fixUpZMEMTHi

839						;-------------------------------------------------------------------------

841	.c37b					LC37B:
842	.c37b	a9 10		lda #$10	                lda #vduv.cursorFlags.noVerticalScroll
843	.c37d	2c 66 03	bit $0366	                bit vduv.cursorFlags
844	.c380	d0 0d		bne $c38f	                bne LC38F
845	.c382	8a		txa		                txa
846	.c383	49 06		eor #$06	                eor #$06
847	.c385	48		pha		                pha
848	.c386	a9 42		lda #$42	                lda #STATE.isCursorEditing|STATE.isScrollingDisabled
849	.c388	24 d0		bit $d0		                bit STATE
850	.c38a	f0 16		beq $c3a2	                beq LC3A2
851	.c38c	70 09		bvs $c397	                bvs LC397
852	.c38e	68		pla		                pla
853	.c38f					LC38F:
854	.c38f	20 c5 c2	jsr $c2c5	                jsr resetTextCursorXPositionWithCursorFlags
855	.c392	20 fa cc	jsr $ccfa	                jsr updateZMEMTWithTextCursorPosition
856	.c395	18		clc		                clc
857	.c396	60		rts		                rts

859	.c397					LC397:
860	.c397	20 be e2	jsr $e2be	                jsr exchangeEditCursorPositionAndTextCursorPosition
861	.c39a	fa		plx		                plx
862	.c39b	da		phx		                phx
863	.c39c	20 ef c2	jsr $c2ef	                jsr callMoveTextCursorRoutine
864	.c39f	20 be e2	jsr $e2be	                jsr exchangeEditCursorPositionAndTextCursorPosition
865	.c3a2					LC3A2:
866	.c3a2	fa		plx		                plx
867	.c3a3	38		sec		                sec
868	.c3a4					rtsC3A4:
869	.c3a4	60		rts		                rts

871						;-------------------------------------------------------------------------

873	.c3a5					vdu28EntryPoint:
874	.c3a5	ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
875	.c3a8	ad 21 03	lda $0321	                lda vduv.queueEnd-3          ; max Y
876	.c3ab	cd 23 03	cmp $0323	                cmp vduv.queueEnd-1          ; min Y
877	.c3ae	90 f4		bcc $c3a4	                bcc rtsC3A4                  ; bail if max Y<min Y
878	.c3b0	dd 11 e1	cmp $e111,x	                cmp modeMaxRow,x             ;
879	.c3b3	f0 02		beq $c3b7	                beq +                        ; taken if max Y==max row
880	.c3b5	b0 ed		bcs $c3a4	                bcs rtsC3A4                  ; bail if max Y>max row
881	.c3b7					+
882	.c3b7	ad 22 03	lda $0322	                lda vduv.queueEnd-2          ; max X
883	.c3ba	dd 19 e1	cmp $e119,x	                cmp modeMaxColumn,x
884	.c3bd	f0 03		beq $c3c2	                beq +                        ; taken if max X==max col
885	.c3bf	b0 e3		bcs $c3a4	                bcs rtsC3A4                  ; bail if max X>max col
886	.c3c1	38		sec		                sec
887	.c3c2					+
888	.c3c2	ed 20 03	sbc $0320	                sbc vduv.queueEnd-4          ; form window width
889	.c3c5	90 dd		bcc $c3a4	                bcc rtsC3A4                  ; bail if negative
890	.c3c7	20 80 c7	jsr $c780	                jsr setTextWindowWidthInBytes
891	.c3ca	a9 08		lda #$08	                lda #STATE.isTextWindow
892	.c3cc	04 d0		tsb $d0		                tsb STATE                    ; set isTextWIndow bit

894						                ; set text window value from the 4 VDU 28 argument
895						                ; bytes in the VDU queue
896	.c3ce	a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
897	.c3d0	a0 08		ldy #$08	                ldy #VDUVariables.textWindowLeft
898	.c3d2	20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables

900	.c3d5	20 be e2	jsr $e2be	                jsr exchangeEditCursorPositionAndTextCursorPosition
901	.c3d8	20 da cc	jsr $ccda	                jsr updateZMEMTWithTextCursorPositionIfValid
902	.c3db	90 03		bcc $c3e0	                bcc LC3E0         ; taken if text cursor pos was valid
903	.c3dd	20 e8 c3	jsr $c3e8	                jsr resetTextCursorPosition
904	.c3e0					LC3E0:
905	.c3e0	20 be e2	jsr $e2be	                jsr exchangeEditCursorPositionAndTextCursorPosition
906	.c3e3	20 da cc	jsr $ccda	                jsr updateZMEMTWithTextCursorPositionIfValid
907	.c3e6	90 1f		bcc $c407	                bcc LC407         ; taken if text cursor pos was valid
908	.c3e8					resetTextCursorPosition:
909	.c3e8	a5 d0		lda $d0		                lda STATE
910	.c3ea	48		pha		                pha
911	.c3eb	29 df		and #$df	                and #~STATE.isVDU5
912	.c3ed	85 d0		sta $d0		                sta STATE
913	.c3ef	20 7c c4	jsr $c47c	                jsr vdu30EntryPoint
914	.c3f2	68		pla		                pla
915	.c3f3	85 d0		sta $d0		                sta STATE
916	.c3f5	60		rts		                rts

918	.c3f6					vdu13EntryPoint:
919	.c3f6	ad 66 03	lda $0366	                lda vduv.cursorFlags
920	.c3f9	29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal;$0E
921	.c3fb	aa		tax		                tax
8	.c3fc	20 e2 e2	jsr $e2e2	                jsr testVDU5StateNonInlined
923	.c3ff	d0 09		bne $c40a	                bne LC40A
924	.c401	4e 6c 03	lsr $036c	                lsr vduv.column81
925	.c404	20 8f c3	jsr $c38f	                jsr LC38F
926	.c407					LC407:
927	.c407	4c ed c6	jmp $c6ed	                jmp updateCRTCCursorAddress

929	.c40a					LC40A:
930	.c40a	20 de c1	jsr $c1de	                jsr LC1DE
931	.c40d	4c df c4	jmp $c4df	                jmp LC4DF

933	.c410					jsrVDU30EntryPoint:
934	.c410	20 7c c4	jsr $c47c	                jsr vdu30EntryPoint

936						;-------------------------------------------------------------------------
937						;
938						; VDU 16 (&10) Clear graphics window [MasRef E.3-7]
939						;
940	.c413					vdu16EntryPoint:
941	.c413	ad 61 03	lda $0361	                lda vduv.pixelsPerByteMinusOne
942	.c416	f0 8c		beq $c3a4	                beq rtsC3A4                    ;taken if MODE 7
943	.c418	a2 00		ldx #$00	                ldx #VDUVariables.graphicsWindowPixelsLeft
944	.c41a	20 02 c9	jsr $c902	                jsr copyEightBytesToWorkspace28
945	.c41d	20 51 c9	jsr $c951	                jsr prepareForPlotBackground
946	.c420					LC420:
947	.c420	a2 2a		ldx #$2a	                ldx #$2A
948	.c422	a0 2e		ldy #$2e	                ldy #$2E
949	.c424	20 c2 e2	jsr $e2c2	                jsr exchangeTwoVDUBytes
950	.c427					LC427:
951	.c427	a2 28		ldx #$28	                ldx #$28
952	.c429	a0 2c		ldy #$2c	                ldy #$2C
953	.c42b	20 e8 da	jsr $dae8	                jsr LDAE8
954	.c42e	ad 2a 03	lda $032a	                lda $032A
955	.c431	d0 03		bne $c436	                bne LC436
956	.c433	ce 2b 03	dec $032b	                dec $032B
957	.c436					LC436:
958	.c436	ce 2a 03	dec $032a	                dec $032A
959	.c439	ad 2a 03	lda $032a	                lda $032A
960	.c43c	cd 2e 03	cmp $032e	                cmp $032E
961	.c43f	ad 2b 03	lda $032b	                lda $032B
962	.c442	ed 2f 03	sbc $032f	                sbc $032F
963	.c445	10 e0		bpl $c427	                bpl LC427
964	.c447	60		rts		                rts

966	.c448					LC448:
967	.c448	a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
968	.c44a	20 e6 c8	jsr $c8e6	                jsr prepareAABB
969	.c44d	80 d1		bra $c420	                bra LC420

971						;-------------------------------------------------------------------------
972						;
973						; VDU 12 (&0C) Clear text window [MasRef E.3-5]
974						;
975	.c44f					vdu12EntryPoint:
976	.c44f	a9 20		lda #$20	                lda #STATE.isVDU5
977	.c451	24 d0		bit $d0		                bit STATE
978	.c453	d0 bb		bne $c410	                bne jsrVDU30EntryPoint       ;taken if VDU 5 mode
979	.c455	a9 08		lda #$08	                lda #STATE.isTextWindow
980	.c457	24 d0		bit $d0		                bit STATE
981	.c459	d0 03		bne $c45e	                bne clearTextWindow                    ;taken if text window
982	.c45b	4c 66 c8	jmp $c866	                jmp clsFastPath

984						                ; Clear screen within text window
985						                ; -------------------------------
986	.c45e					clearTextWindow:
987	.c45e	20 08 c9	jsr $c908	                jsr copyTextWindowWidthInBytesToWorkspace28
988	.c461	ae 08 03	ldx $0308	                ldx vduv.textWindowLeft
989	.c464	8e 18 03	stx $0318	                stx vduv.textCursorXPosition
990	.c467	ae 0b 03	ldx $030b	                ldx vduv.textWindowTop
991	.c46a					clearTextWindowRowsLoop:
992	.c46a	8e 19 03	stx $0319	                stx vduv.textCursorYPosition
993	.c46d	20 fa cc	jsr $ccfa	                jsr updateZMEMTWithTextCursorPosition
994	.c470	20 e8 ca	jsr $cae8	                jsr LCAE8
995	.c473	ae 19 03	ldx $0319	                ldx vduv.textCursorYPosition
996	.c476	ec 09 03	cpx $0309	                cpx vduv.textWindowBottom
997	.c479	e8		inx		                inx
998	.c47a	90 ee		bcc $c46a	                bcc clearTextWindowRowsLoop

1000						;-------------------------------------------------------------------------
1001						;
1002						; VDU 30 (&1E) Home cursor [MasRef E.3-36]
1003						;
1004	.c47c					vdu30EntryPoint:
1005						                ; pretend it's VDU 31,0,0
1006	.c47c	9c 23 03	stz $0323	                stz vduv.queueEnd-1
1007	.c47f	9c 22 03	stz $0322	                stz vduv.queueEnd-2

1009						;-------------------------------------------------------------------------
1010						;
1011						; VDU 31 (&1F) Tab cursor [MasRef E.3-36]
1012						;
1013	.c482					vdu31EntryPoint:
1014	.c482	ad 66 03	lda $0366	                lda vduv.cursorFlags
1015	.c485	29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
1016	.c487	aa		tax		                tax
1017	.c488					LC488:
8	.c488	20 e2 e2	jsr $e2e2	                jsr testVDU5StateNonInlined
1019	.c48b	d0 42		bne $c4cf	                bne LC4CF                    ;taken if VDU 5
1020	.c48d	ad 18 03	lda $0318	                lda vduv.textCursorXPosition
1021	.c490	48		pha		                pha                          ;save old X pos
1022	.c491	ad 19 03	lda $0319	                lda vduv.textCursorYPosition
1023	.c494	48		pha		                pha                          ;save old Y pos
1024	.c495	ad 22 03	lda $0322	                lda vduv.queueEnd-2          ;X coordinate
1025	.c498	20 c7 c2	jsr $c2c7	                jsr setTextCursorXPositionWithCursorFlags
1026	.c49b	da		phx		                phx                          ;save true cursorFlags bits
1027	.c49c	8a		txa		                txa
1028	.c49d	49 08		eor #$08	                eor #vduv.cursorFlags.swapAxes ;cheekily do the other axis by just changing the cursor flags
1029	.c49f	aa		tax		                tax
1030	.c4a0	ad 23 03	lda $0323	                lda vduv.queueEnd-1          ;Y coordinate
1031	.c4a3	20 d7 cc	jsr $ccd7	                jsr LCCD7
1032	.c4a6	fa		plx		                plx                    ;restore true cursorFlags bits
1033	.c4a7	90 11		bcc $c4ba	                bcc LC4BA              ;taken if no scrolling required
1034	.c4a9	a9 01		lda #$01	                lda #vduv.cursorFlags.scrollProtect
1035	.c4ab	2c 66 03	bit $0366	                bit $0366
1036	.c4ae	f0 11		beq $c4c1	                beq LC4C1                 ;taken if scroll protect off

1038						                ; Wrap text cursor X.
1039	.c4b0	ad 22 03	lda $0322	                lda vduv.queueEnd-2       ;X coordinate
1040	.c4b3	3a		dec a		                dec a
1041	.c4b4	20 d7 cc	jsr $ccd7	                jsr LCCD7
1042	.c4b7	b0 08		bcs $c4c1	                bcs LC4C1
1043	.c4b9	38		sec		                sec
1044	.c4ba					LC4BA:
1045	.c4ba	6e 6c 03	ror $036c	                ror vduv.column81
1046	.c4bd	68		pla		                pla                          ;discard old Y pos
1047	.c4be	68		pla		                pla                          ;discard old X pos
1048	.c4bf	80 0b		bra $c4cc	                bra LC4CC

1050	.c4c1					LC4C1:
1051	.c4c1	68		pla		                pla
1052	.c4c2	8d 19 03	sta $0319	                sta vduv.textCursorYPosition ;restore old Y pos
1053	.c4c5	68		pla		                pla
1054	.c4c6	8d 18 03	sta $0318	                sta vduv.textCursorXPosition ;restore old X pos
1055	.c4c9	20 fa cc	jsr $ccfa	                jsr updateZMEMTWithTextCursorPosition
1056	.c4cc					LC4CC:
1057	.c4cc	4c ed c6	jmp $c6ed	                jmp updateCRTCCursorAddress

1059	.c4cf					LC4CF:
1060	.c4cf	ad 22 03	lda $0322	                lda $0322
1061	.c4d2	20 e0 c1	jsr $c1e0	                jsr LC1E0
1062	.c4d5	8a		txa		                txa
1063	.c4d6	49 08		eor #$08	                eor #$08
1064	.c4d8	aa		tax		                tax
1065	.c4d9	ad 23 03	lda $0323	                lda $0323
1066	.c4dc	20 e0 c1	jsr $c1e0	                jsr LC1E0
1067	.c4df					LC4DF:
1068	.c4df	a0 10		ldy #$10	                ldy #$10
1069	.c4e1	20 1c c9	jsr $c91c	                jsr copyGraphicsCursorPixels
1070	.c4e4	a2 02		ldx #$02	                ldx #$02
1071	.c4e6	a0 02		ldy #$02	                ldy #$02
1072	.c4e8	20 fc c4	jsr $c4fc	                jsr LC4FC
1073	.c4eb	a2 00		ldx #$00	                ldx #$00
1074	.c4ed	a0 04		ldy #$04	                ldy #$04
1075	.c4ef	ad 61 03	lda $0361	                lda $0361
1076	.c4f2					LC4F2:
1077	.c4f2	88		dey		                dey
1078	.c4f3	4a		lsr a		                lsr a
1079	.c4f4	d0 fc		bne $c4f2	                bne LC4F2
1080	.c4f6	ad 56 03	lda $0356	                lda $0356
1081	.c4f9	f0 01		beq $c4fc	                beq LC4FC
1082	.c4fb	c8		iny		                iny
1083	.c4fc					LC4FC:
1084	.c4fc	1e 10 03	asl $0310,x	                asl $0310,x
1085	.c4ff	3e 11 03	rol $0311,x	                rol $0311,x
1086	.c502	88		dey		                dey
1087	.c503	d0 f7		bne $c4fc	                bne LC4FC
1088	.c505	38		sec		                sec
1089	.c506	20 0a c5	jsr $c50a	                jsr LC50A
1090	.c509	e8		inx		                inx
1091	.c50a					LC50A:
1092	.c50a	bd 10 03	lda $0310,x	                lda $0310,x
1093	.c50d	fd 0c 03	sbc $030c,x	                sbc $030C,x
1094	.c510	9d 10 03	sta $0310,x	                sta $0310,x
1095	.c513	60		rts		                rts

1097						;-------------------------------------------------------------------------
1098						;
1099						; VDU 14 (&0E) Page mode on [MasRef E.3-6]
1100						;
1101	.c514					vdu14EntryPoint:
1102	.c514	9c 69 02	stz $0269	                stz pagedModeCounter
1103	.c517	a9 91		lda #$91	                lda #$91

1105						;-------------------------------------------------------------------------
1106						;
1107						; VDU 21 (&15) Disable VDU driver [MasRef E.3-11]
1108						;
1109	.c519					vdu21EntryPoint:
1110	.c519	49 95		eor #$95	                eor #$95
1111	.c51b					LC51B:
1112	.c51b	04 d0		tsb $d0		                tsb STATE
1113	.c51d	60		rts		                rts

1115						;-------------------------------------------------------------------------
1116						;
1117						; VDU 4 (&04) Print at text cursor [MasRef E.3-2]
1118						;
1119	.c51e					vdu4EntryPoint:
1120	.c51e	ad 61 03	lda $0361	                lda $0361
1121	.c521	f0 09		beq $c52c	                beq LC52C
1122	.c523	20 50 cf	jsr $cf50	                jsr showCursor
1123	.c526	a9 2b		lda #$2b	                lda #$2B

1125						                ; fall through to vdu15EntryPoint

1127						;-------------------------------------------------------------------------
1128						;
1129						; VDU 15 (&0F) Page mode off [MasRef E.3-6]
1130						;
1131	.c528					vdu15EntryPoint:
1132	.c528	49 0b		eor #$0b	                eor #$0B
1133	.c52a	14 d0		trb $d0		                trb STATE
1134	.c52c					LC52C:
1135	.c52c	60		rts		                rts

1137						;-------------------------------------------------------------------------
1138						;
1139						; VDU 5 (&05) Print text at graphics cursor [MasRef E.3-3]
1140						;
1141	.c52d					vdu5EntryPoint:
1142	.c52d	ad 61 03	lda $0361	                lda $0361
1143	.c530	f0 fa		beq $c52c	                beq LC52C
1144	.c532	a9 20		lda #$20	                lda #$20
1145	.c534	20 53 cf	jsr $cf53	                jsr setCRTCRegister10
1146	.c537	80 e2		bra $c51b	                bra LC51B

1148						;-------------------------------------------------------------------------
1149						;
1150						; VDU 17 (&11) Define text colour [MasRef E.3-7]
1151						;
1152	.c539					vdu17EntryPoint:
1153	.c539	a0 00		ldy #$00	                ldy #$00
1154	.c53b	ad 23 03	lda $0323	                lda $0323
1155	.c53e	10 01		bpl $c541	                bpl LC541
1156	.c540	c8		iny		                iny
1157	.c541					LC541:
1158	.c541	2d 60 03	and $0360	                and $0360
1159	.c544	85 da		sta $da		                sta $DA
1160	.c546	ad 60 03	lda $0360	                lda $0360
1161	.c549	f0 18		beq $c563	                beq LC563
1162	.c54b	29 07		and #$07	                and #$07
1163	.c54d	18		clc		                clc
1164	.c54e	65 da		adc $da		                adc $DA
1165	.c550	aa		tax		                tax
1166	.c551	bd 5b e1	lda $e15b,x	                lda solidColoursTable-1,x
1167	.c554	99 57 03	sta $0357,y	                sta $0357,y
1168	.c557	ad 57 03	lda $0357	                lda $0357
1169	.c55a	49 ff		eor #$ff	                eor #$FF
1170	.c55c	85 d3		sta $d3		                sta ZEOR
1171	.c55e	4d 58 03	eor $0358	                eor $0358
1172	.c561	85 d2		sta $d2		                sta ZORA
1173	.c563					LC563:
1174	.c563	60		rts		                rts

1176						;-------------------------------------------------------------------------
1177						;
1178						; VDU 18 (&12) Define graphics colour [MasRef E.3-7]
1179						;
1180	.c564					vdu18EntryPoint:
1181	.c564	a0 00		ldy #$00	                ldy #$00                    ;assume setting foreground
1182	.c566	ad 23 03	lda $0323	                lda vduv.queueEnd-1         ;get colour
1183	.c569	10 01		bpl $c56c	                bpl +                     ;taken if setting foreground
1184	.c56b	c8		iny		                iny                       ;setting background
1185	.c56c					+
1186	.c56c	2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne
1187	.c56f	99 6d 03	sta $036d,y	                sta vduv.foregroundGraphicsColour,y
1188	.c572	ad 22 03	lda $0322	                lda vduv.queueEnd-2          ;get GCOL mode
1189	.c575	99 5b 03	sta $035b,y	                sta vduv.foregroundGCOLMode,y
1190	.c578	29 f0		and #$f0	                and #$F0                     ;non-zero if ECF
1191	.c57a	99 6a 03	sta $036a,y	                sta vduv.isForegroundECF,y
1192	.c57d					initializeCurrentECFPatterns:
1193	.c57d	ad 5b 03	lda $035b	                lda vduv.foregroundGCOLMode
1194	.c580	ae 6d 03	ldx $036d	                ldx vduv.foregroundGraphicsColour
1195	.c583	a0 00		ldy #$00	                ldy #andy.fgECFPattern-andy.currentECFPatterns
1196	.c585	20 90 c5	jsr $c590	                jsr initializeCurrentECFPattern
1197	.c588	ad 5c 03	lda $035c	                lda vduv.backgroundGCOLMode
1198	.c58b	ae 6e 03	ldx $036e	                ldx vduv.backgroundGraphicsColour
1199	.c58e	a0 08		ldy #$08	                ldy #andy.bgECFPattern-andy.currentECFPatterns
1200	.c590					initializeCurrentECFPattern:
1201	.c590	29 f0		and #$f0	                and #$F0                     ;GCOL mode ECF bits
1202	.c592	d0 18		bne $c5ac	                bne initializeECFPatternFromPattern

1204	.c594					initializeECFPatternFromColour:
1205	.c594	86 da		stx $da		                stx ZTEMP+0                  ;colour low bits
1206	.c596	ad 60 03	lda $0360	                lda vduv.numberOfLogicalColoursMinusOne
1207	.c599	29 07		and #$07	                and #$07
1208	.c59b	18		clc		                clc
1209	.c59c	65 da		adc $da		                adc ZTEMP+0
1210	.c59e	aa		tax		                tax
1211						                ; use solid colour as ECF "pattern".
1212	.c59f	bd 5b e1	lda $e15b,x	                lda solidColoursTable-1,x
1213	.c5a2	a2 07		ldx #$07	                ldx #$07
1214	.c5a4					-
1215	.c5a4	99 20 88	sta $8820,y	                sta andy.fgECFPattern,y
1216	.c5a7	c8		iny		                iny
1217	.c5a8	ca		dex		                dex
1218	.c5a9	10 f9		bpl $c5a4	                bpl -
1219	.c5ab	60		rts		                rts

1221	.c5ac					initializeECFPatternFromPattern:
1222	.c5ac	4a		lsr a		                lsr a                        ;(index+1)*8
1223	.c5ad	aa		tax		                tax
1224	.c5ae	a9 07		lda #$07	                lda #$07
1225	.c5b0	85 da		sta $da		                sta ZTEMP+0
1226	.c5b2					-
1227	.c5b2	bd f8 87	lda $87f8,x	                lda andy.ecfPatterns-8,x     ;-8 due to index+1 above
1228	.c5b5	99 20 88	sta $8820,y	                sta andy.fgECFPattern,y
1229	.c5b8	e8		inx		                inx
1230	.c5b9	c8		iny		                iny
1231	.c5ba	c6 da		dec $da		                dec ZTEMP+0
1232	.c5bc	10 f4		bpl $c5b2	                bpl -
1233	.c5be	60		rts		                rts

1235						;-------------------------------------------------------------------------
1236						;
1237						; VDU 20 (&14) Restore default logical colours [MasRef E.3-10]
1238						;
1239	.c5bf					setBackgroundTextColourForTeletext:
1240	.c5bf	a9 20		lda #$20	                lda #' '
1241	.c5c1	8d 58 03	sta $0358	                sta vduv.backgroundTextColour
1242	.c5c4	60		rts		                rts

1244	.c5c5					vdu20EntryPoint:
1245	.c5c5	a2 05		ldx #$05	                ldx #$05
1246	.c5c7					-
1247	.c5c7	9e 57 03	stz $0357,x	                stz vduv.foregroundTextColour,x
1248	.c5ca	ca		dex		                dex
1249	.c5cb	10 fa		bpl $c5c7	                bpl -
1250	.c5cd	9c 6e 03	stz $036e	                stz vduv.backgroundGraphicsColour
1251	.c5d0	9c 6b 03	stz $036b	                stz vduv.isBackgroundECF
1252	.c5d3	a9 ff		lda #$ff	                lda #%11111111
1253	.c5d5	ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
1254	.c5d8	f0 e5		beq $c5bf	                beq setBackgroundTextColourForTeletext
1255	.c5da	e0 0f		cpx #$0f	                cpx #$0F
1256	.c5dc	d0 02		bne $c5e0	                bne +                        ;taken unless MODE 2
1257	.c5de	a9 3f		lda #$3f	                lda #%00111111               ;MODE 2 default foreground colour is 7
1258	.c5e0					+
1259	.c5e0	8d 57 03	sta $0357	                sta vduv.foregroundTextColour
1260	.c5e3	49 ff		eor #$ff	                eor #$FF
1261	.c5e5	85 d2		sta $d2		                sta ZORA
1262	.c5e7	85 d3		sta $d3		                sta ZEOR
1263	.c5e9	8a		txa		                txa
1264	.c5ea	29 07		and #$07	                and #$07
1265	.c5ec	8d 6d 03	sta $036d	                sta vduv.foregroundGraphicsColour
1266	.c5ef	9c 6a 03	stz $036a	                stz vduv.isForegroundECF
1267	.c5f2	da		phx		                phx                          ;save numberOfLogicalColoursMinusOne
1268	.c5f3	20 7d c5	jsr $c57d	                jsr initializeCurrentECFPatterns
1269	.c5f6	fa		plx		                plx                          ;restore numberOfLogicalColoursMinusOne
1270	.c5f7	8e 1f 03	stx $031f	                stx vduv.queueEnd-5          ;Prepare VDU19,<max logical colour>
1271	.c5fa	e0 03		cpx #$03	                cpx #$03
1272	.c5fc	f0 11		beq $c60f	                beq reset4Colours            ;taken if MODE 1/5
1273	.c5fe	90 20		bcc $c620	                bcc reset2Colours            ;taken if MODE 0/3/4/6
1274	.c600					reset16Colours:
1275	.c600	8e 20 03	stx $0320	                stx vduv.queueEnd-4          ;start with VDU19,15,15,_,_,_
1276	.c603					-
1277	.c603	20 2d c6	jsr $c62d	                jsr vdu19EntryPoint
1278	.c606	ce 20 03	dec $0320	                dec vduv.queueEnd-4
1279	.c609	ce 1f 03	dec $031f	                dec vduv.queueEnd-5
1280	.c60c	10 f5		bpl $c603	                bpl -
1281	.c60e	60		rts		                rts

1283	.c60f					reset4Colours:
1284	.c60f	a2 07		ldx #$07	                ldx #$07
1285	.c611	8e 20 03	stx $0320	                stx vduv.queueEnd-4          ;start with VDU19,3,7,_,_,_
1286	.c614					-
1287	.c614	20 2d c6	jsr $c62d	                jsr vdu19EntryPoint          ;2,3, then 1,1, then 0,0
1288	.c617	4e 20 03	lsr $0320	                lsr vduv.queueEnd-4
1289	.c61a	ce 1f 03	dec $031f	                dec vduv.queueEnd-5
1290	.c61d	10 f5		bpl $c614	                bpl -
1291	.c61f	60		rts		                rts

1293	.c620					reset2Colours:
1294	.c620	a2 07		ldx #$07	                ldx #$07
1295	.c622	20 2a c6	jsr $c62a	                jsr +                        ;VDU19,1,7,_,_,_
1296	.c625	a2 00		ldx #$00	                ldx #$00
1297	.c627	9c 1f 03	stz $031f	                stz vduv.queueEnd-5          ;VDU19,0,0,_,_,_
1298	.c62a					+
1299	.c62a	8e 20 03	stx $0320	                stx vduv.queueEnd-4          ;VDU19,N,X,_,_,_

1301						                ; fall through to VDU19

1303						;-------------------------------------------------------------------------
1304						;
1305						; VDU 19 (&13) Define logical colour [MasRef E.3-9]
1306						;
1307	.c62d					vdu19EntryPoint:
1308	.c62d	08		php		                php
1309	.c62e	78		sei		                sei
1310	.c62f	ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get logical colour
1311	.c632	2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne ;apply logical colour limit
1312	.c635	aa		tax		                tax                        ;X = clamped logical colour
1313	.c636	ad 20 03	lda $0320	                lda vduv.queueEnd-4        ;get physical colour
1314	.c639					LC639:
1315	.c639	29 0f		and #$0f	                and #$0F                     ;apply physical colour limit
1316	.c63b	9d 6f 03	sta $036f,x	                sta vduv.currentPalette,x    ;update palette
1317	.c63e	a8		tay		                tay                          ;Y = physical colour
1318	.c63f	ad 60 03	lda $0360	                lda vduv.numberOfLogicalColoursMinusOne
1319	.c642	85 fa		sta $fa		                sta SEIWKA
1320	.c644	c9 03		cmp #$03	                cmp #$03 ;Z=1 C=1 if 4 colour; Z=0 C=1 if 16 colour; Z=0 C=0 if 2 colour
1321	.c646	08		php		                php      ;save flags
1322	.c647	8a		txa		                txa                          ;A = logical colour

1324						                ;put the logical colour value in the top 1, 2 or 4
1325						                ;bits of SEIWKA, depending on the colour depth.
1326						                ;
1327						                ; 2 colours: turn %0000000a into %a0000000
1328						                ; 4 colours: turn %000000ab into %ab000000
1329						                ;16 colours: turn %0000abcd into %abcd0000
1330	.c648					-
1331	.c648	4a		lsr a		                lsr a
1332	.c649	66 fa		ror $fa		                ror SEIWKA
1333	.c64b	b0 fb		bcs $c648	                bcs -
1334	.c64d	06 fa		asl $fa		                asl SEIWKA

1336	.c64f	98		tya		                tya                          ;A = physical colour
1337	.c650	05 fa		ora $fa		                ora SEIWKA                   ;mix in logical colour
1338	.c652	aa		tax		                tax                          ;X = VPALETTE value
1339	.c653	a0 f0		ldy #$f0	                ldy #$F0 ;counts up to zero - counter for setting
1340						                         ;multiple logical colours [AUG p380]
1341	.c655					LC655:
1342	.c655	28		plp		                plp                          ;restore flags
1343	.c656	08		php		                php                          ;save flags
1344	.c657	d0 03		bne $c65c	                bne +                     ;taken if 2 colour/16 colour
1345	.c659	20 6f c6	jsr $c66f	                jsr fixUpVPALETTEFor4Colours
1346	.c65c					+
1347	.c65c	20 20 f3	jsr $f320	                jsr writeVPALETTE
1348	.c65f	18		clc		                clc
1349	.c660	98		tya		                tya
1350	.c661	6d 60 03	adc $0360	                adc vduv.numberOfLogicalColoursMinusOne
1351	.c664	a8		tay		                tay
1352	.c665	8a		txa		                txa
1353	.c666	69 10		adc #$10	                adc #$10                     ;next logical colour
1354	.c668	aa		tax		                tax
1355	.c669	c8		iny		                iny                          ;Y+=numberOfLogicalColours
1356	.c66a	d0 e9		bne $c655	                bne LC655                    ;all logical colours set once zero
1357	.c66c	28		plp		                plp
1358	.c66d	28		plp		                plp
1359	.c66e	60		rts		                rts

1361	.c66f					fixUpVPALETTEFor4Colours:
1362	.c66f	2a		rol a		                rol a                        ;A BCDabcd1
1363	.c670	85 da		sta $da		                sta ZTEMP+0                  ;  BCDabcd1
1364	.c672	2a		rol a		                rol a                        ;B CDabcd1A
1365	.c673	2a		rol a		                rol a                        ;C Dabcd1AB
1366	.c674	08		php		                php                          ;C
1367	.c675	26 da		rol $da		                rol ZTEMP+0                  ;B CDabcd1C
1368	.c677	6a		ror a		                ror a                        ;B BDabcd1A
1369	.c678	28		plp		                plp                          ;C BDabcd1A
1370	.c679	6a		ror a		                ror a                        ;A CBDabcd1
1371	.c67a	6a		ror a		                ror a                        ;1 ACBDabcd
1372	.c67b	60		rts		                rts                          ;

1374						;-------------------------------------------------------------------------
1375						;
1376						; VDU 23 (&17) Various functions [MasRef E.3-12]
1377						;
1378	.c67c					vdu23EntryPoint:
1379	.c67c	ad 1b 03	lda $031b	                lda vduv.queueEnd-9           ;get VDU 23 code
1380	.c67f	c9 20		cmp #$20	                cmp #$20
1381	.c681	90 0e		bcc $c691	                bcc LC691         ;branch taken if <32 - i.e., special

1383						                ; copy the 8 bytes of character definition to the
1384						                ; appropriate place.
1385	.c683	20 3c e2	jsr $e23c	                jsr getSoftCharacterDefinitionAddress
1386	.c686	a0 07		ldy #$07	                ldy #$07
1387	.c688					LC688:
1388	.c688	b9 1c 03	lda $031c,y	                lda vduv.queueEnd-8,y
1389	.c68b	91 de		sta ($de),y	                sta ($DE),y
1390	.c68d	88		dey		                dey
1391	.c68e	10 f8		bpl $c688	                bpl LC688
1392	.c690	60		rts		                rts

1394	.c691					LC691:
1395	.c691	0a		asl a		                asl a
1396	.c692	aa		tax		                tax
1397	.c693	4a		lsr a		                lsr a
1398	.c694	c9 11		cmp #$11	                cmp #$11
1399	.c696	b0 0f		bcs $c6a7	                bcs callVDUV    ;call with C=1 - invalid code [MasRef
1400						                                ;E.3-19]
1401	.c698	7c 79 e0	jmp ($e079,x)	                jmp (vdu23EntryPointTable,x)

1403						;-------------------------------------------------------------------------
1404						;
1405						; VDU 25 (&19) PLOT commands [MasRef E.3-21]
1406						;
1407	.c69b					vdu25EntryPoint:
1408	.c69b	ae 61 03	ldx $0361	                ldx vduv.pixelsPerByteMinusOne
1409	.c69e	f0 03		beq $c6a3	                beq callVDUVForPLOT          ;non-graphics PLOT
1410	.c6a0	4c 46 d1	jmp $d146	                jmp handlePLOT

1412						;-------------------------------------------------------------------------
1413						;
1414						; Call VDUV for a PLOT call, either to handle non-graphics PLOT
1415						; [MasRef E.3-21] or PLOT 240-255 [MasRef E.3-34].
1416						;
1417	.c6a3					callVDUVForPLOT:
1418	.c6a3	ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT code
1419	.c6a6	18		clc		                clc ;call with C=0 - non-graphics PLOT [MasRef E.3-21]

1421						;-------------------------------------------------------------------------
1422						;
1423						; Call VDUV.
1424						;
1425	.c6a7					callVDUV:
1429	.c6a7	4c f3 e2	jmp $e2f3	                jmp LE2F3

1432						;-------------------------------------------------------------------------
1433						;
1434						; VDU 26 (&1A) Restore default windows [MasRef E.3-34]
1435						;
1436	.c6aa					vdu26EntryPoint:
1437	.c6aa	a2 2c		ldx #$2c	                ldx #VDUVariables.workspace._2C
1438	.c6ac					-
1439	.c6ac	9e 00 03	stz $0300,x	                stz vduv,x                    ;reset workspace
1440	.c6af	ca		dex		                dex
1441	.c6b0	10 fa		bpl $c6ac	                bpl -

1443	.c6b2	20 b2 e2	jsr $e2b2	                jsr getDefaultBoundsForCurrentScreenMODE
1444	.c6b5	8e 0a 03	stx $030a	                stx vduv.textWindowRight
1445	.c6b8	8c 09 03	sty $0309	                sty vduv.textWindowBottom

1447	.c6bb	8a		txa		                txa
1448	.c6bc	20 80 c7	jsr $c780	                jsr setTextWindowWidthInBytes

1450						                ; Set up the VDU queue as if VDU 24,0;0;1279;1023;,
1451						                ; then call the VDU 24 entry point.

1453						                ; 1c - ll - $00
1454						                ; 1d - lh - $00
1455						                ; 1e - tl - $00
1456						                ; 1f - th - $00
1457						                ; 20 - rl - $ff
1458						                ; 21 - rh - $04
1459						                ; 22 - tl - $ff
1460						                ; 23 - th - $03

1462	.c6bf	a0 03		ldy #$03	                ldy #$03
1463	.c6c1	8c 23 03	sty $0323	                sty $0323
1464	.c6c4	c8		iny		                iny
1465	.c6c5	8c 21 03	sty $0321	                sty $0321
1466	.c6c8	ce 22 03	dec $0322	                dec $0322
1467	.c6cb	ce 20 03	dec $0320	                dec $0320
1468	.c6ce	20 1f c7	jsr $c71f	                jsr vdu24EntryPoint

1470	.c6d1	a9 08		lda #$08	                lda #STATE.isTextWindow
1471	.c6d3	14 d0		trb $d0		                trb STATE                    ;reset isTextWindow

1473	.c6d5	4c 7c c4	jmp $c47c	                jmp vdu30EntryPoint          ;reset text cursor

1475						;-------------------------------------------------------------------------
1476						;
1477						; Update CRTC cursor address to reflect text cursor position.
1478						;
1479	.c6d8					updateCRTCTextCursor:
1480	.c6d8	20 fa cc	jsr $ccfa	                jsr updateZMEMTWithTextCursorPosition
1481	.c6db	80 10		bra $c6ed	                bra updateCRTCCursorAddress

1483						;-------------------------------------------------------------------------

1485	.c6dd					setCRTCCursorAddress:
1486	.c6dd	8e 4a 03	stx $034a	                stx vduv.textCursorCRTCAddress+0
1487	.c6e0	8d 4b 03	sta $034b	                sta vduv.textCursorCRTCAddress+1
1488	.c6e3	10 04		bpl $c6e9	                bpl +
1489	.c6e5	38		sec		                sec
1490	.c6e6	ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte
1491	.c6e9					+
1492	.c6e9	86 d8		stx $d8		                stx ZMEMT+0
1493	.c6eb	85 d9		sta $d9		                sta ZMEMT+1

1495						;-------------------------------------------------------------------------
1496						;
1497						;
1498	.c6ed					updateCRTCCursorAddress:
1504	.c6ed	ae 4a 03	ldx $034a	                ldx vduv.textCursorCRTCAddress+0
1505	.c6f0	ad 4b 03	lda $034b	                lda vduv.textCursorCRTCAddress+1
1506	.c6f3	a0 0e		ldy #$0e	                ldy #$0E

1508						;-------------------------------------------------------------------------
1509						;
1510						; Set CRTC address - cursor, or screen start.
1511						;
1512						; entry:
1513						;
1514						; A (msb), X (msb) = 6502 address to set
1515						;
1516						; Y = first CRTC register to set
1517						;
1519						; C = 1 if in Mode 7
1521						;
1522	.c6f5					setCRTCAddress:
1524	.c6f5	48		pha		                pha                          ;save screen address MSB
1525	.c6f6	ad 55 03	lda $0355	                lda vduv.currentScreenMODE
1526	.c6f9	c9 07		cmp #$07	                cmp #$07
1527	.c6fb	68		pla		                pla                        ;restore screen address MSB
1529	.c6fc	b0 0f		bcs $c70d	                bcs adjustAddressForMODE7
1530	.c6fe	86 da		stx $da		                stx ZTEMP+0
1531	.c700	4a		lsr a		                lsr a
1532	.c701	66 da		ror $da		                ror ZTEMP+0                  ;/2
1533	.c703	4a		lsr a		                lsr a
1534	.c704	66 da		ror $da		                ror ZTEMP+0                  ;/4
1535	.c706	4a		lsr a		                lsr a
1536	.c707	66 da		ror $da		                ror ZTEMP+0                  ;/8
1537	.c709	a6 da		ldx $da		                ldx ZTEMP+0
1538	.c70b	80 04		bra $c711	                bra setCRTCAddressRegisters

1540	.c70d					adjustAddressForMODE7:
1541						                ; C=1
1548	.c70d	e9 74		sbc #$74	                sbc #$74                 ;adjust for Mode 7 addressing
1549	.c70f	49 20		eor #$20	                eor #$20                 ;adjust for Mode 7 addressing
1551	.c711					setCRTCAddressRegisters:
1552	.c711	8c 00 fe	sty $fe00	                sty CRTC+0
1553	.c714	8d 01 fe	sta $fe01	                sta CRTC+1
1554	.c717	c8		iny		                iny
1555	.c718	8c 00 fe	sty $fe00	                sty CRTC+0
1556	.c71b	8e 01 fe	stx $fe01	                stx CRTC+1
1557	.c71e	60		rts		                rts

1559						;-------------------------------------------------------------------------
1560						;
1561						; VDU 24 (&18) Define graphics window [MasRef E.3-21]
1562						;
1563						; VDU queue:
1564						;
1565						; -8 = <left
1566						; -7 = >left
1567						; -6 = <bottom
1568						; -5 = >bottom
1569						; -4 = <right
1570						; -3 = >right
1571						; -2 = <top
1572						; -1 = >top
1573						;
1574	.c71f					vdu24EntryPoint:
1575	.c71f	20 79 c7	jsr $c779	                jsr LC779

1577	.c722	a2 02		ldx #$02	                ldx #2
1578	.c724					-
1579	.c724	38		sec		                sec

1581						                ; <height when X=2, then <width when X=0
1582	.c725	bd 20 03	lda $0320,x	                lda vduv.queueEnd-4+0,x
1583	.c728	fd 1c 03	sbc $031c,x	                sbc vduv.queueEnd-8+0,x
1584	.c72b	9d 2c 03	sta $032c,x	                sta vduv.workspace._2C+0,x

1586						                ; >height when X=2, then >width when X=0
1587	.c72e	bd 21 03	lda $0321,x	                lda vduv.queueEnd-4+1,x
1588	.c731	fd 1d 03	sbc $031d,x	                sbc vduv.queueEnd-8+1,x
1589	.c734	9d 2d 03	sta $032d,x	                sta vduv.workspace._2C+1,x

1591	.c737	ca		dex		                dex
1592	.c738	ca		dex		                dex
1593	.c739	10 e9		bpl $c724	                bpl -

1595	.c73b	0d 2f 03	ora $032f	                ora vduv.workspace._2C+3     ;A=>width|>height
1596	.c73e	30 39		bmi $c779	                bmi LC779 ;taken if either dimension negative - window invalid
1597	.c740	a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4 ;left bottom
1598	.c742	20 de d1	jsr $d1de	                jsr eigabsEntryPoint         ;convert to pixels
1599	.c745	a2 1c		ldx #$1c	                ldx #VDUVariables.queueEnd-8 ;right top
1600	.c747	20 de d1	jsr $d1de	                jsr eigabsEntryPoint         ;convert to pixels
1601	.c74a	ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;>bottom
1602	.c74d	0d 1d 03	ora $031d	                ora vduv.queueEnd-7          ;>left
1603	.c750	30 27		bmi $c779	                bmi LC779 ;taken if either bottom or left negative - window invalid
1604	.c752	ad 23 03	lda $0323	                lda vduv.queueEnd-1          ;>top
1605	.c755	d0 22		bne $c779	                bne LC779          ;taken if top>=256 - window invalid
1606	.c757	ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
1607	.c75a	ad 21 03	lda $0321	                lda vduv.queueEnd-3          ;>right
1608	.c75d	85 da		sta $da		                sta ZTEMP+0
1609	.c75f	ad 20 03	lda $0320	                lda vduv.queueEnd-4          ;<right
1610	.c762	46 da		lsr $da		                lsr ZTEMP+0                  ;>(right/2)
1611	.c764	6a		ror a		                ror a                        ;<(right/2)
1612	.c765	46 da		lsr $da		                lsr ZTEMP+0                  ;>(right/4)

1614						                ; 639>>2=159 - so any valid pixel X in any mode will
1615						                ; have an MSB of 0 after being shifted right 2.
1616	.c767	d0 10		bne $c779	                bne LC779 ;taken if right edge definitely off screen - window invalid
1617	.c769	6a		ror a		                ror a     ;<(right/4)
1618	.c76a	4a		lsr a		                lsr a     ;<(right/8)
1619	.c76b	dd 19 e1	cmp $e119,x	                cmp modeMaxColumn,x
1620	.c76e	f0 02		beq $c772	                beq LC772                    ;taken if right edge just on screen
1621	.c770	10 07		bpl $c779	                bpl LC779 ;taken if right edge off screen - window definitely invalid
1622	.c772					LC772:
1623	.c772	a0 00		ldy #$00	                ldy #VDUVariables.graphicsWindowPixelsLeft
1624	.c774	a2 1c		ldx #$1c	                ldx #VDUVariables.queueEnd-8
1625	.c776	20 04 c9	jsr $c904	                jsr copyEightBytesWithinVDUVariables
1626	.c779					LC779:
1627	.c779	a2 10		ldx #$10	                ldx #VDUVariables.graphicsCursorPositionX
1628	.c77b	a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
1629	.c77d	4c ca e2	jmp $e2ca	                jmp exchangeFourVDUBytes

1631						;-------------------------------------------------------------------------
1632						;
1633						; Call getBytesPerInclusiveTextRow, and store the result in the
1634						; textWindowWidthInBytes VDU variable.
1635						;
1636	.c780					setTextWindowWidthInBytes:
1637	.c780	20 3b c9	jsr $c93b	                jsr getBytesPerInclusiveTextRow
1638	.c783	8d 4c 03	sta $034c	                sta vduv.textWindowWidthInBytes+0
1639	.c786	8e 4d 03	stx $034d	                stx vduv.textWindowWidthInBytes+1
1640	.c789	60		rts		                rts

1642						;-------------------------------------------------------------------------
1643						;
1644						; VDU 29 (&1D) Define graphics origin [MasRef E.3-35]
1645						;
1646	.c78a					vdu29EntryPoint:
1647	.c78a	a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
1648	.c78c	a0 0c		ldy #$0c	                ldy #VDUVariables.graphicsWindowOriginX
1649	.c78e	20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
1650	.c791	4c df c4	jmp $c4df	                jmp LC4DF

1652						;-------------------------------------------------------------------------
1653						;
1654						; VDU 22 (&16) Select screen mode [MasRef E.3-11]
1655						;
1656	.c794					vdu22EntryPoint:
1657	.c794	ad 23 03	lda $0323	                lda vduv.queueEnd-1          ;get MODE number
1658	.c797	80 23		bra $c7bc	                bra setMODE

1660						;-------------------------------------------------------------------------
1661						;
1662	.c799					setStartupMODE:
1666	.c799	85 da		sta $da		                sta ZTEMP+0                  ;save MODE
1667	.c79b	a5 f4		lda $f4		                lda $F4
1668	.c79d	48		pha		                pha
1669	.c79e	09 80		ora #$80	                ora #$80                     ;page in ANDY
1670	.c7a0	20 ab e5	jsr $e5ab	                jsr selectROMA
1671	.c7a3	20 aa c7	jsr $c7aa	                jsr +
1672	.c7a6	68		pla		                pla
1673	.c7a7	4c ab e5	jmp $e5ab	                jmp selectROMA               ;restore old ROM

1675	.c7aa					+
1676						                ; TODO but what of the reserved byte here?
1677	.c7aa	a2 7f		ldx #$7f	                ldx #size(VDUVariables)-1
1678	.c7ac	64 d0		stz $d0		                stz STATE
1679	.c7ae	ad 66 03	lda $0366	                lda vduv.cursorFlags
1680	.c7b1					-
1681	.c7b1	9e ff 02	stz $02ff,x	                stz vduv-1,x
1682	.c7b4	ca		dex		                dex
1683	.c7b5	d0 fa		bne $c7b1	                bne -
1684	.c7b7	8d 66 03	sta $0366	                sta vduv.cursorFlags
1685	.c7ba	a5 da		lda $da		                lda ZTEMP                    ;restore MODE

1687						                ; fall through to setMODE

1689						;-------------------------------------------------------------------------
1690						;
1691						;
1692						;
1693	.c7bc					setMODE:
1694	.c7bc	9c 8a 02	stz $028a	                stz vduDriverMemory
1695	.c7bf	9c 8b 02	stz $028b	                stz displayMemory
1696	.c7c2	a8		tay		                tay                          ;Y=mode
1697	.c7c3	30 10		bmi $c7d5	                bmi setShadowMODE
1698	.c7c5	ae 7f 02	ldx $027f	                ldx shadowRAMState
1699	.c7c8	f0 0b		beq $c7d5	                beq setShadowMODE
1700	.c7ca	a9 10		lda #$10	                lda #STATE.isShadowMode
1701	.c7cc	14 d0		trb $d0		                trb STATE
1702	.c7ce	a9 03		lda #$03	                lda #ACCCON.D|ACCCON.E
1703	.c7d0	1c 34 fe	trb $fe34	                trb ACCCON ;display main RAM, VDU code accesses main RAM
1704	.c7d3	80 09		bra $c7de	                bra +

1706	.c7d5					setShadowMODE:
1707	.c7d5	a9 10		lda #$10	                lda #STATE.isShadowMode
1708	.c7d7	04 d0		tsb $d0		                tsb STATE
1709	.c7d9	a9 03		lda #$03	                lda #ACCCON.D|ACCCON.E
1710	.c7db	0c 34 fe	tsb $fe34	                tsb ACCCON ;display shadow RAM, VDU code accesses shadow RAM
1711	.c7de					+
1712	.c7de	98		tya		                tya                          ;A=mode
1713	.c7df	29 07		and #$07	                and #$07                     ;get MODE 0-7
1714	.c7e1	aa		tax		                tax                          ;X=MODE 0-7
1715	.c7e2	8e 55 03	stx $0355	                stx vduv.currentScreenMODE
1716	.c7e5	bd 4c e1	lda $e14c,x	                lda numberOfLogicalColoursMinusOneForMODE,x
1717	.c7e8	8d 60 03	sta $0360	                sta vduv.numberOfLogicalColoursMinusOne
1718	.c7eb	bd 29 e1	lda $e129,x	                lda bytesPerCharacterForMODE,x
1719	.c7ee	8d 4f 03	sta $034f	                sta vduv.bytesPerCharacter
1720	.c7f1	bd 72 e1	lda $e172,x	                lda pixelsPerByteMinusOneForMODE,x
1721	.c7f4	8d 61 03	sta $0361	                sta vduv.pixelsPerByteMinusOne
1722	.c7f7	d0 02		bne $c7fb	                bne +                        ;taken if graphics mode
1723	.c7f9	a9 07		lda #$07	                lda #$07                     ;assume 8 px/byte for non-graphics modes
1724	.c7fb					+
1725	.c7fb	0a		asl a		                asl a            ;convert to pixelMasks index for rightmost pixel
1726	.c7fc	a8		tay		                tay
1727	.c7fd	b9 3e e1	lda $e13e,y	                lda pixelMasks-1,y
1728	.c800	8d 63 03	sta $0363	                sta vduv.colourMaskRight
1729	.c803					-
1730	.c803	0a		asl a		                asl a
1731	.c804	10 fd		bpl $c803	                bpl -   ;keep shifting until leftmost pixel mask found
1732	.c806	8d 62 03	sta $0362	                sta vduv.colourMaskLeft
1733	.c809	bc 78 e1	ldy $e178,x	                ldy screenMODEGroupForMODE,x
1734	.c80c	8c 56 03	sty $0356	                sty vduv.currentScreenMODEGroup
1735	.c80f	b9 84 e1	lda $e184,y	                lda latchBit4ForScreenMODEGroup,y
1736	.c812	08		php		                php
1737	.c813	78		sei		                sei
1738	.c814	8d 40 fe	sta $fe40	                sta systemVIA.orb
1739	.c817	b9 80 e1	lda $e180,y	                lda latchBit5ForScreenMODEGroup,y
1740	.c81a	8d 40 fe	sta $fe40	                sta systemVIA.orb
1741	.c81d	28		plp		                plp
1742	.c81e	b9 89 e1	lda $e189,y	                lda screenSizeHighByteForScreenMODEGroup,y
1743	.c821	8d 54 03	sta $0354	                sta vduv.screenSizeHighByte
1744	.c824	b9 8e e1	lda $e18e,y	                lda startScreenAddressHighByteForScreenMODEGroup,y
1745	.c827	8d 4e 03	sta $034e	                sta vduv.startScreenAddressHighByte
1746	.c82a	a9 ee		lda #$ee	                lda #STATE.isVDU21|STATE.isCursorEditing|STATE.isVDU5|STATE.isTextWindow|STATE.isPagedScrolling|STATE.isScrollingDisabled
1747	.c82c	14 d0		trb $d0		                trb STATE
1748	.c82e	ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
1749	.c831	bd 21 e1	lda $e121,x	                lda vcontrolForScreenMODE,x
1750	.c834	20 0f f3	jsr $f30f	                jsr setVCONTROL
1751	.c837	08		php		                php
1752	.c838	78		sei		                sei
1753	.c839	be 93 e1	ldx $e193,y	                ldx crtcRegisterLastIndexForScreenMODEGroup,y
1754	.c83c	a0 0b		ldy #$0b	                ldy #$0B
1755	.c83e					-
1756	.c83e	bd 98 e1	lda $e198,x	                lda crtcRegisterValues,x
1757	.c841	20 01 cf	jsr $cf01	                jsr setCRTCRegister
1758	.c844	ca		dex		                dex
1759	.c845	88		dey		                dey
1760	.c846	10 f6		bpl $c83e	                bpl -
1761	.c848	28		plp		                plp
1762	.c849	20 c5 c5	jsr $c5c5	                jsr vdu20EntryPoint
1763	.c84c	20 6d cf	jsr $cf6d	                jsr vdu23_11_EntryPoint
1764	.c84f	a9 aa		lda #$aa	                lda #%10101010
1765	.c851	8d 67 03	sta $0367	                sta vduv.dotPattern
1766	.c854	8d 68 03	sta $0368	                sta vduv.dotPatternState
1767	.c857	20 aa c6	jsr $c6aa	                jsr vdu26EntryPoint
1768	.c85a	ad 4c 03	lda $034c	                lda vduv.textWindowWidthInBytes+0
1769	.c85d	ae 4d 03	ldx $034d	                ldx vduv.textWindowWidthInBytes+1
1770	.c860	8d 52 03	sta $0352	                sta vduv.bytesPerCharacterRow+0
1771	.c863	8e 53 03	stx $0353	                stx vduv.bytesPerCharacterRow+1

1773						                ; Do a fast hardware CLS of the whole screen
1774						                ; ------------------------------------------
1775	.c866					clsFastPath:
1776	.c866	a2 00		ldx #$00	                ldx #$00
1777	.c868	ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
1778	.c86b	9c 50 03	stz $0350	                stz vduv.screenTopLeftAddress+0
1779	.c86e	8d 51 03	sta $0351	                sta vduv.screenTopLeftAddress+1
1780	.c871	20 dd c6	jsr $c6dd	                jsr setCRTCCursorAddress
1781	.c874	a0 0c		ldy #$0c	                ldy #$0C
1782	.c876	20 11 c7	jsr $c711	                jsr setCRTCAddressRegisters
1783	.c879	9c 69 02	stz $0269	                stz pagedModeCounter
1784	.c87c	38		sec		                sec
1785	.c87d	a9 80		lda #$80	                lda #$80
1786	.c87f	ed 4e 03	sbc $034e	                sbc vduv.startScreenAddressHighByte
1787	.c882	aa		tax		                tax
1788	.c883	a0 00		ldy #$00	                ldy #$00
1789	.c885	20 84 cb	jsr $cb84	                jsr clearTextMemory
1790	.c888	4c 7c c4	jmp $c47c	                jmp vdu30EntryPoint

1792	.c88b					LC88B:
1793	.c88b	20 cf c8	jsr $c8cf	                jsr LC8CF                    ; Clear paged mode counter
1794	.c88e					LC88E:
1795	.c88e	20 ef f2	jsr $f2ef	                jsr osbyte76    ; Call KEYV to test Shift & Ctrl keys
1796	.c891	90 02		bcc $c895	                bcc LC895                    ; Ctrl not pressed, exit loop
1797	.c893	30 f6		bmi $c88b	                bmi LC88B                    ; Shift pressed, loop back
1798	.c895					LC895:
1799	.c895	a5 d0		lda $d0		                lda STATE
1800	.c897	49 04		eor #$04	                eor #STATE.isPagedScrolling
1801	.c899	29 46		and #$46	                and #STATE.isCursorEditing|STATE.isPagedScrolling|STATE.isScrollingDisabled;
1802	.c89b	d0 39		bne $c8d6	                bne LC8D6
1803	.c89d	20 d7 c8	jsr $c8d7	                jsr LC8D7
1804	.c8a0	b9 18 03	lda $0318,y	                lda vduv.textCursorXPosition,y
1805	.c8a3	dd 08 03	cmp $0308,x	                cmp vduv.textWindowLeft,x
1806	.c8a6	d0 2b		bne $c8d3	                bne LC8D3
1810	.c8a8	38		sec		                sec
1811	.c8a9	c8		iny		                iny
1812	.c8aa	88		dey		                dey
1814	.c8ab	d0 08		bne $c8b5	                bne LC8B5
1815	.c8ad	ad 0a 03	lda $030a	                lda vduv.textWindowRight
1816	.c8b0	ed 08 03	sbc $0308	                sbc vduv.textWindowLeft
1817	.c8b3	80 06		bra $c8bb	                bra LC8BB

1819	.c8b5					LC8B5:
1820	.c8b5	ad 09 03	lda $0309	                lda vduv.textWindowBottom
1821	.c8b8	ed 0b 03	sbc $030b	                sbc vduv.textWindowTop
1822	.c8bb					LC8BB:
1823	.c8bb	48		pha		                pha
1824	.c8bc	4a		lsr a		                lsr a
1825	.c8bd	4a		lsr a		                lsr a
1826	.c8be	85 da		sta $da		                sta ZTEMP+0
1827	.c8c0	38		sec		                sec
1828	.c8c1	68		pla		                pla
1829	.c8c2	e5 da		sbc $da		                sbc ZTEMP+0
1830	.c8c4	cd 69 02	cmp $0269	                cmp pagedModeCounter
1831	.c8c7	b0 0a		bcs $c8d3	                bcs LC8D3
1832	.c8c9					LC8C9:
1833	.c8c9	20 ef f2	jsr $f2ef	                jsr osbyte76
1834	.c8cc	38		sec		                sec
1835	.c8cd	10 fa		bpl $c8c9	                bpl LC8C9

1837	.c8cf					LC8CF:
1838	.c8cf	9c 69 02	stz $0269	                stz pagedModeCounter        ; Clear paged mode counter
1840	.c8d2	ea		nop		                nop
1842	.c8d3					LC8D3:
1843	.c8d3	ee 69 02	inc $0269	                inc pagedModeCounter
1844	.c8d6					LC8D6:
1845	.c8d6	60		rts		                rts

1847	.c8d7					LC8D7:
1848	.c8d7	ad 66 03	lda $0366	                lda vduv.cursorFlags
1849	.c8da	29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
1850	.c8dc	4a		lsr a		                lsr a                        ;xvh
1851	.c8dd	aa		tax		                tax
1852	.c8de	bd 14 e2	lda $e214,x	                lda LE204,x
1853	.c8e1	aa		tax		                tax
1854	.c8e2	29 01		and #$01	                and #$01
1855	.c8e4	a8		tay		                tay
1856	.c8e5	60		rts		                rts

1858						;-------------------------------------------------------------------------
1859						;
1860						; Prepare AABB based on the current graphics cursor and some other
1861						; coordinate.
1862						;
1863						; entry:
1864						;
1865						; X = VDU variable offset of other coordinate (4 bytes: X;Y;)
1866						;
1867						; exit:
1868						;
1869						; vduv.workspace._28 = minimum
1870						;
1871						; vduv.workspace._2c = maximum
1872						;
1873	.c8e6					prepareAABB:
1874	.c8e6	a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixels
1875	.c8e8	20 b7 d5	jsr $d5b7	                jsr sortVDUVariableCoordinates
1876	.c8eb	5a		phy		                phy                          ;save greater Y
1877	.c8ec	da		phx		                phx                          ;save lesser Y
1878	.c8ed	20 cc d5	jsr $d5cc	                jsr sortVDUVariableWords     ;X=lesser X, Y=greater X
1879	.c8f0	68		pla		                pla                          ;A=lesser Y
1880	.c8f1	5a		phy		                phy                          ;save greater X
1881	.c8f2	a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
1882	.c8f4	20 f9 c8	jsr $c8f9	                jsr +
1883	.c8f7	fa		plx		                plx                          ;X=greater X
1884	.c8f8	68		pla		                pla                          ;A=greater Y
1885	.c8f9					+
1886						                ; Copy VDU variable word +X to VDU variable word+Y.
1887						                ; Then cropy VDU variable word +A+2 to VDU variable
1888						                ; word+Y+2. Return with updated Y.
1889	.c8f9	48		pha		                pha
1890	.c8fa	20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
1891	.c8fd	fa		plx		                plx
1892	.c8fe	e8		inx		                inx
1893	.c8ff	e8		inx		                inx
1894	.c900	80 0a		bra $c90c	                bra copyTwoBytesWithinVDUVariables

1896						;-------------------------------------------------------------------------
1897						;
1898						; Copy 8 bytes to workspace 28 in the VDU variables.
1899						;
1900						; entry:
1901						;
1902						; X = source offset
1903						;
1904	.c902					copyEightBytesToWorkspace28:
1905	.c902	a0 28		ldy #$28	                ldy #VDUVariables.workspace._28

1907						;-------------------------------------------------------------------------
1908						;
1909						; Copy 8 bytes in the VDU variables.
1910						;
1911						; entry:
1912						;
1913						; X = source offset
1914						;
1915						; Y = dest offset
1916						;
1917	.c904					copyEightBytesWithinVDUVariables:
1918	.c904	a9 08		lda #$08	                lda #$08
1919	.c906	80 18		bra $c920	                bra copyABytesWithinVDUVariables

1921						;-------------------------------------------------------------------------
1922						;
1923						; copyTextWindowWidthInBytesToWorkspace28
1924	.c908					copyTextWindowWidthInBytesToWorkspace28:
1925	.c908	a2 4c		ldx #$4c	                ldx #VDUVariables.textWindowWidthInBytes
1926	.c90a	a0 28		ldy #$28	                ldy #VDUVariables.workspace._28

1928						;-------------------------------------------------------------------------
1929						;
1930						;
1931	.c90c					copyTwoBytesWithinVDUVariables:
1932	.c90c	a9 02		lda #$02	                lda #$02
1933	.c90e	80 10		bra $c920	                bra copyABytesWithinVDUVariables

1935						;-------------------------------------------------------------------------
1936						;
1937						; Copy text window info to workspace2C.
1938						;
1939	.c910					copyTextWindowToWorkspace2C:
1940	.c910	a2 08		ldx #$08	                ldx #VDUVariables.textWindowLeft
1941	.c912	a0 2c		ldy #$2c	                ldy #VDUVariables.workspace._2C
1942	.c914	80 08		bra $c91e	                bra copyFourBytesWithinVDUVariables

1944						;-------------------------------------------------------------------------
1945						;
1946						; Copy last 4 bytes of VDU queue somewhere.
1947						;
1948	.c916					copyLastFourVDUQueueBytes:
1949	.c916	a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
1950	.c918	80 04		bra $c91e	                bra copyFourBytesWithinVDUVariables

1952						;-------------------------------------------------------------------------
1953						;
1954						; Copy old graphics cursor position to current graphics cursor position.
1955						;
1956	.c91a					copyGraphicsCursorPixelsToOldGraphicsCursorPixels:
1957	.c91a	a0 14		ldy #$14	                ldy #VDUVariables.oldGraphicsCursorPixelsX

1959						;-------------------------------------------------------------------------
1960						;
1961						; Copy the graphics cursor position somewhere.
1962						;
1963	.c91c					copyGraphicsCursorPixels:
1964	.c91c	a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX

1966						;-------------------------------------------------------------------------
1967						;
1968						; Copy 4 bytes in the VDU variables.
1969						;
1970						; entry:
1971						;
1972						; X = source offset
1973						;
1974						; Y = dest offset
1975						;
1976	.c91e					copyFourBytesWithinVDUVariables:
1977	.c91e	a9 04		lda #$04	                lda #$04

1979						                ; fall through to copyABytesWithinVDUVariables

1981						;-------------------------------------------------------------------------
1982						;
1983						; Copy some bytes in the VDU variables.
1984						;
1985						; entry:
1986						;
1987						; A = number of bytes
1988						;
1989						; X = source offset
1990						;
1991						; Y = dest offset
1992						;
1993						; exit:
1994						;
1995						; X = updated source offset
1996						;
1997						; Y = updated dest offset
1998						;
1999	.c920					copyABytesWithinVDUVariables:
2000	.c920	48		pha		                pha
2001	.c921	bd 00 03	lda $0300,x	                lda vduv,x
2002	.c924	99 00 03	sta $0300,y	                sta vduv,y
2003	.c927	e8		inx		                inx
2004	.c928	c8		iny		                iny
2005	.c929	68		pla		                pla
2006	.c92a	3a		dec a		                dec a
2007	.c92b	d0 f3		bne $c920	                bne copyABytesWithinVDUVariables
2008	.c92d	60		rts		                rts

2010						;-------------------------------------------------------------------------
2011						;
2012						; Negate a 16-bit value stored in Y/A
2013						;
2014						; entry:
2015						;
2016						; Y (LSB), A (MSB) = value
2017						;
2018						; exit:
2019						;
2020						; Y (LSB), A (MSB) = -value
2021						;
2022	.c92e					negateAY:
2023	.c92e	48		pha		                pha
2024	.c92f	98		tya		                tya
2025	.c930	49 ff		eor #$ff	                eor #$FF
2026	.c932	a8		tay		                tay
2027	.c933	68		pla		                pla
2028	.c934	49 ff		eor #$ff	                eor #$FF
2029	.c936	c8		iny		                iny
2030	.c937	d0 01		bne $c93a	                bne +
2031	.c939	1a		inc a		                inc a
2032	.c93a					+
2033	.c93a	60		rts		                rts

2035						;-------------------------------------------------------------------------
2036						;
2037						; Multiply a text window width by the number of bytes per char. There
2038						; are inclusive and exclusive versions, depending on how the width was
2039						; calculated.
2040						;
2041						; entry:
2042						;
2043						; A = value-1 to multiply (inclusive), value to multiply (exclusive)
2044						;
2045						; exit:
2046						;
2047						; A (lsb), X (msb) = value*vduv.bytesPerCharacter
2048						;
2049	.c93b					getBytesPerInclusiveTextRow:
2050	.c93b	1a		inc a		                inc a
2051	.c93c					getBytesPerExclusiveTextRow:
2052	.c93c	85 da		sta $da		                sta $DA
2053	.c93e	64 db		stz $db		                stz $DB
2054	.c940	ad 4f 03	lda $034f	                lda vduv.bytesPerCharacter    ;A=1/8/16/32
2055	.c943					-
2056	.c943	4a		lsr a		                lsr a
2057	.c944	b0 06		bcs $c94c	                bcs +                     ;taken when multiply is done
2058	.c946	06 da		asl $da		                asl $DA              ;shift size LSB
2059	.c948	26 db		rol $db		                rol $DB              ;carry into size MSB
2060	.c94a	80 f7		bra $c943	                bra -

2062	.c94c					+
2063	.c94c	a5 da		lda $da		                lda $DA
2064	.c94e	a6 db		ldx $db		                ldx $DB
2065	.c950	60		rts		                rts

2067						;-------------------------------------------------------------------------
2068						;
2069						;
2070	.c951					prepareForPlotBackground:
2071	.c951	a2 08		ldx #$08	                ldx #$08                     ;plot background
2072	.c953	8e 59 03	stx $0359	                stx vduv.graphicsPlotState
2073	.c956	ad 5c 03	lda $035c	                lda vduv.backgroundGCOLMode
2074	.c959	29 0f		and #$0f	                and #$0F
2075	.c95b	8d 5a 03	sta $035a	                sta vduv.graphicsPlotMode
2076	.c95e	60		rts		                rts

2078						;-------------------------------------------------------------------------

2080	.c95f					LC95F:
2081	.c95f	a9 00		lda #$00	                lda #$00
2082	.c961	48		pha		                pha
2083	.c962	48		pha		                pha
2084	.c963	ae 2a 03	ldx $032a	                ldx $032A
2085	.c966	20 7d cc	jsr $cc7d	                jsr LCC7D
2086	.c969	80 14		bra $c97f	                bra LC97F

2088	.c96b					LC96B:
2089	.c96b	38		sec		                sec
2090	.c96c	ad 4f 03	lda $034f	                lda $034F
2091	.c96f	ed 2a 03	sbc $032a	                sbc $032A
2092	.c972	48		pha		                pha
2093	.c973	20 b2 e2	jsr $e2b2	                jsr getDefaultBoundsForCurrentScreenMODE
2094	.c976	da		phx		                phx
2095	.c977	a9 00		lda #$00	                lda #$00
2096	.c979	ae 2a 03	ldx $032a	                ldx $032A
2097	.c97c	20 5d cc	jsr $cc5d	                jsr LCC5D
2098	.c97f					LC97F:
2099						                ; scroll left/right
2100	.c97f	8e 50 03	stx $0350	                stx vduv.screenTopLeftAddress+0
2101	.c982	8d 51 03	sta $0351	                sta vduv.screenTopLeftAddress+1
2102	.c985	fa		plx		                plx
2103	.c986	a0 00		ldy #$00	                ldy #$00
2104	.c988	20 b0 cc	jsr $ccb0	                jsr getAddressForTextPosition
2105	.c98b	fa		plx		                plx
2106	.c98c	a9 00		lda #$00	                lda #$00
2107	.c98e	20 5d cc	jsr $cc5d	                jsr LCC5D
2108	.c991	86 d8		stx $d8		                stx ZMEMT+0
2109	.c993	85 d9		sta $d9		                sta ZMEMT+1
2110	.c995	20 b2 e2	jsr $e2b2	                jsr getDefaultBoundsForCurrentScreenMODE
2111	.c998	20 ae ca	jsr $caae	                jsr LCAAE
2112	.c99b	80 1b		bra $c9b8	                bra LC9B8

2114	.c99d					LC99D:
2115	.c99d	a0 00		ldy #$00	                ldy #$00
2116	.c99f	20 77 cc	jsr $cc77	                jsr LCC77
2117	.c9a2	80 06		bra $c9aa	                bra LC9AA

2119	.c9a4					LC9A4:
2120	.c9a4	20 b2 e2	jsr $e2b2	                jsr getDefaultBoundsForCurrentScreenMODE
2121	.c9a7	20 57 cc	jsr $cc57	                jsr LCC57
2122	.c9aa					LC9AA:
2123	.c9aa	8e 50 03	stx $0350	                stx vduv.screenTopLeftAddress+0
2124	.c9ad	8d 51 03	sta $0351	                sta vduv.screenTopLeftAddress+1
2125	.c9b0	a2 00		ldx #$00	                ldx #$00
2126	.c9b2	20 b0 cc	jsr $ccb0	                jsr getAddressForTextPosition
2127	.c9b5	20 e8 ca	jsr $cae8	                jsr LCAE8
2128	.c9b8					LC9B8:
2134	.c9b8	a0 0c		ldy #$0c	                ldy #$0C
2135	.c9ba	ad 51 03	lda $0351	                lda vduv.screenTopLeftAddress+1
2136	.c9bd	ae 50 03	ldx $0350	                ldx vduv.screenTopLeftAddress+0
2137	.c9c0	4c f5 c6	jmp $c6f5	                jmp setCRTCAddress

2139	.c9c3					LC9C3:
2140	.c9c3	20 a0 cc	jsr $cca0	                jsr LCCA0
2141	.c9c6					LC9C6:
2142	.c9c6	85 dd		sta $dd		                sta $DD
2143	.c9c8	86 dc		stx $dc		                stx $DC
2144	.c9ca	20 2c cc	jsr $cc2c	                jsr LCC2C
2145	.c9cd	ad 29 03	lda $0329	                lda $0329
2146	.c9d0	ae 28 03	ldx $0328	                ldx $0328
2147	.c9d3	20 5d cc	jsr $cc5d	                jsr LCC5D
2148	.c9d6	20 88 cc	jsr $cc88	                jsr LCC88
2149	.c9d9	86 d8		stx $d8		                stx ZMEMT+0
2150	.c9db	85 d9		sta $d9		                sta ZMEMT+1
2151	.c9dd	a9 00		lda #$00	                lda #$00
2152	.c9df	ae 2a 03	ldx $032a	                ldx $032A
2153	.c9e2	20 7d cc	jsr $cc7d	                jsr LCC7D
2154	.c9e5	20 88 cc	jsr $cc88	                jsr LCC88
2155	.c9e8	86 da		stx $da		                stx $DA
2156	.c9ea	85 db		sta $db		                sta $DB
2157	.c9ec	ac 28 03	ldy $0328	                ldy $0328
2158	.c9ef	ae 29 03	ldx $0329	                ldx $0329
2159	.c9f2	50 23		bvc $ca17	                bvc LCA17
2160	.c9f4	a4 e0		ldy $e0		                ldy $E0
2161	.c9f6	a6 e1		ldx $e1		                ldx $E1
2162	.c9f8	20 e7 cb	jsr $cbe7	                jsr LCBE7
2163	.c9fb	a4 e0		ldy $e0		                ldy $E0
2164	.c9fd	90 09		bcc $ca08	                bcc LCA08
2165	.c9ff	a2 80		ldx #$80	                ldx #$80
2166	.ca01	86 db		stx $db		                stx $DB
2167	.ca03	64 da		stz $da		                stz $DA
2168	.ca05	ac 2a 03	ldy $032a	                ldy $032A
2169	.ca08					LCA08:
2170	.ca08	a2 00		ldx #$00	                ldx #$00
2171	.ca0a	20 f3 cb	jsr $cbf3	                jsr LCBF3
2172	.ca0d	a2 80		ldx #$80	                ldx #$80
2173	.ca0f	86 d9		stx $d9		                stx ZMEMT+1
2174	.ca11	64 d8		stz $d8		                stz ZMEMT+0
2175	.ca13	a4 de		ldy $de		                ldy $DE
2176	.ca15	a6 df		ldx $df		                ldx $DF
2177	.ca17					LCA17:
2178	.ca17	20 e7 cb	jsr $cbe7	                jsr LCBE7
2179	.ca1a	20 97 cc	jsr $cc97	                jsr LCC97
2180	.ca1d	20 94 cc	jsr $cc94	                jsr LCC94
2181	.ca20	20 57 cc	jsr $cc57	                jsr LCC57
2182	.ca23	86 d8		stx $d8		                stx ZMEMT+0
2183	.ca25	85 d9		sta $d9		                sta ZMEMT+1
2184	.ca27	ce 2b 03	dec $032b	                dec $032B
2185	.ca2a	10 9a		bpl $c9c6	                bpl LC9C6
2186	.ca2c	60		rts		                rts

2188	.ca2d					LCA2D:
2189	.ca2d	20 a0 cc	jsr $cca0	                jsr LCCA0
2190	.ca30					LCA30:
2191	.ca30	20 2c cc	jsr $cc2c	                jsr LCC2C
2192	.ca33	a9 00		lda #$00	                lda #$00
2193	.ca35	ae 2a 03	ldx $032a	                ldx $032A
2194	.ca38	20 5d cc	jsr $cc5d	                jsr LCC5D
2195	.ca3b	86 da		stx $da		                stx $DA
2196	.ca3d	85 db		sta $db		                sta $DB
2197	.ca3f	20 57 cc	jsr $cc57	                jsr LCC57
2198	.ca42	86 dc		stx $dc		                stx $DC
2199	.ca44	85 dd		sta $dd		                sta $DD
2200	.ca46	ac 28 03	ldy $0328	                ldy $0328
2201	.ca49	ae 29 03	ldx $0329	                ldx $0329
2202	.ca4c	50 25		bvc $ca73	                bvc LCA73
2203	.ca4e	a4 de		ldy $de		                ldy $DE
2204	.ca50	a6 df		ldx $df		                ldx $DF
2205	.ca52	20 a8 cb	jsr $cba8	                jsr LCBA8
2206	.ca55	a4 de		ldy $de		                ldy $DE
2207	.ca57	90 0a		bcc $ca63	                bcc LCA63
2208	.ca59	ae 4e 03	ldx $034e	                ldx $034E
2209	.ca5c	86 db		stx $db		                stx $DB
2210	.ca5e	64 da		stz $da		                stz $DA
2211	.ca60	ac 2a 03	ldy $032a	                ldy $032A
2212	.ca63					LCA63:
2213	.ca63	a2 00		ldx #$00	                ldx #$00
2214	.ca65	20 b4 cb	jsr $cbb4	                jsr LCBB4
2215	.ca68	ae 4e 03	ldx $034e	                ldx $034E
2216	.ca6b	86 d9		stx $d9		                stx ZMEMT+1
2217	.ca6d	64 d8		stz $d8		                stz ZMEMT+0
2218	.ca6f	a4 e0		ldy $e0		                ldy $E0
2219	.ca71	a6 e1		ldx $e1		                ldx $E1
2220	.ca73					LCA73:
2221	.ca73	20 a8 cb	jsr $cba8	                jsr LCBA8
2222	.ca76	20 94 cc	jsr $cc94	                jsr LCC94
2223	.ca79	ce 2b 03	dec $032b	                dec $032B
2224	.ca7c	10 b2		bpl $ca30	                bpl LCA30
2225	.ca7e					LCA7E:
2226	.ca7e	60		rts		                rts

2228	.ca7f					LCA7F:
2229	.ca7f	86 dc		stx $dc		                stx $DC
2230	.ca81	aa		tax		                tax
2231	.ca82	38		sec		                sec
2232	.ca83	e5 dc		sbc $dc		                sbc $DC
2233	.ca85	f0 f7		beq $ca7e	                beq LCA7E
2234	.ca87	85 dd		sta $dd		                sta $DD
2235	.ca89	da		phx		                phx
2236	.ca8a	20 3c c9	jsr $c93c	                jsr getBytesPerExclusiveTextRow
2237	.ca8d	fa		plx		                plx
2238	.ca8e	ad 66 03	lda $0366	                lda $0366
2239	.ca91	89 08		bit #$08	                bit #$08
2240	.ca93	d0 0b		bne $caa0	                bne LCAA0
2241	.ca95	89 02		bit #$02	                bit #$02
2242	.ca97	20 ca cc	jsr $ccca	                jsr LCCCA
2243	.ca9a	a4 da		ldy $da		                ldy $DA
2244	.ca9c	a6 db		ldx $db		                ldx $DB
2245	.ca9e	80 2e		bra $cace	                bra LCACE

2247	.caa0					LCAA0:
2248	.caa0	89 04		bit #$04	                bit #$04
2249	.caa2	20 ca cc	jsr $ccca	                jsr LCCCA
2250	.caa5	ad 4f 03	lda $034f	                lda $034F
2251	.caa8	8d 2a 03	sta $032a	                sta $032A
2252	.caab	a4 dd		ldy $dd		                ldy $DD
2253	.caad	88		dey		                dey
2254	.caae					LCAAE:
2255	.caae	98		tya		                tya
2256	.caaf	f0 18		beq $cac9	                beq LCAC9
2257	.cab1	84 dc		sty $dc		                sty $DC
2258	.cab3					LCAB3:
2259	.cab3	20 57 cc	jsr $cc57	                jsr LCC57
2260	.cab6	86 da		stx $da		                stx $DA
2261	.cab8	85 db		sta $db		                sta $DB
2262	.caba	20 c9 ca	jsr $cac9	                jsr LCAC9
2263	.cabd	a6 da		ldx $da		                ldx $DA
2264	.cabf	86 d8		stx $d8		                stx ZMEMT+0
2265	.cac1	a5 db		lda $db		                lda $DB
2266	.cac3	85 d9		sta $d9		                sta ZMEMT+1
2267	.cac5	c6 dc		dec $dc		                dec $DC
2268	.cac7	d0 ea		bne $cab3	                bne LCAB3
2269	.cac9					LCAC9:
2270	.cac9	a2 00		ldx #$00	                ldx #$00
2271	.cacb	ac 2a 03	ldy $032a	                ldy $032A
2272	.cace					LCACE:
2273	.cace	ad 28 03	lda $0328	                lda $0328
2274	.cad1	48		pha		                pha
2275	.cad2	ad 29 03	lda $0329	                lda $0329
2276	.cad5	48		pha		                pha
2277	.cad6	8c 28 03	sty $0328	                sty $0328
2278	.cad9	8e 29 03	stx $0329	                stx $0329
2279	.cadc	20 e8 ca	jsr $cae8	                jsr LCAE8
2280	.cadf	68		pla		                pla
2281	.cae0	8d 29 03	sta $0329	                sta $0329
2282	.cae3	68		pla		                pla
2283	.cae4	8d 28 03	sta $0328	                sta $0328
2284	.cae7	60		rts		                rts

2286						;-------------------------------------------------------------------------

2288	.cae8					LCAE8:
2289	.cae8	a6 d8		ldx $d8		                ldx ZMEMT+0
2290	.caea	a5 d9		lda $d9		                lda ZMEMT+1
2291	.caec	20 2c cc	jsr $cc2c	                jsr LCC2C
2292	.caef	80 79		bra $cb6a	                bra LCB6A

2294						;-------------------------------------------------------------------------

2296	.caf1					LCAF1:
2297	.caf1	a2 77		ldx #$77	                ldx #<LCC77
2298	.caf3	a9 cc		lda #$cc	                lda #>LCC77
2299	.caf5	ac 2d 03	ldy $032d	                ldy $032D
2300	.caf8	80 07		bra $cb01	                bra LCB01

2302	.cafa					LCAFA:
2303	.cafa	a2 57		ldx #$57	                ldx #<LCC57
2304	.cafc	a9 cc		lda #$cc	                lda #>LCC57
2305	.cafe	ac 2f 03	ldy $032f	                ldy $032F
2306	.cb01					LCB01:
2307	.cb01	8e 5d 03	stx $035d	                stx $035D
2308	.cb04	8d 5e 03	sta $035e	                sta $035E
2309	.cb07	38		sec		                sec
2310	.cb08	ad 2d 03	lda $032d	                lda $032D
2311	.cb0b	ed 2f 03	sbc $032f	                sbc $032F
2312	.cb0e	8d 2b 03	sta $032b	                sta $032B
2313	.cb11	ae 2c 03	ldx $032c	                ldx $032C
2314	.cb14	20 b0 cc	jsr $ccb0	                jsr getAddressForTextPosition
2315	.cb17	85 dd		sta $dd		                sta $DD
2316	.cb19	86 dc		stx $dc		                stx $DC
2317	.cb1b	20 2c cc	jsr $cc2c	                jsr LCC2C
2318	.cb1e	ad 2b 03	lda $032b	                lda $032B
2319	.cb21	f0 47		beq $cb6a	                beq LCB6A
2320	.cb23					LCB23:
2321	.cb23	08		php		                php
2322	.cb24	20 24 c0	jsr $c024	                jsr LC024
2323	.cb27	86 da		stx $da		                stx $DA
2324	.cb29	85 db		sta $db		                sta $DB
2325	.cb2b	86 dc		stx $dc		                stx $DC
2326	.cb2d	85 dd		sta $dd		                sta $DD
2327	.cb2f	28		plp		                plp
2328	.cb30	50 1d		bvc $cb4f	                bvc LCB4F
2329	.cb32	b8		clv		                clv
2330	.cb33					LCB33:
2331	.cb33	a6 df		ldx $df		                ldx $DF
2332	.cb35	a4 de		ldy $de		                ldy $DE
2333	.cb37	20 b4 cb	jsr $cbb4	                jsr LCBB4
2334	.cb3a	ad 4e 03	lda $034e	                lda $034E
2335	.cb3d	70 06		bvs $cb45	                bvs LCB45
2336	.cb3f	85 d9		sta $d9		                sta ZMEMT+1
2337	.cb41	64 d8		stz $d8		                stz ZMEMT+0
2338	.cb43	80 04		bra $cb49	                bra LCB49

2340	.cb45					LCB45:
2341	.cb45	85 db		sta $db		                sta $DB
2342	.cb47	64 da		stz $da		                stz $DA
2343	.cb49					LCB49:
2344	.cb49	a6 e1		ldx $e1		                ldx $E1
2345	.cb4b	a4 e0		ldy $e0		                ldy $E0
2346	.cb4d	80 0b		bra $cb5a	                bra LCB5A

2348	.cb4f					LCB4F:
2349	.cb4f	20 2c cc	jsr $cc2c	                jsr LCC2C
2350	.cb52	70 df		bvs $cb33	                bvs LCB33
2351	.cb54	ae 29 03	ldx $0329	                ldx $0329
2352	.cb57	ac 28 03	ldy $0328	                ldy $0328
2353	.cb5a					LCB5A:
2354	.cb5a	20 b4 cb	jsr $cbb4	                jsr LCBB4
2355	.cb5d	a6 dc		ldx $dc		                ldx $DC
2356	.cb5f	86 d8		stx $d8		                stx ZMEMT+0
2357	.cb61	a5 dd		lda $dd		                lda $DD
2358	.cb63	85 d9		sta $d9		                sta ZMEMT+1
2359	.cb65	ce 2b 03	dec $032b	                dec $032B
2360	.cb68	d0 b9		bne $cb23	                bne LCB23
2361	.cb6a					LCB6A:
2362	.cb6a	ae 29 03	ldx $0329	                ldx $0329
2363	.cb6d	ac 28 03	ldy $0328	                ldy $0328
2364	.cb70	50 12		bvc $cb84	                bvc clearTextMemory
2365	.cb72	a6 df		ldx $df		                ldx $DF
2366	.cb74	a4 de		ldy $de		                ldy $DE
2367	.cb76	20 84 cb	jsr $cb84	                jsr clearTextMemory
2368	.cb79	ad 4e 03	lda $034e	                lda $034E
2369	.cb7c	85 d9		sta $d9		                sta ZMEMT+1
2370	.cb7e	64 d8		stz $d8		                stz ZMEMT+0
2371	.cb80	a6 e1		ldx $e1		                ldx $E1
2372	.cb82	a4 e0		ldy $e0		                ldy $E0

2374						;-------------------------------------------------------------------------
2375						;
2376						; Clear a block of text screen memory.
2377						;
2378						; entry:
2379						;
2380						; (ZMEMT),y - first byte to clear
2381						;
2382						; X = number of pages (including first, possibly partial page) to clear
2383						;
2384	.cb84					clearTextMemory:
2385						                ; align memory so that Y=0 on each page boundary
2386						                ; crossing.
2387						                ;
2388						                ; e.g., on entry ZMEMT=$30f8, Y=$08 - then after,
2389						                ; ZMEMT=$3000, Y=$F7; or, ZMEMT=$30f0, Y=$08 -> ZMEMT=$2ff8, Y=$F7.
2390	.cb84	98		tya		                tya                          ;A=initial offset
2391	.cb85	18		clc		                clc
2392	.cb86	65 d8		adc $d8		                adc ZMEMT+0                  ;add to dest address
2393	.cb88	85 d8		sta $d8		                sta ZMEMT+0
2394	.cb8a	b0 02		bcs $cb8e	                bcs +
2395	.cb8c	c6 d9		dec $d9		                dec ZMEMT+1
2396	.cb8e					+
2397	.cb8e	98		tya		                tya
2398	.cb8f	49 ff		eor #$ff	                eor #$FF
2399	.cb91	a8		tay		                tay
2400	.cb92	4a		lsr a		                lsr a                        ;C set if odd
2401	.cb93	ad 58 03	lda $0358	                lda vduv.backgroundTextColour
2402	.cb96	b0 07		bcs $cb9f	                bcs nextByte                    ;taken if odd - slightly different loop
2403	.cb98	80 02		bra $cb9c	                bra clearTextMemoryByte

2405	.cb9a					clearTextMemoryLoop:
2406	.cb9a	91 d8		sta ($d8),y	                sta (ZMEMT),y
2407	.cb9c					clearTextMemoryByte:
2408	.cb9c	c8		iny		                iny
2409	.cb9d	91 d8		sta ($d8),y	                sta (ZMEMT),y
2410	.cb9f					nextByte:
2411	.cb9f	c8		iny		                iny
2412	.cba0	d0 f8		bne $cb9a	                bne clearTextMemoryLoop
2413	.cba2	e6 d9		inc $d9		                inc ZMEMT+1
2414	.cba4	ca		dex		                dex
2415	.cba5	10 f3		bpl $cb9a	                bpl clearTextMemoryLoop
2416	.cba7	60		rts		                rts

2418						;-------------------------------------------------------------------------

2420	.cba8					LCBA8:
2421	.cba8	38		sec		                sec
2422	.cba9	98		tya		                tya
2423	.cbaa	ed 2a 03	sbc $032a	                sbc $032A
2424	.cbad	a8		tay		                tay
2425	.cbae	b0 04		bcs $cbb4	                bcs LCBB4
2426	.cbb0	ca		dex		                dex
2427	.cbb1	30 33		bmi $cbe6	                bmi LCBE6
2428	.cbb3	38		sec		                sec
2429	.cbb4					LCBB4:
2430	.cbb4	08		php		                php
2431	.cbb5	98		tya		                tya
2432	.cbb6	18		clc		                clc
2433	.cbb7	65 da		adc $da		                adc ZTEMP+0
2434	.cbb9	85 da		sta $da		                sta ZTEMP+0
2435	.cbbb	b0 02		bcs $cbbf	                bcs LCBBF
2436	.cbbd	c6 db		dec $db		                dec ZTEMP+1
2437	.cbbf					LCBBF:
2438	.cbbf	98		tya		                tya
2439	.cbc0	18		clc		                clc
2440	.cbc1	65 d8		adc $d8		                adc ZMEMT+0
2441	.cbc3	85 d8		sta $d8		                sta ZMEMT+0
2442	.cbc5	b0 02		bcs $cbc9	                bcs LCBC9
2443	.cbc7	c6 d9		dec $d9		                dec ZMEMT+1
2444	.cbc9					LCBC9:
2445	.cbc9	98		tya		                tya
2446	.cbca	49 ff		eor #$ff	                eor #$FF
2447	.cbcc	a8		tay		                tay
2448	.cbcd	4a		lsr a		                lsr a
2449	.cbce	b0 0b		bcs $cbdb	                bcs LCBDB
2450	.cbd0	80 04		bra $cbd6	                bra LCBD6

2452	.cbd2					LCBD2:
2453	.cbd2	b1 da		lda ($da),y	                lda ($DA),y
2454	.cbd4	91 d8		sta ($d8),y	                sta (ZMEMT),y
2455	.cbd6					LCBD6:
2456	.cbd6	c8		iny		                iny
2457	.cbd7	b1 da		lda ($da),y	                lda ($DA),y
2458	.cbd9	91 d8		sta ($d8),y	                sta (ZMEMT),y
2459	.cbdb					LCBDB:
2460	.cbdb	c8		iny		                iny
2461	.cbdc	d0 f4		bne $cbd2	                bne LCBD2
2462	.cbde	e6 db		inc $db		                inc $DB
2463	.cbe0	e6 d9		inc $d9		                inc ZMEMT+1
2464	.cbe2	ca		dex		                dex
2465	.cbe3	10 ed		bpl $cbd2	                bpl LCBD2
2466	.cbe5					LCBE5:
2467	.cbe5	28		plp		                plp
2468	.cbe6					LCBE6:
2469	.cbe6	60		rts		                rts

2471	.cbe7					LCBE7:
2472	.cbe7	38		sec		                sec
2473	.cbe8	98		tya		                tya
2474	.cbe9	ed 2a 03	sbc $032a	                sbc $032A
2475	.cbec	a8		tay		                tay
2476	.cbed	b0 04		bcs $cbf3	                bcs LCBF3
2477	.cbef	ca		dex		                dex
2478	.cbf0	30 f4		bmi $cbe6	                bmi LCBE6
2479	.cbf2	38		sec		                sec
2480	.cbf3					LCBF3:
2481	.cbf3	08		php		                php
2482	.cbf4	98		tya		                tya
2483	.cbf5	49 ff		eor #$ff	                eor #$FF
2484	.cbf7	48		pha		                pha
2485	.cbf8	38		sec		                sec
2486	.cbf9	65 da		adc $da		                adc $DA
2487	.cbfb	85 da		sta $da		                sta $DA
2488	.cbfd	b0 02		bcs $cc01	                bcs LCC01
2489	.cbff	c6 db		dec $db		                dec $DB
2490	.cc01					LCC01:
2491	.cc01	68		pla		                pla
2492	.cc02	38		sec		                sec
2493	.cc03	65 d8		adc $d8		                adc ZMEMT+0
2494	.cc05	85 d8		sta $d8		                sta ZMEMT+0
2495	.cc07	b0 02		bcs $cc0b	                bcs LCC0B
2496	.cc09	c6 d9		dec $d9		                dec ZMEMT+1
2497	.cc0b					LCC0B:
2498	.cc0b	98		tya		                tya
2499	.cc0c	4a		lsr a		                lsr a
2500	.cc0d	b0 14		bcs $cc23	                bcs LCC23
2501	.cc0f	d0 0d		bne $cc1e	                bne LCC1E
2502	.cc11					LCC11:
2503	.cc11	ca		dex		                dex
2504	.cc12	30 d1		bmi $cbe5	                bmi LCBE5
2505	.cc14	c6 db		dec $db		                dec $DB
2506	.cc16	c6 d9		dec $d9		                dec ZMEMT+1
2507	.cc18	80 04		bra $cc1e	                bra LCC1E

2509	.cc1a					LCC1A:
2510	.cc1a	b1 da		lda ($da),y	                lda ($DA),y
2511	.cc1c	91 d8		sta ($d8),y	                sta (ZMEMT),y
2512	.cc1e					LCC1E:
2513	.cc1e	88		dey		                dey
2514	.cc1f	b1 da		lda ($da),y	                lda ($DA),y
2515	.cc21	91 d8		sta ($d8),y	                sta (ZMEMT),y
2516	.cc23					LCC23:
2517	.cc23	88		dey		                dey
2518	.cc24	d0 f4		bne $cc1a	                bne LCC1A
2519	.cc26	b2 da		lda ($da)	                lda ($DA)
2520	.cc28	92 d8		sta ($d8)	                sta (ZMEMT)
2521	.cc2a	80 e5		bra $cc11	                bra LCC11

2523						;-------------------------------------------------------------------------
2524						;
2525						; Get pointers for a text window row.
2526						;
2527						; entry:
2528						;
2529						; vduv.workspace._28; = text window stride, in bytes
2530						;
2531						; >A, <X = address
2532						;
2533						; exit:
2534						;
2535						; V=0: >A, <X = new address
2536						;
2537						; V=1: (ZTEMPC) =

2539	.cc2c					LCC2C:
2540	.cc2c	48		pha		                pha                          ;save >address
2541	.cc2d	8a		txa		                txa                          ;A=<address
2542	.cc2e	18		clc		                clc
2543	.cc2f	6d 28 03	adc $0328	                adc vduv.workspace._28       ;A=<(new address)
2544	.cc32	aa		tax		                tax                          ;X=<(new address)
2545	.cc33	68		pla		                pla                          ;restore >addcess
2546	.cc34	6d 29 03	adc $0329	                adc vduv.workspace._29       ;A=>(new address)
2547	.cc37	50 1d		bvc $cc56	                bvc rtsCC56                  ;taken if no address wrap
2548	.cc39	86 e0		stx $e0		                stx ZTEMPD+0
2549	.cc3b	29 7f		and #$7f	                and #$7F                     ;
2550	.cc3d	85 e1		sta $e1		                sta ZTEMPD+1
2551	.cc3f	05 e0		ora $e0		                ora ZTEMPD+0
2552	.cc41	f0 12		beq $cc55	                beq clv_rts
2553	.cc43	08		php		                php
2554	.cc44	38		sec		                sec
2555	.cc45	ad 28 03	lda $0328	                lda vduv.workspace._28
2556	.cc48	e5 e0		sbc $e0		                sbc ZTEMPD+0
2557	.cc4a	85 de		sta $de		                sta ZTEMPC+0
2558	.cc4c	ad 29 03	lda $0329	                lda vduv.workspace._29
2559	.cc4f	e5 e1		sbc $e1		                sbc ZTEMPD+1
2560	.cc51	85 df		sta $df		                sta ZTEMPC+1
2561	.cc53	28		plp		                plp
2562	.cc54	60		rts		                rts

2564						;-------------------------------------------------------------------------

2566	.cc55					clv_rts:
2567	.cc55	b8		clv		                clv
2568	.cc56					rtsCC56:
2569	.cc56	60		rts		                rts

2571	.cc57					LCC57:
2572	.cc57	ad 53 03	lda $0353	                lda vduv.bytesPerCharacterRow+1
2573	.cc5a	ae 52 03	ldx $0352	                ldx vduv.bytesPerCharacterRow+0
2574	.cc5d					LCC5D:
2575	.cc5d	18		clc		                clc
2576	.cc5e					LCC5E:
2577	.cc5e	08		php		                php
2578	.cc5f	48		pha		                pha
2579	.cc60	8a		txa		                txa
2580	.cc61	65 d8		adc $d8		                adc ZMEMT+0
2581	.cc63	aa		tax		                tax
2582	.cc64	68		pla		                pla
2583	.cc65	65 d9		adc $d9		                adc ZMEMT+1
2584	.cc67	10 04		bpl $cc6d	                bpl +
2585	.cc69	38		sec		                sec
2586	.cc6a	ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte ;handle wraparound at end
2587	.cc6d					+
2588	.cc6d	cd 4e 03	cmp $034e	                cmp vduv.startScreenAddressHighByte
2589	.cc70	b0 03		bcs $cc75	                bcs +
2590	.cc72	6d 54 03	adc $0354	                adc vduv.screenSizeHighByte ;handle wraparound at start
2591	.cc75					+
2592	.cc75	28		plp		                plp
2593	.cc76	60		rts		                rts

2595	.cc77					LCC77:
2596	.cc77	ad 53 03	lda $0353	                lda $0353
2597	.cc7a	ae 52 03	ldx $0352	                ldx $0352
2598	.cc7d					LCC7D:
2599	.cc7d	48		pha		                pha
2600	.cc7e	8a		txa		                txa
2601	.cc7f	49 ff		eor #$ff	                eor #$FF
2602	.cc81	aa		tax		                tax
2603	.cc82	68		pla		                pla
2604	.cc83	49 ff		eor #$ff	                eor #$FF
2605	.cc85	38		sec		                sec
2606	.cc86	80 d6		bra $cc5e	                bra LCC5E

2608	.cc88					LCC88:
2609	.cc88	cd 4e 03	cmp $034e	                cmp $034E
2610	.cc8b	d0 06		bne $cc93	                bne LCC93
2611	.cc8d	e0 00		cpx #$00	                cpx #$00
2612	.cc8f	d0 02		bne $cc93	                bne LCC93
2613	.cc91	a9 80		lda #$80	                lda #$80
2614	.cc93					LCC93:
2615	.cc93	60		rts		                rts

2617	.cc94					LCC94:
2618	.cc94	20 c9 ca	jsr $cac9	                jsr LCAC9
2619	.cc97					LCC97:
2620	.cc97	a6 dc		ldx $dc		                ldx $DC
2621	.cc99	86 d8		stx $d8		                stx ZMEMT+0
2622	.cc9b	a5 dd		lda $dd		                lda $DD
2623	.cc9d	85 d9		sta $d9		                sta ZMEMT+1
2624	.cc9f	60		rts		                rts

2626	.cca0					LCCA0:
2627	.cca0	38		sec		                sec
2628	.cca1	ad 2d 03	lda $032d	                lda $032D
2629	.cca4	ed 2f 03	sbc $032f	                sbc $032F
2630	.cca7	8d 2b 03	sta $032b	                sta $032B
2631	.ccaa	ae 2c 03	ldx $032c	                ldx $032C
2632	.ccad	ac 2f 03	ldy $032f	                ldy $032F

2634						;-------------------------------------------------------------------------
2635						;
2636						; Get display address for a text position.
2637						;
2638	.ccb0					getAddressForTextPosition:
2639	.ccb0	ad 18 03	lda $0318	                lda vduv.textCursorXPosition
2640	.ccb3	48		pha		                pha
2641	.ccb4	ad 19 03	lda $0319	                lda vduv.textCursorYPosition
2642	.ccb7	48		pha		                pha
2643	.ccb8	8e 18 03	stx $0318	                stx vduv.textCursorXPosition
2644	.ccbb	8c 19 03	sty $0319	                sty vduv.textCursorYPosition
2645	.ccbe	20 fa cc	jsr $ccfa	                jsr updateZMEMTWithTextCursorPosition
2646	.ccc1	7a		ply		                ply
2647	.ccc2	8c 19 03	sty $0319	                sty vduv.textCursorYPosition
2648	.ccc5	7a		ply		                ply
2649	.ccc6	8c 18 03	sty $0318	                sty vduv.textCursorXPosition
2650	.ccc9	60		rts		                rts

2652						;-------------------------------------------------------------------------

2654	.ccca					LCCCA:
2655	.ccca	f0 03		beq $cccf	                beq LCCCF
2656	.cccc	ca		dex		                dex
2657	.cccd	86 dc		stx $dc		                stx ZTEMPB+0
2658	.cccf					LCCCF:
2659	.cccf	ad 66 03	lda $0366	                lda vduv.cursorFlags
2660	.ccd2	29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
2661	.ccd4	aa		tax		                tax
2662	.ccd5	a5 dc		lda $dc		                lda ZTEMPB+0
2663	.ccd7					LCCD7:
2664	.ccd7	20 c7 c2	jsr $c2c7	                jsr setTextCursorXPositionWithCursorFlags

2666	.ccda					updateZMEMTWithTextCursorPositionIfValid:
2667	.ccda					LCCDA:
2668	.ccda	ae 18 03	ldx $0318	                ldx vduv.textCursorXPosition
2669	.ccdd	ec 08 03	cpx $0308	                cpx vduv.textWindowLeft
2670	.cce0	30 16		bmi $ccf8	                bmi LCCF8            ;taken if off left edge of window
2671	.cce2	ec 0a 03	cpx $030a	                cpx vduv.textWindowRight
2672	.cce5	f0 02		beq $cce9	                beq LCCE9            ;taken if at right edge of window
2673	.cce7	10 0f		bpl $ccf8	                bpl LCCF8            ;taken if off right edge of window
2674	.cce9					LCCE9:
2675	.cce9	ae 19 03	ldx $0319	                ldx vduv.textCursorYPosition
2676	.ccec	ec 0b 03	cpx $030b	                cpx vduv.textWindowTop
2677	.ccef	30 07		bmi $ccf8	                bmi LCCF8
2678	.ccf1	ec 09 03	cpx $0309	                cpx vduv.textWindowBottom
2679	.ccf4	30 04		bmi $ccfa	                bmi updateZMEMTWithTextCursorPosition
2680	.ccf6	f0 02		beq $ccfa	                beq updateZMEMTWithTextCursorPosition
2681	.ccf8					LCCF8:
2682	.ccf8	38		sec		                sec
2683	.ccf9	60		rts		                rts

2685						;-------------------------------------------------------------------------
2686						;
2687						; Get display address for current text cursor position.
2688						;
2689						; Set up display address without using BBC lookup table at &E0/1
2690						;
2691						; Exit: C=0
2692						;
2693	.ccfa					updateZMEMTWithTextCursorPosition:
2694	.ccfa	ad 56 03	lda $0356	                lda vduv.currentScreenMODEGroup
2695	.ccfd	29 fe		and #$fe	                and #$fe                     ; Reduce to 0,0,2,2,4
2696	.ccff	aa		tax		                tax                          ; Index into jump table
2697	.cd00	ac 19 03	ldy $0319	                ldy vduv.textCursorYPosition  ; Get current line
2698	.cd03	7c 06 cd	jmp ($cd06,x)	                jmp (multiplyRoutinesTable,x) ; Jump to calculation setup

2700	.cd06					multiplyRoutinesTable:
2701	>cd06	21 cd				                .word multiplyBy640     ; Memory map 0,1  MODE 0,1,2,3
2702	>cd08	15 cd				                .word multiplyBy320       ; Memory map 2,3  MODE 4,5,6
2703	>cd0a	0c cd				                .word multiplyBy40        ; Memory map 4    MODE 7

2705	.cd0c					multiplyBy40:
2706	.cd0c	be bf e0	ldx $e0bf,y	                ldx multiplyBy40TableHigh,y ; Get offset high byte for start of this line
2707	.cd0f	b9 d8 e0	lda $e0d8,y	                lda multiplyBy40TableLow,y ; Get offset low byte for start of this line
2708	.cd12	18		clc		                clc
2709	.cd13	80 14		bra $cd29	                bra LCD29

2711	.cd15					multiplyBy320:
2712	.cd15	b9 f1 e0	lda $e0f1,y	                lda multiplyBy640TableHigh,y
2713	.cd18	4a		lsr a		                lsr a
2714	.cd19	aa		tax		                tax
2715	.cd1a	98		tya		                tya
2716	.cd1b	29 03		and #$03	                and #$03
2717	.cd1d	4a		lsr a		                lsr a
2718	.cd1e	6a		ror a		                ror a
2719	.cd1f	80 07		bra $cd28	                bra LCD28

2721	.cd21					multiplyBy640:
2722	.cd21	be f1 e0	ldx $e0f1,y	                ldx multiplyBy640TableHigh,y
2723	.cd24	98		tya		                tya
2724	.cd25	29 01		and #$01	                and #$01
2725	.cd27	4a		lsr a		                lsr a
2726	.cd28					LCD28:
2727	.cd28	6a		ror a		                ror a                        ; A=A/2 +(128*carry)

2729	.cd29					LCD29:
2730	.cd29	6d 50 03	adc $0350	                adc vduv.screenTopLeftAddress+0
2731	.cd2c	85 d8		sta $d8		                sta ZMEMT+0                      ; store it
2732	.cd2e	8a		txa		                txa
2733	.cd2f	6d 51 03	adc $0351	                adc vduv.screenTopLeftAddress+1 ; window start address hi
2734	.cd32	a8		tay		                tay
2735	.cd33	ad 18 03	lda $0318	                lda vduv.textCursorXPosition  ; text column
2736	.cd36	ae 4f 03	ldx $034f	                ldx vduv.bytesPerCharacter    ; bytes per character
2737	.cd39	ca		dex		                dex
2738	.cd3a	f0 12		beq $cd4e	                beq LCD4E                    ; 1 colour, MODE 7
2739	.cd3c	e0 0f		cpx #$0f	                cpx #$0F
2740	.cd3e	f0 03		beq $cd43	                beq LCD43                    ; 4 colours, MODE 1 or MODE 5
2741	.cd40	90 02		bcc $cd44	                bcc LCD44                    ; 2 colours, MODE 0,3,4,6
2742	.cd42	0a		asl a		                asl a                        ; 16 colours, MODE 2
2743	.cd43					LCD43:
2744	.cd43	0a		asl a		                asl a
2745	.cd44					LCD44:
2746	.cd44	0a		asl a		                asl a
2747	.cd45	0a		asl a		                asl a
2748	.cd46	90 02		bcc $cd4a	                bcc LCD4A
2749	.cd48	c8		iny		                iny
2750	.cd49	c8		iny		                iny
2751	.cd4a					LCD4A:
2752	.cd4a	0a		asl a		                asl a
2753	.cd4b	90 02		bcc $cd4f	                bcc LCD4F
2754	.cd4d	c8		iny		                iny
2755	.cd4e					LCD4E:
2756	.cd4e	18		clc		                clc
2757	.cd4f					LCD4F:
2758	.cd4f	65 d8		adc $d8		                adc ZMEMT+0
2759	.cd51	85 d8		sta $d8		                sta ZMEMT+0
2760	.cd53	8d 4a 03	sta $034a	                sta vduv.textCursorCRTCAddress+0
2761	.cd56	aa		tax		                tax
2762	.cd57	98		tya		                tya
2763	.cd58	69 00		adc #$00	                adc #$00
2764	.cd5a	8d 4b 03	sta $034b	                sta vduv.textCursorCRTCAddress+1
2765	.cd5d	10 04		bpl $cd63	                bpl LCD63
2766	.cd5f	38		sec		                sec
2767	.cd60	ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte
2768	.cd63					LCD63:
2769	.cd63	85 d9		sta $d9		                sta ZMEMT+1
2770	.cd65	18		clc		                clc
2771	.cd66	60		rts		                rts

2773						;-------------------------------------------------------------------------

2775	.cd67					nextMaskedCharColumn
2776	.cd67	ee 24 03	inc $0324	                inc vduv.graphicsCursorPixelsX+0
2777	.cd6a	d0 03		bne $cd6f	                bne +
2778	.cd6c	ee 25 03	inc $0325	                inc vduv.graphicsCursorPixelsX+1
2779	.cd6f					+
2780	.cd6f	0a		asl a		                asl a
2781	.cd70					plotMaskedCharRow:
2782						                ; find next pixel to plot, updating graphics cursor X
2783						                ; as it goes. A is non-zero, so this loop will finish
2784						                ; eventually.
2785	.cd70	10 f5		bpl $cd67	                bpl nextMaskedCharColumn
2786	.cd72	5a		phy		                phy
2787	.cd73	85 dd		sta $dd		                sta ZTEMPB+1                 ;
2788	.cd75	a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixels
2789	.cd77	20 c8 de	jsr $dec8	                jsr gaddrEntryPoint
2790	.cd7a	80 02		bra $cd7e	                bra plotMaskedCharPixel

2792	.cd7c					plotMaskedCharPixelsLoop:
2793	.cd7c	10 03		bpl $cd81	                bpl nextMaskedCharPixel
2794	.cd7e					plotMaskedCharPixel:
2795	.cd7e	20 51 db	jsr $db51	                jsr plbyteEntryPoint
2796	.cd81					nextMaskedCharPixel
2797	.cd81	46 d1		lsr $d1		                lsr ZMASK
2798	.cd83	90 03		bcc $cd88	                bcc +
2799	.cd85	20 67 da	jsr $da67	                jsr nextColumnAndResetMask
2800	.cd88					+
2801	.cd88	06 dd		asl $dd		                asl ZTEMPB+1
2802	.cd8a	d0 f0		bne $cd7c	                bne plotMaskedCharPixelsLoop
2803	.cd8c	a2 28		ldx #$28	                ldx #VDUVariables.workspace._28
2804	.cd8e	a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixelsX
2805	.cd90	20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
2806	.cd93	7a		ply		                ply
2807	.cd94	80 50		bra $cde6	                bra nextMaskedCharY

2809	.cd96					plotCharAtGraphicsCursor:
2810	.cd96	20 3c e2	jsr $e23c	                jsr getSoftCharacterDefinitionAddress
2811	.cd99	9c 59 03	stz $0359	                stz vduv.graphicsPlotState   ;plot in foreground colour
2812	.cd9c	ad 5b 03	lda $035b	                lda vduv.foregroundGCOLMode
2813	.cd9f	29 0f		and #$0f	                and #$0F
2814	.cda1					plotFontDataAtGraphicsCursorWithPlotMode:
2815	.cda1	8d 5a 03	sta $035a	                sta vduv.graphicsPlotMode
2816	.cda4	a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
2817	.cda6	20 1c c9	jsr $c91c	                jsr copyGraphicsCursorPixels
2818	.cda9	a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixelsX
2819	.cdab	a2 00		ldx #$00	                ldx #VDUVariables.graphicsWindowPixelsLeft
2820	.cdad	20 b4 ce	jsr $ceb4	                jsr getDistanceMask
2821	.cdb0	85 dc		sta $dc		                sta ZTEMPB+0
2822	.cdb2	a2 04		ldx #$04	                ldx #VDUVariables.graphicsWindowPixelsRight
2823	.cdb4	20 b4 ce	jsr $ceb4	                jsr getDistanceMask
2824	.cdb7	6a		ror a		                ror a
2825	.cdb8	14 dc		trb $dc		                trb ZTEMPB+0
2826	.cdba	a2 26		ldx #$26	                ldx #VDUVariables.graphicsCursorPixelsY
2827	.cdbc	a0 06		ldy #$06	                ldy #VDUVariables.graphicsWindowPixelsTop
2828	.cdbe	20 b4 ce	jsr $ceb4	                jsr getDistanceMask
2829	.cdc1	85 dd		sta $dd		                sta ZTEMPB+1
2830	.cdc3	a2 26		ldx #$26	                ldx #VDUVariables.graphicsCursorPixelsY
2831	.cdc5	a0 02		ldy #$02	                ldy #VDUVariables.graphicsWindowPixelsBottom
2832	.cdc7	20 b4 ce	jsr $ceb4	                jsr getDistanceMask
2833	.cdca	6a		ror a		                ror a
2834	.cdcb	14 dd		trb $dd		                trb ZTEMPB+1
2835	.cdcd	a0 07		ldy #$07	                ldy #$07
2836	.cdcf					copyMaskedCharLoop:
2837	.cdcf	b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte
2838	.cdd1	25 dc		and $dc		                and ZTEMPB+0                 ;mask out columns
2839	.cdd3	46 dd		lsr $dd		                lsr ZTEMPB+1                 ;test row
2840	.cdd5	b0 02		bcs $cdd9	                bcs +
2841	.cdd7	a9 00		lda #$00	                lda #$00                     ;mask out this row
2842	.cdd9					+
2843	.cdd9	99 2c 03	sta $032c,y	                sta vduv.workspace._2C,y
2844	.cddc	88		dey		                dey
2845	.cddd	10 f0		bpl $cdcf	                bpl copyMaskedCharLoop
2846	.cddf	a0 f8		ldy #$f8	                ldy #$F8
2847	.cde1					plotMaskedCharLoop:
2848	.cde1	b9 34 02	lda $0234,y	                lda vduv.workspace._2C-$f8,y ;get masked byte
2849	.cde4	d0 8a		bne $cd70	                bne plotMaskedCharRow        ;taken if data to write
2850	.cde6					nextMaskedCharY:
2851	.cde6	ae 26 03	ldx $0326	                ldx vduv.graphicsCursorPixelsY+0
2852	.cde9	d0 03		bne $cdee	                bne +
2853	.cdeb	ce 27 03	dec $0327	                dec vduv.graphicsCursorPixelsY+1
2854	.cdee					+
2855	.cdee	ce 26 03	dec $0326	                dec vduv.graphicsCursorPixelsY+0
2856	.cdf1	c8		iny		                iny
2857	.cdf2	d0 ed		bne $cde1	                bne plotMaskedCharLoop
2858	.cdf4	a2 2a		ldx #$2a	                ldx #VDUVariables.workspace._2A
2859	.cdf6	a0 26		ldy #$26	                ldy #VDUVariables.graphicsCursorPixelsY
2860	.cdf8	4c 0c c9	jmp $c90c	                jmp copyTwoBytesWithinVDUVariables

2862	.cdfb					vdu127AtGraphicsCursor:
2863						                ; CHR$127 is a solid block, not a backspace.
2864	.cdfb	a9 f8		lda #$f8	                lda #<chr127
2865	.cdfd	85 de		sta $de		                sta ZTEMPC+0
2866	.cdff	a9 bb		lda #$bb	                lda #>chr127
2867	.ce01	85 df		sta $df		                sta ZTEMPC+1
2868	.ce03	a2 08		ldx #$08	                ldx #$08
2869	.ce05	8e 59 03	stx $0359	                stx vduv.graphicsPlotState   ;plot in background colour
2870	.ce08	a9 00		lda #$00	                lda #$00
2871	.ce0a	80 95		bra $cda1	                bra plotFontDataAtGraphicsCursorWithPlotMode

2873	.ce0c					plotCharAtTextCursor:
2874	.ce0c	20 2d d1	jsr $d12d	                jsr handleColumn81
2875	.ce0f	b0 85		bcs $cd96	                bcs plotCharAtGraphicsCursor          ;taken if VDU5
2876	.ce11	ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
2899	.ce14	f0 37		beq $ce4d	                beq writeTeletextChar
2901	.ce16					writeBitmapSoftCharacter:
2902	.ce16	20 3c e2	jsr $e23c	                jsr getSoftCharacterDefinitionAddress
2903	.ce19					writeBitmapChar:
2904	.ce19	a0 07		ldy #$07	                ldy #$07
2905	.ce1b	e0 03		cpx #$03	                cpx #$03
2906	.ce1d	f0 34		beq $ce53	                beq write2bppChar            ;taken if MODE 1/5
2907	.ce1f	b0 5b		bcs $ce7c	                bcs write4bppChar                    ;taken if MODE 2
2908	.ce21					write1bppChar:
2909	.ce21	b1 de		lda ($de),y	                lda (ZTEMPC),y
2910	.ce23	05 d2		ora $d2		                ora ZORA
2911	.ce25	45 d3		eor $d3		                eor ZEOR
2912	.ce27	91 d8		sta ($d8),y	                sta (ZMEMT),y
2913	.ce29	88		dey		                dey
2921	.ce2a	10 f5		bpl $ce21	                bpl write1bppChar
2922	.ce2c	60		rts		                rts

2924	.ce2d					vdu127EntryPoint:
2925	.ce2d	a9 20		lda #$20	                lda #$20
2926	.ce2f	2c 66 03	bit $0366	                bit $0366
2927	.ce32	d0 03		bne $ce37	                bne LCE37
2928	.ce34	20 9a c2	jsr $c29a	                jsr vdu8EntryPoint
2929	.ce37					LCE37:
8	.ce37	20 e2 e2	jsr $e2e2	                jsr testVDU5StateNonInlined
2931	.ce3a	d0 bf		bne $cdfb	                bne vdu127AtGraphicsCursor
2932	.ce3c	ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
2933	.ce3f	f0 0a		beq $ce4b	                beq writeTeletextSpaceChar   ;taken if teletext mode

2935						                ; Address of space char is known.
2936	.ce41	a9 00		lda #$00	                lda #<LB900
2937	.ce43	85 de		sta $de		                sta ZTEMPC+0
2938	.ce45	a9 b9		lda #$b9	                lda #>LB900
2939	.ce47	85 df		sta $df		                sta ZTEMPC+1
2940	.ce49	80 ce		bra $ce19	                bra writeBitmapChar

2942	.ce4b					writeTeletextSpaceChar:
2943	.ce4b	a9 20		lda #$20	                lda #$20
2948	.ce4d					writeTeletextChar:
2949	.ce4d	20 e5 dd	jsr $dde5	                jsr getSAA5050FromASCII
2950	.ce50	92 d8		sta ($d8)	                sta (ZMEMT)
2951	.ce52	60		rts		                rts

2954	.ce53					write2bppChar:
2955	.ce53	a5 d9		lda $d9		                lda ZMEMT+1
2956	.ce55	a6 d8		ldx $d8		                ldx ZMEMT+0
2957	.ce57	20 e7 ce	jsr $cee7	                jsr getNextColumnAddress
2958	.ce5a					-
2959	.ce5a	b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte
2960	.ce5c	29 0f		and #$0f	                and #$0F                     ;get data for right 4 pixels
2961	.ce5e	aa		tax		                tax
2962	.ce5f	bd 23 e0	lda $e023,x	                lda LE013,x                  ;form byte
2963	.ce62	05 d2		ora $d2		                ora ZORA
2964	.ce64	45 d3		eor $d3		                eor ZEOR
2965	.ce66	91 e0		sta ($e0),y	                sta (ZTEMPD),y               ;write to right column
2966	.ce68	b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte
2970	.ce6a	4a		lsr a		                lsr a                        ;
2971	.ce6b	4a		lsr a		                lsr a                        ;
2972	.ce6c	4a		lsr a		                lsr a                        ;
2973	.ce6d	4a		lsr a		                lsr a                        ;get data for left 4 pixels
2975	.ce6e	aa		tax		                tax                          ;
2976	.ce6f	bd 23 e0	lda $e023,x	                lda LE013,x                  ;form byte
2977	.ce72	05 d2		ora $d2		                ora ZORA
2978	.ce74	45 d3		eor $d3		                eor ZEOR
2979	.ce76	91 d8		sta ($d8),y	                sta (ZMEMT),y                ;write to left column
2980	.ce78	88		dey		                dey
2981	.ce79	10 df		bpl $ce5a	                bpl -
2982	.ce7b	60		rts		                rts

2984						get4bppScreenByteFor2Pixels: .macro
2989						                .endm

2991	.ce7c					write4bppChar:
2992	.ce7c	a5 d9		lda $d9		                lda ZMEMT+1
2993	.ce7e	a6 d8		ldx $d8		                ldx ZMEMT+0
2994	.ce80	20 d9 ce	jsr $ced9	                jsr getNext3ColumnAddresses
2995	.ce83					-
2996	.ce83	b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte - %abcdefgh
3001	.ce85	20 a9 ce	jsr $cea9	                jsr get4bppScreenByteFor2PixelsNonInlined ;pixels g and h
3003	.ce88	91 e0		sta ($e0),y	                sta (ZTEMPD),y
3004	.ce8a	b1 de		lda ($de),y	                lda (ZTEMPC),y               ;get font byte - %abcdefgh
3005	.ce8c	4a		lsr a		                lsr a                        ;%0abcdefg
3006	.ce8d	4a		lsr a		                lsr a                        ;%00abcdef
3007	.ce8e	48		pha		                pha                          ;save %00abcdef
3012	.ce8f	20 a9 ce	jsr $cea9	                jsr get4bppScreenByteFor2PixelsNonInlined ;pixels e and f
3014	.ce92	91 dc		sta ($dc),y	                sta (ZTEMPB),y
3015	.ce94	68		pla		                pla                          ;restore %00abcdef
3016	.ce95	4a		lsr a		                lsr a                        ;%000abcde
3017	.ce96	4a		lsr a		                lsr a                        ;%0000abcd
3018	.ce97	48		pha		                pha                          ;save %0000abcd
3023	.ce98	20 a9 ce	jsr $cea9	                jsr get4bppScreenByteFor2PixelsNonInlined ;pixels c and d
3025	.ce9b	91 da		sta ($da),y	                sta (ZTEMP),y
3026	.ce9d	68		pla		                pla                          ;restore %0000abcd
3027	.ce9e	4a		lsr a		                lsr a                        ;%00000abc
3028	.ce9f	4a		lsr a		                lsr a                        ;%000000ab
3032	.cea0	20 a9 ce	jsr $cea9	                jsr get4bppScreenByteFor2PixelsNonInlined ;pixels a and b
3034	.cea3	91 d8		sta ($d8),y	                sta (ZMEMT),y
3035	.cea5	88		dey		                dey
3036	.cea6	10 db		bpl $ce83	                bpl -
3037	.cea8	60		rts		                rts

3040	.cea9					get4bppScreenByteFor2PixelsNonInlined:
3041	.cea9	29 03		and #$03	                and #$03                     ;mask out 2 pixels
2985	.ceab	aa		tax		                tax
2986	.ceac	bd 33 e0	lda $e033,x	                lda LE023,x                  ;form byte
2987	.ceaf	05 d2		ora $d2		                ora ZORA
2988	.ceb1	45 d3		eor $d3		                eor ZEOR
3043	.ceb3	60		rts		                rts

3046						;-------------------------------------------------------------------------
3047						;
3048						; Get mask indicating the distance between two 16-bit VDU variable
3049						; values - >=8, or some amount less than that.
3050						;
3051						; (These can be used for masking pixels, or counting loops, or
3052						; whatever.)
3053						;
3054						; entry:
3055						;
3056						; X = offset of value A in VDU variables
3057						;
3058						; Y = offset of value B in VDU variables
3059						;
3060						; exit:
3061						;
3062						; if distance<=0, A=255, C=1
3063						;
3064						; if distance>=8, A=0, C=0
3065						;
3066						; otherwise, A=255>>distance, C=0
3067						;
3068	.ceb4					getDistanceMask:
3069	.ceb4	38		sec		                sec
3070	.ceb5	bd 00 03	lda $0300,x	                lda vduv+0,x
3071	.ceb8	f9 00 03	sbc $0300,y	                sbc vduv+0,y
3072	.cebb	85 da		sta $da		                sta ZTEMP                    ;get result LSB
3073	.cebd	bd 01 03	lda $0301,x	                lda vduv+1,x
3074	.cec0	f9 01 03	sbc $0301,y	                sbc vduv+1,y
3075	.cec3	30 0c		bmi $ced1	                bmi distanceMask255                  ;taken if result -ve
3076	.cec5	d0 0e		bne $ced5	                bne distanceMask0                  ;taken if result >=256
3077	.cec7	a6 da		ldx $da		                ldx ZTEMP
3078	.cec9	e0 08		cpx #$08	                cpx #$08
3079	.cecb	b0 08		bcs $ced5	                bcs distanceMask0                    ;taken if result>=8
3080	.cecd	bd 37 e1	lda $e137,x	                lda distanceMasksTable,x             ;get mask for <8 items
3081	.ced0	60		rts		                rts

3083	.ced1					distanceMask255:
3084	.ced1	a9 ff		lda #$ff	                lda #%11111111
3085	.ced3	38		sec		                sec
3086	.ced4	60		rts		                rts

3088	.ced5					distanceMask0:
3089	.ced5	a9 00		lda #$00	                lda #$00
3090	.ced7	18		clc		                clc
3091	.ced8	60		rts		                rts

3093						;-------------------------------------------------------------------------
3094						;
3095						; Get addresses of next 3 columns on screen.
3096						;
3097						; entry:
3098						;
3099						; A (MSB)/X (LSB) = address
3100						;
3101						; exit:
3102						;
3103						; (ZTEMP) = column N+1
3104						; (ZTEMPB) = column N+2
3105						; (ZTEMPD) = column N+3
3106						;
3107	.ced9					getNext3ColumnAddresses:
3108	.ced9	20 e7 ce	jsr $cee7	                jsr getNextColumnAddress
3109	.cedc	86 da		stx $da		                stx ZTEMP+0
3110	.cede	85 db		sta $db		                sta ZTEMP+1
3111	.cee0	20 e7 ce	jsr $cee7	                jsr getNextColumnAddress
3112	.cee3	86 dc		stx $dc		                stx ZTEMPB+0
3113	.cee5	85 dd		sta $dd		                sta ZTEMPB+1

3116						;-------------------------------------------------------------------------
3117						;
3118						; Get address of next column on screen.
3119						;
3120						; entry:
3121						;
3122						; A (MSB)/X (LSB) = address
3123						;
3124						; exit:
3125						;
3126						; A (MSB)/X (LSB) = address of next column
3127						; (ZTEMPD) = address of next column
3128						;
3129	.cee7					getNextColumnAddress:
3130	.cee7	48		pha		                pha
3131	.cee8	8a		txa		                txa
3132	.cee9	18		clc		                clc
3133	.ceea	69 08		adc #$08	                adc #$08                     ;next column...
3134	.ceec	aa		tax		                tax
3135	.ceed	68		pla		                pla
3136	.ceee	90 06		bcc $cef6	                bcc +                        ;taken if no carry
3137	.cef0	1a		inc a		                inc a
3138	.cef1	10 03		bpl $cef6	                bpl +           ;taken if no screen address wraparound
3139	.cef3	ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
3140	.cef6					+
3141	.cef6	86 e0		stx $e0		                stx ZTEMPD+0
3142	.cef8	85 e1		sta $e1		                sta ZTEMPD+1
3143	.cefa	60		rts		                rts

3145						;-------------------------------------------------------------------------
3146						;
3147						; VDU 23 0 Control 6845 CRTC directly [MasRef E.3-12]
3148						;
3149	.cefb					vdu23_0_EntryPoint:
3150	.cefb	ad 1d 03	lda $031d	                lda vduv.queueEnd-7           ;get value
3151	.cefe	ac 1c 03	ldy $031c	                ldy vduv.queueEnd-8           ;get register

3153						                ; fall through to setCRTCRegister

3155						;-------------------------------------------------------------------------
3156						;
3157						; Set a CRTC register, adjusting and/or noting values if appropriate.
3158						;
3159						; entry:
3160						;
3161						; Y = register to set
3162						;
3163						; A = value

3165	.cf01					setCRTCRegister:
3166	.cf01	c0 07		cpy #$07	                cpy #$07
3167	.cf03	90 1f		bcc $cf24	                bcc setCRTCRegisterRaw
3168	.cf05	d0 03		bne $cf0a	                bne +        ;taken if not setting R7

3170						                ; Setting R7 (vsync position), so apply the *TV offset.
3171	.cf07	6d 90 02	adc $0290	                adc tvOffset
3172	.cf0a					+
3173	.cf0a	c0 08		cpy #$08	                cpy #$08
3174	.cf0c	d0 07		bne $cf15	                bne +                    ;taken if not setting R8

3176						                ; Setting R8 (interlace/delay register), so apply the
3177						                ; *TV interlace setting.
3178	.cf0e	09 00		ora #$00	                ora #$00
3179	.cf10	30 03		bmi $cf15	                bmi +       ;branch taken if bit 7 set - this is taken
3180						                            ;to imply the mode being set is Mode 7
3181	.cf12	4d 91 02	eor $0291	                eor tvInterlace ;apply *TV interlace setting
3182	.cf15					+
3183	.cf15	c0 0a		cpy #$0a	                cpy #$0A
3184	.cf17	d0 0b		bne $cf24	                bne setCRTCRegisterRaw

3186						                ; Setting R10 (cursor start register). Note the new
3187						                ; setting in the VDU variable. If in VDU5 mode, reuse
3188						                ; the result of testVDU5State - i.e., 32 - as the
3189						                ; setting, hiding the cursor.
3190	.cf19	8d 5f 03	sta $035f	                sta vduv.lastCursorStartRegisterValue
8	.cf1c	20 e2 e2	jsr $e2e2	                jsr testVDU5StateNonInlined
3192	.cf1f	d0 09		bne $cf2a	                bne rtsCF2A
3193	.cf21	ad 5f 03	lda $035f	                lda vduv.lastCursorStartRegisterValue

3195						                ; fall through to setCRTCRegisterRaw

3197						;-------------------------------------------------------------------------
3198						;
3199						; Set a CRTC register.
3200						;
3201	.cf24					setCRTCRegisterRaw:
3202	.cf24	8c 00 fe	sty $fe00	                sty CRTC+0
3203	.cf27	8d 01 fe	sta $fe01	                sta CRTC+1
3204	.cf2a					rtsCF2A:
3205	.cf2a	60		rts		                rts

3207						;-------------------------------------------------------------------------
3208						;
3209						; VDU 23 1 Turn cursor on/off [MasRef E.3-12]
3210						;
3211	.cf2b					vdu23_1_EntryPoint:
8	.cf2b	20 e2 e2	jsr $e2e2	                jsr testVDU5StateNonInlined
3213	.cf2e	d0 fa		bne $cf2a	                bne rtsCF2A                  ;taken if VDU5
3214	.cf30	ad 1c 03	lda $031c	                lda vduv.queueEnd-8           ;get new cursor state
3215	.cf33	29 03		and #$03	                and #$03                     ;mask off bits of interest
3216	.cf35	0a		asl a		                asl a
3217	.cf36	aa		tax		                tax
3218	.cf37	a9 20		lda #$20	                lda #$20 ;R10 value for hiding the cursor - save a few
3219						                         ;bytes by loading this here
3220	.cf39	7c 3c cf	jmp ($cf3c,x)	                jmp (LCF3C,x)

3222	.cf3c					LCF3C:
3223	>cf3c	53 cf				                .word setCRTCRegister10            ; 23,1,0... - hide
3224	>cf3e	50 cf				                .word showCursor            ; 23,1,1... - show
3225	>cf40	44 cf				                .word steadyCursor          ; 23,1,2... - steady
3226	>cf42	4b cf				                .word slowFlashCursor       ; 23,1,3... - flash slowly

3228	.cf44					steadyCursor:
3229	.cf44	a9 60		lda #$60	                lda #%01100000
3230	.cf46	1c 5f 03	trb $035f	                trb vduv.lastCursorStartRegisterValue ;steady cursor
3231	.cf49	80 05		bra $cf50	                bra showCursor

3233	.cf4b					slowFlashCursor:
3234	.cf4b	a9 60		lda #$60	                lda #%01100000
3235	.cf4d	0c 5f 03	tsb $035f	                tsb vduv.lastCursorStartRegisterValue ;slow blink cursor
3236	.cf50					showCursor:
3237	.cf50	ad 5f 03	lda $035f	                lda vduv.lastCursorStartRegisterValue
3238	.cf53					setCRTCRegister10:
3239	.cf53	a0 0a		ldy #$0a	                ldy #$0A
3240	.cf55	80 cd		bra $cf24	                bra setCRTCRegisterRaw

3242						;-------------------------------------------------------------------------
3243						;
3244						; VDU 23 2-5 Set ECF patterns [MasRef E.3-13]
3245						;
3246	.cf57					vdu23_2_EntryPoint:
3247	.cf57					vdu23_3_EntryPoint:
3248	.cf57					vdu23_4_EntryPoint:
3249	.cf57					vdu23_5_EntryPoint:
3250	.cf57	e9 01		sbc #$01	                sbc #$01  ;subtract 2 (C=0 on entry...) to get pattern
3251						                          ;index
3252	.cf59	0a		asl a		                asl a
3253	.cf5a	0a		asl a		                asl a
3254	.cf5b	0a		asl a		                asl a                        ;index*8
3255	.cf5c	69 07		adc #$07	                adc #$07                     ;index*8+7
3256	.cf5e	a8		tay		                tay
3257	.cf5f	a2 07		ldx #$07	                ldx #$07
3258	.cf61					-
3259	.cf61	bd 1c 03	lda $031c,x	                lda vduv.queueEnd-8,x
3260	.cf64	99 00 88	sta $8800,y	                sta andy.ecfPatterns,y
3261	.cf67	88		dey		                dey
3262	.cf68	ca		dex		                dex
3263	.cf69	10 f6		bpl $cf61	                bpl -
3264	.cf6b	80 26		bra $cf93	                bra LCF93

3266						;-------------------------------------------------------------------------

3268	.cf6d					vdu23_11_EntryPoint:
3269	.cf6d	ad 55 03	lda $0355	                lda vduv.currentScreenMODE
3270	.cf70	d0 01		bne $cf73	                bne +
3271						                ; Use a different table for MODE 0 - see MasRef E.3-16.
3272	.cf72	3a		dec a		                dec a                        ;
3273	.cf73					+
3274	.cf73	29 03		and #$03	                and #$03 ;index=0 (mode 4); 1 (mode 1/5); 2 (mode 2);
3275						                         ;3 (mode 0)
3276	.cf75	1a		inc a		                inc a
3277	.cf76	0a		asl a		                asl a
3278	.cf77	0a		asl a		                asl a
3279	.cf78	0a		asl a		                asl a
3280	.cf79	0a		asl a		                asl a                        ;(index+1)*16
3281	.cf7a	aa		tax		                tax
3282	.cf7b	a0 1c		ldy #$1c	                ldy #32-4
3283	.cf7d					setDefaultECFPatterns:
3284	.cf7d	bd d3 e1	lda $e1d3,x	                lda defaultECFPatterns-1,x
3285	.cf80	99 ff 87	sta $87ff,y	                sta andy.ecfPatterns-1,y     ;copy first repeat
3286	.cf83	99 03 88	sta $8803,y	                sta andy.ecfPatterns+4-1,y   ;copy second repeat
3287	.cf86	ca		dex		                dex                          ;next byte in defaults table
3288	.cf87	88		dey		                dey
3289	.cf88	98		tya		                tya
3290	.cf89	89 07		bit #$07	                bit #$07
3291	.cf8b	d0 f0		bne $cf7d	                bne setDefaultECFPatterns ;taken if pattern not filled
3292						                ; skip to start of previous pattern
3293	.cf8d	88		dey		                dey
3294	.cf8e	88		dey		                dey
3295	.cf8f	88		dey		                dey
3296	.cf90	88		dey		                dey
3297	.cf91	10 ea		bpl $cf7d	                bpl setDefaultECFPatterns
3298	.cf93					LCF93:
3299	.cf93	4c 7d c5	jmp $c57d	                jmp initializeCurrentECFPatterns

3301						;-------------------------------------------------------------------------
3302						;
3303						; VDU 23 12-15 Set simple ECF pattern [MasRef E.3-17]
3304						;
3305	.cf96					vdu23_12_EntryPoint:
3306	.cf96					vdu23_13_EntryPoint:
3307	.cf96					vdu23_14_EntryPoint:
3308	.cf96					vdu23_15_EntryPoint:
3309	.cf96	e9 0b		sbc #$0b	                sbc #$0B                     ;-12 to get pattern index
3310	.cf98	0a		asl a		                asl a                        ;index*2
3311	.cf99	0a		asl a		                asl a                        ;index*4
3312	.cf9a	0a		asl a		                asl a                        ;index*8, C=0
3313	.cf9b	69 03		adc #$03	                adc #$03                     ;index*8+3, C=0
3314	.cf9d	48		pha		                pha                          ;save offset
3315	.cf9e	a2 07		ldx #$07	                ldx #$07                     ;
3316	.cfa0					LCFA0:
3317	.cfa0	bd 1c 03	lda $031c,x	                lda vduv.queueEnd-8,x        ;get simple pattern byte
3318	.cfa3	2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne ;apply logical colour limit
3319	.cfa6	85 da		sta $da		                sta ZTEMP+0
3320	.cfa8	ad 60 03	lda $0360	                lda vduv.numberOfLogicalColoursMinusOne
3321	.cfab	29 07		and #$07	                and #$07                     ;1/3/7
3322	.cfad	65 da		adc $da		                adc ZTEMP+0                  ;select 2/4/16 colour table
3323	.cfaf	a8		tay		                tay
3324	.cfb0	b9 5b e1	lda $e15b,y	                lda solidColoursTable-1,y
3325	.cfb3	9d 1c 03	sta $031c,x	                sta vduv.queueEnd-8,x
3326	.cfb6	ca		dex		                dex
3327	.cfb7	10 e7		bpl $cfa0	                bpl LCFA0
3328	.cfb9	a9 55		lda #$55	                lda #%01010101
3329	.cfbb	ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
3330	.cfbe	d0 02		bne $cfc2	                bne +                 ;taken if not MODE 0
3331	.cfc0	a9 33		lda #$33	                lda #%00110011        ;double-width pattern for MODE 0
3332	.cfc2					+
3333	.cfc2	85 da		sta $da		                sta ZTEMP+0
3334	.cfc4	7a		ply		                ply
3335	.cfc5	a2 07		ldx #$07	                ldx #$07
3336	.cfc7					LCFC7:
3337	.cfc7	bd 1c 03	lda $031c,x	                lda vduv.queueEnd-8,x
3338	.cfca	ca		dex		                dex
3339	.cfcb	5d 1c 03	eor $031c,x	                eor vduv.queueEnd-8,x
3340	.cfce	25 da		and $da		                and ZTEMP+0
3341	.cfd0	5d 1c 03	eor $031c,x	                eor vduv.queueEnd-8,x
3342	.cfd3	99 00 88	sta $8800,y	                sta andy.ecfPatterns+0,y
3343	.cfd6	99 04 88	sta $8804,y	                sta andy.ecfPatterns+4,y
3344	.cfd9	88		dey		                dey
3345	.cfda	ca		dex		                dex
3346	.cfdb	10 ea		bpl $cfc7	                bpl LCFC7
3347	.cfdd	80 b4		bra $cf93	                bra LCF93

3349						;-------------------------------------------------------------------------
3350						;
3351						; VDU 23 6 Set dotted lines pattern [MasRef E.3-13]
3352						;
3353	.cfdf					vdu23_6_EntryPoint:
3354	.cfdf	ad 1c 03	lda $031c	                lda vduv.queueEnd-8
3355	.cfe2	8d 67 03	sta $0367	                sta vduv.dotPattern
3356	.cfe5	60		rts		                rts

3358						;-------------------------------------------------------------------------
3359						;
3360						; VDU 23 7 Scroll window directly [MasRef E.3-14]
3361						;
3362	.cfe6					vdu23_7_EntryPoint:
3363	.cfe6	ad 1c 03	lda $031c	                lda vduv.queueEnd-8           ;get <m>
3364	.cfe9	d0 0a		bne $cff5	                bne scrollEntireScreen
3365	.cfeb	20 10 c9	jsr $c910	                jsr copyTextWindowToWorkspace2C
3366	.cfee	a5 d0		lda $d0		                lda STATE
3367	.cff0	29 08		and #$08	                and #STATE.isTextWindow
3368	.cff2	0a		asl a		                asl a ;A=$10 (text window active) or $00 (no text window)
3369	.cff3	80 11		bra $d006	                bra +

3371	.cff5					scrollEntireScreen:
3372	.cff5	a9 00		lda #$00	                lda #$00
3373	.cff7	8d 2c 03	sta $032c	                sta vduv.workspace._2C          ;left
3374	.cffa	8d 2f 03	sta $032f	                sta vduv.workspace._2F          ;top
3375	.cffd	20 b2 e2	jsr $e2b2	                jsr getDefaultBoundsForCurrentScreenMODE
3376	.d000	8e 2e 03	stx $032e	                stx vduv.workspace._2E          ;right
3377	.d003	8c 2d 03	sty $032d	                sty vduv.workspace._2D          ;bottom
3378	.d006					+
3379	.d006	85 dc		sta $dc		                sta ZTEMPB+0
3380	.d008	38		sec		                sec
3381	.d009	ad 2e 03	lda $032e	                lda vduv.workspace._2E          ;right
3382	.d00c	ed 2c 03	sbc $032c	                sbc vduv.workspace._2C          ;right-left
3383	.d00f	20 3b c9	jsr $c93b	                jsr getBytesPerInclusiveTextRow
3384	.d012	8d 28 03	sta $0328	                sta vduv.workspace._28+0        ;bytes per row LSB
3385	.d015	8e 29 03	stx $0329	                stx vduv.workspace._28+1        ;bytes per row MSB
3386	.d018	ae 4f 03	ldx $034f	                ldx vduv.bytesPerCharacter
3387	.d01b	e0 01		cpx #$01	                cpx #$01
3388	.d01d	f0 07		beq $d026	                beq +  ;when 1 byte/char, no cell/byte distinction
3389	.d01f	ad 1e 03	lda $031e	                lda vduv.queueEnd-6       ;get <z>
3390	.d022	f0 02		beq $d026	                beq +                ;taken if scrolling by 1 cell
3391	.d024	a2 08		ldx #$08	                ldx #$08                 ;scroll by 1 horizontal byte
3392	.d026					+
3393	.d026	8e 2a 03	stx $032a	                stx vduv.workspace._2A

3395						; <d> is a bitmask - %00000AVN.
3396						;
3397						; A is set if scrolling by axis (controlled by the VDU cursor flags)
3398						; rather than by direction.
3399						;
3400						; V is set to scroll vertically/in Y rather than horizontally/in X.
3401						;
3402						; N is set to scroll in the negative direction.

3404	.d029	ad 1d 03	lda $031d	                lda vduv.queueEnd-7           ;00000avn C=?
3405	.d02c	4a		lsr a		                lsr a                        ;000000av C=n
3406	.d02d	08		php		                php
3407	.d02e	2a		rol a		                rol a                        ;00000avn C=0
3408	.d02f	28		plp		                plp                          ;00000avn C=n
3409	.d030	2a		rol a		                rol a                        ;0000avnn C=0
3410	.d031	0a		asl a		                asl a                        ;000avnn0 C=0
3411	.d032	c9 10		cmp #$10	                cmp #$10                     ;$10 = 000a0000
3412	.d034	90 03		bcc $d039	                bcc LD039                 ;taken if scrolling by direction
3413	.d036	4d 66 03	eor $0366	                eor vduv.cursorFlags       ;adjust axes
3414	.d039					LD039:
3415	.d039	29 0e		and #$0e	                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
3416	.d03b	05 dc		ora $dc		                ora ZTEMPB+0
3417	.d03d					LD03D:
3418	.d03d	aa		tax		                tax
3419	.d03e	ad 50 03	lda $0350	                lda vduv.screenTopLeftAddress+0
3420	.d041	85 d8		sta $d8		                sta ZMEMT+0
3421	.d043	ad 51 03	lda $0351	                lda vduv.screenTopLeftAddress+1
3422	.d046	85 d9		sta $d9		                sta ZMEMT+1
3423	.d048	20 4e d0	jsr $d04e	                jsr callScrollRoutine
3424	.d04b	4c d8 c6	jmp $c6d8	                jmp updateCRTCTextCursor

3426	.d04e					callScrollRoutine:
3427	.d04e	7c 1c e2	jmp ($e21c,x)	                jmp (scrollRoutinesTable,x)

3429	.d051					LD051:
3430	.d051	da		phx		                phx
3431	.d052	20 10 c9	jsr $c910	                jsr copyTextWindowToWorkspace2C
3432	.d055	20 08 c9	jsr $c908	                jsr copyTextWindowWidthInBytesToWorkspace28
3433	.d058	ae 4f 03	ldx $034f	                ldx $034F
3434	.d05b	8e 2a 03	stx $032a	                stx $032A
3435	.d05e	68		pla		                pla
3436	.d05f	4a		lsr a		                lsr a
3437	.d060	45 d0		eor $d0		                eor STATE
3438	.d062	29 f7		and #$f7	                and #(~STATE.isTextWindow)&$ff
3439	.d064	45 d0		eor $d0		                eor STATE
3440	.d066	0a		asl a		                asl a
3441	.d067	80 d4		bra $d03d	                bra LD03D

3443						;-------------------------------------------------------------------------
3444						;
3445						; VDU 23 8 Clear block [MasRef E.3-15]
3446						;
3447	.d069					vdu23_8_EntryPoint:
3448	.d069	9c 34 03	stz $0334	                stz $0334
3449	.d06c	9c 35 03	stz $0335	                stz $0335
3450	.d06f	20 62 e2	jsr $e262	                jsr getTextCursorPositionWithColumn81
3451	.d072	8e 36 03	stx $0336	                stx $0336
3452	.d075	8c 37 03	sty $0337	                sty $0337
3453	.d078	20 6c e2	jsr $e26c	                jsr LE25C
3454	.d07b	e8		inx		                inx
3455	.d07c	8e 38 03	stx $0338	                stx $0338
3456	.d07f	8c 39 03	sty $0339	                sty $0339
3457	.d082	a0 00		ldy #$00	                ldy #$00
3458	.d084	ad 1c 03	lda $031c	                lda $031C
3459	.d087	20 e5 d0	jsr $d0e5	                jsr LD0E5
3460	.d08a	ad 1d 03	lda $031d	                lda $031D
3461	.d08d	20 e5 d0	jsr $d0e5	                jsr LD0E5
3462	.d090	ad 33 03	lda $0333	                lda $0333
3463	.d093	cd 31 03	cmp $0331	                cmp $0331
3464	.d096	90 76		bcc $d10e	                bcc LD10E
3465	.d098	d0 08		bne $d0a2	                bne LD0A2
3466	.d09a	ad 30 03	lda $0330	                lda $0330
3467	.d09d	cd 32 03	cmp $0332	                cmp $0332
3468	.d0a0	b0 6c		bcs $d10e	                bcs LD10E
3469	.d0a2					LD0A2:
3470	.d0a2	ad 18 03	lda $0318	                lda $0318
3471	.d0a5	48		pha		                pha
3472	.d0a6	ad 19 03	lda $0319	                lda $0319
3473	.d0a9	48		pha		                pha
3474	.d0aa	ac 31 03	ldy $0331	                ldy $0331
3475	.d0ad					LD0AD:
3476	.d0ad	5a		phy		                phy
3477	.d0ae	ad 66 03	lda $0366	                lda $0366
3478	.d0b1	49 08		eor #$08	                eor #$08
3479	.d0b3	29 0e		and #$0e	                and #$0E
3480	.d0b5	aa		tax		                tax
3481	.d0b6	98		tya		                tya
3482	.d0b7	20 c7 c2	jsr $c2c7	                jsr setTextCursorXPositionWithCursorFlags
3483	.d0ba	a2 00		ldx #$00	                ldx #$00
3484	.d0bc	ad 38 03	lda $0338	                lda $0338
3485	.d0bf	cc 31 03	cpy $0331	                cpy $0331
3486	.d0c2	d0 03		bne $d0c7	                bne LD0C7
3487	.d0c4	ae 30 03	ldx $0330	                ldx $0330
3488	.d0c7					LD0C7:
3489	.d0c7	cc 33 03	cpy $0333	                cpy $0333
3490	.d0ca	f0 07		beq $d0d3	                beq LD0D3
3491	.d0cc	20 7f ca	jsr $ca7f	                jsr LCA7F
3492	.d0cf	7a		ply		                ply
3493	.d0d0	c8		iny		                iny
3494	.d0d1	80 da		bra $d0ad	                bra LD0AD

3496	.d0d3					LD0D3:
3497	.d0d3	ad 32 03	lda $0332	                lda $0332
3498	.d0d6	20 7f ca	jsr $ca7f	                jsr LCA7F
3499	.d0d9	7a		ply		                ply
3500	.d0da	68		pla		                pla
3501	.d0db	8d 19 03	sta $0319	                sta $0319
3502	.d0de	68		pla		                pla
3503	.d0df	8d 18 03	sta $0318	                sta $0318
3504	.d0e2	4c fa cc	jmp $ccfa	                jmp updateZMEMTWithTextCursorPosition

3506	.d0e5					LD0E5:
3507	.d0e5	48		pha		                pha
3508	.d0e6	29 03		and #$03	                and #$03
3509	.d0e8	0a		asl a		                asl a
3510	.d0e9	20 f0 d0	jsr $d0f0	                jsr LD0F0
3511	.d0ec	68		pla		                pla
3512	.d0ed	4a		lsr a		                lsr a
3513	.d0ee	09 01		ora #$01	                ora #$01
3514	.d0f0					LD0F0:
3515	.d0f0	aa		tax		                tax
3516	.d0f1	29 01		and #$01	                and #$01
3517	.d0f3	48		pha		                pha
3518	.d0f4	bd 34 03	lda $0334,x	                lda $0334,x
3519	.d0f7	fa		plx		                plx
3520	.d0f8	18		clc		                clc
3521	.d0f9	c8		iny		                iny
3522	.d0fa	79 1d 03	adc $031d,y	                adc $031D,y
3523	.d0fd	30 0a		bmi $d109	                bmi LD109
3524	.d0ff	dd 38 03	cmp $0338,x	                cmp $0338,x
3525	.d102	90 07		bcc $d10b	                bcc LD10B
3526	.d104	bd 38 03	lda $0338,x	                lda $0338,x
3527	.d107	80 02		bra $d10b	                bra LD10B

3529	.d109					LD109:
3530	.d109	a9 00		lda #$00	                lda #$00
3531	.d10b					LD10B:
3532	.d10b	99 2f 03	sta $032f,y	                sta $032F,y
3533	.d10e					LD10E:
3534	.d10e	60		rts		                rts

3536						;-------------------------------------------------------------------------
3537						;
3538						; VDU 23 9 Set 1st flash time [MasRef E.3-16]
3539						;
3540	.d10f					vdu23_9_EntryPoint:
3541	.d10f	38		sec		                sec

3543						;-------------------------------------------------------------------------
3544						;
3545						; VDU 23 10 Set 2nd flash time [MasRef E.3-16]
3546						;
3547	.d110					vdu23_10_EntryPoint:
3548	.d110	ae 1c 03	ldx $031c	                ldx vduv.queueEnd-8          ;get flash value
3549	.d113	a0 00		ldy #$00	                ldy #$00                     ;Y=0 for OSBYTE call
3550	.d115	90 03		bcc $d11a	                bcc doOSBYTE0A               ;taken if VDU23,10
3551	.d117	4c 2e ed	jmp $ed2e	                jmp osbyte09
3552	.d11a					doOSBYTE0A:
3553	.d11a	38		sec		                sec
3554	.d11b	4c 30 ed	jmp $ed30	                jmp osbyte0A

3556						;-------------------------------------------------------------------------
3557						;
3558						; VDU 23 16 Cursor movement control [MasRef E.3-17]
3559						;
3560	.d11e					vdu23_16_EntryPoint:
3561	.d11e	ad 66 03	lda $0366	                lda vduv.cursorFlags
3562	.d121	2d 1d 03	and $031d	                and vduv.queueEnd-7          ;value AND <y>
3563	.d124	4d 1c 03	eor $031c	                eor vduv.queueEnd-8          ;(value AND <y>) EOR <x>
3564	.d127	8d 66 03	sta $0366	                sta vduv.cursorFlags
3565	.d12a	4a		lsr a		                lsr a
3566	.d12b	b0 18		bcs $d145	                bcs rtsD145            ;taken if scrollProtect flag on
3567						                ; scroll protect flag is off, so handle column 81 if
3568						                ; necessary.

3570						;-------------------------------------------------------------------------
3571						;
3572						; Handle column 81, if necessary.
3573						;
3574						; TODO - probably misnamed due to the return value
3575						;
3576						; exit:
3577						;
3578						; C=0 if not VDU 5
3579						;
3580						; C=1 if VDU 5
3581						;
3582	.d12d					handleColumn81:

3610	.d12d	48		pha		                pha
3611	.d12e	da		phx		                phx
3612	.d12f	20 e2 e2	jsr $e2e2	                jsr testVDU5StateNonInlined
3613	.d132	38		sec		                sec
3614	.d133	d0 0e		bne $d143	                bne plx_pla_rts        ;taken if VDU5
3615	.d135	18		clc		                clc
3616	.d136	2c 6c 03	bit $036c	                bit vduv.column81
3617	.d139	10 08		bpl $d143	                bpl plx_pla_rts        ;taken if not column 81
3618	.d13b	08		php		                php
3619	.d13c	20 f6 c3	jsr $c3f6	                jsr vdu13EntryPoint          ;CR
3620	.d13f	20 5b c2	jsr $c25b	                jsr vdu10EntryPoint          ;LF
3621	.d142	28		plp		                plp
3622	.d143					plx_pla_rts:
3623	.d143	fa		plx		                plx
3624	.d144	68		pla		                pla
3625	.d145					rtsD145:
3626	.d145	60		rts		                rts

3630						;-------------------------------------------------------------------------
3631						;
3632						; Handle PLOT. [MasRef E.3-21]
3633						;
3634						; PLOT numbers are of the form %pppppamm, where %ppppp is the PLOT
3635						; type, %a the absolute flag and %mm the PLOT mode.
3636						;
3637						; Absolute flag and mode are clear enough from [MasRef E.3-22]. The
3638						; %ppppp part isn't documented as such, so here's a list:
3639						;
3640						; %00000 =  0 = 0-7 = Plot solid line (both endpoints included) [MasRef E.3-23]
3641						; %00001 =  1 = 8-15 = Plot solid line (final point omitted) [MasRef E.3-23]
3642						; %00010 =  2 = 16-23 = Plot solid line (final point omitted) [MasRef E.3-23]
3643						; %00011 =  3 = 24-31 = Plot dotted line (final point omitted) [MasRef E.3-23]
3644						; %00100 =  4 = 32-39 = Plot solid line (initial point omitted) [MasRef E.3-24]
3645						; %00101 =  5 = 40-47 = Plot solid line (both endpoints omitted) [MasRef E.3-24]
3646						; %00110 =  6 = 48-55 = Plot dotted line (initial point omitted) [MasRef E.3-24]
3647						; %00111 =  7 = 56-63 = Plot dotted line (both endpoints omitted) [MasRef E.3-24]
3648						; %01000 =  8 = 64-71 = Plot point [MasRef E.3-24]
3649						; %01001 =  9 = 72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
3650						; %01010 = 10 = 80-87 = Plot triangle [MasRef E.3-25]
3651						; %01011 = 11 = 88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
3652						; %01100 = 12 = 96-103 = Plot rectangle [MasRef E.3-26]
3653						; %01101 = 13 = 104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
3654						; %01110 = 14 = 112-119 = Plot parallelogram [MasRef E.3-27]
3655						; %01111 = 15 = 120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
3656						; %10000 = 16 = 128-135 = Flood fill to non-background [MasRef E.3-28]
3657						; %10001 = 17 = 136-143 = Flood fill to foreground [MasRef E.3-28]
3658						; %10010 = 18 = 144-151 = Plot circle outline [MasRef E.3-28]
3659						; %10011 = 19 = 152-159 = Plot filled circle [MasRef E.3-29]
3660						; %10100 = 20 = 160-167 = Plot circular arc [MasRef E.3-29]
3661						; %10101 = 21 = 168-175 = Plot filled chord segment [MasRef E.3-30]
3662						; %10110 = 22 = 176-183 = Plot filled sector [MasRef E.3-30]
3663						; %10111 = 23 = 184-191 = Move/copy rectangle [MasRef E.3-31]
3664						; %11000 = 24 = 192-199 = Plot ellipse outline [MasRef E.3-32]
3665						; %11001 = 25 = 200-207 = Plot solid ellipse [MasRef E.3-32]
3666						; %11010 = 26 = 208-215 = Reserved [MasRef E.3-34]
3667						; %11011 = 27 = 215-223 = Reserved [MasRef E.3-34]
3668						; %11100 = 28 = 224-231 = Reserved [MasRef E.3-34]
3669						; %11101 = 29 = 232-239 = Reserved for Acornsoft sprites [MasRef E.3-34]
3670						; %11110 = 30 = 240-247 = User program calls [MasRef E.3-34]
3671						; %11111 = 31 = 248-255 = User program calls [MasRef E.3-34]
3672						;
3673						; entry:
3674						;
3675						; vduQueueEnd-5 = PLOT number
3676						;
3677						; vduQueueEnd-3 = X coordinate
3678						;
3679						; vduQueueEnd-1 = Y coordinate
3680						;;

3682	.d146					handlePLOT:
3683	.d146	a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
3684	.d148	20 e2 d1	jsr $d1e2	                jsr eigabsForPLOT
3685	.d14b	ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number
3686	.d14e	a0 05		ldy #$05	                ldy #gcolModeLeave                     ;
3687	.d150	29 03		and #$03	                and #$03                     ;mask out colour/plot mode [MasRef E.3-22]
3688	.d152	f0 0c		beq $d160	                beq LD160 ;taken if <p> MOD 4=0 - early out
3689	.d154	4a		lsr a		                lsr a                        ;C=1 if using VDU18 settings
3690	.d155	88		dey		                dey                          ;Y=gcolModeInvert
3691	.d156	90 08		bcc $d160	                bcc LD160                    ;taken if invert mode
3692	.d158	aa		tax		                tax              ;X=0 if fg settings, 1 if bg settings
3693	.d159	bc 5b 03	ldy $035b,x	                ldy vduv.foregroundGCOLMode,x
3694	.d15c	0a		asl a		                asl a
3695	.d15d	0a		asl a		                asl a
3696	.d15e	0a		asl a		                asl a
3697	.d15f	aa		tax		                tax              ;X=0 if fg settings, 8 if bg settings
3698	.d160					LD160:
3699	.d160	8e 59 03	stx $0359	                stx vduv.graphicsPlotState
3700	.d163	98		tya		                tya
3701	.d164	29 0f		and #$0f	                and #$0F
3702	.d166	8d 5a 03	sta $035a	                sta vduv.graphicsPlotMode
3703	.d169	ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number pppppmmm
3704	.d16c	4a		lsr a		                lsr a                        ;0pppppmm
3705	.d16d	4a		lsr a		                lsr a                        ;00pppppm
3706	.d16e	29 fe		and #$fe	                and #$fe                     ;00ppppp0
3707	.d170	aa		tax		                tax
3708	.d171	c9 34		cmp #$34	                cmp #208/4
3709	.d173	b0 1b		bcs $d190	                bcs LD190                    ;taken if reserved PLOT
3710	.d175	29 f3		and #$f3	                and #$F3                     ;00pp00p0
3711	.d177	c9 12		cmp #$12	                cmp #$12                     ;
3712	.d179	08		php		                php                          ;
3713	.d17a	f0 08		beq $d184	                beq LD184                ;taken if horizonal line fill
3714	.d17c	e0 2e		cpx #$2e	                cpx #184/4
3715	.d17e	f0 04		beq $d184	                beq LD184                ;taken if move/copy rectangle
3716	.d180	c0 05		cpy #$05	                cpy #gcolModeLeave
3717	.d182	f0 19		beq $d19d	                beq LD19D
3718	.d184					LD184:
3719	.d184	ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number
3720	.d187	20 93 d1	jsr $d193	                jsr LD193
3721	.d18a	28		plp		                plp
3722	.d18b	d0 11		bne $d19e	                bne LD19E
3723	.d18d	4c df c4	jmp $c4df	                jmp LC4DF

3725	.d190					LD190:
3726	.d190	4c a3 c6	jmp $c6a3	                jmp callVDUVForPLOT

3728	.d193					LD193:
3729	.d193	e0 10		cpx #$10	                cpx #64/4
3730	.d195	b0 03		bcs $d19a	                bcs LD19A                     ;taken if PLOT >=64
3731	.d197	4c a9 d8	jmp $d8a9	                jmp LD8A9                    ;handle line PLOTs

3733	.d19a					LD19A:
3734	.d19a	7c 8b e0	jmp ($e08b,x)	                jmp (plotEntryPointTable-8*2,x)

3736	.d19d					LD19D:
3737	.d19d	68		pla		                pla
3738	.d19e					LD19E:
3739	.d19e	20 1a c9	jsr $c91a	                jsr copyGraphicsCursorPixelsToOldGraphicsCursorPixels
3740	.d1a1	a0 24		ldy #$24	                ldy #$24
3741	.d1a3	4c 16 c9	jmp $c916	                jmp copyLastFourVDUQueueBytes

3743	.d1a6					LD1A6:
3744	.d1a6	a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX

3746						;-------------------------------------------------------------------------
3747						;
3748						; WIND [MasRef E.4-7]. The result is a bit field, %vvhh, where %vv is
3749						; the outcode for the vertical axis and %hh the outcode for the
3750						; horizontal axis. Each outcode is %xn, where x is set if point above
3751						; maximum and n set if point below minimum. (Of course, %11 is then
3752						; not possible.)
3753						;
3754						; See https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm
3755						;
3756						; So the possible results, in binary, are:
3757						;
3758						; %1001 | %1000 | %1010
3759						; ------+-------+------
3760						; %0001 | %0000 | %0010
3761						; ------+-------+------
3762						; %0101 | %0100 | %0110
3763						;
3764	.d1a8					windEntryPoint:
3765	.d1a8	e8		inx		                inx
3766	.d1a9	e8		inx		                inx                          ;point to Y coordinate
3767	.d1aa	20 b5 d1	jsr $d1b5	                jsr getOutcodeForYAxis                    ;process Y coordinate
3768	.d1ad	ca		dex		                dex
3769	.d1ae	ca		dex		                dex                          ;point to X coordinate
3770	.d1af	0a		asl a		                asl a
3771	.d1b0	0a		asl a		                asl a                        ;shift Y outcode into bits 2/3
3772	.d1b1	a0 00		ldy #$00	                ldy #$00                     ;doing Y axis
3773	.d1b3	80 04		bra $d1b9	                bra updateOutcodeForAxis

3775						;-------------------------------------------------------------------------
3776						;
3777	.d1b5					getOutcodeForYAxis:
3778	.d1b5	a0 02		ldy #$02	                ldy #$02                     ;Y=2 for Y coordinate
3779						;-------------------------------------------------------------------------
3780						;
3781						; Get outcode for X or Y axis.
3782						;
3783						; entry:
3784						;
3785						; X = offset in VDU variables of coordinate
3786						;
3787						; Y = 0 if X axis, 2 if Y axis
3788						;
3789						; exit:
3790						;
3791						; ZTEMP?0 = outcode - 0, 1 or 2
3792						;
3793						; A = outcode
3794						;
3795						; N/Z set as per outcode
3796						;
3797	.d1b7					getOutcodeForAxis:
3798	.d1b7	a9 00		lda #$00	                lda #$00                     ;initialize result

3800						;-------------------------------------------------------------------------
3801						;
3802						; Update outcode for X or Y axis
3803						;
3804						; entry: as per getOutcodeForAxis
3805						;
3806						; exit:
3807						;
3808						; ZTEMP?0 = updated; outcode is added to its existing value
3809						;
3810	.d1b9					updateOutcodeForAxis:
3811	.d1b9	85 da		sta $da		                sta ZTEMP+0                  ;save current result
3812						                ; set flags for coordinate-minimum
3813	.d1bb	bd 00 03	lda $0300,x	                lda vduv+0,x
3814	.d1be	d9 00 03	cmp $0300,y	                cmp vduv.graphicsWindowPixelsLeft+0,y
3815	.d1c1	bd 01 03	lda $0301,x	                lda vduv+1,x
3816	.d1c4	f9 01 03	sbc $0301,y	                sbc vduv.graphicsWindowPixelsLeft+1,y
3817	.d1c7	30 10		bmi $d1d9	                bmi add1ToOutcode ;taken if point below minimum - outcode is 1

3819						                ; set flags for maximum-coordinate
3820	.d1c9	b9 04 03	lda $0304,y	                lda vduv.graphicsWindowPixelsRight+0,y
3821	.d1cc	dd 00 03	cmp $0300,x	                cmp vduv+0,x
3822	.d1cf	b9 05 03	lda $0305,y	                lda vduv.graphicsWindowPixelsRight+1,y
3823	.d1d2	fd 01 03	sbc $0301,x	                sbc vduv+1,x
3824	.d1d5	10 04		bpl $d1db	                bpl gotOutcode ;taken if point below maximum - axis outcode is 0
3825						                ; point is above maximum - axis outcode is 2
3826	.d1d7					add2ToOutcode:
3827	.d1d7	e6 da		inc $da		                inc ZTEMP+0
3828	.d1d9					add1ToOutcode:
3829	.d1d9	e6 da		inc $da		                inc ZTEMP+0
3830	.d1db					gotOutcode:
3831	.d1db	a5 da		lda $da		                lda ZTEMP+0
3832	.d1dd	60		rts		                rts

3834						;-------------------------------------------------------------------------
3835						;
3836						; EIGABS entry point.
3837						;
3838	.d1de					eigabsEntryPoint:
3839	.d1de	a9 ff		lda #$ff	                lda #$FF ;pretend it's PLOT 255 (as that would be absolute coordinates)
3840	.d1e0	80 03		bra $d1e5	                bra eigabsCommon

3842						;-------------------------------------------------------------------------
3843						;
3844						; EIGABS, but for a VDU 25. Handles relative/absolute addressing,
3845						; based on the PLOT number in the VDU queue.
3846						;
3847	.d1e2					eigabsForPLOT:
3848	.d1e2	ad 1f 03	lda $031f	                lda vduv.queueEnd-5          ;get PLOT number

3850						;-------------------------------------------------------------------------
3851						;
3852						; EIGABS shared code.
3853						;
3854	.d1e5					eigabsCommon:
3855	.d1e5	85 da		sta $da		                sta ZTEMP+0                  ;save PLOT number
3856	.d1e7	a0 02		ldy #$02	                ldy #$02                     ;process Y
3857	.d1e9	20 0b d2	jsr $d20b	                jsr handleExternalCoordinate
3858	.d1ec	20 42 d2	jsr $d242	                jsr divideCoordinatesBy2     ;divide Y by 4 - convert 0-1023 to 0-255
3859	.d1ef	a0 00		ldy #$00	                ldy #$00                     ;process X
3860	.d1f1	ca		dex		                dex                          ;...
3861	.d1f2	ca		dex		                dex                          ;...
3862	.d1f3	20 0b d2	jsr $d20b	                jsr handleExternalCoordinate
3863	.d1f6	ac 61 03	ldy $0361	                ldy vduv.pixelsPerByteMinusOne
3864	.d1f9	c0 03		cpy #$03	                cpy #$03  ;
3865	.d1fb	f0 05		beq $d202	                beq +     ;branch taken if mode 1/5 - divide by 4 or 8
3866	.d1fd	b0 06		bcs $d205	                bcs ++    ;branch taken if mode 0/4 - divide by 2 or 4
3867	.d1ff	20 42 d2	jsr $d242	                jsr divideCoordinatesBy2     ;mode 2 - divide by 8
3868	.d202					+
3869	.d202	20 42 d2	jsr $d242	                jsr divideCoordinatesBy2
3870	.d205					+
3871	.d205	ad 56 03	lda $0356	                lda vduv.currentScreenMODEGroup
3872	.d208	d0 38		bne $d242	                bne divideCoordinatesBy2     ;branch taken if MODE 4/5
3873	.d20a	60		rts		                rts

3875						;-------------------------------------------------------------------------
3876						;
3877						; Handle external coordinate.
3878						;
3879						; 1. Deal with absolute or relative PLOTting
3880						;
3881						; 2. Update graphics cursor position
3882						;
3883						; 3. Handle window origin
3884						;
3885						; 4. Update input coordinate
3886						;
3887						; 5. Divide result by 2 (as this always needs doing at least once)
3888						;
3889						; entry:
3890						;
3891						; ZTEMP?0 = PLOT number
3892						;
3893						; X = offset-2 of external coordinates
3894						;
3895						; Y = 0 to process X coordinate, 2 to process Y coordinate
3896						;
3897	.d20b					handleExternalCoordinate:
3898	.d20b	18		clc		                clc
3899	.d20c	a5 da		lda $da		                lda ZTEMP+0                  ;get PLOT number
3900	.d20e	29 04		and #$04	                and #$04                     ;get absolute/relative flag
3901	.d210	f0 09		beq $d21b	                beq relativePLOT             ;branch taken if relative
3902	.d212					absolutePLOT:
3903	.d212	bd 02 03	lda $0302,x	                lda vduv+2,x                 ;get coordinate LSB
3904	.d215	48		pha		                pha                          ;save coordinate LSB
3905	.d216	bd 03 03	lda $0303,x	                lda vduv+3,x                 ;get coordinate MSB
3906	.d219	80 0e		bra $d229	                bra LD229                    ;

3908	.d21b					relativePLOT:
3909	.d21b	bd 02 03	lda $0302,x	                lda vduv+2,x                 ;get coordinate LSB
3910	.d21e	79 10 03	adc $0310,y	                adc vduv.graphicsCursorPositionX+0,y ;add current position LSB
3911	.d221	48		pha		                pha                                  ;save coordinate LSB
3912	.d222	bd 03 03	lda $0303,x	                lda vduv+3,x                 ;get coordinate MSB
3913	.d225	79 11 03	adc $0311,y	                adc vduv.graphicsCursorPositionX+1,y ;add current position MSB
3914	.d228	18		clc		                clc
3915	.d229					LD229:
3916	.d229	99 11 03	sta $0311,y	                sta vduv.graphicsCursorPositionX+1,y ;update current position MSB
3917	.d22c	79 0d 03	adc $030d,y	                adc vduv.graphicsWindowOriginX+1,y   ;add window origin MSB
3918	.d22f	9d 03 03	sta $0303,x	                sta vduv+3,x                  ;update coordinate MSB
3919	.d232	68		pla		                pla                          ;restore coordinate LSB
3920	.d233	99 10 03	sta $0310,y	                sta vduv.graphicsCursorPositionX+0,y ;update current position LSB
3921	.d236	18		clc		                clc
3922	.d237	79 0c 03	adc $030c,y	                adc vduv.graphicsWindowOriginX+0,y ;add window origin LSB
3923	.d23a	9d 02 03	sta $0302,x	                sta vduv+2,x                       ;update coordinate LSB
3924	.d23d	90 03		bcc $d242	                bcc +
3925	.d23f	fe 03 03	inc $0303,x	                inc vduv+3,x       ;handle carry, ignored earlier
3926	.d242					+

3928	.d242					divideCoordinatesBy2:
3929	.d242	bd 03 03	lda $0303,x	                lda vduv+3,x
3930	.d245	0a		asl a		                asl a                        ;C=bit 7
3931	.d246	7e 03 03	ror $0303,x	                ror vduv+3,x                  ;signed divide by 2
3932	.d249	7e 02 03	ror $0302,x	                ror vduv+2,x                  ;signed divide by 2
3933	.d24c	60		rts		                rts

3935						;-------------------------------------------------------------------------

3937	.d24d					LD24D:
3938	.d24d	da		phx		                phx
3939	.d24e	5a		phy		                phy
3940	.d24f	5a		phy		                phy
3941	.d250	da		phx		                phx
3942	.d251	5a		phy		                phy
3943	.d252	20 80 d2	jsr $d280	                jsr LD280
3944	.d255	fa		plx		                plx
3945	.d256	20 80 d2	jsr $d280	                jsr LD280
3946	.d259	fa		plx		                plx
3947	.d25a	7a		ply		                ply
3948	.d25b	20 e8 da	jsr $dae8	                jsr LDAE8
3949	.d25e	fa		plx		                plx
3950	.d25f	20 68 d2	jsr $d268	                jsr LD268
3951	.d262	fa		plx		                plx
3952	.d263	80 03		bra $d268	                bra LD268

3954	.d265					LD265:
3955	.d265	20 a9 9b	jsr $9ba9	                jsr L9B09
3956	.d268					LD268:
3957	.d268	a0 00		ldy #$00	                ldy #$00
3958	.d26a	20 70 d2	jsr $d270	                jsr LD270
3959	.d26d	e8		inx		                inx
3960	.d26e	a0 02		ldy #$02	                ldy #$02
3961	.d270					LD270:
3962	.d270	38		sec		                sec
3963	.d271	20 76 d2	jsr $d276	                jsr LD276
3964	.d274	e8		inx		                inx
3965	.d275	c8		iny		                iny
3966	.d276					LD276:
3967	.d276	bd 00 03	lda $0300,x	                lda $0300,x
3968	.d279	f9 14 03	sbc $0314,y	                sbc $0314,y
3969	.d27c	9d 00 03	sta $0300,x	                sta $0300,x
3970	.d27f					LD27F:
3971	.d27f	60		rts		                rts

3973	.d280					LD280:
3974	.d280	a0 00		ldy #$00	                ldy #$00
3975	.d282	20 88 d2	jsr $d288	                jsr LD288
3976	.d285	e8		inx		                inx
3977	.d286	a0 02		ldy #$02	                ldy #$02
3978	.d288					LD288:
3979	.d288	18		clc		                clc
3980	.d289	20 8e d2	jsr $d28e	                jsr LD28E
3981	.d28c	e8		inx		                inx
3982	.d28d	c8		iny		                iny
3983	.d28e					LD28E:
3984	.d28e	bd 00 03	lda $0300,x	                lda $0300,x
3985	.d291	79 14 03	adc $0314,y	                adc $0314,y
3986	.d294	9d 00 03	sta $0300,x	                sta $0300,x
3987	.d297	60		rts		                rts

3989	.d298					LD298:
3990	.d298	85 e1		sta $e1		                sta $E1
3991	.d29a	20 25 d4	jsr $d425	                jsr LD425
3992	.d29d	f0 e0		beq $d27f	                beq LD27F
3993	.d29f	a0 14		ldy #$14	                ldy #$14
3994	.d2a1	a9 20		lda #$20	                lda #$20
3995	.d2a3	a2 2c		ldx #$2c	                ldx #$2C
3996	.d2a5	20 65 d2	jsr $d265	                jsr LD265
3997	.d2a8	20 aa d3	jsr $d3aa	                jsr LD3AA
3998	.d2ab	a9 01		lda #$01	                lda #$01
3999	.d2ad					LD2AD:
4000	.d2ad	84 e0		sty $e0		                sty $E0
4001	.d2af	04 e0		tsb $e0		                tsb $E0
4002	.d2b1	a2 2c		ldx #$2c	                ldx #VDUVariables.workspace._2C
4003	.d2b3	a0 28		ldy #$28	                ldy #VDUVariables.workspace._28
4004	.d2b5	20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
4005	.d2b8	2c 35 03	bit $0335	                bit $0335
4006	.d2bb	08		php		                php
4007	.d2bc	a2 2c		ldx #$2c	                ldx #$2C
4008	.d2be	20 26 d7	jsr $d726	                jsr LD726
4009	.d2c1	28		plp		                plp
4010	.d2c2	10 03		bpl $d2c7	                bpl LD2C7
4011	.d2c4	20 aa d3	jsr $d3aa	                jsr LD3AA
4012	.d2c7					LD2C7:
4013	.d2c7	ac 2c 03	ldy $032c	                ldy $032C
4014	.d2ca	ad 2d 03	lda $032d	                lda $032D
4015	.d2cd	30 03		bmi $d2d2	                bmi LD2D2
4016	.d2cf	20 2e c9	jsr $c92e	                jsr negateAY
4017	.d2d2					LD2D2:
4018	.d2d2	48		pha		                pha
4019	.d2d3	18		clc		                clc
4020	.d2d4	98		tya		                tya
4021	.d2d5	6d 30 88	adc $8830	                adc L8830
4022	.d2d8	a8		tay		                tay
4023	.d2d9	68		pla		                pla
4024	.d2da	6d 31 88	adc $8831	                adc L8831
4025	.d2dd	10 ce		bpl $d2ad	                bpl LD2AD
4026	.d2df	1a		inc a		                inc a
4027	.d2e0	d0 23		bne $d305	                bne LD305
4028	.d2e2	c8		iny		                iny
4029	.d2e3	d0 20		bne $d305	                bne LD305
4030	.d2e5	a5 e0		lda $e0		                lda $E0
4031	.d2e7	f0 1c		beq $d305	                beq LD305
4032	.d2e9	ad 2c 03	lda $032c	                lda $032C
4033	.d2ec	cd 28 03	cmp $0328	                cmp $0328
4034	.d2ef	f0 14		beq $d305	                beq LD305
4035	.d2f1	a2 2c		ldx #$2c	                ldx #$2C
4036	.d2f3	a0 28		ldy #$28	                ldy #$28
4037	.d2f5	ad 36 03	lda $0336	                lda $0336
4038	.d2f8	0a		asl a		                asl a
4039	.d2f9	4d 36 03	eor $0336	                eor $0336
4040	.d2fc	10 04		bpl $d302	                bpl LD302
4041	.d2fe	e8		inx		                inx
4042	.d2ff	e8		inx		                inx
4043	.d300	c8		iny		                iny
4044	.d301	c8		iny		                iny
4045	.d302					LD302:
4046	.d302	20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
4047	.d305					LD305:
4048	.d305	20 25 d4	jsr $d425	                jsr LD425
4049	.d308	ad 29 03	lda $0329	                lda $0329
4050	.d30b	aa		tax		                tax
4051	.d30c	4d 1c 03	eor $031c	                eor $031C
4052	.d30f	30 18		bmi $d329	                bmi LD329
4053	.d311	a0 02		ldy #$02	                ldy #$02
4054	.d313	20 6f d4	jsr $d46f	                jsr LD46F
4055	.d316	d0 0c		bne $d324	                bne LD324
4056	.d318	ae 2b 03	ldx $032b	                ldx $032B
4057	.d31b	a0 00		ldy #$00	                ldy #$00
4058	.d31d	20 6f d4	jsr $d46f	                jsr LD46F
4059	.d320	f0 11		beq $d333	                beq LD333
4060	.d322	49 80		eor #$80	                eor #$80
4061	.d324					LD324:
4062	.d324	86 da		stx $da		                stx $DA
4063	.d326	45 da		eor $da		                eor $DA
4064	.d328	aa		tax		                tax
4065	.d329					LD329:
4066	.d329	8a		txa		                txa
4067	.d32a	29 80		and #$80	                and #$80
4068	.d32c	f0 02		beq $d330	                beq LD330
4069	.d32e	a9 c0		lda #$c0	                lda #$C0
4070	.d330					LD330:
4071	.d330	04 e1		tsb $e1		                tsb $E1
4072	.d332	18		clc		                clc
4073	.d333					LD333:
4074	.d333	60		rts		                rts

4076	.d334					LD334:
4077	.d334	a5 e1		lda $e1		                lda $E1
4078	.d336	8d 48 88	sta $8848	                sta L8848
4079	.d339	89 03		bit #$03	                bit #$03
4080	.d33b	f0 f6		beq $d333	                beq LD333
4081	.d33d	a9 10		lda #$10	                lda #$10
4082	.d33f	85 dc		sta $dc		                sta $DC
4083	.d341	0a		asl a		                asl a
4084	.d342	85 dd		sta $dd		                sta $DD
4085	.d344	a2 1b		ldx #$1b	                ldx #$1B
4086	.d346	20 4f d3	jsr $d34f	                jsr LD34F
4087	.d349	06 dc		asl $dc		                asl $DC
4088	.d34b	46 dd		lsr $dd		                lsr $DD
4089	.d34d	a2 28		ldx #$28	                ldx #$28
4090	.d34f					LD34F:
4091	.d34f	a9 80		lda #$80	                lda #$80
4092	.d351	85 da		sta $da		                sta $DA
4093	.d353	bd 02 03	lda $0302,x	                lda $0302,x
4094	.d356	cd 32 88	cmp $8832	                cmp L8832
4095	.d359	d0 d8		bne $d333	                bne LD333
4096	.d35b	bd 03 03	lda $0303,x	                lda $0303,x
4097	.d35e	cd 33 88	cmp $8833	                cmp L8833
4098	.d361	d0 d0		bne $d333	                bne LD333
4099	.d363	bc 00 03	ldy $0300,x	                ldy $0300,x
4100	.d366	bd 01 03	lda $0301,x	                lda $0301,x
4101	.d369	10 05		bpl $d370	                bpl LD370
4102	.d36b	46 da		lsr $da		                lsr $DA
4103	.d36d	20 2e c9	jsr $c92e	                jsr negateAY
4104	.d370					LD370:
4105	.d370	cc 30 88	cpy $8830	                cpy L8830
4106	.d373	d0 be		bne $d333	                bne LD333
4107	.d375	cd 31 88	cmp $8831	                cmp L8831
4108	.d378	d0 b9		bne $d333	                bne LD333
4109	.d37a	a5 e1		lda $e1		                lda $E1
4110	.d37c	89 02		bit #$02	                bit #$02
4111	.d37e	f0 19		beq $d399	                beq LD399
4112	.d380	a0 30		ldy #$30	                ldy #$30
4113	.d382	89 01		bit #$01	                bit #$01
4114	.d384	f0 02		beq $d388	                beq LD388
4115	.d386	a4 dc		ldy $dc		                ldy $DC
4116	.d388					LD388:
4117	.d388	98		tya		                tya
4118	.d389	4a		lsr a		                lsr a
4119	.d38a	4a		lsr a		                lsr a
4120	.d38b	24 e1		bit $e1		                bit $E1
4121	.d38d	d0 06		bne $d395	                bne LD395
4122	.d38f	05 dc		ora $dc		                ora $DC
4123	.d391	04 e1		tsb $e1		                tsb $E1
4124	.d393	80 04		bra $d399	                bra LD399

4126	.d395					LD395:
4127	.d395	05 dd		ora $dd		                ora $DD
4128	.d397	14 e1		trb $e1		                trb $E1
4129	.d399					LD399:
4130	.d399	a5 da		lda $da		                lda $DA
4131	.d39b	24 e1		bit $e1		                bit $E1
4132	.d39d	f0 91		beq $d330	                beq LD330
4133	.d39f	14 e1		trb $e1		                trb $E1
4134	.d3a1	a5 e1		lda $e1		                lda $E1
4135	.d3a3	8d 48 88	sta $8848	                sta L8848
4136	.d3a6	8d 49 88	sta $8849	                sta L8849
4137	.d3a9	60		rts		                rts

4139	.d3aa					LD3AA:
4140	.d3aa	ad 2e 03	lda $032e	                lda $032E
4141	.d3ad	8d 32 88	sta $8832	                sta L8832
4142	.d3b0	ad 2f 03	lda $032f	                lda $032F
4143	.d3b3	8d 33 88	sta $8833	                sta L8833
4144	.d3b6	20 fc d3	jsr $d3fc	                jsr LD3FC
4145	.d3b9	20 13 d5	jsr $d513	                jsr LD513
4146	.d3bc	8c 30 88	sty $8830	                sty L8830
4147	.d3bf	ad 46 88	lda $8846	                lda L8846
4148	.d3c2	4a		lsr a		                lsr a
4149	.d3c3	ad 3d 88	lda $883d	                lda L883D
4150	.d3c6	90 06		bcc $d3ce	                bcc LD3CE
4151	.d3c8	c9 80		cmp #$80	                cmp #$80
4152	.d3ca	6a		ror a		                ror a
4153	.d3cb	6e 30 88	ror $8830	                ror L8830
4154	.d3ce					LD3CE:
4155	.d3ce	8d 31 88	sta $8831	                sta L8831
4156	.d3d1	60		rts		                rts

4158	.d3d2					LD3D2:
4159	.d3d2	9c 47 88	stz $8847	                stz L8847
4160	.d3d5	9c 30 88	stz $8830	                stz L8830
4161	.d3d8	9c 31 88	stz $8831	                stz L8831
4162	.d3db	9c 34 88	stz $8834	                stz L8834
4163	.d3de	9c 35 88	stz $8835	                stz L8835
4164	.d3e1	ad 32 88	lda $8832	                lda L8832
4165	.d3e4	0a		asl a		                asl a
4166	.d3e5	8d 36 88	sta $8836	                sta L8836
4167	.d3e8	ad 33 88	lda $8833	                lda L8833
4168	.d3eb	2a		rol a		                rol a
4169	.d3ec	8d 37 88	sta $8837	                sta L8837
4170	.d3ef	ad 46 88	lda $8846	                lda L8846
4171	.d3f2	89 02		bit #$02	                bit #$02
4172	.d3f4	f0 06		beq $d3fc	                beq LD3FC
4173	.d3f6	0e 36 88	asl $8836	                asl L8836
4174	.d3f9	2e 37 88	rol $8837	                rol L8837
4175	.d3fc					LD3FC:
4176	.d3fc	ad 46 88	lda $8846	                lda L8846
4177	.d3ff	4a		lsr a		                lsr a
4178	.d400	4a		lsr a		                lsr a
4179	.d401	ac 32 88	ldy $8832	                ldy L8832
4180	.d404	ad 33 88	lda $8833	                lda L8833
4181	.d407	20 c5 d4	jsr $d4c5	                jsr LD4C5
4182	.d40a	38		sec		                sec
4183	.d40b	a2 fc		ldx #$fc	                ldx #$FC
4184	.d40d					LD40D:
4185	.d40d	bd 3c 87	lda $873c,x	                lda L873C,x
4186	.d410	fd 44 87	sbc $8744,x	                sbc L8744,x
4187	.d413	9d 44 87	sta $8744,x	                sta L8744,x
4188	.d416	e8		inx		                inx
4189	.d417	d0 f4		bne $d40d	                bne LD40D
4190	.d419	60		rts		                rts

4192	.d41a					LD41A:
4193	.d41a	20 1a c9	jsr $c91a	                jsr copyGraphicsCursorPixelsToOldGraphicsCursorPixels
4194	.d41d	64 e1		stz $e1		                stz $E1
4195	.d41f	a2 20		ldx #$20	                ldx #$20
4196	.d421	20 27 d4	jsr $d427	                jsr LD427
4197	.d424	60		rts		                rts

4199	.d425					LD425:
4200	.d425	a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX
4201	.d427					LD427:
4202	.d427	a0 1b		ldy #$1b	                ldy #VDUVariables.queueEnd-9
4203	.d429	20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
4204	.d42c	a2 1b		ldx #$1b	                ldx #$1B
4205	.d42e	20 68 d2	jsr $d268	                jsr LD268
4206	.d431	20 86 d4	jsr $d486	                jsr LD486
4207	.d434	20 13 d5	jsr $d513	                jsr LD513
4208	.d437	a0 0c		ldy #$0c	                ldy #$0C
4209	.d439	20 ab d4	jsr $d4ab	                jsr LD4AB
4210	.d43c	20 13 d5	jsr $d513	                jsr LD513
4211	.d43f	c9 20		cmp #$20	                cmp #$20
4212	.d441	90 05		bcc $d448	                bcc LD448
4213	.d443	68		pla		                pla
4214	.d444	68		pla		                pla
4215	.d445	68		pla		                pla
4216	.d446	68		pla		                pla
4217	.d447	60		rts		                rts

4219	.d448					LD448:
4220	.d448	8c 44 88	sty $8844	                sty L8844
4221	.d44b	8d 45 88	sta $8845	                sta L8845
4222	.d44e	ad 46 88	lda $8846	                lda L8846
4223	.d451	89 02		bit #$02	                bit #$02
4224	.d453	f0 06		beq $d45b	                beq LD45B
4225	.d455	4e 45 88	lsr $8845	                lsr L8845
4226	.d458	6e 44 88	ror $8844	                ror L8844
4227	.d45b					LD45B:
4228	.d45b	ac 44 88	ldy $8844	                ldy L8844
4229	.d45e	ad 45 88	lda $8845	                lda L8845
4230	.d461	20 2e c9	jsr $c92e	                jsr negateAY
4231	.d464	8c 32 88	sty $8832	                sty L8832
4232	.d467	8d 33 88	sta $8833	                sta L8833
4233	.d46a	0d 32 88	ora $8832	                ora L8832
4234	.d46d	38		sec		                sec
4235	.d46e	60		rts		                rts

4237	.d46f					LD46F:
4238	.d46f	64 da		stz $da		                stz $DA
4239	.d471	b9 1b 03	lda $031b,y	                lda $031B,y
4240	.d474	d9 28 03	cmp $0328,y	                cmp $0328,y
4241	.d477	f0 02		beq $d47b	                beq LD47B
4242	.d479	e6 da		inc $da		                inc $DA
4243	.d47b					LD47B:
4244	.d47b	b9 1c 03	lda $031c,y	                lda $031C,y
4245	.d47e	f9 29 03	sbc $0329,y	                sbc $0329,y
4246	.d481	d0 02		bne $d485	                bne LD485
4247	.d483	a5 da		lda $da		                lda $DA
4248	.d485					LD485:
4249	.d485	60		rts		                rts

4251	.d486					LD486:
4252	.d486	ae 55 03	ldx $0355	                ldx $0355
4253	.d489	bd bf d4	lda $d4bf,x	                lda LD4BF,x
4254	.d48c	8d 46 88	sta $8846	                sta L8846
4255	.d48f	4a		lsr a		                lsr a
4256	.d490	48		pha		                pha
4257	.d491	a2 04		ldx #$04	                ldx #$04
4258	.d493					LD493:
4259	.d493	9e 37 88	stz $8837,x	                stz L8837,x
4260	.d496	ca		dex		                dex
4261	.d497	d0 fa		bne $d493	                bne LD493
4262	.d499	20 a0 d4	jsr $d4a0	                jsr LD4A0
4263	.d49c	68		pla		                pla
4264	.d49d	4a		lsr a		                lsr a
4265	.d49e	a2 02		ldx #$02	                ldx #$02
4266	.d4a0					LD4A0:
4267	.d4a0	bc 1b 03	ldy $031b,x	                ldy $031B,x
4268	.d4a3	bd 1c 03	lda $031c,x	                lda $031C,x
4269	.d4a6	20 c5 d4	jsr $d4c5	                jsr LD4C5
4270	.d4a9	a0 10		ldy #$10	                ldy #$10
4271	.d4ab					LD4AB:
4272	.d4ab	18		clc		                clc
4273	.d4ac	a2 fc		ldx #$fc	                ldx #$FC
4274	.d4ae					LD4AE:
4275	.d4ae	bd 3c 87	lda $873c,x	                lda L873C,x
4276	.d4b1	79 30 88	adc $8830,y	                adc L8830,y
4277	.d4b4	9d 3c 87	sta $873c,x	                sta L873C,x
4278	.d4b7	9d 44 87	sta $8744,x	                sta L8744,x
4279	.d4ba	c8		iny		                iny
4280	.d4bb	e8		inx		                inx
4281	.d4bc	d0 f0		bne $d4ae	                bne LD4AE
4282	.d4be	60		rts		                rts

4284	.d4bf					LD4BF:
4285	>d4bf	02				                .byte $02
4286	.d4c0	00		brk #		                brk
4287	.d4c1	01 ff		ora ($ff,x)	                ora ($FF,x)
4288	.d4c3	00		brk #		                brk
4289						;ORA (&8C,x)      :\ D4C4= 01       ..
4290	>d4c4	01				                .byte $01
4291	.d4c5					LD4C5:
4292	.d4c5	8c 3c 88	sty $883c	                sty L883C
4293	.d4c8	90 04		bcc $d4ce	                bcc LD4CE
4294	.d4ca	0e 3c 88	asl $883c	                asl L883C
4295	.d4cd	2a		rol a		                rol a
4296	.d4ce					LD4CE:
4297	.d4ce	8d 3d 88	sta $883d	                sta L883D
4298	.d4d1	ac 3c 88	ldy $883c	                ldy L883C
4299	.d4d4	aa		tax		                tax
4300	.d4d5	10 03		bpl $d4da	                bpl LD4DA
4301	.d4d7	20 2e c9	jsr $c92e	                jsr negateAY
4302	.d4da					LD4DA:
4303	.d4da	8c 3c 88	sty $883c	                sty L883C
4304	.d4dd	8d 3d 88	sta $883d	                sta L883D
4305	.d4e0	8c 40 88	sty $8840	                sty L8840
4306	.d4e3	9c 42 88	stz $8842	                stz L8842
4307	.d4e6	9c 43 88	stz $8843	                stz L8843
4308	.d4e9	a0 0f		ldy #$0f	                ldy #$0F
4309	.d4eb	4a		lsr a		                lsr a
4310	.d4ec	8d 41 88	sta $8841	                sta L8841
4311	.d4ef	6e 40 88	ror $8840	                ror L8840
4312	.d4f2					LD4F2:
4313	.d4f2	90 13		bcc $d507	                bcc LD507
4314	.d4f4	18		clc		                clc
4315	.d4f5	ad 3c 88	lda $883c	                lda L883C
4316	.d4f8	6d 42 88	adc $8842	                adc L8842
4317	.d4fb	8d 42 88	sta $8842	                sta L8842
4318	.d4fe	ad 3d 88	lda $883d	                lda L883D
4319	.d501	6d 43 88	adc $8843	                adc L8843
4320	.d504	8d 43 88	sta $8843	                sta L8843
4321	.d507					LD507:
4322	.d507	a2 03		ldx #$03	                ldx #$03
4323	.d509					LD509:
4324	.d509	7e 40 88	ror $8840,x	                ror L8840,x
4325	.d50c	ca		dex		                dex
4326	.d50d	10 fa		bpl $d509	                bpl LD509
4327	.d50f	88		dey		                dey
4328	.d510	10 e0		bpl $d4f2	                bpl LD4F2
4329	.d512	60		rts		                rts

4331	.d513					LD513:
4332	.d513	a2 02		ldx #$02	                ldx #$02
4333	.d515					LD515:
4334	.d515	9e 3c 88	stz $883c,x	                stz L883C,x
4335	.d518	74 db		stz $db,x	                stz $DB,x
4336	.d51a	ca		dex		                dex
4337	.d51b	10 f8		bpl $d515	                bpl LD515
4338	.d51d	a0 03		ldy #$03	                ldy #$03
4339	.d51f					LD51F:
4340	.d51f	b9 40 88	lda $8840,y	                lda L8840,y
4341	.d522	85 da		sta $da		                sta $DA
4342	.d524	5a		phy		                phy
4343	.d525	a0 03		ldy #$03	                ldy #$03
4344	.d527					LD527:
4345	.d527	5a		phy		                phy
4346	.d528	38		sec		                sec
4347	.d529	2e 3c 88	rol $883c	                rol L883C
4348	.d52c	2e 3d 88	rol $883d	                rol L883D
4349	.d52f	2e 3e 88	rol $883e	                rol L883E
4350	.d532	a2 01		ldx #$01	                ldx #$01
4351	.d534	a5 db		lda $db		                lda $DB
4352	.d536					LD536:
4353	.d536	06 da		asl $da		                asl $DA
4354	.d538	2a		rol a		                rol a
4355	.d539	26 dc		rol $dc		                rol $DC
4356	.d53b	26 dd		rol $dd		                rol $DD
4357	.d53d	ca		dex		                dex
4358	.d53e	10 f6		bpl $d536	                bpl LD536
4359	.d540	85 db		sta $db		                sta $DB
4360	.d542	38		sec		                sec
4361	.d543	ed 3c 88	sbc $883c	                sbc L883C
4362	.d546	aa		tax		                tax
4363	.d547	a5 dc		lda $dc		                lda $DC
4364	.d549	ed 3d 88	sbc $883d	                sbc L883D
4365	.d54c	a8		tay		                tay
4366	.d54d	a5 dd		lda $dd		                lda $DD
4367	.d54f	ed 3e 88	sbc $883e	                sbc L883E
4368	.d552	90 0b		bcc $d55f	                bcc LD55F
4369	.d554	85 dd		sta $dd		                sta $DD
4370	.d556	84 dc		sty $dc		                sty $DC
4371	.d558	86 db		stx $db		                stx $DB
4372	.d55a	ee 3c 88	inc $883c	                inc L883C
4373	.d55d	80 03		bra $d562	                bra LD562

4375	.d55f					LD55F:
4376	.d55f	ce 3c 88	dec $883c	                dec L883C
4377	.d562					LD562:
4378	.d562	7a		ply		                ply
4379	.d563	88		dey		                dey
4380	.d564	10 c1		bpl $d527	                bpl LD527
4381	.d566	7a		ply		                ply
4382	.d567	88		dey		                dey
4383	.d568	10 b5		bpl $d51f	                bpl LD51F
4384	.d56a	4e 3e 88	lsr $883e	                lsr L883E
4385	.d56d	6e 3d 88	ror $883d	                ror L883D
4386	.d570	6e 3c 88	ror $883c	                ror L883C
4387	.d573	9c 3e 88	stz $883e	                stz L883E
4388	.d576	9c 3f 88	stz $883f	                stz L883F
4389	.d579	ac 3c 88	ldy $883c	                ldy L883C
4390	.d57c	ad 3d 88	lda $883d	                lda L883D
4391	.d57f	60		rts		                rts

4393						;-------------------------------------------------------------------------
4394						;
4395						; Add dimension of region to a coordinate.
4396						;
4397						; entry:
4398						;
4399						; X = VDU variable offset of coordinate
4400						;
4401						; A = VDU variable offset of minimum coordinate of region
4402						;
4403						; Y = VDU variable offset of maximum coordinate of region
4404						;
4405						; ZTEMP?0 = VDU variable offset for result
4406						;
4407						; exit:
4408						;
4409						; result variable = coordinate+(min-max)
4410						;
4411	.d580					addRegionDimensionsToVDUVariableCoordinates:
4412	.d580	20 8d d5	jsr $d58d	                jsr addRegionDimensionToVDUVariableCoordinate ;do X

4414						                ; bump offsets to do Y.
4415	.d583	c8		iny		                iny
4416	.d584	c8		iny		                iny
4417	.d585	e8		inx		                inx
4418	.d586	e8		inx		                inx
4419	.d587	1a		inc a		                inc a
4420	.d588	1a		inc a		                inc a
4421	.d589	e6 da		inc $da		                inc ZTEMP+0
4422	.d58b	e6 da		inc $da		                inc ZTEMP+0

4424						                ; TODO - not a great name. Could probably just be
4425						                ; addDifference, or something.
4426	.d58d					addRegionDimensionToVDUVariableCoordinate:
4427	.d58d	da		phx		                phx                          ;save VX
4428	.d58e	5a		phy		                phy                          ;save VY
4429	.d58f	48		pha		                pha                          ;save VA
4430	.d590	18		clc		                clc
4431	.d591	bd 00 03	lda $0300,x	                lda vduv+0,x                 ;<VX
4432	.d594	79 00 03	adc $0300,y	                adc vduv+0,y                 ;<(VX+VY)
4433	.d597	85 de		sta $de		                sta ZTEMPC+0                 ;ZTEMPC?0=<(VX+VY)
4434	.d599	bd 01 03	lda $0301,x	                lda vduv+1,x                 ;>VX
4435	.d59c	79 01 03	adc $0301,y	                adc vduv+1,y                 ;>(VX+VY)
4436	.d59f	fa		plx		                plx                          ;X=VA
4437	.d5a0	48		pha		                pha                          ;save >(VX+VY)
4438	.d5a1	a4 da		ldy $da		                ldy ZTEMP+0                  ;Y=VT
4439	.d5a3	38		sec		                sec
4440	.d5a4	a5 de		lda $de		                lda ZTEMPC+0                 ;<(VX+VY)
4441	.d5a6	fd 00 03	sbc $0300,x	                sbc vduv+0,x                 ;<(VX+VY-VA)
4442	.d5a9	99 00 03	sta $0300,y	                sta vduv+0,y                 ;<VT=<(VX+VY-VA)
4443	.d5ac	68		pla		                pla                          ;>(VX+VY)
4444	.d5ad	fd 01 03	sbc $0301,x	                sbc vduv+1,x                 ;>(VX+VY-VA)
4445	.d5b0	99 01 03	sta $0301,y	                sta vduv+1,y                 ;>VT=<(VX+VY-VA)
4446	.d5b3	8a		txa		                txa                          ;restore old A
4447	.d5b4	7a		ply		                ply                          ;restore old Y
4448	.d5b5	fa		plx		                plx                          ;restore old X
4449	.d5b6	60		rts		                rts

4451						;-------------------------------------------------------------------------
4452						;
4453						; Sort points by Y coordinate, then X.
4454						;
4455						; entry:
4456						;
4457						; X = VDU variable offset of point A (4 bytes: X;Y;)
4458						;
4459						; Y = VDU variable offset of point B (4 bytes: X;Y;)
4460						;
4461						; exit:
4462						;
4463						; X = offset of point with lesser Y (or lesser X, if same Y)
4464						;
4465						; Y = offset of point with greater Y (or greater X, if same Y)
4466						;
4467	.d5b7					sortVDUVariableCoordinates:
4468	.d5b7	38		sec		                sec
4469	.d5b8	b9 02 03	lda $0302,y	                lda vduv+2,y
4470	.d5bb	fd 02 03	sbc $0302,x	                sbc vduv+2,x
4471	.d5be	85 de		sta $de		                sta ZTEMPC
4472	.d5c0	b9 03 03	lda $0303,y	                lda vduv+3,y
4473	.d5c3	fd 03 03	sbc $0303,x	                sbc vduv+3,x
4474	.d5c6	30 09		bmi $d5d1	                bmi exchangeXAndY           ;taken if PX.y>PY.y
4475	.d5c8	05 de		ora $de		                ora ZTEMPC
4476	.d5ca	d0 09		bne $d5d5	                bne rtsD5D5                  ;taken if PX.y<PY.y

4478						;-------------------------------------------------------------------------
4479						;
4480						; Sort words by value.
4481						;
4482						; entry:
4483						;
4484						; X = VDU variable offset of word A
4485						;
4486						; Y = VDU variable offset of word B
4487						;
4488						; exit:
4489						;
4490						; X = offset of lesser value
4491						;
4492						; Y = offset of greater value
4493						;
4494	.d5cc					sortVDUVariableWords:
4495	.d5cc	20 d6 d5	jsr $d5d6	                jsr compareVDUVariableWords
4496	.d5cf	10 04		bpl $d5d5	                bpl rtsD5D5
4497	.d5d1					exchangeXAndY:
4498	.d5d1	8a		txa		                txa
4499	.d5d2	5a		phy		                phy
4500	.d5d3	fa		plx		                plx
4501	.d5d4	a8		tay		                tay
4502	.d5d5					rtsD5D5:
4503	.d5d5	60		rts		                rts

4505						;-------------------------------------------------------------------------
4506						;
4507						; Compare 2 16-bit VDU variable values.
4508						;
4509						; entry:
4510						;
4511						; X = offset of one variable
4512						;
4513						; Y = offset of the other variable
4514						;
4515						; exit:
4516						;
4517						; N=1 if X>Y
4518						;
4519	.d5d6					compareVDUVariableWords:
4520	.d5d6	b9 00 03	lda $0300,y	                lda vduv+0,y
4521	.d5d9	dd 00 03	cmp $0300,x	                cmp vduv+0,x
4522	.d5dc	b9 01 03	lda $0301,y	                lda vduv+1,y
4523	.d5df	fd 01 03	sbc $0301,x	                sbc vduv+1,x
4524	.d5e2	60		rts		                rts

4526						;-------------------------------------------------------------------------

4528	.d5e3					LD5E3:
4529	.d5e3	ee 47 88	inc $8847	                inc L8847
4530	.d5e6					LD5E6:
4531	.d5e6	ad 47 88	lda $8847	                lda L8847
4532	.d5e9	d0 0f		bne $d5fa	                bne LD5FA
4533	.d5eb	ad 32 88	lda $8832	                lda L8832
4534	.d5ee	0d 33 88	ora $8833	                ora L8833
4535	.d5f1	f0 f0		beq $d5e3	                beq LD5E3
4536	.d5f3	a2 00		ldx #$00	                ldx #$00
4537	.d5f5	20 44 d6	jsr $d644	                jsr LD644
4538	.d5f8	10 49		bpl $d643	                bpl LD643
4539	.d5fa					LD5FA:
4540	.d5fa	a2 02		ldx #$02	                ldx #$02
4541	.d5fc	20 44 d6	jsr $d644	                jsr LD644
4542	.d5ff	10 42		bpl $d643	                bpl LD643
4543	.d601	a2 00		ldx #$00	                ldx #$00
4544	.d603	20 0a d6	jsr $d60a	                jsr LD60A
4545	.d606	10 3b		bpl $d643	                bpl LD643
4546	.d608	a2 02		ldx #$02	                ldx #$02
4547	.d60a					LD60A:
4548	.d60a	bd 30 88	lda $8830,x	                lda L8830,x
4549	.d60d	d0 03		bne $d612	                bne LD612
4550	.d60f	de 31 88	dec $8831,x	                dec L8831,x
4551	.d612					LD612:
4552	.d612	de 30 88	dec $8830,x	                dec L8830,x
4553	.d615	8a		txa		                txa
4554	.d616	4a		lsr a		                lsr a
4555	.d617	1a		inc a		                inc a
4556	.d618	2c 46 88	bit $8846	                bit L8846
4557	.d61b	f0 03		beq $d620	                beq LD620
4558	.d61d	20 20 d6	jsr $d620	                jsr LD620
4559	.d620					LD620:
4560	.d620	20 36 d6	jsr $d636	                jsr LD636
4561	.d623	18		clc		                clc
4562	.d624	ad 40 88	lda $8840	                lda L8840
4563	.d627	7d 34 88	adc $8834,x	                adc L8834,x
4564	.d62a	8d 40 88	sta $8840	                sta L8840
4565	.d62d	ad 41 88	lda $8841	                lda L8841
4566	.d630	7d 35 88	adc $8835,x	                adc L8835,x
4567	.d633	8d 41 88	sta $8841	                sta L8841
4568	.d636					LD636:
4569	.d636	08		php		                php
4570	.d637	bd 34 88	lda $8834,x	                lda L8834,x
4571	.d63a	d0 03		bne $d63f	                bne LD63F
4572	.d63c	de 35 88	dec $8835,x	                dec L8835,x
4573	.d63f					LD63F:
4574	.d63f	de 34 88	dec $8834,x	                dec L8834,x
4575	.d642	28		plp		                plp
4576	.d643					LD643:
4577	.d643	60		rts		                rts

4579	.d644					LD644:
4580	.d644	fe 30 88	inc $8830,x	                inc L8830,x
4581	.d647	d0 03		bne $d64c	                bne LD64C
4582	.d649	fe 31 88	inc $8831,x	                inc L8831,x
4583	.d64c					LD64C:
4584	.d64c	8a		txa		                txa
4585	.d64d	4a		lsr a		                lsr a
4586	.d64e	1a		inc a		                inc a
4587	.d64f	2c 46 88	bit $8846	                bit L8846
4588	.d652	f0 03		beq $d657	                beq LD657
4589	.d654	20 57 d6	jsr $d657	                jsr LD657
4590	.d657					LD657:
4591	.d657	20 6d d6	jsr $d66d	                jsr LD66D
4592	.d65a	38		sec		                sec
4593	.d65b	ad 40 88	lda $8840	                lda L8840
4594	.d65e	fd 34 88	sbc $8834,x	                sbc L8834,x
4595	.d661	8d 40 88	sta $8840	                sta L8840
4596	.d664	ad 41 88	lda $8841	                lda L8841
4597	.d667	fd 35 88	sbc $8835,x	                sbc L8835,x
4598	.d66a	8d 41 88	sta $8841	                sta L8841
4599	.d66d					LD66D:
4600	.d66d	08		php		                php
4601	.d66e	fe 34 88	inc $8834,x	                inc L8834,x
4602	.d671	d0 03		bne $d676	                bne LD676
4603	.d673	fe 35 88	inc $8835,x	                inc L8835,x
4604	.d676					LD676:
4605	.d676	28		plp		                plp
4606	.d677	60		rts		                rts

4608	.d678					LD678:
4609	.d678	48		pha		                pha
4610	.d679	38		sec		                sec
4611	.d67a	b9 00 03	lda $0300,y	                lda $0300,y
4612	.d67d	fd 00 03	sbc $0300,x	                sbc $0300,x
4613	.d680	48		pha		                pha
4614	.d681	b9 01 03	lda $0301,y	                lda $0301,y
4615	.d684	fd 01 03	sbc $0301,x	                sbc $0301,x
4616	.d687	7a		ply		                ply
4617	.d688	c9 80		cmp #$80	                cmp #$80
4618	.d68a	90 03		bcc $d68f	                bcc LD68F
4619	.d68c	20 2e c9	jsr $c92e	                jsr negateAY
4620	.d68f					LD68F:
4621	.d68f	fa		plx		                plx
4622	.d690	9d 01 03	sta $0301,x	                sta $0301,x
4623	.d693	98		tya		                tya
4624	.d694	9d 00 03	sta $0300,x	                sta $0300,x
4625	.d697	60		rts		                rts

4627	.d698					LD698:
4628	.d698	a2 37		ldx #$37	                ldx #$37
4629	.d69a	20 23 d7	jsr $d723	                jsr LD723
4630	.d69d					LD69D:
4631	.d69d	3c 0a 03	bit $030a,x	                bit $030A,x
4632	.d6a0	70 10		bvs $d6b2	                bvs LD6B2
4633	.d6a2	60		rts		                rts

4635	.d6a3					LD6A3:
4636	.d6a3	a2 2c		ldx #$2c	                ldx #$2C
4637	.d6a5	20 23 d7	jsr $d723	                jsr LD723
4638	.d6a8					LD6A8:
4639	.d6a8	3c 0a 03	bit $030a,x	                bit $030A,x
4640	.d6ab	50 05		bvc $d6b2	                bvc LD6B2
4641	.d6ad	60		rts		                rts

4643	.d6ae					LD6AE:
4644	.d6ae	fa		plx		                plx
4645	.d6af	20 26 d7	jsr $d726	                jsr LD726
4646	.d6b2					LD6B2:
4647	.d6b2	bd 09 03	lda $0309,x	                lda $0309,x
4648	.d6b5	30 10		bmi $d6c7	                bmi LD6C7
4649	.d6b7	a0 03		ldy #$03	                ldy #$03
4650	.d6b9	da		phx		                phx
4651	.d6ba					LD6BA:
4652	.d6ba	bd 00 03	lda $0300,x	                lda $0300,x
4653	.d6bd	dd 1e 88	cmp $881e,x	                cmp L881E,x
4654	.d6c0	d0 ec		bne $d6ae	                bne LD6AE
4655	.d6c2	e8		inx		                inx
4656	.d6c3	88		dey		                dey
4657	.d6c4	10 f4		bpl $d6ba	                bpl LD6BA
4658	.d6c6	fa		plx		                plx
4659	.d6c7					LD6C7:
4660	.d6c7	60		rts		                rts

4662	.d6c8					LD6C8:
4663	.d6c8	20 fd d6	jsr $d6fd	                jsr LD6FD
4664	.d6cb	bd 0a 03	lda $030a,x	                lda $030A,x
4665	.d6ce	0a		asl a		                asl a
4666	.d6cf	0a		asl a		                asl a
4667	.d6d0	bd 0a 03	lda $030a,x	                lda $030A,x
4668	.d6d3	6a		ror a		                ror a
4669	.d6d4	85 da		sta $da		                sta $DA
4670	.d6d6	18		clc		                clc
4671	.d6d7	10 0f		bpl $d6e8	                bpl LD6E8
4672	.d6d9	bd 02 03	lda $0302,x	                lda $0302,x
4673	.d6dc	ed 04 03	sbc $0304	                sbc $0304
4674	.d6df	a8		tay		                tay
4675	.d6e0	bd 03 03	lda $0303,x	                lda $0303,x
4676	.d6e3	ed 05 03	sbc $0305	                sbc $0305
4677	.d6e6	80 0d		bra $d6f5	                bra LD6F5

4679	.d6e8					LD6E8:
4680	.d6e8	ad 00 03	lda $0300	                lda $0300
4681	.d6eb	fd 02 03	sbc $0302,x	                sbc $0302,x
4682	.d6ee	a8		tay		                tay
4683	.d6ef	ad 01 03	lda $0301	                lda $0301
4684	.d6f2	fd 03 03	sbc $0303,x	                sbc $0303,x
4685	.d6f5					LD6F5:
4686	.d6f5	20 a4 d7	jsr $d7a4	                jsr LD7A4
4687	.d6f8	20 fd d6	jsr $d6fd	                jsr LD6FD
4688	.d6fb	80 58		bra $d755	                bra LD755

4690	.d6fd					LD6FD:
4691	.d6fd	8a		txa		                txa
4692	.d6fe	1a		inc a		                inc a
4693	.d6ff	48		pha		                pha
4694	.d700	1a		inc a		                inc a
4695	.d701	a8		tay		                tay
4696	.d702	20 c2 e2	jsr $e2c2	                jsr exchangeTwoVDUBytes
4697	.d705	e8		inx		                inx
4698	.d706	e8		inx		                inx
4699	.d707	c8		iny		                iny
4700	.d708	c8		iny		                iny
4701	.d709	20 c2 e2	jsr $e2c2	                jsr exchangeTwoVDUBytes
4702	.d70c	fa		plx		                plx
4703	.d70d	20 11 d7	jsr $d711	                jsr LD711
4704	.d710	ca		dex		                dex
4705	.d711					LD711:
4706	.d711	bd 08 03	lda $0308,x	                lda $0308,x
4707	.d714	49 ff		eor #$ff	                eor #$FF
4708	.d716	9d 08 03	sta $0308,x	                sta $0308,x
4709	.d719	60		rts		                rts

4711	.d71a					LD71A:
4712	.d71a	20 26 d7	jsr $d726	                jsr LD726
4713	.d71d					LD71D:
4714	.d71d	bd 09 03	lda $0309,x	                lda $0309,x
4715	.d720	10 f8		bpl $d71a	                bpl LD71A
4716	.d722	60		rts		                rts

4718	.d723					LD723:
4719	.d723	20 1d d7	jsr $d71d	                jsr LD71D
4720	.d726					LD726:
4721	.d726	bd 09 03	lda $0309,x	                lda $0309,x
4722	.d729	10 2a		bpl $d755	                bpl LD755
4723	.d72b					LD72B:
4724	.d72b	18		clc		                clc
4725	.d72c	bd 08 03	lda $0308,x	                lda $0308,x
4726	.d72f	7d 04 03	adc $0304,x	                adc $0304,x
4727	.d732	9d 08 03	sta $0308,x	                sta $0308,x
4728	.d735	bd 09 03	lda $0309,x	                lda $0309,x
4729	.d738	7d 05 03	adc $0305,x	                adc $0305,x
4730	.d73b	9d 09 03	sta $0309,x	                sta $0309,x
4731	.d73e	30 03		bmi $d743	                bmi LD743
4732	.d740	20 55 d7	jsr $d755	                jsr LD755
4733	.d743					LD743:
4734	.d743	da		phx		                phx
4735	.d744	e8		inx		                inx
4736	.d745	e8		inx		                inx
4737	.d746	3c 08 03	bit $0308,x	                bit $0308,x
4738	.d749	30 23		bmi $d76e	                bmi LD76E
4739	.d74b					LD74B:
4740	.d74b	fe 00 03	inc $0300,x	                inc $0300,x
4741	.d74e	d0 03		bne $d753	                bne LD753
4742	.d750	fe 01 03	inc $0301,x	                inc $0301,x
4743	.d753					LD753:
4744	.d753	fa		plx		                plx
4745	.d754	60		rts		                rts

4747	.d755					LD755:
4748	.d755	38		sec		                sec
4749	.d756	bd 08 03	lda $0308,x	                lda $0308,x
4750	.d759	fd 06 03	sbc $0306,x	                sbc $0306,x
4751	.d75c	9d 08 03	sta $0308,x	                sta $0308,x
4752	.d75f	bd 09 03	lda $0309,x	                lda $0309,x
4753	.d762	fd 07 03	sbc $0307,x	                sbc $0307,x
4754	.d765	9d 09 03	sta $0309,x	                sta $0309,x
4755	.d768	da		phx		                phx
4756	.d769	3c 0a 03	bit $030a,x	                bit $030A,x
4757	.d76c	50 dd		bvc $d74b	                bvc LD74B
4758	.d76e					LD76E:
4759	.d76e	bd 00 03	lda $0300,x	                lda $0300,x
4760	.d771	d0 03		bne $d776	                bne LD776
4761	.d773	de 01 03	dec $0301,x	                dec $0301,x
4762	.d776					LD776:
4763	.d776	de 00 03	dec $0300,x	                dec $0300,x
4764	.d779	fa		plx		                plx
4765	.d77a	60		rts		                rts

4767	.d77b					LD77B:
4768	.d77b	18		clc		                clc
4769	.d77c	bd 0a 03	lda $030a,x	                lda $030A,x
4770	.d77f	85 da		sta $da		                sta $DA
4771	.d781	10 0f		bpl $d792	                bpl LD792
4772	.d783	bd 02 03	lda $0302,x	                lda $0302,x
4773	.d786	ed 06 03	sbc $0306	                sbc $0306
4774	.d789	a8		tay		                tay
4775	.d78a	bd 03 03	lda $0303,x	                lda $0303,x
4776	.d78d	ed 07 03	sbc $0307	                sbc $0307
4777	.d790	80 0d		bra $d79f	                bra LD79F

4779	.d792					LD792:
4780	.d792	ad 02 03	lda $0302	                lda $0302
4781	.d795	fd 02 03	sbc $0302,x	                sbc $0302,x
4782	.d798	a8		tay		                tay
4783	.d799	ad 03 03	lda $0303	                lda $0303
4784	.d79c	fd 03 03	sbc $0303,x	                sbc $0303,x
4785	.d79f					LD79F:
4786	.d79f	20 a4 d7	jsr $d7a4	                jsr LD7A4
4787	.d7a2	80 87		bra $d72b	                bra LD72B

4789	.d7a4					LD7A4:
4790	.d7a4	84 de		sty $de		                sty $DE
4791	.d7a6	85 df		sta $df		                sta $DF
4792	.d7a8	bd 02 03	lda $0302,x	                lda $0302,x
4793	.d7ab	bc 03 03	ldy $0303,x	                ldy $0303,x
4794	.d7ae	06 da		asl $da		                asl $DA
4795	.d7b0	b0 0a		bcs $d7bc	                bcs LD7BC
4796	.d7b2	65 de		adc $de		                adc $DE
4797	.d7b4	9d 02 03	sta $0302,x	                sta $0302,x
4798	.d7b7	98		tya		                tya
4799	.d7b8	65 df		adc $df		                adc $DF
4800	.d7ba	80 08		bra $d7c4	                bra LD7C4

4802	.d7bc					LD7BC:
4803	.d7bc	e5 de		sbc $de		                sbc $DE
4804	.d7be	9d 02 03	sta $0302,x	                sta $0302,x
4805	.d7c1	98		tya		                tya
4806	.d7c2	e5 df		sbc $df		                sbc $DF
4807	.d7c4					LD7C4:
4808	.d7c4	9d 03 03	sta $0303,x	                sta $0303,x
4809	.d7c7	a9 00		lda #$00	                lda #$00
4810	.d7c9	3c 09 03	bit $0309,x	                bit $0309,x
4811	.d7cc	10 01		bpl $d7cf	                bpl LD7CF
4812	.d7ce	3a		dec a		                dec a
4813	.d7cf					LD7CF:
4814	.d7cf	85 dc		sta $dc		                sta $DC
4815	.d7d1	4a		lsr a		                lsr a
4816	.d7d2	85 dd		sta $dd		                sta $DD
4817	.d7d4	a0 10		ldy #$10	                ldy #$10
4818	.d7d6					LD7D6:
4819	.d7d6	a5 dd		lda $dd		                lda $DD
4820	.d7d8	0a		asl a		                asl a
4821	.d7d9	3e 08 03	rol $0308,x	                rol $0308,x
4822	.d7dc	3e 09 03	rol $0309,x	                rol $0309,x
4823	.d7df	26 dc		rol $dc		                rol $DC
4824	.d7e1	26 dd		rol $dd		                rol $DD
4825	.d7e3	06 de		asl $de		                asl $DE
4826	.d7e5	26 df		rol $df		                rol $DF
4827	.d7e7	90 19		bcc $d802	                bcc LD802
4828	.d7e9	18		clc		                clc
4829	.d7ea	a5 dc		lda $dc		                lda $DC
4830	.d7ec	7d 04 03	adc $0304,x	                adc $0304,x
4831	.d7ef	85 dc		sta $dc		                sta $DC
4832	.d7f1	a5 dd		lda $dd		                lda $DD
4833	.d7f3	7d 05 03	adc $0305,x	                adc $0305,x
4834	.d7f6	85 dd		sta $dd		                sta $DD
4835	.d7f8	90 08		bcc $d802	                bcc LD802
4836	.d7fa	fe 08 03	inc $0308,x	                inc $0308,x
4837	.d7fd	d0 03		bne $d802	                bne LD802
4838	.d7ff	fe 09 03	inc $0309,x	                inc $0309,x
4839	.d802					LD802:
4840	.d802	88		dey		                dey
4841	.d803	d0 d1		bne $d7d6	                bne LD7D6
4842	.d805	3c 09 03	bit $0309,x	                bit $0309,x
4843	.d808	50 0b		bvc $d815	                bvc LD815
4844	.d80a	a5 dc		lda $dc		                lda $DC
4845	.d80c	9d 08 03	sta $0308,x	                sta $0308,x
4846	.d80f	a5 dd		lda $dd		                lda $DD
4847	.d811	9d 09 03	sta $0309,x	                sta $0309,x
4848	.d814	60		rts		                rts

4850	.d815					LD815:
4851	.d815	a0 10		ldy #$10	                ldy #$10
4852	.d817					LD817:
4853	.d817	26 dc		rol $dc		                rol $DC
4854	.d819	26 dd		rol $dd		                rol $DD
4855	.d81b	3e 08 03	rol $0308,x	                rol $0308,x
4856	.d81e	3e 09 03	rol $0309,x	                rol $0309,x
4857	.d821	38		sec		                sec
4858	.d822	bd 08 03	lda $0308,x	                lda $0308,x
4859	.d825	fd 06 03	sbc $0306,x	                sbc $0306,x
4860	.d828	85 de		sta $de		                sta $DE
4861	.d82a	bd 09 03	lda $0309,x	                lda $0309,x
4862	.d82d	fd 07 03	sbc $0307,x	                sbc $0307,x
4863	.d830	90 08		bcc $d83a	                bcc LD83A
4864	.d832	9d 09 03	sta $0309,x	                sta $0309,x
4865	.d835	a5 de		lda $de		                lda $DE
4866	.d837	9d 08 03	sta $0308,x	                sta $0308,x
4867	.d83a					LD83A:
4868	.d83a	88		dey		                dey
4869	.d83b	d0 da		bne $d817	                bne LD817
4870	.d83d	26 dc		rol $dc		                rol $DC
4871	.d83f	26 dd		rol $dd		                rol $DD
4872	.d841	38		sec		                sec
4873	.d842	bd 08 03	lda $0308,x	                lda $0308,x
4874	.d845	fd 06 03	sbc $0306,x	                sbc $0306,x
4875	.d848	9d 08 03	sta $0308,x	                sta $0308,x
4876	.d84b	bd 09 03	lda $0309,x	                lda $0309,x
4877	.d84e	fd 07 03	sbc $0307,x	                sbc $0307,x
4878	.d851	9d 09 03	sta $0309,x	                sta $0309,x
4879	.d854	bd 00 03	lda $0300,x	                lda $0300,x
4880	.d857	bc 01 03	ldy $0301,x	                ldy $0301,x
4881	.d85a	06 da		asl $da		                asl $DA
4882	.d85c	b0 0b		bcs $d869	                bcs LD869
4883	.d85e	38		sec		                sec
4884	.d85f	65 dc		adc $dc		                adc $DC
4885	.d861	9d 00 03	sta $0300,x	                sta $0300,x
4886	.d864	98		tya		                tya
4887	.d865	65 dd		adc $dd		                adc $DD
4888	.d867	80 09		bra $d872	                bra LD872

4890	.d869					LD869:
4891	.d869	18		clc		                clc
4892	.d86a	e5 dc		sbc $dc		                sbc $DC
4893	.d86c	9d 00 03	sta $0300,x	                sta $0300,x
4894	.d86f	98		tya		                tya
4895	.d870	e5 dd		sbc $dd		                sbc $DD
4896	.d872					LD872:
4897	.d872	9d 01 03	sta $0301,x	                sta $0301,x
4898	.d875					LD875:
4899	.d875	60		rts		                rts

4901	.d876					LD876:
4902	.d876	0e 32 03	asl $0332	                asl $0332
4903	.d879	a0 2c		ldy #$2c	                ldy #$2C
4904	.d87b	20 16 c9	jsr $c916	                jsr copyLastFourVDUQueueBytes
4905	.d87e	06 db		asl $db		                asl $DB
4906	.d880	90 0d		bcc $d88f	                bcc LD88F
4907	.d882	20 26 da	jsr $da26	                jsr LDA26
4908	.d885	f0 ee		beq $d875	                beq LD875
4909	.d887	a2 00		ldx #$00	                ldx #$00
4910	.d889	ad 32 03	lda $0332	                lda $0332
4911	.d88c	20 0f da	jsr $da0f	                jsr LDA0F
4912	.d88f					LD88F:
4913	.d88f	24 db		bit $db		                bit $DB
4914	.d891	50 0f		bvc $d8a2	                bvc LD8A2
4915	.d893	20 26 da	jsr $da26	                jsr LDA26
4916	.d896	f0 dd		beq $d875	                beq LD875
4917	.d898	a2 04		ldx #$04	                ldx #$04
4918	.d89a	ad 32 03	lda $0332	                lda $0332
4919	.d89d	49 80		eor #$80	                eor #$80
4920	.d89f	20 0f da	jsr $da0f	                jsr LDA0F
4921	.d8a2					LD8A2:
4922	.d8a2	a2 28		ldx #$28	                ldx #$28
4923	.d8a4	a0 2c		ldy #$2c	                ldy #$2C
4924	.d8a6	4c e8 da	jmp $dae8	                jmp LDAE8

4926	.d8a9					LD8A9:
4927	.d8a9	0a		asl a		                asl a
4928	.d8aa	0a		asl a		                asl a
4929	.d8ab	85 db		sta $db		                sta $DB
4930	.d8ad	29 c0		and #$c0	                and #$C0
4931	.d8af	49 40		eor #$40	                eor #$40
4932	.d8b1	d0 06		bne $d8b9	                bne LD8B9
4933	.d8b3	ad 67 03	lda $0367	                lda $0367
4934	.d8b6	8d 68 03	sta $0368	                sta $0368
4935	.d8b9					LD8B9:
4936	.d8b9	20 a6 d1	jsr $d1a6	                jsr LD1A6
4937	.d8bc	85 dc		sta $dc		                sta $DC
4938	.d8be	f0 04		beq $d8c4	                beq LD8C4
4939	.d8c0	a9 80		lda #$80	                lda #$80
4940	.d8c2	14 db		trb $db		                trb $DB
4941	.d8c4					LD8C4:
4942	.d8c4	a2 20		ldx #$20	                ldx #$20
4943	.d8c6	20 a8 d1	jsr $d1a8	                jsr windEntryPoint
4944	.d8c9	85 e0		sta $e0		                sta $E0
4945	.d8cb	f0 0a		beq $d8d7	                beq LD8D7
4946	.d8cd	aa		tax		                tax
4947	.d8ce	a9 20		lda #$20	                lda #$20
4948	.d8d0	14 db		trb $db		                trb $DB
4949	.d8d2	8a		txa		                txa
4950	.d8d3	24 dc		bit $dc		                bit $DC
4951	.d8d5					LD8D5:
4952	.d8d5	d0 9e		bne $d875	                bne LD875
4953	.d8d7					LD8D7:
4954	.d8d7	a0 24		ldy #$24	                ldy #$24
4955	.d8d9	a9 20		lda #$20	                lda #$20
4956	.d8db	a2 28		ldx #$28	                ldx #$28
4957	.d8dd	20 a9 9b	jsr $9ba9	                jsr L9B09
4958	.d8e0	24 db		bit $db		                bit $DB
4959	.d8e2	70 08		bvs $d8ec	                bvs LD8EC
4960	.d8e4	ad 2e 03	lda $032e	                lda $032E
4961	.d8e7	0d 2f 03	ora $032f	                ora $032F
4962	.d8ea	f0 8a		beq $d876	                beq LD876
4963	.d8ec					LD8EC:
4964	.d8ec	a5 dc		lda $dc		                lda $DC
4965	.d8ee	89 0c		bit #$0c	                bit #$0C
4966	.d8f0	f0 0e		beq $d900	                beq LD900
4967	.d8f2	a2 28		ldx #$28	                ldx #$28
4968	.d8f4	20 7b d7	jsr $d77b	                jsr LD77B
4969	.d8f7	a2 28		ldx #$28	                ldx #$28
4970	.d8f9	20 a8 d1	jsr $d1a8	                jsr windEntryPoint
4971	.d8fc	24 e0		bit $e0		                bit $E0
4972	.d8fe	d0 d5		bne $d8d5	                bne LD8D5
4973	.d900					LD900:
4974	.d900	89 03		bit #$03	                bit #$03
4975	.d902	f0 0a		beq $d90e	                beq LD90E
4976	.d904	a2 28		ldx #$28	                ldx #$28
4977	.d906	20 c8 d6	jsr $d6c8	                jsr LD6C8
4978	.d909	a2 28		ldx #$28	                ldx #$28
4979	.d90b	20 a8 d1	jsr $d1a8	                jsr windEntryPoint
4980	.d90e					LD90E:
4981	.d90e	a8		tay		                tay
4982	.d90f	d0 c4		bne $d8d5	                bne LD8D5
4983	.d911	a0 20		ldy #$20	                ldy #$20
4984	.d913	a2 22		ldx #$22	                ldx #$22
4985	.d915	a5 e0		lda $e0		                lda $E0
4986	.d917	f0 0f		beq $d928	                beq LD928
4987	.d919	a0 04		ldy #$04	                ldy #$04
4988	.d91b	a2 06		ldx #$06	                ldx #$06
4989	.d91d	2c 32 03	bit $0332	                bit $0332
4990	.d920	10 02		bpl $d924	                bpl LD924
4991	.d922	a2 02		ldx #$02	                ldx #$02
4992	.d924					LD924:
4993	.d924	50 02		bvc $d928	                bvc LD928
4994	.d926	a0 00		ldy #$00	                ldy #$00
4995	.d928					LD928:
4996	.d928	18		clc		                clc
4997	.d929	bd 00 03	lda $0300,x	                lda $0300,x
4998	.d92c	ed 2a 03	sbc $032a	                sbc $032A
4999	.d92f	90 03		bcc $d934	                bcc LD934
5000	.d931	1a		inc a		                inc a
5001	.d932	49 ff		eor #$ff	                eor #$FF
5002	.d934					LD934:
5003	.d934	85 dc		sta $dc		                sta $DC
5004	.d936	18		clc		                clc
5005	.d937	b9 00 03	lda $0300,y	                lda $0300,y
5006	.d93a	ed 28 03	sbc $0328	                sbc $0328
5007	.d93d	aa		tax		                tax
5008	.d93e	b9 01 03	lda $0301,y	                lda $0301,y
5009	.d941	ed 29 03	sbc $0329	                sbc $0329
5010	.d944	30 0c		bmi $d952	                bmi LD952
5011	.d946	e8		inx		                inx
5012	.d947	d0 01		bne $d94a	                bne LD94A
5013	.d949	1a		inc a		                inc a
5014	.d94a					LD94A:
5015	.d94a	49 ff		eor #$ff	                eor #$FF
5016	.d94c	a8		tay		                tay
5017	.d94d	8a		txa		                txa
5018	.d94e	49 ff		eor #$ff	                eor #$FF
5019	.d950	aa		tax		                tax
5020	.d951	98		tya		                tya
5021	.d952					LD952:
5022	.d952	85 dd		sta $dd		                sta $DD
5023	.d954	86 e0		stx $e0		                stx $E0
5024	.d956	a2 28		ldx #$28	                ldx #$28
5025	.d958	20 41 df	jsr $df41	                jsr LDF41
5026	.d95b	06 db		asl $db		                asl $DB
5027	.d95d	b0 2a		bcs $d989	                bcs LD989
5028	.d95f					LD95F:
5029	.d95f	24 db		bit $db		                bit $DB
5030	.d961	50 0b		bvc $d96e	                bvc LD96E
5031	.d963	a5 e0		lda $e0		                lda $E0
5032	.d965	25 dc		and $dc		                and $DC
5033	.d967	25 dd		and $dd		                and $DD
5034	.d969	1a		inc a		                inc a
5035	.d96a	f0 34		beq $d9a0	                beq LD9A0
5036	.d96c	24 db		bit $db		                bit $DB
5037	.d96e					LD96E:
5038	.d96e	10 09		bpl $d979	                bpl LD979
5039	.d970	ad 68 03	lda $0368	                lda $0368
5040	.d973	0a		asl a		                asl a
5041	.d974	2e 68 03	rol $0368	                rol $0368
5042	.d977	90 10		bcc $d989	                bcc LD989
5043	.d979					LD979:
5044	.d979	a5 d1		lda $d1		                lda ZMASK
5045	.d97b	25 d4		and $d4		                and ZGORA
5046	.d97d	11 d6		ora ($d6),y	                ora (ZMEMG),y
5047	.d97f	85 da		sta $da		                sta $DA
5048	.d981	a5 d1		lda $d1		                lda ZMASK
5049	.d983	25 d5		and $d5		                and ZGEOR
5050	.d985	45 da		eor $da		                eor $DA
5051	.d987	91 d6		sta ($d6),y	                sta (ZMEMG),y
5052	.d989					LD989:
5053	.d989	ad 31 03	lda $0331	                lda $0331
5054	.d98c	10 4e		bpl $d9dc	                bpl LD9DC
5055	.d98e	e6 dc		inc $dc		                inc $DC
5056	.d990	f0 0e		beq $d9a0	                beq LD9A0
5057	.d992	2c 32 03	bit $0332	                bit $0332
5058	.d995	30 0a		bmi $d9a1	                bmi LD9A1
5059	.d997	88		dey		                dey
5060	.d998	ca		dex		                dex
5061	.d999	10 24		bpl $d9bf	                bpl LD9BF
5062	.d99b	20 4c da	jsr $da4c	                jsr LDA4C
5063	.d99e	80 1f		bra $d9bf	                bra LD9BF

5065	.d9a0					LD9A0:
5066	.d9a0	60		rts		                rts

5068	.d9a1					LD9A1:
5069	.d9a1	c8		iny		                iny
5070	.d9a2	e8		inx		                inx
5071	.d9a3	e0 08		cpx #$08	                cpx #$08
5072	.d9a5	d0 18		bne $d9bf	                bne LD9BF
5073	.d9a7	38		sec		                sec
5074	.d9a8	98		tya		                tya
5075	.d9a9	e9 08		sbc #$08	                sbc #$08
5076	.d9ab	18		clc		                clc
5077	.d9ac	6d 52 03	adc $0352	                adc $0352
5078	.d9af	a8		tay		                tay
5079	.d9b0	a5 d7		lda $d7		                lda ZMEMG+1
5080	.d9b2	6d 53 03	adc $0353	                adc $0353
5081	.d9b5	10 04		bpl $d9bb	                bpl LD9BB
5082	.d9b7	38		sec		                sec
5083	.d9b8	ed 54 03	sbc $0354	                sbc $0354
5084	.d9bb					LD9BB:
5085	.d9bb	85 d7		sta $d7		                sta ZMEMG+1
5086	.d9bd	a2 00		ldx #$00	                ldx #$00
5087	.d9bf					LD9BF:
5088	.d9bf	ad 69 03	lda $0369	                lda $0369
5089	.d9c2	f0 03		beq $d9c7	                beq LD9C7
5090	.d9c4	20 7c da	jsr $da7c	                jsr setupColourMasks
5091	.d9c7					LD9C7:
5092	.d9c7	18		clc		                clc
5093	.d9c8	ad 30 03	lda $0330	                lda $0330
5094	.d9cb	6d 2c 03	adc $032c	                adc $032C
5095	.d9ce	8d 30 03	sta $0330	                sta $0330
5096	.d9d1	ad 31 03	lda $0331	                lda $0331
5097	.d9d4	6d 2d 03	adc $032d	                adc $032D
5098	.d9d7	8d 31 03	sta $0331	                sta $0331
5099	.d9da	30 83		bmi $d95f	                bmi LD95F
5100	.d9dc					LD9DC:
5101	.d9dc	e6 e0		inc $e0		                inc $E0
5102	.d9de	d0 04		bne $d9e4	                bne LD9E4
5103	.d9e0	e6 dd		inc $dd		                inc $DD
5104	.d9e2	f0 bc		beq $d9a0	                beq LD9A0
5105	.d9e4					LD9E4:
5106	.d9e4	2c 32 03	bit $0332	                bit $0332
5107	.d9e7	70 09		bvs $d9f2	                bvs LD9F2
5108	.d9e9	46 d1		lsr $d1		                lsr ZMASK
5109	.d9eb	90 0c		bcc $d9f9	                bcc LD9F9
5110	.d9ed	20 67 da	jsr $da67	                jsr nextColumnAndResetMask
5111	.d9f0	80 07		bra $d9f9	                bra LD9F9

5113	.d9f2					LD9F2:
5114	.d9f2	06 d1		asl $d1		                asl ZMASK
5115	.d9f4	90 03		bcc $d9f9	                bcc LD9F9
5116	.d9f6	20 34 da	jsr $da34	                jsr previousColumnAndResetMask
5117	.d9f9					LD9F9:
5118	.d9f9	38		sec		                sec
5119	.d9fa	ad 30 03	lda $0330	                lda $0330
5120	.d9fd	ed 2e 03	sbc $032e	                sbc $032E
5121	.da00	8d 30 03	sta $0330	                sta $0330
5122	.da03	ad 31 03	lda $0331	                lda $0331
5123	.da06	ed 2f 03	sbc $032f	                sbc $032F
5124	.da09	8d 31 03	sta $0331	                sta $0331
5125	.da0c	4c 5f d9	jmp $d95f	                jmp LD95F

5127	.da0f					LDA0F:
5128	.da0f	30 09		bmi $da1a	                bmi LDA1A
5129	.da11	fe 28 03	inc $0328,x	                inc $0328,x
5130	.da14	d0 0f		bne $da25	                bne LDA25
5131	.da16	fe 29 03	inc $0329,x	                inc $0329,x
5132	.da19	60		rts		                rts

5134	.da1a					LDA1A:
5135	.da1a	bd 28 03	lda $0328,x	                lda $0328,x
5136	.da1d	d0 03		bne $da22	                bne LDA22
5137	.da1f	de 29 03	dec $0329,x	                dec $0329,x
5138	.da22					LDA22:
5139	.da22	de 28 03	dec $0328,x	                dec $0328,x
5140	.da25					LDA25:
5141	.da25	60		rts		                rts

5143	.da26					LDA26:
5144	.da26	a0 04		ldy #$04	                ldy #$04
5145	.da28					LDA28:
5146	.da28	b9 27 03	lda $0327,y	                lda $0327,y
5147	.da2b	d9 2b 03	cmp $032b,y	                cmp $032B,y
5148	.da2e	d0 03		bne $da33	                bne LDA33
5149	.da30	88		dey		                dey
5150	.da31	d0 f5		bne $da28	                bne LDA28
5151	.da33					LDA33:
5152	.da33	60		rts		                rts

5154						;-------------------------------------------------------------------------

5156	.da34					previousColumnAndResetMask:
5157	.da34	ad 63 03	lda $0363	                lda vduv.colourMaskRight
5158	.da37	85 d1		sta $d1		                sta ZMASK
5159	.da39	98		tya		                tya
5160	.da3a	e9 08		sbc #$08	                sbc #$08
5161	.da3c	a8		tay		                tay
5162	.da3d	b0 0c		bcs $da4b	                bcs rtsDA4B
5163	.da3f	a5 d7		lda $d7		                lda ZMEMG+1
5164	.da41	3a		dec a		                dec a
5165	.da42	cd 4e 03	cmp $034e	                cmp vduv.startScreenAddressHighByte
5166	.da45	b0 02		bcs $da49	                bcs +
5167	.da47	a9 7f		lda #$7f	                lda #$7F
5168	.da49					+
5169	.da49	85 d7		sta $d7		                sta ZMEMG+1
5170	.da4b					rtsDA4B:
5171	.da4b	60		rts		                rts

5173						;-------------------------------------------------------------------------

5175	.da4c					LDA4C:
5176	.da4c	18		clc		                clc
5177	.da4d	98		tya		                tya
5178	.da4e	69 08		adc #$08	                adc #$08
5179	.da50	38		sec		                sec
5180	.da51	ed 52 03	sbc $0352	                sbc $0352
5181	.da54	a8		tay		                tay
5182	.da55	a5 d7		lda $d7		                lda ZMEMG+1
5183	.da57	ed 53 03	sbc $0353	                sbc $0353
5184	.da5a	cd 4e 03	cmp $034e	                cmp $034E
5185	.da5d	b0 03		bcs $da62	                bcs LDA62
5186	.da5f	6d 54 03	adc $0354	                adc $0354
5187	.da62					LDA62:
5188	.da62	85 d7		sta $d7		                sta ZMEMG+1
5189	.da64	a2 07		ldx #$07	                ldx #$07
5190	.da66	60		rts		                rts

5192						;-------------------------------------------------------------------------
5193						;
5194	.da67					nextColumnAndResetMask:
5195	.da67	ad 62 03	lda $0362	                lda vduv.colourMaskLeft
5196	.da6a	85 d1		sta $d1		                sta ZMASK

5198						;-------------------------------------------------------------------------
5199						;
5200						; Add 8 to (ZMEMG),Y, taking into account screen wrap.
5201						;
5202						; entry:
5203						;
5204						; C=1
5205						;
5206						; (ZMEMG),Y = screen address
5207						;
5208						; exit:
5209						;
5210						; (ZMEMG),Y = new screen address
5211						;
5212	.da6c					nextColumn:
5213	.da6c	98		tya		                tya
5214	.da6d	69 07		adc #$07	                adc #$07
5215	.da6f	a8		tay		                tay
5216	.da70	90 09		bcc $da7b	                bcc +
5217	.da72	e6 d7		inc $d7		                inc ZMEMG+1
5218	.da74	10 05		bpl $da7b	                bpl +
5219	.da76	ad 4e 03	lda $034e	                lda vduv.startScreenAddressHighByte
5220	.da79	85 d7		sta $d7		                sta ZMEMG+1
5221	.da7b					+
5222	.da7b	60		rts		                rts

5224						;-------------------------------------------------------------------------
5225						;
5226						; Set up colour masks, taking into account ECF pattern.
5227						;
5228						; entry:
5229						;
5230						; X = scanline in row, 0-7
5231						;
5232	.da7c					setupColourMasks:
5233	.da7c	da		phx		                phx                          ;save scanline
5234	.da7d	8a		txa		                txa                          ;A=scanline
5235	.da7e	0d 59 03	ora $0359	                ora vduv.graphicsPlotState   ;0-7 if fg, 8-15 if bg
5236	.da81	aa		tax		                tax
5237	.da82	bd 20 88	lda $8820,x	                lda andy.fgECFPattern,x      ;get appropriate ECF byte
5238	.da85	ae 5a 03	ldx $035a	                ldx vduv.graphicsPlotMode
5239	.da88	48		pha		                pha
5240	.da89	1d 54 e1	ora $e154,x	                ora zgoraORTable,x
5241	.da8c	5d 55 e1	eor $e155,x	                eor zgoraEORTable,x
5242	.da8f	85 d4		sta $d4		                sta ZGORA
5243	.da91	68		pla		                pla
5244	.da92	1d 53 e1	ora $e153,x	                ora zgeorORTable,x
5245	.da95	5d 58 e1	eor $e158,x	                eor zgeorEORTable,x
5246	.da98	85 d5		sta $d5		                sta ZGEOR
5247	.da9a	fa		plx		                plx
5248	.da9b	60		rts		                rts

5250						;-------------------------------------------------------------------------

5252	.da9c					LDA9C:
5253	.da9c	b9 01 03	lda $0301,y	                lda $0301,y
5254	.da9f	48		pha		                pha
5255	.daa0	b9 00 03	lda $0300,y	                lda $0300,y
5256	.daa3	48		pha		                pha
5257	.daa4	2d 61 03	and $0361	                and $0361
5258	.daa7	18		clc		                clc
5259	.daa8	6d 61 03	adc $0361	                adc $0361
5260	.daab	a8		tay		                tay
5261	.daac	b9 3e e1	lda $e13e,y	                lda pixelMasks-1,y
5262	.daaf	59 30 e1	eor $e130,y	                eor LE120,y
5263	.dab2	85 dc		sta $dc		                sta $DC
5264	.dab4	bd 00 03	lda $0300,x	                lda $0300,x
5265	.dab7	2d 61 03	and $0361	                and $0361
5266	.daba	6d 61 03	adc $0361	                adc $0361
5267	.dabd	a8		tay		                tay
5268	.dabe	b9 30 e1	lda $e130,y	                lda LE120,y
5269	.dac1	85 d1		sta $d1		                sta ZMASK
5270	.dac3	38		sec		                sec
5271	.dac4	68		pla		                pla
5272	.dac5	0d 61 03	ora $0361	                ora $0361
5273	.dac8	fd 00 03	sbc $0300,x	                sbc $0300,x
5274	.dacb	a8		tay		                tay
5275	.dacc	68		pla		                pla
5276	.dacd	fd 01 03	sbc $0301,x	                sbc $0301,x
5277	.dad0	85 dd		sta $dd		                sta $DD
5278	.dad2	98		tya		                tya
5279	.dad3	ac 61 03	ldy $0361	                ldy $0361
5280	.dad6	c0 03		cpy #$03	                cpy #$03
5281	.dad8	f0 05		beq $dadf	                beq LDADF
5282	.dada	90 06		bcc $dae2	                bcc LDAE2
5283	.dadc	46 dd		lsr $dd		                lsr $DD
5284	.dade	6a		ror a		                ror a
5285	.dadf					LDADF:
5286	.dadf	46 dd		lsr $dd		                lsr $DD
5287	.dae1	6a		ror a		                ror a
5288	.dae2					LDAE2:
5289	.dae2	4a		lsr a		                lsr a
5290	.dae3					LDAE3:
5291	.dae3	60		rts		                rts

5293	.dae4					LDAE4:                                       ; fillRow?
5294	.dae4	a2 42		ldx #$42	                ldx #$42
5295	.dae6	a0 46		ldy #$46	                ldy #$46
5296	.dae8					LDAE8:                                       ; fillRowInternal?
5297	.dae8	20 cc d5	jsr $d5cc	                jsr sortVDUVariableWords
5298	.daeb	86 de		stx $de		                stx $DE
5299	.daed	84 df		sty $df		                sty $DF
5300	.daef	a6 df		ldx $df		                ldx $DF
5301	.daf1	a0 00		ldy #$00	                ldy #$00
5302	.daf3	20 b7 d1	jsr $d1b7	                jsr getOutcodeForAxis
5303	.daf6	f0 07		beq $daff	                beq LDAFF
5304	.daf8	4a		lsr a		                lsr a
5305	.daf9	f0 e8		beq $dae3	                beq LDAE3
5306	.dafb	a2 04		ldx #$04	                ldx #$04
5307	.dafd	86 df		stx $df		                stx $DF
5308	.daff					LDAFF:
5309	.daff	a6 de		ldx $de		                ldx $DE
5310	.db01	20 a8 d1	jsr $d1a8	                jsr windEntryPoint
5311	.db04	4a		lsr a		                lsr a
5312	.db05	d0 dc		bne $dae3	                bne LDAE3
5313	.db07	bd 02 03	lda $0302,x	                lda $0302,x
5314	.db0a	90 04		bcc $db10	                bcc LDB10
5315	.db0c	a2 00		ldx #$00	                ldx #$00
5316	.db0e	86 de		stx $de		                stx $DE
5317	.db10					LDB10:
5318	.db10	20 cb de	jsr $decb	                jsr LDECB
5319	.db13	a6 de		ldx $de		                ldx $DE
5320	.db15	a4 df		ldy $df		                ldy $DF
5321	.db17	20 9c da	jsr $da9c	                jsr LDA9C
5322	.db1a	aa		tax		                tax
5323	.db1b	ac 1a 03	ldy $031a	                ldy $031A
5324	.db1e	8a		txa		                txa
5325	.db1f	f0 23		beq $db44	                beq LDB44
5326	.db21	20 51 db	jsr $db51	                jsr plbyteEntryPoint
5327	.db24	80 08		bra $db2e	                bra LDB2E

5329	.db26					LDB26:
5330	.db26	b1 d6		lda ($d6),y	                lda (ZMEMG),y
5331	.db28	05 d4		ora $d4		                ora ZGORA
5332	.db2a	45 d5		eor $d5		                eor ZGEOR
5333	.db2c	91 d6		sta ($d6),y	                sta (ZMEMG),y
5334	.db2e					LDB2E:
5335	.db2e	98		tya		                tya
5336	.db2f	18		clc		                clc
5337	.db30	69 08		adc #$08	                adc #$08
5338	.db32	a8		tay		                tay
5339	.db33	90 09		bcc $db3e	                bcc LDB3E
5340	.db35	e6 d7		inc $d7		                inc ZMEMG+1
5341	.db37	10 05		bpl $db3e	                bpl LDB3E
5342	.db39	ad 4e 03	lda $034e	                lda $034E
5343	.db3c	85 d7		sta $d7		                sta ZMEMG+1
5344	.db3e					LDB3E:
5345	.db3e	ca		dex		                dex
5346	.db3f	d0 e5		bne $db26	                bne LDB26
5347	.db41	ca		dex		                dex
5348	.db42	86 d1		stx $d1		                stx ZMASK
5349	.db44					LDB44:
5350	.db44	a5 dc		lda $dc		                lda $DC
5351	.db46	14 d1		trb $d1		                trb ZMASK
5352	.db48	80 07		bra $db51	                bra plbyteEntryPoint

5354						;-------------------------------------------------------------------------
5355						;
5356						; mem mask ora eor | result
5357						; --- ---- --- --- | ------
5358						;  0    0   0   0  |   0
5359						;  0    0   0   1  |   0
5360						;  0    0   1   0  |   0
5361						;  0    0   1   1  |   0
5362						;  0    1   0   0  |   0
5363						;  0    1   0   1  |   1
5364						;  0    1   1   0  |   1
5365						;  0    1   1   1  |   0
5366						;  1    0   0   0  |   1
5367						;  1    0   0   1  |   1
5368						;  1    0   1   0  |   1
5369						;  1    0   1   1  |   1
5370						;  1    1   0   0  |   1
5371						;  1    1   0   1  |   0
5372						;  1    1   1   0  |   1
5373						;  1    1   1   1  |   0
5374						;
5375	.db4a					plotPoint:
5376	.db4a	a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
5377	.db4c					plotPointInternal:
5378	.db4c	20 c3 de	jsr $dec3	                jsr windGADDR
5379	.db4f	d0 10		bne $db61	                bne rtsDB61                  ;taken if point outside window
5380	.db51					plbyteEntryPoint:
5381	.db51	a5 d1		lda $d1		                lda ZMASK
5382	.db53	25 d4		and $d4		                and ZGORA
5383	.db55	11 d6		ora ($d6),y	                ora (ZMEMG),y
5384	.db57	85 da		sta $da		                sta ZTEMP+0
5385	.db59	a5 d5		lda $d5		                lda ZGEOR
5386	.db5b	25 d1		and $d1		                and ZMASK
5387	.db5d	45 da		eor $da		                eor ZTEMP+0
5388	.db5f					oswrscCode:
5389	.db5f	91 d6		sta ($d6),y	                sta (ZMEMG),y
5390	.db61					rtsDB61:
5391	.db61	60		rts		                rts

5393						;-------------------------------------------------------------------------

5395	.db62					LDB62:
5396	.db62	a2 2a		ldx #$2a	                ldx #VDUVariables.workspace._2A
5397	.db64	a0 32		ldy #$32	                ldy #VDUVariables.workspace._32
5398	.db66	20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
5399	.db69	a2 36		ldx #$36	                ldx #VDUVariables.workspace._36
5400	.db6b	a0 3e		ldy #$3e	                ldy #VDUVariables.workspace._3E
5401	.db6d	20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
5402	.db70	a2 2a		ldx #$2a	                ldx #$2A
5403	.db72	20 b5 d1	jsr $d1b5	                jsr getOutcodeForYAxis
5404	.db75	48		pha		                pha
5405	.db76	a2 36		ldx #$36	                ldx #$36
5406	.db78	20 b5 d1	jsr $d1b5	                jsr getOutcodeForYAxis
5407	.db7b	f0 0f		beq $db8c	                beq LDB8C
5408	.db7d	68		pla		                pla
5409	.db7e	d0 05		bne $db85	                bne LDB85
5410	.db80	ad 45 03	lda $0345	                lda $0345
5411	.db83	f0 01		beq $db86	                beq LDB86
5412	.db85					LDB85:
5413	.db85	60		rts		                rts

5415	.db86					LDB86:
5416	.db86	a2 28		ldx #$28	                ldx #$28
5417	.db88	a0 2c		ldy #$2c	                ldy #$2C
5418	.db8a	80 07		bra $db93	                bra LDB93

5420	.db8c					LDB8C:
5421	.db8c	68		pla		                pla
5422	.db8d	f0 07		beq $db96	                beq LDB96
5423	.db8f	a2 34		ldx #$34	                ldx #$34
5424	.db91	a0 38		ldy #$38	                ldy #$38
5425	.db93					LDB93:
5426	.db93	4c e8 da	jmp $dae8	                jmp LDAE8

5428	.db96					LDB96:
5429	.db96	a2 30		ldx #$30	                ldx #$30
5430	.db98	20 c8 de	jsr $dec8	                jsr gaddrEntryPoint
5431	.db9b	2c 47 03	bit $0347	                bit $0347
5432	.db9e	30 09		bmi $dba9	                bmi LDBA9
5433	.dba0	98		tya		                tya
5434	.dba1	38		sec		                sec
5435	.dba2	e9 08		sbc #$08	                sbc #$08
5436	.dba4	a8		tay		                tay
5437	.dba5	b0 02		bcs $dba9	                bcs LDBA9
5438	.dba7	c6 d7		dec $d7		                dec ZMEMG+1
5439	.dba9					LDBA9:
5440	.dba9	ad 44 03	lda $0344	                lda $0344
5441	.dbac	85 dd		sta $dd		                sta $DD
5442	.dbae					LDBAE:
5443	.dbae	b1 d6		lda ($d6),y	                lda (ZMEMG),y
5444	.dbb0	ae 42 03	ldx $0342	                ldx $0342
5445	.dbb3	f0 04		beq $dbb9	                beq LDBB9
5446	.dbb5					LDBB5:
5447	.dbb5	0a		asl a		                asl a
5448	.dbb6	ca		dex		                dex
5449	.dbb7	d0 fc		bne $dbb5	                bne LDBB5
5450	.dbb9					LDBB9:
5451	.dbb9	85 da		sta $da		                sta $DA
5452	.dbbb	38		sec		                sec
5453	.dbbc	20 6c da	jsr $da6c	                jsr nextColumn
5454	.dbbf	b1 d6		lda ($d6),y	                lda (ZMEMG),y
5455	.dbc1	ae 43 03	ldx $0343	                ldx $0343
5456	.dbc4	f0 04		beq $dbca	                beq LDBCA
5457	.dbc6					LDBC6:
5458	.dbc6	4a		lsr a		                lsr a
5459	.dbc7	ca		dex		                dex
5460	.dbc8	d0 fc		bne $dbc6	                bne LDBC6
5461	.dbca					LDBCA:
5462	.dbca	45 da		eor $da		                eor $DA
5463	.dbcc	25 e1		and $e1		                and $E1
5464	.dbce	45 da		eor $da		                eor $DA
5465	.dbd0	a6 dd		ldx $dd		                ldx $DD
5466	.dbd2	9d 30 88	sta $8830,x	                sta L8830,x
5467	.dbd5	c6 dd		dec $dd		                dec $DD
5468	.dbd7	10 d5		bpl $dbae	                bpl LDBAE
5469	.dbd9	a2 34		ldx #$34	                ldx #$34
5470	.dbdb	a0 38		ldy #$38	                ldy #$38
5471	.dbdd	20 e8 da	jsr $dae8	                jsr LDAE8
5472	.dbe0	ad 45 03	lda $0345	                lda $0345
5473	.dbe3	d0 03		bne $dbe8	                bne LDBE8
5474	.dbe5	20 86 db	jsr $db86	                jsr LDB86
5475	.dbe8					LDBE8:
5476	.dbe8	a2 3c		ldx #$3c	                ldx #$3C
5477	.dbea	20 c8 de	jsr $dec8	                jsr gaddrEntryPoint
5478	.dbed	ad 46 03	lda $0346	                lda $0346
5479	.dbf0	85 da		sta $da		                sta $DA
5480	.dbf2	ae 44 03	ldx $0344	                ldx $0344
5481	.dbf5	f0 15		beq $dc0c	                beq LDC0C
5482	.dbf7	20 10 dc	jsr $dc10	                jsr LDC10
5483	.dbfa	a9 ff		lda #$ff	                lda #$FF
5484	.dbfc	85 da		sta $da		                sta $DA
5485	.dbfe	80 05		bra $dc05	                bra LDC05

5487	.dc00					LDC00_code:
5488	.dc00	bd 30 88	lda $8830,x	                lda L8830,x
5489	.dc03	91 d6		sta ($d6),y	                sta (ZMEMG),y
5490	.dc05					LDC05:
5491	.dc05	38		sec		                sec
5492	.dc06	20 6c da	jsr $da6c	                jsr nextColumn
5493	.dc09	ca		dex		                dex
5494	.dc0a	d0 f4		bne $dc00	                bne LDC00_code
5495	.dc0c					LDC0C:
5496	.dc0c	a5 e0		lda $e0		                lda $E0
5497	.dc0e	14 da		trb $da		                trb $DA
5498	.dc10					LDC10:
5499	.dc10	bd 30 88	lda $8830,x	                lda L8830,x
5500	.dc13	51 d6		eor ($d6),y	                eor (ZMEMG),y
5501	.dc15	25 da		and $da		                and $DA
5502	.dc17	51 d6		eor ($d6),y	                eor (ZMEMG),y
5503	.dc19	91 d6		sta ($d6),y	                sta (ZMEMG),y
5504	.dc1b	60		rts		                rts

5506	.dc1c					LDC1C:
5507	.dc1c	ad 37 03	lda $0337	                lda $0337
5508	.dc1f	1a		inc a		                inc a
5509	.dc20	cd 36 03	cmp $0336	                cmp $0336
5510	.dc23	f0 22		beq $dc47	                beq LDC47
5511	.dc25	8d 37 03	sta $0337	                sta $0337
5512	.dc28	aa		tax		                tax
5513	.dc29	ad 2e 03	lda $032e	                lda $032E
5514	.dc2c	9d 00 84	sta $8400,x	                sta L8400,x
5515	.dc2f	ad 32 03	lda $0332	                lda $0332
5516	.dc32	9d 00 85	sta $8500,x	                sta L8500,x
5517	.dc35	ad 2f 03	lda $032f	                lda $032F
5518	.dc38	0a		asl a		                asl a
5519	.dc39	0a		asl a		                asl a
5520	.dc3a	0d 33 03	ora $0333	                ora $0333
5521	.dc3d	9d 00 86	sta $8600,x	                sta L8600,x
5522	.dc40	ad 30 03	lda $0330	                lda $0330
5523	.dc43	9d 00 87	sta $8700,x	                sta L8700,x
5524	.dc46					LDC46:
5525	.dc46	18		clc		                clc
5526	.dc47					LDC47:
5527	.dc47	60		rts		                rts

5529	.dc48					LDC48:
5530	.dc48	8d 2a 03	sta $032a	                sta $032A
5531	.dc4b	a2 28		ldx #$28	                ldx #$28
5532	.dc4d	20 b0 dc	jsr $dcb0	                jsr LDCB0
5533	.dc50	d0 0a		bne $dc5c	                bne LDC5C
5534	.dc52					LDC52:
5535	.dc52	20 1c dc	jsr $dc1c	                jsr LDC1C
5536	.dc55	b0 f0		bcs $dc47	                bcs LDC47
5537	.dc57	20 f7 9d	jsr $9df7	                jsr L9D57
5538	.dc5a	b0 ea		bcs $dc46	                bcs LDC46
5539	.dc5c					LDC5C:
5540	.dc5c	20 c1 dc	jsr $dcc1	                jsr LDCC1
5541	.dc5f	20 f7 9d	jsr $9df7	                jsr L9D57
5542	.dc62	b0 e2		bcs $dc46	                bcs LDC46
5543	.dc64	20 d7 dc	jsr $dcd7	                jsr LDCD7
5544	.dc67	20 b8 dc	jsr $dcb8	                jsr LDCB8
5545	.dc6a	80 e6		bra $dc52	                bra LDC52

5547						;-------------------------------------------------------------------------
5548						;
5549						; 72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
5550						; 88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
5551						; 104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
5552						; 120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
5553						;
5554	.dc6c					plotHorizontalLineFill:
5555	.dc6c	20 9f dd	jsr $dd9f	                jsr copyECFPatternForLineFill
5556	.dc6f	20 b0 dc	jsr $dcb0	                jsr LDCB0
5557	.dc72	18		clc		                clc
5558	.dc73	80 0e		bra $dc83	                bra LDC83

5560	.dc75					plotHorizontalLineFillRight:
5561	.dc75	20 9f dd	jsr $dd9f	                jsr copyECFPatternForLineFill
5562	.dc78	20 c9 dc	jsr $dcc9	                jsr LDCC9
5563	.dc7b	20 d2 dc	jsr $dcd2	                jsr LDCD2
5564	.dc7e	d0 03		bne $dc83	                bne LDC83
5565	.dc80	20 b8 dc	jsr $dcb8	                jsr LDCB8
5566	.dc83					LDC83:
5567	.dc83	08		php		                php
5568	.dc84	a2 2e		ldx #$2e	                ldx #VDUVariables.hlfw.pixelsX
5569	.dc86	a0 14		ldy #$14	                ldy #VDUVariables.oldGraphicsCursorPixelsX
5570	.dc88	20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
5571	.dc8b	28		plp		                plp
5572	.dc8c	08		php		                php
5573	.dc8d	f0 02		beq $dc91	                beq LDC91
5574	.dc8f	a2 2e		ldx #$2e	                ldx #VDUVariables.hlfw.pixelsX
5575	.dc91					LDC91:
5576	.dc91	a0 24		ldy #$24	                ldy #VDUVariables.graphicsCursorPixelsX
5577	.dc93	20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
5578	.dc96	a2 30		ldx #$30	                ldx #VDUVariables.hlfw.pixelsY
5579	.dc98	20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
5580	.dc9b	28		plp		                plp
5581	.dc9c	f0 05		beq $dca3	                beq LDCA3
5582	.dc9e	b0 04		bcs $dca4	                bcs LDCA4
5583	.dca0	ee 16 03	inc $0316	                inc $0316
5584	.dca3					LDCA3:
5585	.dca3	60		rts		                rts

5587	.dca4					LDCA4:
5588	.dca4	ad 24 03	lda $0324	                lda $0324
5589	.dca7	d0 03		bne $dcac	                bne LDCAC
5590	.dca9	ce 25 03	dec $0325	                dec $0325
5591	.dcac					LDCAC:
5592	.dcac	ce 24 03	dec $0324	                dec $0324
5593	.dcaf	60		rts		                rts

5595						;-------------------------------------------------------------------------

5597	.dcb0					LDCB0:
5598	.dcb0	20 d2 dc	jsr $dcd2	                jsr LDCD2
5599	.dcb3	d0 55		bne $dd0a	                bne rtsDD0A
5600	.dcb5	20 0b dd	jsr $dd0b	                jsr LDD0B
5601	.dcb8					LDCB8:
5602	.dcb8	a2 2e		ldx #$2e	                ldx #$2E
5603	.dcba	a0 32		ldy #$32	                ldy #$32
5604	.dcbc	20 e8 da	jsr $dae8	                jsr LDAE8
5605	.dcbf	80 46		bra $dd07	                bra LDD07

5607	.dcc1					LDCC1:
5608	.dcc1	20 c9 dc	jsr $dcc9	                jsr LDCC9
5609	.dcc4	a2 2c		ldx #$2c	                ldx #$2C
5610	.dcc6	20 d9 dc	jsr $dcd9	                jsr LDCD9
5611	.dcc9					LDCC9:
5612	.dcc9	08		php		                php
5613	.dcca	a5 e1		lda $e1		                lda $E1
5614	.dccc	49 08		eor #$08	                eor #$08
5615	.dcce	85 e1		sta $e1		                sta $E1
5616	.dcd0	28		plp		                plp
5617	.dcd1	60		rts		                rts

5619						;-------------------------------------------------------------------------

5621	.dcd2					LDCD2:
5622	.dcd2	a0 2e		ldy #$2e	                ldy #VDUVariables.hlfw.pixelsX
5623	.dcd4	20 1e c9	jsr $c91e	                jsr copyFourBytesWithinVDUVariables
5624	.dcd7					LDCD7:
5625	.dcd7	a2 04		ldx #$04	                ldx #VDUVariables.graphicsWindowPixelsRight
5626	.dcd9					LDCD9:
5627	.dcd9	a0 34		ldy #$34	                ldy #VDUVariables.hlfw.pixelsLimitX
5628	.dcdb	20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables
5629	.dcde	a2 34		ldx #$34	                ldx #VDUVariables.hlfw.pixelsLimitX
5630	.dce0	20 35 dd	jsr $dd35	                jsr shouldFillPixel
5631	.dce3	d0 25		bne $dd0a	                bne rtsDD0A  ;taken if pixel not to be filled, so done
5632	.dce5					LDCE5:
5633	.dce5	46 d1		lsr $d1		                lsr ZMASK                    ;next pixel
5634	.dce7	90 08		bcc $dcf1	                bcc LDCF1                    ;taken if still in same byte
5635	.dce9					LDCE9:
5636	.dce9	20 67 da	jsr $da67	                jsr nextColumnAndResetMask
5637	.dcec	20 65 dd	jsr $dd65	                jsr shouldFillByte
5638	.dcef	b0 f8		bcs $dce9	                bcs LDCE9
5639	.dcf1					LDCF1:
5640	.dcf1	20 85 dd	jsr $dd85	                jsr LDD85
5641	.dcf4	b0 ef		bcs $dce5	                bcs LDCE5
5642	.dcf6	38		sec		                sec
5643	.dcf7	ad 34 03	lda $0334	                lda vduv.hlfw.pixelsLimitX+0
5644	.dcfa	e5 de		sbc $de		                sbc zhlfw.pixelsX+0
5645	.dcfc	8d 32 03	sta $0332	                sta vduv.hlfw.pixelsRightEndX+0
5646	.dcff	ad 35 03	lda $0335	                lda vduv.hlfw.pixelsLimitX+1
5647	.dd02	e5 df		sbc $df		                sbc zhlfw.pixelsX+1
5648	.dd04	8d 33 03	sta $0333	                sta vduv.hlfw.pixelsRightEndX+1
5649	.dd07					LDD07:
5650	.dd07	a9 00		lda #$00	                lda #$00
5651	.dd09	38		sec		                sec
5652	.dd0a					rtsDD0A:
5653	.dd0a	60		rts		                rts

5655	.dd0b					LDD0B:
5656	.dd0b	a2 00		ldx #$00	                ldx #VDUVariables.graphicsWindowPixelsLeft
5657	.dd0d	20 35 dd	jsr $dd35	                jsr shouldFillPixel
5658	.dd10	d0 f8		bne $dd0a	                bne rtsDD0A                    ;taken if pixel not to be filled, so done
5659	.dd12					LDD12:
5660	.dd12	06 d1		asl $d1		                asl ZMASK                      ;next pixel
5661	.dd14	90 08		bcc $dd1e	                bcc LDD1E                    ;taken if still in same byte
5662	.dd16					LDD16:
5663	.dd16	20 34 da	jsr $da34	                jsr previousColumnAndResetMask
5664	.dd19	20 65 dd	jsr $dd65	                jsr shouldFillByte
5665	.dd1c	b0 f8		bcs $dd16	                bcs LDD16
5666	.dd1e					LDD1E:
5667	.dd1e	20 85 dd	jsr $dd85	                jsr LDD85
5668	.dd21	b0 ef		bcs $dd12	                bcs LDD12
5669	.dd23	ad 00 03	lda $0300	                lda vduv.graphicsWindowPixelsLeft+0
5670	.dd26	65 de		adc $de		                adc zhlfw.pixelsX+0
5671	.dd28	8d 2e 03	sta $032e	                sta vduv.hlfw.pixelsX+0
5672	.dd2b	ad 01 03	lda $0301	                lda vduv.graphicsWindowPixelsLeft+1
5673	.dd2e	65 df		adc $df		                adc zhlfw.pixelsX+1
5674	.dd30	8d 2f 03	sta $032f	                sta vduv.hlfw.pixelsX+1
5675	.dd33	80 d2		bra $dd07	                bra LDD07

5677						;-------------------------------------------------------------------------
5678						;
5679						; Check whether line fill should fill a pixel.
5680						;
5681						; entry:
5682						;
5683						; X = VDU variable offset of edge of window
5684						;
5685						; vduv.workspace._2E - pixel X, Y coordinates
5686						;
5687						; exit:
5688						;
5689						; Z=1 if pixel should be filled
5690						;
5691						; ZTEMPC = ???
5692						;
5693	.dd35					shouldFillPixel:
5694	.dd35	38		sec		                sec
5695	.dd36	ad 2e 03	lda $032e	                lda vduv.workspace._2E+0
5696	.dd39	fd 00 03	sbc $0300,x	                sbc vduv+0,x
5697	.dd3c	a8		tay		                tay
5698	.dd3d	ad 2f 03	lda $032f	                lda vduv.workspace._2E+1
5699	.dd40	fd 01 03	sbc $0301,x	                sbc vduv+1,x
5700	.dd43	10 03		bpl $dd48	                bpl +
5701	.dd45	20 2e c9	jsr $c92e	                jsr negateAY
5702	.dd48					+
5703	.dd48	84 de		sty $de		                sty zhlfw.pixelsX+0
5704	.dd4a	85 df		sta $df		                sta zhlfw.pixelsX+1
5705	.dd4c	a2 2e		ldx #$2e	                ldx #VDUVariables.workspace._2E
5706	.dd4e	20 c3 de	jsr $dec3	                jsr windGADDR
5707	.dd51	18		clc		                clc
5708	.dd52	d0 10		bne $dd64	                bne rtsDD64                    ;taken if point outside window
5709	.dd54	b1 d6		lda ($d6),y	                lda (ZMEMG),y                  ;get screen byte
5710	.dd56	5d 30 88	eor $8830,x	                eor andy.hlfw.ecfPattern,x     ;EOR with appropriate pattern
5711	.dd59	85 da		sta $da		                sta zhlfw.notByteMatch ;0 if whole byte matches
5712	.dd5b	25 d1		and $d1		                and ZMASK                      ;0 if masked byte matches
5713	.dd5d	f0 02		beq $dd61	                beq +              ;taken if masked byte matches - A=0
5714	.dd5f	a9 08		lda #$08	                lda #$08              ;masked byte doesn't match - A=8
5715	.dd61					+
5716	.dd61	45 e1		eor $e1		                eor zhlfw.resultEOR ;maybe invert result
5717	.dd63	38		sec		                sec
5718	.dd64					rtsDD64:
5719	.dd64	60		rts		                rts

5721						;-------------------------------------------------------------------------

5723	.dd65					shouldFillByte:
5724	.dd65	b1 d6		lda ($d6),y	                lda (ZMEMG),y
5725	.dd67	5d 30 88	eor $8830,x	                eor andy.hlfw.ecfPattern,x
5726	.dd6a	85 da		sta $da		                sta zhlfw.notByteMatch
5727	.dd6c	05 e1		ora $e1		                ora zhlfw.resultEOR
5728	.dd6e	18		clc		                clc
5729	.dd6f	d0 13		bne $dd84	                bne rtsDD84
5730	.dd71	a5 de		lda $de		                lda zhlfw.pixelsX+0
5731	.dd73	ed 61 03	sbc $0361	                sbc vduv.pixelsPerByteMinusOne
5732	.dd76	48		pha		                pha
5733	.dd77	a5 df		lda $df		                lda zhlfw.pixelsX+1
5734	.dd79	e9 00		sbc #$00	                sbc #$00
5735	.dd7b	90 06		bcc $dd83	                bcc pla_rts_DD83             ;taken if past X=0
5736	.dd7d	85 df		sta $df		                sta zhlfw.pixelsX+1
5737	.dd7f	68		pla		                pla
5738	.dd80	85 de		sta $de		                sta zhlfw.pixelsX+0
5739	.dd82	60		rts		                rts

5741	.dd83					pla_rts_DD83:
5742	.dd83	68		pla		                pla
5743	.dd84					rtsDD84:
5744	.dd84	60		rts		                rts

5746						;-------------------------------------------------------------------------

5748	.dd85					LDD85:
5749	.dd85	a5 da		lda $da		                lda zhlfw.notByteMatch
5750	.dd87	25 d1		and $d1		                and ZMASK
5751	.dd89	f0 02		beq $dd8d	                beq +
5752	.dd8b	a9 08		lda #$08	                lda #$08
5753	.dd8d					+
5754	.dd8d	45 e1		eor $e1		                eor zhlfw.resultEOR
5755	.dd8f	d0 0d		bne $dd9e	                bne rtsDD9E

5757						                ; pixelsX -= 1
5758	.dd91	a5 de		lda $de		                lda zhlfw.pixelsX+0
5759	.dd93	d0 06		bne $dd9b	                bne +
5760	.dd95	a5 df		lda $df		                lda zhlfw.pixelsX+1
5761	.dd97	f0 05		beq $dd9e	                beq rtsDD9E
5762	.dd99	c6 df		dec $df		                dec zhlfw.pixelsX+1
5763	.dd9b					+
5764	.dd9b	c6 de		dec $de		                dec zhlfw.pixelsX+0
5765	.dd9d	38		sec		                sec
5766	.dd9e					rtsDD9E:
5767	.dd9e	60		rts		                rts

5769						;-------------------------------------------------------------------------
5770						;
5771						; Copy appropriate ECF pattern for line fill.
5772						;
5773						; entry:
5774						;
5775						; A = horizontal line fill PLOT code
5776						;
5777						; exit:
5778						;
5779						; andy.hlfw.ecfPattern = holds bg/fg ECF pattern as required
5780						;
5781						; ZTEMPD?1 = 0 for fill to matching, 8 to fill to non-matching
5782						;
5783	.dd9f					copyECFPatternForLineFill:
5784	.dd9f	4a		lsr a		                lsr a                        ;36-39; 44-47; 52-55; 60-63
5785	.dda0	4a		lsr a		                lsr a                        ;18-19; 42-43; 26-27; 30-31
5786	.dda1					LDDA1:
5787	.dda1	29 08		and #$08	                and #$08                     ;8 if PLOT >= 104
5788	.dda3	85 e1		sta $e1		                sta zhlfw.resultEOR
5789	.dda5	49 0f		eor #$0f	                eor #$0F                     ;
5790	.dda7	aa		tax		                tax
5791	.dda8	a0 07		ldy #$07	                ldy #$07
5792	.ddaa					-
5793	.ddaa	bd 20 88	lda $8820,x	                lda andy.currentECFPatterns,x
5794	.ddad	99 30 88	sta $8830,y	                sta andy.hlfw.ecfPattern,y
5795	.ddb0	ca		dex		                dex
5796	.ddb1	88		dey		                dey
5797	.ddb2	10 f6		bpl $ddaa	                bpl -
5798	.ddb4	a2 20		ldx #$20	                ldx #VDUVariables.queueEnd-4
5799	.ddb6	60		rts		                rts

5801						;-------------------------------------------------------------------------
5802						;
5803						;
5804						; entry:
5805						;
5806						; A = offset into VDU variables of coordinates
5807						;
5808						; exit:
5809						;
5810						; A = colour, or $ff if off screen/teletext (as per OSWORD $09)
5811						;
5812	.ddb7					readPixelColour: .proc
5813	.ddb7	20 fa c0	jsr $c0fa	                jsr stopCursorEditing
5814	.ddba	ae 61 03	ldx $0361	                ldx vduv.pixelsPerByteMinusOne
5815	.ddbd	f0 21		beq $dde0	                beq invalid             ;taken if teletext
5816	.ddbf	48		pha		                pha
5817	.ddc0	aa		tax		                tax
5818	.ddc1	20 de d1	jsr $d1de	                jsr eigabsEntryPoint
5819	.ddc4	fa		plx		                plx
5820	.ddc5	20 c3 de	jsr $dec3	                jsr windGADDR
5821	.ddc8	d0 16		bne $dde0	                bne invalid             ;taken if off screen
5822	.ddca	b1 d6		lda ($d6),y	                lda (ZMEMG),y
5823	.ddcc	64 da		stz $da		                stz ZTEMP+0
5824	.ddce	80 01		bra $ddd1	                bra shiftMask

5826						                ; Keep shifting the byte and the mask. When a 1 bit is
5827						                ; shifted out of the mask, shift the corresponding
5828						                ; byte bit bit into ZTEMP+0, building up the pixel
5829						                ; colour a bit at a time.
5830						                ;
5831						                ; When the mask becomes 0, done.
5832	.ddd0					shiftByteAndMask:
5833	.ddd0	0a		asl a		                asl a
5834	.ddd1					shiftMask:
5835	.ddd1	06 d1		asl $d1		                asl ZMASK
5836	.ddd3	90 fb		bcc $ddd0	                bcc shiftByteAndMask
5837	.ddd5	0a		asl a		                asl a
5838	.ddd6	26 da		rol $da		                rol ZTEMP+0
5839	.ddd8	a6 d1		ldx $d1		                ldx ZMASK
5840	.ddda	d0 f5		bne $ddd1	                bne shiftMask
5841	.dddc	a5 da		lda $da		                lda ZTEMP+0
5842	.ddde	80 02		bra $dde2	                bra done

5844	.dde0					invalid:
5845	.dde0	a9 ff		lda #$ff	                lda #$FF
5846	.dde2					done:
5847	.dde2	4c ca c0	jmp $c0ca	                jmp reinstateCursorEditing
5848						                .endproc

5850						;-------------------------------------------------------------------------
5851						;
5852						; Translate ASCII char to the SAA5050 character set.
5853						;
5854						; # ($23) becomes $5f
5855						; _ ($5f) becomes $60
5856						; GBP ($60) becomes $23
5857						;
5858						; Because the mapping is a kind of cycle, you can call this routine
5859						; twice to translate from SAA5050 to ASCII.
5860						;
5861						; entry:
5862						;
5863						; A = ASCII char
5864						;
5865						; exit:
5866						;
5867						; A = SAA550 char
5868						;
5869	.dde5					getSAA5050FromASCII: .block
5870	.dde5	c9 23		cmp #$23	                cmp #$23
5871	.dde7	f0 0a		beq $ddf3	                beq translateHash
5872	.dde9	c9 5f		cmp #$5f	                cmp #$5F
5873	.ddeb	f0 08		beq $ddf5	                beq translateUnderscore
5874	.dded	c9 60		cmp #$60	                cmp #$60
5875	.ddef	d0 06		bne $ddf7	                bne rtsDDF7
5876	.ddf1					translateGBP:
5877	.ddf1	49 3f		eor #$3f	                eor #$3F                     ;0x60->0x5f
5878	.ddf3					translateHash:
5879	.ddf3	49 43		eor #$43	                eor #$43                     ;0x23->0x5f or 0x5f->0x1c
5880	.ddf5					translateUnderscore:
5881	.ddf5	49 3f		eor #$3f	                eor #$3F                     ;0x5f->0x60 or 0x1c->0x23
5882	.ddf7					rtsDDF7:
5883	.ddf7	60		rts		                rts
5884						                .endblock

5886						;-------------------------------------------------------------------------

5888	.ddf8					readCharacterAtTextCursor: .proc
5889	.ddf8	58		cli		                cli
5890	.ddf9	24 d0		bit $d0		                bit STATE
5891	.ddfb	50 06		bvc $de03	                bvc +                      ;taken if not cursor editing
5892	.ddfd	20 fa c0	jsr $c0fa	                jsr stopCursorEditing
5893	.de00	20 d1 c0	jsr $c0d1	                jsr exchangeCursors
5894	.de03					+
5895	.de03	ac 60 03	ldy $0360	                ldy vduv.numberOfLogicalColoursMinusOne
5896	.de06	d0 17		bne $de1f	                bne bitmapMode
5897	.de08					readTeletextChar:
5898	.de08	b2 d8		lda ($d8)	                lda (ZMEMT)                  ;read character from screen
5899	.de0a	20 e5 dd	jsr $dde5	                jsr getSAA5050FromASCII      ;call 2x to convert to ASCII
5900	.de0d	20 e5 dd	jsr $dde5	                jsr getSAA5050FromASCII      ;call 2x to convert to ASCII
5901	.de10					done:
5902	.de10	24 d0		bit $d0		                bit STATE
5903	.de12	50 06		bvc $de1a	                bvc +                     ;taken if not cursor editing
5904	.de14	20 d1 c0	jsr $c0d1	                jsr exchangeCursors
5905	.de17	20 ca c0	jsr $c0ca	                jsr reinstateCursorEditing
5906	.de1a					+
5907	.de1a	ac 55 03	ldy $0355	                ldy vduv.currentScreenMODE
5908	.de1d	aa		tax		                tax
5909	.de1e	60		rts		                rts

5911	.de1f					bitmapMode:
5912	.de1f	20 56 de	jsr $de56	                jsr LDE56
5913	.de22	a5 f4		lda $f4		                lda $F4
5914	.de24	48		pha		                pha
5915	.de25	20 98 e5	jsr $e598	                jsr selectTerminalROMAndANDY
5916	.de28	a9 20		lda #$20	                lda #$20
5917	.de2a	aa		tax		                tax                          ;X = ASCII code for char
5918	.de2b	20 3c e2	jsr $e23c	                jsr getSoftCharacterDefinitionAddress
5919	.de2e					compare:
5920	.de2e	a0 07		ldy #$07	                ldy #$07
5921	.de30					-
5922	.de30	b9 28 03	lda $0328,y	                lda vduv.workspace._28,y
5923	.de33	51 de		eor ($de),y	                eor (ZTEMPC),y
5924	.de35	d0 0a		bne $de41	                bne nextFontChar ;taken if no match - can't be this char
5925	.de37	88		dey		                dey
5926	.de38	10 f6		bpl $de30	                bpl -

5928	.de3a	8a		txa		                txa                          ;A = char found
5933	.de3b					bitmapModeDone:
5934	.de3b	fa		plx		                plx
5935	.de3c	20 9a e5	jsr $e59a	                jsr selectROMX
5936	.de3f	80 cf		bra $de10	                bra done

5938	.de41					nextFontChar:
5939	.de41	e8		inx		                inx                          ;next ASCII code
5947	.de42	18		clc		                clc
5948	.de43	a5 de		lda $de		                lda ZTEMPC+0
5949	.de45	69 08		adc #$08	                adc #$08                     ;8 bytes/font char
5950	.de47	85 de		sta $de		                sta ZTEMPC+0
5951	.de49	90 02		bcc $de4d	                bcc gotCharAddress
5952	.de4b	e6 df		inc $df		                inc ZTEMPC+1
5954	.de4d					gotCharAddress:
5955	.de4d	e0 7f		cpx #$7f	                cpx #$7F
5956	.de4f	f0 f0		beq $de41	                beq nextFontChar                 ;skip CHR$127
5957	.de51	8a		txa		                txa
5958	.de52	d0 da		bne $de2e	                bne compare           ;taken if more chars to consider
5959	.de54	80 e5		bra $de3b	                bra bitmapModeDone ;finish with A=0 - i.e., no match found
5960						                .endproc

5962						;-------------------------------------------------------------------------
5963						;
5964						; Copy character out of screen memory, and store as a 1 bpp bitmap in
5965						; VDU variables workspace.
5966						;
5967	.de56					LDE56: .proc
5968	.de56	a6 d8		ldx $d8		                ldx ZMEMT+0
5969	.de58	a5 d9		lda $d9		                lda ZMEMT+1
5970	.de5a	20 d9 ce	jsr $ced9	                jsr getNext3ColumnAddresses
5971	.de5d	a0 07		ldy #$07	                ldy #$07
5972	.de5f					loop:
5973	.de5f	ae 60 03	ldx $0360	                ldx vduv.numberOfLogicalColoursMinusOne
5974	.de62	e0 03		cpx #$03	                cpx #$03
5975	.de64	f0 09		beq $de6f	                beq read2bppChar
5976	.de66	b0 13		bcs $de7b	                bcs read4bppChar
5977	.de68					read1bppChar:
5978	.de68	b1 d8		lda ($d8),y	                lda (ZMEMT),y
5979	.de6a	4d 58 03	eor $0358	                eor vduv.backgroundTextColour
5980	.de6d	80 22		bra $de91	                bra next

5982	.de6f					read2bppChar:
5983	.de6f	b1 d8		lda ($d8),y	                lda (ZMEMT),y                ;get pixels 0-3
5984	.de71	20 a2 de	jsr $dea2	                jsr get4Pixels
5985	.de74	b1 da		lda ($da),y	                lda (ZTEMP),y                  ;get pixels 4-7
5986	.de76	20 a2 de	jsr $dea2	                jsr get4Pixels
5987	.de79	80 14		bra $de8f	                bra LDE8F

5989	.de7b					read4bppChar:
5990	.de7b	b1 d8		lda ($d8),y	                lda (ZMEMT),y                ;get pixels 0/1
5991	.de7d	20 98 de	jsr $de98	                jsr get2Pixels
5992	.de80	b1 da		lda ($da),y	                lda (ZTEMP),y                ;get pixels 2/3
5993	.de82	20 98 de	jsr $de98	                jsr get2Pixels
5994	.de85	b1 dc		lda ($dc),y	                lda (ZTEMPB),y               ;get pixels 4/5
5995	.de87	20 98 de	jsr $de98	                jsr get2Pixels
5996	.de8a	b1 e0		lda ($e0),y	                lda (ZTEMPD),y               ;get pixels 6/7
5997	.de8c	20 98 de	jsr $de98	                jsr get2Pixels
5998	.de8f					LDE8F:
5999	.de8f	a5 df		lda $df		                lda ZTEMPC+1
6000	.de91					next:
6001	.de91	99 28 03	sta $0328,y	                sta vduv.workspace._28,y
6002	.de94	88		dey		                dey
6003	.de95	10 c8		bpl $de5f	                bpl loop
6004	.de97	60		rts		                rts

6006	.de98					get2Pixels:
6007	.de98	4d 58 03	eor $0358	                eor vduv.backgroundTextColour ;reset background pixel bits
6008	.de9b	20 b5 de	jsr $deb5	                jsr or2Pixels
6009	.de9e	29 03		and #$03	                and #%00000011               ;2 pixels/byte
6010	.dea0	80 0c		bra $deae	                bra shiftIn2

6012	.dea2					get4Pixels:
6013	.dea2	4d 58 03	eor $0358	                eor vduv.backgroundTextColour ;
6014	.dea5	20 ba de	jsr $deba	                jsr or4Pixels
6015	.dea8	29 0f		and #$0f	                and #%00001111               ;4 pixels/byte

6017						                ; Build up the 1bpp char row in ZTEMPC?1, 2 or 4 bits
6018						                ; at a time.
6019	.deaa	06 df		asl $df		                asl ZTEMPC+1
6020	.deac	06 df		asl $df		                asl ZTEMPC+1
6021	.deae					shiftIn2:
6022	.deae	06 df		asl $df		                asl ZTEMPC+1
6023	.deb0	06 df		asl $df		                asl ZTEMPC+1
6024	.deb2	04 df		tsb $df		                tsb ZTEMPC+1
6025	.deb4	60		rts		                rts

6027						                ; OR together all the N bits for each pixel, making a
6028						                ; byte in which the bottom N bits have a bit set for
6029						                ; each non-0 pixel in the byte.
6030	.deb5					or2Pixels:
6031	.deb5	85 de		sta $de		                sta ZTEMPC+0
6032	.deb7	20 be de	jsr $debe	                jsr shiftOut2
6033	.deba					or4Pixels:
6034	.deba	85 de		sta $de		                sta ZTEMPC+0                 ;%abcdABCD
6035	.debc	4a		lsr a		                lsr a                        ;%0abcdABC
6036	.debd	4a		lsr a		                lsr a                        ;%00abcdAB
6037	.debe					shiftOut2:
6038	.debe	4a		lsr a		                lsr a                        ;%000abcdA
6039	.debf	4a		lsr a		                lsr a                        ;%0000abcd
6040	.dec0	05 de		ora $de		                ora ZTEMPC+0                 ;%0000abcd|%abcdABCD
6041						                .endproc
6042	.dec2					rtsDEC2:
6043	.dec2	60		rts		                rts

6045						;-------------------------------------------------------------------------
6046						;
6047						; Do WIND. If point not in window, return with Z=0. Otherwise, call
6048						; GADDR and return with Z=1.
6049						;
6050	.dec3					windGADDR:
6051	.dec3	20 a8 d1	jsr $d1a8	                jsr windEntryPoint
6052	.dec6	d0 fa		bne $dec2	                bne rtsDEC2                  ;taken if point outside window
6053	.dec8					gaddrEntryPoint:
6054	.dec8	bd 02 03	lda $0302,x	                lda vduv+2,x                 ;get Y coordinate
6055	.decb					LDECB:
6056	.decb	49 ff		eor #$ff	                eor #$FF                     ;invert Y coordinate
6057	.decd	a8		tay		                tay                          ;Y=Y coordinate
6058	.dece	29 07		and #$07	                and #$07                ;get scanline in character row
6059	.ded0	85 da		sta $da		                sta ZTEMP+0             ;save scanline
6060	.ded2	98		tya		                tya                          ;A=Y coordinate
6061	.ded3	29 f8		and #$f8	                and #$F8                     ;row*8
6062	.ded5	4a		lsr a		                lsr a                        ;row*4
6063	.ded6	85 d7		sta $d7		                sta ZMEMG+1                  ;>(row*1024)
6064	.ded8	4a		lsr a		                lsr a                        ;>(row*512)
6065	.ded9	4a		lsr a		                lsr a                        ;>(row*256)
6066	.deda	65 d7		adc $d7		                adc ZMEMG+1                  ;>(row*1280)
6067	.dedc	4a		lsr a		                lsr a                        ;>(row*640)
6068	.dedd	85 d7		sta $d7		                sta ZMEMG+1                  ;
6069	.dedf	a9 00		lda #$00	                lda #$00                     ;
6070	.dee1	6a		ror a		                ror a                        ;<(row*640) - $00/$80
6071	.dee2	ac 56 03	ldy $0356	                ldy vduv.currentScreenMODEGroup
6072	.dee5	f0 03		beq $deea	                beq +                      ;taken if 640 bytes per row
6073	.dee7	46 d7		lsr $d7		                lsr ZMEMG+1                ;>(row*320)
6074	.dee9	6a		ror a		                ror a                    ;<(row*320) - $00/$40/$80/$c0
6075	.deea					+
6076	.deea	05 da		ora $da		                ora ZTEMP+0               ;include the scanline offset
6077	.deec	6d 50 03	adc $0350	                adc vduv.screenTopLeftAddress+0 ;include LSB of screen base
6078	.deef	8d 1a 03	sta $031a	                sta vduv.graphicsAddressOffset

6080						                ; add MSB of screen base to ZMEMG+1
6081	.def2	a5 d7		lda $d7		                lda ZMEMG+1
6082	.def4	6d 51 03	adc $0351	                adc vduv.screenTopLeftAddress+1
6083	.def7	85 d7		sta $d7		                sta ZMEMG+1

6085	.def9	bd 01 03	lda $0301,x	                lda vduv+1,x                 ;get >X
6086	.defc	85 d6		sta $d6		                sta ZMEMG+0                  ;save >X
6087	.defe	bd 00 03	lda $0300,x	                lda vduv+0,x                 ;get <X
6088	.df01	2d 61 03	and $0361	                and vduv.pixelsPerByteMinusOne ;index for pixel
6089	.df04	6d 61 03	adc $0361	                adc vduv.pixelsPerByteMinusOne ;offset into pixel mask table
6090	.df07	a8		tay		                tay
6091	.df08	b9 3e e1	lda $e13e,y	                lda pixelMasks-1,y
6092	.df0b	85 d1		sta $d1		                sta ZMASK

6094						                ; Form 16-bit column address offset (LSB in A, MSB in
6095						                ; ZMEMG+0), assuming 8 bits/pixel. No adjustment
6096						                ; needed if MODE 0/4, but scale up by 2 if MODE 1/5 or
6097						                ; 4 if MODE 2.

6099	.df0d	bd 00 03	lda $0300,x	                lda vduv+0,x                 ;A = <X
6100	.df10	ac 61 03	ldy $0361	                ldy vduv.pixelsPerByteMinusOne
6101	.df13	c0 03		cpy #$03	                cpy #$03
6102	.df15	f0 05		beq $df1c	                beq LDF1C         ;taken if 4 px/byte - i.e., MODE 1/5
6103	.df17	b0 06		bcs $df1f	                bcs LDF1F        ;taken if >4 px/byte - i.e., MODE 0/4
6104	.df19	0a		asl a		                asl a
6105	.df1a	26 d6		rol $d6		                rol ZMEMG+0
6106	.df1c					LDF1C:
6107	.df1c	0a		asl a		                asl a
6108	.df1d	26 d6		rol $d6		                rol ZMEMG+0
6109	.df1f					LDF1F:
6110	.df1f	29 f8		and #$f8	                and #$F8                     ;<column offset
6111	.df21	18		clc		                clc
6112	.df22	6d 1a 03	adc $031a	                adc vduv.graphicsAddressOffset
6113	.df25	8d 1a 03	sta $031a	                sta vduv.graphicsAddressOffset
6114	.df28	a5 d6		lda $d6		                lda ZMEMG+0                  ;>column offset
6115	.df2a	65 d7		adc $d7		                adc ZMEMG+1                  ;add to address MSB
6116	.df2c	10 04		bpl $df32	                bpl +                        ;taken if no wrap
6117	.df2e	38		sec		                sec
6118	.df2f	ed 54 03	sbc $0354	                sbc vduv.screenSizeHighByte ;handle wrap at end of screen
6119	.df32					+
6120	.df32	85 d7		sta $d7		                sta ZMEMG+1                  ;got MSB
6121	.df34	64 d6		stz $d6		                stz ZMEMG+0 ;LSB always 0 - the offset takes care of this
6122	.df36	a6 da		ldx $da		                ldx ZTEMP+0 ;get scanline in row
6123	.df38	20 7c da	jsr $da7c	                jsr setupColourMasks
6124	.df3b	ac 1a 03	ldy $031a	                ldy vduv.graphicsAddressOffset
6125	.df3e					ldaim00_rts_DF3E:
6126	.df3e	a9 00		lda #$00	                lda #$00                     ;return with Z=1, as per WIND
6127	.df40	60		rts		                rts

6129						;-------------------------------------------------------------------------

6131	.df41					LDF41:
6132	.df41	20 c8 de	jsr $dec8	                jsr gaddrEntryPoint
6133	.df44	da		phx		                phx
6134	.df45	a2 00		ldx #$00	                ldx #$00
6135	.df47	ad 5a 03	lda $035a	                lda $035A
6136	.df4a	c9 04		cmp #$04	                cmp #$04
6137	.df4c	b0 0b		bcs $df59	                bcs LDF59
6138	.df4e	ae 6a 03	ldx $036a	                ldx $036A
6139	.df51	ad 59 03	lda $0359	                lda $0359
6140	.df54	f0 03		beq $df59	                beq LDF59
6141	.df56	ae 6b 03	ldx $036b	                ldx $036B
6142	.df59					LDF59:
6143	.df59	8e 69 03	stx $0369	                stx $0369
6144	.df5c	fa		plx		                plx
6145	.df5d	60		rts		                rts

6147						;-------------------------------------------------------------------------

6149	.df5e					handleCopyKey:
6150	.df5e	a9 20		lda #$20	                lda #STATE.isVDU5
6151	.df60	24 d0		bit $d0		                bit STATE
6152	.df62	50 da		bvc $df3e	                bvc ldaim00_rts_DF3E      ;taken if not cursor editing
6153	.df64	d0 d8		bne $df3e	                bne ldaim00_rts_DF3E      ;taken if VDU5
6157	.df66	20 f8 dd	jsr $ddf8	                jsr readCharacterAtTextCursor
6163	.df69	f0 0c		beq $df77	                beq rtsDF77              ;taken if char not recognised
6164	.df6b	48		pha		                pha                      ;save char recognised
6165	.df6c	20 d5 df	jsr $dfd5	                jsr isCursorEditingPossible
6166	.df6f	d0 05		bne $df76	                bne pla_rts_DF76
6167	.df71	a9 09		lda #$09	                lda #$09
6168	.df73	20 bc df	jsr $dfbc	                jsr moveEditCursor
6169	.df76					pla_rts_DF76:
6170	.df76	68		pla		                pla
6171	.df77					rtsDF77:
6172	.df77	60		rts		                rts

6174						;-------------------------------------------------------------------------
6175						;
6176						; Handle cursor key press.
6177						;
6178						; Entry: A = one of the cursor key codes:
6179						;            $88 = left
6180						;            $89 = right
6181						;            $8a = down
6182						;            $8b = up

6184	.df78					handleCursorKey:
6185	.df78	48		pha		                pha                          ;save cursor key code
6186	.df79	20 d5 df	jsr $dfd5	                jsr isCursorEditingPossible
6187	.df7c	d0 f8		bne $df76	                bne pla_rts_DF76             ;bail if editing not possible
6188	.df7e	70 16		bvs $df96	                bvs editing                  ;taken if already editing
6189	.df80					beginEditing:
6190	.df80	ad 5f 03	lda $035f	                lda vduv.lastCursorStartRegisterValue
6191	.df83	29 df		and #$df	                and #%11011111
6192	.df85	20 53 cf	jsr $cf53	                jsr setCRTCRegister10        ;hide cursor
6193	.df88	a2 18		ldx #$18	                ldx #VDUVariables.textCursorXPosition
6194	.df8a	a0 64		ldy #$64	                ldy #VDUVariables.editCursorXPosition
6195	.df8c	20 0c c9	jsr $c90c	                jsr copyTwoBytesWithinVDUVariables ;edit cursor pos =
6196						                                                   ;text cursor pos
6197	.df8f	20 05 c1	jsr $c105	                jsr activateEditCursor
6198	.df92	a9 02		lda #$02	                lda #STATE.isScrollingDisabled
6199	.df94	04 d0		tsb $d0		                tsb STATE
6200	.df96					editing:
6201	.df96	68		pla		                pla                          ;restore cursor key code

6203						                ; Form appropriate VDU command (8/9/10/11) for the
6204						                ; key, assuming no VDU axis rearrangement.
6205	.df97	29 7f		and #$7f	                and #$7F
6206	.df99	85 da		sta $da		                sta ZTEMP                    ;save VDU command

6208						                ; Adjust VDU command based on axis swap/inversion.
6209	.df9b	c9 0a		cmp #$0a	                cmp #$0A
6210	.df9d	b0 0e		bcs $dfad	                bcs handleCursorUpOrDown     ;taken if up/down
6211	.df9f					handleCursorLeftOrRightOrCopy:
6212	.df9f	ad 66 03	lda $0366	                lda vduv.cursorFlags
6213	.dfa2	4a		lsr a		                lsr a
6214	.dfa3	29 05		and #$05	                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertHorizontal)>>1
6215	.dfa5	89 04		bit #$04	                bit #vduv.cursorFlags.swapAxes>>1
6216	.dfa7	f0 11		beq $dfba	                beq gotActualMoveCommand

6218	.dfa9	49 07		eor #$07	                eor #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal)>>1
6219	.dfab	80 0d		bra $dfba	                bra gotActualMoveCommand

6221	.dfad					handleCursorUpOrDown:
6222	.dfad	ad 66 03	lda $0366	                lda vduv.cursorFlags
6223	.dfb0	4a		lsr a		                lsr a
6224	.dfb1	4a		lsr a		                lsr a
6225	.dfb2	29 03		and #$03	                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical)>>2 ;000000SV
6226	.dfb4	89 02		bit #$02	                bit #vduv.cursorFlags.swapAxes>>2
6227	.dfb6	f0 02		beq $dfba	                beq gotActualMoveCommand

6229	.dfb8	49 01		eor #$01	                eor #vduv.cursorFlags.invertVertical>>2
6230	.dfba					gotActualMoveCommand:
6231	.dfba	45 da		eor $da		                eor ZTEMP
6232	.dfbc					moveEditCursor:
6233	.dfbc	a8		tay		                tay                          ;save command
6234	.dfbd	a9 40		lda #$40	                lda #STATE.isCursorEditing
6235	.dfbf	14 d0		trb $d0		                trb STATE            ;temporarily disable edit mode
6236	.dfc1	98		tya		                tya                  ;restore command
6237	.dfc2	ae 6c 03	ldx $036c	                ldx vduv.column81
6238	.dfc5	da		phx		                phx                  ;save old column 81 flag
6239	.dfc6	4e 6c 03	lsr $036c	                lsr vduv.column81    ;temporarily reset column 81 flag
6240	.dfc9	20 27 c0	jsr $c027	                jsr outputToVDU      ;print the cursor movement command
6241	.dfcc	68		pla		                pla
6242	.dfcd	8d 6c 03	sta $036c	                sta vduv.column81            ;restore column 81 flag
6243	.dfd0	a9 40		lda #$40	                lda #STATE.isCursorEditing
6244	.dfd2	04 d0		tsb $d0		                tsb STATE                    ;reinstate edit mode
6245	.dfd4	60		rts		                rts

6247						; Check if cursor editing is possible.
6248						;
6249						; Exit: Z=1 - editing is possible
6250						;             V reflects current STATE.isCursorEditing bit
6251						;       Z=0 - editing not possible
6252	.dfd5					isCursorEditingPossible:
6253	.dfd5	ae 6a 02	ldx $026a	                ldx vduQueueNegativeLength
6254	.dfd8	d0 04		bne $dfde	                bne +                        ;return with Z=0 if VDU
6255						                                             ;queue not empty
6256	.dfda	a9 a0		lda #$a0	                lda #STATE.isVDU21|STATE.isVDU5
6257	.dfdc	24 d0		bit $d0		                bit STATE   ;return with Z=0 if neither VDU21 nor VDU5
6258	.dfde					+
6259	.dfde	60		rts		                rts

6261						;-------------------------------------------------------------------------
6262						;
6263						; 184-191 = Move/copy rectangle [MasRef E.3-31]
6264						;
6266	.dfdf					selectExtROMAndPlotMoveOrCopyRectangle:
6267	.dfdf	a2 8f		ldx #$8f	                ldx #$80|extROM   ; select VIEW+ANDY
6268	.dfe1	20 9a e5	jsr $e59a	                jsr selectROMX
6269	.dfe4	20 19 b4	jsr $b419	                jsr plotMoveOrCopyRectangle
6270	.dfe7	80 08		bra $dff1	                bra LDFF1

6273						;-------------------------------------------------------------------------
6274						;
6275						; 192-199 = Plot ellipse outline [MasRef E.3-32]
6276						;
6278	.dfe9					selectExtROMAndPlotEllipseOutline:
6279	.dfe9	a2 8f		ldx #$8f	                ldx #$80|extROM
6280	.dfeb	20 9a e5	jsr $e59a	                jsr selectROMX
6281	.dfee	20 3f af	jsr $af3f	                jsr plotEllipseOutline
6282	.dff1					LDFF1:
6283	.dff1	4c 98 e5	jmp $e598	                jmp selectTerminalROMAndANDY

6286						;-------------------------------------------------------------------------
6287						;
6288						; 200-207 = Plot solid ellipse [MasRef E.3-32]
6289						;
6291	.dff4					selectExtROMAndPlotEllipseFilled:
6292	.dff4	a2 8f		ldx #$8f	                ldx #$80|extROM
6293	.dff6	20 9a e5	jsr $e59a	                jsr selectROMX
6294	.dff9	20 c2 af	jsr $afc2	                jsr plotEllipseFilled
6295	.dffc	80 f3		bra $dff1	                bra LDFF1

6302						;-------------------------------------------------------------------------

6304						; Pretty sure I have the logic for this all wrong...

6307	>dffe					                .align 16
6309	.e000					startupMessages: .block
6311	>e000	00 00 00 00 00 00 00 00		                .fill 16,0
	>e008	00 00 00 00 00 00 00 00

6317	.e010					acornMOS:
6318	>e010	0d				                .text 13

6333	>e011	41 63 6f 72 6e 20 4d 4f		                .text "Acorn MOS"
	>e019	53
6338	>e01a	00				                .byte 0
6339	.e01b					beep:
6340	>e01b	07				                .byte 7
6341	>e01c	00				                .byte 0
6343	>e01d	00 00 00			                .byte 0,0,0   ;space for "xxK"

6346	.e020					twoNewlines:
6347	>e020	08				                .byte 8
6348	>e021	0d				                .byte $0D
6349	>e022	0d				                .byte $0D
6350						                ; terminating 0 comes from following table!
6352						                .endblock
6353	.e023					LE013:
6354	>e023	00				                .byte %00000000;$00
6355	>e024	11				                .byte %00010001;$11
6356	>e025	22				                .byte %00100010;$22
6357	>e026	33				                .byte %00110011;$33
6358	>e027	44				                .byte %01000100;$44
6359	>e028	55				                .byte %01010101;$55
6360	>e029	66				                .byte %01100110;$66
6361	>e02a	77				                .byte %01110111;$77
6362	>e02b	88				                .byte %10001000;$88
6363	>e02c	99				                .byte %10011001;$99
6364	>e02d	aa				                .byte %10101010;$AA
6365	>e02e	bb				                .byte %10111011;$BB
6366	>e02f	cc				                .byte %11001100;$CC
6367	>e030	dd				                .byte %11011101;$DD
6368	>e031	ee				                .byte %11101110;$EE
6369	>e032	ff				                .byte %11111111;$FF
6370	.e033					LE023:
6371	>e033	00				                .byte %00000000;$00
6372	>e034	55				                .byte %01010101;$55
6373	>e035	aa				                .byte %10101010;$AA
6374	>e036	ff				                .byte %11111111;$FF

6376						; VDU control code dispatch tables
6377						; ================================
6378						;
6379						; entry:
6380						;
6381						;

6383						; each routine is (address, number of additional VDU bytes)
6384	=[($c035,0)]				_:=[(vdu0EntryPoint,0)] ; VDU0
6385	=[($c035,0),($c0e2,1)]			_..=[(vdu1EntryPoint,1)] ; VDU1
6386	=[($c035,0),($c0e2,1),($c0ea,0)]	_..=[(vdu2EntryPoint,0)] ; VDU2
6387	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0)]
						_..=[(vdu3EntryPoint,0)] ; VDU3
6388	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0)]
						_..=[(vdu4EntryPoint,0)] ; VDU4
6389	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0)]
						_..=[(vdu5EntryPoint,0)] ; VDU5
6390	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0)]
						_..=[(vdu6EntryPoint,0)] ; VDU6
6391	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0)]
						_..=[(vdu7EntryPoint,0)] ; VDU7
6392	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0)]
						_..=[(vdu8EntryPoint,0)] ; VDU8
6393	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0)]
						_..=[(vdu9EntryPoint,0)] ; VDU9
6394	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0)]
						_..=[(vdu10EntryPoint,0)] ; VDU10
6395	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0)]
						_..=[(vdu11EntryPoint,0)] ; VDU11
6396	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0)]
						_..=[(vdu12EntryPoint,0)] ; VDU12
6397	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0)]
						_..=[(vdu13EntryPoint,0)] ; VDU13
6398	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0)]
						_..=[(vdu14EntryPoint,0)] ; VDU14
6399	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0)]
						_..=[(vdu15EntryPoint,0)] ; VDU15
6400	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0)]
						_..=[(vdu16EntryPoint,0)] ; VDU16
6401	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1)]
						_..=[(vdu17EntryPoint,1)] ; VDU17
6402	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2)]
						_..=[(vdu18EntryPoint,2)] ; VDU18
6403	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5)]
						_..=[(vdu19EntryPoint,5)] ; VDU19
6404	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0)]
						_..=[(vdu20EntryPoint,0)] ; VDU20
6405	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0)]
						_..=[(vdu21EntryPoint,0)] ; VDU21
6406	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1)]
						_..=[(vdu22EntryPoint,1)] ; VDU22
6407	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9)]
						_..=[(vdu23EntryPoint,9)] ; VDU23
6408	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8)]
						_..=[(vdu24EntryPoint,8)] ; VDU24
6409	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5)]
						_..=[(vdu25EntryPoint,5)] ; VDU25
6410	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0)]
						_..=[(vdu26EntryPoint,0)] ; VDU26
6411	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0)]
						_..=[(vdu27EntryPoint,0)] ; VDU27
6412	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4)]
						_..=[(vdu28EntryPoint,4)] ; VDU28
6413	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4),($c78a,4)]
						_..=[(vdu29EntryPoint,4)] ; VDU29
6414	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4),($c78a,4),($c47c,0)]
						_..=[(vdu30EntryPoint,0)] ; VDU30
6415	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4),($c78a,4),($c47c,0),($c482,2)]
						_..=[(vdu31EntryPoint,2)] ; VDU31
6416	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4),($c78a,4),($c47c,0),($c482,2),($ce2d,0)]
						_..=[(vdu127EntryPoint,0)] ; VDU127
6417	=[($c035,0),($c0e2,1),($c0ea,0),($c0ea,0),($c51e,0),($c52d,0),($c035,0),($f067,0),($c29a,0),($c24c,0),($c25b,0),($c2b1,0),($c44f,0),($c3f6,0),($c514,0),($c528,0),($c413,0),($c539,1),($c564,2),($c62d,5),($c5c5,0),($c519,0),($c794,1),($c67c,9),($c71f,8),($c69b,5),($c6aa,0),($c035,0),($c3a5,4),($c78a,4),($c47c,0),($c482,2),($ce2d,0)]
						vdu_routines=_

6419						; LSB of routine address
6420	.e037					vduRoutinesLSBTable:
6421						                .for _i=0,_i<len(vdu_routines),_i+=1
6422	>e037	35				                .byte <vdu_routines[_i][0]
6422	>e038	e2				                .byte <vdu_routines[_i][0]
6422	>e039	ea				                .byte <vdu_routines[_i][0]
6422	>e03a	ea				                .byte <vdu_routines[_i][0]
6422	>e03b	1e				                .byte <vdu_routines[_i][0]
6422	>e03c	2d				                .byte <vdu_routines[_i][0]
6422	>e03d	35				                .byte <vdu_routines[_i][0]
6422	>e03e	67				                .byte <vdu_routines[_i][0]
6422	>e03f	9a				                .byte <vdu_routines[_i][0]
6422	>e040	4c				                .byte <vdu_routines[_i][0]
6422	>e041	5b				                .byte <vdu_routines[_i][0]
6422	>e042	b1				                .byte <vdu_routines[_i][0]
6422	>e043	4f				                .byte <vdu_routines[_i][0]
6422	>e044	f6				                .byte <vdu_routines[_i][0]
6422	>e045	14				                .byte <vdu_routines[_i][0]
6422	>e046	28				                .byte <vdu_routines[_i][0]
6422	>e047	13				                .byte <vdu_routines[_i][0]
6422	>e048	39				                .byte <vdu_routines[_i][0]
6422	>e049	64				                .byte <vdu_routines[_i][0]
6422	>e04a	2d				                .byte <vdu_routines[_i][0]
6422	>e04b	c5				                .byte <vdu_routines[_i][0]
6422	>e04c	19				                .byte <vdu_routines[_i][0]
6422	>e04d	94				                .byte <vdu_routines[_i][0]
6422	>e04e	7c				                .byte <vdu_routines[_i][0]
6422	>e04f	1f				                .byte <vdu_routines[_i][0]
6422	>e050	9b				                .byte <vdu_routines[_i][0]
6422	>e051	aa				                .byte <vdu_routines[_i][0]
6422	>e052	35				                .byte <vdu_routines[_i][0]
6422	>e053	a5				                .byte <vdu_routines[_i][0]
6422	>e054	8a				                .byte <vdu_routines[_i][0]
6422	>e055	7c				                .byte <vdu_routines[_i][0]
6422	>e056	82				                .byte <vdu_routines[_i][0]
6422	>e057	2d				                .byte <vdu_routines[_i][0]
6423						                .next

6425						; If bit 7 set: MSB of routine address
6426						;
6427						; If bit 7 clear:
6428						;
6429						; Top 4 bits are bits 8-11 of routine address (bits 12-15 are %1010,
6430						; so address is $C0xx to $C7xx)
6431						;
6432						; Bottom 4 bits are ORed with $f0 and stored in $26a - -ve bytes left
6433						; in VDU queue.
6434	.e058					vduRoutinesMSBTable:
6435						                .for _i=0,_i<len(vdu_routines),_i+=1
6437	>e058	c0				                .byte >vdu_routines[_i][0]
6441	>e059	0f				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6437	>e05a	c0				                .byte >vdu_routines[_i][0]
6437	>e05b	c0				                .byte >vdu_routines[_i][0]
6437	>e05c	c5				                .byte >vdu_routines[_i][0]
6437	>e05d	c5				                .byte >vdu_routines[_i][0]
6437	>e05e	c0				                .byte >vdu_routines[_i][0]
6437	>e05f	f0				                .byte >vdu_routines[_i][0]
6437	>e060	c2				                .byte >vdu_routines[_i][0]
6437	>e061	c2				                .byte >vdu_routines[_i][0]
6437	>e062	c2				                .byte >vdu_routines[_i][0]
6437	>e063	c2				                .byte >vdu_routines[_i][0]
6437	>e064	c4				                .byte >vdu_routines[_i][0]
6437	>e065	c3				                .byte >vdu_routines[_i][0]
6437	>e066	c5				                .byte >vdu_routines[_i][0]
6437	>e067	c5				                .byte >vdu_routines[_i][0]
6437	>e068	c4				                .byte >vdu_routines[_i][0]
6441	>e069	5f				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6441	>e06a	5e				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6441	>e06b	6b				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6437	>e06c	c5				                .byte >vdu_routines[_i][0]
6437	>e06d	c5				                .byte >vdu_routines[_i][0]
6441	>e06e	7f				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6441	>e06f	67				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6441	>e070	78				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6441	>e071	6b				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6437	>e072	c6				                .byte >vdu_routines[_i][0]
6437	>e073	c0				                .byte >vdu_routines[_i][0]
6441	>e074	3c				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6441	>e075	7c				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6437	>e076	c4				                .byte >vdu_routines[_i][0]
6441	>e077	4e				                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
6437	>e078	ce				                .byte >vdu_routines[_i][0]
6443						                .next

6445						;-------------------------------------------------------------------------
6446						;
6447						; entry:
6448						;
6449						; C=0
6450						;
6451						; A = vdu 23 code
6452						;
6453						; VDU queue = the full 9 bytes of the VDU 23
6454						;
6455	.e079					vdu23EntryPointTable:
6456	>e079	fb ce				                .word vdu23_0_EntryPoint
6457	>e07b	2b cf				                .word vdu23_1_EntryPoint
6458	>e07d	57 cf				                .word vdu23_2_EntryPoint
6459	>e07f	57 cf				                .word vdu23_3_EntryPoint
6460	>e081	57 cf				                .word vdu23_4_EntryPoint
6461	>e083	57 cf				                .word vdu23_5_EntryPoint
6462	>e085	df cf				                .word vdu23_6_EntryPoint
6463	>e087	e6 cf				                .word vdu23_7_EntryPoint
6464	>e089	69 d0				                .word vdu23_8_EntryPoint
6465	>e08b	0f d1				                .word vdu23_9_EntryPoint
6466	>e08d	10 d1				                .word vdu23_10_EntryPoint
6467	>e08f	6d cf				                .word vdu23_11_EntryPoint
6468	>e091	96 cf				                .word vdu23_12_EntryPoint
6469	>e093	96 cf				                .word vdu23_13_EntryPoint
6470	>e095	96 cf				                .word vdu23_14_EntryPoint
6471	>e097	96 cf				                .word vdu23_15_EntryPoint
6472	>e099	1e d1				                .word vdu23_16_EntryPoint

6474						;-------------------------------------------------------------------------
6475						;
6476						; entry:
6477						;
6478						; A = plot number
6479						;
6480	.e09b					plotEntryPointTable:
6481	>e09b	4a db				                .word plotPoint    ;64-71 = Plot point [MasRef E.3-24]
6482	>e09d	6c dc				                .word plotHorizontalLineFill ;72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
6483	>e09f	97 9c				                .word L9BF7 ;80-87 = Plot triangle [MasRef E.3-25]
6484	>e0a1	75 dc				                .word plotHorizontalLineFillRight ;88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
6485	>e0a3	48 c4				                .word LC448 ;96-103 = Plot rectangle [MasRef E.3-26]
6486	>e0a5	6c dc				                .word plotHorizontalLineFill ;104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
6487	>e0a7	43 9c				                .word plotParallelogram ;112-119 = Plot parallelogram [MasRef E.3-27]
6488	>e0a9	75 dc				                .word plotHorizontalLineFillRight ;120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
6489	>e0ab	99 9d				                .word L9CF9 ;128-135 = Flood fill to non-background [MasRef E.3-28]
6490	>e0ad	99 9d				                .word L9CF9 ;136-143 = Flood fill to foreground [MasRef E.3-28]
6491	>e0af	44 9a				                .word L99A4 ;144-151 = Plot circle outline [MasRef E.3-28]
6492	>e0b1	e4 99				                .word L9944 ;152-159 = Plot filled circle [MasRef E.3-29]
6493	>e0b3	39 9a				                .word L9999 ;160-167 = Plot circular arc [MasRef E.3-29]
6494	>e0b5	d5 99				                .word L9935 ;168-175 = Plot filled chord segment [MasRef E.3-30]
6495	>e0b7	c3 99				                .word L9923 ;176-183 = Plot filled sector [MasRef E.3-30]
6496	>e0b9	df df				                .word selectExtROMAndPlotMoveOrCopyRectangle ;184-191 = Move/copy rectangle [MasRef E.3-31]
6497	>e0bb	e9 df				                .word selectExtROMAndPlotEllipseOutline ;192-199 = Plot ellipse outline [MasRef E.3-32]
6498	>e0bd	f4 df				                .word selectExtROMAndPlotEllipseFilled ;200-207 = Plot solid ellipse [MasRef E.3-32]

6500						; Times 40 lookup table, high bytes
6501	.e0bf					multiplyBy40TableHigh:
6502						                .for _i=0,_i<25,_i+=1
6503	>e0bf	00				                .byte >_i*40
6503	>e0c0	00				                .byte >_i*40
6503	>e0c1	00				                .byte >_i*40
6503	>e0c2	00				                .byte >_i*40
6503	>e0c3	00				                .byte >_i*40
6503	>e0c4	00				                .byte >_i*40
6503	>e0c5	00				                .byte >_i*40
6503	>e0c6	01				                .byte >_i*40
6503	>e0c7	01				                .byte >_i*40
6503	>e0c8	01				                .byte >_i*40
6503	>e0c9	01				                .byte >_i*40
6503	>e0ca	01				                .byte >_i*40
6503	>e0cb	01				                .byte >_i*40
6503	>e0cc	02				                .byte >_i*40
6503	>e0cd	02				                .byte >_i*40
6503	>e0ce	02				                .byte >_i*40
6503	>e0cf	02				                .byte >_i*40
6503	>e0d0	02				                .byte >_i*40
6503	>e0d1	02				                .byte >_i*40
6503	>e0d2	02				                .byte >_i*40
6503	>e0d3	03				                .byte >_i*40
6503	>e0d4	03				                .byte >_i*40
6503	>e0d5	03				                .byte >_i*40
6503	>e0d6	03				                .byte >_i*40
6503	>e0d7	03				                .byte >_i*40
6504						                .next

6506						; Times 40 lookup table, low bytes
6507	.e0d8					multiplyBy40TableLow:
6508						                .for _i=0,_i<25,_i+=1
6509	>e0d8	00				                .byte <_i*40
6509	>e0d9	28				                .byte <_i*40
6509	>e0da	50				                .byte <_i*40
6509	>e0db	78				                .byte <_i*40
6509	>e0dc	a0				                .byte <_i*40
6509	>e0dd	c8				                .byte <_i*40
6509	>e0de	f0				                .byte <_i*40
6509	>e0df	18				                .byte <_i*40
6509	>e0e0	40				                .byte <_i*40
6509	>e0e1	68				                .byte <_i*40
6509	>e0e2	90				                .byte <_i*40
6509	>e0e3	b8				                .byte <_i*40
6509	>e0e4	e0				                .byte <_i*40
6509	>e0e5	08				                .byte <_i*40
6509	>e0e6	30				                .byte <_i*40
6509	>e0e7	58				                .byte <_i*40
6509	>e0e8	80				                .byte <_i*40
6509	>e0e9	a8				                .byte <_i*40
6509	>e0ea	d0				                .byte <_i*40
6509	>e0eb	f8				                .byte <_i*40
6509	>e0ec	20				                .byte <_i*40
6509	>e0ed	48				                .byte <_i*40
6509	>e0ee	70				                .byte <_i*40
6509	>e0ef	98				                .byte <_i*40
6509	>e0f0	c0				                .byte <_i*40
6510						                .next

6512						; Times 640 lookup table, high bytes
6513	.e0f1					multiplyBy640TableHigh:
6514						                .for _i=0,_i<32,_i+=1
6515	>e0f1	00				                .byte >_i*640
6515	>e0f2	02				                .byte >_i*640
6515	>e0f3	05				                .byte >_i*640
6515	>e0f4	07				                .byte >_i*640
6515	>e0f5	0a				                .byte >_i*640
6515	>e0f6	0c				                .byte >_i*640
6515	>e0f7	0f				                .byte >_i*640
6515	>e0f8	11				                .byte >_i*640
6515	>e0f9	14				                .byte >_i*640
6515	>e0fa	16				                .byte >_i*640
6515	>e0fb	19				                .byte >_i*640
6515	>e0fc	1b				                .byte >_i*640
6515	>e0fd	1e				                .byte >_i*640
6515	>e0fe	20				                .byte >_i*640
6515	>e0ff	23				                .byte >_i*640
6515	>e100	25				                .byte >_i*640
6515	>e101	28				                .byte >_i*640
6515	>e102	2a				                .byte >_i*640
6515	>e103	2d				                .byte >_i*640
6515	>e104	2f				                .byte >_i*640
6515	>e105	32				                .byte >_i*640
6515	>e106	34				                .byte >_i*640
6515	>e107	37				                .byte >_i*640
6515	>e108	39				                .byte >_i*640
6515	>e109	3c				                .byte >_i*640
6515	>e10a	3e				                .byte >_i*640
6515	>e10b	41				                .byte >_i*640
6515	>e10c	43				                .byte >_i*640
6515	>e10d	46				                .byte >_i*640
6515	>e10e	48				                .byte >_i*640
6515	>e10f	4b				                .byte >_i*640
6515	>e110	4d				                .byte >_i*640
6516						                .next

6518						;-------------------------------------------------------------------------

6520	.e111					modeMaxRow:
6521	>e111	1f				                .byte 31                     ;MODE 0 = 32 rows
6522	>e112	1f				                .byte 31                     ;MODE 1 = 32 rows
6523	>e113	1f				                .byte 31                     ;MODE 2 = 32 rows
6524	>e114	18				                .byte 24                     ;MODE 3 = 25 rows
6525	>e115	1f				                .byte 31                     ;MODE 4 = 32 rows
6526	>e116	1f				                .byte 31                     ;MODE 5 = 32 rows
6527	>e117	18				                .byte 24                     ;MODE 6 = 25 rows
6528	>e118	18				                .byte 24                     ;MODE 7 = 25 rows

6530						;-------------------------------------------------------------------------

6532	.e119					modeMaxColumn:
6533	>e119	4f				                .byte 79                     ;MODE 0 = 80 columns
6534	>e11a	27				                .byte 39                     ;MODE 1 = 40 columns
6535	>e11b	13				                .byte 19                     ;MODE 2 = 20 columns
6536	>e11c	4f				                .byte 79                     ;MODE 3 = 80 columns
6537	>e11d	27				                .byte 39                     ;MODE 4 = 40 columns
6538	>e11e	13				                .byte 19                     ;MODE 5 = 20 columns
6539	>e11f	27				                .byte 39                     ;MODE 6 = 40 columns
6540	>e120	27				                .byte 39                     ;MODE 7 = 40 columns

6542						;-------------------------------------------------------------------------

6544	.e121					vcontrolForScreenMODE:
6545	>e121	9c				                .byte VCONTROL.cursorX___|VCONTROL.crtc2MHz|VCONTROL.shift16MHz ; $9C - MODE 0
6546	>e122	d8				                .byte VCONTROL.cursorXX__|VCONTROL.crtc2MHz|VCONTROL.shift8MHz ; $d8 - MODE 1
6547	>e123	f4				                .byte VCONTROL.cursorXXXX|VCONTROL.crtc2MHz|VCONTROL.shift4MHz ; $F4 - MODE 2
6548	>e124	9c				                .byte VCONTROL.cursorX___|VCONTROL.crtc2MHz|VCONTROL.shift16MHz ; $9C - MODE 3
6549	>e125	88				                .byte VCONTROL.cursorX___|VCONTROL.crtc1MHz|VCONTROL.shift8MHz ; $88 - MODE 4
6550	>e126	c4				                .byte VCONTROL.cursorXX__|VCONTROL.crtc1MHz|VCONTROL.shift4MHz ; $C4 - MODE 5
6551	>e127	88				                .byte VCONTROL.cursorX___|VCONTROL.crtc1MHz|VCONTROL.shift8MHz ; $88 - MODE 6
6552	>e128	4b				                .byte VCONTROL.cursor_X__|VCONTROL.crtc1MHz|VCONTROL.shift8MHz|VCONTROL.isTeletext|VCONTROL.flash ; $4B - MODE 7

6554						;-------------------------------------------------------------------------

6556	.e129					bytesPerCharacterForMODE:
6557	>e129	08				                .byte 8                      ;MODE 0
6558	>e12a	10				                .byte 16                     ;MODE 1
6559	>e12b	20				                .byte 32                     ;MODE 2
6560	>e12c	08				                .byte 8                      ;MODE 3
6561	>e12d	08				                .byte 8                      ;MODE 4
6562	>e12e	10				                .byte 16                     ;MODE 5
6563	>e12f	08				                .byte 8                      ;MODE 6
6564	.e130					LE120:
6565	>e130	01				                .byte %00000001              ;MODE 7
6566	>e131	ff				                .byte %11111111
6567	>e132	55				                .byte %01010101
6568	>e133	ff				                .byte %11111111
6569	>e134	77				                .byte %01110111
6570	>e135	33				                .byte %00110011
6571	>e136	11				                .byte %00010001

6573						;-------------------------------------------------------------------------

6575	.e137					distanceMasksTable:
6576	>e137	ff				                .byte %11111111
6577	>e138	7f				                .byte %01111111
6578	>e139	3f				                .byte %00111111
6579	>e13a	1f				                .byte %00011111
6580	>e13b	0f				                .byte %00001111
6581	>e13c	07				                .byte %00000111
6582	>e13d	03				                .byte %00000011
6583	>e13e	01				                .byte %00000001

6585						;-------------------------------------------------------------------------
6586						;
6587						; These graphics tables often overlap. I haven't always bothered
6588						; commenting the MODEs for the MODE-indexed tables, as even those
6589						; sometimes overlap.
6590						;
6591						;------------------------------------------------------------------------

6593						;-------------------------------------------------------------------------
6594						;
6595						; This is 3 tables in one. Use the numberOfLogicalColoursMinusOne VDU
6596						; variable to access it:
6597						; pixelMasks[(numberOfLogicalColoursMinusOne&7)-1+colour&numberOfLogicalColoursMinusOne=
6598						;
6599	.e13f					pixelMasks:
6600	>e13f	aa				                .byte %10101010
6601	>e140	55				                .byte %01010101

6603	>e141	88				                .byte %10001000
6604	>e142	44				                .byte %01000100
6605	>e143	22				                .byte %00100010
6606	>e144	11				                .byte %00010001

6608	>e145	80				                .byte %10000000
6609	>e146	40				                .byte %01000000
6610	>e147	20				                .byte %00100000
6611	>e148	10				                .byte %00010000
6612	>e149	08				                .byte %00001000
6613	>e14a	04				                .byte %00000100
6614	>e14b	02				                .byte %00000010
6615	.e14c					numberOfLogicalColoursMinusOneForMODE:
6616	>e14c	01				                .byte %00000001              ;MODE 0 (also part of pixelMasks)
6617	>e14d	03				                .byte 3                      ;MODE 1
6618	>e14e	0f				                .byte 15                     ;MODE 2
6619	>e14f	01				                .byte 1                      ;MODE 3
6620	>e150	01				                .byte 1                      ;MODE 4
6621	>e151	03				                .byte 3                      ;MODE 5
6622	>e152	01				                .byte 1                      ;MODE 6
6623						                ; MODE 7 value (0) is in next table

6625						;-------------------------------------------------------------------------
6626						;
6627						; Overwrite: ZGORA=$ff, ZGEOR=$ff
6628						; OR: ZGORA=value, ZGEOR=$00
6629						; AND: ZGORA=~value, ZGEOR=$00
6630						; EOR: ZGORA=$00, ZGEOR=value
6631						; Invert: ZGORA=$00, ZGEOR=$ff
6632						; Leave: ZGORA=$00, ZGEOR=$ff
6633						;
6634	.e153					zgeorORTable:
6635	>e153	00				                .byte $00
6636	.e154					zgoraORTable:
6637	>e154	ff				                .byte $FF
6638	.e155					zgoraEORTable:
6639	>e155	00				                .byte $00
6640	>e156	00				                .byte $00
6641	>e157	ff				                .byte $FF
6642	.e158					zgeorEORTable:
6643	>e158	ff				                .byte $FF
6644	>e159	ff				                .byte $FF
6645	>e15a	ff				                .byte $FF
6646	>e15b	00				                .byte $00

6648						;-------------------------------------------------------------------------
6649						;
6650						; Index using logical colour value to get a byte with that colour
6651						; value in every pixel.
6652						;
6653						; This is 3 tables in one. Use the numberOfLogicalColoursMinusOne VDU
6654						; variable to access it:
6655						; solidColoursTable[(numberOfLogicalColoursMinusOne&7)-1+colour&numberOfLogicalColoursMinusOne=
6656						;
6657	.e15c					solidColoursTable:

6659						                ; 1 bpp
6660	>e15c	00				                .byte %00000000
6661	>e15d	ff				                .byte %11111111

6663						                ; 2 bpp
6664	>e15e	00				                .byte %00000000
6665	>e15f	0f				                .byte %00001111
6666	>e160	f0				                .byte %11110000
6667	>e161	ff				                .byte %11111111

6669						                ; 4 bpp
6670	>e162	00				                .byte %00000000
6671	>e163	03				                .byte %00000011
6672	>e164	0c				                .byte %00001100
6673	>e165	0f				                .byte %00001111
6674	>e166	30				                .byte %00110000
6675	>e167	33				                .byte %00110011
6676	>e168	3c				                .byte %00111100
6677	>e169	3f				                .byte %00111111
6678	>e16a	c0				                .byte %11000000
6679	>e16b	c3				                .byte %11000011
6680	>e16c	cc				                .byte %11001100
6681	>e16d	cf				                .byte %11001111
6682	>e16e	f0				                .byte %11110000
6683	>e16f	f3				                .byte %11110011
6684	>e170	fc				                .byte %11111100
6685	>e171	ff				                .byte %11111111

6687	.e172					pixelsPerByteMinusOneForMODE:
6688	>e172	07				                .byte 7
6689	>e173	03				                .byte 3
6690	>e174	01				                .byte 1
6691	.e175					LE165:
6692	>e175	00				                .byte 0
6693	>e176	07				                .byte 7
6694	>e177	03				                .byte 3
6695	.e178					screenMODEGroupForMODE:
6696	>e178	00				                .byte 0
6697	>e179	00				                .byte 0
6698	.e17a	00		brk #		                brk
6699	.e17b	01 02		ora ($02,x)	                ora ($02,x)
6700	>e17d	02				                .byte $02
6701	>e17e	03				                .byte $03
6702						;TSB &0D          :\ E16F= 04 0D       ..
6703	>e17f	04				                .byte $04

6705						;-------------------------------------------------------------------------
6706						;
6707						; Hardware scrolling wraparound size settings for screen mode group.
6708						;
6709						; The values for group 4 (1 KB) are bogus - the Mode 7 addressing
6710						; wraparound is handled differently.
6711						;
6712	.e180					latchBit5ForScreenMODEGroup:
6713	>e180	0d				                .byte 5|8                    ;20 KB
6714	>e181	05				                .byte 5|0                    ;16 KB
6715	>e182	0d				                .byte 5|8                    ;10 KB
6716	>e183	05				                .byte 5|0                    ; 8 KB
6717	.e184					latchBit4ForScreenMODEGroup:
6718	>e184	04				                .byte 4|0                    ;20 KB (also benign value for 1 KB)
6719	>e185	04				                .byte 4|0                    ;16 KB
6720	>e186	0c				                .byte 4|8                    ;10 KB
6721	>e187	0c				                .byte 4|8                    ; 8 KB
6722	>e188	04				                .byte 4|0                    ;(benign value for 1 KB)

6724						;-------------------------------------------------------------------------

6726	.e189					screenSizeHighByteForScreenMODEGroup:
6727	>e189	50				                .byte $50
6728	>e18a	40				                .byte $40
6729	>e18b	28				                .byte $28
6730	>e18c	20				                .byte $20
6731	>e18d	04				                .byte $04
6732	.e18e					startScreenAddressHighByteForScreenMODEGroup:
6733	>e18e	30				                .byte $30
6734	>e18f	40				                .byte $40
6735	>e190	58				                .byte $58
6736	>e191	60				                .byte $60
6737	>e192	7c				                .byte $7c
6738	.e193					crtcRegisterLastIndexForScreenMODEGroup:
6739	>e193	0b				                .byte (crtcRegisterValues20KB-crtcRegisterValues)+$0B
6740	>e194	17				                .byte (crtcRegisterValues16KB-crtcRegisterValues)+$0B
6741	>e195	23				                .byte (crtcRegisterValues10KB-crtcRegisterValues)+$0B
6742	>e196	2f				                .byte (crtcRegisterValues8KB-crtcRegisterValues)+$0B
6743	>e197	3b				                .byte (crtcRegisterValues1KB-crtcRegisterValues)+$0B
6744	.e198					crtcRegisterValues:
6745	.e198					crtcRegisterValues20KB:                   ;MODEs 0/1/2
6746	>e198	7f				                .byte $7F            ;R0 - Horizontal Total
6747	>e199	50				                .byte $50            ;R1 - Horizontal Displayed
6748	>e19a	62				                .byte $62            ;R2 - Horizontal Sync
6749	>e19b	28				                .byte $28            ;R3 - Sync Width (%vvvvhhhh)
6750	>e19c	26				                .byte $26            ;R4 - Vertical Total
6751	>e19d	00				                .byte $00            ;R5 - Vertical Total Adjust
6752	>e19e	20				                .byte $20            ;R6 - Vertical Displayed
6753	>e19f	22				                .byte $22            ;R7 - Vertical Sync Position
6754	>e1a0	01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6755	>e1a1	07				                .byte $07               ;R9 - Scan lines per character
6756	>e1a2	67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6757	>e1a3	08				                .byte 8                    ;R11 - Cursor End
6758	.e1a4					crtcRegisterValues16KB:                    ;MODE 3
6759	>e1a4	7f				                .byte $7F                 ;R0 - Horizontal Total
6760	>e1a5	50				                .byte $50                 ;R1 - Horizontal Displayed
6761	>e1a6	62				                .byte $62                 ;R2 - Horizontal Sync
6762	>e1a7	28				                .byte $28                 ;R3 - Sync Width (%vvvvhhhh)
6763	>e1a8	1e				                .byte $1e                 ;R4 - Vertical Total
6764	>e1a9	02				                .byte $02                 ;R5 - Vertical Total Adjust
6765	>e1aa	19				                .byte $19                 ;R6 - Vertical Displayed
6766	>e1ab	1b				                .byte $1B                 ;R7 - Vertical Sync Position
6767	>e1ac	01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6768	>e1ad	09				                .byte $09               ;R9 - Scan lines per character
6769	>e1ae	67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6770	>e1af	09				                .byte 9                      ;R11 - Cursor End
6771	.e1b0					crtcRegisterValues10KB:                      ;MODEs 4/5
6772	>e1b0	3f				                .byte $3f                 ;R0 - Horizontal Total
6773	>e1b1	28				                .byte $28                 ;R1 - Horizontal Displayed
6774	>e1b2	31				                .byte $31                 ;R2 - Horizontal Sync
6775	>e1b3	24				                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
6776	>e1b4	26				                .byte $26                 ;R4 - Vertical Total
6777	>e1b5	00				                .byte $00                 ;R5 - Vertical Total Adjust
6778	>e1b6	20				                .byte $20                 ;R6 - Vertical Displayed
6779	>e1b7	22				                .byte $22                 ;R7 - Vertical Sync Position
6780	>e1b8	01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6781	>e1b9	07				                .byte $07               ;R9 - Scan lines per character
6782	>e1ba	67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6783	>e1bb	08				                .byte 8                      ;R11 - Cursor End
6784	.e1bc					crtcRegisterValues8KB:                       ;MODE 6
6785	>e1bc	3f				                .byte $3F                 ;R0 - Horizontal Total
6786	>e1bd	28				                .byte $28                 ;R1 - Horizontal Displayed
6787	>e1be	31				                .byte $31                 ;R2 - Horizontal Sync
6788	>e1bf	24				                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
6789	>e1c0	1e				                .byte $1e                 ;R4 - Vertical Total
6790	>e1c1	02				                .byte $02                 ;R5 - Vertical Total Adjust
6791	>e1c2	19				                .byte $19                 ;R6 - Vertical Displayed
6792	>e1c3	1b				                .byte $1B                 ;R7 - Vertical Sync Position
6793	>e1c4	01				                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
6794	>e1c5	09				                .byte $09               ;R9 - Scan lines per character
6795	>e1c6	67				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
6796	>e1c7	09				                .byte 9                      ;R11 - Cursor End
6797	.e1c8					crtcRegisterValues1KB:                       ;MODE 7
6798	>e1c8	3f				                .byte $3f                 ;R0 - Horizontal Total
6799	>e1c9	28				                .byte $28                 ;R1 - Horizontal Displayed
6800	>e1ca	33				                .byte $33                 ;R2 - Horizontal Sync
6801	>e1cb	24				                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
6802	>e1cc	1e				                .byte $1e                 ;R4 - Vertical Total
6803	>e1cd	02				                .byte $02                 ;R5 - Vertical Total Adjust
6804	>e1ce	19				                .byte $19                 ;R6 - Vertical Displayed
6805	>e1cf	1b				                .byte $1b                 ;R7 - Vertical Sync Position
6806	>e1d0	93				                .byte CRTC.R8.cursorDelay2|CRTC.R8.displayDelay1|CRTC.R8.interlaceSyncAndVideo ;R8 - Interlace/Delay
6807	>e1d1	12				                .byte $12               ;R9 - Scan lines per character
6808	>e1d2	72				                .byte CRTC.R10.blink|CRTC.R10.slowBlink|18 ;R10 - Cursor blink/start
6809	>e1d3	13				                .byte 19                     ;R11 - Cursor End

6811						;-------------------------------------------------------------------------
6812						;
6813						; Default ECF patterns [MasRef E.3-16]
6814						;
6815						; Only half the pattern is stored. Each pattern repeats every 4
6816						; scanlines.
6817						;
6818	.e1d4					defaultECFPatterns:
6819						                ; MODE 4
6820	>e1d4	aa 00 aa 00			                .byte $aa,$00,$aa,$00        ;1 - Dark grey
6821	>e1d8	aa 55 aa 55			                .byte $aa,$55,$aa,$55        ;2 - Grey
6822	>e1dc	ff 55 ff 55			                .byte $ff,$55,$ff,$55        ;3 - Light grey
6823	>e1e0	11 22 44 88			                .byte $11,$22,$44,$88        ;4 - Hatching

6825						                ; MODE 1/5
6826	>e1e4	a5 0f a5 0f			                .byte $a5,$0f,$a5,$0f        ;1 - Red-orange
6827	>e1e8	a5 5a a5 5a			                .byte $a5,$5a,$a5,$5a        ;2 - Orange
6828	>e1ec	f0 5a f0 5a			                .byte $f0,$5a,$f0,$5a        ;3 - Yellow-orange
6829	>e1f0	f5 fa f5 fa			                .byte $f5,$fa,$f5,$fa        ;4 - Cream

6831						                ; MODE 2
6832	>e1f4	0b 07 0b 07			                .byte $0b,$07,$0b,$07        ;1 - Orange
6833	>e1f8	23 13 23 13			                .byte $23,$13,$23,$13        ;2 - Pink
6834	>e1fc	0e 0d 0e 0d			                .byte $0e,$0d,$0e,$0d        ;3 - Yellow-green
6835	>e200	1f 2f 1f 2f			                .byte $1f,$2f,$1f,$2f        ;4 - Cream

6837						                ; MODE 0
6838	>e204	cc 00 cc 00			                .byte $cc,$00,$cc,$00        ;0 - Dark grey
6839	>e208	cc 33 cc 33			                .byte $cc,$33,$cc,$33        ;1 - Grey
6840	>e20c	ff 33 ff 33			                .byte $ff,$33,$ff,$33        ;2 - Light grey
6841	>e210	03 0c 30 c0			                .byte $03,$0c,$30,$c0        ;4 - Hatching

6843	.e214					LE204:
6844	>e214	01				                .byte $01                    ;---
6845	>e215	01				                .byte $01                    ;--h
6846	>e216	03				                .byte $03                    ;-v-
6847	>e217	03				                .byte $03                    ;-vh
6848	>e218	02				                .byte $02                    ;x--
6849	>e219	00				                .byte $00                    ;x-h
6850	>e21a	02				                .byte $02                    ;xv-
6851	>e21b	00				                .byte $00                    ;xvh

6853	.e21c					scrollRoutinesTable:
6854	>e21c	5f c9				                .word LC95F
6855	>e21e	6b c9				                .word LC96B
6856	>e220	5f c9				                .word LC95F
6857	>e222	6b c9				                .word LC96B
6858	>e224	9d c9				                .word LC99D
6859	>e226	9d c9				                .word LC99D
6860	>e228	a4 c9				                .word LC9A4
6861	>e22a	a4 c9				                .word LC9A4
6862	>e22c	c3 c9				                .word LC9C3
6863	>e22e	2d ca				                .word LCA2D
6864	>e230	c3 c9				                .word LC9C3
6865	>e232	2d ca				                .word LCA2D
6866	>e234	f1 ca				                .word LCAF1
6867	>e236	f1 ca				                .word LCAF1
6868	>e238	fa ca				                .word LCAFA
6869	>e23a	fa ca				                .word LCAFA

6871						;-------------------------------------------------------------------------
6872						;
6873						; Get address of soft character definition.
6874						;
6875						; entry:
6876						;
6877						; A = character (32-255)
6878						;
6879						; exit:
6880						;
6881						; (ZTEMPC) = address
6882						;
6883	.e23c					getSoftCharacterDefinitionAddress:
6884	.e23c	0a		asl a		                asl a                        ;a bcdefgh0
6885	.e23d	2a		rol a		                rol a                        ;b cdefgh0a
6886	.e23e	2a		rol a		                rol a                        ;c defgh0ab
6887	.e23f	a8		tay		                tay
6888	.e240	29 03		and #$03	                and #$03                     ;c 000000ab
6889	.e242	2a		rol a		                rol a                        ;0 00000abc
6890	.e243	69 88		adc #$88	                adc #(>andy.softCharacterDefinitions)-1
6891	.e245	85 df		sta $df		                sta ZTEMPC+1
6892	.e247	98		tya		                tya                          ;0 defgh0ab
6893	.e248	29 f8		and #$f8	                and #$F8                     ;0 defgh000
6894	.e24a	85 de		sta $de		                sta ZTEMPC+0
6895	.e24c	60		rts		                rts                          ;

6897						;-------------------------------------------------------------------------
6898						;
6899						; OSBYTE 165 (&A5) Read output cursor position [MasRef D.2-50]
6900						;
6901	.e24d					osbyteA5:
6902	.e24d	20 88 f4	jsr $f488	                jsr withMOSROM
6903	.e250	24 d0		bit $d0		                bit STATE
6904	.e252	50 0e		bvc $e262	                bvc getTextCursorPositionWithColumn81                    ;taken if cursor editing
6905	.e254	20 be e2	jsr $e2be	                jsr exchangeEditCursorPositionAndTextCursorPosition
6906	.e257	20 62 e2	jsr $e262	                jsr getTextCursorPositionWithColumn81
6907	.e25a	da		phx		                phx
6908	.e25b	5a		phy		                phy
6909	.e25c	20 be e2	jsr $e2be	                jsr exchangeEditCursorPositionAndTextCursorPosition
6910	.e25f	7a		ply		                ply
6911	.e260	fa		plx		                plx
6912	.e261	60		rts		                rts

6914						;-------------------------------------------------------------------------
6915						;
6916						; Get text cursor position, taking the column 81 flag into account and
6917						; reporting the X coordinate as N+1 in that case.
6918						;
6919	.e262					getTextCursorPositionWithColumn81:
6920	.e262	20 7d e2	jsr $e27d	                jsr getTextCursorPosition
6921	.e265	2c 6c 03	bit $036c	                bit vduv.column81
6922	.e268	10 01		bpl $e26b	                bpl +                       ;taken if not at column 81
6923	.e26a	e8		inx		                inx                         ;X=81
6924	.e26b					+
6925	.e26b	60		rts		                rts

6927						;-------------------------------------------------------------------------

6929	.e26c					LE25C:
6930	.e26c	38		sec		                sec
6931	.e26d	ad 0a 03	lda $030a	                lda vduv.textWindowRight
6932	.e270	ed 08 03	sbc $0308	                sbc vduv.textWindowLeft
6933	.e273	48		pha		                pha
6934	.e274	a9 00		lda #$00	                lda #$00
6935	.e276	a8		tay		                tay
6936	.e277	80 10		bra $e289	                bra LE279

6938						;-------------------------------------------------------------------------
6939						;
6940						; OSBYTE 134 (&86) Read text cursor position [MasRef D.2-41]
6941						;
6942	.e279					osbyte86:
6943	.e279	24 d0		bit $d0		                bit STATE
6944	.e27b	50 d0		bvc $e24d	                bvc osbyteA5       ;taken if not cursor editing
6945	.e27d					getTextCursorPosition:
6946	.e27d	a9 02		lda #$02	                lda #VDUVariables.cursorFlags.invertHorizontal
6947	.e27f	a0 10		ldy #$10	                ldy #VDUVariables.textCursorXPosition-VDUVariables.textWindow
6948	.e281	a2 00		ldx #$00	                ldx #VDUVariables.textWindowLeft-VDUVariables.textWindow
6949	.e283	20 9a e2	jsr $e29a	                jsr getTextWindowRelativePosition
6950	.e286	48		pha		                pha                          ;save X position
6951	.e287	a9 04		lda #$04	                lda #VDUVariables.cursorFlags.invertVertical
6952	.e289					LE279:
6953	.e289	c8		iny		                iny               ;i.e., offset of textCursorYPosition
6954	.e28a	a2 03		ldx #$03	                ldx #VDUVariables.textWindowTop-VDUVariables.textWindow
6955	.e28c	20 9a e2	jsr $e29a	                jsr getTextWindowRelativePosition
6956	.e28f	aa		tax		                tax                          ;X = Y position
6957	.e290	a8		tay		                tay                          ;Y = Y position
6958	.e291	a9 08		lda #$08	                lda #vduv.cursorFlags.swapAxes
6959	.e293	2c 66 03	bit $0366	                bit vduv.cursorFlags
6960	.e296	f0 24		beq $e2bc	                beq plx_rts ;taken if axes unswapped - so X = X position, Y = Y position
6961	.e298	7a		ply		                ply                          ;Y = Y position, X = X position
6962	.e299	60		rts		                rts

6964						;-------------------------------------------------------------------------
6965						;
6966						; Get text window-relative cursor position, taking into account cursor
6967						; flags.
6968						;
6969						; entry:
6970						;
6971						; A = cursorFlags bit for axis of interest - invertHorizontal or invertVertical
6972						;
6973						; X = offset in VDU variables of text window minimum for axis of interest
6974						;
6975						; Y = offset in VDU variables of cursor position for axis of interest
6976						;
6977						; exit:
6978						;
6979						; A = text window-relative coordinate
6980						;
6981	.e29a					getTextWindowRelativePosition:
6982	.e29a	38		sec		                sec                     ;C=1 ready for the subtraction
6983	.e29b	2c 66 03	bit $0366	                bit vduv.cursorFlags ;test cursor flags inversion bit of interest
6984	.e29e	f0 0b		beq $e2ab	                beq axisNotInverted
6985	.e2a0					axisInverted:
6986	.e2a0	8a		txa		                txa
6987	.e2a1	49 02		eor #$02	                eor #$02                     ;swap min and max
6988	.e2a3	aa		tax		                tax
6989	.e2a4	bd 08 03	lda $0308,x	                lda vduv.textWindow,x
6990	.e2a7	f9 08 03	sbc $0308,y	                sbc vduv.textWindow,y
6991	.e2aa	60		rts		                rts

6993	.e2ab					axisNotInverted:
6994	.e2ab	b9 08 03	lda $0308,y	                lda vduv.textWindow,y
6995	.e2ae	fd 08 03	sbc $0308,x	                sbc vduv.textWindow,x
6996	.e2b1	60		rts		                rts

6998						;-------------------------------------------------------------------------
6999						;
7000						; Get default bounds for current mode.
7001						;
7002						; exit:
7003						;
7004						; X = max column (19, 39 or 79)
7005						;
7006						; Y = max row (24 or 31)
7007						;
7008						; preserves: A, C
7009						;
7010	.e2b2					getDefaultBoundsForCurrentScreenMODE:
7011	.e2b2	ae 55 03	ldx $0355	                ldx vduv.currentScreenMODE
7012	.e2b5	bc 19 e1	ldy $e119,x	                ldy modeMaxColumn,x          ;Y = max column
7013	.e2b8	5a		phy		                phy                          ;save max column
7014	.e2b9	bc 11 e1	ldy $e111,x	                ldy modeMaxRow,x             ;Y = max row
7015	.e2bc					plx_rts:
7016	.e2bc	fa		plx		                plx                          ;X = max column
7017	.e2bd	60		rts		                rts

7019						;-------------------------------------------------------------------------
7020						;
7021						; Swap edit cursor position and text cursor position.
7022						;
7023	.e2be					exchangeEditCursorPositionAndTextCursorPosition:
7024	.e2be	a2 18		ldx #$18	                ldx #VDUVariables.textCursorXPosition
7025	.e2c0	a0 64		ldy #$64	                ldy #VDUVariables.editCursorXPosition

7027						;-------------------------------------------------------------------------
7028						;
7029						; Swap 2 bytes in the VDU variables.
7030						;
7031						; entry:
7032						;
7033						; X = offset of one set of 2 bytes
7034						;
7035						; Y = offset of the other set of 2 bytes
7036						;
7037	.e2c2					exchangeTwoVDUBytes:
7038	.e2c2	a9 02		lda #$02	                lda #$02
7039	.e2c4	80 06		bra $e2cc	                bra exchangeVDUVariables

7041						;-------------------------------------------------------------------------
7042						;
7043						; Swap graphics cursor and old graphics cursor.
7044						;
7045	.e2c6					LE2B6:
7046	.e2c6	a2 24		ldx #$24	                ldx #VDUVariables.graphicsCursorPixelsX
7047	.e2c8					LE2B8:
7048	.e2c8	a0 14		ldy #$14	                ldy #VDUVariables.oldGraphicsCursorPixelsX

7050						;-------------------------------------------------------------------------
7051						;
7052						; Swap 4 bytes in the VDU variables.
7053						;
7054						; entry:
7055						;
7056						; X = offset of one set of 4 bytes
7057						;
7058						; Y = offset of the other set of 4 bytes
7059						;
7060	.e2ca					exchangeFourVDUBytes:
7061	.e2ca	a9 04		lda #$04	                lda #$04

7063						;-------------------------------------------------------------------------
7064						;
7065						; Swap bytes in the VDU variables.
7066						;
7067						; entry:
7068						;
7069						; A = number of bytes to swap
7070						;
7071						; X = offset of one set of bytes
7072						;
7073						; Y = offset of the other set of bytes
7074						;
7075	.e2cc					exchangeVDUVariables:
7076	.e2cc	48		pha		                pha                          ;save count remaining
7077	.e2cd	bd 00 03	lda $0300,x	                lda vduv,x
7078	.e2d0	48		pha		                pha
7079	.e2d1	b9 00 03	lda $0300,y	                lda vduv,y
7080	.e2d4	9d 00 03	sta $0300,x	                sta vduv,x
7081	.e2d7	68		pla		                pla
7082	.e2d8	99 00 03	sta $0300,y	                sta vduv,y
7083	.e2db	e8		inx		                inx
7084	.e2dc	c8		iny		                iny
7085	.e2dd	68		pla		                pla
7086	.e2de	3a		dec a		                dec a
7087	.e2df	d0 eb		bne $e2cc	                bne exchangeVDUVariables
7088	.e2e1	60		rts		                rts

7090						;-------------------------------------------------------------------------
7091						;
7092						; Test current VDU4/VDU5 status.
7093						;
7094						; exit:
7095						;
7096						; Z=0 if VDU5 mode
7097	.e2e2					testVDU5StateNonInlined:
7098	.e2e2	a5 d0		lda $d0		                lda STATE
7099	.e2e4	29 20		and #$20	                and #STATE.isVDU5
7100	.e2e6	60		rts		                rts

7102						;-------------------------------------------------------------------------

7105	.e2e7					LE2E7:
7106	.e2e7	20 88 f4	jsr $f488	                jsr withMOSROM
7107	.e2ea	4c 65 ea	jmp $ea65	                jmp callPrinterDriverWithPrinterBuffer

7110						;-------------------------------------------------------------------------

7113	.e2ed					LE2ED:
7114	.e2ed	20 88 f4	jsr $f488	                jsr withMOSROM
7115	.e2f0	4c e4 e9	jmp $e9e4	                jmp LE8B9

7118						;-------------------------------------------------------------------------

7121	.e2f3					LE2F3:
7122	.e2f3	20 88 f4	jsr $f488	                jsr withMOSROM
7123	.e2f6	6c 26 02	jmp ($0226)	                jmp (VDUV)

7126						;-------------------------------------------------------------------------

7128						; Default vector table
7129						; ====================
7130	.e2f9					defaultVectorTable: .block
7131	>e2f9	60 fb				                .word badCommandError        ; USERV=$200
7132	>e2fb	7e e5				                .word defaultBRKHandler      ; BRKV=$202
7133	>e2fd	18 e6				                .word irq1EntryPoint         ; IRQ1V=$204
7134	>e2ff	25 e6				                .word irq2EntryPoint         ; IRQ2V=$206
7135	>e301	2d e9				                .word oscliEntryPoint        ; CLIV=$208
7136	>e303	92 ef				                .word osbyteEntryPoint       ; BYTEV=$20a
7137	>e305	5c ef				                .word oswordEntryPoint       ; WORDV=$20c
7138	>e307	4d e9				                .word oswrchEntryPoint       ; WRCHV=$20e
7139	>e309	ec e8				                .word osrdchEntryPoint       ; RDCHV=$210
7140	.e30b					fsVectors: .block
7141	>e30b	1b ff				                .word E_FILEV                ; FILEV=$212
7142	>e30d	1e ff				                .word E_ARGSV                ; ARGSV=$214
7143	>e30f	21 ff				                .word E_BGETV                ; BGETV=$216
7144	>e311	24 ff				                .word E_BPUTV                ; BPUTV=$218
7145	>e313	27 ff				                .word E_GBPBV                ; GBPBV=$21a
7146	>e315	2a ff				                .word E_FINDV                ; FINDV=$21c
7147	>e317	2d ff				                .word E_FSCV                 ; FSCV=$21e
7148	.e319					end:
7149						                .bend
7150	>e319	aa ff				                .word rtsFFAA                ; EVENTV=$220
7151	>e31b	aa ff				                .word rtsFFAA                ; UPTV=$222
7152	>e31d	aa ff				                .word rtsFFAA                ; NETV=$224
7153	>e31f	aa ff				                .word rtsFFAA                ; VDUV=$226
7154	>e321	59 f5				                .word keyEntryPoint          ; KEYV=$228
7155	>e323	6e eb				                .word insEntryPoint          ; INSV=$22a
7156	>e325	23 eb				                .word remEntryPoint          ; REMV=$22c
7157	>e327	a6 ea				                .word cnpEntryPoint          ; CNPV=$22e
7158	>e329	aa ff				                .word rtsFFAA                ; IND1V=$230
7159	>e32b	aa ff				                .word rtsFFAA                ; IND2V=$232
7160	>e32d	aa ff				                .word rtsFFAA                ; IND3V=$234
7161	.e32f					end:
7162						                .bend

7164						                ; valueFF is a (presumably arbitrary) byte with the
7165						                ; value 255, that's BIT'd in a few places to set the V
7166						                ; flag.
7167	.e32f					defaultMOSVariables:
7168	>e32f	90 01				                .word mosVariables-166       ;mosVariablesAddress
7169	>e331	9f 0d				                .word extendedVectorSpace    ;extendedVectorSpaceAddress
7170	>e333	a1 02				                .word romInformationTable  ;romInformationTableAddress
7171	>e335	1e f7				                .word keyTranslationTable-16 ;keyboardTranslationTableAddress
7172	>e337	00 03				                .word vduv                   ;vduVariablesAddress
7173	>e339	00				                .byte $00                    ;cfsTimeoutCounter
7174	>e33a	00				                .byte $00                    ;inputSource
7175	>e33b	ff				                .byte $FF                    ;keyboardSemaphore
7176	>e33c	00				                .byte $00                    ;romPollingSemaphore
7177	>e33d	00				                .byte $00                    ;oshwm
7178	>e33e	01				                .byte $01                    ;rs423InputInterpretationStatus
7179	>e33f	00				                .byte $00                    ;noignoreState
7180	>e340	00				                .byte $00                    ;cfsRFSFSSwitch
7181	>e341	00				                .byte $00                    ;vcontrolRegister
7182	>e342	00				                .byte $00                    ;vpaletteRegister
7183	>e343	00				                .byte $00                    ;romActiveAtLastBRK
7184	>e344	ff				                .byte $FF                    ;basicROMNumber
7189	>e345	02				                .byte $02                    ;currentADCChannel
7190	>e346	02				                .byte $02                    ;maximumADCChannel
7192	>e347	00				                .byte $00                    ;adcConversionType
7193	>e348	ff				                .byte $FF                    ;rs423Busy
7197	>e349	42				                .byte $42                    ;aciaControlRegister
7199	>e34a	19				                .byte $19                    ;flashCounter
7200	>e34b	19				                .byte $19                    ;firstFlashColourDuration
7201	>e34c	19				                .byte $19                    ;secondFlashColourDuration
7202	>e34d	32				                .byte $32                    ;keyboardAutoRepeatDelay
7203	>e34e	08				                .byte $08                    ;keyboardAutoRepeatRate
7204	>e34f	00				                .byte $00                    ;execFileHandle
7205	>e350	00				                .byte $00                    ;spoolFileHandle
7206	>e351	00				                .byte $00                    ;breakAndESCAPEEffect
7207	>e352	00				                .byte $00                    ;keyboardStatus
7208	>e353	20				                .byte $20                    ;keyboardStatusByte
7209	>e354	09				                .byte $09                    ;rs423InputBufferMinimumSpace
7210	>e355	00				                .byte $00                    ;rs423Ignore
7211	>e356	00				                .byte $00                    ;rs423Destination
7212	>e357	00				                .byte $00                    ;econetInterceptionStatus
7213	>e358	00				                .byte $00                    ;econetInputInterpretationStatus
7214	>e359	00				                .byte $00                    ;econetOutputInterpretationStatus
7215	>e35a	00				                .byte $00                    ;speechSystemByte1
7216	>e35b	00				                .byte $00                    ;soundSuppressionStatus
7217	>e35c	03				                .byte $03                    ;bellChannel
7218	>e35d	90				                .byte $90                    ;bellSound
7219	>e35e	64				                .byte $64                    ;bellFrequency
7220	>e35f	06				                .byte $06                    ;bellDuration
7221	>e360	81				                .byte $81                    ;startupMessageSuppressionStatus
7222	>e361	00				                .byte $00                    ;softKeyStringLength
7223	>e362	00				                .byte $00                    ;pagedModeCounter
7224	>e363	00				                .byte $00                    ;vduQueueNegativeLength
7225	>e364	09				                .byte $09                    ;tabKeyCode
7226	>e365	1b				                .byte $1B                    ;escapeCharacter
7227	>e366	01				                .byte $01                    ;input192To207Interpretation
7228	>e367	d0				                .byte $D0                    ;input208To223Interpretation
7229	>e368	e0				                .byte $E0                    ;input224To239Interpretation
7230	>e369	f0				                .byte $F0                    ;input240To255Interpretation
7231	>e36a	01				                .byte $01                    ;softKeyInterpretation
7232	>e36b	80				                .byte $80                    ;shiftSoftKeyInterpretation
7233	>e36c	90				                .byte $90                    ;ctrlSoftKeyInterpretation
7234	>e36d	00				                .byte $00                    ;shiftCtrlSoftKeyInterpretation
7235	>e36e	00				                .byte $00                    ;escapeKeyStatus
7236	>e36f	00				                .byte $00                    ;escapeEffects
7237	>e370	ff				valueFF:        .byte $FF                    ;userVIAInterruptMask
7238	>e371	ff				                .byte $FF                    ;rs423InterruptMask
7239	>e372	ff				                .byte $FF                    ;systemVIAInterruptMask
7240	>e373	00				                .byte $00                    ;tubePresence
7241	>e374	00				                .byte $00                    ;speechSystemByte2
7242	>e375	00				                .byte $00                    ;characterDestinationStatus
7243	>e376	00				                .byte editKeysMode.editKeys  ;editKeysMode
7244	>e377	30				                .byte $30                    ;numericKeypadInterpretation
7245	>e378	01				                .byte $01                    ;shadowRAMState
7246	>e379	00				                .byte $00                    ;countryFlag
7247	>e37a	00				                .byte $00                    ;userFlag
7251	>e37b	64				                .byte $64                    ;serialULARegister
7253	>e37c	05				                .byte initialTimerSwitchState ;timerSwitchState
7254	>e37d	ff				                .byte $FF                    ;softKeyConsistencyFlag
7258	>e37e	01				                .byte $01                    ;printerDriverType
7260	>e37f	0a				                .byte $0a                    ;printerIgnoreChar
7261	>e380	00				                .byte $00                    ;breakVectorByte0
7262	>e381	00				                .byte $00                    ;breakVectorByte1
7263	>e382	00				                .byte $00                    ;breakVectorByte2
7264	>e383	00				                .byte $00                    ;vduDriverMemory
7265	>e384	00				                .byte $00                    ;displayMemory
7266	>e385	ff				                .byte $FF                    ;currentLanguageROM

7268						;-------------------------------------------------------------------------
7269						;
7270						; STARTUP
7271						; =======
7272						;
7273	.e386					resetEntryPoint:                ;e364
7274	.e386	a9 40		lda #$40	                lda #$40        ; $40 = RTI
7275	.e388	8d 00 0d	sta $0d00	                sta nmiEntryPoint ; make NMI routine a no-op
7276	.e38b	78		sei		                sei
7278						                ; https://www.stardot.org.uk/forums/viewtopic.php?p=329122
7279	.e38c	a9 53		lda #$53	                lda #$53                 ; ???
7280	.e38e	8d 8e fe	sta $fe8e	                sta $FE8E                ; ???
7293	.e391	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM ; Page in ROM 15 and continue
7294	.e394	4c 1d 80	jmp $801d	                jmp reset

7297						;-------------------------------------------------------------------------

7306						;-------------------------------------------------------------------------

7309						                .include "isSecondProcessorPresent.s65"

:21	;******  Processing file: src/isSecondProcessorPresent.s65

1						;-------------------------------------------------------------------------
2						;
3						; Check if a coprocessor is attached to the Tube
4						;
5						; exit:
6						;
7						; C=0 = no Tube
8						;
9						; C=1 = Tube
10						;

12						; (Note that this code is always included in MOS 5.xx, even though
13						; there's no second processor support.)

15	.e397					isSecondProcessorPresent:
19	.e397					isSecondProcessorPresent2:
20						                ; (+ 6 2 4 4 2 2 4 4 2 6) = 36
21	.e397	a2 01		ldx #$01	                ldx #$01
22	.e399	8e e0 fe	stx $fee0	                stx $fee0       ;tube.status1
23	.e39c	ad e0 fe	lda $fee0	                lda $fee0       ;tube.status1
24	.e39f	49 01		eor #$01	                eor #$01
25	.e3a1	a2 81		ldx #$81	                ldx #$81
26	.e3a3	8e e0 fe	stx $fee0	                stx $fee0       ;tube.status1
27	.e3a6	2d e0 fe	and $fee0	                and $fee0 ;tube.status1       ; Cy=0 if no Tube, Cy=1 if Tube
28	.e3a9	6a		ror a		                ror a
29	.e3aa	60		rts		                rts

31						;-------------------------------------------------------------------------
32						;
33						; Check if a coprocessor is attached to the Tube, with a timeout to
34						; accommodate PiTube bootup time.
35						;
36						; exit:
37						;
38						; C=0 = no Tube
39						;
40						; C=1 = Tube
41						;

:15	;******  Return to file: src/mos.s65

7312						;-------------------------------------------------------------------------
7313						;
7314						;
7315						;

7321	.e3ab					LE389:
7322	.e3ab	5a		phy		                phy
7323	.e3ac	da		phx		                phx
7325	.e3ad	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM
7326	.e3b0	20 7c 87	jsr $877c	                jsr L873F
7335	.e3b3	c9 01		cmp #$01	                cmp #$01                     ;C set if ROM is inserted
7336	.e3b5	fa		plx		                plx
7337	.e3b6	7a		ply		                ply
7338	.e3b7	4c 9a e5	jmp $e59a	                jmp selectROMX

7340						;-------------------------------------------------------------------------
7341						;
7342						; Scan ROMs and fill in the rom information table.
7343						;
7344						; entry:
7345						;
7346						; X = first ROM to scan
7347						;
7349	.e3ba					scanROMs: .proc
7350						                .include "scan_roms.s65"

:16	;******  Processing file: src/scan_roms.s65

1	.e3ba	8a		txa		                txa               ;A = ROM of interest
2	.e3bb	a8		tay		                tay               ;Y = ROM of interest
7	.e3bc	20 1e e4	jsr $e41e	                jsr isROMValid
8	.e3bf	90 35		bcc $e3f6	                bcc currentROMInvalid        ;taken if ROM invalid
9	.e3c1	a6 f4		ldx $f4		                ldx $F4                      ;start from current ROM
10	.e3c3	a4 f4		ldy $f4		                ldy $F4                      ;start from current ROM
24	.e3c5					nextOtherROM:
25	.e3c5	c8		iny		                iny                          ;next other ROM
26	.e3c6	c0 10		cpy #$10	                cpy #$10                     ;out of other ROMs?
27	.e3c8	b0 30		bcs $e3fa	                bcs currentROMValid       ;taken if no more other ROMs
37						                ; Start address is $8000-Y, so that there's no need to
38						                ; save Y.
39	.e3ca	98		tya		                tya
40	.e3cb	49 ff		eor #$ff	                eor #$FF
41	.e3cd	85 fa		sta $fa		                sta SEIWKA+0
42	.e3cf	a9 7f		lda #$7f	                lda #$7F
43	.e3d1	85 fb		sta $fb		                sta SEIWKA+1
45	.e3d3					compareLoop:
46	.e3d3	8c 30 fe	sty $fe30	                sty ROMSEL                   ;select other ROM
50	.e3d6	b1 fa		lda ($fa),y	                lda (SEIWKA),y               ;get byte from other ROM
52	.e3d8	8e 30 fe	stx $fe30	                stx ROMSEL                   ;select ROM
56	.e3db	d1 fa		cmp ($fa),y	                cmp (SEIWKA),y               ;same as other ROM?
58	.e3dd	d0 e6		bne $e3c5	                bne nextOtherROM             ;taken if other ROM is good
59	.e3df	e6 fa		inc $fa		                inc SEIWKA+0
60	.e3e1	d0 f0		bne $e3d3	                bne compareLoop
61	.e3e3	e6 fb		inc $fb		                inc SEIWKA+1
62	.e3e5	a5 fb		lda $fb		                lda SEIWKA+1
64	.e3e7	e0 08		cpx #$08	                cpx #8
65	.e3e9	90 02		bcc $e3ed	                bcc +
66	.e3eb	69 02		adc #$02	                adc #2
67	.e3ed					+
69	.e3ed	c9 84		cmp #$84	                cmp #$84                  ;compare only the first 1 KB
70	.e3ef	90 e2		bcc $e3d3	                bcc compareLoop
71						                ; The first 1 KB of the current ROM matches the first
72						                ; 1 KB of some higher-priority ROM, so the current ROM
73						                ; is invalid.
75	.e3f1	a9 01		lda #$01	                lda #1
76	.e3f3	9d a1 02	sta $02a1,x	                sta romInformationTable,x

79	.e3f6					currentROMInvalid:
80	.e3f6	a6 f4		ldx $f4		                ldx $F4
81	.e3f8	80 19		bra $e413	                bra nextROM

83	.e3fa					currentROMValid:
85	.e3fa	8a		txa		                txa
86	.e3fb	a8		tay		                tay
90	.e3fc	20 ab e3	jsr $e3ab	                jsr LE389
92	.e3ff	90 12		bcc $e413	                bcc nextROM
94	.e401	ad 06 80	lda $8006	                lda sidewaysROMType
95	.e404	9d a1 02	sta $02a1,x	                sta romInformationTable,x
96	.e407	29 8f		and #$8f	                and #$8F
97	.e409	d0 08		bne $e413	                bne nextROM       ;taken if any mandatory bits are set

99						                ; A bogus ROM type means this ROM is the BASIC ROM.
101	.e40b	2c 4b 02	bit $024b	                bit basicROMNumber
102	.e40e	10 03		bpl $e413	                bpl nextROM

105	.e410	8e 4b 02	stx $024b	                stx basicROMNumber

107	.e413					nextROM:
108	.e413	e8		inx		                inx
109	.e414	e0 10		cpx #$10	                cpx #$10
110	.e416	90 a2		bcc $e3ba	                bcc scanROMs
111	.e418	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM

:15	;******  Return to file: src/mos.s65

7351	.e41b	4c 55 82	jmp $8255	                jmp romsScanned     ;not sure why not RTS.
7352						                .endproc

7355						;-------------------------------------------------------------------------
7356						;
7357						; Checks a ROM is valid - i.e., has a valid-looking copyright string.
7358						;
7359						; Entry:
7360						;
7361						; X = ROM to check
7362						;
7363						; Exit:
7364						;
7365						; C=0 if ROM invalid; C=1 if ROM valid
7366						;
7367						; ROM of interest is selected
7368						;
7369	.e41e					isROMValid: .proc ;e3f7
7370	.e41e	20 9a e5	jsr $e59a	                jsr selectROMX
7371	.e421	a2 03		ldx #$03	                ldx #$03
7372	.e423	ac 07 80	ldy $8007	                ldy $8007       ; fetch ROM copyright offset pointer
7373	.e426	18		clc		                clc             ; assume no match
7374	.e427					-
7375	.e427	b9 00 80	lda $8000,y	                lda $8000,y     ; fetch possible ROM copyright char
7376	.e42a	5d 2c e5	eor $e52c,x	                eor sidewaysROMCopyrightPrefix,x     ; Z=1 if it matches "\x0(C)"
7377	.e42d	d0 05		bne $e434	                bne +           ; branch taken if no match
7378	.e42f	c8		iny		                iny             ; next copyright byte
7379	.e430	ca		dex		                dex             ; count 4 chars
7380	.e431	10 f4		bpl $e427	                bpl -
7381	.e433	38		sec		                sec             ; C=1 means a match
7382	.e434					+
7383	.e434	60		rts		                rts
7384						                .pend

7386						;-------------------------------------------------------------------------

7388						; End of STARTUP code
7389						; ===================
7390	.e435					LE40E:
7391	.e435	38		sec		                sec                      ; Call Break Intercept Vector
7392	.e436	20 1f f4	jsr $f41f	                jsr osbyte247EntryPoint
7393	.e439	a2 27		ldx #$27	                ldx #romServiceCallInformReset
7394	.e43b	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
7395	.e43e	ac 56 02	ldy $0256	                ldy execFileHandle ; Get Exec handle, skip past if closed
7396	.e441	f0 08		beq $e44b	                beq LE424
7397	.e443	9c 56 02	stz $0256	                stz execFileHandle           ; Clear Exec handle
7398	.e446	a9 00		lda #$00	                lda #$00                     ; Close Exec channel
7399	.e448	20 ce ff	jsr $ffce	                jsr OSFIND
7400	.e44b					LE424:
7401	.e44b	38		sec		                sec                          ;
7402	.e44c	6e 00 df	ror $df00	                ror hazel.currentFS
7403	.e44f	ad 8d 02	lda $028d	                lda lastBREAKType            ; Soft Break
7404	.e452	f0 04		beq $e458	                beq LE431
7405	.e454	38		sec		                sec                          ;
7406	.e455	6e 02 df	ror $df02	                ror hazel.libFS
7407	.e458					LE431:
7408	.e458	20 f1 ee	jsr $eef1	                jsr LEE64                    ; Set default ROMFS/TAPEFS settings
7409	.e45b	20 ef f2	jsr $f2ef	                jsr osbyte76                    ; Test Shift and Ctrl keys
7413	.e45e	4a		lsr a		                lsr a                        ; Move SHIFT status from b7 to b3
7414	.e45f	4a		lsr a		                lsr a
7415	.e460	4a		lsr a		                lsr a
7416	.e461	4a		lsr a		                lsr a
7418	.e462	4d 8f 02	eor $028f	                eor startupOptions ; Toggle with OSBYTE 255 boot status
7419	.e465	29 08		and #$08	                and #$08
7420	.e467	a8		tay		                tay
7421	.e468	ae 03 df	ldx $df03	                ldx hazel.currentFSROM
7422	.e46b	ad 8d 02	lda $028d	                lda lastBREAKType ; Soft Break, use current filing system
7423	.e46e	f0 09		beq $e479	                beq LE454         ; taken if soft BREAK
7435	.e470	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM
7437	.e473	a2 33		ldx #$33	                ldx #configureTable.file.metadata-configureTable
7438	.e475	20 a1 8a	jsr $8aa1	                jsr readConfigurationByte

7446	.e478	aa		tax		                tax
7447	.e479					LE454:
7448	.e479	3c a1 02	bit $02a1,x	                bit romInformationTable,x    ; check ROM of interest
7449	.e47c	10 1f		bpl $e49d	                bpl LE478                    ; taken if no service entry
7450	.e47e	20 9a e5	jsr $e59a	                jsr selectROMX               ; select ROM of interest
7451	.e481	e0 0f		cpx #$0f	                cpx #terminalROM             ; is it the terminal ROM?
7452	.e483	d0 0c		bne $e491	                bne LE46C                    ; taken if not terminal ROM

7454						                ; SPACE+BREAK = RFS *RUN !BOOT when RFS is the default
7455						                ; FS
7456	.e485	20 ac f7	jsr $f7ac	                jsr osbyte7A
7457	.e488	e8		inx		                inx
7458	.e489	f0 19		beq $e4a4	                beq LE47F                    ; taken if no key pressed
7459	.e48b	e0 63		cpx #$63	                cpx #key_space+1             ; +1 due to previous inx
7460	.e48d	f0 15		beq $e4a4	                beq LE47F                    ; taken if SPACE held
7461	.e48f	80 0c		bra $e49d	                bra LE478                    ; wasn't space - just
7462						                                             ; ordinary ROM auto boot

7464	.e491					LE46C:
7465	.e491	a9 03		lda #$03	                lda #romServiceCallAutoBoot  ; Filing System selection
7466	.e493	20 03 80	jsr $8003	                jsr $8003                    ; pass to specific ROM
7467	.e496	aa		tax		                tax                          ; save service call result
7468	.e497	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM
7469	.e49a	8a		txa		                txa                          ; restore service call result
7470	.e49b	f0 2a		beq $e4c7	                beq LE4A3                    ; taken if call was handled
7471	.e49d					LE478:
7472	.e49d	a2 03		ldx #$03	                ldx #romServiceCallAutoBoot
7473	.e49f	20 ff ee	jsr $eeff	                jsr makeROMServiceCall     ; pass to highest priority ROM
7474	.e4a2	f0 23		beq $e4c7	                beq LE4A3                    ; taken if call was handled
7475	.e4a4					LE47F:
7476	.e4a4	98		tya		                tya                          ; A = boot file flag
7477	.e4a5	d0 17		bne $e4be	                bne LE499                    ; taken if not booting

7479						                ; Handle SPACE+BREAK, or boot mode in the absence of
7480						                ; any non-MOS FS.
7481	.e4a7	a9 8d		lda #$8d	                lda #$8D                     ; select ROM filing system
7482	.e4a9	20 27 ee	jsr $ee27	                jsr osbyte8C8D
7483	.e4ac	a2 e5		ldx #$e5	                ldx #<starRunBOOT
7484	.e4ae	a0 f4		ldy #$f4	                ldy #>starRunBOOT
7485	.e4b0	ce 67 02	dec $0267	                dec startupMessageSuppressionStatus
7486	.e4b3	20 f7 ff	jsr $fff7	                jsr OSCLI
7487	.e4b6	ee 67 02	inc $0267	                inc startupMessageSuppressionStatus
7488	.e4b9	80 0c		bra $e4c7	                bra LE4A3

7490						;-------------------------------------------------------------------------

7492	.e4bb					LE496:
7493	.e4bb	ee 67 02	inc $0267	                inc startupMessageSuppressionStatus ;set bit 0
7494	.e4be					LE499:
7495	.e4be	38		sec		                sec
7496	.e4bf	6e 00 df	ror $df00	                ror hazel.currentFS
7504	.e4c2	a9 8d		lda #$8d	                lda #$8d
7505	.e4c4	20 27 ee	jsr $ee27	                jsr osbyte8C8D
7507	.e4c7					LE4A3:
7508	.e4c7	a9 05		lda #$05	                lda #$05                     ;
7509	.e4c9	ae 85 02	ldx $0285	                ldx printerDriverType        ; *FX5,<current printer>
7510	.e4cc	20 92 ef	jsr $ef92	                jsr osbyteEntryPoint
7516	.e4cf	ad 8d 02	lda $028d	                lda lastBREAKType ; If not Soft Break, select default language
7517	.e4d2	d0 0b		bne $e4df	                bne LE4BB         ; taken if hard break or power on
7518	.e4d4	ae 8c 02	ldx $028c	                ldx currentLanguageROM      ; Get current language ROM
7524	.e4d7	e0 10		cpx #$10	                cpx #$10                     ; <16, normal ROM number, use it
7526	.e4d9	90 0d		bcc $e4e8	                bcc LE4C2
7530	.e4db	e0 1f		cpx #$1f	                cpx #$10+terminalROM ; 16+UTILS ROM, re-enter Supervisor or Tube CLI
7532	.e4dd	f0 49		beq $e528	                beq LE509
7533	.e4df					LE4BB:
7534	.e4df	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM     ; Page in ROM 15 - UTILS ROM
7536	.e4e2	a2 41		ldx #$41	                ldx #configureTable.lang.metadata-configureTable
7537	.e4e4	20 a1 8a	jsr $8aa1	                jsr readConfigurationByte
7541	.e4e7	aa		tax		                tax
7542	.e4e8					LE4C2:
7543	.e4e8	18		clc		                clc

7545						;-------------------------------------------------------------------------
7546						;
7547						; OSBYTE 142 (&8E) Enter language ROM [MasRef D.2-44]
7548						;
7549	.e4e9					osbyte8E:
7556	.e4e9	3c a1 02	bit $02a1,x	                bit romInformationTable,x ; b6=0, error Not a language
7560	.e4ec	50 41		bvc $e52f	                bvc thisIsNotALanguageError
7561	.e4ee	08		php		                php
7562	.e4ef	90 16		bcc $e507	                bcc LE4E1 ;taken if not OSBYTE 142 - so skip ROM check
7563	.e4f1	20 9a e5	jsr $e59a	                jsr selectROMX
7564	.e4f4	ad 06 80	lda $8006	                lda sidewaysROMType
7565	.e4f7	29 0d		and #$0d	                and #%00001101
7566	.e4f9	f0 05		beq $e500	                beq is6502ROM ;taken if low nybble is 0 (6502 BASIC) or 2 (other 6502 ROM)
7570	.e4fb	2c 7a 02	bit $027a	                bit tubePresenceUnused
7572	.e4fe	10 47		bpl $e547	                bpl iCannotRunThisCodeError  ;taken if no Tube - assume impossible to run
7573	.e500					is6502ROM:
7574	.e500	da		phx		                phx                          ;save ROM slot
7575	.e501	a2 2a		ldx #$2a	                ldx #romServiceCallLanguageChange
7576	.e503	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
7577	.e506	fa		plx		                plx                          ;restore ROM slot
7578	.e507					LE4E1:
7579	.e507	8e 8c 02	stx $028c	                stx currentLanguageROM
7580	.e50a	20 9a e5	jsr $e59a	                jsr selectROMX
7581	.e50d	a9 80		lda #$80	                lda #>sidewaysROMName
7582	.e50f	a0 08		ldy #$08	                ldy #(<sidewaysROMName)-1
7583	.e511	20 7d e7	jsr $e77d	                jsr print0TerminatedString
7584	.e514	84 fd		sty $fd		                sty errPtr+0
7585	.e516	20 e7 ff	jsr $ffe7	                jsr OSNEWL
7586	.e519	20 e7 ff	jsr $ffe7	                jsr OSNEWL
7587	.e51c	28		plp		                plp
7593	.e51d	ad 06 80	lda $8006	                lda sidewaysROMType
7594	.e520	29 0d		and #$0d	                and #%00001101
7595	.e522	d0 23		bne $e547	                bne iCannotRunThisCodeError ;taken if low nybble isn't 0 (6502 BASIC) or 2 (other 6502 ROM)
7596	.e524	1a		inc a		                inc a                   ;A=1 on default language entry
7597	.e525	4c 00 80	jmp $8000	                jmp sidewaysROMLanguageEntry

7599	.e528					LE509:
7600	.e528	a9 00		lda #$00	                lda #$00
7607	.e52a	80 66		bra $e592	                bra startCommandLineUI

7610						;-------------------------------------------------------------------------

7612	.e52c					sidewaysROMCopyrightPrefix: .block
7613	>e52c	29 43 28			                .text ")C("
7614	.e52f					end:
7615						                .endblock

7617						;-------------------------------------------------------------------------

7619	.e52f					thisIsNotALanguageError:
7620	.e52f	00		brk #		                brk
7621	>e530	00 54 68 69 73 20 69 73		                .text 0,"This is not a language"
	>e538	20 6e 6f 74 20 61 20 6c 61 6e 67 75 61 67 65

7623						;-------------------------------------------------------------------------

7625	.e547					iCannotRunThisCodeError:
7626	.e547	00		brk #		                brk
7627	>e548	00 49 20 63 61 6e 6e 6f		                .text 0,"I cannot run this code",0
	>e550	74 20 72 75 6e 20 74 68 69 73 20 63 6f 64 65 00

7629						;-------------------------------------------------------------------------
7630						;
7631						; OSBYTE 164 (&A4) Check processor type [MasRef D.2-50]
7632						;
7633	.e560					osbyteA4:
7634	.e560	a2 03		ldx #$03	                ldx #sidewaysROMCopyrightPrefix.end-sidewaysROMCopyrightPrefix
7635	.e562	a0 07		ldy #$07	                ldy #<sidewaysROMCopyrightOffset
7636	.e564	b1 f0		lda ($f0),y	                lda (originalX),y
7637	.e566	a8		tay		                tay
7638	.e567					-
7639	.e567	b1 f0		lda ($f0),y	                lda (originalX),y
7640	.e569	dd 2c e5	cmp $e52c,x	                cmp sidewaysROMCopyrightPrefix,x
7641	.e56c	d0 0f		bne $e57d	                bne rtsE564 ;taken if (C) not found - must be OK, if it's not a ROM?
7642	.e56e	c8		iny		                iny
7643	.e56f	ca		dex		                dex
7644	.e570	10 f5		bpl $e567	                bpl -
7645	.e572	a0 06		ldy #$06	                ldy #<sidewaysROMType
7646	.e574	b1 f0		lda ($f0),y	                lda (originalX),y
7647	.e576	0a		asl a		                asl a
7648	.e577	10 b6		bpl $e52f	                bpl thisIsNotALanguageError ;taken if no language entry point
7649	.e579	29 1a		and #$1a	                and #%00001101<<1
7650	.e57b	d0 ca		bne $e547	                bne iCannotRunThisCodeError ;taken if low nybble wasn't 0 (6502 BASIC) or 2 (other 6502 ROM)
7651	.e57d					rtsE564:
7652	.e57d	60		rts		                rts

7654						;-------------------------------------------------------------------------

7665						;-------------------------------------------------------------------------

7675						;-------------------------------------------------------------------------

7677	.e57e					defaultBRKHandler:
7678	.e57e	a0 00		ldy #$00	                ldy #$00
7679	.e580	20 81 e7	jsr $e781	                jsr printBRKMessage
7680	.e583	20 e7 ff	jsr $ffe7	                jsr OSNEWL
7681	.e586	ad 67 02	lda $0267	                lda startupMessageSuppressionStatus
7682	.e589	6a		ror a		                ror a
7683	.e58a	b0 06		bcs $e592	                bcs startCommandLineUI                   ;taken if bit 0 was set
7684	.e58c	20 e7 ff	jsr $ffe7	                jsr OSNEWL
7685	.e58f	4c bb e4	jmp $e4bb	                jmp LE496

7687						;-------------------------------------------------------------------------

7689	.e592					startCommandLineUI:
7690	.e592	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM
7691	.e595	4c b1 86	jmp $86b1	                jmp commandLineUI

7693						;-------------------------------------------------------------------------
7694						;
7695						; Select paged ROM bank 15 - TERMINAL - with ANDY paged in,
7696						;
7697						; Preserves A/Y
7698	.e598					selectTerminalROMAndANDY:   ;e57f
7699	.e598	a2 8f		ldx #$8f	                ldx #$80|terminalROM
7700						                ; fall through into selectROMX

7702						;-------------------------------------------------------------------------
7703						;-------------------------------------------------------------------------
7704						;
7705						; Select paged ROM bank.
7706						;
7707						; Entry:
7708						;
7709						; X = bank to select.
7710						;
7711						; Preserves A/X/Y/P
7712	.e59a					selectROMX:   ;e581
7713	.e59a	86 f4		stx $f4		                stx $F4
7714	.e59c	8e 30 fe	stx $fe30	                stx ROMSEL
7715	.e59f	60		rts		                rts

7717						;-------------------------------------------------------------------------
7718						;
7719	.e5a0					isROMValidThenSelectTerminalROM:
7720	.e5a0	5a		phy		                phy
7721	.e5a1	20 1e e4	jsr $e41e	                jsr isROMValid
7722	.e5a4	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM
7723	.e5a7	7a		ply		                ply
7724	.e5a8	60		rts		                rts

7726						;-------------------------------------------------------------------------
7727						;
7728						; Select paged ROM bank 15 -
7729						;
7730						; Preserves X/Y
7731	.e5a9					selectTerminalROM:            ;e590
7732	.e5a9	a9 0f		lda #$0f	                lda #terminalROM
7733						                ; fall through into selectROMA

7735						;-------------------------------------------------------------------------
7736						;
7737						; Select paged ROM bank.
7738						;
7739						; A = bank to select.
7740						;
7741						; Preserves A/X/Y/P
7742	.e5ab					selectROMA:                   ;e592
7743	.e5ab	85 f4		sta $f4		                sta $F4         ;update ROMSEL copy
7744	.e5ad	8d 30 fe	sta $fe30	                sta ROMSEL
7745	.e5b0	60		rts		                rts

7747						;-------------------------------------------------------------------------
7748						;
7749						; Select paged ROM bank 15 - TERMINAL - with ANDY paged in,
7750						;
7751						; Preserves A/X/Y

7753	.e5b1					selectTerminalROMAndANDY2:
7754	.e5b1	da		phx		                phx
7755	.e5b2	20 98 e5	jsr $e598	                jsr selectTerminalROMAndANDY
7756	.e5b5	fa		plx		                plx
7757	.e5b6	60		rts		                rts

7759						;-------------------------------------------------------------------------

7761	.e5b7					irqEntryPoint:
7762	.e5b7	85 fc		sta $fc		                sta TEMPA
7763	.e5b9	68		pla		                pla                          ;restore P
7764	.e5ba	48		pha		                pha                          ;save P
7765	.e5bb	29 10		and #$10	                and #$10
7766	.e5bd	d0 03		bne $e5c2	                bne brkEntryPoint
7767	.e5bf	6c 04 02	jmp ($0204)	                jmp (IRQ1V)

7769	.e5c2					brkEntryPoint:
7770	.e5c2	da		phx		                phx
7771	.e5c3	ba		tsx		                tsx
7772	.e5c4	bd 03 01	lda $0103,x	                lda $0103,x                  ;get BRK address+1 LSB
7773	.e5c7	d8		cld		                cld                          ;
7774	.e5c8	38		sec		                sec                          ;
7775	.e5c9	e9 01		sbc #$01	                sbc #$01                     ;get BRK address LSB
7776	.e5cb	85 fd		sta $fd		                sta errPtr+0
7777	.e5cd	bd 04 01	lda $0104,x	                lda $0104,x                  ;get BRK address+1 MSB
7778	.e5d0	e9 00		sbc #$00	                sbc #$00                     ;get BRK address MSB
7779	.e5d2	85 fe		sta $fe		                sta errPtr+1
7780	.e5d4	a5 f4		lda $f4		                lda $F4
7781	.e5d6	8d 4a 02	sta $024a	                sta romActiveAtLastBRK
7782	.e5d9	86 f0		stx $f0		                stx originalX
7783	.e5db	a2 06		ldx #$06	                ldx #romServiceCallBreakInstruction
7784	.e5dd	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
7785	.e5e0	ae 8c 02	ldx $028c	                ldx currentLanguageROM
7786	.e5e3	20 9a e5	jsr $e59a	                jsr selectROMX
7787	.e5e6	fa		plx		                plx
7788	.e5e7	a5 fc		lda $fc		                lda TEMPA
7789	.e5e9	58		cli		                cli
7790	.e5ea	6c 02 02	jmp ($0202)	                jmp (BRKV)

7792						;-------------------------------------------------------------------------

7795	.e5ed					LE5D4:
7796	.e5ed	38		sec		                sec
7797	.e5ee	6e 4f 02	ror $024f	                ror rs423Busy
7798	.e5f1	2c 50 02	bit $0250	                bit aciaControlRegister
7799	.e5f4	10 07		bpl $e5fd	                bpl LE5E4
7800	.e5f6	20 be ed	jsr $edbe	                jsr getRS423InputBufferFreeBytes
7801	.e5f9	a2 00		ldx #$00	                ldx #$00
7802	.e5fb	b0 02		bcs $e5ff	                bcs LE5E6
7803	.e5fd					LE5E4:
7804	.e5fd	a2 40		ldx #$40	                ldx #$40
7805	.e5ff					LE5E6:
7806	.e5ff	4c 3d ea	jmp $ea3d	                jmp resetACIAState

7808	.e602					LE5E9:
7809	.e602	ac 09 fe	ldy $fe09	                ldy ACIA+1
7810	.e605	29 3a		and #$3a	                and #$3A
7811	.e607	d0 3b		bne $e644	                bne LE628
7812	.e609	ae 5c 02	ldx $025c	                ldx rs423Ignore
7813	.e60c	d0 09		bne $e617	                bne LE5FE
7814	.e60e	e8		inx		                inx
7815	.e60f	20 ab eb	jsr $ebab	                jsr osbyte99
7816	.e612	20 be ed	jsr $edbe	                jsr getRS423InputBufferFreeBytes
7817	.e615	90 e6		bcc $e5fd	                bcc LE5E4
7818	.e617					LE5FE:
7819	.e617	60		rts		                rts

7822						;-------------------------------------------------------------------------

7824	.e618					irq1EntryPoint:
7825	.e618	a5 fc		lda $fc		                lda TEMPA
7826	.e61a	48		pha		                pha
7827	.e61b	da		phx		                phx
7828	.e61c	5a		phy		                phy
7830	.e61d	b8		clv		                clv
7832	.e61e	20 28 e6	jsr $e628	                jsr irq1Handler
7833	.e621	7a		ply		                ply
7834	.e622	fa		plx		                plx
7835	.e623	68		pla		                pla
7836	.e624	40		rti		                rti

7838						;-------------------------------------------------------------------------

7840	.e625					irq2EntryPoint:
7841	.e625	a5 fc		lda $fc		                lda TEMPA
7842	.e627	40		rti		                rti

7844						;-------------------------------------------------------------------------

7850	.e628					irq1Handler:
7851	.e628	ad 08 fe	lda $fe08	                lda ACIA+0
7853	.e62b	2d 78 02	and $0278	                and rs423InterruptMask
7855	.e62e	70 02		bvs $e632	                bvs LE616
7856	.e630	10 59		bpl $e68b	                bpl checkForSystemVIAInterrupt
7857	.e632					LE616:
7858	.e632	a6 ea		ldx $ea		                ldx $EA
7859	.e634	ca		dex		                dex
7860	.e635	30 33		bmi $e66a	                bmi LE64E
7861	.e637	70 30		bvs $e669	                bvs rtsE64D
7862	.e639	20 61 f4	jsr $f461	                jsr withTerminalROM
7863	.e63c	4c d7 a8	jmp $a8d7	                jmp LA45D

7865	.e63f					LE623:
7866	.e63f	ac 09 fe	ldy $fe09	                ldy ACIA+1
7867	.e642	2a		rol a		                rol a
7868	.e643	0a		asl a		                asl a
7869	.e644					LE628:
7870	.e644	aa		tax		                tax
7871	.e645	98		tya		                tya
7872	.e646	a0 07		ldy #$07	                ldy #$07
7873	.e648	4c 53 eb	jmp $eb53	                jmp eventEntryPoint

7875	.e64b					LE62F:
7876	.e64b	a2 02		ldx #$02	                ldx #$02
7877	.e64d	20 1f eb	jsr $eb1f	                jsr osbyte91
7878	.e650	90 10		bcc $e662	                bcc LE646
7879	.e652	ad 85 02	lda $0285	                lda printerDriverType
7880	.e655	c9 02		cmp #$02	                cmp #$02
7881	.e657	d0 94		bne $e5ed	                bne LE5D4
7882	.e659	e8		inx		                inx
7883	.e65a	20 1f eb	jsr $eb1f	                jsr osbyte91
7884	.e65d	6e d1 02	ror $02d1	                ror bufferEmptyFlags+bufferPrinter
7885	.e660	30 8b		bmi $e5ed	                bmi LE5D4
7886	.e662					LE646:
7887	.e662	8d 09 fe	sta $fe09	                sta ACIA+1
7888	.e665	a9 e7		lda #$e7	                lda #$E7
7889	.e667	85 ea		sta $ea		                sta $EA
7890	.e669					rtsE64D:
7891	.e669	60		rts		                rts

7893	.e66a					LE64E:
7897	.e66a	4a		lsr a		                lsr a
7898	.e66b	90 07		bcc $e674	                bcc LE65B
7899	.e66d	70 05		bvs $e674	                bvs LE65B
7900	.e66f	ac 50 02	ldy $0250	                ldy aciaControlRegister
7901	.e672	30 8e		bmi $e602	                bmi LE5E9
7902	.e674					LE65B:
7903	.e674	4a		lsr a		                lsr a
7904	.e675	6a		ror a		                ror a
7905	.e676	b0 c7		bcs $e63f	                bcs LE623
7906	.e678	30 d1		bmi $e64b	                bmi LE62F
7907	.e67a	70 ed		bvs $e669	                bvs rtsE64D

7910						;-------------------------------------------------------------------------

7912	.e67c					handleUnrecogisedInterrupt:
7913	.e67c	a2 05		ldx #$05	                ldx #romServiceCallUnrecognisedInterrupt
7914	.e67e	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
7915	.e681	f0 e6		beq $e669	                beq rtsE64D                  ;taken if handled

7917						                ; Pass unrecognised, unhandled interrupts to IRQ2V.
7918	.e683	68		pla		                pla
7919	.e684	68		pla		                pla
7920	.e685	7a		ply		                ply
7921	.e686	fa		plx		                plx
7922	.e687	68		pla		                pla
7926	.e688	6c 06 02	jmp ($0206)	                jmp (IRQ2V)

7928						;-------------------------------------------------------------------------

7933	.e68b					checkForSystemVIAInterrupt:
7935	.e68b	ad 4d fe	lda $fe4d	                lda systemVIA.ifr
7939	.e68e	10 3c		bpl $e6cc	                bpl checkForUserVIAInterrupt
7941	.e690	2d 79 02	and $0279	                and systemVIAInterruptMask
7942	.e693	2d 4e fe	and $fe4e	                and systemVIA.ier
7943	.e696	89 02		bit #$02	                bit #VIA.irq.ca1
7944	.e698	f0 54		beq $e6ee	                beq checkForSystemVIAT1Interrupt

7946						                ; Handle CA1 interrupt - CRTC vsync.

7948	.e69a	ce 40 02	dec $0240	                dec cfsTimeoutCounter
7950	.e69d	a5 ea		lda $ea		                lda $EA
7951	.e69f	10 02		bpl $e6a3	                bpl +
7952	.e6a1	e6 ea		inc $ea		                inc $EA
7953	.e6a3					+
7955	.e6a3	ad 51 02	lda $0251	                lda flashCounter
7956	.e6a6	f0 1a		beq $e6c2	                beq flashDone                    ;taken if no flash
7957	.e6a8	ce 51 02	dec $0251	                dec flashCounter             ;count down
7958	.e6ab	d0 15		bne $e6c2	                bne flashDone
7959	.e6ad	ae 52 02	ldx $0252	                ldx firstFlashColourDuration ;assume first flash colour is next
7960	.e6b0	ad 48 02	lda $0248	                lda vcontrolRegister
7961	.e6b3	4a		lsr a		                lsr a                        ;C=flash bit
7962	.e6b4	90 03		bcc $e6b9	                bcc +                        ;taken if first flash colour is next
7963	.e6b6	ae 53 02	ldx $0253	                ldx secondFlashColourDuration ;actually, second flash colour is next
7964	.e6b9					+
7965	.e6b9	2a		rol a		                rol a                        ;reinstate old register value
7966	.e6ba	49 01		eor #$01	                eor #VCONTROL.flash          ;toggle flash bit
7967	.e6bc	20 0f f3	jsr $f30f	                jsr setVCONTROL
7968	.e6bf	8e 51 02	stx $0251	                stx flashCounter
7969	.e6c2					flashDone:
7970	.e6c2	a0 04		ldy #$04	                ldy #eventStartOfVerticalSync
7971	.e6c4	20 53 eb	jsr $eb53	                jsr eventEntryPoint
7972	.e6c7	a9 02		lda #$02	                lda #VIA.irq.ca1
7976	.e6c9	4c 6f e7	jmp $e76f	                jmp staSystemVIAIFR          ;acknowledge CA1

7980	.e6cc					checkForUserVIAInterrupt:
7981	.e6cc	ad 6d fe	lda $fe6d	                lda userVIA.ifr
7982	.e6cf	10 ab		bpl $e67c	                bpl handleUnrecogisedInterrupt
7983	.e6d1	2d 77 02	and $0277	                and userVIAInterruptMask
7984	.e6d4	2d 6e fe	and $fe6e	                and userVIA.ier
7985	.e6d7	6a		ror a		                ror a                        ;C=CA2
7986	.e6d8	6a		ror a		                ror a                        ;C=CA1
7987	.e6d9	90 a1		bcc $e67c	                bcc handleUnrecogisedInterrupt
7988	.e6db	ac 85 02	ldy $0285	                ldy printerDriverType
7989	.e6de	88		dey		                dey
7990	.e6df	d0 9b		bne $e67c	                bne handleUnrecogisedInterrupt ;taken if printerDriverType not 1
7991	.e6e1	a9 02		lda #$02	                lda #VIA.irq.ca1
7992	.e6e3	8d 6d fe	sta $fe6d	                sta userVIA.ifr              ;acknowledge CA1
7993	.e6e6	8d 6e fe	sta $fe6e	                sta userVIA.ier              ;inhibit CA1
7994	.e6e9	a2 03		ldx #$03	                ldx #bufferPrinter
7995	.e6eb	4c 00 ea	jmp $ea00	                jmp LE8D5

7998	.e6ee					checkForSystemVIAT1Interrupt:
7999	.e6ee	89 40		bit #$40	                bit #VIA.irq.t1
8003	.e6f0	f0 74		beq $e766	                beq checkForSystemVIACA2Interrupt

8006						                ; Handle T1 interrupt - 100 Hz timer.

8008	.e6f2	a9 40		lda #$40	                lda #VIA.irq.t1
8009	.e6f4	8d 4d fe	sta $fe4d	                sta systemVIA.ifr            ;acknowledge T1 interrupt
8010	.e6f7	ad 83 02	lda $0283	                lda timerSwitchState
8011	.e6fa	aa		tax		                tax                          ;X=old timerSwitchState
8012	.e6fb	49 0f		eor #$0f	                eor #$0F
8013	.e6fd	48		pha		                pha                          ;save new timerSwitchState
8014	.e6fe	a8		tay		                tay                          ;Y=new timerSwitchState
8015	.e6ff	38		sec		                sec                          ;C=1 - increment
8016	.e700					updateTIMELoop:
8017	.e700	bd 91 02	lda $0291,x	                lda timer0-1,x
8018	.e703	69 00		adc #$00	                adc #$00
8019	.e705	99 91 02	sta $0291,y	                sta timer0-1,y

8021						                ; one of X or Y will get to 0 to indicate the end of
8022						                ; the loop.
8023	.e708	ca		dex		                dex
8024	.e709	f0 03		beq $e70e	                beq updateTIMEDone
8025	.e70b	88		dey		                dey
8026	.e70c	d0 f2		bne $e700	                bne updateTIMELoop
8027	.e70e					updateTIMEDone:
8028	.e70e	68		pla		                pla                          ;restore new timerSwitchState
8029	.e70f	8d 83 02	sta $0283	                sta timerSwitchState
8030	.e712	a2 05		ldx #$05	                ldx #$05
8031	.e714					incrementIntervalTimer:
8032	.e714	fe 9b 02	inc $029b,x	                inc intervalTimer-1,x
8033	.e717	d0 08		bne $e721	                bne intervalTimerDone
8034	.e719	ca		dex		                dex
8035	.e71a	d0 f8		bne $e714	                bne incrementIntervalTimer
8036	.e71c	a0 05		ldy #$05	                ldy #eventIntervalTimerCrossingZero
8037	.e71e	20 53 eb	jsr $eb53	                jsr eventEntryPoint
8038	.e721					intervalTimerDone:
8039	.e721	ad b1 02	lda $02b1	                lda inkeyTimeoutCounter+0
8040	.e724	d0 08		bne $e72e	                bne LE715
8041	.e726	ad b2 02	lda $02b2	                lda inkeyTimeoutCounter+1
8042	.e729	f0 06		beq $e731	                beq LE718
8043	.e72b	ce b2 02	dec $02b2	                dec inkeyTimeoutCounter+1
8044	.e72e					LE715:
8045	.e72e	ce b1 02	dec $02b1	                dec inkeyTimeoutCounter+0
8046	.e731					LE718:
8047	.e731	2c cd 02	bit $02cd	                bit previousKeyPressedWhenReadingOSBYTE
8048	.e734	10 0b		bpl $e741	                bpl LE728
8049	.e736	ee cd 02	inc $02cd	                inc previousKeyPressedWhenReadingOSBYTE
8050	.e739	58		cli		                cli
8054	.e73a	20 ec f4	jsr $f4ec	                jsr LF416                    ;update sound???
8056	.e73d	78		sei		                sei
8057	.e73e	ce cd 02	dec $02cd	                dec previousKeyPressedWhenReadingOSBYTE
8058	.e741					LE728:
8059	.e741	2c 70 e3	bit $e370	                bit valueFF                  ;V=1
8061	.e744	20 28 e6	jsr $e628	                jsr irq1Handler
8063	.e747	a5 ec		lda $ec		                lda lastKeyPressedInternal
8064	.e749	05 ed		ora $ed		                ora firstKeyPressedInternal
8065	.e74b	2d 42 02	and $0242	                and keyboardSemaphore
8066	.e74e	f0 04		beq $e754	                beq +
8067	.e750	38		sec		                sec
8068	.e751	20 9b f7	jsr $f79b	                jsr LF8FF
8069	.e754					+
8071	.e754	20 99 e7	jsr $e799	                jsr handleDigitalJoystick
8073	.e757	20 5e ea	jsr $ea5e	                jsr pollPrinterDriver
8074	.e75a	ac 43 02	ldy $0243	                ldy romPollingSemaphore
8078	.e75d	f0 05		beq $e764	                beq LE748
8080	.e75f	a2 15		ldx #$15	                ldx #romServiceCallPollingInterrupt
8084	.e761	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
8085	.e764					LE748:
8090	.e764	60		rts		                rts

8094	.e765					checkForSystemVIACB1Interrupt:
8132	.e765					initiateADCConversion:
8133	.e765	60		rts		                rts

8137	.e766					checkForSystemVIACA2Interrupt:
8138	.e766	4a		lsr a		                lsr a                        ;C = CA2
8139	.e767	90 0a		bcc $e773	                bcc handleUnrecognisedInterruptE799

8141						                ; Handle CA2 interrupt - keyboard.

8143	.e769	18		clc		                clc
8144	.e76a	20 9b f7	jsr $f79b	                jsr LF8FF
8145	.e76d	a9 01		lda #$01	                lda #VIA.irq.ca2
8149	.e76f					staSystemVIAIFR:
8150	.e76f	8d 4d fe	sta $fe4d	                sta systemVIA.ifr
8151	.e772					rtsE6B6:
8152	.e772	60		rts		                rts

8155	.e773					handleUnrecognisedInterruptE799:
8156	.e773	4c 7c e6	jmp $e67c	                jmp handleUnrecogisedInterrupt

8158						;-------------------------------------------------------------------------
8159						;
8160						; OSBYTE 17 (&11) Write next ADC channel to be sampled [MasRef D.2-25]
8161						;
8162	.e776					osbyte11:
8167	.e776	8c 4c 02	sty $024c	                sty currentADCChannel
8169	.e779	80 ea		bra $e765	                bra initiateADCConversion

8172						;-------------------------------------------------------------------------
8173						;
8174						; Print a 0-terminated string at some offset from startupMessages.
8175						;
8176						; entry:
8177						;
8178						; Y = offset-1 of message
8179						;
8180	.e77b					printStartupMessage:
8181	.e77b	a9 e0		lda #$e0	                lda #>startupMessages
8182						                ; .cerror (<startupMessages)!=0,"startupMessages must be page-aligned" ;it's more flexible than this, but this'll do for now

8184						;-------------------------------------------------------------------------
8185						;
8186						; Print a 0-terminated string.
8187						;
8188						; entry:
8189						;
8190						; A = address MSB
8191						;
8192						; Y = (address LSB)-1
8193						;
8194	.e77d					print0TerminatedString:
8195	.e77d	85 fe		sta $fe		                sta errPtr+1
8196	.e77f	64 fd		stz $fd		                stz errPtr+0

8198						;-------------------------------------------------------------------------
8199						;
8200						; Print the BRK message.
8201						;
8202						; entry:
8203						;
8204						; (errPtr) = pointer to the error number (as will be the case after a
8205						; BRK)
8206						;
8207						; Y=0
8208						;
8209	.e781					printBRKMessage:
8210	.e781	c8		iny		                iny
8211	.e782	b1 fd		lda ($fd),y	                lda (errPtr),y
8212	.e784	20 e3 ff	jsr $ffe3	                jsr OSASCI
8213	.e787	aa		tax		                tax
8214	.e788	d0 f7		bne $e781	                bne printBRKMessage
8215	.e78a					rtsE7B0:
8216	.e78a	60		rts		                rts

8218						;-------------------------------------------------------------------------

8221						;-------------------------------------------------------------------------

8223	>e78b	00				unk_E78B:       .byte 0
8224	>e78c	8d				                .byte $8D       ;
8225	>e78d	8f				                .byte $8F       ;
8226	>e78e	8e				                .byte $8E       ;
8227	>e78f	8c				                .byte $8C       ;
8228	>e790	7f				                .byte $7F       ;
8229	>e791	0d				                .byte $D
8230	>e792	8b				                .byte $8B       ;
8231	>e793	8b				                .byte $8B       ;
8232	>e794	96				unk_E794:       .byte $96
8233	>e795	e6				                .byte $E6       ;
8234	>e796	d6				                .byte $D6       ;
8235	>e797	c6				                .byte $C6       ;
8236	>e798	86				                .byte $86       ;

8238						;-------------------------------------------------------------------------

8240	.e799					handleDigitalJoystick:.block
8241	.e799	ad 4d 02	lda $024d	                lda maximumADCChannel
8242	.e79c	f0 ec		beq $e78a	                beq rtsE7B0
8243	.e79e	2c 4e 02	bit $024e	                bit adcConversionType
8244	.e7a1	50 3b		bvc $e7de	                bvc LE7DE
8245	.e7a3	ad b6 02	lda $02b6	                lda adcResultLSBs
8246	.e7a6	a2 00		ldx #$00	                ldx #0

8248	.e7a8					LE7A8:
8249	.e7a8	e8		inx		                inx
8250	.e7a9	0a		asl a		                asl a
8251	.e7aa	b0 03		bcs $e7af	                bcs LE7AF
8252	.e7ac	d0 fa		bne $e7a8	                bne LE7A8
8253	.e7ae	aa		tax		                tax

8255	.e7af					LE7AF:
8256	.e7af	bc 8b e7	ldy $e78b,x	                ldy unk_E78B,x
8257	.e7b2	cc be 02	cpy $02be	                cpy adcLastChannelRead
8258	.e7b5	8c be 02	sty $02be	                sty adcLastChannelRead
8259	.e7b8	f0 0c		beq $e7c6	                beq LE7C6
8260	.e7ba	98		tya		                tya
8261	.e7bb	f0 09		beq $e7c6	                beq LE7C6
8262	.e7bd	20 a9 eb	jsr $eba9	                jsr insertCharacterIntoKeyboardBuffer
8263	.e7c0	ad 54 02	lda $0254	                lda keyboardAutoRepeatDelay
8264	.e7c3	8d bd 02	sta $02bd	                sta adcResultMSBs+3

8266	.e7c6					LE7C6:
8267	.e7c6	ad bd 02	lda $02bd	                lda adcResultMSBs+3
8268	.e7c9	f0 13		beq $e7de	                beq LE7DE
8269	.e7cb	ce bd 02	dec $02bd	                dec adcResultMSBs+3
8270	.e7ce	d0 0e		bne $e7de	                bne LE7DE
8271	.e7d0	ad 55 02	lda $0255	                lda keyboardAutoRepeatRate
8272	.e7d3	8d bd 02	sta $02bd	                sta adcResultMSBs+3
8273	.e7d6	ac be 02	ldy $02be	                ldy adcLastChannelRead
8274	.e7d9	f0 03		beq $e7de	                beq LE7DE
8275	.e7db	20 a9 eb	jsr $eba9	                jsr insertCharacterIntoKeyboardBuffer

8277	.e7de					LE7DE:
8278	.e7de	2c 4e 02	bit $024e	                bit adcConversionType
8279	.e7e1	10 07		bpl $e7ea	                bpl LE7EA
8280	.e7e3	a0 b6		ldy #$b6	                ldy #$B6
8281	.e7e5	a2 2c		ldx #$2c	                ldx #romServiceCallCompactJoystick
8282	.e7e7	4c ff ee	jmp $eeff	                jmp makeROMServiceCall

8284						;-------------------------------------------------------------------------

8286	.e7ea					LE7EA:
8287	.e7ea	a9 ff		lda #$ff	                lda #$FF
8288	.e7ec	ae 7d 02	ldx $027d	                ldx editKeysMode
8289	.e7ef	e0 03		cpx #$03	                cpx #3
8290	.e7f1	d0 14		bne $e807	                bne LE807
8291	.e7f3	e8		inx		                inx

8293	.e7f4					LE7F4:
8294	.e7f4	48		pha		                pha
8295	.e7f5	da		phx		                phx
8296	.e7f6	bd 94 e7	lda $e794,x	                lda unk_E794,x
8297	.e7f9	aa		tax		                tax
8298	.e7fa	38		sec		                sec
8299	.e7fb	b8		clv		                clv
8300	.e7fc	20 98 ed	jsr $ed98	                jsr LED01
8301	.e7ff	fa		plx		                plx
8302	.e800	68		pla		                pla
8303	.e801	2a		rol a		                rol a
8304	.e802	ca		dex		                dex
8305	.e803	10 ef		bpl $e7f4	                bpl LE7F4
8306	.e805	49 ff		eor #$ff	                eor #$FF

8308	.e807					LE807:
8309	.e807	2d 60 fe	and $fe60	                and userVIA.irb
8310	.e80a	49 1f		eor #$1f	                eor #$1F
8311	.e80c	4a		lsr a		                lsr a
8312	.e80d	08		php		                php
8313	.e80e	0a		asl a		                asl a
8314	.e80f	0a		asl a		                asl a
8315	.e810	0a		asl a		                asl a
8316	.e811	28		plp		                plp
8317	.e812	2a		rol a		                rol a
8318	.e813	aa		tax		                tax
8319	.e814	4d b6 02	eor $02b6	                eor adcResultLSBs
8320	.e817	2c 4e 02	bit $024e	                bit adcConversionType
8321	.e81a	29 f0		and #$f0	                and #$F0
8322	.e81c	8e b6 02	stx $02b6	                stx adcResultLSBs
8323	.e81f	70 05		bvs $e826	                bvs locret_E826
8324	.e821	f0 04		beq $e827	                beq LE827
8325	.e823	9c bd 02	stz $02bd	                stz adcResultMSBs+3

8327	.e826					locret_E826:
8328	.e826	60		rts		                rts

8330						;-------------------------------------------------------------------------

8332	.e827					LE827:
8333	.e827	ad 4e 02	lda $024e	                lda adcConversionType
8334	.e82a	f0 06		beq $e832	                beq LE832
8335	.e82c	c9 08		cmp #$08	                cmp #8
8336	.e82e	90 04		bcc $e834	                bcc LE834
8337	.e830	a9 04		lda #$04	                lda #4

8339	.e832					LE832:
8340	.e832	49 03		eor #$03	                eor #3

8342	.e834					LE834:
8343	.e834	a8		tay		                tay
8344	.e835	3a		dec a		                dec a
8345	.e836	aa		tax		                tax
8346	.e837	ad bd 02	lda $02bd	                lda adcResultMSBs+3
8347	.e83a	9c bc 02	stz $02bc	                stz adcResultMSBs+2

8349	.e83d					LE83D:
8350	.e83d	ca		dex		                dex
8351	.e83e	30 06		bmi $e846	                bmi LE846
8352	.e840	0a		asl a		                asl a
8353	.e841	2e bc 02	rol $02bc	                rol adcResultMSBs+2
8354	.e844	80 f7		bra $e83d	                bra LE83D

8356						;-------------------------------------------------------------------------

8358	.e846					LE846:
8359	.e846	8d bb 02	sta $02bb	                sta adcResultMSBs+1
8360	.e849	cc bc 02	cpy $02bc	                cpy adcResultMSBs+2
8361	.e84c	b0 06		bcs $e854	                bcs LE854
8362	.e84e	8c bb 02	sty $02bb	                sty adcResultMSBs+1
8363	.e851	8c bc 02	sty $02bc	                sty adcResultMSBs+2

8365	.e854					LE854:
8366	.e854	ad 4e 02	lda $024e	                lda adcConversionType
8367	.e857	29 20		and #$20	                and #$20
8368	.e859	f0 0f		beq $e86a	                beq LE86A
8369	.e85b	a9 ff		lda #$ff	                lda #$FF
8370	.e85d	8d b7 02	sta $02b7	                sta adcResultLSBs+1
8371	.e860	8d b9 02	sta $02b9	                sta adcResultLSBs+3
8372	.e863	4a		lsr a		                lsr a
8373	.e864	8d b8 02	sta $02b8	                sta adcResultLSBs+2
8374	.e867	8d ba 02	sta $02ba	                sta adcResultMSBs

8376	.e86a					LE86A:
8377	.e86a	a2 09		ldx #$09	                ldx #9

8379	.e86c					LE86C:
8380	.e86c	ad b6 02	lda $02b6	                lda adcResultLSBs
8381	.e86f	3c d5 e8	bit $e8d5,x	                bit unk_E8D5,x
8382	.e872	f0 3e		beq $e8b2	                beq LE8B2
8383	.e874	bd d6 e8	lda $e8d6,x	                lda unk_E8D5+1,x
8384	.e877	0a		asl a		                asl a
8385	.e878	a8		tay		                tay
8386	.e879	ad 4e 02	lda $024e	                lda adcConversionType
8387	.e87c	29 20		and #$20	                and #$20        ; ' '
8388	.e87e	f0 05		beq $e885	                beq LE885
8389	.e880	bd d7 e8	lda $e8d7,x	                lda unk_E8D5+2,x
8390	.e883	80 27		bra $e8ac	                bra LE8AC

8392						;-------------------------------------------------------------------------

8394	.e885					LE885:
8395	.e885	b9 b7 02	lda $02b7,y	                lda adcResultLSBs+1,y
8396	.e888	b0 12		bcs $e89c	                bcs LE89C
8397	.e88a	6d bb 02	adc $02bb	                adc adcResultMSBs+1
8398	.e88d	99 b7 02	sta $02b7,y	                sta adcResultLSBs+1,y
8399	.e890	b9 b8 02	lda $02b8,y	                lda adcResultLSBs+2,y
8400	.e893	6d bc 02	adc $02bc	                adc adcResultMSBs+2
8401	.e896	90 17		bcc $e8af	                bcc LE8AF
8402	.e898	a9 ff		lda #$ff	                lda #$FF
8403	.e89a	80 10		bra $e8ac	                bra LE8AC

8405						;-------------------------------------------------------------------------

8407	.e89c					LE89C:
8408	.e89c	ed bb 02	sbc $02bb	                sbc adcResultMSBs+1
8409	.e89f	99 b7 02	sta $02b7,y	                sta adcResultLSBs+1,y
8410	.e8a2	b9 b8 02	lda $02b8,y	                lda adcResultLSBs+2,y
8411	.e8a5	ed bc 02	sbc $02bc	                sbc adcResultMSBs+2
8412	.e8a8	b0 05		bcs $e8af	                bcs LE8AF
8413	.e8aa	a9 00		lda #$00	                lda #0

8415	.e8ac					LE8AC:
8416	.e8ac	99 b7 02	sta $02b7,y	                sta adcResultLSBs+1,y

8418	.e8af					LE8AF:
8419	.e8af	99 b8 02	sta $02b8,y	                sta adcResultLSBs+2,y

8421	.e8b2					LE8B2:
8422	.e8b2	ca		dex		                dex
8423	.e8b3	ca		dex		                dex
8424	.e8b4	ca		dex		                dex
8425	.e8b5	10 b5		bpl $e86c	                bpl LE86C
8426	.e8b7	ee bd 02	inc $02bd	                inc adcResultMSBs+3
8427	.e8ba	d0 03		bne $e8bf	                bne LE8BF
8428	.e8bc	ce bd 02	dec $02bd	                dec adcResultMSBs+3

8430	.e8bf					LE8BF:
8431	.e8bf	ae 4c 02	ldx $024c	                ldx currentADCChannel
8432	.e8c2	a0 03		ldy #$03	                ldy #3
8433	.e8c4	20 53 eb	jsr $eb53	                jsr eventEntryPoint
8434	.e8c7	ce 4c 02	dec $024c	                dec currentADCChannel
8435	.e8ca	f0 02		beq $e8ce	                beq LE8CE
8436	.e8cc	10 06		bpl $e8d4	                bpl locret_E8D4

8438	.e8ce					LE8CE:
8439	.e8ce	ad 4d 02	lda $024d	                lda maximumADCChannel
8440	.e8d1	8d 4c 02	sta $024c	                sta currentADCChannel

8442	.e8d4					locret_E8D4:
8443	.e8d4	60		rts		                rts
8444						                .endblock

8446						;-------------------------------------------------------------------------

8448	>e8d5	40				unk_E8D5:       .byte $40; @
8449	>e8d6	01				                .byte 1
8450	>e8d7	ff				                .byte $FF
8451	>e8d8	20				                .byte $20
8452	>e8d9	81				                .byte $81       ;
8453	>e8da	00				                .byte 0
8454	>e8db	80				                .byte $80       ;
8455	>e8dc	80				                .byte $80       ;
8456	>e8dd	00				                .byte 0
8457	>e8de	10				                .byte $10
8458	>e8df	00				                .byte 0
8459	>e8e0	ff				                .byte $FF

8462						;-------------------------------------------------------------------------

8464	.e8e1					osbyte81Timed:
8465	.e8e1	8e b1 02	stx $02b1	                stx inkeyTimeoutCounter+0
8466	.e8e4	8c b2 02	sty $02b2	                sty inkeyTimeoutCounter+1
8467	.e8e7	66 e6		ror $e6		                ror readCharacterTimedFlag   ;set the timed flag
8468	.e8e9	58		cli		                cli
8469	.e8ea	80 02		bra $e8ee	                bra osrdchWithTimeout

8471						;-------------------------------------------------------------------------

8473	.e8ec					osrdchEntryPoint:
8474	.e8ec	64 e6		stz $e6		                stz readCharacterTimedFlag   ;clear the timed flag
8475	.e8ee					osrdchWithTimeout:
8476	.e8ee	da		phx		                phx
8477	.e8ef	5a		phy		                phy
8478	.e8f0	ac 56 02	ldy $0256	                ldy execFileHandle
8479	.e8f3	f0 12		beq $e907	                beq osrdchLoop               ;taken if not *EXEC'ing
8480	.e8f5	38		sec		                sec
8481	.e8f6	66 eb		ror $eb		                ror tapeCritical
8482	.e8f8	20 d7 ff	jsr $ffd7	                jsr OSBGET             ;get 1 byte from the *EXEC file
8483	.e8fb	64 eb		stz $eb		                stz tapeCritical
8484	.e8fd	90 24		bcc $e923	                bcc osrdchDone                    ;taken if byte valid
8485	.e8ff	a9 00		lda #$00	                lda #$00                     ;OSFIND close file
8486	.e901	9c 56 02	stz $0256	                stz execFileHandle           ;reset *EXEC handle
8487	.e904	20 ce ff	jsr $ffce	                jsr OSFIND                   ;close *EXEC file
8488	.e907					osrdchLoop:
8489	.e907	a5 ff		lda $ff		                lda escapeFlag               ;b7 set if ESCAPE pressed
8490	.e909	0a		asl a		                asl a                        ;C=1 if ESCAPE pressed
8491	.e90a	a9 1b		lda #$1b	                lda #27                      ;ASCII for ESCAPE
8492	.e90c	b0 15		bcs $e923	                bcs osrdchDone               ;exit with C=1 if ESCAPE
8493						                                             ;pressed
8495	.e90e	ae 41 02	ldx $0241	                ldx inputSource
8497	.e911	20 5e ec	jsr $ec5e	                jsr readFromEconetOrSoftKeyOrInputBufferA ;handle Econet/soft key stuff???
8498	.e914	90 0d		bcc $e923	                bcc osrdchDone
8499	.e916	24 e6		bit $e6		                bit readCharacterTimedFlag
8500	.e918	10 ed		bpl $e907	                bpl osrdchLoop     ;taken if no timeout - keep looping
8501	.e91a	ad b2 02	lda $02b2	                lda inkeyTimeoutCounter+1
8502	.e91d	0d b1 02	ora $02b1	                ora inkeyTimeoutCounter+0
8503	.e920	d0 e5		bne $e907	                bne osrdchLoop     ;taken if timeout not timed out yet
8504	.e922	3a		dec a		                dec a              ;timed out: A=$ff, C=1
8505	.e923					osrdchDone:
8506	.e923	7a		ply		                ply
8507	.e924	fa		plx		                plx
8508	.e925	60		rts		                rts

8510						;-------------------------------------------------------------------------

8512	.e926					starLIBFS:
8513	.e926	ad 01 df	lda $df01	                lda hazel.activeFS
8514	.e929	8d 02 df	sta $df02	                sta hazel.libFS
8515	.e92c	60		rts		                rts

8517						;-------------------------------------------------------------------------

8526						;-------------------------------------------------------------------------
8527						;
8528						; OSCLI
8529						;
8530						; MasRef D.4-1
8531						;

8533	.e92d					oscliEntryPoint: .block
8534	.e92d	20 47 ee	jsr $ee47	                jsr selectHAZEL
8535	.e930	86 f2		stx $f2		                stx stringInputBufferAddress+0
8536	.e932	84 f3		sty $f3		                sty stringInputBufferAddress+1
8537	.e934	a0 00		ldy #$00	                ldy #$00
8538	.e936					-
8539	.e936	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
8540	.e938	99 00 dc	sta $dc00,y	                sta hazel.commandLine,y
8541	=$e93c					emptyCommandLine=*+1                         ;arbitrary place that's
8542						                                             ;just a 13 byte...
8543	.e93b	c9 0d		cmp #$0d	                cmp #$0D
8544	.e93d	f0 04		beq $e943	                beq +     ;branch taken if end of command line reached
8545	.e93f	c8		iny		                iny
8546	.e940	d0 f4		bne $e936	                bne -

8548						                ; OSCLI is a no-op if the command line is too long.
8549	.e942	60		rts		                rts

8551	.e943					+
8552	.e943	a0 dc		ldy #$dc	                ldy #>hazel.commandLine
8553	.e945	a2 00		ldx #$00	                ldx #<hazel.commandLine
8554	.e947	20 61 f4	jsr $f461	                jsr withTerminalROM
8555	.e94a	4c 8e 85	jmp $858e	                jmp oscli
8556						                .endblock

8558	=$e93c					emptyCommandLine=oscliEntryPoint.emptyCommandLine

8560						;-------------------------------------------------------------------------

8562						                ; OSWRCH
8563						                ; ======
8564	.e94d					oswrchEntryPoint:
8565	.e94d	48		pha		                pha                          ;S=[ch]
8566	.e94e	da		phx		                phx                          ;S=[x; ch]
8567	.e94f	5a		phy		                phy                          ;S=[y; x; ch]
8568	.e950	48		pha		                pha                          ;S=[ch; y; x; ch]
8569	.e951	2c 60 02	bit $0260	                bit econetOutputInterpretationStatus
8570	.e954	10 08		bpl $e95e	                bpl LE833
8571	.e956	a8		tay		                tay
8572	.e957	a9 04		lda #$04	                lda #netWriteCharacterAttempted
8573	.e959	20 65 ec	jsr $ec65	                jsr callNETV
8574	.e95c	b0 72		bcs $e9d0	                bcs LE8A5
8575	.e95e					LE833:
8576	.e95e	a9 02		lda #$02	                lda #characterDestinationStatus.vdu_disable
8577	.e960	2c 7c 02	bit $027c	                bit characterDestinationStatus
8578	.e963	d0 28		bne $e98d	                bne LE862                ; taken if VDU disabled
8583	.e965	68		pla		                pla                          ;restore char to print
8584	.e966	48		pha		                pha                          ;save it again
8585	.e967	aa		tax		                tax                          ;X=char to print
8587	.e968	ad 34 fe	lda $fe34	                lda ACCCON                   ;
8588	.e96b	48		pha		                pha                          ;S=[old ACCCON; ch; y; x; ch]
8596	.e96c	a9 08		lda #$08	                lda #ACCCON.Y
8597	.e96e	1c 34 fe	trb $fe34	                trb ACCCON                   ;MOS ROM at $c000
8599	.e971	a5 f4		lda $f4		                lda $F4
8600	.e973	48		pha		                pha          ;S=[old ROMSEL; old ACCCON; ch; y; x; ch]
8601	.e974	a9 8f		lda #$8f	                lda #$80|terminalROM
8602	.e976	85 f4		sta $f4		                sta $F4
8603	.e978	8d 30 fe	sta $fe30	                sta ROMSEL                   ;page in ANDY+Terminal
8604	.e97b	8a		txa		                txa                          ;A=char to print
8605	.e97c	20 27 c0	jsr $c027	                jsr outputToVDU
8606	.e97f	68		pla		                pla
8607	.e980	85 f4		sta $f4		                sta $F4
8608	.e982	8d 30 fe	sta $fe30	                sta ROMSEL
8609	.e985	68		pla		                pla
8610						                ; Only the saved Y bit is valid. For example, a mode
8611						                ; change might have adjusted the shadow RAM setup.
8612	.e986	29 08		and #$08	                and #ACCCON.Y
8613	.e988	0c 34 fe	tsb $fe34	                tsb ACCCON

8626	.e98b	b0 07		bcs $e994	                bcs LE869
8627	.e98d					LE862:
8628	.e98d	a9 08		lda #$08	                lda #characterDestinationStatus.printer_enable
8629	.e98f	2c 7c 02	bit $027c	                bit characterDestinationStatus
8630	.e992	f0 05		beq $e999	                beq LE86E                    ; taken if printer disabled
8631	.e994					LE869:
8632	.e994	68		pla		                pla
8633	.e995	48		pha		                pha
8634	.e996	20 d5 e9	jsr $e9d5	                jsr LE8AA
8635	.e999					LE86E:
8637	.e999	ad 7c 02	lda $027c	                lda characterDestinationStatus
8638	.e99c	6a		ror a		                ror a                      ; extract rs423_enable flag
8639	.e99d	90 1b		bcc $e9ba	                bcc LE88F                  ; taken if RS423 disabled
8640	.e99f	a4 ea		ldy $ea		                ldy $EA
8641	.e9a1	88		dey		                dey
8642	.e9a2	10 16		bpl $e9ba	                bpl LE88F
8643	.e9a4	68		pla		                pla
8644	.e9a5	48		pha		                pha
8645	.e9a6	08		php		                php
8646	.e9a7	78		sei		                sei
8647	.e9a8	a2 02		ldx #$02	                ldx #$02
8648	.e9aa	48		pha		                pha
8649	.e9ab	20 1a eb	jsr $eb1a	                jsr osbyte98
8650	.e9ae	90 03		bcc $e9b3	                bcc LE888
8651	.e9b0	20 33 ea	jsr $ea33	                jsr clearRS423BusyAndSetRS423Active
8652	.e9b3					LE888:
8653	.e9b3	68		pla		                pla
8654	.e9b4	a2 02		ldx #$02	                ldx #$02
8655	.e9b6	20 ce ea	jsr $eace	                jsr LE9A3
8656	.e9b9	28		plp		                plp
8657	.e9ba					LE88F:

8660	.e9ba	a9 10		lda #$10	                lda #characterDestinationStatus.spool_disable
8661	.e9bc	2c 7c 02	bit $027c	                bit characterDestinationStatus
8662	.e9bf	d0 0f		bne $e9d0	                bne LE8A5
8663	.e9c1	ac 57 02	ldy $0257	                ldy spoolFileHandle
8664	.e9c4	f0 0a		beq $e9d0	                beq LE8A5
8665	.e9c6	68		pla		                pla
8666	.e9c7	48		pha		                pha
8667	.e9c8	38		sec		                sec
8668	.e9c9	66 eb		ror $eb		                ror tapeCritical
8669	.e9cb	20 d4 ff	jsr $ffd4	                jsr OSBPUT
8670	.e9ce	46 eb		lsr $eb		                lsr tapeCritical
8671	.e9d0					LE8A5:
8672	.e9d0	68		pla		                pla
8673	.e9d1	7a		ply		                ply
8674	.e9d2	fa		plx		                plx
8675	.e9d3	68		pla		                pla
8676	.e9d4	60		rts		                rts

8678	.e9d5					LE8AA:
8679	.e9d5	2c 7c 02	bit $027c	                bit characterDestinationStatus
8680	.e9d8	70 25		bvs $e9ff	                bvs LE8D4
8681	.e9da	cd 86 02	cmp $0286	                cmp printerIgnoreChar
8682	.e9dd	d0 05		bne $e9e4	                bne LE8B9
8683	.e9df	2c 46 02	bit $0246	                bit noignoreState
8684	.e9e2	10 1b		bpl $e9ff	                bpl LE8D4
8685	.e9e4					LE8B9:
8686	.e9e4	08		php		                php
8687	.e9e5	78		sei		                sei
8688	.e9e6	aa		tax		                tax
8689	.e9e7	a9 04		lda #$04	                lda #characterDestinationStatus.printer_disable
8690	.e9e9	2c 7c 02	bit $027c	                bit characterDestinationStatus
8691	.e9ec	d0 10		bne $e9fe	                bne LE8D3
8692	.e9ee	8a		txa		                txa
8693	.e9ef	a2 03		ldx #$03	                ldx #$03
8694	.e9f1	20 ce ea	jsr $eace	                jsr LE9A3
8695	.e9f4	b0 08		bcs $e9fe	                bcs LE8D3
8696	.e9f6	2c d1 02	bit $02d1	                bit bufferEmptyFlags+bufferPrinter
8697	.e9f9	10 03		bpl $e9fe	                bpl LE8D3
8698	.e9fb	20 00 ea	jsr $ea00	                jsr LE8D5
8699	.e9fe					LE8D3:
8700	.e9fe	28		plp		                plp
8701	.e9ff					LE8D4:
8702	.e9ff	60		rts		                rts

8704	.ea00					LE8D5:                                       ;E7CA in MOS 4.00
8705	.ea00	ad 85 02	lda $0285	                lda printerDriverType
8707	.ea03	f0 7f		beq $ea84	                beq LE959
8708	.ea05	3a		dec a		                dec a
8709	.ea06	d0 20		bne $ea28	                bne LE8FD
8710	.ea08	20 1f eb	jsr $eb1f	                jsr osbyte91
8711	.ea0b	6e d1 02	ror $02d1	                ror bufferEmptyFlags+bufferPrinter
8712	.ea0e	30 43		bmi $ea53	                bmi rtsE928
8713	.ea10	a0 82		ldy #$82	                ldy #$82
8714	.ea12	8c 6e fe	sty $fe6e	                sty userVIA.ier
8715	.ea15	8d 61 fe	sta $fe61	                sta userVIA.ora
8716	.ea18	ad 6c fe	lda $fe6c	                lda userVIA.pcr
8717	.ea1b	29 f1		and #$f1	                and #$F1
8718	.ea1d	09 0c		ora #$0c	                ora #$0C
8719	.ea1f	8d 6c fe	sta $fe6c	                sta userVIA.pcr
8720	.ea22	09 0e		ora #$0e	                ora #$0E
8721	.ea24	8d 6c fe	sta $fe6c	                sta userVIA.pcr
8722	.ea27	60		rts		                rts

8724	.ea28					LE8FD:
8725	.ea28	3a		dec a		                dec a
8726	.ea29	d0 29		bne $ea54	                bne activatePrinterDriver
8727	.ea2b	a4 ea		ldy $ea		                ldy $EA
8728	.ea2d	88		dey		                dey
8729	.ea2e	10 54		bpl $ea84	                bpl LE959
8730	.ea30	4e d1 02	lsr $02d1	                lsr bufferEmptyFlags+bufferPrinter
8731	.ea33					clearRS423BusyAndSetRS423Active:
8732	.ea33	4e 4f 02	lsr $024f	                lsr rs423Busy
8733	.ea36					setRS423Active:
8734	.ea36	20 be ed	jsr $edbe	                jsr getRS423InputBufferFreeBytes
8735	.ea39	90 18		bcc $ea53	                bcc rtsE928
8736	.ea3b	a2 20		ldx #$20	                ldx #ACIA.control.rtsLowTXInterruptEnabled
8737	.ea3d					resetACIAState:
8738	.ea3d	a0 9f		ldy #$9f	                ldy #ACIA.control.rtsRTSInterruptEnabled|ACIA.control.word8DataOddParity1Stop|ACIA.control.reset

8740						;-------------------------------------------------------------------------
8741						;
8742						; OSBYTE 156 (&9C) Read/write serial ACIA control [MasRef D.2-47]
8743						;
8744	.ea3f					osbyte9C:
8745	.ea3f	08		php		                php
8746	.ea40	78		sei		                sei
8747	.ea41	98		tya		                tya
8748	.ea42	86 fa		stx $fa		                stx SEIWKA
8749	.ea44	2d 50 02	and $0250	                and aciaControlRegister
8750	.ea47	45 fa		eor $fa		                eor SEIWKA
8751	.ea49	ae 50 02	ldx $0250	                ldx aciaControlRegister
8752	.ea4c					writeACIAControlRegisterAndCopy:
8753	.ea4c	8d 50 02	sta $0250	                sta aciaControlRegister
8754	.ea4f	8d 08 fe	sta $fe08	                sta ACIA.control
8755	.ea52	28		plp		                plp
8756	.ea53					rtsE928:
8757	.ea53	60		rts		                rts

8770						;-------------------------------------------------------------------------

8772	.ea54					activatePrinterDriver:
8773	.ea54	18		clc		                clc
8774	.ea55	a9 01		lda #$01	                lda #printerDriverActivate
8775	.ea57	20 65 ea	jsr $ea65	                jsr callPrinterDriverWithPrinterBuffer

8777						                ; printer driver will set C=0 if active, C=1 if
8778						                ; inactive.

8780						;-------------------------------------------------------------------------
8781						;
8782						; OSBYTE 123 (&7B) Inform MOS of printer driver going dormant [MasRef
8783						; D.2-36]
8784						;
8785	.ea5a					osbyte7B:
8786	.ea5a	6e d1 02	ror $02d1	                ror bufferEmptyFlags+bufferPrinter   ;C=1 on entry, so set bit 7
8787	.ea5d					rtsE932:
8788	.ea5d	60		rts		                rts

8790						;-------------------------------------------------------------------------

8792	.ea5e					pollPrinterDriver:
8793	.ea5e	2c d1 02	bit $02d1	                bit bufferEmptyFlags+bufferPrinter
8794	.ea61	30 fa		bmi $ea5d	                bmi rtsE932           ;taken if printer driver dormant
8795	.ea63	a9 00		lda #$00	                lda #printerDriverPoll
8796	.ea65					callPrinterDriverWithPrinterBuffer:
8797	.ea65	a2 03		ldx #$03	                ldx #bufferPrinter
8798	.ea67					callPrinterDriver:
8799	.ea67	ac 85 02	ldy $0285	                ldy printerDriverType
8800	.ea6a	20 65 ec	jsr $ec65	                jsr callNETV
8801	.ea6d	6c 22 02	jmp ($0222)	                jmp (UPTV)

8803						;-------------------------------------------------------------------------
8804						;
8805						; OSBYTE 15 (&0F) Flush buffer
8806						;
8807	.ea70					osbyte0F:
8808	.ea70	d0 0f		bne $ea81	                bne LE956
8809	.ea72					LE947:
8810	.ea72	a2 08		ldx #$08	                ldx #$08
8811	.ea74					LE949:
8812	.ea74	58		cli		                cli
8813	.ea75	78		sei		                sei
8814	.ea76	20 7c ea	jsr $ea7c	                jsr osbyte15
8815	.ea79	ca		dex		                dex
8816	.ea7a	10 f8		bpl $ea74	                bpl LE949

8818						;-------------------------------------------------------------------------
8819						;
8820						; OSBYTE 21 (&15) Flush selected buffer
8821						;
8822	.ea7c					osbyte15:                                    ;e951
8823	.ea7c	e0 09		cpx #$09	                cpx #bufferMax+1
8824	.ea7e	90 04		bcc $ea84	                bcc LE959
8825	.ea80	60		rts		                rts

8827	.ea81					LE956:
8828	.ea81	ae 41 02	ldx $0241	                ldx inputSource
8829	.ea84					LE959:
8830	.ea84	18		clc		                clc
8831	.ea85					LE95A:
8832	.ea85	48		pha		                pha
8833	.ea86	08		php		                php
8834	.ea87	78		sei		                sei
8835	.ea88	b0 08		bcs $ea92	                bcs LE967
8836	.ea8a	8a		txa		                txa
8837	.ea8b	29 04		and #$04	                and #$04                     ;buffer 4-7?
8838	.ea8d	f0 03		beq $ea92	                beq LE967                    ;taken if not sound buffer
8839	.ea8f	20 f9 f4	jsr $f4f9	                jsr clearSoundChannelBuffer
8840	.ea92					LE967:
8841	.ea92	38		sec		                sec
8842	.ea93	7e ce 02	ror $02ce,x	                ror bufferEmptyFlags,x
8843	.ea96	e0 02		cpx #$02	                cpx #bufferFirstOutput
8844	.ea98	b0 06		bcs $eaa0	                bcs LE975                    ;taken if output buffer
8845	.ea9a	9c 68 02	stz $0268	                stz softKeyStringLength
8846	.ea9d	9c 6a 02	stz $026a	                stz vduQueueNegativeLength
8847	.eaa0					LE975:
8848	.eaa0	20 b8 ed	jsr $edb8	                jsr purgeBufferViaCNPV
8849	.eaa3	28		plp		                plp
8850	.eaa4	68		pla		                pla
8851	.eaa5	60		rts		                rts

8853						;-------------------------------------------------------------------------
8854						;
8855						; Count/purge entry point [AUG p264]
8856						;
8857	.eaa6					cnpEntryPoint:
8858	.eaa6	50 07		bvc $eaaf	                bvc countBuffer
8859	.eaa8					purgeBuffer:
8860	.eaa8	bd d7 02	lda $02d7,x	                lda bufferStartIndices,x
8861	.eaab	9d e0 02	sta $02e0,x	                sta bufferEndIndices,x
8862	.eaae	60		rts		                rts

8864	.eaaf					countBuffer:
8865	.eaaf	08		php		                php
8866	.eab0	78		sei		                sei
8867	.eab1	08		php		                php
8868	.eab2	38		sec		                sec
8869	.eab3	bd e0 02	lda $02e0,x	                lda bufferEndIndices,x
8870	.eab6	fd d7 02	sbc $02d7,x	                sbc bufferStartIndices,x
8871	.eab9	b0 04		bcs $eabf	                bcs LE994
8872	.eabb	38		sec		                sec
8873	.eabc	fd 06 eb	sbc $eb06,x	                sbc bufferIndex0Offsets,x
8874	.eabf					LE994:
8875	.eabf	28		plp		                plp
8876	.eac0	90 06		bcc $eac8	                bcc LE99D
8877	.eac2	18		clc		                clc
8878	.eac3	7d 06 eb	adc $eb06,x	                adc bufferIndex0Offsets,x
8879	.eac6	49 ff		eor #$ff	                eor #$FF
8880	.eac8					LE99D:
8881	.eac8	a0 00		ldy #$00	                ldy #$00
8882	.eaca	aa		tax		                tax
8883	.eacb	28		plp		                plp
8884	.eacc					rtsE9A1:
8885	.eacc	60		rts		                rts

8887						;-------------------------------------------------------------------------

8889	.eacd					LE9A2:
8890	.eacd	58		cli		                cli
8891	.eace					LE9A3:
8892	.eace	78		sei		                sei
8893	.eacf					LE9A4:
8894	.eacf	20 6b eb	jsr $eb6b	                jsr callINSV
8895	.ead2	90 f8		bcc $eacc	                bcc rtsE9A1
8896	.ead4	20 00 f3	jsr $f300	                jsr LF241
8897	.ead7	48		pha		                pha
8898	.ead8	20 42 f5	jsr $f542	                jsr updateKeyboardLEDs
8899	.eadb	0a		asl a		                asl a
8900	.eadc	68		pla		                pla
8901	.eadd	90 ee		bcc $eacd	                bcc LE9A2
8902	.eadf	60		rts		                rts

8904						;-------------------------------------------------------------------------
8905						;
8906						; OSBYTE $77
8907						;
8908						; D.2-33
8909						;
8911	.eae0					selectTerminalROMAndOSBYTE77:
8912	.eae0	20 61 f4	jsr $f461	                jsr withTerminalROM
8913	.eae3	4c 3c 96	jmp $963c	                jmp osbyte77

8916						;-------------------------------------------------------------------------
8917						;
8918						; Get *IGNORE CMOS byte offset and mask for a given ROM.
8919						;
8920						; entry:
8921						;
8922						; Y = ROM number
8923						;
8924						; exit:
8925						;
8926						; A = mask
8927						;
8928						; X = RTC address of byte
8929						;
8930	.eae6					getROMInsertedFlagRTCAddressAndMask:
8931	.eae6	a9 00		lda #$00	                lda #$00
8932	.eae8	38		sec		                sec
8933	.eae9	a2 06		ldx #$06	                ldx #CMOSBytes.insertedROMs+0+cmosBytesOffset
8934	.eaeb					-
8935	.eaeb	2a		rol a		                rol a
8936	.eaec	d0 02		bne $eaf0	                bne +
8937	.eaee	e8		inx		                inx
8938	.eaef	2a		rol a		                rol a
8939	.eaf0					+
8940	.eaf0	88		dey		                dey
8941	.eaf1	10 f8		bpl $eaeb	                bpl -
8942	.eaf3	60		rts		                rts

8944						;-------------------------------------------------------------------------

8946	=[]					_:=[]
8947	=[($03e0,32)]				_..=[(bufferKeyboardAddress,bufferKeyboardSize)]
8948	=[($03e0,32),($0a00,256)]		_..=[(bufferRS423InputAddress,bufferRS423InputSize)]
8949	=[($03e0,32),($0a00,256),($0900,192)]	_..=[(bufferRS423OutputAddress,bufferRS423OutputSize)]
8950	=[($03e0,32),($0a00,256),($0900,192),($0880,64)]
						_..=[(bufferPrinterAddress,bufferPrinterSize)]
8951	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16)]
						_..=[(bufferSoundChannel0Address,bufferSoundChannel0Size)]
8952	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16)]
						_..=[(bufferSoundChannel1Address,bufferSoundChannel1Size)]
8953	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16)]
						_..=[(bufferSoundChannel2Address,bufferSoundChannel2Size)]
8954	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16),($0870,16)]
						_..=[(bufferSoundChannel3Address,bufferSoundChannel3Size)]
8955	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16),($0870,16),($09c0,64)]
						_..=[(buffer8Address,buffer8Size)]
8956	=[($03e0,32),($0a00,256),($0900,192),($0880,64),($0840,16),($0850,16),($0860,16),($0870,16),($09c0,64)]
						buffers=_

8958						BufferTableIndex0Offset: .function buffer
8959						                .endfunction 256-buffer[1]

8961						BufferTableBase: .function buffer
8962						                .endfunction buffer[0]-BufferTableIndex0Offset(buffer)

8964						;-------------------------------------------------------------------------
8965						;
8966						; Buffer base addresses - each buffer's address, offset by the offset
8967						; for index 0 (see bufferIndex0Offsets).
8968						;
8969	.eaf4					bufferBaseAddressMSBs:
8970						                .for _i=0,_i<len(buffers),_i+=1
8971	>eaf4	03				                .byte >BufferTableBase(buffers[_i])
8971	>eaf5	0a				                .byte >BufferTableBase(buffers[_i])
8971	>eaf6	08				                .byte >BufferTableBase(buffers[_i])
8971	>eaf7	07				                .byte >BufferTableBase(buffers[_i])
8971	>eaf8	07				                .byte >BufferTableBase(buffers[_i])
8971	>eaf9	07				                .byte >BufferTableBase(buffers[_i])
8971	>eafa	07				                .byte >BufferTableBase(buffers[_i])
8971	>eafb	07				                .byte >BufferTableBase(buffers[_i])
8971	>eafc	09				                .byte >BufferTableBase(buffers[_i])
8972						                .endfor

8974	.eafd					bufferBaseAddressLSBs:
8975						                .for _i=0,_i<len(buffers),_i+=1
8976	>eafd	00				                .byte <BufferTableBase(buffers[_i])
8976	>eafe	00				                .byte <BufferTableBase(buffers[_i])
8976	>eaff	c0				                .byte <BufferTableBase(buffers[_i])
8976	>eb00	c0				                .byte <BufferTableBase(buffers[_i])
8976	>eb01	50				                .byte <BufferTableBase(buffers[_i])
8976	>eb02	60				                .byte <BufferTableBase(buffers[_i])
8976	>eb03	70				                .byte <BufferTableBase(buffers[_i])
8976	>eb04	80				                .byte <BufferTableBase(buffers[_i])
8976	>eb05	00				                .byte <BufferTableBase(buffers[_i])
8977						                .endfor

8979						;-------------------------------------------------------------------------

8981						; Offset of buffer index 0 for each buffer. Index 0 is (-buffer size)
8982						; - buffer indexes count up, and wrap once they reach 0.

8984	.eb06					bufferIndex0Offsets:
8985						                .for _i=0,_i<len(buffers),_i+=1
8986	>eb06	e0				                .byte BufferTableIndex0Offset(buffers[_i])
8986	>eb07	00				                .byte BufferTableIndex0Offset(buffers[_i])
8986	>eb08	40				                .byte BufferTableIndex0Offset(buffers[_i])
8986	>eb09	c0				                .byte BufferTableIndex0Offset(buffers[_i])
8986	>eb0a	f0				                .byte BufferTableIndex0Offset(buffers[_i])
8986	>eb0b	f0				                .byte BufferTableIndex0Offset(buffers[_i])
8986	>eb0c	f0				                .byte BufferTableIndex0Offset(buffers[_i])
8986	>eb0d	f0				                .byte BufferTableIndex0Offset(buffers[_i])
8986	>eb0e	c0				                .byte BufferTableIndex0Offset(buffers[_i])
8987						                .endfor

8989						;-------------------------------------------------------------------------
8990						;
8991						; Get base address for a buffer.
8992						;
8993						; entry:
8994						;
8995						; X = buffer number
8996						;
8997						; exit:
8998						;
8999						; (SEIWKA) = buffer base address
9000						;
9001	.eb0f					getBufferBaseAddress:
9002	.eb0f	bd fd ea	lda $eafd,x	                lda bufferBaseAddressLSBs,x
9003	.eb12	85 fa		sta $fa		                sta SEIWKA
9004	.eb14	bd f4 ea	lda $eaf4,x	                lda bufferBaseAddressMSBs,x
9005	.eb17	85 fb		sta $fb		                sta SEIWKB
9006	.eb19	60		rts		                rts

9008						;-------------------------------------------------------------------------
9009						;
9010						; OSBYTE 152 (&98) Examine buffer status [MasRef D.2-45]
9011						;
9012	.eb1a					osbyte98:
9013	.eb1a	2c 70 e3	bit $e370	                bit valueFF                  ;V=1
9014	.eb1d	80 01		bra $eb20	                bra callREMV

9016						;-------------------------------------------------------------------------
9017						;
9018						; OSBYTE 145 (&91) Get character from buffer [MasRef D.2-45]
9019						;
9020						; X = buffer number
9021	.eb1f					osbyte91:
9022	.eb1f	b8		clv		                clv                          ;remove
9023	.eb20					callREMV:
9024	.eb20	6c 2c 02	jmp ($022c)	                jmp (REMV)

9026						;-------------------------------------------------------------------------
9027						;
9028						; Buffer remove entry point. [AUG p263]
9029						;
9030						; Even in remove mode, A is the character removed on exit. Some of the
9031						; other MOS routines rely on this.
9032						;
9033	.eb23					remEntryPoint:
9034	.eb23	08		php		                php
9035	.eb24	78		sei		                sei
9036	.eb25	bd d7 02	lda $02d7,x	                lda bufferStartIndices,x
9037	.eb28	dd e0 02	cmp $02e0,x	                cmp bufferEndIndices,x
9038	.eb2b	f0 6c		beq $eb99	                beq plp_sec_rts  ;taken if buffer empty
9039	.eb2d	a8		tay		                tay                          ;Y=start index
9040	.eb2e	20 0f eb	jsr $eb0f	                jsr getBufferBaseAddress
9041	.eb31	b1 fa		lda ($fa),y	                lda (SEIWKA),y               ;get byte from buffer
9042	.eb33	70 1a		bvs $eb4f	                bvs tay_plp_clc_rts                  ;taken if only looking
9043	.eb35	48		pha		                pha                          ;save buffered byte
9044	.eb36	c8		iny		                iny                          ;next char in buffer
9045	.eb37	98		tya		                tya                          ;set Z if wrap
9046	.eb38	d0 03		bne $eb3d	                bne +                        ;branch taken if no wrap
9047	.eb3a	bd 06 eb	lda $eb06,x	                lda bufferIndex0Offsets,x    ;reset index on wrap
9048	.eb3d					+
9049	.eb3d	9d d7 02	sta $02d7,x	                sta bufferStartIndices,x

9051						                ; Issue output buffer empty event when appropriate.
9052	.eb40	e0 02		cpx #$02	                cpx #bufferFirstOutput
9053	.eb42	90 0a		bcc $eb4e	                bcc pla_tay_plp_clc_rts ;taken if keyboard or RS423
9054						                                        ;input - i.e., buffer is input
9055	.eb44	dd e0 02	cmp $02e0,x	                cmp bufferEndIndices,x       ;buffer now empty?
9056	.eb47	d0 05		bne $eb4e	                bne pla_tay_plp_clc_rts           ;taken if not empty
9057	.eb49	a0 00		ldy #$00	                ldy #eventOutputBufferEmpty
9058	.eb4b	20 53 eb	jsr $eb53	                jsr eventEntryPoint
9059	.eb4e					pla_tay_plp_clc_rts:
9060	.eb4e	68		pla		                pla                          ;restore buffered byte
9061	.eb4f					tay_plp_clc_rts:
9062	.eb4f	a8		tay		                tay                          ;Y=buffered byte
9063	.eb50					plp_clc_rts:
9064	.eb50	28		plp		                plp
9065	.eb51	18		clc		                clc
9066	.eb52	60		rts		                rts

9068						;-------------------------------------------------------------------------
9069						;
9070						; [MasRef D.9-1]
9071						;
9072	.eb53					eventEntryPoint:
9073	.eb53	08		php		                php
9074	.eb54	78		sei		                sei
9075	.eb55	48		pha		                pha
9076	.eb56	b9 bf 02	lda $02bf,y	                lda eventEnabledFlags,y      ;is the event enabled?
9077	.eb59	f0 3d		beq $eb98	                beq pla_plp_sec_rts                    ;
9078	.eb5b	98		tya		                tya
9079	.eb5c	7a		ply		                ply
9080	.eb5d	5a		phy		                phy
9081	.eb5e	20 5b f7	jsr $f75b	                jsr LF8BF
9082	.eb61	80 eb		bra $eb4e	                bra pla_tay_plp_clc_rts

9084						;-------------------------------------------------------------------------
9085						;
9086						; Insert character into buffer and issue an event for it.
9087						;
9088						; entry:
9089						;
9090						; Y = buffer number
9091						;
9092	.eb63					insertCharacterIntoBuffer:
9093	.eb63	98		tya		                tya
9094	.eb64	a0 02		ldy #$02	                ldy #eventCharacterEnteringBuffer
9095	.eb66	20 53 eb	jsr $eb53	                jsr eventEntryPoint
9096	.eb69	a8		tay		                tay

9098						;-------------------------------------------------------------------------
9099						;
9100						; OSBYTE 138 (&8A) Insert character code into buffer [MasRef D.2-43]
9101						;
9102	.eb6a					osbyte8A:
9103	.eb6a	98		tya		                tya
9104	.eb6b					callINSV:
9105	.eb6b	6c 2a 02	jmp ($022a)	                jmp (INSV)

9107						;-------------------------------------------------------------------------
9108						;
9109						; Default INSV entry point [AUG p263]
9110						;
9111	.eb6e					insEntryPoint:
9112	.eb6e	08		php		                php
9113	.eb6f	78		sei		                sei
9114	.eb70	48		pha		                pha                          ;save value to insert
9115	.eb71	bd e0 02	lda $02e0,x	                lda bufferEndIndices,x       ;get buffer index
9116	.eb74	1a		inc a		                inc a                        ;bump index
9117	.eb75	d0 03		bne $eb7a	                bne +          ;taken if index hasn't wrapped around
9118	.eb77	bd 06 eb	lda $eb06,x	                lda bufferIndex0Offsets,x        ;reset index due to wrap
9119	.eb7a					+
9120	.eb7a	dd d7 02	cmp $02d7,x	                cmp bufferStartIndices,x     ;are we at the start index?
9121	.eb7d	f0 0e		beq $eb8d	                beq bufferFull       ;taken if yes - i.e., buffer full
9122	.eb7f	bc e0 02	ldy $02e0,x	                ldy bufferEndIndices,x       ;note old buffer end
9123	.eb82	9d e0 02	sta $02e0,x	                sta bufferEndIndices,x       ;update buffer end
9124	.eb85	20 0f eb	jsr $eb0f	                jsr getBufferBaseAddress
9125	.eb88	68		pla		                pla                          ;restore value to insert
9126	.eb89	91 fa		sta ($fa),y	                sta (SEIWKA),y               ;store byte in buffer
9127	.eb8b	80 c3		bra $eb50	                bra plp_clc_rts              ;done

9129	.eb8d					bufferFull
9130						                ; Issue input buffer full event when appropriate.
9131	.eb8d	68		pla		                pla
9132	.eb8e	e0 02		cpx #$02	                cpx #bufferFirstOutput
9133	.eb90	b0 07		bcs $eb99	                bcs plp_sec_rts  ;taken if output buffer
9134	.eb92	a0 01		ldy #$01	                ldy #eventInputBufferFull
9135	.eb94	20 53 eb	jsr $eb53	                jsr eventEntryPoint
9136	.eb97	48		pha		                pha
9137	.eb98					pla_plp_sec_rts:
9138	.eb98	68		pla		                pla
9139	.eb99					plp_sec_rts:
9140	.eb99	28		plp		                plp
9141	.eb9a	38		sec		                sec
9142	.eb9b	60		rts		                rts

9144						;-------------------------------------------------------------------------
9145						;
9146						; Check if character is a letter - A-Z or a-z.
9147						;
9148						; Entry:
9149						;
9150						; A = character to test
9151						;
9152						; Exit:
9153						;
9154						; C=0 if character is letter, C=1 otherwise
9155						;
9156						; Preserves: A/X/Y
9157	.eb9c					isLetter: .proc                 ;EA71
9158	.eb9c	48		pha		                pha
9159	.eb9d	29 df		and #$df	                and #$DF        ;convert to upper case
9160	.eb9f	c9 5b		cmp #$5b	                cmp #'Z'+1
9161	.eba1	b0 04		bcs $eba7	                bcs +           ;branch taken with C=1 if past Z
9162	.eba3	49 ff		eor #$ff	                eor #$FF
9163	.eba5	c9 bf		cmp #$bf	                cmp #-'A'       ;C=1 if past A
9164	.eba7					+
9165	.eba7	68		pla		                pla
9166	.eba8	60		rts		                rts
9167						                .pend

9169						;-------------------------------------------------------------------------
9170						;
9171						; OSBYTE 153 (&99) Insert character code into buffer, checking for
9172						; ESCAPE [MasRef D.2-46]
9173						;
9178	.eba9					insertCharacterIntoKeyboardBuffer:
9179	.eba9	a2 00		ldx #$00	                ldx #$00
9180	.ebab					osbyte99:
9182	.ebab	8a		txa		                txa                          ;X=1 if RS423, 0 if keyboard
9183	.ebac	2d 45 02	and $0245	                and rs423InputInterpretationStatus ;A=0 if RS423 simulates keyboard, 1=default
9184	.ebaf	d0 b9		bne $eb6a	                bne osbyte8A ;taken if default - don't treat RS423 as keyboard
9186	.ebb1	98		tya		                tya          ;A=char
9187	.ebb2	4d 6c 02	eor $026c	                eor escapeCharacter
9188	.ebb5	0d 75 02	ora $0275	                ora escapeKeyStatus
9189	.ebb8	d0 a9		bne $eb63	                bne insertCharacterIntoBuffer
9190	.ebba	ad 58 02	lda $0258	                lda breakAndESCAPEEffect
9191	.ebbd	6a		ror a		                ror a                        ;C=0 if normal ESCAPE action
9192	.ebbe	98		tya		                tya                          ;A=char
9193	.ebbf	b0 0a		bcs $ebcb	                bcs osbyte99Done             ;taken if ESCAPE inhibited
9194	.ebc1	a0 06		ldy #$06	                ldy #eventESCAPEPressed
9195	.ebc3	20 53 eb	jsr $eb53	                jsr eventEntryPoint
9196	.ebc6	90 03		bcc $ebcb	                bcc osbyte99Done             ;taken if event handled
9197	.ebc8	20 fc ec	jsr $ecfc	                jsr osbyte7D
9198	.ebcb					osbyte99Done:
9199	.ebcb	18		clc		                clc
9200	.ebcc	60		rts		                rts

9202						;-------------------------------------------------------------------------

9204						; A = 0 (edit keys)/1 (ascii keys)/2 (F keys)
9205	.ebcd					handleCursorKeysAndCopy:
9211	.ebcd	c9 02		cmp #$02	                cmp #2
9212	.ebcf	68		pla		                pla
9213	.ebd0	90 2a		bcc $ebfc	                bcc clc_rts_EABD

9216	.ebd2					handleFunctionKey:
9217	.ebd2	98		tya		                tya
9225	.ebd3	48		pha		                pha
9226	.ebd4	98		tya		                tya
9227	.ebd5	4a		lsr a		                lsr a
9228	.ebd6	4a		lsr a		                lsr a
9229	.ebd7	4a		lsr a		                lsr a
9230	.ebd8	4a		lsr a		                lsr a
9232	.ebd9	49 04		eor #$04	                eor #$04
9233	.ebdb	a8		tay		                tay
9234	.ebdc	b9 65 02	lda $0265,y	                lda input192To207Interpretation-8,y
9235	.ebdf	4a		lsr a		                lsr a
9242	.ebe0	d0 03		bne $ebe5	                bne +
9243	.ebe2	4c a0 ec	jmp $eca0	                jmp LEC99
9244	.ebe5					+
9245	.ebe5	2a		rol a		                rol a
9246	.ebe6	c9 02		cmp #$02	                cmp #2
9247	.ebe8	d0 0b		bne $ebf5	                bne LEBF5
9248	.ebea					LEBEA:
9249	.ebea	68		pla		                pla
9250	.ebeb	85 f8		sta $f8		                sta softKeyExpansionPtr
9251	.ebed	a9 ff		lda #$ff	                lda #$ff
9252	.ebef	8d 68 02	sta $0268	                sta softKeyStringLength
9253	.ebf2	1a		inc a		                inc a
9254	.ebf3	80 07		bra $ebfc	                bra clc_rts_EABD

9256	.ebf5					LEBF5:
9257	.ebf5	68		pla		                pla
9258	.ebf6	29 0f		and #$0f	                and #$0f
9259	.ebf8	18		clc		                clc
9260	.ebf9	79 65 02	adc $0265,y	                adc input192To207Interpretation-8,y

9263	.ebfc					clc_rts_EABD:
9264	.ebfc	18		clc		                clc
9265	.ebfd	60		rts		                rts

9267						;-------------------------------------------------------------------------

9269	.ebfe					copyCharNotRecognised:
9270	.ebfe	20 67 f0	jsr $f067	                jsr vdu7EntryPoint           ;beep
9271	.ec01	fa		plx		                plx
9272	.ec02					readFromInputBufferX:
9273	.ec02	20 1f eb	jsr $eb1f	                jsr osbyte91          ;extract character from buffer X
9277	.ec05	b0 0c		bcs $ec13	                bcs LEC0D                    ; taken if buffer empty
9278	.ec07	a8		tay		                tay                          ; Y=char removed???
9279	.ec08	d0 1f		bne $ec29	                bne LEAC8                    ; taken if non-zero
9281	.ec0a	8a		txa		                txa                          ; A=buffer number
9282	.ec0b	2d 45 02	and $0245	                and rs423InputInterpretationStatus ;
9283	.ec0e	d0 18		bne $ec28	                bne LEC29
9288	.ec10	20 1f eb	jsr $eb1f	                jsr osbyte91
9290	.ec13					LEC0D:
9291	.ec13	b0 7e		bcs $ec93	                bcs rtsEB28
9292	.ec15	a8		tay		                tay
9293	.ec16	d0 e4		bne $ebfc	                bne clc_rts_EABD
9294	.ec18	48		pha		                pha
9295	.ec19	a0 08		ldy #$08	                ldy #8

9297	.ec1b					LEC15:
9298	.ec1b	b9 6c 02	lda $026c,y	                lda shiftCtrlSoftKeyInterpretation-8,y
9299	.ec1e	c9 02		cmp #$02	                cmp #2
9300	.ec20	f0 c8		beq $ebea	                beq LEBEA
9301	.ec22	88		dey		                dey
9302	.ec23	d0 f6		bne $ec1b	                bne LEC15
9303	.ec25	68		pla		                pla
9304	.ec26	80 d4		bra $ebfc	                bra clc_rts_EABD

9308	.ec28					LEC29:
9309	.ec28	98		tya		                tya

9313	.ec29					LEAC8:
9314	.ec29	48		pha		                pha                   ;save character extracted
9315	.ec2a	e0 01		cpx #$01	                cpx #bufferRS423Input ;was it RS423 input buffer?
9316	.ec2c	d0 06		bne $ec34	                bne LEAD3             ;taken if not RS423 input buffer
9317	.ec2e	20 36 ea	jsr $ea36	                jsr setRS423Active
9318	.ec31	38		sec		                sec
9319	.ec32	a2 01		ldx #$01	                ldx #bufferRS423Input

9321	.ec34					LEAD3:
9322	.ec34	68		pla		                pla                          ;restore char extracted
9323	.ec35	90 05		bcc $ec3c	                bcc LEADB                    ;taken if keyboard buffer
9324	.ec37	ac 45 02	ldy $0245	                ldy rs423InputInterpretationStatus ;D.2-54
9325	.ec3a	d0 56		bne $ec92	                bne clc_rts_EB27             ;taken if default mode

9328	.ec3c					LEADB:
9329	.ec3c	a8		tay		                tay                          ;Y = char
9330	.ec3d	10 53		bpl $ec92	                bpl clc_rts_EB27             ;if normal char, all good
9331	.ec3f	29 0f		and #$0f	                and #$0F
9332	.ec41	c9 0b		cmp #$0b	                cmp #$0B
9333	.ec43	90 8d		bcc $ebd2	                bcc handleFunctionKey        ;taken if F key
9334	.ec45	69 7b		adc #$7b	                adc #$7B    ;C=1, so +$7c - convert $0b-0$f to $87-$8B
9335	.ec47	48		pha		                pha         ;save translated value
9336	.ec48	ad 7d 02	lda $027d	                lda editKeysMode
9337	.ec4b	d0 80		bne $ebcd	                bne handleCursorKeysAndCopy  ;taken if not editKeys
9338	.ec4d	ad 7c 02	lda $027c	                lda characterDestinationStatus
9339	.ec50	6a		ror a		                ror a                        ;C=rs423_enable
9340	.ec51	6a		ror a		                ror a                        ;C=vdu_disable
9341	.ec52	68		pla		                pla                          ;restore translated value
9342	.ec53	b0 ad		bcs $ec02	                bcs readFromInputBufferX     ;taken if VDU output disabled
9343	.ec55	c9 87		cmp #$87	                cmp #$87                     ;COPY?
9344	.ec57	f0 3b		beq $ec94	                beq readCopyChar
9345	.ec59	da		phx		                phx                          ;save buffer number
9346	.ec5a	20 d0 ec	jsr $ecd0	                jsr handleCursorKeyThunk     ;handle cursor key
9347	.ec5d	fa		plx		                plx
9348	.ec5e					readFromEconetOrSoftKeyOrInputBufferA:
9352	.ec5e	2c 5f 02	bit $025f	                bit econetInputInterpretationStatus
9353	.ec61	10 05		bpl $ec68	                bpl readFromSoftKeyOrInputBufferA
9354	.ec63	a9 06		lda #$06	                lda #netReadCharacterAttempted
9355	.ec65					callNETV:
9356	.ec65	6c 24 02	jmp ($0224)	                jmp (NETV)

9358	.ec68					readFromSoftKeyOrInputBufferA:
9359	.ec68	ad 68 02	lda $0268	                lda softKeyStringLength
9360	.ec6b	f0 95		beq $ec02	                beq readFromInputBufferX
9362	.ec6d	1a		inc a		                inc a
9363	.ec6e	d0 07		bne $ec77	                bne LEC70
9364	.ec70	9c 68 02	stz $0268	                stz softKeyStringLength
9365	.ec73	a5 f8		lda $f8		                lda softKeyExpansionPtr
9366	.ec75	80 1b		bra $ec92	                bra clc_rts_EB27
9367	.ec77					LEC70:
9370	.ec77	8a		txa		                txa
9371	.ec78	2d 45 02	and $0245	                and rs423InputInterpretationStatus
9372	.ec7b	d0 85		bne $ec02	                bne readFromInputBufferX
9374	.ec7d	a5 f4		lda $f4		                lda $F4
9375	.ec7f	48		pha		                pha
9376	.ec80	20 b1 e5	jsr $e5b1	                jsr selectTerminalROMAndANDY2
9377	.ec83	b2 f8		lda ($f8)	                lda (softKeyExpansionPtr)
9378	.ec85	fa		plx		                plx
9379	.ec86	20 9a e5	jsr $e59a	                jsr selectROMX
9380	.ec89	ce 68 02	dec $0268	                dec softKeyStringLength
9381	.ec8c	e6 f8		inc $f8		                inc softKeyExpansionPtr+0
9382	.ec8e	d0 02		bne $ec92	                bne clc_rts_EB27
9383	.ec90	e6 f9		inc $f9		                inc softKeyExpansionPtr+1
9384	.ec92					clc_rts_EB27:
9385	.ec92	18		clc		                clc
9386	.ec93					rtsEB28:
9387	.ec93	60		rts		                rts

9389	.ec94					readCopyChar:
9390	.ec94	da		phx		                phx
9391	.ec95	20 d6 ec	jsr $ecd6	                jsr handleCopyKeyThunk
9395	.ec98	d0 03		bne $ec9d	                bne +
9396	.ec9a	4c fe eb	jmp $ebfe	                jmp copyCharNotRecognised
9397	.ec9d					+
9399	.ec9d	fa		plx		                plx
9400	.ec9e	18		clc		                clc
9401	.ec9f					rtsEB31:
9402	.ec9f	60		rts		                rts

9405	.eca0					LEC99:
9406	.eca0	68		pla		                pla
9407	.eca1	29 0f		and #$0f	                and #$0f
9408	.eca3	a8		tay		                tay
9409	.eca4	b0 03		bcs $eca9	                bcs LECA2
9410	.eca6	4c 02 ec	jmp $ec02	                jmp readFromInputBufferX

9412	.eca9					LECA2:
9413	.eca9	8d c9 02	sta $02c9	                sta currentSoftKey

9425	.ecac	a5 f4		lda $f4		                lda $F4
9426	.ecae	48		pha		                pha                           ;save old ROMSEL
9427	.ecaf	20 b1 e5	jsr $e5b1	                jsr selectTerminalROMAndANDY2
9428	.ecb2	20 c8 ec	jsr $ecc8	                jsr getSoftKeyStringLength
9429	.ecb5	8d 68 02	sta $0268	                sta softKeyStringLength
9430	.ecb8	b9 00 80	lda $8000,y	                lda andy.softKeys.stringLSBs,y
9431	.ecbb	85 f8		sta $f8		                sta softKeyExpansionPtr+0
9432	.ecbd	b9 11 80	lda $8011,y	                lda andy.softKeys.stringMSBs,y
9433	.ecc0	85 f9		sta $f9		                sta softKeyExpansionPtr+1
9434	.ecc2	68		pla		                pla
9435	.ecc3	20 ab e5	jsr $e5ab	                jsr selectROMA               ;restore old ROMSEL
9436	.ecc6	80 96		bra $ec5e	                bra readFromEconetOrSoftKeyOrInputBufferA

9438						;-------------------------------------------------------------------------

9440	.ecc8					getSoftKeyStringLength:
9441	.ecc8	b9 01 80	lda $8001,y	                lda andy.softKeys.stringLSBs+1,y
9442	.eccb	38		sec		                sec
9443	.eccc	f9 00 80	sbc $8000,y	                sbc andy.softKeys.stringLSBs+0,y
9444	.eccf	60		rts		                rts

9446						;-------------------------------------------------------------------------
9447						;
9448						; Page HAZEL out, page MOS in, call handleCursorKey.
9449						;
9450	.ecd0					handleCursorKeyThunk:
9451	.ecd0	20 88 f4	jsr $f488	                jsr withMOSROM
9452	.ecd3	4c 78 df	jmp $df78	                jmp handleCursorKey

9454						;-------------------------------------------------------------------------
9455						;
9456						; Page HAZEL out, page MOS in, call handleCopyKey.
9457						;
9458	.ecd6					handleCopyKeyThunk:
9459	.ecd6	20 88 f4	jsr $f488	                jsr withMOSROM
9460	.ecd9	4c 5e df	jmp $df5e	                jmp handleCopyKey

9462						;-------------------------------------------------------------------------
9463						;
9464						; Call OSBYTE $91 (Get character from buffer) (MasRef D.2-45) in a
9465						; loop, until a character is extracted or ESCAPE is pressed.
9466						;
9467						; Entry:
9468						;
9469						; X = buffer number
9470						;
9471						; Exit:
9472						;
9473						; C=0 - character was extracted
9474						; C=1 - ESCAPE was pressed

9487						;-------------------------------------------------------------------------

9493						;-------------------------------------------------------------------------

9495	.ecdc					osbyte88: ;LEC37:
9496	.ecdc	a9 00		lda #$00	                lda #$00

9498	.ecde					callUSERV:
9499	.ecde	6c 00 02	jmp ($0200)	                jmp (USERV)

9501	.ece1					osbyte7E:                       ;ec3c
9502	.ece1	a2 00		ldx #$00	                ldx #$00
9503	.ece3	24 ff		bit $ff		                bit $FF
9504	.ece5	10 14		bpl $ecfb	                bpl osbyte7C
9505	.ece7	ad 76 02	lda $0276	                lda escapeEffects
9506	.ecea	d0 0d		bne $ecf9	                bne LEC54
9507	.ecec	58		cli		                cli
9508	.eced	9c 69 02	stz $0269	                stz pagedModeCounter
9509	.ecf0	20 61 f4	jsr $f461	                jsr withTerminalROM
9510	.ecf3	20 00 aa	jsr $aa00	                jsr starEXEC
9511	.ecf6	20 72 ea	jsr $ea72	                jsr LE947
9512	.ecf9					LEC54:
9513	.ecf9	a2 ff		ldx #$ff	                ldx #$FF
9514	.ecfb					osbyte7C: ;EC56
9515	.ecfb	18		clc		                clc
9516	.ecfc					osbyte7D: ;EC57
9528	.ecfc	08		php		                php
9529	.ecfd	78		sei		                sei
9530	.ecfe	08		php		                php
9531	.ecff	06 ff		asl $ff		                asl escapeFlag
9532	.ed01	28		plp		                plp
9533	.ed02	66 ff		ror $ff		                ror escapeFlag
9534	.ed04	28		plp		                plp
9535	.ed05	80 6e		bra $ed75	                bra LECD9

9538						;-------------------------------------------------------------------------

9550						;-------------------------------------------------------------------------
9551						;
9552						; ;OSBYTE 8 (&08) Write RS423 transmit rate
9553						;
9554						; This call sets the RS423 baud rate for transmitting data. The actual format of
9555						; the data is set using OSBYTE 156/&9C (see below).
9556						;
9557						; Entry parameters :
9558						; X=0 selects 9600 baud
9559						; X=1 selects 75 baud
9560						; X=2 selects 150 baud
9561						; X=3 selects 300 baud
9562						; X=4 selects 1200 baud
9563						; X=5 selects 2400 baud
9564						; X=6 selects 4800 baud
9565						; X=7 selects 9600 baud
9566						; X=8 selects 19200 baud
9567						; Y=0
9568						;
9569						; On exit : X=Y=<old serial ACIA control register contents>

9572	.ed07					osbyte08:
9573	.ed07	a9 38		lda #$38	                lda #$38
9574						                ; fall through to OSBYTE &07

9577						;-------------------------------------------------------------------------
9578						;
9579						; OSBYTE 7 (&07) Write RS423 receive rate
9580						;
9581						; This call sets the RS423 baud rate for receiving data. The actual
9582						; format of the data is set using OSBYTE 156/&9C (see below).
9583						;
9584						; Entry parameters :
9585						; X=0 selects 9600 baud
9586						; X=1 selects 75 baud
9587						; X=2 selects 150 baud
9588						; X=3 selects 300 baud
9589						; X=4 selects 1200 baud
9590						; X=5 selects 2400 baud
9591						; X=6 selects 4800 baud
9592						; X=7 selects 9600 baud
9593						; X=8 selects 19200 baud
9594						; Y=0
9595						;
9596						; On exit : X=Y=<old serial ACIA control register contents>

9599	.ed09					osbyte07:                                    ;ec6d
9600	.ed09	49 3f		eor #$3f	                eor #$3F                     ;if OSBYTE 8,
9601						                                             ;A=%00000111, mask for
9602						                                             ;transmit rate; if OSBYTE
9603						                                             ;8, A=%000111000, mask
9604						                                             ;for receive rate.
9605	.ed0b	85 fa		sta $fa		                sta $FA                      ;save mask
9606	.ed0d	ac 82 02	ldy $0282	                ldy serialULARegister                    ;
9607	.ed10	e0 09		cpx #$09	                cpx #$09                     ;check for invalid baud rate
9608	.ed12	b0 17		bcs $ed2b	                bcs LEC8F                    ;branch taken if invalid
9609	.ed14	3d 9d f1	and $f19d,x	                and serialBaudRatesTable,x   ;get setting in A
9610	.ed17	85 fb		sta $fb		                sta $FB                      ;store setting
9611	.ed19	98		tya		                tya                          ;
9612	.ed1a	05 fa		ora $fa		                ora $FA
9613	.ed1c	45 fa		eor $fa		                eor $FA
9614	.ed1e	05 fb		ora $fb		                ora $FB
9615	.ed20	09 40		ora #$40	                ora #$40
9616	.ed22	4d 5d 02	eor $025d	                eor rs423Destination ;mask in tape/serial flag set by OSBYTE 205ac
9617	.ed25					LEC89:
9618	.ed25	8d 82 02	sta $0282	                sta serialULARegister
9619	.ed28	8d 10 fe	sta $fe10	                sta SERPROC+0
9620	.ed2b					LEC8F:
9621	.ed2b	98		tya		                tya
9622	.ed2c					LEC90:
9623	.ed2c	aa		tax		                tax
9624	.ed2d	60		rts		                rts

9634						;-------------------------------------------------------------------------

9636						; Y=0 on entry.

9638	.ed2e					osbyte09:                       ;ec92
9639	.ed2e	c8		iny		                iny
9640	.ed2f	18		clc		                clc
9641	.ed30					osbyte0A:                                    ;ec94
9642	.ed30	b9 52 02	lda $0252,y	                lda firstFlashColourDuration,y
9643	.ed33	48		pha		                pha
9644	.ed34	8a		txa		                txa
9645	.ed35	99 52 02	sta $0252,y	                sta firstFlashColourDuration,y
9646	.ed38	7a		ply		                ply
9647	.ed39	ad 51 02	lda $0251	                lda flashCounter
9648	.ed3c	d0 ed		bne $ed2b	                bne LEC8F
9649	.ed3e	8e 51 02	stx $0251	                stx flashCounter
9650	.ed41	ad 48 02	lda $0248	                lda vcontrolRegister
9651	.ed44	08		php		                php
9652	.ed45	6a		ror a		                ror a
9653	.ed46	28		plp		                plp
9654	.ed47	2a		rol a		                rol a
9655	.ed48	8d 48 02	sta $0248	                sta vcontrolRegister
9656	.ed4b	8d 20 fe	sta $fe20	                sta VCONTROL
9657	.ed4e	80 db		bra $ed2b	                bra LEC8F

9659						;-------------------------------------------------------------------------
9660						;
9661						; OSBYTE 2 (&02) Specify input stream
9662						;
9663						; Input may be taken from either the keyboard (by default) or the
9664						; RS423 port. This call specifies the selection for all subsequent
9665						; input.
9666						;
9667						; Entry parameters :
9668						; X=0 selects keyboard input and disables RS423
9669						; X=1 selects and enables RS423 input
9670						; X=2 selects keyboard input and enables RS423
9671						; Y=0
9672						;
9673						; On exit : X=0 indicates previous input was from the keyboard
9674						;           X=1 indicates previous input was from RS423
9675						;           Y is undefined
9676						;
9677						; D.2-18
9679	.ed50					osbyte02:                       ;ecb4
9680	.ed50	8a		txa		                txa
9681	.ed51	29 01		and #$01	                and #$01
9682	.ed53	48		pha		                pha
9683	.ed54	ad 50 02	lda $0250	                lda aciaControlRegister
9684	.ed57	2a		rol a		                rol a
9685	.ed58	e0 01		cpx #$01	                cpx #$01
9686	.ed5a	6a		ror a		                ror a
9687	.ed5b	cd 50 02	cmp $0250	                cmp aciaControlRegister
9688	.ed5e	08		php		                php
9689	.ed5f	8d 50 02	sta $0250	                sta aciaControlRegister
9690	.ed62	8d 08 fe	sta $fe08	                sta ACIA+0
9691	.ed65	20 36 ea	jsr $ea36	                jsr setRS423Active
9692	.ed68	28		plp		                plp
9693	.ed69	f0 03		beq $ed6e	                beq LECD2
9694	.ed6b	2c 09 fe	bit $fe09	                bit ACIA+1
9695	.ed6e					LECD2:
9696	.ed6e	ae 41 02	ldx $0241	                ldx inputSource
9697	.ed71	68		pla		                pla
9698	.ed72	8d 41 02	sta $0241	                sta inputSource
9699	.ed75					LECD9:
9700	.ed75	60		rts		                rts

9703						;-------------------------------------------------------------------------
9704						;
9705						; OSBYTE 13 (&0D) Disable event
9706						;
9707						; All events are assigned a unique number and this call provides a
9708						; means of disabling specific events.
9709						;
9710						; Entry parameters:
9711						; X = event number
9712						;
9713						; On exit: X = Y = <old enable state> (0=disabled)
9714	.ed76					osbyte0D:
9715	.ed76	98		tya		                tya             ;A=0

9717						;-------------------------------------------------------------------------
9718						;
9719						; OSBYTE 14 (&0E) Enable event
9720						;
9721						; This call provides a means of enabling specific events.
9722						;
9723						;
9724	.ed77					osbyte0E:
9725	.ed77	e0 0a		cpx #$0a	                cpx #eventMax+1
9727	.ed79	b0 b1		bcs $ed2c	                bcs LEC90
9731	.ed7b	bc bf 02	ldy $02bf,x	                ldy eventEnabledFlags,x
9732	.ed7e	9d bf 02	sta $02bf,x	                sta eventEnabledFlags,x
9734	.ed81	80 a8		bra $ed2b	                bra LEC8F

9745						;-------------------------------------------------------------------------
9746						;
9747						; OSBYTE 16 (&10) Write number of ADC channels
9748						;
9749						; By default, each of the four ADC channels is sampled and converted
9750						; in turn so that each reading is updated every 40 milliseconds. This
9751						; call enables the number of channels to be changed so that if, for
9752						; example, only two channels are required, each will be updated every
9753						; 20 milliseconds.
9754						;
9756	.ed83					osbyte10:
9762	.ed83	ad 4d 02	lda $024d	                lda maximumADCChannel
9763	.ed86	8e 4d 02	stx $024d	                stx maximumADCChannel
9764	.ed89	aa		tax		                tax
9765	.ed8a	60		rts		                rts

9768						;-------------------------------------------------------------------------
9769						;
9770						; OSBYTE 129 (&81) Read key with time limit
9771						;
9772						; This call may be used to read a key from the keyboard subject to a
9773						; specified time limit or to perform a keyboard scan for a specified
9774						; key depression.

9776	.ed8b					osbyte81:
9777	.ed8b	98		tya		                tya
9778	.ed8c	30 0a		bmi $ed98	                bmi LED01          ;taken if scanning for specific key
9779	.ed8e	20 e1 e8	jsr $e8e1	                jsr osbyte81Timed
9780	.ed91	b0 03		bcs $ed96	                bcs LECFF                 ;taken if timed out or error
9781	.ed93	aa		tax		                tax                       ;X = ASCII char
9782	.ed94					LECFD:
9783	.ed94	a9 00		lda #$00	                lda #$00
9784	.ed96					LECFF:
9785	.ed96	a8		tay		                tay
9786	.ed97	60		rts		                rts

9788	.ed98					LED01:
9789	.ed98	8a		txa		                txa
9790	.ed99	f0 10		beq $edab	                beq LED14
9791	.ed9b	49 7f		eor #$7f	                eor #$7F
9792	.ed9d	aa		tax		                tax
9793	.ed9e	20 9e f7	jsr $f79e	                jsr callKEYV
9794	.eda1	2a		rol a		                rol a
9795						                ; fall through

9797						;-------------------------------------------------------------------------

9799	.eda2					osbyte82:
9800	.eda2	a2 ff		ldx #$ff	                ldx #$FF
9801	.eda4	a0 ff		ldy #$ff	                ldy #$FF
9802	.eda6	b0 02		bcs $edaa	                bcs LEB13                    ;if OSBYTE $82, done
9803	.eda8	e8		inx		                inx
9804	.eda9	c8		iny		                iny
9805	.edaa					LEB13:
9806	.edaa	60		rts		                rts

9808	.edab					LED14:
9816	.edab	a2 f4		ldx #$f4	                ldx #$f4
9820	.edad	80 e5		bra $ed94	                bra LECFD

9822	.edaf					LED18:
9826	.edaf	8a		txa		                txa
9827	.edb0	49 ff		eor #$ff	                eor #$FF
9828	.edb2	aa		tax		                tax
9829	.edb3	e0 02		cpx #$02	                cpx #$02
9830						                ; fall through

9832						;-------------------------------------------------------------------------

9834	.edb5					countBufferViaCNPV:
9835	.edb5	b8		clv		                clv
9836	.edb6	80 03		bra $edbb	                bra callCNPV

9838	.edb8					purgeBufferViaCNPV:
9839	.edb8	2c 70 e3	bit $e370	                bit valueFF                  ;V=1
9840	.edbb					callCNPV:
9841	.edbb	6c 2e 02	jmp ($022e)	                jmp (CNPV)

9843						;-------------------------------------------------------------------------

9846	.edbe					getRS423InputBufferFreeBytes:
9847	.edbe	38		sec		                sec
9848	.edbf	a2 01		ldx #$01	                ldx #bufferRS423Input
9849	.edc1	20 b5 ed	jsr $edb5	                jsr countBufferViaCNPV
9850	.edc4	c0 01		cpy #$01	                cpy #$01                     ;check MSB
9851	.edc6	b0 03		bcs $edcb	                bcs +                        ;if >= 256 bytes, all good
9852	.edc8	ec 5b 02	cpx $025b	                cpx rs423InputBufferMinimumSpace ;compare to min space
9853	.edcb					+
9854	.edcb	60		rts		                rts

9857						;-------------------------------------------------------------------------

9860	.edcc					osbyte80:
9861	.edcc	30 e1		bmi $edaf	                bmi LED18
9862	.edce	f0 0e		beq $edde	                beq LED45
9870	.edd0	e8		inx		                inx
9871	.edd1	8a		txa		                txa
9872	.edd2	29 01		and #$01	                and #1
9873	.edd4	0a		asl a		                asl a
9874	.edd5	aa		tax		                tax
9875	.edd6	bc b8 02	ldy $02b8,x	                ldy adcResultLSBs+3-1,x
9876	.edd9	bd b7 02	lda $02b7,x	                lda adcResultLSBs+2-1,x
9877	.eddc	aa		tax		                tax
9879	.eddd	60		rts		                rts

9882						;-------------------------------------------------------------------------

9885	.edde					LED45:
9899	.edde	ac 4c 02	ldy $024c	                ldy currentADCChannel
9900	.ede1	ae b6 02	ldx $02b6	                ldx adcResultLSBs
9902	.ede4	60		rts		                rts

9905						;-------------------------------------------------------------------------
9906						;
9907						; OSBYTE $70
9908						;
9909						; D.2-31
9910						;
9911	.ede5					osbyte70:                       ;ed58
9912	.ede5	20 fd ed	jsr $edfd	                jsr osbyte7071
9913	.ede8	0a		asl a		                asl a
9914	.ede9	f0 04		beq $edef	                beq clearACCCCONE
9915	.edeb					LED5E:
9916	.edeb	0c 34 fe	tsb $fe34	                tsb ACCCON
9917	.edee	60		rts		                rts

9919	.edef					clearACCCCONE:
9920	.edef	a9 02		lda #$02	                lda #ACCCON.E
9921	.edf1					LED64:
9922	.edf1	1c 34 fe	trb $fe34	                trb ACCCON
9923	.edf4	60		rts		                rts

9925						;-------------------------------------------------------------------------

9927	.edf5					osbyte71:                       ;ed68
9928	.edf5	20 fd ed	jsr $edfd	                jsr osbyte7071
9929	.edf8	d0 f1		bne $edeb	                bne LED5E
9930	.edfa	1a		inc a		                inc a
9931	.edfb	80 f4		bra $edf1	                bra LED64

9933						;-------------------------------------------------------------------------
9934						;
9935						; Handle OSBYTE $70 or OSBYTE $71
9936						;
9937						; Entry: A=$70 or $71
9938						;
9939	.edfd					osbyte7071:
9940	.edfd	a8		tay		                tay
9941	.edfe	8a		txa		                txa
9943	.edff	99 1a 02	sta $021a,y	                sta vduDriverMemory-$70,y
9944	.ee02	d0 09		bne $ee0d	                bne LED80
9945	.ee04	a5 d0		lda $d0		                lda STATE
9946	.ee06	29 10		and #$10	                and #STATE.isShadowMode
9947	.ee08	f0 06		beq $ee10	                beq LED83
9948	.ee0a					LED7D:
9949	.ee0a	a9 01		lda #$01	                lda #$01
9950	.ee0c	60		rts		                rts

9952	.ee0d					LED80:
9953	.ee0d	3a		dec a		                dec a
9954	.ee0e	d0 fa		bne $ee0a	                bne LED7D
9955	.ee10					LED83:
9956	.ee10	60		rts		                rts

9958						;-------------------------------------------------------------------------

9960						; OSBYTE &6E (110), &6F (111)
9961						; ===========================
9962						; Pass to sideways ROMs
9963	.ee11					osbyteUnused:                   ;ed84
9964	.ee11	a2 07		ldx #$07	                ldx #romServiceCallUnrecognisedOSBYTE
9965	.ee13	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
9966	.ee16	a6 f0		ldx $f0		                ldx originalX
9968	.ee18	49 00		eor #$00	                eor #$00
9970	.ee1a	60		rts		                rts

9972						;-------------------------------------------------------------------------

9975	.ee1b					osbyteA1:
9976	.ee1b	20 61 f4	jsr $f461	                jsr withTerminalROM
9977	.ee1e	4c 1a 9e	jmp $9e1a	                jmp readCMOSByte

9980						;-------------------------------------------------------------------------

9983	.ee21					osbyteA2:
9984	.ee21	20 61 f4	jsr $f461	                jsr withTerminalROM
9985	.ee24	4c 69 9e	jmp $9e69	                jmp writeCMOSByte

9988						;-------------------------------------------------------------------------
9989						;
9990						; OSBYTE 140 (&8C) Select Cassette Filing System [MasRef D.2-43]
9991						; OSBYTE 141 (&8D) Select ROM Filing System [MasRef D.2-43]
9992						;
9993	.ee27					osbyte8C8D:
9994	.ee27	20 4d ee	jsr $ee4d	                jsr selectROMOrTAPEByOSBYTE
9995	.ee2a	ad 34 fe	lda $fe34	                lda ACCCON                    ; Save ACCON register
9996	.ee2d	48		pha		                pha
9997	.ee2e	20 47 ee	jsr $ee47	                jsr selectHAZEL         ; Page Hazel workspace in
9998	.ee31	ae 01 df	ldx $df01	                ldx hazel.activeFS
9999	.ee34	8e 00 df	stx $df00	                stx hazel.currentFS
10000	.ee37	a9 0f		lda #$0f	                lda #terminalROM
10001	.ee39	8d 03 df	sta $df03	                sta hazel.currentFSROM
10002	.ee3c	68		pla		                pla                          ; Restore ACCON
10003	.ee3d					selectMOSOrHAZEL:                                       ;edb0
10004	.ee3d	29 08		and #$08	                and #ACCCON.Y   ;get just the HAZEL/MOS bit
10005	.ee3f	d0 08		bne $ee49	                bne setACCCONBits      ;branch taken if HAZEL at $c000
10006	.ee41					selectMOS:
10007	.ee41	a9 08		lda #$08	                lda #ACCCON.Y
10008	.ee43	1c 34 fe	trb $fe34	                trb ACCCON      ;page in MOS at $c000
10009	.ee46	60		rts		                rts

10011	.ee47					selectHAZEL:
10012	.ee47	a9 08		lda #$08	                lda #ACCCON.Y
10013	.ee49					setACCCONBits:
10014	.ee49	0c 34 fe	tsb $fe34	                tsb ACCCON      ;page in HAZEL at $c000
10015	.ee4c	60		rts		                rts

10017						;-------------------------------------------------------------------------

10025						;-------------------------------------------------------------------------
10026						;
10027						; Select ROM or TAPE.
10028						;
10029						; Two entry points: selectROMOrTAPEByOSBYTE picks FS by OSBYTE number
10030						; ($8c=TAPE, $8d=ROM), and selectROMOrTAPE picks FS by number (0=TAPE,
10031						; 1=ROM).
10032						;
10033						; entry:
10034						;
10035						; A = FS to select
10036						;
10037	.ee4d					selectROMOrTAPEByOSBYTE:

10051	.ee4d	49 8c		eor #$8c	                eor #$8C                     ;A=0 if tape, A=1 if ROM
10052	.ee4f					selectROMOrTAPE:
10053	.ee4f	0a		asl a		                asl a           ; Set CFS/RFS switch to 0=CFS or 2=RFS
10054	.ee50	8d 47 02	sta $0247	                sta cfsRFSFSSwitch
10055	.ee53	d0 04		bne $ee59	                bne LEDCC                    ;taken if ROM
10056	.ee55	a9 04		lda #$04	                lda #$04                     ; CFS, clear b2 of status
10057	.ee57	14 e2		trb $e2		                trb $E2
10058	.ee59					LEDCC:
10059	.ee59	e0 03		cpx #$03	                cpx #$03                     ; EQ=TAPE 300, NE=TAPE 1200
10060	.ee5b	80 06		bra $ee63	                bra LEDD6

10062	.ee5d					LEDD0:
10066	.ee5d	20 f1 ee	jsr $eef1	                jsr LEE64
10067	.ee60	20 a4 f2	jsr $f2a4	                jsr LF1EE
10068	.ee63					LEDD6:
10069	.ee63	08		php		                php                          ; Save baud flag in Carry
10070	.ee64	a9 06		lda #$06	                lda #$06                     ; Vectors about to change
10071	.ee66	20 9b f2	jsr $f29b	                jsr callFSCV
10072	.ee69	ad 47 02	lda $0247	                lda cfsRFSFSSwitch           ; Jump if RFS selected
10073	.ee6c	d0 0d		bne $ee7b	                bne LEDEE
10074	.ee6e	a2 06		ldx #$06	                ldx #$06                     ; Prepare baud=6 for TAPE300
10075	.ee70	28		plp		                plp                          ; Skip past if TAPE300
10076	.ee71	f0 05		beq $ee78	                beq LEDEB
10077	.ee73	a9 04		lda #$04	                lda #$04                     ; TAPE1200, set bit 2 of status
10078	.ee75	04 e2		tsb $e2		                tsb $E2
10079	.ee77	ca		dex		                dex                          ; Change to baud=5 for TAPE1200
10080	.ee78					LEDEB:
10081	.ee78	86 c6		stx $c6		                stx $C6                      ; Store baud rate setting
10082	.ee7a	08		php		                php
10083	.ee7b					LEDEE:
10084	.ee7b	64 ce		stz $ce		                stz $CE                      ; Clear byte (unused on BBC)
10085	.ee7d	28		plp		                plp

10088	.ee7e	a2 0e		ldx #$0e	                ldx #defaultVectorTable.fsVectors.end-defaultVectorTable.fsVectors ; Prepare to set 7 vectors
10089	.ee80					LEDF3:
10090	.ee80	bd 0a e3	lda $e30a,x	                lda defaultVectorTable.fsVectors-1,x ; Set filing
10091						                                                     ; system vectors
10092						                                                     ; to point to
10093						                                                     ; extended
10094						                                                     ; vectors
10095	.ee83	9d 11 02	sta $0211,x	                sta FILEV-1,x
10096	.ee86	ca		dex		                dex
10097	.ee87	d0 f7		bne $ee80	                bne LEDF3
10098	.ee89	20 a4 f2	jsr $f2a4	                jsr LF1EE                    ; Set extended vectors
10099	.ee8c	64 c2		stz $c2		                stz $C2                      ; Set Progress=idle
10100	.ee8e	a2 0f		ldx #$0f	                ldx #romServiceCallVectorsClaimed ; Send service call &0F - vectors changed

10102						;-------------------------------------------------------------------------
10103						;
10104						; OSBYTE 143 (&8F) Issue paged ROM service request [MasRef D.2-44]
10105						;
10106	.ee90					osbyte8F: .proc                    ;ee03
10107	.ee90	5a		phy		                phy
10108	.ee91	da		phx		                phx                          ; Send service call
10109	.ee92	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
10110	.ee95	fa		plx		                plx
10111	.ee96	e0 0f		cpx #$0f	                cpx #romServiceCallVectorsClaimed ; If VectorsClaimed,
10112						                                                  ; hook FileSwitch
10113						                                                  ; back in
10114	.ee98	f0 36		beq $eed0	                beq handleVectorsClaimed
10115	.ee9a	1a		inc a		                inc a       ; If claimed, check for
10116						                            ; InitialiseFilingSystem or
10117						                            ; UnrecognisedCommand
10118	.ee9b	3a		dec a		                dec a       ;Z=1 if claimed
10119	.ee9c	f0 03		beq $eea1	                beq wasClaimed  ;branch taken if claimed
10120	.ee9e					done:
10121	.ee9e	fa		plx		                plx             ; Return with result in X, EQ=Claimed
10122	.ee9f	aa		tax		                tax
10123	.eea0	60		rts		                rts

10125	.eea1					wasClaimed:
10126	.eea1	e0 12		cpx #$12	                cpx #romServiceCallInitialiseFilingSystem
10127	.eea3	f0 04		beq $eea9	                beq +
10128	.eea5	e0 04		cpx #$04	                cpx #romServiceCallUnrecognisedCommand
10129	.eea7	d0 f5		bne $ee9e	                bne done
10130	.eea9					+

10132						; handle InitialiseFilingSystem ($12) or UnrecognisedCommand ($04)

10134	.eea9	7a		ply		                ply                     ;Y=service call arg
10135	.eeaa	48		pha		                pha                     ;save A (though actually it's
10136						                                        ;always $00...)
10137	.eeab	ad 34 fe	lda $fe34	                lda ACCCON
10138	.eeae	48		pha		                pha                     ;save ACCCON
10139	.eeaf	20 47 ee	jsr $ee47	                jsr selectHAZEL
10140	.eeb2	38		sec		                sec
10141	.eeb3	6e 00 df	ror $df00	                ror hazel.currentFS ;set currentFS bit 7
10142	.eeb6					LEE29:
10143	.eeb6	5a		phy		                phy             ;save ROM service call argument
10144	.eeb7	a9 00		lda #$00	                lda #$00
10145	.eeb9	a8		tay		                tay
10146	.eeba	20 8b f9	jsr $f98b	                jsr callARGSV   ;A=0, Y=0 - get active FS number
10147	.eebd	8d 01 df	sta $df01	                sta hazel.activeFS ;save active FS number
10148	.eec0	2c 00 df	bit $df00	                bit hazel.currentFS
10149	.eec3	10 03		bpl $eec8	                bpl LEE3B
10150	.eec5	20 c5 f2	jsr $f2c5	                jsr osbyte6D
10151	.eec8					LEE3B:
10152	.eec8	7a		ply		                ply
10153	.eec9	68		pla		                pla
10154	.eeca	20 3d ee	jsr $ee3d	                jsr selectMOSOrHAZEL
10155	.eecd	68		pla		                pla
10156	.eece	aa		tax		                tax
10157	.eecf	60		rts		                rts

10159	.eed0					handleVectorsClaimed:
10160	.eed0	7a		ply		                ply
10161	.eed1	48		pha		                pha
10162	.eed2	ad 34 fe	lda $fe34	                lda ACCCON
10163	.eed5	48		pha		                pha
10164	.eed6	20 47 ee	jsr $ee47	                jsr selectHAZEL
10165	.eed9	ad 1e 02	lda $021e	                lda FSCV+0
10166	.eedc	8d da df	sta $dfda	                sta hazel.activeFSCV+0
10167	.eedf	ad 1f 02	lda $021f	                lda FSCV+1
10168	.eee2	8d db df	sta $dfdb	                sta hazel.activeFSCV+1
10169	.eee5	a9 dc		lda #$dc	                lda #<fileswitchFSCEntryPoint
10170	.eee7	8d 1e 02	sta $021e	                sta FSCV+0
10171	.eeea	a9 fa		lda #$fa	                lda #>fileswitchFSCEntryPoint
10172	.eeec	8d 1f 02	sta $021f	                sta FSCV+1
10173	.eeef	80 c5		bra $eeb6	                bra LEE29
10174						                .pend

10176						;-------------------------------------------------------------------------

10178	.eef1					LEE64:
10179	.eef1	a9 a1		lda #$a1	                lda #$A1
10180	.eef3	85 e3		sta $e3		                sta $E3
10181	.eef5	a9 19		lda #$19	                lda #$19
10182	.eef7	8d d1 03	sta $03d1	                sta $03D1
10183	.eefa	a9 04		lda #$04	                lda #$04
10184	.eefc	04 e2		tsb $e2		                tsb $E2
10185	.eefe	60		rts		                rts

10187						;-------------------------------------------------------------------------
10188						;
10189						; Pass service call around sideways ROMs
10190						;
10191						; Entry:
10192						; X=service call number
10193						; Y=any parameters
10194						;
10195						; Exit:
10196						; X=0 or preserved
10197						; Y=any returned parameters
10198						; EQ=call claimed if called directly
10199						;
10200	.eeff					makeROMServiceCall: .proc                    ;ee72
10201	.eeff	a5 f4		lda $f4		                lda $F4         ; Save current ROM
10202	.ef01	48		pha		                pha
10203	.ef02	ad 34 fe	lda $fe34	                lda ACCCON      ; Save current paging state
10204	.ef05	48		pha		                pha
10205	.ef06	20 47 ee	jsr $ee47	                jsr selectHAZEL ; Page in Hazel
10206	.ef09	8a		txa		                txa             ; Pass service call number to A
10207	.ef0a	a2 0f		ldx #$0f	                ldx #$0F     ; Start at ROM 15, and always call ROM 15
10208	.ef0c	80 05		bra $ef13	                bra callServiceEntry
10209	.ef0e					callServiceEntriesLoop:
10210	.ef0e	3c a1 02	bit $02a1,x	                bit romInformationTable,x ;check if ROM X has a service entry
10211	.ef11	10 0b		bpl $ef1e	                bpl nextROM       ;branch taken if no service entry
10212	.ef13					callServiceEntry:
10213	.ef13	20 9a e5	jsr $e59a	                jsr selectROMX  ; Page in ROM X
10214	.ef16	20 03 80	jsr $8003	                jsr $8003       ; Call ROM service entry point
10215	.ef19	aa		tax		                tax             ; X = service call result
10216	.ef1a	f0 05		beq $ef21	                beq done       ;branch taken if service call claimed
10217	.ef1c	a6 f4		ldx $f4		                ldx $F4         ; Get ROM number
10218	.ef1e					nextROM:
10219	.ef1e	ca		dex		                dex       ; Step down to next ROM, loop until all done
10220	.ef1f	10 ed		bpl $ef0e	                bpl callServiceEntriesLoop

10222	.ef21					done:
10223	.ef21	68		pla		                pla                          ; Restore paging state
10224	.ef22	20 3d ee	jsr $ee3d	                jsr selectMOSOrHAZEL
10225	.ef25	68		pla		                pla                          ; Restore current ROM
10226	.ef26	20 ab e5	jsr $e5ab	                jsr selectROMA
10227	.ef29	8a		txa		                txa                          ; Pass claim/noclaim to A
10228	.ef2a	60		rts		                rts
10229						                .pend

10231						;-------------------------------------------------------------------------

10233						; OSBYTE &6B (107) - Select memory for direct access
10234						; ==============================================
10235	.ef2b					osbyte6B:                       ;ee9e
10236	.ef2b	a0 20		ldy #$20	                ldy #$20                     ; Y=&20 to change 1MHz bit
10237	.ef2d	80 02		bra $ef31	                bra LEEA4

10239						;-------------------------------------------------------------------------

10241						; OSBYTE &6C (108) - Select memory for direct access
10242						; ==============================================
10243	.ef2f					osbyte6C:
10244	.ef2f	a0 04		ldy #$04	                ldy #ACCCON.X                ; Y=&04 to change RAM bit
10245	.ef31					LEEA4:
10246	.ef31	98		tya		                tya                          ; Clear RAM or 1MHz bit
10247	.ef32	1c 34 fe	trb $fe34	                trb ACCCON
10248	.ef35	8a		txa		                txa                          ; If X=0, exit with normal RAM/1MHz selected
10249	.ef36	f0 05		beq $ef3d	                beq LEEB0
10253	.ef38	a9 04		lda #$04	                lda #ACCCON.X                ; BUG! This should be TYA
10255	.ef3a	0c 34 fe	tsb $fe34	                tsb ACCCON                   ; Page in shadow RAM
10256	.ef3d					LEEB0:
10257	.ef3d	60		rts		                rts                          ; X preserved, Y=&04 or &20

10259						;-------------------------------------------------------------------------

10261						osword06Macro: .macro
10268						                .endmacro

10270						LEF1BMacro: .macro
10282						                .endmacro

10284						;-------------------------------------------------------------------------

10287	.ef3e					osword06:
10262	.ef3e	20 12 f0	jsr $f012	                jsr getAddressFromOSWORDParameterBlock
10263	.ef41	b1 f0		lda ($f0),y	                lda (originalX),y
10264	.ef43	92 fa		sta ($fa)	                sta (SEIWKA)
10265	.ef45					ret:
10266	.ef45	a9 00		lda #$00	                lda #$00
10267	.ef47	60		rts		                rts
10288	.ef48					LEF1B:
10271	.ef48	a5 eb		lda $eb		                lda $EB
10272	.ef4a	30 f9		bmi $ef45	                bmi osword06.ret
10273	.ef4c	ad 57 02	lda $0257	                lda spoolFileHandle
10274	.ef4f	d0 f4		bne $ef45	                bne osword06.ret
10275	.ef51	a9 08		lda #$08	                lda #$08
10276	.ef53	25 e2		and $e2		                and $E2
10277	.ef55	d0 04		bne $ef5b	                bne LEF2E
10278	.ef57	a9 88		lda #$88	                lda #$88
10279	.ef59	25 bb		and $bb		                and $BB
10280	.ef5b					LEF2E:
10281	.ef5b	60		rts		                rts

10291						;-------------------------------------------------------------------------

10294	.ef5c					oswordEntryPoint:
10295	.ef5c	48		pha		                pha
10296	.ef5d	08		php		                php
10297	.ef5e	78		sei		                sei
10298	.ef5f	85 ef		sta $ef		                sta originalA
10299	.ef61	86 f0		stx $f0		                stx originalX
10300	.ef63	84 f1		sty $f1		                sty originalY
10301	.ef65	a2 08		ldx #$08	                ldx #romServiceCallUnrecognisedOSWORD
10302	.ef67	c9 e0		cmp #$e0	                cmp #$e0
10303	.ef69	b0 3f		bcs $efaa	                bcs osbyteOrUSERV
10304	.ef6b	c9 10		cmp #$10	                cmp #$10
10305	.ef6d	90 0e		bcc $ef7d	                bcc osword00To0F
10306	.ef6f	c9 44		cmp #$44	                cmp #$44
10307	.ef71	b0 05		bcs $ef78	                bcs osword44ToFF
10308	.ef73	c9 42		cmp #$42	                cmp #$42
10309	.ef75	b0 04		bcs $ef7b	                bcs osword42To43
10310	.ef77	38		sec		                sec
10311	.ef78					osword44ToFF:
10312	.ef78	4c 01 f0	jmp $f001	                jmp handleUnrecognisedOSBYTEOrOSWORD

10314	.ef7b					osword42To43:
10316	.ef7b	e9 33		sbc #$33	                sbc #$42-((osword42AndAboveRoutineTable-oswordRoutineTable)/2-1)

10318	.ef7d					osword00To0F:
10320	.ef7d	69 59		adc #$59	                adc #(oswordRoutineTable-osbyteAndOSWORDRoutineTable)/2
10321	.ef7f	0a		asl a		                asl a
10322	.ef80	80 32		bra $efb4	                bra callOSBYTEOrOSWORDFromTable

10325						;-------------------------------------------------------------------------

10328	.ef82					selectTerminalROMAndOSWORD0E:
10329	.ef82	c9 03		cmp #$03	                cmp #3
10330	.ef84	b0 77		bcs $effd	                bcs handleUnrecognisedOSWORD
10331	.ef86	20 61 f4	jsr $f461	                jsr withTerminalROM
10332	.ef89	4c e8 98	jmp $98e8	                jmp osword0E

10335						;-------------------------------------------------------------------------

10338	.ef8c					LEF85:
10339	.ef8c	28		plp		                plp
10340	.ef8d	68		pla		                pla
10341	.ef8e	2c 70 e3	bit $e370	                bit valueFF
10342	.ef91	60		rts		                rts

10345						;-------------------------------------------------------------------------

10348						; OSBYTE
10349						; ======
10350	.ef92					osbyteEntryPoint:
10351	.ef92	48		pha		                pha
10352	.ef93	08		php		                php
10353	.ef94	78		sei		                sei
10354	.ef95	85 ef		sta $ef		                sta originalA
10355	.ef97	86 f0		stx $f0		                stx originalX
10356	.ef99	84 f1		sty $f1		                sty originalY
10357	.ef9b	a2 07		ldx #$07	                ldx #romServiceCallUnrecognisedOSBYTE
10358	.ef9d	c9 6b		cmp #$6b	                cmp #$6B
10359	.ef9f	90 4c		bcc $efed	                bcc osbyte00To6A
10360	.efa1	c9 a6		cmp #$a6	                cmp #$A6
10361	.efa3	90 09		bcc $efae	                bcc osbyte6BToA5
10362	.efa5	c9 a6		cmp #$a6	                cmp #$A6
10363	.efa7	90 58		bcc $f001	                bcc handleUnrecognisedOSBYTEOrOSWORD       ;??? - wait... didn't we just do this?

10365	.efa9					osbyteA6ToFF:
10366	.efa9	18		clc		                clc
10367	.efaa					osbyteOrUSERV:      ;call OSBYTE A6+ routine if C=0; call USERV if C=1
10368	.efaa	a9 a6		lda #$a6	                lda #$A6
10369	.efac	69 00		adc #$00	                adc #$00
10374	.efae					osbyte6BToA5:
10375						                ; map $6b-$a5 to $46-$80
10376	.efae	e9 24		sbc #$24	                sbc #$24
10377	.efb0					osbyte44To45:
10378						                ; map $44-$80 $1a-$56
10379	.efb0	e9 2a		sbc #$2a	                sbc #$2A
10381	.efb2					osbyteUseTable:
10382	.efb2	0a		asl a		                asl a           ;table is of words
10383	.efb3	38		sec		                sec
10384	.efb4					callOSBYTEOrOSWORDFromTable:
10385	.efb4	84 f1		sty $f1		                sty originalY
10386	.efb6	a8		tay		                tay             ;get table offset in Y
10387	.efb7	2c 5e 02	bit $025e	                bit econetInterceptionStatus
10388	.efba	10 07		bpl $efc3	                bpl LEEE0             ;taken if no Econet interception
10389	.efbc	8a		txa		                txa
10392	.efbd	b8		clv		                clv
10393	.efbe	20 65 ec	jsr $ec65	                jsr callNETV
10394	.efc1	70 24		bvs $efe7	                bvs LEEFA
10395	.efc3					LEEE0:
10397	.efc3	a5 f4		lda $f4		                lda $f4
10398	.efc5	48		pha		                pha
10399	.efc6	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM
10410	.efc9	b9 e6 8f	lda $8fe6,y	                lda osbyteAndOSWORDRoutineTable+1,y
10411	.efcc	85 fb		sta $fb		                sta SEIWKB
10412	.efce	b9 e5 8f	lda $8fe5,y	                lda osbyteAndOSWORDRoutineTable,y
10413	.efd1	85 fa		sta $fa		                sta SEIWKA
10416	.efd3	fa		plx		                plx
10417	.efd4	20 9a e5	jsr $e59a	                jsr selectROMX
10423	.efd7	a5 ef		lda $ef		                lda originalA
10424	.efd9	a4 f1		ldy $f1		                ldy originalY
10425	.efdb	b0 04		bcs $efe1	                bcs +
10426	.efdd	a0 00		ldy #$00	                ldy #$00            ;??? - is this actually desirable?
10427	.efdf	b2 f0		lda ($f0)	                lda ($F0)           ;fetch 0th byte of parameter block
10428	.efe1					+
10429	.efe1	38		sec		                sec
10433	.efe2	a6 f0		ldx $f0		                ldx originalX

10435						; on entry to the OSBYTE handlers, C=1, N/Z set as per X.

10437	.efe4	20 7b f7	jsr $f77b	                jsr callSEIWKA
10439	.efe7					LEEFA:
10440	.efe7	6a		ror a		                ror a
10441	.efe8	28		plp		                plp
10442	.efe9	2a		rol a		                rol a
10443	.efea	68		pla		                pla
10444	.efeb	b8		clv		                clv
10445	.efec	60		rts		                rts

10447	.efed					osbyte00To6A:
10448	.efed	a0 00		ldy #$00	                ldy #$00        ;Y=0 on entry for this lot
10449	.efef	c9 1a		cmp #$1a	                cmp #$1A        ;OSBYTE <=$19 is table-driven
10450	.eff1	90 bf		bcc $efb2	                bcc osbyteUseTable ;taken if OSBYTE $00-$19
10452	.eff3	c9 44		cmp #$44	                cmp #$44
10453	.eff5	f0 b9		beq $efb0	                beq osbyte44To45
10454	.eff7	c9 45		cmp #$45	                cmp #$45
10455	.eff9	f0 b5		beq $efb0	                beq osbyte44To45
10457	.effb	80 04		bra $f001	                bra handleUnrecognisedOSBYTEOrOSWORD

10459	.effd					handleUnrecognisedOSWORD:
10460	.effd	a2 08		ldx #$08	                ldx #romServiceCallUnrecognisedOSWORD
10461	.efff	68		pla		                pla
10462	.f000	68		pla		                pla
10463	.f001					handleUnrecognisedOSBYTEOrOSWORD:
10464	.f001	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
10468	.f004	d0 86		bne $ef8c	                bne LEF85
10470	.f006	a6 f0		ldx $f0		                ldx originalX
10471	.f008	80 dd		bra $efe7	                bra LEEFA

10480						;-------------------------------------------------------------------------

10486						;-------------------------------------------------------------------------
10487						;
10488						; OSWORD 14 (&0E) Read CMOS clock [MasRef D.3-22]
10489						;

10498						;-------------------------------------------------------------------------
10499						;
10500						; Entry point for OSWORD.
10501						;
10502						; D.3-3
10503						;

10550						;-------------------------------------------------------------------------
10551						;
10552						; OSWORD 5 (&05) Read byte from I/O processor memory [MasRef D.3-9]
10553						;
10554	.f00a					osword05:
10555	.f00a	20 12 f0	jsr $f012	                jsr getAddressFromOSWORDParameterBlock
10556	.f00d	b2 fa		lda ($fa)	                lda (SEIWKA)                 ;read byte from the address
10557	.f00f	91 f0		sta ($f0),y	                sta (originalX),y                  ;update parameter block
10558	.f011	60		rts		                rts

10560						;-------------------------------------------------------------------------
10561						;
10562						; OSWORD 6 (&06) Write byte to I/O processor memory [MasRef D.3-9]
10563						;

10569						;-------------------------------------------------------------------------
10570						;
10571						; Get address from OSWORD parameter block.
10572						;
10573						; entry:
10574						;
10575						; A = 0th byte of parameter block
10576						;
10577						; Y = 0
10578						;
10579						; (originalX) = parameter block
10580						;
10581						; exit:
10582						;
10583						; (SEIWKA) = address, first two bytes from parameter block
10584						;
10585						; Y = 4 (this is just convenient for both callers)
10586						;
10587	.f012					getAddressFromOSWORDParameterBlock:
10588	.f012	85 fa		sta $fa		                sta SEIWKA
10589	.f014	c8		iny		                iny
10590	.f015	b1 f0		lda ($f0),y	                lda (originalX),y
10591	.f017	85 fb		sta $fb		                sta SEIWKA+1
10592	.f019	a0 04		ldy #$04	                ldy #$04
10593	.f01b					ldxim03_rts:
10599	.f01b	a2 05		ldx #$05	                ldx #$05
10601	.f01d	60		rts		                rts

10603						;-------------------------------------------------------------------------
10604						;
10605						; OSBYTE 0 (&00) Display MOS version
10606						;
10607						; OSBYTE 0 has the effect of performing a BRK instruction and
10608						; displaying the MOS version number.
10609						;
10610						; Entry parameters :
10611						;
10612						; X=0 executes a BRK and displays the OS version
10613						;
10614						; X=1 executes an RTS and returns the Operating system version
10615						;
10616						; On exit : X=<OS version>
10617						;
10618						; D.2-18
10619						;
10620	.f01e					osbyte00:                       ;ef6f
10621	.f01e	d0 fb		bne $f01b	                bne ldxim03_rts ;branch taken if X<>0 - return with
10622						                                 ;X=3

10624						; do a BRK and print MOS version number.

10626	.f020	00		brk #		                brk
10627	>f021	f7 4d 4f 53 20 35 2e 31		                .text $f7,versionString,0
	>f029	30 69 00

10629						;-------------------------------------------------------------------------
10630						;
10631						; OSWORD 7 (&07) Generate a sound [MasRef D.3-10]
10632						;
10633	.f02c					osword07:
10634	.f02c	c8		iny		                iny
10635	.f02d	b1 f0		lda ($f0),y	                lda ($F0),y
10636	.f02f	c9 20		cmp #$20	                cmp #$20
10637	.f031	b0 ca		bcs $effd	                bcs handleUnrecognisedOSWORD
10638	.f033	88		dey		                dey
10639	.f034	20 a7 f0	jsr $f0a7	                jsr LEFF6
10640	.f037	09 04		ora #$04	                ora #$04
10641	.f039	aa		tax		                tax
10642	.f03a	90 05		bcc $f041	                bcc LEF90
10643	.f03c	20 85 ea	jsr $ea85	                jsr LE95A
10644	.f03f	a0 01		ldy #$01	                ldy #$01
10645	.f041					LEF90:
10646	.f041	20 a7 f0	jsr $f0a7	                jsr LEFF6
10647	.f044	85 fa		sta $fa		                sta $FA
10648	.f046	08		php		                php
10649	.f047	a0 06		ldy #$06	                ldy #$06
10650	.f049	b1 f0		lda ($f0),y	                lda ($F0),y
10651	.f04b	48		pha		                pha
10652	.f04c	a0 04		ldy #$04	                ldy #$04
10653	.f04e	b1 f0		lda ($f0),y	                lda ($F0),y
10654	.f050	48		pha		                pha
10655	.f051	a0 02		ldy #$02	                ldy #$02
10656	.f053	b1 f0		lda ($f0),y	                lda ($F0),y
10657	.f055	2a		rol a		                rol a
10658	.f056	3a		dec a		                dec a
10659	.f057	3a		dec a		                dec a
10660	.f058	0a		asl a		                asl a
10661	.f059	0a		asl a		                asl a
10662	.f05a	05 fa		ora $fa		                ora $FA
10663	.f05c	20 ce ea	jsr $eace	                jsr LE9A3
10664	.f05f	90 1e		bcc $f07f	                bcc LEFCE
10665	.f061	68		pla		                pla
10666	.f062	68		pla		                pla
10667	.f063	28		plp		                plp

10669						                ; WTF... fall through to OSBYTE $75!

10671						;-------------------------------------------------------------------------
10672						;
10673						; OSBYTE 117 (&75) Read VDU status [MasRef D.2-32]
10674						;
10675	.f064					osbyte75:
10676	.f064	a6 d0		ldx $d0		                ldx STATE
10677	.f066	60		rts		                rts

10679						;-------------------------------------------------------------------------
10680						;
10681						; VDU 7 (&07) Produce BELL sound [MasRef E.3-4]
10682						;
10683	.f067					vdu7EntryPoint:
10684	.f067	08		php		                php
10685	.f068	78		sei		                sei
10686	.f069	ad 63 02	lda $0263	                lda bellChannel
10687	.f06c	29 07		and #$07	                and #$07
10688	.f06e	09 04		ora #$04	                ora #$04
10689	.f070	aa		tax		                tax
10690	.f071	ad 64 02	lda $0264	                lda bellSound
10691	.f074	20 6b eb	jsr $eb6b	                jsr callINSV
10692	.f077	ad 66 02	lda $0266	                lda bellDuration
10693	.f07a	48		pha		                pha
10694	.f07b	ad 65 02	lda $0265	                lda bellFrequency
10695	.f07e	48		pha		                pha
10696	.f07f					LEFCE:
10697	.f07f	38		sec		                sec
10698	.f080	7e 00 08	ror $0800,x	                ror $0800,x
10699	.f083	68		pla		                pla
10700	.f084	20 6b eb	jsr $eb6b	                jsr callINSV
10701	.f087	68		pla		                pla
10702	.f088	20 6b eb	jsr $eb6b	                jsr callINSV
10703	.f08b	28		plp		                plp
10704	.f08c	60		rts		                rts

10706						;-------------------------------------------------------------------------
10707						;
10708						; OSWORD 8 (&08) Define a sound envelope [MasRef D.3-14]
10709						;
10710	.f08d					osword08:
10711	.f08d	3a		dec a		                dec a                   ;get index of 1-based envelope
10712	.f08e	0a		asl a		                asl a
10713	.f08f	0a		asl a		                asl a
10714	.f090	0a		asl a		                asl a
10715	.f091	0a		asl a		                asl a                        ;index*16
10716	.f092	09 0f		ora #$0f	                ora #$0F                     ;index*16+15
10717	.f094	aa		tax		                tax                          ;
10718	.f095	a9 00		lda #$00	                lda #$00                     ;
10719	.f097	a0 10		ldy #$10	                ldy #16             ;16 bytes of envelope data get set
10720	.f099					-
10721	.f099	c0 0e		cpy #$0e	                cpy #$0E                     ;
10722	.f09b	b0 02		bcs $f09f	                bcs + ;taken if last 2 bytes of data - they get initialized to $00
10723	.f09d	b1 f0		lda ($f0),y	                lda (originalX),y        ;fetch byte from OSWORD block
10724	.f09f					+
10725	.f09f	9d c0 08	sta $08c0,x	                sta envelope1Data,x          ;set envelope data bytes
10726	.f0a2	ca		dex		                dex
10727	.f0a3	88		dey		                dey
10728	.f0a4	d0 f3		bne $f099	                bne -
10729	.f0a6	60		rts		                rts

10731						;-------------------------------------------------------------------------

10733	.f0a7					LEFF6:
10734	.f0a7	b1 f0		lda ($f0),y	                lda ($F0),y
10735	.f0a9	c9 10		cmp #$10	                cmp #$10
10736	.f0ab	29 03		and #$03	                and #$03
10737	.f0ad	c8		iny		                iny
10738	.f0ae	60		rts		                rts

10740						;-------------------------------------------------------------------------
10741						;
10742						; OSWORD 3 (&03) Read interval timer [MasRef D.3-8]
10743						;
10744	.f0af					osword03:
10745	.f0af	a2 0f		ldx #$0f	                ldx #$0F
10746	.f0b1	80 03		bra $f0b6	                bra LF005

10748						;-------------------------------------------------------------------------
10749						;
10750						; OSWORD 1 (&01) Read system clock [MasRef D.3-7]
10751						;
10752	.f0b3					osword01:
10753	.f0b3	ae 83 02	ldx $0283	                ldx timerSwitchState
10754	.f0b6					LF005:
10755	.f0b6	a0 04		ldy #$04	                ldy #$04
10756	.f0b8					-
10757	.f0b8	bd 8d 02	lda $028d,x	                lda timer0-initialTimerSwitchState,x
10758	.f0bb	91 f0		sta ($f0),y	                sta (originalX),y
10759	.f0bd	e8		inx		                inx
10760	.f0be	88		dey		                dey
10761	.f0bf	10 f7		bpl $f0b8	                bpl -
10762	.f0c1					rtsF010:
10763	.f0c1	60		rts		                rts

10765						;-------------------------------------------------------------------------
10766						;
10767						; OSWORD 4 (&04) Write interval timer [MasRef D.3-9]
10768						;
10769	.f0c2					osword04:
10770	.f0c2	a9 0f		lda #$0f	                lda #intervalTimer-(timer0-initialTimerSwitchState)
10771	.f0c4	80 06		bra $f0cc	                bra copyTIMEValue

10773						;-------------------------------------------------------------------------
10774						;
10775						; OSWORD 2 (&02) Write system clock [MasRef D.3-8]
10776						;
10777	.f0c6					osword02:
10778	.f0c6	ad 83 02	lda $0283	                lda timerSwitchState
10779	.f0c9	49 0f		eor #$0f	                eor #$0F       ;select the timer that isn't being used
10780	.f0cb	18		clc		                clc
10781	.f0cc					copyTIMEValue:
10782	.f0cc	48		pha		                pha
10783	.f0cd	aa		tax		                tax
10784	.f0ce	a0 04		ldy #$04	                ldy #$04
10785	.f0d0					-
10786	.f0d0	b1 f0		lda ($f0),y	                lda (originalX),y
10787	.f0d2	9d 8d 02	sta $028d,x	                sta timer0-initialTimerSwitchState,x
10788	.f0d5	e8		inx		                inx
10789	.f0d6	88		dey		                dey
10790	.f0d7	10 f7		bpl $f0d0	                bpl -
10791	.f0d9	68		pla		                pla
10792	.f0da	b0 e5		bcs $f0c1	                bcs rtsF010
10793	.f0dc	8d 83 02	sta $0283	                sta timerSwitchState
10794	.f0df	60		rts		                rts

10796						;-------------------------------------------------------------------------
10797						;
10798						; OSWORD 0 (&00) Read line from input stream to memory [MasRef D.3-6]
10799						;
10800	.f0e0					osword00:
10801	.f0e0	a0 04		ldy #$04	                ldy #$04
10802	.f0e2					LF031:
10803	.f0e2	b1 f0		lda ($f0),y	                lda (originalX),y
10806	.f0e4	99 b1 02	sta $02b1,y	                sta osword0MaxLineLength-2,y
10807	.f0e7	88		dey		                dey
10808	.f0e8	c0 02		cpy #$02	                cpy #$02
10809	.f0ea	b0 f6		bcs $f0e2	                bcs LF031
10810	.f0ec	b1 f0		lda ($f0),y	                lda ($F0),y
10811	.f0ee	85 e9		sta $e9		                sta $E9
10812	.f0f0	88		dey		                dey
10813	.f0f1	9c 69 02	stz $0269	                stz pagedModeCounter
10814	.f0f4	b2 f0		lda ($f0)	                lda ($F0)
10815	.f0f6	85 e8		sta $e8		                sta $E8
10816	.f0f8	58		cli		                cli
10817	.f0f9	80 07		bra $f102	                bra LF051

10819	.f0fb					LF04A:
10820	.f0fb	a9 07		lda #$07	                lda #$07
10821	.f0fd					LF04C:
10822	.f0fd	88		dey		                dey
10823	.f0fe					LF04D:
10824	.f0fe	c8		iny		                iny
10825	.f0ff					LF04E:
10826	.f0ff	20 ee ff	jsr $ffee	                jsr OSWRCH
10827	.f102					LF051:
10828	.f102	20 e0 ff	jsr $ffe0	                jsr OSRDCH
10829	.f105	b0 49		bcs $f150	                bcs LF09F
10830	.f107	aa		tax		                tax
10831	.f108	ad 7c 02	lda $027c	                lda characterDestinationStatus
10832	.f10b	6a		ror a		                ror a
10833	.f10c	6a		ror a		                ror a
10834	.f10d	8a		txa		                txa
10835	.f10e	b0 05		bcs $f115	                bcs LF064
10836	.f110	ae 6a 02	ldx $026a	                ldx vduQueueNegativeLength
10837	.f113	d0 ea		bne $f0ff	                bne LF04E
10838	.f115					LF064:
10839	.f115	c9 7f		cmp #$7f	                cmp #$7F
10840	.f117	d0 07		bne $f120	                bne LF06F
10841	.f119	c0 00		cpy #$00	                cpy #$00
10842	.f11b	f0 e5		beq $f102	                beq LF051
10843	.f11d	88		dey		                dey
10844	.f11e	80 df		bra $f0ff	                bra LF04E

10846	.f120					LF06F:
10847	.f120	c9 15		cmp #$15	                cmp #$15
10848	.f122	d0 0d		bne $f131	                bne LF080
10849	.f124	98		tya		                tya
10850	.f125	f0 db		beq $f102	                beq LF051
10851	.f127	a9 7f		lda #$7f	                lda #$7F
10852	.f129					LF078:
10853	.f129	20 ee ff	jsr $ffee	                jsr OSWRCH
10854	.f12c	88		dey		                dey
10855	.f12d	d0 fa		bne $f129	                bne LF078
10856	.f12f	80 d1		bra $f102	                bra LF051

10858	.f131					LF080:
10859	.f131	91 e8		sta ($e8),y	                sta ($E8),y
10860	.f133	c9 0d		cmp #$0d	                cmp #$0D
10861	.f135	f0 13		beq $f14a	                beq LF099
10862	.f137	cc b3 02	cpy $02b3	                cpy osword0MaxLineLength
10863	.f13a	b0 bf		bcs $f0fb	                bcs LF04A
10864	.f13c	cd b4 02	cmp $02b4	                cmp osword0MinASCIICharacter
10865	.f13f	90 bc		bcc $f0fd	                bcc LF04C
10866	.f141	cd b5 02	cmp $02b5	                cmp osword0MaxASCIICharacter
10867	.f144	f0 b8		beq $f0fe	                beq LF04D
10868	.f146	90 b6		bcc $f0fe	                bcc LF04D
10869	.f148	80 b3		bra $f0fd	                bra LF04C

10871	.f14a					LF099:
10872	.f14a	20 e7 ff	jsr $ffe7	                jsr OSNEWL
10873	.f14d	20 65 ec	jsr $ec65	                jsr callNETV
10874	.f150					LF09F:
10875	.f150	a5 ff		lda $ff		                lda $FF
10876	.f152	2a		rol a		                rol a
10877	.f153	60		rts		                rts

10879						;-------------------------------------------------------------------------
10880						;
10881						; OSBYTE 3 (&03) Specify output stream [MasRef D.2-19]
10882						;
10883	.f154					osbyte03:
10884	.f154	da		phx		                phx
10885	.f155	ae 7c 02	ldx $027c	                ldx characterDestinationStatus
10886	.f158	a9 0a		lda #$0a	                lda #printerDriverFX3
10887	.f15a	20 67 ea	jsr $ea67	                jsr callPrinterDriver
10888	.f15d	fa		plx		                plx
10889	.f15e	a9 03		lda #$03	                lda #$03
10890	.f160	a0 00		ldy #$00	                ldy #$00
10891	.f162	80 23		bra $f187	                bra osbyte04

10893						;-------------------------------------------------------------------------
10894						;
10895						; OSBYTE 6 (&06) Write printer ignore character [MasRef D.2-21]
10896						;
10897	.f164					osbyte06:                       ;f0b3
10898	.f164	4e 46 02	lsr $0246	                lsr noignoreState
10899	.f167	80 16		bra $f17f	                bra osbyte01

10901						;-------------------------------------------------------------------------
10902						;
10903						; OSBYTE 114 (&72) Write usage of shadow memory [MasRef D.2-32]
10904						;
10905	.f169					osbyte72:                       ;f0b8
10906	.f169	a9 1f		lda #$1f	                lda #$1F
10907	.f16b	80 10		bra $f17d	                bra LF0CC

10909						;-------------------------------------------------------------------------
10910						;
10911						; OSBYTE 5 (&05) Write printer driver type [MasRef D.2-20]
10912						;
10913	.f16d					osbyte05:
10914	.f16d					waitForPrinterDriverDormant:
10915	.f16d	58		cli		                cli
10916	.f16e	78		sei		                sei
10917	.f16f	24 ff		bit $ff		                bit $FF                      ;test for ESCAPE
10918	.f171	30 29		bmi $f19c	                bmi rtsF0EB                  ;taken if ESCAPE pressed
10919	.f173	2c d1 02	bit $02d1	                bit bufferEmptyFlags+bufferPrinter
10920	.f176	10 f5		bpl $f16d	                bpl waitForPrinterDriverDormant ;taken if printer driver active
10921	.f178	20 67 ea	jsr $ea67	                jsr callPrinterDriver    ;call with A=printerDriverFX5
10922	.f17b	a0 00		ldy #$00	                ldy #$00
10923	.f17d					LF0CC:
10924	.f17d	64 f1		stz $f1		                stz $F1

10926						                ; fall through to standard MOS variable handling,
10927						                ; affecting printerDriverType

10929						;-------------------------------------------------------------------------
10930						;
10931						; OSBYTE 1 (&01) Write user flag [MasRef D.2-18]
10932						;
10933	.f17f					osbyte01:
10934	.f17f	49 f0		eor #$f0	                eor #firstMOSVariableOSBYTE+(userFlag-mosVariables)-1 ;-1 because OSBYTE 1
10935	.f181	80 07		bra $f18a	                bra osbyteA6X  ;jump to standard MOS variable handling

10937						;-------------------------------------------------------------------------
10938						;
10939						; OSBYTE 12 (&0C) Write keyboard auto-repeat rate [MasRef D.2-23]
10940						;
10941	.f183					osbyte0C:
10942	.f183	f0 33		beq $f1b8	                beq resetKeyRepeat    ;taken if X=0

10944						;-------------------------------------------------------------------------
10945						;
10946						; OSBYTE 11 (&0B) Write keyboard auto-repeat delay [MasRef D.2-22]
10947						;
10948	.f185					osbyte0B:
10949						                ; TODO - turn this constant into an expression
10950	.f185	69 cf		adc #$cf	                adc #$CF

10952						                ;if osbyte0C, A=$db
10953						                ;if osbyteOD, A=$dc

10955						;-------------------------------------------------------------------------
10956						;
10957						; OSBYTE 4 (&04) Enable/disable cursor editing [MasRef D.2-19]
10958						;
10959	.f187					osbyte04:
10960	.f187	18		clc		                clc
10961	.f188	69 e9		adc #$e9	                adc #firstMOSVariableOSBYTE+(editKeysMode-mosVariables)-4 ;-4 because OSBYTE 4

10963						                ;if originally OSBYTE 4 (&04) Enable/disable cursor
10964						                ;editing [MasRef D.2-19], it's now OSBYTE 237 (&ED)
10965						                ;Read/write cursor editing status [MasRef D.2-77].
10966						                ;
10967						                ;if originally OSBYTE 12 (&0C) Write keyboard
10968						                ;auto-repeat rate [MasRef D.2-23], it's now OSBYTE 197
10969						                ;(&C5) Read/write keyboard auto-repeat rate [MasRef
10970						                ;D.2-60].
10971						                ;
10972						                ;if originally OSBYTE 11 (&0B) Write keyboard
10973						                ;auto-repeat delay [MasRef D.2-22], it's now OSBYTE
10974						                ;196 (&C4) Read/write keyboard auto-repeat delay
10975						                ;[MasRef D.2-60].

10977	.f18a					osbyteA6X:
10978	.f18a	86 f0		stx $f0		                stx originalX

10980						;-------------------------------------------------------------------------
10981						;
10982						; OSBYTE 166 (&A6) Read start address of MOS variables [MasRef D.2-50]
10983						;
10984	.f18c					osbyteA6:
10985	.f18c	a8		tay		                tay             ;
10986	.f18d	b9 90 01	lda $0190,y	                lda mosVariables-firstMOSVariableOSBYTE,y;
10987	.f190	aa		tax		                tax             ;save old value
10988	.f191	25 f1		and $f1		                and originalY   ;AND old value with Y
10989	.f193	45 f0		eor $f0		                eor originalX   ;EOR old value with X
10990	.f195	99 90 01	sta $0190,y	                sta mosVariables-firstMOSVariableOSBYTE,y     ;set new variable value
10991	.f198	b9 91 01	lda $0191,y	                lda mosVariables-firstMOSVariableOSBYTE+1,y
10992	.f19b	a8		tay		                tay             ;Y=contents of next location
10993	.f19c					rtsF0EB:
10994	.f19c	60		rts		                rts

10996						;-------------------------------------------------------------------------
10997						;
10998						; This table is used to set the serial baud rate.
10999						;
11000						;   - bit 7 is not used (always clear)
11001						;   - bit 6 is not used (always set)
11002						;   - bits 3,4,5 indicate the serial receive baud rate
11003						;   - bits 0,1,2 indicate the serial transmit baud rate
11004						;
11005						;       111 =    75 baud
11006						;       011 =   150 baud
11007						;       101 =   300 baud
11008						;       001 =  1200 baud
11009						;       110 =  2400 baud
11010						;       010 =  4800 baud
11011						;       100 =  9600 baud
11012						;       000 = 19200 baud
11013						;
11015	.f19d					serialBaudRatesTable:
11016	>f19d	64				                .byte %01100100;$64
11017	>f19e	7f				                .byte %01111111;$7f
11018	>f19f	5b				                .byte %01011011;$5b
11019	>f1a0	6d				                .byte %01101101;$6d
11020	>f1a1	49				                .byte %01001001;$49
11021	>f1a2	76				                .byte %01110110;$76
11022	>f1a3	52				                .byte %01010010;$52
11023	>f1a4	64				                .byte %01100100;$64
11024	>f1a5	40				                .byte %01000000;$40

11027						;-------------------------------------------------------------------------
11028						;
11029						; OSBYTE 19 (&13) Wait for vertical sync [MasRef D.2-26]
11030						;
11031	.f1a6					osbyte13:
11032	.f1a6	ad 40 02	lda $0240	                lda cfsTimeoutCounter
11033	.f1a9					-
11034	.f1a9	58		cli		                cli
11035	.f1aa	78		sei		                sei
11036	.f1ab	cd 40 02	cmp $0240	                cmp cfsTimeoutCounter
11037	.f1ae	f0 f9		beq $f1a9	                beq -

11039						                ; fall through to OSBYTE $a0 (!!)

11041						;-------------------------------------------------------------------------
11042						;
11043						; OSBYTE 160 (&A0) Read VDU variable value [MasRef D.2-49]
11044						;
11045	.f1b0					osbyteA0:
11046	.f1b0	bc 01 03	ldy $0301,x	                ldy vduv+1,x
11047	.f1b3	bd 00 03	lda $0300,x	                lda vduv+0,x
11048	.f1b6	aa		tax		                tax
11049	.f1b7	60		rts		                rts

11051						;-------------------------------------------------------------------------
11052						;
11053						; Reset key auto repeat settings to the defaults set in CMOS.
11054						;
11059	.f1b8					resetKeyRepeat:
11060	.f1b8	20 61 f4	jsr $f461	                jsr withTerminalROM
11062	.f1bb	a2 0c		ldx #$0c	                ldx #CMOSBytes.keyboardAutoRepeatDelay+cmosBytesOffset
11063	.f1bd	20 3a 9e	jsr $9e3a	                jsr readRTCByte
11064	.f1c0	8d 54 02	sta $0254	                sta keyboardAutoRepeatDelay
11065	.f1c3	a2 0d		ldx #$0d	                ldx #CMOSBytes.keyboardAutoRepeatRate+cmosBytesOffset
11066	.f1c5	20 3a 9e	jsr $9e3a	                jsr readRTCByte
11067	.f1c8	a8		tay		                tay
11073	.f1c9	ae 55 02	ldx $0255	                ldx keyboardAutoRepeatRate
11074	.f1cc	8c 55 02	sty $0255	                sty keyboardAutoRepeatRate
11075	.f1cf	60		rts		                rts

11077						;-------------------------------------------------------------------------
11078						;
11079						; OSBYTE 18 (&12) Reset soft keys [MasRef D.2-26]
11080						;
11081						; MasRef says X undefined on exit; in fact, X=0, and scanROMs
11082						; relies on this.
11083						;
11084	.f1d0					osbyte12:
11085	.f1d0	38		sec		                sec
11086	.f1d1	6e 84 02	ror $0284	                ror softKeyConsistencyFlag   ;mark soft keys inconsistent
11087	.f1d4	a5 f4		lda $f4		                lda $F4
11088	.f1d6	48		pha		                pha                          ;push selected paged ROM
11089	.f1d7	20 98 e5	jsr $e598	                jsr selectTerminalROMAndANDY

11091						                ; point each soft key at the 0th byte of the strings -
11092						                ; they all then have length 0.
11093	.f1da	a2 10		ldx #$10	                ldx #softKeyCount
11094	.f1dc					-
11095	.f1dc	a9 22		lda #$22	                lda #<andy.softKeys.strings
11096	.f1de	9d 00 80	sta $8000,x	                sta andy.softKeys.stringLSBs,x
11097	.f1e1	a9 80		lda #$80	                lda #>andy.softKeys.strings
11098	.f1e3	9d 11 80	sta $8011,x	                sta andy.softKeys.stringMSBs,x
11099	.f1e6	ca		dex		                dex
11100	.f1e7	10 f3		bpl $f1dc	                bpl -

11102	.f1e9	68		pla		                pla                 ;pop previously selected paged ROM
11103	.f1ea	20 ab e5	jsr $e5ab	                jsr selectROMA

11105	.f1ed	9c 68 02	stz $0268	                stz softKeyStringLength
11106	.f1f0	9c 84 02	stz $0284	                stz softKeyConsistencyFlag   ;mark soft keys consistent
11107	.f1f3	e8		inx		                inx
11108	.f1f4	60		rts		                rts

11110						;-------------------------------------------------------------------------
11111						;
11112						; OSWORD 11 (&0B) Read the palette [MasRef D.3-20]
11113						;
11114	.f1f5					osword0B:
11115	.f1f5	2d 60 03	and $0360	                and vduv.numberOfLogicalColoursMinusOne
11116	.f1f8	aa		tax		                tax
11117	.f1f9	bd 6f 03	lda $036f,x	                lda vduv.currentPalette,x
11118	.f1fc					LF146:
11119	.f1fc	c8		iny		                iny
11120	.f1fd					LF147:
11121	.f1fd	91 f0		sta ($f0),y	                sta (originalX),y
11122	.f1ff	a9 00		lda #$00	                lda #$00                     ;fill last 3 bytes with 0
11123	.f201	c0 04		cpy #$04	                cpy #$04
11124	.f203	d0 f7		bne $f1fc	                bne LF146
11125	.f205	60		rts		                rts

11127						;-------------------------------------------------------------------------
11128						;
11129						; OSWORD 9 (&09) Read pixel logical colour [MasRef D.3-19]
11130						;
11131	.f206					osword09:                                    ;f150
11132	.f206	20 88 f4	jsr $f488	                jsr withMOSROM               ; sF150= 20 AB F3     +s
11133	.f209	a0 03		ldy #$03	                ldy #$03
11134	.f20b					-
11135	.f20b	b1 f0		lda ($f0),y	                lda (originalX),y
11136	.f20d	99 28 03	sta $0328,y	                sta vduv.workspace._28,y
11137	.f210	b9 10 03	lda $0310,y	                lda $0310,y
11138	.f213	48		pha		                pha
11139	.f214	88		dey		                dey
11140	.f215	10 f4		bpl $f20b	                bpl -
11141	.f217	a9 28		lda #$28	                lda #VDUVariables.workspace._28
11142	.f219	20 b7 dd	jsr $ddb7	                jsr readPixelColour
11143	.f21c	aa		tax		                tax
11144	.f21d	a0 00		ldy #$00	                ldy #$00
11145	.f21f					LF169:
11146	.f21f	68		pla		                pla
11147	.f220	99 10 03	sta $0310,y	                sta $0310,y
11148	.f223	c8		iny		                iny
11149	.f224	c0 04		cpy #$04	                cpy #$04
11150	.f226	d0 f7		bne $f21f	                bne LF169
11151	.f228	8a		txa		                txa
11152	.f229	80 d2		bra $f1fd	                bra LF147

11154	.f22b					osword0A:                                    ;f175
11155	.f22b	20 3c e2	jsr $e23c	                jsr getSoftCharacterDefinitionAddress
11156	.f22e	a0 00		ldy #$00	                ldy #$00
11157	.f230	a5 f4		lda $f4		                lda $F4
11158	.f232	48		pha		                pha
11159	.f233	20 98 e5	jsr $e598	                jsr selectTerminalROMAndANDY
11160	.f236					LF180:
11161	.f236	b1 de		lda ($de),y	                lda ($DE),y
11162	.f238	c8		iny		                iny
11163	.f239	91 f0		sta ($f0),y	                sta ($F0),y
11164	.f23b	c0 08		cpy #$08	                cpy #$08
11165	.f23d	d0 f7		bne $f236	                bne LF180
11166	.f23f	fa		plx		                plx
11167	.f240	4c 9a e5	jmp $e59a	                jmp selectROMX

11169	.f243					osword0C:                                    ;f18d
11170	.f243	20 88 f4	jsr $f488	                jsr withMOSROM
11171	.f246	08		php		                php
11172	.f247	2d 60 03	and $0360	                and $0360
11173	.f24a	aa		tax		                tax
11174	.f24b	c8		iny		                iny
11175	.f24c	b1 f0		lda ($f0),y	                lda ($F0),y
11176	.f24e	4c 39 c6	jmp $c639	                jmp LC639

11178	.f251					osword0D:                                    ;f19b
11179	.f251	20 88 f4	jsr $f488	                jsr withMOSROM
11180	.f254	a9 03		lda #$03	                lda #$03
11181	.f256	20 5b f2	jsr $f25b	                jsr LF1A5
11182	.f259	a9 07		lda #$07	                lda #$07
11183	.f25b					LF1A5:
11184	.f25b	48		pha		                pha
11185	.f25c	20 c6 e2	jsr $e2c6	                jsr LE2B6
11186	.f25f	20 df c4	jsr $c4df	                jsr LC4DF
11187	.f262	a2 03		ldx #$03	                ldx #$03
11188	.f264	68		pla		                pla
11189	.f265	a8		tay		                tay
11190	.f266					LF1B0:
11191	.f266	bd 10 03	lda $0310,x	                lda $0310,x
11192	.f269	91 f0		sta ($f0),y	                sta ($F0),y
11193	.f26b	88		dey		                dey
11194	.f26c	ca		dex		                dex
11195	.f26d	10 f7		bpl $f266	                bpl LF1B0
11196	.f26f	60		rts		                rts

11198						; Read address of bottom of screen/top of user memory
11199						; ===================================================
11200	.f270					osbyte84:                     ;f1ba
11201	.f270	a5 d0		lda $d0		                lda STATE     ; Get VDU status
11202	.f272	89 10		bit #$10	                bit #STATE.isShadowMode ; If shadow screen, jump to return &8000
11203	.f274	d0 18		bne $f28e	                bne LF1D8
11204	.f276					LF1C0:
11205	.f276	ad 55 03	lda $0355	                lda $0355                    ; Get current screen MODE

11207						; Return start of screen for non-shadow MODE in X
11208						; -----------------------------------------------
11209	.f279					LF1C3:
11210	.f279	29 07		and #$07	                and #$07
11211	.f27b	a8		tay		                tay
11212	.f27c	be 78 e1	ldx $e178,y	                ldx screenMODEGroupForMODE,y ; Get screen map for supplied MODE
11213	.f27f	bd 8e e1	lda $e18e,x	                lda startScreenAddressHighByteForScreenMODEGroup,x ; Get address top byte for this screen map
11214	.f282					LF1CC:
11215	.f282	a2 00		ldx #$00	                ldx #$00                     ; Address=&xx00
11216	.f284	a8		tay		                tay
11217	.f285	60		rts		                rts

11219						;-------------------------------------------------------------------------
11220						;
11221						; OSBYTE 133 (&85) Read top of user RAM for given mode [MasRef D.2-41]
11222						;
11223	.f286					osbyte85:
11224	.f286	8a		txa		                txa                          ; If MODE &80+n, return &8000
11225	.f287	30 05		bmi $f28e	                bmi LF1D8
11226	.f289	ae 7f 02	ldx $027f	                ldx shadowRAMState ; If *SHADOW<>0, jump to return non-shadow address
11227	.f28c	d0 eb		bne $f279	                bne LF1C3
11228	.f28e					LF1D8:
11229	.f28e	a9 80		lda #$80	                lda #$80                     ; Return &8000
11230	.f290	80 f0		bra $f282	                bra LF1CC

11232						;-------------------------------------------------------------------------
11233						;
11234						; OSBYTE 135 (&87) Read screen mode and character at text cursor
11235						; position [MasRef D.2-42]
11236						;
11237	.f292					osbyte87: ;F1DC:
11238	.f292	20 88 f4	jsr $f488	                jsr withMOSROM
11239	.f295	4c f8 dd	jmp $ddf8	                jmp readCharacterAtTextCursor

11241						;-------------------------------------------------------------------------
11242						;
11243						; OSBYTE 139 (&8B) Write Filing System options [MasRef D.2-43]
11244						;
11245	.f298					osbyte8B:
11246	.f298	0a		asl a		                asl a

11248						;-------------------------------------------------------------------------
11249						;
11250						; OSBYTE 127 (&7F) Check for end of file on an opened file [MasRef D.2-37]
11251						;
11252	.f299					osbyte7F:
11253	.f299	29 01		and #$01	                and #$01

11255						;-------------------------------------------------------------------------
11256						;
11257						; Call OSFSC. There's no entry point for this.
11258						;
11259	.f29b					callFSCV:
11260	.f29b	6c 1e 02	jmp ($021e)	                jmp (FSCV)

11262						;-------------------------------------------------------------------------
11263						;
11264						; OSWORD 15 (&0F) Write CMOS clock [MasRef D.3-24]
11265						;
11267	.f29e					selectTerminalROMAndOSWORD0F:
11268	.f29e	20 61 f4	jsr $f461	                jsr withTerminalROM       ; Page in ROM 15
11269	.f2a1	4c e3 98	jmp $98e3	                jmp osword0F

11272						;-------------------------------------------------------------------------

11274						; Set TAPE/ROM extended vectors
11275						; =============================
11276	.f2a4					LF1EE:
11277	.f2a4	a2 15		ldx #$15	                ldx #$15
11278	.f2a6					LF1F0:
11279	.f2a6	bd af f2	lda $f2af,x	                lda LF1FA-1,x
11280	.f2a9	9d b9 0d	sta $0db9,x	                sta ExtendedVectorAddress(FILEV)-1,x
11281	.f2ac	ca		dex		                dex
11282	.f2ad	d0 f7		bne $f2a6	                bne LF1F0
11283	.f2af					LF1F9:
11284	.f2af	60		rts		                rts

11286						; TAPE/ROM extended vector values
11287						; -------------------------------
11288	.f2b0					LF1FA:
11289	>f2b0	6e a5				                .word osfileTapeOrROM ; FILEV
11290	>f2b2	0f				                .byte terminalROM
11291	>f2b3	10 a4				                .word osargsTapeOrROM ; ARGSV
11292	>f2b5	0f				                .byte terminalROM
11293	>f2b6	b0 a7				                .word bputTapeOrROM ; BPUTV
11294	>f2b8	0f				                .byte terminalROM
11298	>f2b9	11 a8				                .word bgetTapeOrROM ; BGETV
11300	>f2bb	0f				                .byte terminalROM
11301	>f2bc	33 a8				                .word osgbpbTapeOrROM ; GBPBV
11302	>f2be	0f				                .byte terminalROM
11303	>f2bf	bf a6				                .word osfindTapeOrROM ; FINDV
11304	>f2c1	0f				                .byte terminalROM
11305	>f2c2	73 a4				                .word fscTapeOrROM  ; FSCV
11306	>f2c4	0f				                .byte terminalROM

11308						;-------------------------------------------------------------------------
11309						;
11310						; OSBYTE 109 (&6D) Make temporary Filing System permanent
11311						;
11312						; MasRef D.2-30
11313						;
11314	.f2c5					osbyte6D:;f20f
11315	.f2c5	ae 01 df	ldx $df01	                ldx hazel.activeFS; Copy active FS to current FS
11316	.f2c8	8e 00 df	stx $df00	                stx hazel.currentFS
11317	.f2cb	ad bc 0d	lda $0dbc	                lda ExtendedVectorAddress(FILEV)+2 ; Copy XFILEV ROM to current FS ROM number
11318	.f2ce	8d 03 df	sta $df03	                sta hazel.currentFSROM
11319	.f2d1					rtsF180:
11320	.f2d1	60		rts		                rts

11322						;-------------------------------------------------------------------------
11323						;
11324						; OSBYTE 20 (&14) Restore default font definitions
11325						;
11326						; MasRef D.2-24
11327						;
11329	.f2d2					osbyte14:                       ;f21c
11330	.f2d2	20 61 f4	jsr $f461	                jsr withTerminalROM
11331	.f2d5	4c b9 94	jmp $94b9	                jmp restoreFont32To126

11334						;-------------------------------------------------------------------------
11335						;
11336						; OSBYTE 25 (&19) Restore a group of font definitions
11337						;
11338						; MasRef D.2-28
11339						;
11340	.f2d8					selectTerminalROMAndOSBYTE19:                ;f222
11342	.f2d8	a2 07		ldx #$07	                ldx #romServiceCallUnrecognisedOSBYTE
11343	.f2da	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
11347	.f2dd	f0 0b		beq $f2ea	                beq LF2EB
11349	.f2df	a6 f0		ldx $f0		                ldx originalX
11351	.f2e1	20 61 f4	jsr $f461	                jsr withTerminalROM
11352	.f2e4	4c bd 94	jmp $94bd	                jmp osbyte19

11354						;-------------------------------------------------------------------------

11356						; OSBYTE &16 - Increment ROM polling semaphore
11357						; ========================================
11358	.f2e7					osbyte16:                       ;f228
11359	.f2e7	ee 43 02	inc $0243	                inc romPollingSemaphore
11360	.f2ea					LF2EB:
11361	.f2ea	60		rts		                rts

11363						;-------------------------------------------------------------------------

11365						; OSBYTE &17 - Decrement ROM polling semaphore
11366	.f2eb					osbyte17:                       ;f22c
11367						; ========================================
11368	.f2eb	ce 43 02	dec $0243	                dec romPollingSemaphore
11369	.f2ee	60		rts		                rts

11371						;-------------------------------------------------------------------------

11383						;-------------------------------------------------------------------------

11385						; OSBYTE &76 - Set LEDs to keyboard state
11386						; =======================================
11387	.f2ef					osbyte76:
11388	.f2ef	08		php		                php                          ; Disable IRQs
11389	.f2f0	78		sei		                sei
11390	.f2f1	a9 40		lda #$40	                lda #$40                     ; Turn on LEDs
11391	.f2f3	20 00 f3	jsr $f300	                jsr LF241
11392	.f2f6	30 05		bmi $f2fd	                bmi LF23E                    ; Exit if Escape pending
11393	.f2f8	18		clc		                clc                          ; Call KEYV to read SHIFT and CTRL
11394	.f2f9	b8		clv		                clv
11395	.f2fa	20 9e f7	jsr $f79e	                jsr callKEYV
11396						; Returns A.b7=CTRL, A.b6=SHIFT, MI=CTRL, VS=SHIFT
11397	.f2fd					LF23E:
11398	.f2fd	28		plp		                plp                          ; Restore IRQs
11399	.f2fe	2a		rol a		                rol a                        ; Set Carry from A bit 7 and return
11400	.f2ff	60		rts		                rts
11401						; Returns A.b7=SHIFT, CS=CTRL

11403						; Set keyboard LEDs
11404						; -----------------
11405	.f300					LF241:
11406	.f300	90 09		bcc $f30b	                bcc LF24C                    ; Skip if not called from OSBYTE
11407	.f302	a0 07		ldy #$07	                ldy #$07                     ; Turn ShiftLock LED on
11408	.f304	8c 40 fe	sty $fe40	                sty systemVIA.orb
11409	.f307	88		dey		                dey                          ; Turn CapsLock LED on
11410	.f308	8c 40 fe	sty $fe40	                sty systemVIA.orb
11411	.f30b					LF24C:
11412	.f30b	24 ff		bit $ff		                bit $FF                      ; Test Escape and return
11413	.f30d	60		rts		                rts

11415						;-------------------------------------------------------------------------

11417	.f30e					osbyte9A:
11418	.f30e	8a		txa		                txa
11419	.f30f					setVCONTROL:
11420	.f30f	08		php		                php
11421	.f310	78		sei		                sei
11422	.f311	8d 48 02	sta $0248	                sta vcontrolRegister
11423	.f314	8d 20 fe	sta $fe20	                sta VCONTROL
11424	.f317	ad 53 02	lda $0253	                lda secondFlashColourDuration
11425	.f31a	8d 51 02	sta $0251	                sta flashCounter
11426	.f31d	28		plp		                plp
11427	.f31e	60		rts		                rts

11429						;-------------------------------------------------------------------------
11430						;
11431						; OSBYTE 155 (&9B) Write to video ULA palette register and copy
11432						;
11433	.f31f					osbyte9B:
11434	.f31f	8a		txa		                txa
11435	.f320					writeVPALETTE:
11436	.f320	49 07		eor #$07	                eor #$07
11437	.f322	08		php		                php
11438	.f323	78		sei		                sei
11439	.f324	8d 49 02	sta $0249	                sta vpaletteRegister
11440	.f327	8d 21 fe	sta $fe21	                sta VPALETTE
11441	.f32a	28		plp		                plp
11442	.f32b	60		rts		                rts

11444						;-------------------------------------------------------------------------

11446	.f32c					gsinitForFilenameParsing:
11447	.f32c	18		clc		                clc

11450						;-------------------------------------------------------------------------
11451						;
11452						; GSINIT
11453						;
11454						; MasRef D.10-1
11455						;
11456	.f32d					gsinitEntryPoint:
11457	.f32d	66 e4		ror $e4		                ror stringInputOptions    ;put C into bit 7
11458	.f32f	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
11459	.f332	c8		iny		                iny
11460	.f333	c9 22		cmp #$22	                cmp #'"'
11461	.f335	f0 02		beq $f339	                beq +                       ; C=1 if double quotes
11462	.f337	88		dey		                dey
11463	.f338	18		clc		                clc                         ; clear double quotes flag
11464	.f339					+
11465	.f339	66 e4		ror $e4		                ror stringInputOptions ; set doubleQuotes; move bit 7 into spaceNotATerminator
11466	.f33b	c9 0d		cmp #$0d	                cmp #$0D                     ; set Z if initial CR
11467	.f33d	60		rts		                rts

11469						;-------------------------------------------------------------------------
11470						;
11471						; GSREAD
11472						;
11473						; MasRef D.10-2
11474						; MasRef C.5-8 has the | syntax
11475						;
11476	.f33e					gsreadEntryPoint:
11477	.f33e	a9 01		lda #$01	                lda #stringInputOptions.goodString
11478	.f340	04 e4		tsb $e4		                tsb stringInputOptions
11479	.f342	20 5b f3	jsr $f35b	                jsr LF29C
11480	.f345	08		php		                php                          ; save flags
11481	.f346	46 e4		lsr $e4		                lsr stringInputOptions       ; move goodString into C
11482	.f348	90 04		bcc $f34e	                bcc badStringError           ; branch taken if bad string
11483	.f34a	26 e4		rol $e4		                rol stringInputOptions       ; reinstate goodString
11484	.f34c	28		plp		                plp                          ; restore flags
11485	.f34d	60		rts		                rts                          ;

11487	.f34e					badStringError:
11488	.f34e	00		brk #		                brk                          ;
11489	>f34f	fd 42 61 64 20 73 74 72		                .text $fd,"Bad string",0
	>f357	69 6e 67 00
11490	.f35b					LF29C:
11491	.f35b	18		clc		                clc                          ; last char not !
11492	.f35c					LF29D:
11493						                ; C=1 at this point if |! was the last sequence seen.
11494	.f35c	64 e5		stz $e5		                stz stringInputPlingFlag
11495	.f35e	66 e5		ror $e5		                ror stringInputPlingFlag     ; set ! flag as required
11496	.f360	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11497	.f362	c9 0d		cmp #$0d	                cmp #13                      ;EOL?
11498	.f364	d0 09		bne $f36f	                bne notRETURN                ;taken if not EOL
11499	.f366	24 e4		bit $e4		                bit stringInputOptions
11500	.f368	10 20		bpl $f38a	                bpl finishedString           ;taken if !doubleQuotes
11501	.f36a					badString:
11502	.f36a	a9 01		lda #$01	                lda #stringInputOptions.goodString
11503	.f36c	14 e4		trb $e4		                trb stringInputOptions
11504	.f36e	60		rts		                rts

11506	.f36f					notRETURN:
11507	.f36f	c9 20		cmp #$20	                cmp #' '
11508	.f371	90 f7		bcc $f36a	                bcc badString ;taken if unprintable control char
11509	.f373	d0 06		bne $f37b	                bne notSPACE
11510	.f375	24 e4		bit $e4		                bit stringInputOptions ;N=doubleQuotes, V=spaceNotATerminator
11511	.f377	30 3e		bmi $f3b7	                bmi finishUpReadClearV ;taken if quoted
11512	.f379	50 0f		bvc $f38a	                bvc finishedString ;taken if space is a terminator
11513	.f37b					notSPACE:
11514	.f37b	c9 22		cmp #$22	                cmp #'"'
11515	.f37d	d0 10		bne $f38f	                bne notDOUBLEQUOTE         ;taken if not quotes
11516	.f37f	24 e4		bit $e4		                bit stringInputOptions ;N=doubleQuotes, V=spaceNotATerminator
11517	.f381	10 34		bpl $f3b7	                bpl finishUpReadClearV ;taken if not double quotes
11518	.f383	c8		iny		                iny
11519	.f384	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11520	.f386	c9 22		cmp #$22	                cmp #'"'
11521	.f388	f0 2d		beq $f3b7	                beq finishUpReadClearV       ;taken if quotes
11522	.f38a					finishedString:
11523	.f38a	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
11524	.f38d	38		sec		                sec
11525	.f38e	60		rts		                rts

11527	.f38f					notDOUBLEQUOTE:
11528	.f38f	c9 7c		cmp #$7c	                cmp #'|'
11529	.f391	d0 24		bne $f3b7	                bne finishUpReadClearV       ;taken if not |
11530	.f393	c8		iny		                iny                          ;skip |
11531	.f394	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11532	.f396	c9 7c		cmp #$7c	                cmp #'|'
11533	.f398	f0 1d		beq $f3b7	                beq finishUpReadClearV ;branch taken if "||" - literal |
11534	.f39a	c9 22		cmp #$22	                cmp #'"'
11535	.f39c	f0 19		beq $f3b7	                beq finishUpReadClearV ;branch taken if "|\"" - literal "
11536	.f39e	c9 21		cmp #$21	                cmp #'!'
11537	.f3a0	d0 03		bne $f3a5	                bne LF2E6                    ;taken if not "|!"

11539						                ; Handle |! - ASCII 128-255
11540	.f3a2	c8		iny		                iny                          ;skip !
11541	.f3a3	80 b7		bra $f35c	                bra LF29D

11543	.f3a5					LF2E6:
11544	.f3a5	c9 20		cmp #$20	                cmp #' '
11545	.f3a7	90 c1		bcc $f36a	                bcc badString ;taken if | followed by a non-printable char
11546	.f3a9	c9 3f		cmp #$3f	                cmp #'?'
11547	.f3ab	f0 08		beq $f3b5	                beq ascii127                 ;taken if "|?" - CHR$127
11548	.f3ad	20 fc f3	jsr $f3fc	                jsr implementCTRLCodes
11549	.f3b0	2c 70 e3	bit $e370	                bit valueFF
11550	.f3b3	80 03		bra $f3b8	                bra LF2F9

11552	.f3b5					ascii127:
11553	.f3b5	a9 7f		lda #$7f	                lda #$7F
11554	.f3b7					finishUpReadClearV:
11555	.f3b7	b8		clv		                clv
11556	.f3b8					LF2F9:
11557	.f3b8	c8		iny		                iny
11558	.f3b9	05 e5		ora $e5		                ora stringInputPlingFlag ;if it was a |! char, set bit 7
11559	.f3bb	18		clc		                clc
11560	.f3bc	60		rts		                rts

11562						;-------------------------------------------------------------------------

11564	.f3bd					incAndSkipSpaces:
11565	.f3bd	c8		iny		                iny
11566	.f3be					skipSpacesAndCheckForCRInStringInput:
11567	.f3be	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
11568	.f3c0	c9 20		cmp #$20	                cmp #' '
11569	.f3c2	f0 f9		beq $f3bd	                beq incAndSkipSpaces
11570	.f3c4					checkForCR:
11571	.f3c4	c9 0d		cmp #$0d	                cmp #13
11572	.f3c6	60		rts		                rts

11574						;-------------------------------------------------------------------------

11576	.f3c7					LF308:
11577	.f3c7	90 f5		bcc $f3be	                bcc skipSpacesAndCheckForCRInStringInput
11578	.f3c9					LF30A:
11579	.f3c9	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
11580	.f3cc	c9 2c		cmp #$2c	                cmp #','
11581	.f3ce	d0 f4		bne $f3c4	                bne checkForCR
11582	.f3d0	c8		iny		                iny
11583	.f3d1	60		rts		                rts

11585						;-------------------------------------------------------------------------

11678						;-------------------------------------------------------------------------
11679						;
11680						; Modify character in A as if the SHIFT key is being pressed.
11681						;

11683	.f3d2					implementShift:

11712	.f3d2	a2 02		ldx #$02	                ldx #2
11713	.f3d4	50 00		bvc $f3d6	                bvc LF3C5
11714	.f3d6					LF3C5:
11715	.f3d6	dd f7 f3	cmp $f3f7,x	                cmp LF3E7-1,x
11716	.f3d9	f0 18		beq $f3f3	                beq LF3E2
11717	.f3db	ca		dex		                dex
11718	.f3dc	d0 f8		bne $f3d6	                bne LF3C5
11719	.f3de	50 12		bvc $f3f2	                bvc LF3E1
11720	.f3e0	c9 21		cmp #$21	                cmp #'!'
11721	.f3e2	90 0e		bcc $f3f2	                bcc LF3E1
11722	.f3e4	c9 40		cmp #$40	                cmp #'@'
11726	.f3e6	90 08		bcc $f3f0	                bcc LF3DF
11727	.f3e8	c9 7f		cmp #$7f	                cmp #$7f
11728	.f3ea	f0 06		beq $f3f2	                beq LF3E1
11729	.f3ec	b0 02		bcs $f3f0	                bcs LF3DF

11731	.f3ee					LF3DD:
11732	.f3ee	49 30		eor #$30	                eor #$30
11733	.f3f0					LF3DF:
11734	.f3f0	49 10		eor #$10	                eor #$10
11735	.f3f2					LF3E1:
11736	.f3f2	60		rts		                rts

11738	.f3f3					LF3E2:
11739	.f3f3	b8		clv		                clv
11740	.f3f4	bd f9 f3	lda $f3f9,x	                lda LF3E9-1,x
11741	.f3f7	60		rts		                rts

11743	.f3f8					LF3E7:
11744	>f3f8	5f				                .byte '_'
11745	>f3f9	30				                .byte '0'
11746	.f3fa					LF3E9:
11747	>f3fa	60				                .byte '`'
11751	>f3fb	40				                .byte '@'

11756						;-------------------------------------------------------------------------
11757						;
11758						; See MasRef C.5-8
11759						;
11760						;
11761	.f3fc					implementCTRLCodes:

11779	.f3fc	da		phx		                phx
11780	.f3fd	a2 02		ldx #$02	                ldx #2
11781	.f3ff					LF3EE:
11782	.f3ff	dd 1a f4	cmp $f41a,x	                cmp LF40A-1,x
11783	.f402	f0 11		beq $f415	                beq LF404
11784	.f404	ca		dex		                dex
11785	.f405	d0 f8		bne $f3ff	                bne LF3EE
11786	.f407	fa		plx		                plx
11787	.f408	c9 3f		cmp #$3f	                cmp #'?'
11788	.f40a	90 08		bcc $f414	                bcc LF403
11789	.f40c	c9 7f		cmp #$7f	                cmp #$7f
11790	.f40e	f0 04		beq $f414	                beq LF403
11791	.f410	b0 dc		bcs $f3ee	                bcs LF3DD
11792	.f412	29 1f		and #$1f	                and #$1f
11793	.f414					LF403:
11794	.f414	60		rts		                rts

11796	.f415					LF404:
11797	.f415	b8		clv		                clv
11798	.f416	bd 1c f4	lda $f41c,x	                lda LF40C-1,x
11799	.f419	fa		plx		                plx
11800	.f41a	60		rts		                rts

11802	.f41b					LF40A:
11803	>f41b	30 40				                .text '0','@'
11804	.f41d					LF40C:
11805	>f41d	00 00				                .text 0,0

11809						;-------------------------------------------------------------------------

11815	.f41f					osbyte247EntryPoint:
11816	.f41f	ad 87 02	lda $0287	                lda breakVectorByte0
11817	.f422	49 4c		eor #$4c	                eor #$4C                     ; JMP abs
11818	.f424	d0 1a		bne $f440	                bne rtsF363
11825	.f426	a5 f4		lda $f4		                lda $f4
11826	.f428	48		pha		                pha
11827	.f429	20 87 02	jsr $0287	                jsr breakVectorByte0
11828	.f42c	68		pla		                pla
11829	.f42d	85 f4		sta $f4		                sta $f4
11830	.f42f	60		rts		                rts

11833						;-------------------------------------------------------------------------
11834						;
11835						; OSBYTE 144 (&90)
11836						; Set vertical screen shift and interlace
11837						;
11838						; MasRef D.2-44
11839						;
11840	.f430					osbyte90:
11841	.f430	ad 90 02	lda $0290	                lda tvOffset
11842	.f433	8e 90 02	stx $0290	                stx tvOffset
11843	.f436	aa		tax		                tax
11844	.f437	98		tya		                tya
11845	.f438	29 01		and #$01	                and #$01
11846	.f43a	ac 91 02	ldy $0291	                ldy tvInterlace
11847	.f43d	8d 91 02	sta $0291	                sta tvInterlace
11848	.f440					rtsF363:
11849	.f440	60		rts		                rts

11851						;-------------------------------------------------------------------------
11852						;
11853						; OSBYTE 149 (&95) - write to JIM
11854						;
11855						; MasRef D.2-45
11856						;
11857	.f441					osbyte95:
11858	.f441	98		tya		                tya
11859	.f442	9d 00 fd	sta $fd00,x	                sta $FD00,x
11860	.f445	60		rts		                rts

11862						;-------------------------------------------------------------------------
11863						;
11864						; OSBYTE 151 (&97) - write to SHEILA
11865						;
11866						; MasRef D.2-45
11867						;
11868	.f446					osbyte97:
11869	.f446	98		tya		                tya
11870	.f447	9d 00 fe	sta $fe00,x	                sta $FE00,x
11871	.f44a	60		rts		                rts

11873						;-------------------------------------------------------------------------
11874						;
11875						; OSBYTE 147 (&93) - write to FRED
11876						;
11877						; MasRef D.2-45
11878						;
11879	.f44b					osbyte93:
11880	.f44b	98		tya		                tya
11881	.f44c	9d 00 fc	sta $fc00,x	                sta $FC00,x
11882	.f44f	60		rts		                rts

11884						;-------------------------------------------------------------------------
11885						;
11886						; *SHUT [MasRef G.5-10]
11887						;
11888	.f450					starSHUT:
11889	.f450	a2 26		ldx #$26	                ldx #romServiceCallCloseAllOpenFiles
11890	.f452	4c ff ee	jmp $eeff	                jmp makeROMServiceCall

11892						;-------------------------------------------------------------------------
11893						;
11894						; Return thunk used by withTerminalROM.
11895						;
11896						; On entry here, the old value of $f4 is at the top of the stack.
11897						;
11898	.f455					withTerminalROMReturnThunk:
11899	.f455	08		php		                php                          ; S=[p; old ROMSEL]
11900	.f456	48		pha		                pha                          ; S=[a; p; old ROMSEL]
11901	.f457	da		phx		                phx                          ; S=[x; a; p; old ROMSEL]
11902	.f458	ba		tsx		                tsx
11903	.f459	bd 04 01	lda $0104,x	                lda $0104,x                  ; get old ROMSEL
11904	.f45c	20 ab e5	jsr $e5ab	                jsr selectROMA               ; re-select old ROM
11905	.f45f	80 5d		bra $f4be	                bra returnThunkSuffix

11907						;-------------------------------------------------------------------------
11908						;
11909						; Select the Terminal ROM. Rearrange the stack so that the original
11910						; ROM is re-selected when withTerminalROM's caller itself returns.
11911						;
11912	.f461					withTerminalROM:
11922	.f461	48		pha		                pha                          ; S=[A]
11923	.f462	48		pha		                pha                          ; S=[A; A]
11924	.f463	48		pha		                pha                          ; S=[A; A; A]
11925	.f464	08		php		                php                          ; S=[P; A; A; A]
11926	.f465	48		pha		                pha                          ; S=[A; P; A; A; A]
11927	.f466	da		phx		                phx                          ; S=[X; A; P; A; A; A]
11928	.f467	ba		tsx		                tsx                          ; S=[X; A; P; A; A; A; RL; RH]
11929	.f468	bd 07 01	lda $0107,x	                lda $0107,x                  ; get RL
11930	.f46b	9d 04 01	sta $0104,x	                sta $0104,x                  ; overwrite placeholder A
11931	.f46e	bd 08 01	lda $0108,x	                lda $0108,x                  ; get RH
11932	.f471	9d 05 01	sta $0105,x	                sta $0105,x                  ; overwrite placeholder A
11933	.f474	a5 f4		lda $f4		                lda $F4                      ; get ROMSEL
11934	.f476	9d 08 01	sta $0108,x	                sta $0108,x                  ; overwrite RH

11936						                ; put return thunk in the right spot
11937	.f479	a9 f4		lda #$f4	                lda #>withTerminalROMReturnThunk-1
11938	.f47b	9d 07 01	sta $0107,x	                sta $0107,x
11939	.f47e	a9 54		lda #$54	                lda #<withTerminalROMReturnThunk-1
11940	.f480	9d 06 01	sta $0106,x	                sta $0106,x
11942	.f483	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM
11943	.f486	80 28		bra $f4b0	                bra plx_pla_plp_rts

11945						;-------------------------------------------------------------------------
11946						;
11947						; Select the MOS ROM (i.e., no HAZEL). Rearrange the stack so that the
11948						; original HAZEL state is restored when withMOSROM's caller itself
11949						; returns.
11950						;
11951	.f488					withMOSROM:
11962	.f488	48		pha		                pha                          ; S=[A]
11963	.f489	48		pha		                pha                          ; S=[A; A]
11964	.f48a	48		pha		                pha                          ; S=[A; A; A]
11965	.f48b	08		php		                php                          ; S=[P; A; A; A]
11966	.f48c	48		pha		                pha                          ; S=[A; P; A; A; A]
11967	.f48d	da		phx		                phx                          ; S=[X; A; P; A; A; A]
11968	.f48e	ba		tsx		                tsx                          ; S=[X; A; P; A; A; A; RL; RH]
11969	.f48f	bd 08 01	lda $0108,x	                lda $0108,x                  ; get RH
11970	.f492	9d 05 01	sta $0105,x	                sta $0105,x                  ; overwrite placeholder A
11971	.f495	bd 07 01	lda $0107,x	                lda $0107,x                  ; get RL
11972	.f498	9d 04 01	sta $0104,x	                sta $0104,x                  ; overwrite placeholder A

11974						                ; put return thunk in the right spot
11975	.f49b	a9 f4		lda #$f4	                lda #>withMOSROMReturnThunk-1
11976	.f49d	9d 07 01	sta $0107,x	                sta $0107,x
11977	.f4a0	a9 b3		lda #$b3	                lda #<withMOSROMReturnThunk-1
11978	.f4a2	9d 06 01	sta $0106,x	                sta $0106,x

11980	.f4a5	ad 34 fe	lda $fe34	                lda ACCCON                   ; get ACCCON
11981	.f4a8	9d 08 01	sta $0108,x	                sta $0108,x                  ; overwrite RH
11982	.f4ab	a9 08		lda #$08	                lda #ACCCON.Y
11983	.f4ad	1c 34 fe	trb $fe34	                trb ACCCON
11984						                ; HAZEL off
11986	.f4b0					plx_pla_plp_rts:
11987						                ; S=[X; A; P; RL; RH; thunkRL; thunkRH; old ACCCON/ROMSEL]
11988	.f4b0	fa		plx		                plx
11989	.f4b1	68		pla		                pla
11990	.f4b2	28		plp		                plp
11991	.f4b3	60		rts		                rts

11993	.f4b4					withMOSROMReturnThunk:
11994	.f4b4	08		php		                php                          ; S=[P]
11995	.f4b5	48		pha		                pha                          ; S=[A; P]
11996	.f4b6	da		phx		                phx                          ; S=[X; A; P]
11997	.f4b7	ba		tsx		                tsx                          ; S=[X; A; P; old ACCCON]
11998	.f4b8	bd 04 01	lda $0104,x	                lda $0104,x                  ; get old ACCCON
11999	.f4bb	20 3d ee	jsr $ee3d	                jsr selectMOSOrHAZEL         ; re-select old HAZEL state
12000	.f4be					returnThunkSuffix:
12001						                ; double up P, as that's the easiest way of ending up
12002						                ; discarding the TOS without affecting the flags.
12003	.f4be	bd 03 01	lda $0103,x	                lda $0103,x
12004	.f4c1	9d 04 01	sta $0104,x	                sta $0104,x
12005	.f4c4	fa		plx		                plx
12006	.f4c5	68		pla		                pla
12007	.f4c6	28		plp		                plp
12008	.f4c7	28		plp		                plp
12009	.f4c8	60		rts		                rts

12011						;-------------------------------------------------------------------------
12012						;
12013						; Clear ACCCON TST bit (paging in I/O for reads, rather than ROM, at
12014						; $fc00...$feff), and restore it on exit from the current routine.
12015						;

12041						;-------------------------------------------------------------------------
12042						;
12043						; Sort out stack for one of the withXXX routines, that set up some
12044						; state and then automatically restore the original state on exit from
12045						; the calling routine.
12046						;

12066						;-------------------------------------------------------------------------

12068	.f4c9					vduChrEntryPoint:
12069	.f4c9	20 88 f4	jsr $f488	                jsr withMOSROM
12070	.f4cc	a6 f4		ldx $f4		                ldx $F4
12071	.f4ce	da		phx		                phx
12072	.f4cf	20 98 e5	jsr $e598	                jsr selectTerminalROMAndANDY
12073	.f4d2	20 27 c0	jsr $c027	                jsr outputToVDU
12074	.f4d5	fa		plx		                plx
12075	.f4d6	4c 9a e5	jmp $e59a	                jmp selectROMX

12077						;-------------------------------------------------------------------------
12078						;
12079						; OSRDSC [MasRef D.6-1]
12080						;
12081	.f4d9					osrdscEntryPoint:
12082	.f4d9	20 88 f4	jsr $f488	                jsr withMOSROM
12083	.f4dc	4c 18 c0	jmp $c018	                jmp LC018

12085						;-------------------------------------------------------------------------
12086						;
12087						; OSWRSC [MasRef D.8-1]
12088						;
12089	.f4df					oswrscEntryPoint:
12090	.f4df	20 88 f4	jsr $f488	                jsr withMOSROM
12091	.f4e2	4c 5f db	jmp $db5f	                jmp oswrscCode

12093						;-------------------------------------------------------------------------

12095	.f4e5					starRunBOOT:
12096	>f4e5	2f 21 42 4f 4f 54 0d		                .text "/!BOOT",13

12098						;-------------------------------------------------------------------------

12104						;-------------------------------------------------------------------------

12108	.f4ec					LF416:
12109	.f4ec	a5 f4		lda $f4		                lda $f4
12110	.f4ee	48		pha		                pha
12111	.f4ef	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM
12112	.f4f2	20 c7 9f	jsr $9fc7	                jsr LF416Internal
12113	.f4f5	fa		plx		                plx
12114	.f4f6	4c 9a e5	jmp $e59a	                jmp selectROMX

12116	.f4f9					clearSoundChannelBuffer:
12117	.f4f9	da		phx		                phx
12118	.f4fa	a5 f4		lda $f4		                lda $f4
12119	.f4fc	48		pha		                pha
12120	.f4fd	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM
12121	.f500	20 0e a1	jsr $a10e	                jsr clearSoundChannelBufferInternal
12122	.f503	fa		plx		                plx
12123	.f504	20 9a e5	jsr $e59a	                jsr selectROMX
12124	.f507	fa		plx		                plx
12125	.f508	60		rts		                rts

12129						;-------------------------------------------------------------------------

12139						;-------------------------------------------------------------------------

12151						;-------------------------------------------------------------------------

12160						;-------------------------------------------------------------------------

12162	.f509					LF6FC:
12163	.f509	a9 ff		lda #$ff	                lda #$FF
12164	.f50b	85 f5		sta $f5		                sta $F5
12165	.f50d	60		rts		                rts

12167	.f50e					LF701:
12168	.f50e	e6 f5		inc $f5		                inc $F5
12169	.f510	a4 f5		ldy $f5		                ldy $F5
12170	.f512	a2 0d		ldx #$0d	                ldx #romServiceCallROMFilingSystemInitialize
12171	.f514					LF707:
12172	.f514	08		php		                php
12173	.f515	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
12174	.f518	28		plp		                plp
12175	.f519	c9 01		cmp #$01	                cmp #$01
12176	.f51b	98		tya		                tya
12177	.f51c	60		rts		                rts

12179	.f51d					LF710:
12180	.f51d	a2 0e		ldx #$0e	                ldx #$0E
12181	.f51f	a0 ff		ldy #$ff	                ldy #$FF
12182	.f521	4c 14 f5	jmp $f514	                jmp LF707

12184	.f524					LF717:
12185	.f524	ad cb 03	lda $03cb	                lda $03CB
12186	.f527	85 f6		sta $f6		                sta $F6
12187	.f529	ad cc 03	lda $03cc	                lda $03CC
12188	.f52c	85 f7		sta $f7		                sta $F7
12189	.f52e	a5 f5		lda $f5		                lda $F5
12190	.f530	60		rts		                rts

12192	.f531					tidyUpAfterKeyboardProcessing:
12193	.f531	a2 ff		ldx #$ff	                ldx #$FF
12194	.f533	a5 ec		lda $ec		                lda lastKeyPressedInternal
12195	.f535	05 ed		ora $ed		                ora firstKeyPressedInternal
12196	.f537	d0 06		bne $f53f	                bne +                    ;taken if any keys pressed
12197	.f539	a9 81		lda #$81	                lda #$81
12198	.f53b	8d 4e fe	sta $fe4e	                sta systemVIA.ier            ;re-enable keyboard IRQ
12199	.f53e	e8		inx		                inx                          ;X=0
12200	.f53f					+
12201	.f53f	8e 42 02	stx $0242	                stx keyboardSemaphore
12202	.f542					updateKeyboardLEDs:
12203	.f542	08		php		                php
12204	.f543	ad 5a 02	lda $025a	                lda keyboardStatusByte
12205	.f546	4a		lsr a		                lsr a

12207						                ; bit 3 = caps lock off
12208						                ; bit 4 = shift lock off
12209	.f547	29 18		and #$18	                and #(keyboardStatusByte.capsLockDisengaged|keyboardStatusByte.shiftLockDisengaged)>>1
12210	.f549	09 06		ora #$06	                ora #$06                     ;latch B6 - caps lock
12211	.f54b	8d 40 fe	sta $fe40	                sta systemVIA.orb            ;update caps lock LED
12212	.f54e	4a		lsr a		                lsr a                        ;bit 3 = shift lock off
12213	.f54f	09 07		ora #$07	                ora #$07                     ;latch B7 - shift lock
12214	.f551	8d 40 fe	sta $fe40	                sta systemVIA.orb            ;update shift lock LED
12215	.f554	20 b8 f7	jsr $f7b8	                jsr enableKeyboardScanning
12216	.f557	68		pla		                pla
12217	.f558	60		rts		                rts

12219						; KEYV handler
12220						; ============
12221	.f559					keyEntryPoint:
12222	.f559	50 0a		bvc $f565	                bvc keyVClear
12223	.f55b	a9 01		lda #$01	                lda #$01
12224	.f55d	8d 4e fe	sta $fe4e	                sta systemVIA.ier
12225	.f560	b0 08		bcs $f56a	                bcs keyboardTimerInterrupt
12226	.f562	4c 01 f7	jmp $f701	                jmp keyPressedInterrupt

12228	.f565					keyVClear:
12229	.f565	90 06		bcc $f56d	                bcc keyTestSHIFTAndCTRLOrTimerInterrupt
12230	.f567	4c b2 f7	jmp $f7b2	                jmp scanKeyboard

12232	.f56a					keyboardTimerInterrupt:
12233	.f56a	ee 42 02	inc $0242	                inc keyboardSemaphore

12235						;-------------------------------------------------------------------------
12236						;
12237						; Test Shift & Ctrl keys, or deal with timer interrupt.
12238						;
12239						; Entry: C=0 if KEYV V=0 C=0 - test SHIFT+CTRL keys
12240						;        C=1 if KEYV V=1 C=1 - keyboard timer interrupt
12241						;
12242	.f56d					keyTestSHIFTAndCTRLOrTimerInterrupt:
12243	.f56d	ad 5a 02	lda $025a	                lda keyboardStatusByte
12244	.f570	29 b7		and #$b7	                and #~(keyboardStatusByte.shiftPressed|keyboardStatusByte.ctrlPressed)
12245	.f572	a2 00		ldx #$00	                ldx #key_shift
12246	.f574	20 1c f7	jsr $f71c	                jsr interrogateKeyboard      ;X=$80 if SHIFT pressed
12247	.f577	90 02		bcc $f57b	                bcc +                        ;taken if testing
12248						                                             ;SHIFT+CTRL only
12249	.f579	86 fa		stx $fa		                stx SEIWKA                   ;b7 set if SHIFT pressed
12250	.f57b					+
12251	.f57b	b8		clv		                clv                        ;V=0
12252	.f57c	10 05		bpl $f583	                bpl testCTRL               ;taken if SHIFT not pressed
12253	.f57e	2c 70 e3	bit $e370	                bit valueFF                ;V=1 N=1
12254	.f581	09 08		ora #$08	                ora #keyboardStatusByte.shiftPressed
12255	.f583					testCTRL:
12256	.f583	e8		inx		                inx                          ;X=1 - key_ctrl
12257	.f584	20 1c f7	jsr $f71c	                jsr interrogateKeyboard
12258	.f587	90 b9		bcc $f542	                bcc updateKeyboardLEDs ;taken if testing SHIFT+CTRL only
12259	.f589	10 02		bpl $f58d	                bpl updateKeyboardStatusByte ;taken if CTRL not pressed
12260	.f58b	09 40		ora #$40	                ora #keyboardStatusByte.ctrlPressed
12261	.f58d					updateKeyboardStatusByte:
12262	.f58d	8d 5a 02	sta $025a	                sta keyboardStatusByte
12263	.f590	a6 ec		ldx $ec		                ldx lastKeyPressedInternal
12264	.f592	f0 4d		beq $f5e1	                beq braRolloverChecks        ;taken if no key pressed
12265	.f594	20 1c f7	jsr $f71c	                jsr interrogateKeyboard      ;still pressed?
12266	.f597	30 0d		bmi $f5a6	                bmi checkForKeyAutoRepeat    ;taken if still pressed
12267	.f599	e4 ec		cpx $ec		                cpx lastKeyPressedInternal   ;X=0 at this point
12268	.f59b					storeLastKeyPressed:
12269	.f59b	86 ec		stx $ec		                stx lastKeyPressedInternal   ;update last key pressed
12270	.f59d	d0 42		bne $f5e1	                bne braRolloverChecks  ;taken if still nothing pressed
12271	.f59f	64 ec		stz $ec		                stz lastKeyPressedInternal   ;reset last key pressed
12272	.f5a1					resetAutoRepeatAndContinue:
12273	.f5a1	20 11 f7	jsr $f711	                jsr resetAutoRepeatCounters
12274	.f5a4	80 3b		bra $f5e1	                bra braRolloverChecks

12276	.f5a6					checkForKeyAutoRepeat:
12277	.f5a6	e4 ec		cpx $ec		                cpx lastKeyPressedInternal
12278	.f5a8	d0 f1		bne $f59b	                bne storeLastKeyPressed      ;taken if new key pressed
12279	.f5aa	a5 e7		lda $e7		                lda autoRepeatCountdownTimer
12280	.f5ac	f0 33		beq $f5e1	                beq braRolloverChecks      ;taken if countdown timer 0
12281	.f5ae	c6 e7		dec $e7		                dec autoRepeatCountdownTimer ;timer--
12282	.f5b0	d0 2f		bne $f5e1	                bne braRolloverChecks        ;taken if timer newly 0
12283	.f5b2	ad ca 02	lda $02ca	                lda keyboardFirstAutoRepeatCount
12284	.f5b5	85 e7		sta $e7		                sta autoRepeatCountdownTimer
12285	.f5b7	ad 55 02	lda $0255	                lda keyboardAutoRepeatRate
12286	.f5ba	8d ca 02	sta $02ca	                sta keyboardFirstAutoRepeatCount
12287	.f5bd	ad 5a 02	lda $025a	                lda keyboardStatusByte
12288	.f5c0	a6 ec		ldx $ec		                ldx lastKeyPressedInternal
12289	.f5c2	e0 d0		cpx #$d0	                cpx #$80|key_shift_lock
12290	.f5c4	f0 12		beq $f5d8	                beq shiftLockPressed
12291	.f5c6	e0 c0		cpx #$c0	                cpx #$80|key_caps_lock
12293	.f5c8	d0 1a		bne $f5e4	                bne LF5E5_511
12297	.f5ca					capsLockPressed:
12298	.f5ca	09 a0		ora #$a0	                ora #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
12299	.f5cc	24 fa		bit $fa		                bit SEIWKA                   ;test SHIFT status
12300	.f5ce	10 04		bpl $f5d4	                bpl +                        ;taken if SHIFT not pressed
12301						                ; Do the SHIFT+CAPS LOCK thing
12302	.f5d0	09 10		ora #$10	                ora #keyboardStatusByte.capsLockDisengaged
12303	.f5d2	49 80		eor #$80	                eor #keyboardStatusByte.shiftEnabled
12304	.f5d4					+
12305	.f5d4	49 90		eor #$90	                eor #keyboardStatusByte.shiftEnabled|keyboardStatusByte.capsLockDisengaged
12306	.f5d6	80 04		bra $f5dc	                bra resetKeyboardStatusAndTimer

12308	.f5d8					shiftLockPressed:
12309	.f5d8	09 90		ora #$90	                ora #keyboardStatusByte.shiftEnabled|keyboardStatusByte.capsLockDisengaged
12310	.f5da	49 a0		eor #$a0	                eor #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
12311	.f5dc					resetKeyboardStatusAndTimer:
12312	.f5dc	8d 5a 02	sta $025a	                sta keyboardStatusByte
12313	.f5df	64 e7		stz $e7		                stz autoRepeatCountdownTimer
12314	.f5e1					braRolloverChecks:
12318	.f5e1	4c e1 f6	jmp $f6e1	                jmp keyboardRolloverChecks

12321						;-------------------------------------------------------------------------

12324	.f5e4					LF5E5_511:
12325	.f5e4	2c 3d 02	bit $023d	                bit keyboardTranslationTableAddress+1
12326	.f5e7	30 1e		bmi $f607	                bmi getASCIICode
12327	.f5e9	da		phx		                phx
12328	.f5ea	da		phx		                phx
12329	.f5eb	7a		ply		                ply
12330	.f5ec	a2 30		ldx #$30	                ldx #romServiceCall30
12331	.f5ee	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
12332	.f5f1	d0 13		bne $f606	                bne LF607
12333	.f5f3	fa		plx		                plx
12334	.f5f4	98		tya		                tya
12335	.f5f5	6a		ror a		                ror a
12336	.f5f6	6a		ror a		                ror a
12337	.f5f7	90 02		bcc $f5fb	                bcc LF5FC
12338	.f5f9	64 e7		stz $e7		                stz autoRepeatCountdownTimer
12339	.f5fb					LF5FC:
12340	.f5fb	30 e4		bmi $f5e1	                bmi braRolloverChecks
12341	.f5fd	ad 3c 02	lda $023c	                lda keyboardTranslationTableAddress+0
12342	.f600	2c 3d 02	bit $023d	                bit keyboardTranslationTableAddress+1
12346	.f603	4c cb f6	jmp $f6cb	                jmp LF6A8

12349	.f606					LF607:
12350	.f606	fa		plx		                plx
12352						;-------------------------------------------------------------------------
12353						;
12354						; Convert internal key number (with bit 7 set) to ASCII code, taking
12355						; into account state of CTRL, SHIFT, CAPS LOCK and SHIFT LOCK.
12356						;
12357	.f607					getASCIICode:
12358						                ; -$80 to adjust for bit 7 set; -16 because
12359						                ; interesting keys start at 16
12360	.f607	bd 9e f6	lda $f69e,x	                lda keyTranslationTable-$80-16,x
12362	.f60a	ae 7d 02	ldx $027d	                ldx editKeysMode
12363	.f60d	e0 03		cpx #$03	                cpx #3
12364	.f60f	d0 08		bne $f619	                bne LF5E5
12365	.f611	c9 8b		cmp #$8b	                cmp #$8b
12366	.f613	90 04		bcc $f619	                bcc LF5E5
12367	.f615	c9 90		cmp #$90	                cmp #$90
12368	.f617	90 c8		bcc $f5e1	                bcc braRolloverChecks
12369	.f619					LF5E5:
12370	.f619	48		pha		                pha
12371	.f61a	c9 1b		cmp #$1b	                cmp #27
12372	.f61c	d0 05		bne $f623	                bne LF5EF
12373	.f61e	a9 07		lda #$07	                lda #7
12374	.f620	1c 5a 02	trb $025a	                trb keyboardStatusByte
12375	.f623					LF5EF:
12376	.f623	68		pla		                pla
12378	.f624	f0 08		beq $f62e	                beq handleTAB                ;taken if TAB
12379	.f626	c9 9d		cmp #$9d	                cmp #$9D                     ;was it key_numpad_return?
12383	.f628	d0 07		bne $f631	                bne LF5FD

12386						                ;Transform $9d into $8d, aka 13|$80. ($8d is already
12387						                ; used in the table for right arrow.)
12388	.f62a	49 10		eor #$10	                eor #$10
12389	.f62c	80 31		bra $f65f	                bra getNumpadASCIICode

12391	.f62e					handleTAB:
12392	.f62e	ad 6b 02	lda $026b	                lda tabKeyCode
12394	.f631					LF5FD:
12395	.f631	c9 01		cmp #$01	                cmp #1
12396	.f633	d0 1e		bne $f653	                bne LF61F
12397	.f635	ad 5a 02	lda $025a	                lda keyboardStatusByte
12398	.f638	29 f8		and #$f8	                and #$f8
12399	.f63a	8d 5a 02	sta $025a	                sta keyboardStatusByte
12400	.f63d	a2 01		ldx #$01	                ldx #1
12401	.f63f	89 08		bit #$08	                bit #keyboardStatusByte.shiftPressed
12402	.f641	f0 01		beq $f644	                beq LF610
12403	.f643	e8		inx		                inx
12404	.f644					LF610:
12405	.f644	89 40		bit #$40	                bit #keyboardStatusByte.ctrlPressed
12406	.f646	f0 02		beq $f64a	                beq LF616
12407	.f648	e8		inx		                inx
12408	.f649	e8		inx		                inx
12409	.f64a					LF616:
12410	.f64a	8a		txa		                txa
12411	.f64b	0d 5a 02	ora $025a	                ora keyboardStatusByte
12412	.f64e	8d 5a 02	sta $025a	                sta keyboardStatusByte
12413	.f651	80 8e		bra $f5e1	                bra braRolloverChecks

12415	.f653					LF61F:
12416	.f653	2c 70 e3	bit $e370	                bit valueFF
12417	.f656	c9 90		cmp #$90	                cmp #$90
12418	.f658	90 01		bcc $f65b	                bcc handleKey
12419	.f65a	b8		clv		                clv
12427	.f65b					handleKey:
12428	.f65b	c9 a0		cmp #$a0	                cmp #$A0                     ;numpad key?
12429	.f65d	90 0e		bcc $f66d	                bcc processModifiers         ;taken if not
12430	.f65f					getNumpadASCIICode:
12432	.f65f	08		php		                php
12434						                ; C=1 at this point
12435	.f660	e9 31		sbc #$31	                sbc #'0'+1      ;+1 to compensate for C=1 in the next
12436						                                ;addition
12437	.f662	6d 7e 02	adc $027e	                adc numericKeypadInterpretation ;form actual ASCII value
12439	.f665	28		plp		                plp
12441	.f666	49 80		eor #$80	                eor #$80                     ;clear bit 7
12442	.f668	ae 8e 02	ldx $028e	                ldx numericKeypadShiftEffect ;does SHIFT affect the
12443						                                             ;keypad?
12444	.f66b	d0 46		bne $f6b3	                bne LF839                    ;taken if no
12445	.f66d					processModifiers:
12446	.f66d	ae 5a 02	ldx $025a	                ldx keyboardStatusByte
12447	.f670	86 fa		stx $fa		                stx SEIWKA
12448	.f672	26 fa		rol $fa		                rol SEIWKA                  ;b7 = ctrlPressed
12449	.f674	10 0a		bpl $f680	                bpl testShiftLock           ;taken if ctrl not pressed
12450	.f676	a6 ed		ldx $ed		                ldx firstKeyPressedInternal
12451	.f678					localResetAutoRepeatAndContinue:
12456	.f678	f0 03		beq $f67d	                beq +
12457	.f67a	4c a1 f5	jmp $f5a1	                jmp resetAutoRepeatAndContinue
12458	.f67d					+
12459	.f67d	20 fc f3	jsr $f3fc	                jsr implementCTRLCodes
12461	.f680					testShiftLock:
12462	.f680	26 fa		rol $fa		                rol SEIWKA                   ;b7 = shiftLockDisengaged
12463	.f682	30 07		bmi $f68b	                bmi testCapsLock             ;taken if shift lock off
12464	.f684	20 d2 f3	jsr $f3d2	                jsr implementShift           ;shift lock on - apply shift
12465	.f687	26 fa		rol $fa		                rol SEIWKA                   ;b7 = capsLockDisengaged
12466	.f689	80 0c		bra $f697	                bra testShiftEnabled

12468	.f68b					testCapsLock:
12469	.f68b	26 fa		rol $fa		                rol SEIWKA                   ;b7 = capsLockDisengaged
12470	.f68d	30 0d		bmi $f69c	                bmi testShift                ;taken if caps lock off
12471	.f68f	20 9c eb	jsr $eb9c	                jsr isLetter
12472	.f692	b0 08		bcs $f69c	                bcs testShift                ;taken if not a letter
12473	.f694	20 d2 f3	jsr $f3d2	                jsr implementShift ;letter + caps lock - make upper case
12474	.f697					testShiftEnabled:
12475	.f697	ae 5a 02	ldx $025a	                ldx keyboardStatusByte       ;b7 = shiftEnabled
12476	.f69a	10 0b		bpl $f6a7	                bpl testEscape               ;taken if not shiftEnabled
12477	.f69c					testShift:
12478	.f69c	26 fa		rol $fa		                rol SEIWKA                   ;b7 = shiftPressed
12479	.f69e	10 07		bpl $f6a7	                bpl testEscape               ;taken if not shiftPressed
12480	.f6a0	a6 ed		ldx $ed		                ldx firstKeyPressedInternal
12481	.f6a2	d0 d4		bne $f678	                bne localResetAutoRepeatAndContinue
12482	.f6a4	20 d2 f3	jsr $f3d2	                jsr implementShift
12483	.f6a7					testEscape:
12484	.f6a7	cd 6c 02	cmp $026c	                cmp escapeCharacter
12485	.f6aa	d0 07		bne $f6b3	                bne LF839
12486	.f6ac	ae 75 02	ldx $0275	                ldx escapeKeyStatus
12487	.f6af	d0 02		bne $f6b3	                bne LF839
12488	.f6b1	64 e7		stz $e7		                stz autoRepeatCountdownTimer

12490	.f6b3					LF839:

12522	.f6b3	48		pha		                pha
12523	.f6b4	ad 5a 02	lda $025a	                lda keyboardStatusByte
12524	.f6b7	29 07		and #$07	                and #7
12525	.f6b9	aa		tax		                tax
12529	.f6ba	1c 5a 02	trb $025a	                trb keyboardStatusByte
12530	.f6bd	68		pla		                pla
12531	.f6be	48		pha		                pha
12532	.f6bf	ca		dex		                dex

12543	.f6c0					LF693:
12544	.f6c0	ca		dex		                dex

12555	.f6c1					LF699:
12556	.f6c1	ca		dex		                dex

12567	.f6c2					LF69F:
12568	.f6c2	ca		dex		                dex
12572	.f6c3	d0 05		bne $f6ca	                bne LF6A7
12574	.f6c5	68		pla		                pla
12575	.f6c6	09 80		ora #$80	                ora #$80
12576	.f6c8	80 06		bra $f6d0	                bra LF6AD

12588	.f6ca					LF6A7:
12590	.f6ca	68		pla		                pla
12591	.f6cb					LF6A8:
12593	.f6cb	a8		tay		                tay
12594	.f6cc	50 02		bvc $f6d0	                bvc LF6AD
12595	.f6ce	d0 06		bne $f6d6	                bne LF6B3
12596	.f6d0					LF6AD:
12597	.f6d0	20 4e f8	jsr $f84e	                jsr insertCharacterIntoKeyboardBufferIfPossible
12598	.f6d3	90 09		bcc $f6de	                bcc LF6BB
12599	.f6d5	a8		tay		                tay

12601	.f6d6					LF6B3:
12602	.f6d6	ad 59 02	lda $0259	                lda keyboardStatus
12603	.f6d9	d0 03		bne $f6de	                bne LF6BB
12604	.f6db	20 a9 eb	jsr $eba9	                jsr insertCharacterIntoKeyboardBuffer
12605	.f6de					LF6BB:
12606	.f6de	20 42 f8	jsr $f842	                jsr enableKeyboardScanningFlippingInterrupts

12610	.f6e1					keyboardRolloverChecks:
12611	.f6e1	a6 ed		ldx $ed		                ldx firstKeyPressedInternal
12612	.f6e3	f0 09		beq $f6ee	                beq LF852                    ;taken if 1 key down
12613	.f6e5	20 1c f7	jsr $f71c	                jsr interrogateKeyboard      ;test first key pressed
12614	.f6e8	86 ed		stx $ed		                stx firstKeyPressedInternal  ;save it
12615	.f6ea	30 18		bmi $f704	                bmi LF868                    ;taken if still pressed
12616	.f6ec	64 ed		stz $ed		                stz firstKeyPressedInternal  ;reset first key
12617	.f6ee					LF852:
12618	.f6ee	a0 ec		ldy #$ec	                ldy #lastKeyPressedInternal
12619	.f6f0	20 08 f8	jsr $f808	                jsr scanKeyboardWithExclusion
12620	.f6f3	30 09		bmi $f6fe	                bmi LF862
12621	.f6f5	a5 ec		lda $ec		                lda lastKeyPressedInternal
12622	.f6f7	85 ed		sta $ed		                sta firstKeyPressedInternal
12623	.f6f9					updateLastKeyPressedInternal:
12624	.f6f9	86 ec		stx $ec		                stx lastKeyPressedInternal
12625	.f6fb	20 11 f7	jsr $f711	                jsr resetAutoRepeatCounters
12626	.f6fe					LF862:
12627	.f6fe	4c 31 f5	jmp $f531	                jmp tidyUpAfterKeyboardProcessing

12629	.f701					keyPressedInterrupt:
12630	.f701	20 1c f7	jsr $f71c	                jsr interrogateKeyboard
12631	.f704					LF868:
12632	.f704	a5 ec		lda $ec		                lda lastKeyPressedInternal
12633	.f706	d0 f6		bne $f6fe	                bne LF862
12634	.f708	a0 ed		ldy #$ed	                ldy #firstKeyPressedInternal
12635	.f70a	20 08 f8	jsr $f808	                jsr scanKeyboardWithExclusion
12636	.f70d	30 ef		bmi $f6fe	                bmi LF862
12637	.f70f	80 e8		bra $f6f9	                bra updateLastKeyPressedInternal

12639	.f711					resetAutoRepeatCounters:
12640	.f711	a2 01		ldx #$01	                ldx #$01
12641	.f713	86 e7		stx $e7		                stx autoRepeatCountdownTimer
12642	.f715	ae 54 02	ldx $0254	                ldx keyboardAutoRepeatDelay
12643	.f718	8e ca 02	stx $02ca	                stx keyboardFirstAutoRepeatCount
12644	.f71b	60		rts		                rts

12646						;-------------------------------------------------------------------------
12647						;
12648						; Read a single key's state from the keyboard
12649						;
12650						; Entry:
12651						;
12652						; X = key to test
12653						;
12654						; Exit:
12655						;
12656						; X=$80, N=1 if key pressed; X=$00, N=0 if key not pressed
12657						;
12658						; Keyboard remains in manual scan mode
12659						;
12660						; Preserves: A/C
12661						;
12666	.f71c					interrogateKeyboard:
12667	.f71c	a0 03		ldy #$03	                ldy #0|3            ;reset latch B3 - manual scan mode
12668	.f71e	8c 40 fe	sty $fe40	                sty systemVIA.orb
12669	.f721	a0 7f		ldy #$7f	                ldy #$7F
12670	.f723	8c 43 fe	sty $fe43	                sty systemVIA.ddra           ;bit 7=input, bits 6-0=output
12671	.f726	8e 4f fe	stx $fe4f	                stx systemVIA.oraNoHandshake ;store key value
12672	.f729	ea		nop		                nop
12673	.f72a	ae 4f fe	ldx $fe4f	                ldx systemVIA.iraNoHandshake ;read key state
12674	.f72d	60		rts		                rts

12676						; Default keyboard table
12677						; ======================

12679	.f72e					keyTranslationTable:
12680	>f72e	71				                .text "q"                    ;10 q
12681	>f72f	33				                .byte "3"                    ;11 3
12682	>f730	34				                .byte "4"                    ;12 4
12683	>f731	35				                .byte "5"                    ;13 5
12684	>f732	84				                .byte $84                    ;14 f4
12685	>f733	38				                .text "8"                    ;15 8
12686	>f734	87				                .byte $87                    ;16 f7
12687	>f735	2d				                .text "-"                    ;17 minus
12688	>f736	5e				                .text "^"                    ;18 caret
12689	>f737	8c				                .byte $8C                    ;19 left
12690	>f738	b6				                .byte "6"|$80                ;1a numpad_6
12691	>f739	b7				                .byte "7"|$80                ;1b numpad_7
12692	.f73a					osbyte92:
12693	.f73a	bc 00 fc	ldy $fc00,x	                ldy $FC00,x                  ;1c 1d 1e
12694	.f73d	60		rts		                rts                          ;1f

12697	>f73e	80				                .byte $80                    ;20 f0
12698	>f73f	77				                .text "w"                    ;21 w
12699	>f740	65				                .text "e"                    ;22 e
12700	>f741	74				                .text "t"                    ;23 t
12701	>f742	37				                .text "7"                    ;24 7
12702	>f743	69				                .text "i"                    ;25 i
12703	>f744	39				                .text "9"                    ;26 9
12704	>f745	30				                .text "0"                    ;27 0
12705	>f746	5f				                .text "_"                    ;28 underline
12706	>f747	8e				                .byte $8E                    ;29 down
12707	>f748	b8				                .byte "8"|$80                ;2a numpad_8
12708	>f749	b9				                .byte "9"|$80                ;2b numpad_9
12709	.f74a					osbyte94:
12710	.f74a	bc 00 fd	ldy $fd00,x	                ldy $FD00,x                  ;2c 2d 2e
12711	.f74d	60		rts		                rts                          ;2f

12714	>f74e	31				                .text "1"                    ;30 1
12715	>f74f	32				                .text "2"                    ;31 2
12716	>f750	64				                .text "d"                    ;32 d
12717	>f751	72				                .text "r"                    ;33 r
12718	>f752	36				                .text "6"                    ;34 6
12719	>f753	75				                .text "u"                    ;35 u
12720	>f754	6f				                .text "o"                    ;36 o
12721	>f755	70				                .text "p"                    ;37 p
12722	>f756	5b				                .text "["                    ;38 left_square_bracket
12723	>f757	8f				                .byte $8F                    ;39 up
12724	>f758	ab				                .byte "+"|$80                ;3a numpad_plus
12725	>f759	ad				                .byte "-"|$80                ;3b numpad_minus
12726	>f75a	9d				                .byte $9D                    ;3c numpad_return
12727	.f75b					LF8BF:
12728	.f75b	6c 20 02	jmp ($0220)	                jmp (EVENTV)                 ;3d 3e 3f
12730	>f75e	01				                .byte 1                      ;40 caps_lock
12731	>f75f	61				                .text "a"                    ;41 a
12732	>f760	78				                .text "x"                    ;42 x
12733	>f761	66				                .text "f"                    ;43 f
12734	>f762	79				                .text "y"                    ;44 y
12735	>f763	6a				                .text "j"                    ;45 j
12736	>f764	6b				                .text "k"                    ;46 k
12740	>f765	01				                .byte 1                      ;47 special
12742	>f766	3a				                .text ":"                    ;48 colon
12743	>f767	0d				                .byte $0D                    ;49 return
12744	>f768	af				                .byte "/"|$80                ;4a numpad_divide
12745	>f769	ff				                .byte 127|$80                ;4b numpad_delete
12746	>f76a	ae				                .byte "."|$80                ;4c numpad_stop
12747	.f76b					call1MHzBusHook:
12748	.f76b	6c fe fd	jmp ($fdfe)	                jmp ($FDFE)                  ;4d 4e 4f

12751	>f76e	02				                .byte 2                      ;50 shift_lock
12752	>f76f	73				                .text "s"                    ;51 s
12753	>f770	63				                .text "c"                    ;52 c
12754	>f771	67				                .text "g"                    ;53 g
12755	>f772	68				                .text "h"                    ;54 h
12756	>f773	6e				                .text "n"                    ;55 n
12757	>f774	6c				                .text "l"                    ;56 l
12758	>f775	3b				                .text ";"                    ;57 semicolon
12759	>f776	5d				                .text "]"                    ;58 right_square_bracket
12760	>f777	7f				                .byte $7F                    ;59 delete
12761	>f778	a3				                .byte "#"|$80                ;5a numpad_hash
12762	>f779	aa				                .byte "*"|$80                ;5b numpad_multiply
12763	>f77a	ac				                .byte ","|$80                ;5c numpad_comma
12764	.f77b					callSEIWKA:
12765	.f77b	6c fa 00	jmp ($00fa)	                jmp (SEIWKA)                 ;5d 5e 5f
12767	>f77e	00				                .byte 0                      ;60 tab
12768	>f77f	7a				                .text "z"                    ;61 z
12769	>f780	20				                .text " "                    ;62 space
12770	>f781	76				                .text "v"                    ;63 v
12771	>f782	62				                .text "b"                    ;64 b
12772	>f783	6d				                .text "m"                    ;65 m
12773	>f784	2c				                .text ","                    ;66 comma
12774	>f785	2e				                .text "."                    ;67 stop
12775	>f786	2f				                .text "/"                    ;68 divide
12776	>f787	8b				                .byte $8B                    ;69 copy
12777	>f788	b0				                .byte "0"|$80                ;6a numpad_0
12778	>f789	b1				                .byte "1"|$80                ;6b numpad_1
12779	>f78a	b3				                .byte "3"|$80                ;6c numpad_3
12780	>f78b	00				                .byte 0                      ;6d
12781	>f78c	00				                .byte 0                      ;6e
12782	>f78d	00				                .byte 0                      ;6f
12784	>f78e	1b				                .byte 27                     ;70 escape
12785	>f78f	81				                .byte $81                    ;71 f1
12786	>f790	82				                .byte $82                    ;72 f2
12787	>f791	83				                .byte $83                    ;73 f3
12788	>f792	85				                .byte $85                    ;74 f5
12789	>f793	86				                .byte $86                    ;75 f6
12790	>f794	88				                .byte $88                    ;76 f8
12791	>f795	89				                .byte $89                    ;77 f9
12792	>f796	5c				                .byte $5C                    ;78 backslash
12793	>f797	8d				                .byte $8D                    ;79 right
12794	>f798	b4				                .byte "4"|$80                ;7a numpad_4
12795	>f799	b5				                .byte "5"|$80                ;7b numpad_5
12796	>f79a	b2				                .byte "2"|$80                ;7c numpad_2
12797	.f79b					LF8FF:
12798	.f79b	2c 70 e3	bit $e370	                bit valueFF                  ; Set V
12799	.f79e					callKEYV:
12800	.f79e	6c 28 02	jmp ($0228)	                jmp (KEYV)                   ; Jump to KEYV

12802						;-------------------------------------------------------------------------
12803						;
12804						; OSBYTE 131 (&83) - Read Operating System High Water Mark (OSHWM)
12805						;
12806						; MasRef D.2-40
12807						;
12808	.f7a1					osbyte83:
12809	.f7a1	ac 44 02	ldy $0244	                ldy oshwm
12810	.f7a4	a2 00		ldx #$00	                ldx #$00
12811	.f7a6	60		rts		                rts

12813						;-------------------------------------------------------------------------
12814						;
12815						; OSBYTE 120 ($78) - Write keys pressed information
12816						;
12817						; MasRef D.2-33
12818						;
12819	.f7a7					osbyte78:                          ;f90b
12820	.f7a7	84 ec		sty $ec		                sty lastKeyPressedInternal
12821	.f7a9	86 ed		stx $ed		                stx firstKeyPressedInternal
12822	.f7ab	60		rts		                rts

12824						;-------------------------------------------------------------------------
12825						;
12826						; OSBYTE 122 (&7A) Keyboard scan from 16 decimal
12827						;
12828						; MasRef D.2-36
12829						;
12834	.f7ac					osbyte7A:
12835	.f7ac	a2 10		ldx #$10	                ldx #$10
12836	.f7ae	b8		clv		                clv
12837	.f7af	38		sec		                sec
12838	.f7b0	80 ec		bra $f79e	                bra callKEYV                 ; C=1, V=0 - scan keyboard

12840						;-------------------------------------------------------------------------

12842	.f7b2					scanKeyboard:
12843	.f7b2	8a		txa		                txa                          ; A=start key
12844	.f7b3	10 0a		bpl $f7bf	                bpl scanKeyboardFromKey  ; taken if full keyboard scan
12845	.f7b5	20 1c f7	jsr $f71c	                jsr interrogateKeyboard      ; query specific key
12846	.f7b8					enableKeyboardScanning:
12847						                ; Reinstate auto scan mode on exit
12848	.f7b8	a9 0b		lda #$0b	                lda #8|3                     ;set latch B3 - auto scan mode
12849	.f7ba	8d 40 fe	sta $fe40	                sta systemVIA.orb            ;set auto scan mode
12850	.f7bd	8a		txa		                txa
12851	.f7be	60		rts		                rts

12853	.f7bf					scanKeyboardFromKey:
12854	.f7bf	8e cb 02	stx $02cb	                stx previousKeyPressedWhenReadingLastKey ; save start key
12855	.f7c2	a9 ff		lda #$ff	                lda #$FF
12856	.f7c4	8d cc 02	sta $02cc	                sta previousKeyPressedWhenReadingFirstKey
12857	.f7c7	a2 0c		ldx #$0c	                ldx #$0C
12858	.f7c9	a9 7f		lda #$7f	                lda #$7F
12859	.f7cb	8d 43 fe	sta $fe43	                sta systemVIA.ddra  ;bit 7=input, bits0-6=output
12860	.f7ce	a9 03		lda #$03	                lda #0|3            ;reset latch B3 - manual scan mode
12861	.f7d0	8d 40 fe	sta $fe40	                sta systemVIA.orb
12862	.f7d3					loopKeyboardColumns:
12863	.f7d3	a9 0f		lda #$0f	                lda #$0F
12864	.f7d5	8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;select a non-existent column
12865	.f7d8	a9 01		lda #$01	                lda #$01
12866	.f7da	8d 4d fe	sta $fe4d	                sta systemVIA.ifr            ;cancel keyboard interrupts
12867	.f7dd	8e 4f fe	stx $fe4f	                stx systemVIA.oraNoHandshake ;select column
12868	.f7e0	2c 4d fe	bit $fe4d	                bit systemVIA.ifr            ;any key in this column
12869						                                             ;pressed?
12870	.f7e3	f0 1b		beq $f800	                beq tryNextKeyboardColumn    ;taken if no key
12871	.f7e5	8a		txa		                txa                          ;A = first key in column
12872	.f7e6					loopKeyboardRows:
12873	.f7e6	18		clc		                clc
12874	.f7e7	69 10		adc #$10	                adc #$10                     ;next row
12875	.f7e9	30 15		bmi $f800	                bmi tryNextKeyboardColumn    ;taken if done
12876	.f7eb	8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;store key
12877	.f7ee	2c 4f fe	bit $fe4f	                bit systemVIA.iraNoHandshake ;pressed?
12878	.f7f1	10 f3		bpl $f7e6	                bpl loopKeyboardRows         ;taken if not
12879						                ; Key is pressed...
12880	.f7f3	cd cb 02	cmp $02cb	                cmp previousKeyPressedWhenReadingLastKey
12881	.f7f6	90 ee		bcc $f7e6	                bcc loopKeyboardRows         ;Taken if key<start key
12882						                                             ;value. The scan excludes
12883						                                             ;this key.
12884	.f7f8	cd cc 02	cmp $02cc	                cmp previousKeyPressedWhenReadingFirstKey
12885	.f7fb	b0 e9		bcs $f7e6	                bcs loopKeyboardRows         ;Taken if key>=first key
12886						                                             ;value. Not sure why not
12887						                                             ;to simply break out of
12888						                                             ;thel loop though?
12889	.f7fd	8d cc 02	sta $02cc	                sta previousKeyPressedWhenReadingFirstKey
12890	.f800					tryNextKeyboardColumn:
12891	.f800	ca		dex		                dex
12892	.f801	10 d0		bpl $f7d3	                bpl loopKeyboardColumns
12893	.f803	ae cc 02	ldx $02cc	                ldx previousKeyPressedWhenReadingFirstKey ; X=key
12894						                                                          ; found, or
12895						                                                          ; $ff if
12896						                                                          ; none
12897	.f806	80 b0		bra $f7b8	                bra enableKeyboardScanning

12899	.f808					scanKeyboardWithExclusion:
12900	.f808	a2 0c		ldx #$0c	                ldx #$0c
12901	.f80a					LF96E:
12902	.f80a	20 42 f8	jsr $f842	                jsr enableKeyboardScanningFlippingInterrupts
12903	.f80d	a9 7f		lda #$7f	                lda #$7F
12904	.f80f	8d 43 fe	sta $fe43	                sta systemVIA.ddra
12905	.f812	a9 03		lda #$03	                lda #0|3
12906	.f814	8d 40 fe	sta $fe40	                sta systemVIA.orb
12907	.f817	a9 0f		lda #$0f	                lda #$0F
12908	.f819	8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;select non-existent column
12909	.f81c	a9 01		lda #$01	                lda #$01
12910	.f81e	8d 4d fe	sta $fe4d	                sta systemVIA.ifr            ;cancel keyboard interrupts
12911	.f821	8e 4f fe	stx $fe4f	                stx systemVIA.oraNoHandshake
12912	.f824	2c 4d fe	bit $fe4d	                bit systemVIA.ifr
12913	.f827	f0 20		beq $f849	                beq LF9AD
12914	.f829	8a		txa		                txa
12915	.f82a					LF98E:
12916	.f82a	18		clc		                clc
12917	.f82b	69 10		adc #$10	                adc #$10
12918	.f82d	30 1a		bmi $f849	                bmi LF9AD                    ;taken if done
12919	.f82f	8d 4f fe	sta $fe4f	                sta systemVIA.oraNoHandshake ;test key
12920	.f832	2c 4f fe	bit $fe4f	                bit systemVIA.iraNoHandshake ;pressed?
12921	.f835	10 f3		bpl $f82a	                bpl LF98E                    ;taken if not
12922	.f837	48		pha		                pha                          ;save key number
12923	.f838					LF99C:
12924	.f838	59 00 00	eor $0000,y	                eor $0000,y                  ;compare to value
12925	.f83b	0a		asl a		                asl a                        ;discard irrelevant bit 7
12926	.f83c	c9 01		cmp #$01	                cmp #$01                     ;C set if different
12927	.f83e	68		pla		                pla                          ;restore key number
12928	.f83f	90 e9		bcc $f82a	                bcc LF98E                    ;same key found - keep going
12929	.f841	aa		tax		                tax
12930	.f842					enableKeyboardScanningFlippingInterrupts:
12931	.f842	20 b8 f7	jsr $f7b8	                jsr enableKeyboardScanning
12932	.f845	58		cli		                cli
12933	.f846	78		sei		                sei
12934	.f847	8a		txa		                txa
12935	.f848	60		rts		                rts

12937	.f849					LF9AD:
12938	.f849	ca		dex		                dex
12939	.f84a	10 be		bpl $f80a	                bpl LF96E
12940	.f84c	80 f4		bra $f842	                bra enableKeyboardScanningFlippingInterrupts

12942						;-------------------------------------------------------------------------

12948						;-------------------------------------------------------------------------

12951						                .include "insertCharacterIntoKeyboardBufferIfPossible.s65"

:17	;******  Processing file: src/insertCharacterIntoKeyboardBufferIfPossible.s65

1						                ; dup of what's called LF82B in MOS 5.00+
2	.f84e					insertCharacterIntoKeyboardBufferIfPossible:
3	.f84e	48		pha		                pha
4	.f84f	a2 00		ldx #$00	                ldx #bufferKeyboard          ; buffer number
5	.f851	b8		clv		                clv                          ; count buffer
6	.f852	38		sec		                sec                          ; return space remaining
7	.f853	20 b5 ed	jsr $edb5	                jsr countBufferViaCNPV       ; do the thing...
8	.f856	98		tya		                tya                          ; A=MSB of space remaining
9	.f857	d0 04		bne $f85d	                bne LF6E2              ; taken if >256 bytes remaining
10	.f859	e0 02		cpx #$02	                cpx #2                 ; X=LSB of space remaining
11	.f85b	90 0a		bcc $f867	                bcc LF6EC            ; taken if 1 or 0 bytes remaining
12	.f85d					LF6E2:
13	.f85d	ac 59 02	ldy $0259	                ldy keyboardStatus
14	.f860	18		clc		                clc                       ; assume char not inserted
15	.f861	d0 04		bne $f867	                bne LF6EC                 ; taken if keyboard disabled
16	.f863	20 a9 eb	jsr $eba9	                jsr insertCharacterIntoKeyboardBuffer
17	.f866	38		sec		                sec                          ; indicate char inserted
18	.f867					LF6EC:
19	.f867	68		pla		                pla
20	.f868	60		rts		                rts

:15	;******  Return to file: src/mos.s65

12954						;-------------------------------------------------------------------------

12956						                ; Ugly condition...
12958	.f869					transferBetweenSidewaysRAMAndRAM: .block
12959	.f869	20 ab e5	jsr $e5ab	                jsr selectROMA
12960	.f86c					transferBetweenSidewaysRAMAndRAMLoop:
12961	.f86c	b1 b0		lda ($b0),y	                lda (sramTransferPointers.src),y
12962	.f86e	91 b2		sta ($b2),y	                sta (sramTransferPointers.dest),y
12963	.f870	c8		iny		                iny
12964	.f871	d0 0d		bne $f880	                bne LF85D
12965	.f873	e6 b1		inc $b1		                inc sramTransferPointers.src+1
12966	.f875	e6 b3		inc $b3		                inc sramTransferPointers.dest+1
12967	.f877	20 a9 e5	jsr $e5a9	                jsr selectTerminalROM
12968	.f87a	20 4c 8d	jsr $8d4c	                jsr L8D0F
12969	.f87d	20 ab e5	jsr $e5ab	                jsr selectROMA
12970	.f880					LF85D:
12971	.f880	cc ef 02	cpy $02ef	                cpy sramWorkspace.length+0
12972	.f883	d0 e7		bne $f86c	                bne transferBetweenSidewaysRAMAndRAMLoop
12973	.f885	b5 01		lda $01,x	                lda 1,x
12974	.f887	cd f0 02	cmp $02f0	                cmp sramWorkspace.length+1
12975	.f88a	d0 e0		bne $f86c	                bne transferBetweenSidewaysRAMAndRAMLoop
12976	.f88c	4c a9 e5	jmp $e5a9	                jmp selectTerminalROM
12977						                .endblock

12980						;-------------------------------------------------------------------------

12983						                .include "sram_access_helpers_2.s65"

:18	;******  Processing file: src/sram_access_helpers_2.s65

1	.f88f					dummyROMHeader: .block
2	.f88f	60		rts		                rts
3	>f890	00 00				                .byte 0,0
4	.f892	60		rts		                rts
5	>f893	00 00				                .byte 0,0
6	>f895	02				                .byte romType6502
7	>f896	0c				                .byte copyright-dummyROMHeader
8	>f897	ff				                .byte $ff
9	>f898	52				                .text "R"
10	.f899					ram_or_rom_char:
11	>f899	41				                .text "A"
12	>f89a	4d				                .text "M"
13	.f89b					copyright:
14	>f89b	00				                .byte 0
15	>f89c	28 43 29			                .text "(C)"
16	=16					size=*-dummyROMHeader
17						                ; I doubt I've caught all the implied 16s...

20						                ; in any event, this ROM header must be <=16 bytes, as
21						                ; the total pseudo-addressable area has a o documented
22						                ; size of 4*(16384-16)
24						                .endblock

26	=32784					dataBankStart=$8000+16
27	=16368					dataBankSize=16384-16

29						;-------------------------------------------------------------------------
30						;
31						;
32	.f89f					initDummyROMHeader:
33	.f89f	20 9a e5	jsr $e59a	                jsr selectROMX
34	.f8a2	a0 0f		ldy #$0f	                ldy #size(dummyROMHeader)-1
35	.f8a4					LF881:
36	.f8a4	b9 8f f8	lda $f88f,y	                lda dummyROMHeader,y
37	.f8a7	99 00 80	sta $8000,y	                sta $8000,y
38	.f8aa	88		dey		                dey
39	.f8ab	10 f7		bpl $f8a4	                bpl LF881
40	.f8ad	2c ee 02	bit $02ee	                bit sramWorkspace.type
41	.f8b0	70 05		bvs $f8b7	                bvs LF894       ; taken if called by *SRDATA
42	.f8b2	a9 4f		lda #$4f	                lda #'O'
43	.f8b4	8d 0a 80	sta $800a	                sta $8000+(dummyROMHeader.ram_or_rom_char-dummyROMHeader)
44	.f8b7					LF894:
45	.f8b7	8e 01 80	stx $8001	                stx $8001
46	.f8ba	4c a9 e5	jmp $e5a9	                jmp selectTerminalROM

48						;-------------------------------------------------------------------------
49						;
50						; Check if a ROM bank is writeable.
51						;
52						; Entry:
53						;
54						; X = ROM bank of interest
55						;
56						; Exit:
57						;
58						; C=0 if ROM, C=1 if RAM
59						;
60						; Terminal ROM selected
61						;
62						; Preserves: X
63						;
64	.f8bd					isBankROM:
65	.f8bd	20 9a e5	jsr $e59a	                jsr selectROMX

67						                ; Modify the version number byte - if a valid
68						                ; writeable sideways ROM, don't leave it in a bad
69						                ; state if reset partway through (not much you can do
70						                ; for non-ROMs of course...)
71	.f8c0	ad 08 80	lda $8008	                lda $8008
72	.f8c3	a8		tay		                tay             ; Y = original value
73	.f8c4	49 ff		eor #$ff	                eor #$ff
74	.f8c6	78		sei		                sei
75	.f8c7	8d 08 80	sta $8008	                sta $8008       ; store modified value

95	.f8ca	cd 08 80	cmp $8008	                cmp $8008       ; did it take? Z=1 if RAM
96	.f8cd	8c 08 80	sty $8008	                sty $8008       ; restore original value
97	.f8d0	58		cli		                cli
98	.f8d1	f0 01		beq $f8d4	                beq jmpSelectTerminalROM ; taken if RAM
99	.f8d3	18		clc		                clc
100	.f8d4					jmpSelectTerminalROM:
101	.f8d4	4c a9 e5	jmp $e5a9	                jmp selectTerminalROM

105						;-------------------------------------------------------------------------

:15	;******  Return to file: src/mos.s65

12986						;-------------------------------------------------------------------------

12989	.f8d7					LF8B4:
12990	.f8d7	20 9a e5	jsr $e59a	                jsr selectROMX
12997	.f8da	a0 80		ldy #$80	                ldy #$80
12998	.f8dc	84 01		sty $01		                sty 1
12999	.f8de	64 00		stz $00		                stz 0
13001	.f8e0	a8		tay		                tay
13002	.f8e1					LF8BE:
13003	.f8e1	91 00		sta ($00),y	                sta (0),y
13004	.f8e3	c8		iny		                iny
13005	.f8e4	d0 fb		bne $f8e1	                bne LF8BE
13006	.f8e6	e6 01		inc $01		                inc 1
13007	.f8e8	24 01		bit $01		                bit 1
13008	.f8ea	50 f5		bvc $f8e1	                bvc LF8BE
13009	.f8ec	ca		dex		                dex
13010	.f8ed	e0 04		cpx #$04	                cpx #4
13011	.f8ef	b0 e6		bcs $f8d7	                bcs LF8B4
13012	.f8f1	4c a9 e5	jmp $e5a9	                jmp selectTerminalROM

13015						;-------------------------------------------------------------------------

13018						                .include "sram_access_helpers_3.s65"

:19	;******  Processing file: src/sram_access_helpers_3.s65

1	.f8f4					LF8D1:
2	.f8f4	ad ee 02	lda $02ee	                lda sramWorkspace.type
3	.f8f7	c9 a0		cmp #$a0	                cmp #$a0
4	.f8f9	d0 d9		bne $f8d4	                bne jmpSelectTerminalROM
5	.f8fb	ac f1 02	ldy $02f1	                ldy sramWorkspace.bank
6	.f8fe	98		tya		                tya
7	.f8ff	aa		tax		                tax
8	.f900	20 ab e3	jsr $e3ab	                jsr LE389
9	.f903	90 cf		bcc $f8d4	                bcc jmpSelectTerminalROM
10	.f905	ad 06 80	lda $8006	                lda $8006
11	.f908	9d a1 02	sta $02a1,x	                sta romInformationTable,x
12	.f90b	80 c7		bra $f8d4	                bra jmpSelectTerminalROM

:15	;******  Return to file: src/mos.s65

13021						;-------------------------------------------------------------------------

13024	.f90d					selectTerminalROMAndOSBYTE44:
13025	.f90d	20 61 f4	jsr $f461	                jsr withTerminalROM
13026	.f910	4c 19 8f	jmp $8f19	                jmp osbyte44

13029						;-------------------------------------------------------------------------

13032	.f913					selectTerminalROMAndOSBYTE45:
13033	.f913	20 61 f4	jsr $f461	                jsr withTerminalROM
13034	.f916	4c c9 8f	jmp $8fc9	                jmp osbyte45

13037						;-------------------------------------------------------------------------

13040	.f919					selectTerminalROMAndOSWORD42:
13041	.f919	20 61 f4	jsr $f461	                jsr withTerminalROM
13042	.f91c	4c 2f 8c	jmp $8c2f	                jmp osword42

13045						;-------------------------------------------------------------------------

13048	.f91f					selectTerminalROMAndOSWORD43:
13049	.f91f	20 61 f4	jsr $f461	                jsr withTerminalROM
13050	.f922	4c 6b 8e	jmp $8e6b	                jmp osword43

13053						;-------------------------------------------------------------------------

13059						;-------------------------------------------------------------------------
13060						;
13061						; OSBPUT [AUG p339]
13062						;
13063	.f925					osbputEntryPoint:
13064	.f925	20 0a fa	jsr $fa0a	                jsr selectFSForHandle
13065	.f928	6c 18 02	jmp ($0218)	                jmp (BPUTV)

13067						;-------------------------------------------------------------------------
13068						;
13069						; OSBGET [AUG p338]
13070						;
13071	.f92b					osbgetEntryPoint:
13072	.f92b	20 0a fa	jsr $fa0a	                jsr selectFSForHandle
13073	.f92e	6c 16 02	jmp ($0216)	                jmp (BGETV)

13075						;-------------------------------------------------------------------------
13076						;
13077						; OSGBPB [AUG p339]
13078						;
13079	.f931					osgbpbEntryPoint: .proc
13080	.f931	c9 05		cmp #$05	                cmp #gbpbGetMediaMetadata
13081	.f933	b0 15		bcs $f94a	                bcs nonFileOperation
13082	.f935	c9 00		cmp #$00	                cmp #$00
13083	.f937	f0 11		beq $f94a	                beq nonFileOperation

13085						                ; Handle OSGBPB call that's an operation on a file
13086						                ; handle. Select the appropriate FS, given the file
13087						                ; handle, and pass the request along.
13088	.f939	5a		phy		                phy                          ;save OSGBPB Y
13089	.f93a	48		pha		                pha                          ;save OSGBPB A
13090	.f93b	86 b0		stx $b0		                stx osgbpbWorkspace.ptr+0
13091	.f93d	84 b1		sty $b1		                sty osgbpbWorkspace.ptr+1
13092	.f93f	b2 b0		lda ($b0)	                lda (osgbpbWorkspace.ptr)    ;get file handle
13093	.f941	a8		tay		                tay
13094	.f942	68		pla		                pla                          ;restore OSGBPB A
13095	.f943	20 0a fa	jsr $fa0a	                jsr selectFSForHandle
13096	.f946					passToCurrentFS:
13097	.f946	7a		ply		                ply                          ;restore OSGBPB Y
13098	.f947	6c 1a 02	jmp ($021a)	                jmp (GBPBV)

13100						;-------------------------------------------------------------------------
13101						;
13102						; Handle OSGBPB call that isn't an operation on a file handle. Select
13103						; current FS and pass the request along.
13104						;
13105	.f94a					nonFileOperation:
13106	.f94a	5a		phy		                phy
13107	.f94b	da		phx		                phx
13108	.f94c	48		pha		                pha
13109	.f94d	20 47 ee	jsr $ee47	                jsr selectHAZEL
13110	.f950	ad 00 df	lda $df00	                lda hazel.currentFS
13111	.f953	20 c0 fa	jsr $fac0	                jsr selectFS
13112	.f956	68		pla		                pla
13113	.f957	fa		plx		                plx
13114	.f958	80 ec		bra $f946	                bra passToCurrentFS
13115						                .endproc

13117						;-------------------------------------------------------------------------
13118						;
13119						; OSARGS [AUG p337[
13120						;
13121						;
13122	.f95a					osargsEntryPoint: .proc
13123	.f95a	c0 00		cpy #$00	                cpy #$00
13124	.f95c	d0 2a		bne $f988	                bne fileOperation            ;taken if file operation
13125	.f95e	c9 04		cmp #$04	                cmp #$04
13126	.f960	b0 26		bcs $f988	                bcs fileOperation ;taken if Y=0, A>=4 - honorary file operation
13127	.f962	48		pha		                pha
13128	.f963	20 47 ee	jsr $ee47	                jsr selectHAZEL
13129	.f966	68		pla		                pla
13130	.f967	d0 04		bne $f96d	                bne notGetFS
13131	.f969					getFS:
13132						                ; OSARGS Y=0 A=0 - read current FS number
13133	.f969	ad 00 df	lda $df00	                lda hazel.currentFS
13134	.f96c	60		rts		                rts

13136	.f96d					notGetFS:
13137	.f96d	3a		dec a		                dec a
13138	.f96e	d0 10		bne $f980	                bne notGetCommandLine
13139	.f970					getCommandLine:
13140						                ; OSARGS Y=0 A=1 - read command line tail address
13141	.f970	3a		dec a		                dec a                        ;A=$ff
13142	.f971	95 02		sta $02,x	                sta 2,x                    ;store full 32-bit address
13143	.f973	95 03		sta $03,x	                sta 3,x                    ;store full 32-bit address
13144	.f975	ad 04 df	lda $df04	                lda hazel.commandLinePointer+0
13145	.f978	95 00		sta $00,x	                sta 0,x                    ;
13146	.f97a	ad 05 df	lda $df05	                lda hazel.commandLinePointer+1
13147	.f97d	95 01		sta $01,x	                sta 1,x
13148	.f97f	60		rts		                rts

13150	.f980					notGetCommandLine:
13151	.f980	c9 01		cmp #$01	                cmp #argsCheckANFS-1    ;-1 due to the dec a above
13152	.f982	f0 03		beq $f987	                beq rtsFA14            ; OSARGS Y=0 A=2 - Read OldNFS flag
13153	.f984					getLibFS:
13154	.f984	ad 02 df	lda $df02	                lda hazel.libFS      ;OSARGS Y=0 A=3 - Read libfs filing system number
13155	.f987					rtsFA14:
13156	.f987	60		rts		                rts

13158	.f988					fileOperation:
13159						                ; Operating on a file. Select appropriate FS first.
13160	.f988	20 0a fa	jsr $fa0a	                jsr selectFSForHandle
13161						                .endproc

13164						;-------------------------------------------------------------------------
13165						;
13166						; Call current FS's OSARGS routine, bypassing the FileSwitch stuff.
13167						;
13168	.f98b					callARGSV:                      ;fa18
13169	.f98b	6c 14 02	jmp ($0214)	                jmp (ARGSV)

13171						;-------------------------------------------------------------------------
13172						;
13173						; OSFIND [AUG p342]
13174						;
13175	.f98e					osfindEntryPoint: .proc
13176	.f98e	09 00		ora #$00	                ora #$00        ;A=$00 if a file is to be closed
13177	.f990	f0 05		beq $f997	                beq close       ;branch taken if closing a file
13178	.f992	20 e1 f9	jsr $f9e1	                jsr parseFileNameAndSelectFS       ;handle something other than a file close
13179	.f995	80 03		bra $f99a	                bra callFINDV

13181	.f997					close:
13182	.f997	20 0a fa	jsr $fa0a	                jsr selectFSForHandle
13183	.f99a					callFINDV:
13184	.f99a	6c 1c 02	jmp ($021c)	                jmp (FINDV)
13185						                .pend

13187						;-------------------------------------------------------------------------
13188						;
13189						; OSFILE [AUG p335]
13190						;
13191	.f99d					osfileEntryPoint:               ;fa2a
13192	.f99d	da		phx		                phx
13193	.f99e	5a		phy		                phy
13194	.f99f	48		pha		                pha
13195	.f9a0	86 f2		stx $f2		                stx stringInputBufferAddress+0
13196	.f9a2	84 f3		sty $f3		                sty stringInputBufferAddress+1
13197	.f9a4	a0 11		ldy #$11	                ldy #size(OSFILEParameterBlock)-1
13198	.f9a6					-
13199	.f9a6	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
13200	.f9a8	99 ed 02	sta $02ed,y	                sta osfileParameterBlock,y
13201	.f9ab	88		dey		                dey
13202	.f9ac	10 f8		bpl $f9a6	                bpl -
13203	.f9ae	ae ed 02	ldx $02ed	                ldx osfileParameterBlock+OSFILEParameterBlock.fileName+0
13204	.f9b1	ac ee 02	ldy $02ee	                ldy osfileParameterBlock+OSFILEParameterBlock.fileName+1
13205	.f9b4	20 e1 f9	jsr $f9e1	                jsr parseFileNameAndSelectFS
13206	.f9b7	8e ed 02	stx $02ed	                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
13207	.f9ba	8c ee 02	sty $02ee	                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
13208	.f9bd	68		pla		                pla
13209	.f9be	a2 ed		ldx #$ed	                ldx #<osfileParameterBlock
13210	.f9c0	a0 02		ldy #$02	                ldy #>osfileParameterBlock
13211	.f9c2	20 de f9	jsr $f9de	                jsr callFILEV
13212	.f9c5	7a		ply		                ply
13213	.f9c6	84 f3		sty $f3		                sty stringInputBufferAddress+1
13214	.f9c8	fa		plx		                plx
13215	.f9c9	86 f2		stx $f2		                stx stringInputBufferAddress+0
13216	.f9cb	48		pha		                pha
13217	.f9cc	a0 11		ldy #$11	                ldy #size(OSFILEParameterBlock)-1
13218	.f9ce					-
13219	.f9ce	b9 ed 02	lda $02ed,y	                lda osfileParameterBlock,y
13220	.f9d1	91 f2		sta ($f2),y	                sta (stringInputBufferAddress),y
13221	.f9d3	88		dey		                dey
13222	.f9d4	c0 02		cpy #$02	                cpy #$02                     ;don't overwrite file name
13223	.f9d6	b0 f6		bcs $f9ce	                bcs -
13224	.f9d8	68		pla		                pla
13225	.f9d9	a6 f2		ldx $f2		                ldx stringInputBufferAddress+0
13226	.f9db	a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
13227	.f9dd	60		rts		                rts

13229	.f9de					callFILEV:
13230	.f9de	6c 12 02	jmp ($0212)	                jmp (FILEV)

13232						;-------------------------------------------------------------------------
13233						;
13234						; Parse file name. Handle (and skip) any -FS- tempfs syntax, selecting
13235						; the FS specified if required.
13236						;
13237						; entry:
13238						;
13239						; Y (MSB)/X (LSB) = address of file name string
13240						;
13241						; exit:
13242						;
13243						; Y (MSB)/X (LSB) = address of file name part
13244						;
13245						; - New FS may have been selected
13246						;
13247	.f9e1					parseFileNameAndSelectFS:
13248	.f9e1	48		pha		                pha
13249	.f9e2	a5 f2		lda $f2		                lda stringInputBufferAddress+0
13250	.f9e4	48		pha		                pha
13251	.f9e5	a5 f3		lda $f3		                lda stringInputBufferAddress+1
13252	.f9e7	48		pha		                pha
13253	.f9e8	20 47 ee	jsr $ee47	                jsr selectHAZEL
13254	.f9eb	86 f2		stx $f2		                stx stringInputBufferAddress+0
13255	.f9ed	84 f3		sty $f3		                sty stringInputBufferAddress+1
13256	.f9ef	a0 00		ldy #$00	                ldy #$00
13257	.f9f1	20 19 fa	jsr $fa19	                jsr parseFileNameFS      ;find -FS- prefix, if any
13258	.f9f4	5a		phy		                phy                      ;save offset
13259	.f9f5	20 c0 fa	jsr $fac0	                jsr selectFS                 ;select desired FS
13260	.f9f8	68		pla		                pla
13261	.f9f9	18		clc		                clc
13262	.f9fa	65 f2		adc $f2		                adc stringInputBufferAddress+0
13263	.f9fc	aa		tax		                tax                          ;save string address LSB
13264	.f9fd	a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
13265	.f9ff	90 01		bcc $fa02	                bcc +
13266	.fa01	c8		iny		                iny
13267	.fa02					+
13268	.fa02	68		pla		                pla
13269	.fa03	85 f3		sta $f3		                sta stringInputBufferAddress+1
13270	.fa05	68		pla		                pla
13271	.fa06	85 f2		sta $f2		                sta stringInputBufferAddress+0
13272	.fa08	68		pla		                pla
13273	.fa09	60		rts		                rts

13275						;-------------------------------------------------------------------------
13276						;
13277						; Select appropriate FS for the given file handle.
13278						;
13279						; entry:
13280						;
13281						; Y = file handle
13282						;
13283						; exit:
13284						;
13285						; - appropriate FS selected
13286						;
13287						; preserves: Y/X/A

13289	.fa0a					selectFSForHandle:
13290	.fa0a	da		phx		                phx
13291	.fa0b	48		pha		                pha
13292	.fa0c	20 47 ee	jsr $ee47	                jsr selectHAZEL
13293	.fa0f	20 96 fa	jsr $fa96	                jsr findFSForHandle
13294	.fa12	8a		txa		                txa
13295	.fa13	20 c0 fa	jsr $fac0	                jsr selectFS
13296	.fa16	68		pla		                pla
13297	.fa17	fa		plx		                plx
13298	.fa18	60		rts		                rts

13300						;-------------------------------------------------------------------------
13301						;
13302						; Parse the FS part of a file name, if any, and return the filing
13303						; system to use.
13304						;
13305						; Entry:
13306						;
13307						; (stringInputBufferAddress),y = the string
13308						;
13309						; Exit:
13310						;
13311						; A = FS number to use
13312						;
13313						; (stringInputBufferAddress),y = next char after any tempfs prefix has
13314						; been consumed
13315	.fa19					parseFileNameFS: .proc

13317	.fa19	4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
13318	.fa1c	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput
13319	.fa1f	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
13320	.fa21	c9 2d		cmp #$2d	                cmp #'-'
13321	.fa23	f0 0c		beq $fa31	                beq parseFSNamePrefix ; branch taken if tempfs syntax
13322	.fa25	2c c6 df	bit $dfc6	                bit hazel.tempFSFlag
13323	.fa28	ad 00 df	lda $df00	                lda hazel.currentFS
13324	.fa2b	50 03		bvc $fa30	                bvc +
13325	.fa2d	ad 01 df	lda $df01	                lda hazel.activeFS
13326	.fa30					+
13327	.fa30	60		rts		                rts

13329	.fa31					parseFSNamePrefix:
13330	.fa31	c8		iny		                iny
13331	.fa32	a2 00		ldx #$00	                ldx #$00
13332	.fa34					LFAC1:
13333	.fa34	bd 06 df	lda $df06,x	                lda hazel.fsInfoBlocks,x ;get FS name char
13334	.fa37	f0 44		beq $fa7d	                beq badFilingSystemName
13335	.fa39	8a		txa		                txa                      ;A=offset in info blocks
13336	.fa3a	18		clc		                clc
13337	.fa3b	69 08		adc #$08	                adc #size(fsInfoBlock.name)
13338	.fa3d	85 b0		sta $b0		                sta parseFileNameFSWorkspace.fsInfoOffset
13339	.fa3f	5a		phy		                phy
13340	.fa40					compareFSNameLoop:
13341	.fa40	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y

13343						; validate FS name char. Must be letter or digit.

13345	.fa42	20 9c eb	jsr $eb9c	                jsr isLetter
13346	.fa45	90 08		bcc $fa4f	                bcc validFSNameChar           ;branch taken if letter
13347	.fa47	c9 30		cmp #$30	                cmp #'0'
13348	.fa49	90 1b		bcc $fa66	                bcc notValidFSNameChar       ;branch taken if not digit
13349	.fa4b	c9 3a		cmp #$3a	                cmp #'9'+1
13350	.fa4d	b0 17		bcs $fa66	                bcs notValidFSNameChar       ;branch taken if not digit
13351	.fa4f					validFSNameChar:
13352	.fa4f	e4 b0		cpx $b0		                cpx parseFileNameFSWorkspace.fsInfoOffset
13353	.fa51	b0 0b		bcs $fa5e	                bcs nextFSInfoBlock ;branch taken if end of FS
13354						                                         ;info block name was reached
13355	.fa53	5d 06 df	eor $df06,x	                eor hazel.fsInfoBlocks,x
13356	.fa56	29 df		and #$df	                and #$DF                 ;Z=1 if char matches FS name
13357	.fa58	d0 04		bne $fa5e	                bne nextFSInfoBlock      ;branch taken if not a match
13358	.fa5a	e8		inx		                inx                      ;next fs info block byte
13359	.fa5b	c8		iny		                iny                      ;next input string byte
13360	.fa5c	80 e2		bra $fa40	                bra compareFSNameLoop

13362	.fa5e					nextFSInfoBlock:
13363	.fa5e	7a		ply		                ply
13364	.fa5f	a6 b0		ldx $b0		                ldx parseFileNameFSWorkspace.fsInfoOffset ;offset of end of name
13365	.fa61	e8		inx		                inx
13366	.fa62	e8		inx		                inx
13367	.fa63	e8		inx		                inx             ;advance to next entry
13368	.fa64	80 ce		bra $fa34	                bra LFAC1

13370	.fa66					notValidFSNameChar:

13372						; Matching FS name must be terminated with -. Otherwise, it's bad
13373						; syntax, or perhaps an overly long name.

13375	.fa66	c9 2d		cmp #$2d	                cmp #'-'
13376	.fa68	d0 13		bne $fa7d	                bne badFilingSystemName
13377	.fa6a	c8		iny		                iny                       ;consume input '-'
13378	.fa6b	e4 b0		cpx $b0		                cpx parseFileNameFSWorkspace.fsInfoOffset
13379	.fa6d	f0 07		beq $fa76	                beq foundFSInfoBlock     ;branch taken if a match due
13380						                                         ;to being right at end of the
13381						                                         ;FS info block name
13382	.fa6f	bd 06 df	lda $df06,x	                lda hazel.fsInfoBlocks,x ;
13383	.fa72	c9 20		cmp #$20	                cmp #' '
13384	.fa74	d0 e8		bne $fa5e	                bne nextFSInfoBlock      ;branch taken if not a match
13385						                                         ;as tthe supplied name was a
13386						                                         ;prefix of this FS's name
13387	.fa76					foundFSInfoBlock:
13388	.fa76	68		pla		                pla
13389	.fa77	a6 b0		ldx $b0		                ldx parseFileNameFSWorkspace.fsInfoOffset
13390	.fa79	bd 08 df	lda $df08,x	                lda hazel.fsInfoBlocks+(fsInfoBlock.fsNumber-(fsInfoBlock.name+size(fsInfoBlock.name))),x
13391	.fa7c	60		rts		                rts

13393	.fa7d					badFilingSystemName:
13394	.fa7d	00		brk #		                brk
13395	>fa7e	f8 42 61 64 20 66 69 6c		                .text $f8,'Bad filing system name',0
	>fa86	69 6e 67 20 73 79 73 74 65 6d 20 6e 61 6d 65 00
13396						                .pend

13398						;-------------------------------------------------------------------------
13399						;
13400						; Find FS for the given handle
13401						;
13402						; entry:
13403						;
13404						; Y = file handle
13405						;
13406						; exit:
13407						;
13408						; X = FS number - will just use current FS if none suitable found
13409						;
13410	.fa96					findFSForHandle: .proc
13411	.fa96	48		pha		                pha                          ;
13412	.fa97	5a		phy		                phy                          ;
13413	.fa98	98		tya		                tya                          ;A = handle to search for
13414	.fa99	a0 00		ldy #$00	                ldy #$00                     ;
13415	.fa9b					loop:
13416	.fa9b	be 06 df	ldx $df06,y	                ldx hazel.fsInfoBlocks.name+0,y
13417	.fa9e	f0 15		beq $fab5	                beq notFound                  ;taken if terminating entry
13418	.faa0	d9 0e df	cmp $df0e,y	                cmp hazel.fsInfoBlocks.minHandle,y
13419	.faa3	90 07		bcc $faac	                bcc next                     ;taken if not this FS
13420	.faa5	d9 0f df	cmp $df0f,y	                cmp hazel.fsInfoBlocks.maxHandle,y
13421	.faa8	90 10		bcc $faba	                bcc found                    ;taken if this FS
13422	.faaa	f0 0e		beq $faba	                beq found                    ;taken if this FS

13424	.faac					next:
13425	.faac	48		pha		                pha
13426	.faad	98		tya		                tya
13427	.faae	18		clc		                clc
13428	.faaf	69 0b		adc #$0b	                adc #size(fsInfoBlock)
13429	.fab1	a8		tay		                tay
13430	.fab2	68		pla		                pla
13431	.fab3	80 e6		bra $fa9b	                bra loop

13433	.fab5					notFound:
13434	.fab5	ae 00 df	ldx $df00	                ldx hazel.currentFS
13435	.fab8	80 03		bra $fabd	                bra done

13437	.faba					found:
13438	.faba	be 10 df	ldx $df10,y	                ldx hazel.fsInfoBlocks.fsNumber,y
13439	.fabd					done:
13440	.fabd	7a		ply		                ply
13441	.fabe	68		pla		                pla
13442	.fabf	60		rts		                rts
13443						                .endproc

13445						;-------------------------------------------------------------------------
13446						;
13447						; Select filing system in A.
13448						;
13449						; Entry:
13450						;
13451						; A = FS number
13452						;
13453	.fac0					selectFS:                               ;fb4d
13454	.fac0	cd 01 df	cmp $df01	                cmp hazel.activeFS      ; Check active fs
13455	.fac3	f0 16		beq $fadb	                beq rtsFB68               ; Already active fs, return
13456	.fac5	5a		phy		                phy
13457	.fac6	da		phx		                phx
13458	.fac7	a8		tay		                tay
13459	.fac8	3a		dec a		                dec a
13460	.fac9	d0 07		bne $fad2	                bne LFB5F       ;taken if not FS 1 (tape)

13462						; ??? - only if trying to select tape FS

13464	.facb	a9 04		lda #$04	                lda #$04
13465	.facd	24 e2		bit $e2		                bit $E2
13466	.facf	d0 01		bne $fad2	                bne LFB5F
13467	.fad1	c8		iny		                iny
13468	.fad2					LFB5F:
13469	.fad2	5a		phy		                phy
13470	.fad3	a2 12		ldx #$12	                ldx #romServiceCallInitialiseFilingSystem
13471	.fad5	20 ff ee	jsr $eeff	                jsr makeROMServiceCall
13472	.fad8	68		pla		                pla
13473	.fad9	fa		plx		                plx
13474	.fada	7a		ply		                ply
13475	.fadb					rtsFB68:
13476	.fadb	60		rts		                rts

13478						;-------------------------------------------------------------------------
13479						;
13480						; FileSwitch FSC
13481						; ==============
13482						;
13483	.fadc					fileswitchFSCEntryPoint:
13484	.fadc	48		pha		                pha                          ;save request type
13485	.fadd	20 47 ee	jsr $ee47	                jsr selectHAZEL
13486	.fae0	4e c6 df	lsr $dfc6	                lsr hazel.tempFSFlag
13487	.fae3	68		pla		                pla                          ;restore request type
13488	.fae4	48		pha		                pha                          ;save request type
13489	.fae5	da		phx		                phx                          ;save request X
13490	.fae6	0a		asl a		                asl a
13491	.fae7	aa		tax		                tax
13492	.fae8	c9 17		cmp #$17	                cmp #11*2+1
13493	.faea	b0 03		bcs $faef	                bcs fileswitchPassFSCToCurrentFS ;taken if out of range
13494	.faec	7c f4 fa	jmp ($faf4,x)	                jmp (fileswitchFSCRoutinesTable,x)

13496						;-------------------------------------------------------------------------
13497						;
13498						; Pass to filing system's FSC
13499						;
13500						; There's 2 entry points - fileswitchPassFSCToCurrentFS, for
13501						; when X and A are both on the stack, and
13502						; fileswitchPassFSCToCurrentFS_X, for when only A is on the
13503						; stack.
13504						;
13505	.faef					fileswitchPassFSCToCurrentFS:
13506	.faef					fileswitchFSCNewFS:
13507	.faef					fileswitchFSCFileHandleRange:
13508	.faef					fileswitchFSCStarCommand:
13509	.faef	fa		plx		                plx                          ;restore request X
13510	.faf0					fileswitchPassFSCToCurrentFS_X:
13511	.faf0	68		pla		                pla                          ;restore request type
13512	.faf1	6c da df	jmp ($dfda)	                jmp (hazel.activeFSCV) ;call active FS's real FSCV entry point

13514						;-------------------------------------------------------------------------
13515						;
13516						; FileSwitch FSC table
13517						;
13518	.faf4					fileswitchFSCRoutinesTable:
13519	>faf4	19 fb				                .word fileswitchFSCOPT
13520	>faf6	12 fb				                .word fileswitchFSCCheckEOF
13521	>faf8	26 fb				                .word fileswitchFSCStarSlash
13522	>fafa	0c fb				                .word fileswitchFSCUnknownCommand
13523	>fafc	26 fb				                .word fileswitchFSCStarRUN
13524	>fafe	2b fb				                .word fileswitchFSCStarCAT
13525	>fb00	ef fa				                .word fileswitchFSCNewFS
13526	>fb02	ef fa				                .word fileswitchFSCFileHandleRange
13527	>fb04	ef fa				                .word fileswitchFSCStarCommand
13528	>fb06	2b fb				                .word fileswitchFSCStarEX
13529	>fb08	2b fb				                .word fileswitchFSCStarINFO
13530	>fb0a	5b fb				                .word fileswitchFSCRUNLibrary

13532						;-------------------------------------------------------------------------
13533						;
13534						; FSC 3 - *command [AUG p344]
13535						;
13536	.fb0c					fileswitchFSCUnknownCommand:
13537	.fb0c	fa		plx		                plx
13538	.fb0d	20 34 fb	jsr $fb34	                jsr getCommandLinePointer
13539	.fb10	80 de		bra $faf0	                bra fileswitchPassFSCToCurrentFS_X

13541						;-------------------------------------------------------------------------
13542						;
13543						; FSC 1 - check EOF [AUG p343]
13544						;
13545	.fb12					fileswitchFSCCheckEOF:
13546	.fb12	7a		ply		                ply                         ;Y = file handle
13547	.fb13	5a		phy		                phy                         ;restore stack arrangement
13548	.fb14	20 0a fa	jsr $fa0a	                jsr selectFSForHandle
13549	.fb17	80 d6		bra $faef	                bra fileswitchPassFSCToCurrentFS

13551						;-------------------------------------------------------------------------
13552						;
13553						; FSC 0 - *OPT [AUG p343]
13554						;
13555	.fb19					fileswitchFSCOPT:
13556	.fb19	2c c6 df	bit $dfc6	                bit hazel.tempFSFlag   ; Check temporary fs flag
13557	.fb1c	70 d1		bvs $faef	                bvs fileswitchPassFSCToCurrentFS
13558	.fb1e	ad 00 df	lda $df00	                lda hazel.currentFS ; Get current filing system number

13560						;-------------------------------------------------------------------------
13561						;
13562						; Pass FSCV request through to a particular FS.
13563						;
13564						; entry:
13565						;
13566						; A = FS to select
13567						;
13568						; Y = FSCV Y
13569						;
13570						; S = [FSCV X; FSCV A]
13571						;
13572	.fb21					fileswitchPassFSCToSpecificFS:
13573	.fb21	20 c0 fa	jsr $fac0	                jsr selectFS        ; Select filing system
13574	.fb24	80 c9		bra $faef	                bra fileswitchPassFSCToCurrentFS

13576						;-------------------------------------------------------------------------
13577						;
13578						; FSC 2 - */filename [AUG p343]
13579						; FSC 4 - *RUN filename [AUG p344]
13580						;
13581	.fb26					fileswitchFSCStarSlash:
13582	.fb26					fileswitchFSCStarRUN:
13583	.fb26	fa		plx		                plx
13584	.fb27	20 34 fb	jsr $fb34	                jsr getCommandLinePointer ; Skip '*'s and spaces, set command line address
13585	.fb2a	da		phx		                phx             ; Continue on to pass to filing system

13588						;-------------------------------------------------------------------------
13589						;
13590						; FSC 5 - *CAT [AUG p344]
13591						; FSC 9 - *EX [NAUG p257]
13592						; FSC, 10 - *INFO [NAUG p257]
13593						;
13594	.fb2b					fileswitchFSCStarCAT:
13595	.fb2b					fileswitchFSCStarEX:
13596	.fb2b					fileswitchFSCStarINFO:
13597	.fb2b	fa		plx		                plx
13598	.fb2c	0e c6 df	asl $dfc6	                asl hazel.tempFSFlag
13599	.fb2f	20 e1 f9	jsr $f9e1	                jsr parseFileNameAndSelectFS
13600	.fb32	80 bc		bra $faf0	                bra fileswitchPassFSCToCurrentFS_X

13602						;-------------------------------------------------------------------------
13603						;
13604						; Get command line pointer.
13605						;
13606						; Entry:
13607						;
13608						; X/Y - pointer to CR-terminated command line string
13609						;
13610						; Exit:
13611						;
13612						; X/Y, (hazel.commandLinePointer) - pointer to first non-space char in
13613						; command line string
13614	.fb34					getCommandLinePointer: .proc ;fbc1
13615	.fb34	86 f2		stx $f2		                stx stringInputBufferAddress+0
13616	.fb36	84 f3		sty $f3		                sty stringInputBufferAddress+1

13618						; skip spaces. Stop if terminating CR encountered.

13620	.fb38	a0 ff		ldy #$ff	                ldy #$FF
13621	.fb3a					-
13622	.fb3a	c8		iny		                iny
13623	.fb3b	b1 f2		lda ($f2),y	                lda (stringInputBufferAddress),y
13624	.fb3d	c9 0d		cmp #$0d	                cmp #$0D
13625	.fb3f	f0 04		beq $fb45	                beq +
13626	.fb41	c9 20		cmp #$20	                cmp #' '
13627	.fb43	d0 f5		bne $fb3a	                bne -

13629	.fb45					+

13631						; Hmm. Didn't we just do this bit already?

13633	.fb45	20 be f3	jsr $f3be	                jsr skipSpacesAndCheckForCRInStringInput

13635						; Store address of first non-space char in the HAZEL command line
13636						; pointer.

13638	.fb48	98		tya		                tya
13639	.fb49	18		clc		                clc
13640	.fb4a	65 f2		adc $f2		                adc stringInputBufferAddress+0
13641	.fb4c	8d 04 df	sta $df04	                sta hazel.commandLinePointer+0
13642	.fb4f	a5 f3		lda $f3		                lda stringInputBufferAddress+1
13643	.fb51	69 00		adc #$00	                adc #$00
13644	.fb53	8d 05 df	sta $df05	                sta hazel.commandLinePointer+1
13645	.fb56	a4 f3		ldy $f3		                ldy stringInputBufferAddress+1
13646	.fb58	a6 f2		ldx $f2		                ldx stringInputBufferAddress+0
13647	.fb5a	60		rts		                rts
13648						                .pend

13650						;-------------------------------------------------------------------------
13651						;
13652						; FSC 11 - RUN from libfs [NAUG p257]
13653						;
13654	.fb5b					fileswitchFSCRUNLibrary:
13655	.fb5b	ad 02 df	lda $df02	                lda hazel.libFS      ; Is a libfs set?
13656	.fb5e	10 c1		bpl $fb21	                bpl fileswitchPassFSCToSpecificFS
13657	.fb60					badCommandError:
13658	.fb60	00		brk #		                brk
13659	>fb61	fe				                .byte 254
13660	>fb62	42 61 64 20 63 6f 6d 6d		                .text "Bad command"
	>fb6a	61 6e 64
13661	.fb6d	00		brk #		                brk

13663						;-------------------------------------------------------------------------

13673						;-------------------------------------------------------------------------
13674						;
13675						; Tube 6502 language ROM relocation
13676						;

13984						;-------------------------------------------------------------------------
13985						;
13986						; Delay after a possible EEPROM write, to give the device time to time
13987						; out out of write mode. Trying to stay reasonably under 10 ms. Don't
13988						; interfere with the 100 Hz timer, but give the 100 Hz routine at
13989						; least a bit of time to run.
13990						;
13991						; 256 times round inner loop=2+256*2+255*3+2=1281 cycles
13992						;
13993						; 1281 cycles = 0.6405 ms
13994						;
13995						; 12 iterations = 15372+(a bit) cycles=~7.7 ms
13996						;
13997						; This can be revisited if required.
13998						;
13999						; Preserves: A/X/P

14020						;-------------------------------------------------------------------------

14022	.fb6e					mosUnusedBegin:
14023	>fb6e	ff ff ff ff ff ff ff ff		                .fill $fc00-*,$ff
	>fb76	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb86	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fb96	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fba6	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbb6	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbc6	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbd6	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbe6	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
	>fbf6	ff ff ff ff ff ff ff ff ff ff
14024	=146					mosUnusedSize=*-mosUnusedBegin

14062						;-------------------------------------------------------------------------
14063						;
14064						; Credits - normally hidden by the I/O region.
14065						;

14074	>fc00	28 43 29 20 31 39 38 36		                .text "(C) 1986 Acorn Computers Ltd."
	>fc08	20 41 63 6f 72 6e 20 43 6f 6d 70 75 74 65 72 73
	>fc18	20 4c 74 64 2e
14076	>fc1d	54 68 61 6e 6b 73 20 61		                .text "Thanks are due to the following contributors to this Computer (among many others):- "
	>fc25	72 65 20 64 75 65 20 74 6f 20 74 68 65 20 66 6f
	>fc35	6c 6c 6f 77 69 6e 67 20 63 6f 6e 74 72 69 62 75
	>fc45	74 6f 72 73 20 74 6f 20 74 68 69 73 20 43 6f 6d
	>fc55	70 75 74 65 72 20 28 61 6d 6f 6e 67 20 6d 61 6e
	>fc65	79 20 6f 74 68 65 72 73 29 3a 2d 20
14078	>fc71	44 61 76 69 64 20 41 6c		                .text "David Allen,"
	>fc79	6c 65 6e 2c
14082	>fc7d	44 61 76 69 64 20 42 65		                .text "David Bell,"
	>fc85	6c 6c 2c
14083	>fc88	50 61 75 6c 20 42 6f 6e		                .text "Paul Bond,"
	>fc90	64 2c
14087	>fc92	4a 75 6c 69 61 6e 20 42		                .text "Julian Brown,"
	>fc9a	72 6f 77 6e 2c
14088	>fc9f	54 75 64 6f 72 20 42 72		                .text "Tudor Brown,"
	>fca7	6f 77 6e 2c
14090	>fcab	54 69 6d 20 43 61 73 70		                .text "Tim Caspell,"
	>fcb3	65 6c 6c 2c
14092	>fcb7	42 72 69 61 6e 20 43 6f		                .text "Brian Cockburn,"
	>fcbf	63 6b 62 75 72 6e 2c
14094	>fcc6	42 61 72 62 61 72 61 20		                .text "Barbara Cole,"
	>fcce	43 6f 6c 65 2c
14099	>fcd3	4d 61 72 6b 20 43 6f 6c		                .text "Mark Colton,"
	>fcdb	74 6f 6e 2c
14100	>fcdf	43 68 72 69 73 20 43 75		                .text "Chris Curry,"
	>fce7	72 72 79 2c
14102	>fceb	4a 69 6d 20 44 61 79 2c		                .text "Jim Day,"
14103	>fcf3	54 69 6d 20 44 6f 62 73		                .text "Tim Dobson,"
	>fcfb	6f 6e 2c
14105	>fcfe	4a 6f 65 20 44 75 6e 6e		                .text "Joe Dunn,"
	>fd06	2c
14113	>fd07	50 61 75 6c 20 46 65 6c		                .text "Paul Fellows,"
	>fd0f	6c 6f 77 73 2c
14114	>fd14	41 6c 61 6e 20 46 6f 75		                .text "Alan Fournier,"
	>fd1c	72 6e 69 65 72 2c
14116	>fd22	53 74 65 76 65 20 46 75		                .text "Steve Furber,"
	>fd2a	72 62 65 72 2c
14117	>fd2f	4d 61 72 74 79 6e 20 47		                .text "Martyn Gilbert,"
	>fd37	69 6c 62 65 72 74 2c
14118	>fd3e	4a 6f 68 6e 20 48 61 72		                .text "John Harrison,"
	>fd46	72 69 73 6f 6e 2c
14119	>fd4c	48 65 72 6d 61 6e 6e 20		                .text "Hermann Hauser,"
	>fd54	48 61 75 73 65 72 2c
14121	>fd5b	4d 69 6b 65 20 48 69 6c		                .text "Mike Hill,"
	>fd63	6c 2c
14124	>fd65	50 61 75 6c 20 48 6f 6c		                .text "Paul Holding,"
	>fd6d	64 69 6e 67 2c
14126	>fd72	4a 6f 68 6e 20 48 6f 72		                .text "John Horton,"
	>fd7a	74 6f 6e 2c
14131	>fd7e	44 61 76 65 20 49 72 65		                .text "Dave Ireland,"
	>fd86	6c 61 6e 64 2c
14136	>fd8b	52 69 63 68 61 72 64 20		                .text "Richard King,"
	>fd93	4b 69 6e 67 2c
14137	>fd98	44 61 76 69 64 20 4b 69		                .text "David Kitson,"
	>fda0	74 73 6f 6e 2c
14139	>fda5	41 6e 64 79 20 4b 6e 69		                .text "Andy Knight,"
	>fdad	67 68 74 2c
14141	>fdb1	4a 75 6c 69 61 6e 20 4c		                .text "Julian Lomberg,"
	>fdb9	6f 6d 62 65 72 67 2c
14142	>fdc0	52 6f 62 20 4d 61 63 6d		                .text "Rob Macmillan,"
	>fdc8	69 6c 6c 61 6e 2c
14144	>fdce	54 6f 6d 20 4d 63 4e 61		                .text "Tom McNamara,"
	>fdd6	6d 61 72 61 2c
14146	>fddb	52 69 63 68 61 72 64 20		                .text "Richard Manby,"
	>fde3	4d 61 6e 62 79 2c
14158	>fde9	44 61 76 69 64 20 4d 6f		                .text "David Morgan,"
	>fdf1	72 67 61 6e 2c
14159	>fdf6	52 69 63 68 61 72 64 20		                .text "Richard Murphy,"
	>fdfe	4d 75 72 70 68 79 2c
14161	>fe05	47 6c 65 6e 20 4e 69 63		                .text "Glen Nicholls,"
	>fe0d	68 6f 6c 6c 73 2c
14162	>fe13	52 6f 62 65 72 74 20 4e		                .text "Robert Nokes,"
	>fe1b	6f 6b 65 73 2c
14164	>fe20	4a 65 61 6e 20 4e 75 6e		                .text "Jean Nunn,"
	>fe28	6e 2c
14166	>fe2a	52 69 63 68 61 72 64 20		                .text "Richard Page,"
	>fe32	50 61 67 65 2c
14173	>fe37	4a 6f 68 6e 20 52 61 64		                .text "John Radcliffe,"
	>fe3f	63 6c 69 66 66 65 2c
14174	>fe46	52 69 63 6b 20 52 61 6e		                .text "Rick Rand,"
	>fe4e	64 2c
14176	>fe50	4e 69 63 6b 20 52 65 65		                .text "Nick Reeves,"
	>fe58	76 65 73 2c
14178	>fe5c	42 72 69 61 6e 20 52 6f		                .text "Brian Robertson,"
	>fe64	62 65 72 74 73 6f 6e 2c
14180	>fe6c	50 61 75 6c 20 52 6f 73		                .text "Paul Rose,"
	>fe74	65 2c
14182	>fe76	52 69 63 68 61 72 64 20		                .text "Richard Russell,"
	>fe7e	52 75 73 73 65 6c 6c 2c
14188	>fe86	52 6f 62 65 72 74 20 53		                .text "Robert Sack,"
	>fe8e	61 63 6b 2c
14189	>fe92	52 6f 67 65 72 20 53 61		                .text "Roger Sale,"
	>fe9a	6c 65 2c
14191	>fe9d	44 61 76 69 64 20 53 65		                .text "David Seal,"
	>fea5	61 6c 2c
14193	>fea8	50 68 69 6c 20 53 6d 69		                .text "Phil Smith,"
	>feb0	74 68 2c
14194	>feb3	54 6f 6e 79 20 53 75 6d		                .text "Tony Sumner,"
	>febb	6e 65 72 2c
14197	>febf	50 61 75 6c 20 53 77 69		                .text "Paul Swindell,"
	>fec7	6e 64 65 6c 6c 2c
14199	>fecd	4a 6f 6e 20 54 68 61 63		                .text "Jon Thackray,"
	>fed5	6b 72 61 79 2c
14201	>feda	54 6f 6e 79 20 54 68 6f		                .text "Tony Thompson,"
	>fee2	6d 70 73 6f 6e 2c
14203	>fee8	48 75 67 6f 20 54 79 73		                .text "Hugo Tyson,"
	>fef0	6f 6e 2c
14218	>fef3	52 6f 67 65 72 20 57 69		                .text "Roger Wilson."
	>fefb	6c 73 6f 6e 2e

14230						;-------------------------------------------------------------------------

14234						;-------------------------------------------------------------------------

14236	.ff00					E_USERV: ; ff00
14237	.ff00	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14238	.ff03					E_BRKV: ; ff03
14239	.ff03	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14240	.ff06					E_IRQ1V: ; ff06
14241	.ff06	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14242	.ff09					E_IRQ2V: ; ff09
14243	.ff09	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14244	.ff0c					E_CLIV: ; ff0c
14245	.ff0c	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14246	.ff0f					E_BYTEV: ; ff0f
14247	.ff0f	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14248	.ff12					E_WORDV: ; ff12
14249	.ff12	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14250	.ff15					E_WRCHV: ; ff15
14251	.ff15	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14252	.ff18					E_RDCHV: ; ff18
14253	.ff18	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14254	.ff1b					E_FILEV: ; ff1b
14255	.ff1b	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14256	.ff1e					E_ARGSV: ; ff1e
14257	.ff1e	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14258	.ff21					E_BGETV: ; ff21
14259	.ff21	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14260	.ff24					E_BPUTV: ; ff24
14261	.ff24	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14262	.ff27					E_GBPBV: ; ff27
14263	.ff27	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14264	.ff2a					E_FINDV: ; ff2a
14265	.ff2a	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14266	.ff2d					E_FSCV: ; ff2d
14267	.ff2d	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14268	.ff30					E_EVENTV: ; ff30
14269	.ff30	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14270	.ff33					E_UPTV: ; ff33
14271	.ff33	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14272	.ff36					E_NETV: ; ff36
14273	.ff36	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14274	.ff39					E_VDUV: ; ff39
14275	.ff39	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14276	.ff3c					E_KEYV: ; ff3c
14277	.ff3c	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14278	.ff3f					E_INSV: ; ff3f
14279	.ff3f	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14280	.ff42					E_REMV: ; ff42
14281	.ff42	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14282	.ff45					E_CNPV: ; ff45
14283	.ff45	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14284	.ff48					E_IND1V: ; ff48
14285	.ff48	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14286	.ff4b					E_IND2V: ; ff4b
14287	.ff4b	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint
14288	.ff4e					E_IND3V: ; ff4e
14289	.ff4e	20 51 ff	jsr $ff51	                jsr extendedVectorEntryPoint

14291						;-------------------------------------------------------------------------

14293	.ff51					extendedVectorEntryPoint:
14294						                ; .if CFA3000
14295						                ; ;...
14296						                ; .else
14297						                ; $10b,x = rL
14298	.ff51	48		pha		                pha                 ; $10a,x  (old ROMSEL)
14299	.ff52	48		pha		                pha                 ; $109,x  (old ACCCON)
14300	.ff53	48		pha		                pha                 ; $108,x  (thunk rH)
14301	.ff54	48		pha		                pha                 ; $107,x  (thunk rL)
14302	.ff55	48		pha		                pha                 ; $106,x  (jump dest MSB)
14303	.ff56	48		pha		                pha                 ; $105,x  (jump dest LSB)
14304	.ff57	08		php		                php                 ; $104,x  (P for RTI)
14305	.ff58	48		pha		                pha                 ; $103,x  (old A)
14306	.ff59	da		phx		                phx                 ; $102,x  (old X)
14307	.ff5a	5a		phy		                phy                 ; $101,x  (old Y)
14308	.ff5b	ba		tsx		                tsx
14309	.ff5c	a9 ff		lda #$ff	                lda #>extendedVectorReturnThunk-1
14310	.ff5e	9d 08 01	sta $0108,x	                sta $0108,x
14311	.ff61	a9 8c		lda #$8c	                lda #<extendedVectorReturnThunk-1
14312	.ff63	9d 07 01	sta $0107,x	                sta $0107,x

14314						                ; this routine is only ever called from $ff00, $ff03,
14315						                ; $ff06, etc. - so rL holds vectorIndex*3+2, suitable
14316						                ; for indexing into the extended vector space.
14317	.ff66	bc 0b 01	ldy $010b,x	                ldy $010B,x                  ;Y=vectorIndex*3+2
14318	.ff69	b9 9d 0d	lda $0d9d,y	                lda extendedVectorSpace-2,y  ;get vector LSB
14319	.ff6c	9d 05 01	sta $0105,x	                sta $0105,x                  ;
14320	.ff6f	b9 9e 0d	lda $0d9e,y	                lda extendedVectorSpace-1,y  ;get vector MSB
14321	.ff72	9d 06 01	sta $0106,x	                sta $0106,x
14322	.ff75	a5 f4		lda $f4		                lda $F4
14323	.ff77	9d 0a 01	sta $010a,x	                sta $010A,x
14324	.ff7a	ad 34 fe	lda $fe34	                lda ACCCON
14325	.ff7d	9d 09 01	sta $0109,x	                sta $0109,x

14327						                ; New stack layout:
14328						                ;
14329						                ; $10a,x - old ROMSEL
14330						                ; $109,x - old ACCCON
14331						                ; $108,x - thunk rH
14332						                ; $107,x - thunk rL
14333						                ; $106,x - jump dest MSB
14334						                ; $105,x - jump dest LSB
14335						                ; $104,x - P (for RTI)
14336						                ; $103,x - old A
14337						                ; $102,x - old X
14338						                ; $101,x - old Y

14340	.ff80	20 47 ee	jsr $ee47	                jsr selectHAZEL
14341	.ff83	b9 9f 0d	lda $0d9f,y	                lda extendedVectorSpace,y    ;get vector ROM number
14342	.ff86	20 ab e5	jsr $e5ab	                jsr selectROMA
14343	.ff89	7a		ply		                ply
14344	.ff8a	fa		plx		                plx
14345	.ff8b	68		pla		                pla
14346	.ff8c	40		rti		                rti
14347						;                .endif

14349						;-------------------------------------------------------------------------

14351	.ff8d					extendedVectorReturnThunk:
14352	.ff8d	08		php		                php
14353	.ff8e	48		pha		                pha
14354	.ff8f	da		phx		                phx
14355	.ff90	ba		tsx		                tsx
14356	.ff91	bd 02 01	lda $0102,x	                lda $0102,x
14357	.ff94	9d 06 01	sta $0106,x	                sta $0106,x
14358	.ff97	bd 03 01	lda $0103,x	                lda $0103,x
14359	.ff9a	9d 07 01	sta $0107,x	                sta $0107,x
14360	.ff9d	fa		plx		                plx
14361	.ff9e	68		pla		                pla
14362	.ff9f	68		pla		                pla
14363	.ffa0	68		pla		                pla
14364	.ffa1	20 3d ee	jsr $ee3d	                jsr selectMOSOrHAZEL
14365	.ffa4	68		pla		                pla
14366	.ffa5	20 ab e5	jsr $e5ab	                jsr selectROMA
14367	.ffa8	68		pla		                pla
14368	.ffa9	28		plp		                plp
14369	.ffaa					rtsFFAA:
14370	.ffaa	60		rts		                rts

14372						;-------------------------------------------------------------------------
14373						;
14374						; OSBYTE 150 (&96) Read from SHEILA (&FE00 - &FEFF) [MasRef D.2-45]
14375						;
14376	.ffab					osbyte96:
14377	.ffab	bc 00 fe	ldy $fe00,x	                ldy $fe00,x
14378	.ffae	60		rts		                rts

14380						;-------------------------------------------------------------------------
14381						;
14382						; OSBYTE 157 (&9D) Write byte across Tube [MasRef D.2-48]
14383						;
14384	.ffaf					osbyte9D:
14385	.ffaf	8a		txa		                txa
14386	.ffb0	80 22		bra $ffd4	                bra OSBPUT

14388	.ffb2	00		brk #		                brk

14390						;-------------------------------------------------------------------------
14391	.ffb3					OSWRSC:
14392	.ffb3	4c df f4	jmp $f4df	                jmp oswrscEntryPoint ; FFB3
14393	>ffb6	36				                .byte defaultVectorTable.end-defaultVectorTable ;
14394	>ffb7	f9 e2				                .word defaultVectorTable ;
14395	.ffb9					OSRDSC:
14396	.ffb9	4c d9 f4	jmp $f4d9	                jmp osrdscEntryPoint ; FFB9
14397	.ffbc					VDUCHR:
14398	.ffbc	4c c9 f4	jmp $f4c9	                jmp vduChrEntryPoint ; FFBC
14399	.ffbf					OSEVEN:
14400	.ffbf	4c 53 eb	jmp $eb53	                jmp eventEntryPoint ; FFBF
14401	.ffc2					GSINIT:
14402	.ffc2	4c 2d f3	jmp $f32d	                jmp gsinitEntryPoint ; FFC2
14403	.ffc5					GSREAD:
14404	.ffc5	4c 3e f3	jmp $f33e	                jmp gsreadEntryPoint ; FFC5
14405	.ffc8					NVRDCH:
14406	.ffc8	4c ec e8	jmp $e8ec	                jmp osrdchEntryPoint                    ; FFC8
14407	.ffcb					NVWRCH:
14408	.ffcb	4c 4d e9	jmp $e94d	                jmp oswrchEntryPoint                    ; FFCB
14409	.ffce					OSFIND:
14410	.ffce	4c 8e f9	jmp $f98e	                jmp osfindEntryPoint                    ; FFCE
14411	.ffd1					OSGBPB:
14412	.ffd1	4c 31 f9	jmp $f931	                jmp osgbpbEntryPoint                    ; FFD1
14413	.ffd4					OSBPUT:
14414	.ffd4	4c 25 f9	jmp $f925	                jmp osbputEntryPoint                    ; FFD4
14415	.ffd7					OSBGET:
14416	.ffd7	4c 2b f9	jmp $f92b	                jmp osbgetEntryPoint                    ; FFD7
14417	.ffda					OSARGS:
14418	.ffda	4c 5a f9	jmp $f95a	                jmp osargsEntryPoint ; FFDA
14419	.ffdd					OSFILE:
14420	.ffdd	4c 9d f9	jmp $f99d	                jmp osfileEntryPoint ; FFDD
14421	.ffe0					OSRDCH:
14422	.ffe0	6c 10 02	jmp ($0210)	                jmp (RDCHV)                  ; FFE0
14423	.ffe3					OSASCI:
14424	.ffe3	c9 0d		cmp #$0d	                cmp #$0D                     ; FFE3
14425	.ffe5	d0 07		bne $ffee	                bne OSWRCH                   ; FFE5
14426	.ffe7					OSNEWL:
14427	.ffe7	a9 0a		lda #$0a	                lda #$0A                     ; FFE7
14428	.ffe9	20 ee ff	jsr $ffee	                jsr OSWRCH                   ; FFE9
14429	.ffec					printCR:
14430						                ; not an official entry point, but saves 2 bytes if
14431						                ; you just want to print a 13.
14432	.ffec	a9 0d		lda #$0d	                lda #$0D                     ; FFEC
14433	.ffee					OSWRCH:
14434	.ffee	6c 0e 02	jmp ($020e)	                jmp (WRCHV)                  ; FFEE
14435	.fff1					OSWORD:
14436	.fff1	6c 0c 02	jmp ($020c)	                jmp (WORDV)                  ; FFF1
14437	.fff4					OSBYTE:
14438	.fff4	6c 0a 02	jmp ($020a)	                jmp (BYTEV)                  ; FFF4
14439	.fff7					OSCLI:
14440	.fff7	6c 08 02	jmp ($0208)	                jmp (CLIV)                  ; FFF7

14442	.fffa					LFFFA:                                       ; FFFA NMIV
14443	>fffa	00 0d				                .word nmiEntryPoint
14444	.fffc					LFFFC:                                       ; FFFB RESETV
14445	>fffc	86 e3				                .word resetEntryPoint
14446	.fffe					LFFFE:                                       ; FFFE IRQV
14447	>fffe	b7 e5				                .word irqEntryPoint

:1	;******  Return to file: mosautocue.s65

28						                .endsection

;******  End of listing