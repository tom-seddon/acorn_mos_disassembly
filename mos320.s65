;-------------------------------------------------------------------------
;
; Names for stuff common to MOS 3.20 and OS 1.20 are intended to
; mostly match the ones in
; https://tobylobster.github.io/mos/mos/index.html
;
;-------------------------------------------------------------------------

                .include "hardware.s65"
                
; The number of sections will probably increase, as a longer term goal
; is to have a bit of flexibility here. Stuff that's got documented
; addresses ($FFxx, default font, VDU driver entry points, etc.) needs
; to stay fixed, but, space permitting, other stuff could be
; rearranged.
                
*=$8000
                .dsection terminal
                .cwarn *>$c000,'Terminal ROM is too large'
                
*=$c000
                .dsection mos
                ; there's no need for a size check here - 64tass gives
                ; you an error if the code would go past the 64 K
                ; barrier.

;-------------------------------------------------------------------------

tubeBrkHandlerAddr=$16
tubeHostAddr=$400
                
;-------------------------------------------------------------------------

osargsBuffer=$a8                ;4-byte ZP buffer for use with OSARGS
printMessageAddress=$b8
                
                .virtual $e4
stringInputOptions: .block
doubleQuotes=$80
spaceNotATerminator=$40
goodString=$01
                .endblock
                .endvirtual
stringInputPlingFlag=$e5        ;bit 7 set if last char was '!'
                
stringInputBufferAddress=$f2    ;word

;-------------------------------------------------------------------------

romServiceCallAbsoluteWorkspaceClaim=$01 ; memory used only when ROM is paged in
romServiceCallPrivateWorkspaceClaim=$02 ; memory used even when ROM is not paged in
romServiceCallAutoBoot=$03              ;
romServiceCallUnrecognisedCommand=$04   ; star command not recognised
romServiceCallUnrecognisedInterrupt=$05 ;
romServiceCallBreakInstruction=$06      ;
romServiceCallUnrecognisedOSBYTE=$07    ;
romServiceCallUnrecognisedOSWORD=$08    ;
romServiceCallHelp=$09                  ;
romServiceCallClaimStaticWorkspace=$0A ; (Issued by paged ROMs, not the OS)
romServiceCallNMIRelease=$0B    ; (Issued by paged ROMs, not the OS)
romServiceCallNMIClaim=$0C      ; (Issued by paged ROMs, not the OS)
romServiceCallROMFilingSystemInitialize=$0D    ;
romServiceCallROMFilingSystemByteGet=$0E    ;
romServiceCallVectorsClaimed=$0F    ; Used when a filing system starts
romServiceCallSpoolExecClosureWarning=$10    ;
;romServiceCallFontImplosionExplosionWarning=$11    ;
romServiceCallInitialiseFilingSystem=$12    ; (Issued from paged ROMs, not the OS)
romServiceCallPollingInterrupt=$15
romServiceCallReserved=$18
romServiceCallAbsoluteHAZELWorkspaceClaim=$21
romServiceCallPrivateHAZELWorkspaceClam=$22
romServiceCallTopOfHAZELWorkspace=$23
romServiceCallCountDynamicHAZELWorkspace=$24
romServiceCallRequestFSInfo=$25
romServiceCallCloseAllOpenFiles=$26
romServiceCallInformReset=$27
romServiceCallUnknownCONFIG=$28
romServiceCallUnknownSTATUS=$29
romServiceCallLanguageChange=$2a
romServiceCallTubeSystemPostInitialisation=$FE    ;
romServiceCallTubeMainInitialisation=$FF    ;

;-------------------------------------------------------------------------

fscOPT=0
fscCheckEOF=1
fscStarSlash=2
fscUnknownCommand=3
fscStarRun=4
fscStarCat=5
fscNewFS=6
fscFileHandleRange=7
fscStarCommand=8
fscStarEX=9
fscStarINFO=10
fscRUNLibrary=11
fscRENAME=12
                
;-------------------------------------------------------------------------

bufferNumberKeyboard=0          ;
bufferNumberRS423Input=1        ;
bufferNumberRS423Output=2       ;
bufferNumberPrinter=3           ;
bufferNumberSound0=4            ; Noise channel
bufferNumberSound1=5            ;
bufferNumberSound2=6            ;
bufferNumberSound3=7            ;
; bufferNumberSpeech=8            ;
bufferNumberHighest=8           ;

;-------------------------------------------------------------------------

uservIndex=0
brkvIndex=1
irq1vIndex=2
irq2vIndex=3
clivIndex=4
bytevIndex=5
wordvIndex=6
wrchvIndex=7
rdchvIndex=8
filevIndex=9
argsvIndex=10
bgetvIndex=11
bputvIndex=12
gbpbvIndex=13
findvIndex=14
fscvIndex=15
eventvIndex=16
uptvIndex=17
netvIndex=18
vduvIndex=19
keyvIndex=20
insvIndex=21
remvIndex=22
cnpvIndex=23
ind1vIndex=24
ind2vIndex=25
ind3vIndex=26

                
vectors=$200
USERV=vectors+uservIndex*2
BRKV=vectors+brkvIndex*2
IRQ1V=vectors+irq1vIndex*2
IRQ2V=vectors+irq2vIndex*2
CLIV=vectors+clivIndex*2
BYTEV=vectors+bytevIndex*2
WORDV=vectors+wordvIndex*2
WRCHV=vectors+wrchvIndex*2
RDCHV=vectors+rdchvIndex*2
FILEV=vectors+filevIndex*2
ARGSV=vectors+argsvIndex*2
BGETV=vectors+bgetvIndex*2
BPUTV=vectors+bputvIndex*2
GBPBV=vectors+gbpbvIndex*2
FINDV=vectors+findvIndex*2
FSCV=vectors+fscvIndex*2
EVENTV=vectors+eventvIndex*2
UPTV=vectors+uptvIndex*2
NETV=vectors+netvIndex*2
VDUV=vectors+vduvIndex*2
KEYV=vectors+keyvIndex*2
INSV=vectors+insvIndex*2
REMV=vectors+remvIndex*2
CNPV=vectors+cnpvIndex*2
IND1V=vectors+ind1vIndex*2
IND2V=vectors+ind2vIndex*2
IND3V=vectors+ind3vIndex*2

extendedVectorSpace=$d9f
                
serialRegisterULACopy=$0282
                
key_space=$62
key_comma=$66
key_minus=$17
key_stop=$67
key_slash=$68
key_0=$27
key_1=$30
key_2=$31
key_3=$11
key_4=$12
key_5=$13
key_6=$34
key_7=$24
key_8=$15
key_9=$26
key_colon=$48
key_semicolon=$57
key_at=$47
key_a=$41
key_b=$64
key_c=$52
key_d=$32
key_e=$22
key_f=$43
key_g=$53
key_h=$54
key_i=$25
key_j=$45
key_k=$46
key_l=$56
key_m=$65
key_n=$55
key_o=$36
key_p=$37
key_q=$10
key_r=$33
key_s=$51
key_t=$23
key_u=$35
key_v=$63
key_w=$21
key_x=$42
key_y=$44
key_z=$61
key_left_square_bracket=$38
key_backslash=$78
key_right_square_bracket=$58
key_caret=$18
key_underline=$28
key_escape=$70
key_tab=$60
key_caps_lock=$40
key_ctrl=$1
key_shift_lock=$50
key_shift=$0
key_delete=$59
key_copy=$69
key_return=$49
key_up=$39
key_down=$29
key_left=$19
key_right=$79
key_f0=$20
key_f1=$71
key_f2=$72
key_f3=$73
key_f4=$14
key_f5=$74
key_f6=$75
key_f7=$16
key_f8=$76
key_f9=$77

fsInfoBlock: .struct
name: .fill 8
minHandle: .fill 1
maxHandle: .fill 1
fsNumber: .fill 1
                .ends

osgbpbBlock: .struct
handle: .fill 1
addr: .fill 4
numBytes: .fill 4
ptr: .fill 4
                .ends

                ; NAUG p260
                .virtual $dc00
hazel: .block
commandLine:                    ;dc00
                .fill 256
ddxx:                           ;dd00
                .fill 256
dexx:
                .fill 256
currentFS:                      ;df00
                .fill 1
activeFS:                       ;df01
                .fill 1
libFS:                          ;df02
                .fill 1
currentFSROM:                   ;df03
                .fill 1
commandLinePointer:             ;df04
                .fill 2

                ; 17 info blocks in total, but everything is relative
                ; to the 0th, so there's only a need to instantiate a
                ; struct for that one. Don't think 64tass handles
                ; arrays of structs anyway.
fsInfoBlocks:   .dstruct fsInfoBlock ;df06
                .fill 16*size(fsInfoBlock)
fsInfoBlocksTerminator:         ;dfc1
                ; space reserved for the 0 terminator when the full
                ; set of info blocks are filled.
                .fill 1
fsFlags: .block                 ;dfc2
                .fill 1
useASCII=$80
isAPPEND=$80
noLineNumbers=$40
                .bend
lineNumberBCD:                  ;dfc3
                .fill 2
lastCharPrinted:                ;dfc5
                .fill 1
tempFSFlag:                     ;dfc6
                .fill 1
moveOSGBPB: .dstruct osgbpbBlock ;dfc7
moveSrcHandle:                  ;dfd4
                .fill 1
moveDestHandle:                 ;dfd5
                .fill 1
moveBufferMSB:                  ;dfd6
                .fill 1
moveNumPages:                   ;dfd7
                .fill 1
moveDestName:                   ;dfd8
                .fill 2
activeFSCV:                     ;dfda
                .fill 2
oldACCCON:                      ;dfdc
                .fill 1
hasACCCONChanged:                ;dfdd
                .fill 1
                .bend
                .endv

;-------------------------------------------------------------------------
;
; VDU variables
; 
; MasRef E.4-1
;
VDUVariables: .struct
; &00 2 Graphics window left column. (p)
graphicsWindowPixelsLeft: .fill 2
; &02 2 Graphics window bottom row. (p)
graphicsWindowPixelsBottom: .fill 2
; &04 2 Graphics window right column. (p)
graphicsWindowPixelsRight: .fill 2
; &06 2 Graphics window top row. (p)
graphicsWindowPixelsTop: .fill 2
; &08 1 Text window left column.
textWindowLeft: .fill 1
; &09 1 Text window bottom row.
textWindowBottom: .fill 1
; &0A 1 Text window right column.
textWindowRight: .fill 1
; &0B 1 Text window top row.
textWindowTop: .fill 1
; &0C 2 Graphics origin X coordinate. (e)
graphicsWindowOriginX: .fill 2
; &0E 2 Graphics origin Y coordinate. (e)
graphicsWindowOriginY: .fill 2
; &10 2 Graphics cursor X coordinate. (e)
graphicsCursorPositionX: .fill 2
; &12 2 Graphics cursor Y coordinate. (e)
graphicsCursorPositionY: .fill 2
; &14 2 Previous graphics cursor X coordinate. (p)
oldGraphicsCursorPixelsX: .fill 2
; &16 2 Previous graphics cursor Y coordinate. (p)
oldGraphicsCursorPixelsY: .fill 2
; &18 1 Text cursor X coordinate (from left of screen) when not cursor editing. When cursor editing, normally the input cursor X coordinate, but the output cursor X coordinate within an “unknown PLOT codes” routine.
textCursorXPosition: .fill 1
; &19 1 Text cursor Y coordinate (from top of screen) when not cursor editing. When cursor editing, normally t.lsthe input cursor Y coordinate, but the output cursor Y coordinate within an “unknown PLOT codes” routine.
textCursorYPosition: .fill 1
; &1A 1 Y produced by GADDR (see next section) so that (ZMEMG),Y addresses the correct byte.
graphicsCursorVerticalOffsetInCell: .fill 1
; &1B–&23 VDU queue: &23 contains last byte of queue, other bytes immediately precede it.
queueSize=9
queueBegin: .fill queueSize
queueEnd:
; &24 2 Graphics cursor X coordinate. (p)
graphicsCursorPixelsX: .fill 2
; &26 2 Graphics cursor Y coordinate. (p)
graphicsCursorPixelsY: .fill 2
; &28–&49 Workspace. But variable &38 must not be used in a Teletext mode (mode 7 or 135).
workspace28:
                .fill 1
workspace29:
                .fill 1
workspace2A:
                .fill 1
workspace2B:
                .fill 1
workspace2C:
                .fill 1
workspace2D:
                .fill 1
workspace2E:
                .fill 1
workspace2F:
                .fill 1
workspace30:
                .fill 1
workspace31:
                .fill 1
workspace32:
                .fill 1
workspace33:
                .fill 1
workspace34:
                .fill 1
workspace35:
                .fill 1
workspace36:
                .fill 1
workspace37:
                .fill 1
workspace38:
                .fill 1
workspace39:
                .fill 1
workspace3A:
                .fill 1
workspace3B:
                .fill 1
workspace3C:
                .fill 1
workspace3D:
                .fill 1
workspace3E:
                .fill 1
workspace3F:
                .fill 1
workspace40:
                .fill 1
workspace41:
                .fill 1
workspace42:
                .fill 1
workspace43:
                .fill 1
workspace44:
                .fill 1
workspace45:
                .fill 1
workspace46:
                .fill 1
workspace47:
                .fill 1
workspace48:
                .fill 1
workspace49:
                .fill 1
; &4A 2 Address at which the 6845 is to display the text cursor.
textCursorCRTCAddress: .fill 2
; &4C 2 Number of bytes in a character row of the text window.
textWindowWidthInBytes: .fill 2
; &4E 1 Most significant byte of address of first byte of screen memory.
startScreenAddressHighByte: .fill 1
; &4F 1 Number of bytes in a character.
bytesPerCharacter: .fill 1
; &50 2 Address of byte in top left corner of screen display.
screenTopLeftAddress: .fill 2
; &52 2 Number of bytes in a character row of the whole screen.
bytesPerCharacterRow: .fill 2
; &54 1 Most significant byte of number of bytes of screen memory.
screenSizeHighByte: .fill 1
; &55 1 Current screen mode (in range 0–7, i.e. without regard to ‘shadowing’).
currentScreenMODE: .fill 1
; &56 1 Memory mode: 0 for 20K modes, 1 for 16K modes, 2 for 10K modes, 3 for 8K modes, 4 for 1K modes.
currentScreenMODEGroup: .fill 1
; &57 1 Foreground text colour mask.
foregroundTextColour: .fill 1
; &58 1 Background text colour mask.
backgroundTextColour: .fill 1
; &59 1 0 if plotting graphics foreground, 8 if plotting graphics background.
graphicsPlotState: .fill 1
; &5A 1 Current graphics plot mode (usually set to one of following two reduced mod 16).
graphicsPlotMode: .fill 1
; &5B 1 Current graphics foreground plot mode (as set by VDU 18).
foregroundGCOLMode: .fill 1
; &5C 1 Current graphics background plot mode (as set by VDU 18).
backgroundGCOLMode: .fill 1
; &5D 2 Address of routine to process current VDU sequence.
jumpVector: .fill 2
; &5F 1 Value for 6845 register 10 to revert to on leaving cursor editing.
lastCursorStartRegisterValue: .fill 1
; &60 1 (Number of logical colours)−1 (0 if Teletext).
numberOfLogicalColoursMinusOne: .fill 1
; &61 1 (Number of pixels/byte)−1 (0 if not graphics).
pixelsPerByteMinusOne: .fill 1
; &62 1 Mask for leftmost pixel in a byte.
colourMaskLeft: .fill 1
; &63 1 Mask for rightmost pixel in a byte.
colourMaskRight: .fill 1
; &64 1 Output cursor X coordinate when cursor editing, but input cursor X coordinate when cursor editing and inside an ‘unknown PLOT codes’ routine.
editCursorXPosition: .fill 1
; &65 1 Output cursor Y coordinate when cursor editing, but input cursor Y coordinate when cursor editing and inside an ‘unknown PLOT codes’ routine.
editCursorYPosition: .fill 1
; &66 1 Cursor control flags (as set by VDU 23 16).
cursorFlags: .block
                .fill 1
; MasRef E.3-18
noSpecialVDU5Actions=$40
noMoveCursorAfterPrint=$20
noVerticalScroll=$10
swapAxes=$08                    ;if set, X=vert; if clear, X=horiz
invertVertical=$04              ;if set, vert=up; if clear, vert=down
invertHorizontal=$02            ;if set, horiz=left; if clear, horiz=right
scrollProtect=$01
                .endblock
; &67 1 Dot pattern (as set by VDU 23 6).
dotPattern: .fill 1
; &68 1 Current state of dot pattern.
dotPatternState: .fill 1
; &69 1 0 if colour being plotted is solid, non-zero if colour is an ECF
isColourECF: .fill 1
; &6A 1 0 if graphics foreground colour is solid, non-zero if foreground colour is an ECF
isForegroundECF: .fill 1
; &6B 1 0 if graphics background colour is solid, non-zero if background colour is an ECF
isBackgroundECF: .fill 1
; &6C 1 Top bit set when cursor is in “column 81”.
column81: .fill 1
; &6D 1 Current graphics foreground colour (as set by VDU 18).
foregroundGraphicsColour: .fill 1
; &6E 1 Current graphics background colour (as set by VDU 18)
backgroundGraphicsColour: .fill 1
; &6F–&7E Software copy of the current palette.
currentPalette: .fill 16
; &7F 1 Reserved.
reserved: .fill 1
                .endstruct

                .virtual $300
vduv: .dstruct VDUVariables
                .endvirtual

; vduQueueItemAddr: .function index
;                 .cerror index<0||index>=vdu.queueSize,"bad VDU queue index"
;                 .endfunction vdu.queue+vdu.queueSize-1-index
                
; Presumed addresses in ANDY that don't happen to coincide with other
; labels.
; 
; MasRef E.4-5, MasRef F.6-10
;
; &8000-83FF  RAM  Soft key expansions buffer
; &8400–87FF  RAM  VDU workspace.
; &8800–07    RAM  ECF pattern 1 definition.
; &8808–0F    RAM  ECF pattern 2 definition.
; &8810–17    RAM  ECF pattern 3 definition.
; &8818–1F    RAM  ECF pattern 4 definition.
; &8820–27    RAM  Current foreground ECF pattern or solid colour.
; &8828–2F    RAM  Current background ECF pattern or solid colour.
; &8830–BF    RAM  VDU workspace.
; &88C0–FF    RAM  Reserved for future expansion.
; &8900–FF    RAM  Current definitions of characters &20–3F.
; &8A00–FF    RAM  Current definitions of characters &40–5F.
; &8B00–FF    RAM  Current definitions of characters &60–7F.
; &8C00–FF    RAM  Current definitions of characters &80–9F.
; &8D00–FF    RAM  Current definitions of characters &A0–BF.
; &8E00–FF    RAM  Current definitions of characters &C0–DF.
; &8F00–FF    RAM  Current definitions of characters &E0–FF.

                .virtual $8000
andy: .block
                .fill $800
ecfPatterns:
ecfPattern1: .fill 8
ecfPattern2: .fill 8
ecfPattern3: .fill 8
ecfPattern4: .fill 8
fgECFPattern: .fill 8
bgECFPattern: .fill 8
                .fill 208
softCharacterDefinitions:
                .fill (256-32)*8
                .cerror (<andy.softCharacterDefinitions)!=0,"Soft character definitions must be page aligned"
                .cerror *!=$9000,"ANDY is the wrong size"
                .endblock
                .endvirtual
                
                
L8000=$8000
L8001=$8001
L8002=$8002
L8004=$8004
L8010=$8010
L8011=$8011
L8012=$8012
                ;l8011=$8011
                ;l8012=$8012
L8021=$8021

; see $d40d, $d4ae
;
; (suspect these are actually references to $8840-$104 and $8848-$104)
L873C=$873c
L8744=$8744
                
L8400=$8400
L8500=$8500
L8600=$8600
L8700=$8700
L8786=$8786
L8787=$8787
L8788=$8788
L8789=$8789
L87F8=$87f8
L87FF=$87FF
L8800=$8800
L8803=$8803
L8804=$8804
L8820=$8820
L8836=$8836
L8837=$8837
L883C=$883C
L8840=$8840
L8844=$8844
L8845=$8845
L883F=$883f
L883E=$883e
L8841=$8841
L8842=$8842
L8843=$8843
L8834=$8834
L8835=$8835
L883D=$883D
L8846=$8846
L8833=$8833
L881E=$881E
L8849=$8849
L8830=$8830
L8831=$8831
L8848=$8848
L8847=$8847
L8832=$8832

                ; entry points in the View bank
XBA00=$BA00
XBA67=$BA67
XBEBE=$BEBE

                ; written to during startup
LFE8E=$fe8e

                .virtual $00
tubeLanguageHostAddr: .fill 2
                .endv
                
                .virtual $12
tubeTransferAddr: .fill 2
tubeClaimed: .fill 1            ;bit 7 clear if tube claimed
tubeClaimantID: .fill 1
                .endv

                .virtual $53
tubeLanguageParasiteAddr: .fill 4
                .endv




                
; MasRef E.4-4
                .virtual $d0
STATE: .block
                .fill 1
                ; D.2-32
isPrinterEnabled=$01
isScrollingDisabled=$02
isPagedScrolling=$04
isTextWindow=$08
isShadowMode=$10
isVDU5=$20
isCursorEditing=$40
isVDU21=$80
                .bend
ZMASK: .fill 1                       ;Pixel mask
ZORA: .fill 1                        ;Text OR mask
ZEOR: .fill 1                        ;Text EOR mask
ZGORA: .fill 1                       ;Graphics OR mask
ZGEOR: .fill 1                       ;Graphics EOR mask
ZMEMG: .fill 2                       ;Graphics pointer
ZMEMT: .fill 2                       ;Text pointer
ZTEMP: .fill 2                       ;Temporary space
ZTEMPB: .fill 2                      ;Temporary space
ZTEMPC: .fill 2                      ;Temporary space
ZTEMPD: .fill 2                      ;Temporary space

                .endv

vduWriteCursor=$d8     

nmiEntryPoint=$d00
                
;-------------------------------------------------------------------------

beword .macro value
                .byte >\value
                .byte <\value
                .endm
                
;-------------------------------------------------------------------------

                .include "terminal.s65"
                .include "mos.s65"
                