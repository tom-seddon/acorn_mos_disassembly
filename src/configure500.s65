byte2: .macro value,value350
                .if version==350
                .byte \value350
                .else
                .byte \value
                .endif
                .endmacro

                ; Metadata layout

                ; +0
                
                ;   7   6   5   4   3   2   1   0
                ; +---+---+---+---+---+---+---+---+
                ; |   |V0 |MaskCount  |MatchValue |
                ; +---+---+---+---+---+---+---+---+

                ; If V0 is clear, this field is actually the address
                ; of a routine.
                ; 
                ; V0 is set if MatchValue is to be used.
                ; 
                ; MatchValue is used when processing *STATUS - if the
                ; configuration byte's bottom 3 bits match the
                ; MatchValue, 
                ;
                ; MaskCount 
                ;

                ; +1
                
                ;   7   6   5   4   3   2   1   0
                ; +---+---+---+---+---+---+---+---+
                ; |N1 |RTCByteIndex   |ShiftCount |
                ; +---+---+---+---+---+---+---+---+
                ;
                ; N1 = tested by L8ADF

                ; The RTC byte indexes in the table are actually
                ; offset.
                .if version==350
rtcByteIndexOffset=cmosBytesOffset+CMOSBytes.fileServerStationNumber
                .else
rtcByteIndexOffset=cmosBytesOffset+CMOSBytes.defaultROMs
                .endif

                

configureTable: .block
                .text "."
                .beword printConfigureOrStatusHeader-1
baud:
                .text "Baud"
baudMetadata:
                .byte $D0
                .byte2 $d2,$d2|$20
boot:
                .text "Boot"
                .byte $C1
                .byte2 $5c,$5c|$20
                .text "Caps"
                .byte $D4
                .byte2 $33,$33^$60
                .if olivetti
                .text "Country"
                .byte $f8
                .byte $f0
                .endif
                .text "Data"
dataMetadata:
                .byte $D0
                .byte2 $dd,$dd|$20
                .text "Delay"
                .byte $F8
                .byte2 $b8,$b8^$60
                .text "Dir"
lastDirChar=*-1
                .byte $C0
                .byte2 $36,$36^$60
                .if version==350
                .text "Ex"
lastExChar=*-1
                .text "Tube"
                .byte $c1
                .byte $7a
                .endif
                .text "Fdrive"
                .byte $D0
                .byte2 $b0,$b0^$60
                .text "File"
fileMetadata:
                .byte $D8
                .byte2 $80,$80|$20
                .if version==350
                .text "Floppy"
                .byte $c1
                .byte $57
                .endif
                .if version==350
                .text "Hard"
                .byte $c0
                .byte $57
                .endif
ignore:
                .text "Ignore"
                .beword handlePrinterIgnoreChar-1
                .if version==350
                .text "In"
lastInChar=*-1
                .text "Tube"
                .byte2 $b8,$c0
                .byte2 $a4,$7a
                .endif
                .text "Lang"
langMetadata:
                .byte $D8
                .byte2 $84,$84|$20
                .text "Loud"
                .byte $C1
                .byte2 $59,$59|$20
                .text "Mode"
modeMetadata:
                .byte $D8
                .byte2 $A8,$a8^$60
                .text "NoBoot"
                .byte $C0
                .byte2 $5C,$5c|$20
                .text "NoCaps"
                .byte $D2
                .byte2 $33,$33^$60
                .text "NoDir"
lastNoDirChar=*-1
                .byte $C1
                .byte2 $36,$36^$60
                .text "NoScroll"
                .byte $C1
                .byte2 $5B,$5b|$20
                .if version==350
                .text "NoTube"
                .byte $c0
                .byte $70
                .endif
                .text "Print"
printMetadata:
                .byte $D0
                .byte2 $D5,$d5|$20
                .text "Quiet"
                .byte $C0
                .byte2 $59,$59|$79
                .text "Repeat"
                .byte $F8
                .byte2 $C0,$c0|$20
                .text "Scroll"
                .byte $C0
                .byte2 $5B,$5b|$20
                .text "Sh"
lastShChar=*-1
                .text "Caps"
                .byte $D1
                .if version==350
                .byte $53
                .else
                .byte $33
                .endif
                .if version==350
                .text "Tube"
                .byte $c1
                .byte $70
                .endif
                .if version>=500
                .text "Proportional"
                .byte $C0
                .byte $6D
                .endif
                .if version>=500
                .text "Switched"
                .byte $C1
                .byte $6D; m
                .endif
                .if version>=500
                .text "Stick"
                .byte $D8
                .byte $E8
                .endif
                .text "TV"
                .if version==350
                .byte $87
                .byte $31
                .else
                .byte $89
                .if version<510
                .byte $64; d
                .else
                .if olivetti
                .byte $b5
                .else
                .byte $a1
                .endif
                .endif
                .endif
                .byte 0
L8603:
                .if version==350
                .byte $00
                .byte $71
                .else
                .byte 8
                .byte $51; Q
                .endif
L8605:
                .byte $18
                .if version==350
                .byte $4C
                .else
                .byte $2C; ,
                .endif
ectory:
                .text "ectory",$ff
                .if version==350
ternal:
                .text "ternal",$ff
                .endif
ift:
                .text "ift",$ff
                
textSnippetInsertPointOffsets:
                .text lastDirChar-configureTable   ;"Directory"
                .byte lastNoDirChar-configureTable ;"NoDirectory"
                .if version==350
                .byte lastExChar-configureTable    ;"External"
                .byte lastInChar-configureTable    ;"Internal"
                .endif
                .byte lastShChar-configureTable    ;"Shift"
textSnippetsCount=*-textSnippetInsertPointOffsets
                
textSnippetOffsets:
                .byte configureTable.ectory-configureTable
                .byte configureTable.ectory-configureTable
                .if version==350
                .byte configureTable.ternal-configureTable
                .byte configureTable.ternal-configureTable
                .endif
                .byte configureTable.ift-configureTable
                .cerror *-textSnippetOffsets!=textSnippetsCount

                .endblock
                
;-------------------------------------------------------------------------

starCONFIGUREOrStarSTATUS:
                asl a
                adc #$80

                ; *STATUS: A=1 V=1 C=1
                ; *CONFIGURE: A=0 V=0 C=1
                php
                lda #<configureTable
                sta oscliWorkspace.tablePtr+0
                lda #>configureTable
                sta oscliWorkspace.tablePtr+1
                ldx #$FF
                jsr mos.skipSpacesAndCheckForCRInStringInput
                bne L886C
                jsr fetchCommandTableByte

L886C:
                bit mos.valueFF ; V=1 to indicate 2-byte metadata
                jsr findCommand
                bcs foundCONFIGOrSTATUSTopic
                plp
                jsr unknownCONFIGOrStatus
                bne L88EB
                rts

;-------------------------------------------------------------------------

foundCONFIGOrSTATUSTopic:
                jsr mos.skipSpacesAndCheckForCRInStringInput
                plp
                bvc L8884
                jsr L895D

;-------------------------------------------------------------------------

L8884:
                lda configureTable,x
                bit #$40
                bne L8895       ;taken if V0 clear
                pha
                lda configureTable+1,x
                pha
                lda (stringInputBufferAddress),y
                eor #$D
                rts

;-------------------------------------------------------------------------

L8895:
                and #7
                .if version==350
                dec configureTable+1,x
                .else
                inc configureTable+1,x
                .endif
                bvs L88D9
                bcs print1NumberHelp
                bmi L88A5
                jsr L895D
                bra jmpL88EE

;-------------------------------------------------------------------------

L88A5:
                phx
                jsr L89B5
                plx
                cpx #7
                bne L88B4
                tay
                bne L88B3
                lda #7

L88B3:
                dec a

L88B4:
                cpx #configureTable.modeMetadata-configureTable
                bne L88C1
                bit #$78
                bne L88EB
                tay
                bpl L88C1
                eor #$88

L88C1:
                jsr getMaskCount
                cmp maskByBitCount,y
                beq jmpL88EE
                bcs L88EB


jmpL88EE:
                jmp L88EE

;-------------------------------------------------------------------------

print1NumberHelp:
                bpl L88D8
                jsr alwaysPrintFollowingMessage
                .text "<D>",13,0
L88D8:
                rts

;-------------------------------------------------------------------------

L88D9:
                bmi printDecimalConfigurationByte
                lda configureTable+1,x
                clc
                jmp L8ADA

;-------------------------------------------------------------------------

printDecimalConfigurationByte:
                jsr readConfigurationByte

printDecimalByteAThenNewLine:
                jsr printDecimalByteA
                jmp OSNEWL

;-------------------------------------------------------------------------

L88EB:
                jmp mos.badCommandError

;-------------------------------------------------------------------------

L88EE: .block
                sta $B0
                jsr getMaskCount
                lda maskByBitCount,y
                jsr getShiftCount
                bra shift
shiftLoop:
                asl a
                asl $B0

shift:
                dey
                bpl shiftLoop
                sta $B1
                jsr getRTCByteIndex
                jsr readRTCByte
                ora $B1
                eor $B1
                ora $B0
                tay
                .endblock
                
jmpWriteRTCByte:
                jmp writeRTCByte

;-------------------------------------------------------------------------

handlePrinterIgnoreChar:
                bvs printDefaultPrinterIgnoreChar ;taken if *STATUS
                bcs print1OptionalNumberHelp
                beq L8927
                jsr L89B5
                phx
                lda #0
                jsr L8929
                ply
                ldx #$E+cmosBytesOffset
                bra jmpWriteRTCByte

;-------------------------------------------------------------------------

L8927:
                lda #1

;-------------------------------------------------------------------------

L8929:
                ldx #configureTable.L8603-configureTable
L892B:
                bra jmpL88EE

;-------------------------------------------------------------------------

printDefaultPrinterIgnoreChar:
                jsr readUsePrinterIgnoreChar
                bcc gotPrinterIgnoreChar
                jsr alwaysPrintFollowingMessage
                .text "No Ignore",13,0
                rts

;-------------------------------------------------------------------------

gotPrinterIgnoreChar:
                ldx #CMOSBytes.printerIgnoreChar+cmosBytesOffset
                jsr readRTCByte
L8946:
                bra printDecimalByteAThenNewLine

;-------------------------------------------------------------------------

print1OptionalNumberHelp:
                jsr alwaysPrintFollowingMessage
                .text "[<D>]",13,0
                rts

;-------------------------------------------------------------------------

L8953:

                jsr parseNumberFromString

L8956:
                bcc L88EB
                txa
                cmp #$10

L895B:
                bcs L88EB

L895D:
                pha
                jsr mos.skipSpacesAndCheckForCRInStringInput

L8961:
                bne L88EB
                pla
                rts

;-------------------------------------------------------------------------

                bvs L8996
                bcs printTVHelp
                beq L8992
                jsr parseNumberFromString
                bcc L8956
                cpx #$FC
                bcs L8978
                cpx #4
                bcs L895B

L8978:
                txa
                asl a
                sta $B1
                ldx #0
                jsr mos.LF30A
                beq L898B
                jsr L89B5
                cmp #2
                bcs L895B
                tax

L898B:
                txa
                ora $B1

L898E:
                ldx #configureTable.L8605-configureTable
                bra L892B

;-------------------------------------------------------------------------

L8992:
                lda #0
                bra L898E

;-------------------------------------------------------------------------

L8996:
                jsr L8BD6
                jsr printDecimalByteY
                lda #','
                jsr OSWRCH
                txa
                bra L8946

;-------------------------------------------------------------------------

printTVHelp:
                jsr alwaysPrintFollowingMessage
                .text "[<D>[,<D>]]",13,0
                rts

;-------------------------------------------------------------------------

L89B5:
                jsr parseNumberFromString
                bcc L8956
                txa
                bra L895D


;-------------------------------------------------------------------------

printConfigureOrStatusHeader: .block
                bne L8961
                php
                phy
                jsr alwaysPrintFollowingMessage
                .text "Configuration ",0
                bvs printStatusHeader ;taken if *STATUS
                jsr alwaysPrintFollowingMessage
                .text "options:",13,0
                bra printItems
printStatusHeader:
                jsr alwaysPrintFollowingMessage
                .text "status:",13,0
printItems:
                sec
                jsr L8ADA
                ply
                plp
                php
                jsr unknownCONFIGOrStatus
                plp
                bvs done        ;taken if *STATUS
                jsr alwaysPrintFollowingMessage
                .text "Where:",13
                .text "D is a decimal number, or",13
                .text "a hexadecimal number preceded by &",13
                .text "Items within [ ] are optional",13
                .byte 0
done:
                rts
                .endblock
                
;-------------------------------------------------------------------------
;
; Read configuration byte, given offset of metadata in the configure
; table.
;
; Entry:
;
; X = offset of metadata in the configure table
;
; Exit:
;
; A = value read
;
; Preserves: X/Y/P

                .if version==350
setTSTAndReadConfigurationByte:
                jsr mos.callWithTST
                .endif
readConfigurationByte: .block
                php
                phy
                phx
                jsr getRTCByteIndex ;
                jsr readRTCByte
                plx
                jsr getShiftCount
                bra shift

;-------------------------------------------------------------------------

shiftLoop:
                lsr a

shift:
                dey
                bpl shiftLoop
                
                jsr getMaskCount
                and maskByBitCount,y
                cpx #configureTable.baudMetadata-configureTable
                bne gotMaskedByte
                inc a

gotMaskedByte:
                ; If retrieving the MODE value, rearrange things so
                ; the shadow modes are 128-135.
                cpx #configureTable.modeMetadata-configureTable
                bne done        ;taken if not MODE
                bit #CMOSBytes.defaults0.defaultSHADOWMask ;test shadow bit
                beq done                                   ;taken if not shadow mode
                eor #$80|CMOSBytes.defaults0.defaultSHADOWMask ;turn mode|flag into mode|$80

done:
                ply
                plp
                rts
                .endblock
                
;-------------------------------------------------------------------------
;
; Find command in command table.
;
; Entry:
;
; (stringInputBufferAddress),y = input
; oscliWorkspace.tablePtr; = address of command table
; V = 0 if commands have 4 bytes of metadata
;     1 if commands have 2 bytes of metadata
;
; Exit:
;
; C=0 = no match
; 
; C=1 = match;
;       A holds 1st byte of metadata
;       oscliWorkspace.tablePtr; = address of 2nd and following metadata bytes
;       (stringInputBufferAddress),y = input following command
;
; Preserves: X/V

findCommand: .block
                sty $E6         ;save Y
                bra checkInput       ;get going...

checkLetter:
                eor (oscliWorkspace.tablePtr)
                and #$DF
                bne noMatch    ; taken if char didn't match
                jsr fetchCommandTableByte
                iny

checkInput:
                lda (stringInputBufferAddress),y
                jsr mos.isLetter
                bcc checkLetter ; taken if letter
                
                ; Non-letter input means potentially end of command
                ; name.
                lda (oscliWorkspace.tablePtr) ; next table byte
                bmi commandMatch ; taken if end of string - a match
                lda (stringInputBufferAddress),y
                cmp #'.'        ; '.' is the abbreviation char
                beq abbreviationMatch ;taken with C=1 if match

noMatch:
                clc             ;indicate no match
                ldy $E6         ;restore Y
                dey             ;compensate for upcoming iny

abbreviationMatch:
                iny             ; skip the '.'

findCommandMetadataLoop:
                jsr fetchCommandTableByte
                beq rts8ACD
                bpl findCommandMetadataLoop ; keep looping through chars if necessary
                bcs rts8ACD                 ;taken if it was a match
                jsr fetchCommandTableByte   ;discard 2nd metadata byte
                bvs checkInput ; if V=1, 2-byte metadata; if V=0, 4-byte metadata
                jsr fetchCommandTableByte ;discard 3rd metadata byte
                jsr fetchCommandTableByte ;discard 4th metadata byte
                bra checkInput

;-------------------------------------------------------------------------

commandMatch:
                jsr fetchCommandTableByte
                sec

rts8ACD:
                rts
                .endblock

;-------------------------------------------------------------------------
;
; Fetch byte from command table with postincrement.
;
; Entry:
;
; oscliWorkspace.tablePtr; = address of byte to fetch
;
; Exit:
;
; A = byte fetched
; oscliWorkspace.tablePtr; incremented
; 
; Preserves: X/Y/C/V

fetchCommandTableByte:
                inx
                lda (oscliWorkspace.tablePtr)
                pha
                inc oscliWorkspace.tablePtr+0
                bne L8AD8
                inc oscliWorkspace.tablePtr+1

L8AD8:
                pla
                rts

;-------------------------------------------------------------------------
;
; Print configure table items.
;
; Entry:
;
; C = ???
;
; V=0 if *CONFIGURE; V=1 if *STATUS
; 
L8ADA: .block
                pha
                ldy #configureTable.baud-configureTable
                ldx #(configureTable.baud-configureTable)-1

loop:
                inx
                lda configureTable,x ;get name byte
                beq done            ;all done if 0
                bpl loop            ;keep going until end of name
                                     ;reached
                bvc L8B08            ;taken if *CONFIGURE

                ; A = metadata byte 0
                and #$40
                beq L8AFD       ;taken if V0 clear
                
                lda configureTable+1,x ;A = metadata byte 1
                bmi L8AFD              ;taken if N1 set

                jsr readConfigurationByte ;Read the actual value
                eor configureTable,x      ;eor with MatchValue
                and #7                    ;A=0 if value matches MatchValue
                bne next                  ;taken if value isn't MatchValue
                dec a                     ;A=$ff

L8AFD:
                bcs L8B08       ;
                bpl next        ;
                pla
                pha
                eor configureTable+1,x
                bne next

L8B08:
                php
                phx
                bvc printOrdinaryItem
                cpy #configureTable.ignore-configureTable
                bne printOrdinaryItem
                jsr readUsePrinterIgnoreChar
                bcs L8B30

printOrdinaryItem:
                ldx #9
                jsr printConfigureTableString
                and #$40
                beq printSpaces       ;taken if V0 clear
                lda configureTable+1,y
                bmi printSpaces ;taken if N1 set

                ; V0 set, N1 clear = newline and next item
                jsr OSNEWL
                bra next2

printSpacesLoop:
                lda #' '
                jsr OSWRCH

printSpaces:
                dex
                bpl printSpacesLoop

L8B30:
                plx
                plp
                php
                phx
                jsr L8884

next2:
                plx
                plp

next:
                inx             ;point X just before next item
                txa
                tay
                iny             ;point Y at next item
                bra loop

done:
                pla
                rts
                .endblock

;-------------------------------------------------------------------------

printConfigureTableStringLoop:
                jsr OSWRCH      ;print char
                pha             ;save A (char to print)
                phy             ;save Y (table offset)
                tya             ;get table offset in A

                ; If we're at a snippet insert point, insert the
                ; snippet, recursively.
                ldy #configureTable.textSnippetsCount-1
findSnippetInsertPointLoop:
                cmp configureTable.textSnippetInsertPointOffsets,y
                bne nextSnippetInsertPoint

                ; Insert a snippet here. Load the new snippet's offset
                ; in Y and repeat.
                lda configureTable.textSnippetOffsets,y
                tay
                jsr printConfigureTableString
nextSnippetInsertPoint
                dey
                bpl findSnippetInsertPointLoop
                ply             ;restore Y (table offset)
                pla             ;restore A (char to print)
                iny             ;next byte in table
                dex             ;
                eor #$20
                ora configureTable,y
                and #%10100000
                bne printConfigureTableString

                ; if char case changed, but it wasn't the end of the
                ; string, pop a space in.
                lda #' '
                jsr OSWRCH
                dex
                .cerror *!=printConfigureTableString

;-------------------------------------------------------------------------
;
; Print string from configure table, with snippets inserted as
; required.
;
; Entry:
;
; X = column counter start value
; Y = configure table offset
;
; Exit:
; 
; A = item's metadata byte 0
; X decremented for each char printed
; 
printConfigureTableString:
                lda configureTable,y
                bpl printConfigureTableStringLoop
                rts


;-------------------------------------------------------------------------
;
; Issue ROM service call romServiceCallUnknownCONFIG ($28) or
; romServiceCallUnknownSTATUS ($29).
;
; Entry:
;
; C=1 for unknown CONFIG, or C=0 for unknown STATUS
;
; Exit:
;
; as per appropriate ROM service call
; 
unknownCONFIGOrStatus:
                lda #$14
                rol a           ;form $28 or $29 according to C
                tax
                jmp mos.makeROMServiceCall

;-------------------------------------------------------------------------
;
; Get actual RTC byte index for configure item, given offset in
; configure table to its metadata.
;
; Entry:
;
; X = offset into configure table for item's metadata
;
; Exit:
;
; X = index of byte read
;
; Preserves: Y/C

getRTCByteIndex:
                lda configureTable+1,x
                and #%01111000
                lsr a
                lsr a
                lsr a
                adc #rtcByteIndexOffset
                tax
                rts

;-------------------------------------------------------------------------
;
; Get shift count for configure item's data, given offset in configure
; table for its metadata.
;
; Entry:
;
; X = offset into configure table for item's metadata
;
; Exit:
;
; Y = shift count
;
; Preserves: A/X/C
; 
getShiftCount:
                pha
                lda configureTable+1,x
                and #%00000111
                tay
                pla
                rts


;-------------------------------------------------------------------------
;
; Get mask bit count for configure item's data, given offset in
; configure table for its metadata.
;
; Entry:
;
; X = offset into configure table for item's metadata
;
; Exit:
;
; Y = mask bit count, -1 (0 = 1 bits ... 7 = 8 bits)
;
; Preserves: A/X
; 
getMaskCount:
                pha
                lda configureTable,x; "."
                lsr a
                lsr a
                lsr a
                and #7
                tay
                pla
                rts

maskByBitCount:
                .byte %00000001
                .byte %00000011
                .byte %00000111
                .byte %00001111
                .byte %00011111
                .byte %00111111
                .byte %01111111
                .byte %11111111

;-------------------------------------------------------------------------
;
; Read the use printer ignore char flag.
;
; Exit:
;
; C=0 if using printer ignore char; C=1 if not.
;
; Preserves: Y

                .if version==350
setTSTAndReadUsePrinterIgnoreChar:
                jsr mos.callWithTST
                .endif
readUsePrinterIgnoreChar:
                phy
                jsr readDefaults2
                lsr a
                lsr a
                ply
                rts

;-------------------------------------------------------------------------
;
; Print decimal byte.
;
; Entry:
;
; (printDecimalByteA) A = value to print
;
; (printDecimalByteY) Y = value to print
; 
printDecimalByteY:
                tya
printDecimalByteA:
                sec             ;set leading zeros flag
                ldy #$FF        ;reset digit counter
                php             ;save leading zeros flag

countHundredsLoop:
                iny
                sbc #100
                bcs countHundredsLoop
                
                adc #100        ;put 0 back in the hundreds column
                plp             ;restore leading zeros flag
                jsr maybePrintHexDigit
                
                ldy #$FF        ;reset digit counter
                php             ;save leading zeros flag
                sec

countTensLoop:
                iny
                sbc #10
                bcs countTensLoop
                
                adc #10         ;put 0 back in the tens column
                plp             ;restore leading zeros flag
                jsr maybePrintHexDigit
                clc             ;always clear leading zeros flag for
                                ;units
                tay             ;Y=3rd digit
                
maybePrintHexDigit:
                pha
                tya
                bne L8BD0       ;always print if non-zero
                bcs L8BD4       ;print non-leading zeros
L8BD0:
                jsr printHexDigit
                clc             ;indicate non-zero digit printed
L8BD4:
                pla
                rts

;-------------------------------------------------------------------------

                .if version==350
setTSTAndL8BD6:
                jsr mos.callWithTST
                .endif
L8BD6:
                ldx #configureTable.L8605-configureTable
                jsr readConfigurationByte
                lsr a
                bit #%00000100
                beq L8BE2
                ora #%11111100
L8BE2:
                tay
                lda #0
                rol a
                tax
                rts

;-------------------------------------------------------------------------
