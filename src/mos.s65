; -*- comment-column:45; -*-

mos: .block

; VDU driver entry block
; ======================
LC000:                                       ; Read from VDU memory
                lda (ZMEMG),y
                rts
LC003:                                       ; Write to VDU memory
                sta (ZMEMG),y
                rts

; MasRef E.4-6
;
; JSR PLBYTE plots the mask held in ZMASK into the byte pointed to by
; (ZMEMG),y, using ZGORA and ZGEOR as colour masks. See GADDR below
; for an example of its use.
;
; PLBYTE uses ZTEMP as workspace and preserves X, Y, V and C.
PLBYTE: 
                jmp plbyteEntryPoint

; MasRef E.4-6
;
; JSR HPLOT plots a fast horizontal line in the current graphics
; colour or ECF and the current graphics mode (all as set by VDU 18)
; between two specified points. It is the low level primitive used by
; all the MOS area fill commands.
;
; On entry, two 4 byte areas at &300+X and &300+Y contain the
; coordinates of the two endpoints, in the standard
; lowX,highX,lowY,highY order. Should the Y coordinates differ, the Y
; coordinate of the line plotted is taken from the leftmost of the two
; points specified.
;
; Only portions of the line inside the graphics window are plotted.
; Subject to this, both endpoints of the line are plotted.
;
; HPLOT uses ZGORA, ZGEOR, ZMASK, ZMEMG, ZTEMP (but not ZTEMP+1),
; ZTEMPB, ZTEMPB+1, ZTEMPC and ZTEMPC+1 as workspace. No registers or
; flags are preserved.
HPLOT:                          
                jmp LDAE8

; MasRef E.4-6
;
; JSR EIGABS converts the 4 byte pair of external coordinates at
; &300+X where X>=2 (in standard lowX,highX,lowY,highY order) into the
; corresponding pair of pixel coordinates by offsetting by the
; graphics origin, then dividing by an appropriate power of 2.
;
; EIGABS uses ZTEMP as workspace, and corrupts all registers and
; flags.
EIGABS:
                jmp eigabsEntryPoint

; MasRef E.4-7
;
; JSR WIND windows the 4 byte pair of pixel coordinates (in standard
; lowX,highX,lowY,highY order) at &300+X, and returns a result in A
; according to its position with respect to the window:

; 9 | 8 | 10    
; --+---+---    
; 1 | 0 | 2     
; --+---+---    
; 5 | 4 | 6     

; WIND uses ZTEMP as workspace, preserves X and sets N and Z according
; to A.
WIND:
                jmp windEntryPoint

; MasRef E.4-7
;
; JSR GADDR addresses the pixel whose 4 byte pair of pixel coordinates
; (in standard lowX,highX,lowY,highY order) is at &300+X. GADDR should
; not be called without first ensuring (typically by means of WIND)
; that the point concerned does lie within the screen.
;
; GADDR initialises the following variables:
;
; . ZMEMG to the start of the page of memory containing the pixel.
;
; . Y and VDU variable &1A (i.e. location &31A) to contain the offset
; of the byte containing the pixel within this page – i.e. (ZMEMG),y
; points to the byte containing the pixel.
;
; . ZMASK to a mask indicating which bits of this byte constitute the
; pixel.
;
; . ZGORA and ZGEOR to the correct colour masks for the current
; graphics plot mode (found in VDU variable &5A) and colour/ECF
;
; . X to Y MOD 7, i.e. the scan line within a character row of the
; pixel.
;
; Additionally, GADDR uses ZTEMP as workspace and returns A=0, Z=1.
;
; An example of the use of PLBYTE, WIND and GADDR is the following
; code, which effectively re-implements the VDU 25 64–71 (plot a
; point) calls. It assumes that the routine addresses have been
; previously defined and that the graphics plot mode, etc. were set up
; by the VDU 25 code before the unknown PLOT codes vector was entered:

; .POINT
;  LDX #&20   ;Addresses new point within VDU queue, as
;             ;left on entry to the unknown PLOT codes
;             ;vector.
;  JSR WIND   ;Is the point inside the window?
;  BNE END    ;Return if not.
;  JSR GADDR  ;Address the point now we know it's on
;             ;screen.
;  JSR PLBYTE ;And plot the point.
; .END
;  RTS
GADDR:
                jmp gaddrEntryPoint

; MasRef E.4-8
;
; JSR IEG takes the internal pixel coordinates of the graphics cursor
; (in VDU variables &24–&27), converts it back to external coordinates
; and stores the result in VDU variables &10–&13.
;
; It should be called whenever the graphics code generates a new
; graphics cursor position (e.g. in the VDU drivers, it is called
; after a character is printed in VDU 5 mode). Its purpose is to make
; the two versions of the graphics cursor agree again, and thus
; prevent errors occurring with relative plots.
;
; IEG uses no page zero locations and corrupts all registers and
; flags.
IEG:
                jmp LC4DF

;-------------------------------------------------------------------------

LC018:                                       ; Fetch byte from ROM Y
                ldx $F4                      ; Get current ROM
                sty $F4                      ; Select ROM in Y
                sty ROMSEL
                lda ($F6)                    ; Get byte with ROM Y paged in
                jmp selectROMX                    ; Page in ROM X and return

LC024:
                jmp ($035D)                  ; C024= 6C 5D 03    l].

;-------------------------------------------------------------------------
;
; VDU driver entry point
;
; Output to VDU.
; 
outputToVDU:
                ldx vduQueueNegativeLength  ;get VDU queue length
                beq outputCharToVDU         ;taken if empty
                sta vduv.queueEnd-1-255,x   ;add to queue
                inc vduQueueNegativeLength  ;one more in the queue...
                beq outputQueueToVDU        ;taken if queue now filled
clc_rts_c034:
                clc

;-------------------------------------------------------------------------
;
; VDU 0 (&00) Null [MasRef E.3-1]
; VDU 6 (&06) Enable VDU driver [MasRef E.3-3]
; VDU 27 (&1B) Null [MasRef E.3-34]
;
vdu0EntryPoint:
vdu6EntryPoint:
vdu27EntryPoint:
rtsC035:
                rts                          ; C035= 60          `

;-------------------------------------------------------------------------

outputQueueToVDU:
                bit STATE
                bpl LC053              ;branch taken if not VDU21 mode

                ; ????
                ldy vduv.jumpVector+1
                cpy #>vdu1EntryPoint
                bne clc_rts_c034
                ldy vduv.jumpVector+0
                cpy #<vdu1EntryPoint
                bne clc_rts_c034
                
outputCharToPrinter:
                tax                          ;save char to print
                lda STATE
                lsr a                       ;C set if isPrinterEnabled
                bcc rtsC035 ;taken if printer disabled - VDU 1 then a no-op
                txa                          ;restore char to print
                clc
                .if version<350
                jmp LE8B9
                .else
                jmp LE2ED
                .endif

LC053:
                jsr stopCursorEditing                    ; C053= 20 FA C0     z@
                clc                          ; C056= 18          .
                bra LC0C0                    ; C057= 80 67       .g

outputCharToVDU:
                jsr stopCursorEditing                    ; C059= 20 FA C0     z@
                bvc LC06D             ;taken if not previously editing
                bmi LC06D             ;taken if VDU 21
                cmp #$0D
                bne LC06D                  ;taken if not printing a CR
                pha                        ;save char to print
                lda #STATE.isCursorEditing|STATE.isScrollingDisabled
                trb STATE
                jsr showCursor
                pla                          ;restore char to print
LC06D:
                cmp #$20
                bcc handleControlChar
                cmp #$7F                     
                bne LC096                    ;taken if not backspace
                lda #$20 ;backspace is entry 32 in the VDU routines table
handleControlChar:
                tay                          ;Y=index in table
                lda vduRoutinesLSBTable,y
                sta vduv.jumpVector+0 ; Store jump address LSB (see MasRef E.4-3)
                lda vduRoutinesMSBTable,y
                bmi LC0B3           ;branch taken if MSB directly
                tax                          ; Save original MSB value
                ora #$F0                     
                sta vduQueueNegativeLength ;initialise initial VDU queue length
                txa                          ; Restore original MSB value
                .if version==350
                jsr LE520
                .else
                lsr a                        ; 
                lsr a                        ; 
                lsr a                        ; 
                lsr a                        ; Extract value in top 4 bits
                .endif
                clc                          ; 
                adc #vduRoutinesPage         ; form MSB
                sta vduv.jumpVector+1
                bra reinstateCursorEditing                    ; Continue

LC096:
                bit STATE
                bmi LC0C7                    ;taken if VDU21
                jsr LCE0C                    ; C09A= 20 0C CE     .N
                lda #$20                     ; C09D= A9 20       )
                bit $0366                    ; C09F= 2C 66 03    ,f.
                bne LC0C7                    ; C0A2= D0 23       P#
                jsr LC276                    ; C0A4= 20 76 C2     vB
                bra LC0C7                    ; C0A7= 80 1E       ..

LC0A9:
                eor #$06                     ; C0A9= 49 06       I.
                bne LC0C5                    ; C0AB= D0 18       P.
                lda #STATE.isVDU21
                trb STATE                      ; C0AF= 14 D0       .P
                bra reinstateCursorEditing                    ; C0B1= 80 17       ..

LC0B3:
                sta vduv.jumpVector+1
                tya                          ; C0B6= 98          .
                eor #$F7                     ; C0B7= 49 F7       Iw
                cmp #$FA                     ; C0B9= C9 FA       Iz
                tya                          ; C0BB= 98          .
                bit STATE
                bmi LC0A9             ;branch taken if VDU21 in effect
LC0C0:
                php                          ; C0C0= 08          .
                jsr LC024                    ; C0C1= 20 24 C0     $@
                plp                          ; C0C4= 28          (
LC0C5:
                bcc reinstateCursorEditing                    ; C0C5= 90 03       ..
LC0C7:
                lda STATE
                lsr a                          ;C=1 if printer enabled
reinstateCursorEditing:
                bit STATE
                bvc rtsC0E1               ;taken if not cursor editing
                jsr activateEditCursor
exchangeCursors:
                php
                pha
                lda STATE
                eor #STATE.isScrollingDisabled
                sta STATE
                jsr exchangeEditCursorPositionAndTextCursorPosition
                jsr updateCRTCTextCursor
                pla
                plp
rtsC0E1:
                rts

;-------------------------------------------------------------------------
;
; VDU 1 (&01) Send next character to printer only [MasRef E.3-2]
; 
vdu1EntryPoint:
                jsr reinstateCursorEditing                    ; C0E2= 20 CA C0     J@
                jsr outputCharToPrinter
                bra stopCursorEditing                    ; C0E8= 80 10       ..

;-------------------------------------------------------------------------
;
; VDU 2 (&02) Enable printer [MasRef E.3-2]
; VDU 3 (&03) Disable printer [MasRef E.3-3]
; 
vdu2EntryPoint:
vdu3EntryPoint:
                pha                          ;
                jsr reinstateCursorEditing
                .if version<350
                jsr callPrinterDriverWithPrinterBuffer
                .else
                jsr LE2E7
                .endif
                lda #STATE.isPrinterEnabled  ;
                tsb STATE                      ; C0F3= 04 D0       .P
                pla                          ; C0F5= 68          h
                and #STATE.isPrinterEnabled
                trb STATE                      ; C0F8= 14 D0       .P

;-------------------------------------------------------------------------
;
; Stop cursor editing, if it's on.
;
; exit:
;
; V=1 if cursor editing previous on
; N=1 if VDU 21 on
;
stopCursorEditing:
                bit STATE
                bvc rtsC0E1                    ;taken if not cursor editing
                jsr exchangeCursors
                php
deactivateEditCursor:
                sec                          
                bra updateEditCursorState

;-------------------------------------------------------------------------

activateEditCursor:
                php                          ; C105= 08          .
                clc                          ; C106= 18          .

;-------------------------------------------------------------------------
;
; Handle cursor editing on/off.
;
; entry:
;
; C=0 - cursor editing on; add fake cursor
;
; C=1 = cursor editing off; remove fake cursor and restore screen
; 
updateEditCursorState: .proc
                pha
                lda ZMEMT+0 
                sta ZTEMPD+0
                lda ZMEMT+1 
                sta ZTEMPD+1
                ldy vduv.bytesPerCharacter
                dey
                bne bitmap
                
teletext:
                lda vduv.workspace._38 ;get old byte under fake cursor (may be bogus)
                bcs storeToScreen      ;taken if switching off
                lda (ZMEMT)            ;get screen byte
                sta vduv.workspace._38 ;store old byte
                lda #$7F               ;store solid block to screen
                bra storeToScreen

bitmap:
                lda #%11111111          ;invert all bits
                cpy #$1F      ;check for 32 chars/byte - i.e., MODE 2
                bne +         ;taken if not MODE 2
                lda #%00111111       ;avoid flashing colours in MODE 2
+
                sta ZTEMP
loop:
                lda (ZTEMPD)
                eor ZTEMP
storeToScreen:
                sta (ZTEMPD)
                inc ZTEMPD+0
                bne +                    ;taken if no carry out of LSB
                inc ZTEMPD+1
                bpl +                 ;taken if no screen address wrap
                lda vduv.startScreenAddressHighByte
                sta ZTEMPD+1
+
                dey               ;Y=$ff after 1 iteration in teletext
                bpl loop
                pla
                plp
                rts
                .endproc

;-------------------------------------------------------------------------

LC147:
                .word LC1BE                  ; C147= BE C1       ..
                .word LC1B1                  ; C149= B1 C1       ..
                .word LC1BE                  ; C14B= BE C1       ..
                .word LC1B1                  ; C14D= B1 C1       ..
                .word LC195                  ; C14F= 95 C1       ..
                .word LC195                  ; C151= 95 C1       ..
                .word LC1A2                  ; C153= A2 C1       ..
                .word LC1A2                  ; C155= A2 C1       ..

;-------------------------------------------------------------------------

LC157:
                .word LC201                  ; C157= 01 C2       ..
                .word LC1EE                  ; C159= EE C1       ..
                .word LC201                  ; C15B= 01 C2       ..
                .word LC1EE                  ; C15D= EE C1       ..
                .word LC221                  ; C15F= 21 C2       !.
                .word LC221                  ; C161= 21 C2       !.
                .word LC210                  ; C163= 10 C2       ..
                .word LC210                  ; C165= 10 C2       ..

;-------------------------------------------------------------------------
; 
; Indexed by the swapAxes, invertVertical and invertHorizontal cursor
; flags bits.
; 
setTextCursorXPositionRoutinesTable:
                .word setTextCursorXPosition           ;0
                .word setTextCursorXPositionInvertHorizontal ;invertHorizontal
                .word setTextCursorXPosition ;invertVertical
                .word setTextCursorXPositionInvertHorizontal ;invertVertical|invertHorizontal
                .word setTextCursorXPositionSwapAxes         ;swapAxes
                .word setTextCursorXPositionSwapAxes ;swapAxes|invertHorizontal
                .word setTextCursorXPositionSwapAxesInvertVertical ;swapAxes|invertVertical
                .word setTextCursorXPositionSwapAxesInvertVertical ;swapAxes|invertVertical|invertHorizontal

;-------------------------------------------------------------------------

LC177:
                .word LC310                  ; C177= 10 C3       ..
                .word LC2F2                  ; C179= F2 C2       ..
                .word LC310                  ; C17B= 10 C3       ..
                .word LC2F2                  ; C17D= F2 C2       ..
                .word LC35A                  ; C17F= 5A C3       Z.
                .word LC35A                  ; C181= 5A C3       Z.
                .word LC338                  ; C183= 38 C3       8.
                .word LC338                  ; C185= 38 C3       8.

;-------------------------------------------------------------------------

LC187:
                eor $0366                    ; C187= 4D 66 03    Mf.
                and #$0E                     ; C18A= 29 0E       ).
                pha                          ; C18C= 48          H
                jsr LD1A6                    ; C18D= 20 A6 D1     &Q
                plx                          ; C190= FA          z
                sec                          ; C191= 38          8
                jmp (LC147,x)                ; C192= 7C 47 C1    |GA

LC195:
                lda $0326                    ; C195= AD 26 03    -&.
                sbc #$08                     ; C198= E9 08       i.
                sta $0326                    ; C19A= 8D 26 03    .&.
                dec $0327                    ; C19D= CE 27 03    N'.
                bra LC1AA                    ; C1A0= 80 08       ..

LC1A2:
                lda $0326                    ; C1A2= AD 26 03    -&.
                adc #$07                     ; C1A5= 69 07       i.
                sta $0326                    ; C1A7= 8D 26 03    .&.
LC1AA:
                bcc LC1CB                    ; C1AA= 90 1F       ..
                inc $0327                    ; C1AC= EE 27 03    n'.
                bra LC1CB                    ; C1AF= 80 1A       ..

LC1B1:
                lda $0324                    ; C1B1= AD 24 03    -$.
                sbc #$08                     ; C1B4= E9 08       i.
                sta $0324                    ; C1B6= 8D 24 03    .$.
                dec $0325                    ; C1B9= CE 25 03    N%.
                bra LC1C6                    ; C1BC= 80 08       ..

LC1BE:
                lda $0324                    ; C1BE= AD 24 03    -$.
                adc #$07                     ; C1C1= 69 07       i.
                sta $0324                    ; C1C3= 8D 24 03    .$.
LC1C6:
                bcc LC1CB                    ; C1C6= 90 03       ..
                inc $0325                    ; C1C8= EE 25 03    n%.
LC1CB:
                lda $DA                      ; C1CB= A5 DA       %Z
                bne LC1DB                    ; C1CD= D0 0C       P.
                bit $0366                    ; C1CF= 2C 66 03    ,f.
                bvs LC1DB                    ; C1D2= 70 07       p.
                phx                          ; C1D4= DA          Z
                jsr LD1A6                    ; C1D5= 20 A6 D1     &Q
                plx                          ; C1D8= FA          z
                tay                          ; C1D9= A8          (
                rts                          ; C1DA= 60          `

LC1DB:
                lda #$00                     ; C1DB= A9 00       ).
                rts                          ; C1DD= 60          `

LC1DE:
                lda #$00                     ; C1DE= A9 00       ).
LC1E0:
                stz $DA                      ; C1E0= 64 DA       dZ
                asl a                        ; C1E2= 0A          .
                rol $DA                      ; C1E3= 26 DA       &Z
                asl a                        ; C1E5= 0A          .
                rol $DA                      ; C1E6= 26 DA       &Z
                asl a                        ; C1E8= 0A          .
                rol $DA                      ; C1E9= 26 DA       &Z
                jmp (LC157,x)                ; C1EB= 7C 57 C1    |WA

LC1EE:
                eor #$F9                     ; C1EE= 49 F9       Iy
                adc $0304                    ; C1F0= 6D 04 03    m..
                sta $0324                    ; C1F3= 8D 24 03    .$.
                lda $DA                      ; C1F6= A5 DA       %Z
                eor #$FF                     ; C1F8= 49 FF       I.
                adc $0305                    ; C1FA= 6D 05 03    m..
                sta $0325                    ; C1FD= 8D 25 03    .%.
                rts                          ; C200= 60          `

LC201:
                adc $0300                    ; C201= 6D 00 03    m..
                sta $0324                    ; C204= 8D 24 03    .$.
                lda $DA                      ; C207= A5 DA       %Z
                adc $0301                    ; C209= 6D 01 03    m..
                sta $0325                    ; C20C= 8D 25 03    .%.
                rts                          ; C20F= 60          `

LC210:
                eor #$07                     ; C210= 49 07       I.
                adc $0302                    ; C212= 6D 02 03    m..
                sta $0326                    ; C215= 8D 26 03    .&.
                lda $DA                      ; C218= A5 DA       %Z
                adc $0303                    ; C21A= 6D 03 03    m..
                sta $0327                    ; C21D= 8D 27 03    .'.
                rts                          ; C220= 60          `

LC221:
                sec                          ; C221= 38          8
                eor #$FF                     ; C222= 49 FF       I.
                adc $0306                    ; C224= 6D 06 03    m..
                sta $0326                    ; C227= 8D 26 03    .&.
                lda $DA                      ; C22A= A5 DA       %Z
                eor #$FF                     ; C22C= 49 FF       I.
                adc $0307                    ; C22E= 6D 07 03    m..
                sta $0327                    ; C231= 8D 27 03    .'.
                rts                          ; C234= 60          `

LC235:
                lda #$00                     ; C235= A9 00       ).
                jsr LC187                    ; C237= 20 87 C1     .A
                beq LC249                    ; C23A= F0 0D       p.
                jsr LC1DE                    ; C23C= 20 DE C1     ^A
LC23F:
                lda #$08                     ; C23F= A9 08       ).
LC241:
                jsr LC187                    ; C241= 20 87 C1     .A
                beq LC249                    ; C244= F0 03       p.
                jsr LC1DE                    ; C246= 20 DE C1     ^A
LC249:
                jmp LC4DF                    ; C249= 4C DF C4    L_D

vdu9EntryPoint:
                jsr handleColumn81                    ; C24C= 20 2D D1     -Q
                bcs LC235                    ; C24F= B0 E4       0d
                lda #$00                     ; C251= A9 00       ).
                jsr LC2E9                    ; C253= 20 E9 C2     iB
                bcc LC273                    ; C256= 90 1B       ..
LC258:
                jsr LC38F                    ; C258= 20 8F C3     .C
vdu10EntryPoint:
                jsr testVDU5State                    ; C25B= 20 D2 E2     Rb
                bne LC23F                    ; C25E= D0 DF       P_
                clc                          ; C260= 18          .
                jsr LC88E                    ; C261= 20 8E C8     .H
                lda #$08                     ; C264= A9 08       ).
                jsr LC2E9                    ; C266= 20 E9 C2     iB
LC269:
                bcc LC273                    ; C269= 90 08       ..
                jsr LC37B                    ; C26B= 20 7B C3     {C
                bcc LC273                    ; C26E= 90 03       ..
                jmp LD051                    ; C270= 4C 51 D0    LQP

LC273:
                jmp updateCRTCCursorAddress

LC276:
                jsr testVDU5State                    ; C276= 20 D2 E2     Rb
                bne LC235                    ; C279= D0 BA       P:
                jsr LC2E9                    ; C27B= 20 E9 C2     iB
                bcc LC273                    ; C27E= 90 F3       .s
                lda #$01                     ; C280= A9 01       ).
                bit $0366                    ; C282= 2C 66 03    ,f.
                beq LC258                    ; C285= F0 D1       pQ
                sec                          ; C287= 38          8
                ror $036C                    ; C288= 6E 6C 03    nl.
LC28B:
                rts                          ; C28B= 60          `

LC28C:
                lda #$06                     ; C28C= A9 06       ).
                jsr LC187                    ; C28E= 20 87 C1     .A
                beq LC249                    ; C291= F0 B6       p6
                jsr LC1DE                    ; C293= 20 DE C1     ^A
LC296:
                lda #$0E                     ; C296= A9 0E       ).
                bra LC241                    ; C298= 80 A7       .'

vdu8EntryPoint:
                jsr testVDU5State                    ; C29A= 20 D2 E2     Rb
                bne LC28C                    ; C29D= D0 ED       Pm
                lsr $036C                    ; C29F= 4E 6C 03    Nl.
                bit $036C                    ; C2A2= 2C 6C 03    ,l.
                bvs LC28B                    ; C2A5= 70 E4       pd
                lda #$06                     ; C2A7= A9 06       ).
                jsr LC2E9                    ; C2A9= 20 E9 C2     iB
                bcc LC273                    ; C2AC= 90 C5       .E
                jsr LC38F                    ; C2AE= 20 8F C3     .C
vdu11EntryPoint:
                jsr testVDU5State                    ; C2B1= 20 D2 E2     Rb
                bne LC296                    ; C2B4= D0 E0       P`
                dec pagedModeCounter                    ; C2B6= CE 69 02    Ni.
                bpl LC2BE                    ; C2B9= 10 03       ..
                inc pagedModeCounter                    ; C2BB= EE 69 02    ni.
LC2BE:
                lda #$0E                     ; C2BE= A9 0E       ).
                jsr LC2E9                    ; C2C0= 20 E9 C2     iB
                bra LC269                    ; C2C3= 80 A4       .$

;-------------------------------------------------------------------------
;
; Set/reset cursor position, taking cursor flags into account.
;
; entry:
;
; (set only) A = cursor position
;
; X = cursorFlags bits: swapAxes, invertVertical, invertHorizontal
; 
resetTextCursorXPositionWithCursorFlags:
                lda #$00
setTextCursorXPositionWithCursorFlags:
                clc
                jmp (setTextCursorXPositionRoutinesTable,x)

;-------------------------------------------------------------------------

setTextCursorXPositionInvertHorizontal:
                sec                          ;+1
                eor #$FF          ;^$ff+1 (i.e., adc will add the -ve)
                adc vduv.textWindowRight
                bra staTextCursorXPosition

;-------------------------------------------------------------------------

setTextCursorXPosition:
                adc vduv.textWindowLeft
staTextCursorXPosition:
                sta vduv.textCursorXPosition
                rts

;-------------------------------------------------------------------------

setTextCursorXPositionSwapAxesInvertVertical:
                sec
                eor #$FF
                adc vduv.textWindowBottom
                bra staTextCursorYPosition

setTextCursorXPositionSwapAxes:
                adc vduv.textWindowTop
staTextCursorYPosition:
                sta vduv.textCursorYPosition
                rts

;-------------------------------------------------------------------------

LC2E9:
                eor $0366                    ; C2E9= 4D 66 03    Mf.
                and #$0E                     ; C2EC= 29 0E       ).
                tax                          ; C2EE= AA          *
LC2EF:
                jmp (LC177,x)                ; C2EF= 7C 77 C1    |wA

LC2F2:
                lda $0308                    ; C2F2= AD 08 03    -..
                cmp $0318                    ; C2F5= CD 18 03    M..
                bcs LC337                    ; C2F8= B0 3D       0=
                dec $0318                    ; C2FA= CE 18 03    N..
                sec                          ; C2FD= 38          8
                lda $034A                    ; C2FE= AD 4A 03    -J.
                sbc $034F                    ; C301= ED 4F 03    mO.
                sta $034A                    ; C304= 8D 4A 03    .J.
                sta ZMEMT+0                      ; C307= 85 D8       .X
                bcs LC336                    ; C309= B0 2B       0+
                dec $034B                    ; C30B= CE 4B 03    NK.
                bra LC32B                    ; C30E= 80 1B       ..

LC310:
                lda $0318                    ; C310= AD 18 03    -..
                cmp $030A                    ; C313= CD 0A 03    M..
                bcs LC337                    ; C316= B0 1F       0.
                inc $0318                    ; C318= EE 18 03    n..
                lda $034A                    ; C31B= AD 4A 03    -J.
                adc $034F                    ; C31E= 6D 4F 03    mO.
                sta $034A                    ; C321= 8D 4A 03    .J.
                sta ZMEMT+0                      ; C324= 85 D8       .X
                bcc LC337                    ; C326= 90 0F       ..
                inc $034B                    ; C328= EE 4B 03    nK.
LC32B:
                lda $034B                    ; C32B= AD 4B 03    -K.
LC32E:
                bpl LC334                    ; C32E= 10 04       ..
                sec                          ; C330= 38          8
                sbc $0354                    ; C331= ED 54 03    mT.
LC334:
                sta ZMEMT+1                      ; C334= 85 D9       .Y
LC336:
                clc                          ; C336= 18          .
LC337:
                rts                          ; C337= 60          `

LC338:
                lda $030B                    ; C338= AD 0B 03    -..
                cmp $0319                    ; C33B= CD 19 03    M..
                bcs LC337                    ; C33E= B0 F7       0w
                dec $0319                    ; C340= CE 19 03    N..
                sec                          ; C343= 38          8
                lda $034A                    ; C344= AD 4A 03    -J.
                sbc $0352                    ; C347= ED 52 03    mR.
                sta $034A                    ; C34A= 8D 4A 03    .J.
                sta ZMEMT+0                      ; C34D= 85 D8       .X
                lda $034B                    ; C34F= AD 4B 03    -K.
                sbc $0353                    ; C352= ED 53 03    mS.
                sta $034B                    ; C355= 8D 4B 03    .K.
                bra LC32E                    ; C358= 80 D4       .T

LC35A:
                lda $0319                    ; C35A= AD 19 03    -..
                cmp $0309                    ; C35D= CD 09 03    M..
                bcs LC337                    ; C360= B0 D5       0U
                inc $0319                    ; C362= EE 19 03    n..
                lda $034A                    ; C365= AD 4A 03    -J.
                adc $0352                    ; C368= 6D 52 03    mR.
                sta $034A                    ; C36B= 8D 4A 03    .J.
                sta ZMEMT+0                      ; C36E= 85 D8       .X
                lda $034B                    ; C370= AD 4B 03    -K.
                adc $0353                    ; C373= 6D 53 03    mS.
                sta $034B                    ; C376= 8D 4B 03    .K.
                bra LC32E                    ; C379= 80 B3       .3

LC37B:
                lda #$10                     ; C37B= A9 10       ).
                bit $0366                    ; C37D= 2C 66 03    ,f.
                bne LC38F                    ; C380= D0 0D       P.
                txa                          ; C382= 8A          .
                eor #$06                     ; C383= 49 06       I.
                pha                          ; C385= 48          H
                lda #$42                     ; C386= A9 42       )B
                bit STATE                      ; C388= 24 D0       $P
                beq LC3A2                    ; C38A= F0 16       p.
                bvs LC397                    ; C38C= 70 09       p.
                pla                          ; C38E= 68          h
LC38F:
                jsr resetTextCursorXPositionWithCursorFlags                    ; C38F= 20 C5 C2     EB
                jsr updateZMEMTWithTextCursorPosition                    ; C392= 20 FA CC     zL
                clc                          ; C395= 18          .
                rts                          ; C396= 60          `

LC397:
                jsr exchangeEditCursorPositionAndTextCursorPosition                    ; C397= 20 AE E2     .b
                plx                          ; C39A= FA          z
                phx                          ; C39B= DA          Z
                jsr LC2EF                    ; C39C= 20 EF C2     oB
                jsr exchangeEditCursorPositionAndTextCursorPosition                    ; C39F= 20 AE E2     .b
LC3A2:
                plx                          ; C3A2= FA          z
                sec                          ; C3A3= 38          8
LC3A4:
                rts                          ; C3A4= 60          `

vdu28EntryPoint:
                ldx $0355                    ; C3A5= AE 55 03    .U.
                lda $0321                    ; C3A8= AD 21 03    -!.
                cmp $0323                    ; C3AB= CD 23 03    M#.
                bcc LC3A4                    ; C3AE= 90 F4       .t
                cmp modeMaxRow,x                  ; C3B0= DD 01 E1    ].a
                beq LC3B7                    ; C3B3= F0 02       p.
                bcs LC3A4                    ; C3B5= B0 ED       0m
LC3B7:
                lda $0322                    ; C3B7= AD 22 03    -".
                cmp modeMaxColumn,x                  ; C3BA= DD 09 E1    ].a
                beq LC3C2                    ; C3BD= F0 03       p.
                bcs LC3A4                    ; C3BF= B0 E3       0c
                sec                          ; C3C1= 38          8
LC3C2:
                sbc $0320                    ; C3C2= ED 20 03    m .
                bcc LC3A4                    ; C3C5= 90 DD       .]
                jsr setTextWindowWidthInBytes                    ; C3C7= 20 80 C7     .G
                lda #$08                     ; C3CA= A9 08       ).
                tsb STATE                      ; C3CC= 04 D0       .P
                ldx #VDUVariables.queueEnd-4
                ldy #VDUVariables.textWindowLeft
                jsr copyFourBytesWithinVDUVariables
                jsr exchangeEditCursorPositionAndTextCursorPosition                    ; C3D5= 20 AE E2     .b
                jsr LCCDA                    ; C3D8= 20 DA CC     ZL
                bcc LC3E0                    ; C3DB= 90 03       ..
                jsr LC3E8                    ; C3DD= 20 E8 C3     hC
LC3E0:
                jsr exchangeEditCursorPositionAndTextCursorPosition                    ; C3E0= 20 AE E2     .b
                jsr LCCDA                    ; C3E3= 20 DA CC     ZL
                bcc LC407                    ; C3E6= 90 1F       ..
LC3E8:
                lda STATE                      ; C3E8= A5 D0       %P
                pha                          ; C3EA= 48          H
                and #$DF                     ; C3EB= 29 DF       )_
                sta STATE                      ; C3ED= 85 D0       .P
                jsr vdu30EntryPoint            ; C3EF= 20 7C C4     |D
                pla                          ; C3F2= 68          h
                sta STATE                      ; C3F3= 85 D0       .P
                rts                          ; C3F5= 60          `

vdu13EntryPoint:
                lda $0366                    ; C3F6= AD 66 03    -f.
                and #$0E                     ; C3F9= 29 0E       ).
                tax                          ; C3FB= AA          *
                jsr testVDU5State                    ; C3FC= 20 D2 E2     Rb
                bne LC40A                    ; C3FF= D0 09       P.
                lsr $036C                    ; C401= 4E 6C 03    Nl.
                jsr LC38F                    ; C404= 20 8F C3     .C
LC407:
                jmp updateCRTCCursorAddress

LC40A:
                jsr LC1DE                    ; C40A= 20 DE C1     ^A
                jmp LC4DF                    ; C40D= 4C DF C4    L_D

LC410:
                jsr vdu30EntryPoint          ; C410= 20 7C C4     |D

;-------------------------------------------------------------------------
;
; VDU 16 (&10) Clear graphics window [MasRef E.3-7]
;
vdu16EntryPoint:
                lda vduv.pixelsPerByteMinusOne
                beq LC3A4                    ;taken if MODE 7
                ldx #VDUVariables.graphicsWindowPixelsLeft
                jsr copyEightBytesToWorkspace28
                jsr prepareForPlotBackground
LC420:
                ldx #$2A                     ; C420= A2 2A       "*
                ldy #$2E                     ; C422= A0 2E        .
                jsr exchangeTwoVDUBytes
LC427:
                ldx #$28                     ; C427= A2 28       "(
                ldy #$2C                     ; C429= A0 2C        ,
                jsr LDAE8                    ; C42B= 20 E8 DA     hZ
                lda $032A                    ; C42E= AD 2A 03    -*.
                bne LC436                    ; C431= D0 03       P.
                dec $032B                    ; C433= CE 2B 03    N+.
LC436:
                dec $032A                    ; C436= CE 2A 03    N*.
                lda $032A                    ; C439= AD 2A 03    -*.
                cmp $032E                    ; C43C= CD 2E 03    M..
                lda $032B                    ; C43F= AD 2B 03    -+.
                sbc $032F                    ; C442= ED 2F 03    m/.
                bpl LC427                    ; C445= 10 E0       .`
                rts                          ; C447= 60          `

LC448:
                ldx #VDUVariables.queueEnd-4
                jsr prepareAABB                    ; C44A= 20 E6 C8     fH
                bra LC420                    ; C44D= 80 D1       .Q

;-------------------------------------------------------------------------
;
; VDU 12 (&0C) Clear text window [MasRef E.3-5]
; 
vdu12EntryPoint:
                lda #STATE.isVDU5
                bit STATE
                bne LC410                    ;taken if VDU 5 mode
                lda #STATE.isTextWindow
                bit STATE
                bne clearTextWindow                    ;taken if text window
                jmp clsFastPath

                ; Clear screen within text window
                ; -------------------------------
clearTextWindow:
                jsr copyTextWindowWidthInBytesToWorkspace28
                ldx vduv.textWindowLeft
                stx vduv.textCursorXPosition
                ldx vduv.textWindowTop
clearTextWindowRowsLoop:
                stx vduv.textCursorYPosition
                jsr updateZMEMTWithTextCursorPosition
                jsr LCAE8
                ldx vduv.textCursorYPosition
                cpx vduv.textWindowBottom
                inx
                bcc clearTextWindowRowsLoop

;-------------------------------------------------------------------------
;
; VDU 30 (&1E) Home cursor [MasRef E.3-36]
; 
vdu30EntryPoint:
                ; pretend it's VDU 31,0,0
                stz vduv.queueEnd-1
                stz vduv.queueEnd-2

;-------------------------------------------------------------------------
;
; VDU 31 (&1F) Tab cursor [MasRef E.3-36]
; 
vdu31EntryPoint:
                lda vduv.cursorFlags
                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
                tax
LC488:
                jsr testVDU5State
                bne LC4CF                    ;taken if VDU 5
                lda vduv.textCursorXPosition
                pha                          ;save old X pos
                lda vduv.textCursorYPosition
                pha                          ;save old Y pos
                lda vduv.queueEnd-2          ;X coordinate
                jsr setTextCursorXPositionWithCursorFlags
                phx                          ;save true cursorFlags bits
                txa
                eor #vduv.cursorFlags.swapAxes ;cheekily do the other axis by just changing the cursor flags
                tax
                lda vduv.queueEnd-1          ;Y coordinate
                jsr LCCD7
                plx                    ;restore true cursorFlags bits
                bcc LC4BA              ;taken if no scrolling required
                lda #vduv.cursorFlags.scrollProtect
                bit $0366
                beq LC4C1                 ;taken if scroll protect off

                ; Wrap text cursor X.
                lda vduv.queueEnd-2       ;X coordinate
                dec a
                jsr LCCD7
                bcs LC4C1
                sec
LC4BA:
                ror vduv.column81
                pla                          ;discard old Y pos
                pla                          ;discard old X pos
                bra LC4CC

LC4C1:
                pla                          
                sta vduv.textCursorYPosition ;restore old Y pos
                pla
                sta vduv.textCursorXPosition ;restore old X pos
                jsr updateZMEMTWithTextCursorPosition
LC4CC:
                jmp updateCRTCCursorAddress

LC4CF:
                lda $0322                    ; C4CF= AD 22 03    -".
                jsr LC1E0                    ; C4D2= 20 E0 C1     `A
                txa                          ; C4D5= 8A          .
                eor #$08                     ; C4D6= 49 08       I.
                tax                          ; C4D8= AA          *
                lda $0323                    ; C4D9= AD 23 03    -#.
                jsr LC1E0                    ; C4DC= 20 E0 C1     `A
LC4DF:
                ldy #$10                     ; C4DF= A0 10        .
                jsr copyGraphicsCursorPixels                    ; C4E1= 20 1C C9     .I
                ldx #$02                     ; C4E4= A2 02       ".
                ldy #$02                     ; C4E6= A0 02        .
                jsr LC4FC                    ; C4E8= 20 FC C4     |D
                ldx #$00                     ; C4EB= A2 00       ".
                ldy #$04                     ; C4ED= A0 04        .
                lda $0361                    ; C4EF= AD 61 03    -a.
LC4F2:
                dey                          ; C4F2= 88          .
                lsr a                        ; C4F3= 4A          J
                bne LC4F2                    ; C4F4= D0 FC       P|
                lda $0356                    ; C4F6= AD 56 03    -V.
                beq LC4FC                    ; C4F9= F0 01       p.
                iny                          ; C4FB= C8          H
LC4FC:
                asl $0310,x                  ; C4FC= 1E 10 03    ...
                rol $0311,x                  ; C4FF= 3E 11 03    >..
                dey                          ; C502= 88          .
                bne LC4FC                    ; C503= D0 F7       Pw
                sec                          ; C505= 38          8
                jsr LC50A                    ; C506= 20 0A C5     .E
                inx                          ; C509= E8          h
LC50A:
                lda $0310,x                  ; C50A= BD 10 03    =..
                sbc $030C,x                  ; C50D= FD 0C 03    }..
                sta $0310,x                  ; C510= 9D 10 03    ...
                rts                          ; C513= 60          `

;-------------------------------------------------------------------------
;
; VDU 14 (&0E) Page mode on [MasRef E.3-6]
; 
vdu14EntryPoint:
                stz pagedModeCounter                    ; C514= 9C 69 02    .i.
                lda #$91                     ; C517= A9 91       ).

;-------------------------------------------------------------------------
;
; VDU 21 (&15) Disable VDU driver [MasRef E.3-11]
; 
vdu21EntryPoint:
                eor #$95                     ; C519= 49 95       I.
LC51B:
                tsb STATE                      ; C51B= 04 D0       .P
                rts                          ; C51D= 60          `

;-------------------------------------------------------------------------
;
; VDU 4 (&04) Print at text cursor [MasRef E.3-2]
; 
vdu4EntryPoint:
                lda $0361                    ; C51E= AD 61 03    -a.
                beq LC52C                    ; C521= F0 09       p.
                jsr showCursor               ; C523= 20 50 CF     PO
                lda #$2B                     ; C526= A9 2B       )+

                ; fall through to vdu15EntryPoint

;-------------------------------------------------------------------------
;
; VDU 15 (&0F) Page mode off [MasRef E.3-6]
; 
vdu15EntryPoint:
                eor #$0B                     ; C528= 49 0B       I.
                trb STATE                      ; C52A= 14 D0       .P
LC52C:
                rts                          ; C52C= 60          `

;-------------------------------------------------------------------------
;
; VDU 5 (&05) Print text at graphics cursor [MasRef E.3-3]
;
vdu5EntryPoint:
                lda $0361                    ; C52D= AD 61 03    -a.
                beq LC52C                    ; C530= F0 FA       pz
                lda #$20                     ; C532= A9 20       )
                jsr setCRTCRegister10               ; C534= 20 53 CF     SO
                bra LC51B                    ; C537= 80 E2       .b

;-------------------------------------------------------------------------
;
; VDU 17 (&11) Define text colour [MasRef E.3-7]
; 
vdu17EntryPoint:
                ldy #$00                     ; C539= A0 00        .
                lda $0323                    ; C53B= AD 23 03    -#.
                bpl LC541                    ; C53E= 10 01       ..
                iny                          ; C540= C8          H
LC541:
                and $0360                    ; C541= 2D 60 03    -`.
                sta $DA                      ; C544= 85 DA       .Z
                lda $0360                    ; C546= AD 60 03    -`.
                beq LC563                    ; C549= F0 18       p.
                and #$07                     ; C54B= 29 07       ).
                clc                          ; C54D= 18          .
                adc $DA                      ; C54E= 65 DA       eZ
                tax                          ; C550= AA          *
                lda solidColoursTable-1,x
                sta $0357,y                  ; C554= 99 57 03    .W.
                lda $0357                    ; C557= AD 57 03    -W.
                eor #$FF                     ; C55A= 49 FF       I.
                sta ZEOR                      ; C55C= 85 D3       .S
                eor $0358                    ; C55E= 4D 58 03    MX.
                sta ZORA                      ; C561= 85 D2       .R
LC563:
                rts                          ; C563= 60          `

;-------------------------------------------------------------------------
;
; VDU 18 (&12) Define graphics colour [MasRef E.3-7]
; 
vdu18EntryPoint:
                ldy #$00                    ;assume setting foreground
                lda vduv.queueEnd-1         ;get colour
                bpl +                     ;taken if setting foreground
                iny                       ;setting background
+
                and vduv.numberOfLogicalColoursMinusOne
                sta vduv.foregroundGraphicsColour,y
                lda vduv.queueEnd-2          ;get GCOL mode
                sta vduv.foregroundGCOLMode,y
                and #$F0                     ;non-zero if ECF
                sta vduv.isForegroundECF,y
initializeCurrentECFPatterns:
                lda vduv.foregroundGCOLMode
                ldx vduv.foregroundGraphicsColour
                ldy #andy.fgECFPattern-andy.currentECFPatterns
                jsr initializeCurrentECFPattern
                lda vduv.backgroundGCOLMode
                ldx vduv.backgroundGraphicsColour
                ldy #andy.bgECFPattern-andy.currentECFPatterns
initializeCurrentECFPattern:
                and #$F0                     ;GCOL mode ECF bits
                bne initializeECFPatternFromPattern

initializeECFPatternFromColour:
                stx ZTEMP+0                  ;colour low bits
                lda vduv.numberOfLogicalColoursMinusOne
                and #$07
                clc
                adc ZTEMP+0
                tax
                ; use solid colour as ECF "pattern".
                lda solidColoursTable-1,x
                ldx #$07
-
                sta andy.fgECFPattern,y
                iny
                dex
                bpl -
                rts

initializeECFPatternFromPattern:
                lsr a                        ;(index+1)*8
                tax
                lda #$07
                sta ZTEMP+0
-
                lda andy.ecfPatterns-8,x     ;-8 due to index+1 above
                sta andy.fgECFPattern,y
                inx
                iny
                dec ZTEMP+0
                bpl -
                rts

;-------------------------------------------------------------------------
;
; VDU 20 (&14) Restore default logical colours [MasRef E.3-10]
; 
setBackgroundTextColourForTeletext:
                lda #' '
                sta vduv.backgroundTextColour
                rts

vdu20EntryPoint:
                ldx #$05                     ; C5C5= A2 05       ".
-
                stz vduv.foregroundTextColour,x
                dex
                bpl -
                stz vduv.backgroundGraphicsColour
                stz vduv.isBackgroundECF
                lda #%11111111
                ldx vduv.numberOfLogicalColoursMinusOne
                beq setBackgroundTextColourForTeletext
                cpx #$0F
                bne +                        ;taken unless MODE 2
                lda #%00111111               ;MODE 2 default foreground colour is 7
+
                sta vduv.foregroundTextColour
                eor #$FF
                sta ZORA
                sta ZEOR
                txa     
                and #$07
                sta vduv.foregroundGraphicsColour
                stz vduv.isForegroundECF
                phx                          ;save numberOfLogicalColoursMinusOne
                jsr initializeCurrentECFPatterns
                plx                          ;restore numberOfLogicalColoursMinusOne
                stx vduv.queueEnd-5          ;Prepare VDU19,<max logical colour>
                cpx #$03
                beq reset4Colours            ;taken if MODE 1/5
                bcc reset2Colours            ;taken if MODE 0/3/4/6
reset16Colours:
                stx vduv.queueEnd-4          ;start with VDU19,15,15,_,_,_
-
                jsr vdu19EntryPoint          ; C603= 20 2D C6     -F
                dec vduv.queueEnd-4
                dec vduv.queueEnd-5
                bpl -
                rts                          ; C60E= 60          `

reset4Colours:
                ldx #$07
                stx vduv.queueEnd-4          ;start with VDU19,3,7,_,_,_
-
                jsr vdu19EntryPoint          ;2,3, then 1,1, then 0,0
                lsr vduv.queueEnd-4
                dec vduv.queueEnd-5
                bpl -
                rts                          ; C61F= 60          `

reset2Colours:
                ldx #$07
                jsr +                        ;VDU19,1,7,_,_,_
                ldx #$00
                stz vduv.queueEnd-5          ;VDU19,0,0,_,_,_
+
                stx vduv.queueEnd-4          ;VDU19,N,X,_,_,_

                ; fall through to VDU19

;-------------------------------------------------------------------------
;
; VDU 19 (&13) Define logical colour [MasRef E.3-9]
; 
vdu19EntryPoint:
                php
                sei
                lda vduv.queueEnd-5          ;get logical colour
                and vduv.numberOfLogicalColoursMinusOne ;apply logical colour limit
                tax                        ;X = clamped logical colour
                lda vduv.queueEnd-4        ;get physical colour
LC639:
                and #$0F                     ;apply physical colour limit
                sta vduv.currentPalette,x    ;update palette
                tay                          ;Y = physical colour
                lda vduv.numberOfLogicalColoursMinusOne
                sta SEIWKA
                cmp #$03 ;Z=1 C=1 if 4 colour; Z=0 C=1 if 16 colour; Z=0 C=0 if 2 colour
                php      ;save flags
                txa                          ;A = logical colour

                ;put the logical colour value in the top 1, 2 or 4
                ;bits of SEIWKA, depending on the colour depth.
                ;
                ; 2 colours: turn %0000000a into %a0000000
                ; 4 colours: turn %000000ab into %ab000000
                ;16 colours: turn %0000abcd into %abcd0000
-
                lsr a
                ror SEIWKA
                bcs -
                asl SEIWKA

                tya                          ;A = physical colour
                ora SEIWKA                   ;mix in logical colour
                tax                          ;X = VPALETTE value
                ldy #$F0 ;counts up to zero - counter for setting
                         ;multiple logical colours [AUG p380]
LC655:
                plp                          ;restore flags
                php                          ;save flags
                bne +                     ;taken if 2 colour/16 colour
                jsr fixUpVPALETTEFor4Colours
+
                jsr writeVPALETTE
                clc
                tya                          
                adc vduv.numberOfLogicalColoursMinusOne
                tay                          
                txa
                adc #$10                     ;next logical colour
                tax
                iny                          ;Y+=numberOfLogicalColours
                bne LC655                    ;all logical colours set once zero
                plp                          
                plp                          
                rts                          

fixUpVPALETTEFor4Colours:
                rol a                        ;A BCDabcd1
                sta ZTEMP+0                  ;  BCDabcd1
                rol a                        ;B CDabcd1A
                rol a                        ;C Dabcd1AB
                php                          ;C
                rol ZTEMP+0                  ;B CDabcd1C 
                ror a                        ;B BDabcd1A
                plp                          ;C BDabcd1A
                ror a                        ;A CBDabcd1
                ror a                        ;1 ACBDabcd
                rts                          ;

;-------------------------------------------------------------------------
;
; VDU 23 (&17) Various functions [MasRef E.3-12]
; 
vdu23EntryPoint:
                lda vduv.queueEnd-9           ;get VDU 23 code
                cmp #$20                     
                bcc LC691         ;branch taken if <32 - i.e., special
                
                ; copy the 8 bytes of character definition to the
                ; appropriate place.
                jsr getSoftCharacterDefinitionAddress
                ldy #$07                     ; C686= A0 07        .
LC688:
                lda vduv.queueEnd-8,y         ; C688= B9 1C 03    9..
                sta ($DE),y                  ; C68B= 91 DE       .^
                dey                          ; C68D= 88          .
                bpl LC688                    ; C68E= 10 F8       .x
                rts                          ; C690= 60          `

LC691:
                asl a
                tax
                lsr a
                cmp #$11
                bcs callVDUV    ;call with C=1 - invalid code [MasRef
                                ;E.3-19]
                jmp (vdu23EntryPointTable,x) ; C698= 7C 69 E0    |i`

;-------------------------------------------------------------------------
;
; VDU 25 (&19) PLOT commands [MasRef E.3-21]
; 
vdu25EntryPoint:
                ldx vduv.pixelsPerByteMinusOne
                beq callVDUVForPLOT          ;non-graphics PLOT
                jmp handlePLOT

;-------------------------------------------------------------------------
;
; Call VDUV for a PLOT call, either to handle non-graphics PLOT
; [MasRef E.3-21] or PLOT 240-255 [MasRef E.3-34].
;
callVDUVForPLOT:
                lda vduv.queueEnd-5          ;get PLOT code
                clc ;call with C=0 - non-graphics PLOT [MasRef E.3-21]

;-------------------------------------------------------------------------
;
; Call VDUV.
; 
callVDUV:
                .if version<350
                jmp (VDUV)
                .else
                jmp LE2F3
                .endif

;-------------------------------------------------------------------------
;
; VDU 26 (&1A) Restore default windows [MasRef E.3-34]
; 
vdu26EntryPoint:
                ldx #VDUVariables.workspace._2C
-
                stz vduv,x                    ;reset workspace
                dex
                bpl -
                
                jsr getDefaultBoundsForCurrentScreenMODE
                stx vduv.textWindowRight
                sty vduv.textWindowBottom
                
                txa
                jsr setTextWindowWidthInBytes

                ; Set up the VDU queue as if VDU 24,0;0;1279;1023;,
                ; then call the VDU 24 entry point.
                
                ; 1c - ll - $00
                ; 1d - lh - $00
                ; 1e - tl - $00
                ; 1f - th - $00
                ; 20 - rl - $ff
                ; 21 - rh - $04
                ; 22 - tl - $ff
                ; 23 - th - $03
                
                ldy #$03                     
                sty $0323                    
                iny                          
                sty $0321                    
                dec $0322                    
                dec $0320                    
                jsr vdu24EntryPoint

                lda #STATE.isTextWindow
                trb STATE                    ;reset isTextWindow
                
                jmp vdu30EntryPoint          ;reset text cursor

;-------------------------------------------------------------------------
;
; Update CRTC cursor address to reflect text cursor position.
; 
updateCRTCTextCursor:
                jsr updateZMEMTWithTextCursorPosition
                bra updateCRTCCursorAddress

;-------------------------------------------------------------------------

setCRTCCursorAddress:
                stx vduv.textCursorCRTCAddress+0
                sta vduv.textCursorCRTCAddress+1
                bpl +
                sec
                sbc vduv.screenSizeHighByte
+
                stx ZMEMT+0
                sta ZMEMT+1

;-------------------------------------------------------------------------
;
; 
updateCRTCCursorAddress:
                ldx vduv.textCursorCRTCAddress+0
                lda vduv.textCursorCRTCAddress+1
                ldy #$0E

;-------------------------------------------------------------------------
;
; Set CRTC address - cursor, or screen start.
;
; entry:
;
; A (msb), X (msb) = 6502 address to set
;
; Y = first CRTC register to set
; 
setCRTCAddress:
                pha                          ;save screen address MSB
                lda vduv.currentScreenMODE
                cmp #$07                     ; C6F9= C9 07       I.
                pla                        ;restore screen address MSB
                bcs adjustAddressForMODE7
                stx ZTEMP+0
                lsr a
                ror ZTEMP+0                  ;/2
                lsr a                        
                ror ZTEMP+0                  ;/4
                lsr a                        
                ror ZTEMP+0                  ;/8
                ldx ZTEMP+0
                bra setCRTCAddressRegisters

adjustAddressForMODE7:
                ; C=1
                sbc #$74                 ;adjust for Mode 7 addressing
                eor #$20                 ;adjust for Mode 7 addressing
setCRTCAddressRegisters:
                sty CRTC+0
                sta CRTC+1
                iny
                sty CRTC+0
                stx CRTC+1
                rts

;-------------------------------------------------------------------------
;
; VDU 24 (&18) Define graphics window [MasRef E.3-21]
;
; VDU queue:
;
; -8 = <left
; -7 = >left
; -6 = <bottom
; -5 = >bottom
; -4 = <right
; -3 = >right
; -2 = <top
; -1 = >top
; 
vdu24EntryPoint:
                jsr LC779
                
                ldx #2
-
                sec

                ; <height when X=2, then <width when X=0
                lda vduv.queueEnd-4+0,x
                sbc vduv.queueEnd-8+0,x
                sta vduv.workspace._2C+0,x

                ; >height when X=2, then >width when X=0
                lda vduv.queueEnd-4+1,x
                sbc vduv.queueEnd-8+1,x
                sta vduv.workspace._2C+1,x
                
                dex
                dex
                bpl -

                ora vduv.workspace._2C+3     ;A=>width|>height
                bmi LC779 ;taken if either dimension negative - window invalid
                ldx #VDUVariables.queueEnd-4 ;left bottom
                jsr eigabsEntryPoint         ;convert to pixels
                ldx #VDUVariables.queueEnd-8 ;right top
                jsr eigabsEntryPoint         ;convert to pixels
                lda vduv.queueEnd-5          ;>bottom
                ora vduv.queueEnd-7          ;>left
                bmi LC779 ;taken if either bottom or left negative - window invalid
                lda vduv.queueEnd-1          ;>top
                bne LC779          ;taken if top>=256 - window invalid
                ldx vduv.currentScreenMODE
                lda vduv.queueEnd-3          ;>right
                sta ZTEMP+0
                lda vduv.queueEnd-4          ;<right
                lsr ZTEMP+0                  ;>(right/2)
                ror a                        ;<(right/2)
                lsr ZTEMP+0                  ;>(right/4)

                ; 639>>2=159 - so any valid pixel X in any mode will
                ; have an MSB of 0 after being shifted right 2.
                bne LC779 ;taken if right edge definitely off screen - window invalid
                ror a     ;<(right/4)
                lsr a     ;<(right/8)
                cmp modeMaxColumn,x
                beq LC772                    ;taken if right edge just on screen
                bpl LC779 ;taken if right edge off screen - window definitely invalid
LC772:
                ldy #VDUVariables.graphicsWindowPixelsLeft
                ldx #VDUVariables.queueEnd-8
                jsr copyEightBytesWithinVDUVariables
LC779:
                ldx #VDUVariables.graphicsCursorPositionX
                ldy #VDUVariables.workspace._28
                jmp exchangeFourVDUBytes

;-------------------------------------------------------------------------
;
; Call getBytesPerInclusiveTextRow, and store the result in the
; textWindowWidthInBytes VDU variable.
; 
setTextWindowWidthInBytes:
                jsr getBytesPerInclusiveTextRow                    ; C780= 20 3B C9     ;I
                sta vduv.textWindowWidthInBytes+0
                stx vduv.textWindowWidthInBytes+1
                rts                          ; C789= 60          `

;-------------------------------------------------------------------------
;
; VDU 29 (&1D) Define graphics origin [MasRef E.3-35]
; 
vdu29EntryPoint:
                ldx #VDUVariables.queueEnd-4
                ldy #VDUVariables.graphicsWindowOriginX
                jsr copyFourBytesWithinVDUVariables
                jmp LC4DF                    ; C791= 4C DF C4    L_D

;-------------------------------------------------------------------------
;
; VDU 22 (&16) Select screen mode [MasRef E.3-11]
; 
vdu22EntryPoint:
                lda vduv.queueEnd-1          ;get MODE number
                bra setMODE

;-------------------------------------------------------------------------
; 
setStartupMODE:
                .if version==350
                jsr callWithTST
                .endif
                sta ZTEMP+0                  ;save MODE
                lda $F4
                pha    
                ora #$80                     ;page in ANDY
                jsr selectROMA               
                jsr +                    
                pla
                jmp selectROMA               ;restore old ROM

+
                ; TODO but what of the reserved byte here?
                ldx #size(VDUVariables)-1
                stz STATE
                lda vduv.cursorFlags
-
                stz vduv-1,x                  ; C7B1= 9E FF 02    ...
                dex                          ; C7B4= CA          J
                bne -
                sta vduv.cursorFlags
                lda ZTEMP                    ;restore MODE

                ; fall through to setMODE

;-------------------------------------------------------------------------
;
;
;
setMODE:
                stz vduDriverMemory
                stz displayMemory
                tay                          ;Y=mode
                bmi setShadowMODE
                ldx shadowRAMState
                beq setShadowMODE
                lda #STATE.isShadowMode
                trb STATE
                lda #ACCCON.D|ACCCON.E
                trb ACCCON ;display main RAM, VDU code accesses main RAM
                bra +

setShadowMODE:
                lda #STATE.isShadowMode
                tsb STATE
                lda #ACCCON.D|ACCCON.E
                tsb ACCCON ;display shadow RAM, VDU code accesses shadow RAM
+
                tya                          ;A=mode
                and #$07                     ;get MODE 0-7
                tax                          ;X=MODE 0-7
                stx vduv.currentScreenMODE
                lda numberOfLogicalColoursMinusOneForMODE,x
                sta vduv.numberOfLogicalColoursMinusOne
                lda bytesPerCharacterForMODE,x
                sta vduv.bytesPerCharacter
                lda pixelsPerByteMinusOneForMODE,x
                sta vduv.pixelsPerByteMinusOne
                bne +                        ;taken if graphics mode
                lda #$07                     ;assume 8 px/byte for non-graphics modes
+
                asl a            ;convert to pixelMasks index for rightmost pixel
                tay
                lda pixelMasks-1,y
                sta vduv.colourMaskRight
-
                asl a
                bpl -   ;keep shifting until leftmost pixel mask found
                sta vduv.colourMaskLeft
                ldy screenMODEGroupForMODE,x
                sty vduv.currentScreenMODEGroup
                lda latchBit4ForScreenMODEGroup,y
                php                          ; C812= 08          .
                sei                          ; C813= 78          x
                sta systemVIA.orb            ; C814= 8D 40 FE    .@~
                lda latchBit5ForScreenMODEGroup,y
                sta systemVIA.orb            ; C81A= 8D 40 FE    .@~
                plp                          ; C81D= 28          (
                lda screenSizeHighByteForScreenMODEGroup,y
                sta vduv.screenSizeHighByte
                lda startScreenAddressHighByteForScreenMODEGroup,y
                sta vduv.startScreenAddressHighByte
                lda #STATE.isVDU21|STATE.isCursorEditing|STATE.isVDU5|STATE.isTextWindow|STATE.isPagedScrolling|STATE.isScrollingDisabled
                trb STATE
                ldx vduv.currentScreenMODE
                lda vcontrolForScreenMODE,x
                jsr setVCONTROL
                php            
                sei            
                ldx crtcRegisterLastIndexForScreenMODEGroup,y    
                ldy #$0B       
-
                lda crtcRegisterValues,x
                jsr setCRTCRegister
                dex                
                dey                
                bpl -
                plp           
                jsr vdu20EntryPoint
                jsr vdu23_11_EntryPoint
                lda #%10101010
                sta vduv.dotPattern
                sta vduv.dotPatternState
                jsr vdu26EntryPoint
                lda vduv.textWindowWidthInBytes+0        
                ldx vduv.textWindowWidthInBytes+1
                sta vduv.bytesPerCharacterRow+0          
                stx vduv.bytesPerCharacterRow+1

                ; Do a fast hardware CLS of the whole screen
                ; ------------------------------------------
clsFastPath:
                ldx #$00
                lda vduv.startScreenAddressHighByte
                stz vduv.screenTopLeftAddress+0
                sta vduv.screenTopLeftAddress+1
                jsr setCRTCCursorAddress
                ldy #$0C
                jsr setCRTCAddressRegisters
                stz pagedModeCounter                    ; C879= 9C 69 02    .i.
                sec                          ; C87C= 38          8
                lda #$80                     ; C87D= A9 80       ).
                sbc vduv.startScreenAddressHighByte
                tax
                ldy #$00
                jsr clearTextMemory
                jmp vdu30EntryPoint          ; C888= 4C 7C C4    L|D

LC88B:
                jsr LC8CF                    ; Clear paged mode counter
LC88E:
                jsr osbyte76    ; Call KEYV to test Shift & Ctrl keys
                bcc LC895                    ; Ctrl not pressed, exit loop
                bmi LC88B                    ; Shift pressed, loop back
LC895:
                lda STATE
                eor #STATE.isPagedScrolling
                and #STATE.isCursorEditing|STATE.isPagedScrolling|STATE.isScrollingDisabled;
                bne LC8D6
                jsr LC8D7
                lda vduv.textCursorXPosition,y
                cmp vduv.textWindowLeft,x
                bne LC8D3
                .if version==400||version==350
                cpy #0
                .else
                sec
                iny
                dey
                .endif
                bne LC8B5
                lda vduv.textWindowRight
                sbc vduv.textWindowLeft
                bra LC8BB

LC8B5:
                lda vduv.textWindowBottom
                sbc vduv.textWindowTop
LC8BB:
                pha
                lsr a
                lsr a
                sta ZTEMP+0
                sec
                pla
                sbc ZTEMP+0
                cmp pagedModeCounter
                bcs LC8D3
LC8C9:
                jsr osbyte76
                sec
                bpl LC8C9

LC8CF:
                stz pagedModeCounter        ; Clear paged mode counter
                .if version!=400&&version!=350
                nop
                .endif
LC8D3:
                inc pagedModeCounter
LC8D6:
                rts

LC8D7:
                lda vduv.cursorFlags
                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
                lsr a                        ;xvh
                tax
                lda LE204,x
                tax
                and #$01
                tay
                rts

;-------------------------------------------------------------------------
;
; Prepare AABB based on the current graphics cursor and some other
; coordinate.
;
; entry:
;
; X = VDU variable offset of other coordinate (4 bytes: X;Y;)
;
; exit:
;
; vduv.workspace._28 = minimum
;
; vduv.workspace._2c = maximum
;
prepareAABB:
                ldy #VDUVariables.graphicsCursorPixels
                jsr sortVDUVariableCoordinates
                phy                          ;save greater Y
                phx                          ;save lesser Y
                jsr sortVDUVariableWords     ;X=lesser X, Y=greater X
                pla                          ;A=lesser Y
                phy                          ;save greater X
                ldy #VDUVariables.workspace._28
                jsr +
                plx                          ;X=greater X
                pla                          ;A=greater Y
+
                ; Copy VDU variable word +X to VDU variable word+Y.
                ; Then cropy VDU variable word +A+2 to VDU variable
                ; word+Y+2. Return with updated Y.
                pha
                jsr copyTwoBytesWithinVDUVariables
                plx
                inx
                inx
                bra copyTwoBytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; Copy 8 bytes to workspace 28 in the VDU variables.
;
; entry:
;
; X = source offset
;
copyEightBytesToWorkspace28:
                ldy #VDUVariables.workspace._28
                
;-------------------------------------------------------------------------
;
; Copy 8 bytes in the VDU variables.
;
; entry:
;
; X = source offset
;
; Y = dest offset
; 
copyEightBytesWithinVDUVariables:
                lda #$08                     ; C904= A9 08       ).
                bra copyABytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; copyTextWindowWidthInBytesToWorkspace28
copyTextWindowWidthInBytesToWorkspace28:
                ldx #VDUVariables.textWindowWidthInBytes
                ldy #VDUVariables.workspace._28

;-------------------------------------------------------------------------
;
; 
copyTwoBytesWithinVDUVariables:
                lda #$02                     ; C90C= A9 02       ).
                bra copyABytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; Copy text window info to workspace2C.
; 
copyTextWindowToWorkspace2C:
                ldx #VDUVariables.textWindowLeft
                ldy #VDUVariables.workspace._2C
                bra copyFourBytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; Copy last 4 bytes of VDU queue somewhere.
;
copyLastFourVDUQueueBytes:
                ldx #VDUVariables.queueEnd-4
                bra copyFourBytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; Copy old graphics cursor position to current graphics cursor position.
; 
copyGraphicsCursorPixelsToOldGraphicsCursorPixels:
                ldy #VDUVariables.oldGraphicsCursorPixelsX

;-------------------------------------------------------------------------
;
; Copy the graphics cursor position somewhere.
; 
copyGraphicsCursorPixels:
                ldx #VDUVariables.graphicsCursorPixelsX

;-------------------------------------------------------------------------
;
; Copy 4 bytes in the VDU variables.
;
; entry:
;
; X = source offset
;
; Y = dest offset
; 
copyFourBytesWithinVDUVariables:
                lda #$04

                ; fall through to copyABytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; Copy some bytes in the VDU variables.
;
; entry:
;
; A = number of bytes
;
; X = source offset
;
; Y = dest offset
;
; exit:
;
; X = updated source offset
;
; Y = updated dest offset
;
copyABytesWithinVDUVariables:
                pha                          ; C920= 48          H
                lda vduv,x
                sta vduv,y
                inx                          ; C927= E8          h
                iny                          ; C928= C8          H
                pla                          ; C929= 68          h
                dec a                        ; C92A= 3A          :
                bne copyABytesWithinVDUVariables
                rts                          ; C92D= 60          `

;-------------------------------------------------------------------------
;
; Negate a 16-bit value stored in Y/A
;
; entry:
;
; Y (LSB), A (MSB) = value
;
; exit:
;
; Y (LSB), A (MSB) = -value
;
negateAY:
                pha
                tya
                eor #$FF
                tay
                pla
                eor #$FF
                iny      
                bne +
                inc a    
+
                rts      

;-------------------------------------------------------------------------
;
; Multiply a text window width by the number of bytes per char. There
; are inclusive and exclusive versions, depending on how the width was
; calculated.
;
; entry:
;
; A = value-1 to multiply (inclusive), value to multiply (exclusive)
;
; exit:
;
; A (lsb), X (msb) = value*vduv.bytesPerCharacter
; 
getBytesPerInclusiveTextRow:
                inc a                        ; C93B= 1A          .
getBytesPerExclusiveTextRow:
                sta $DA                      ; C93C= 85 DA       .Z
                stz $DB                      ; C93E= 64 DB       d[
                lda vduv.bytesPerCharacter    ;A=1/8/16/32
-
                lsr a
                bcs +                     ;taken when multiply is done
                asl $DA              ;shift size LSB
                rol $DB              ;carry into size MSB
                bra -

+
                lda $DA                      ; C94C= A5 DA       %Z
                ldx $DB                      ; C94E= A6 DB       &[
                rts                          ; C950= 60          `

;-------------------------------------------------------------------------
;
;
prepareForPlotBackground:
                ldx #$08                     ;plot background
                stx vduv.graphicsPlotState
                lda vduv.backgroundGCOLMode
                and #$0F                     ; C959= 29 0F       ).
                sta vduv.graphicsPlotMode
                rts                          ; C95E= 60          `

;-------------------------------------------------------------------------

LC95F:
                lda #$00                     ; C95F= A9 00       ).
                pha                          ; C961= 48          H
                pha                          ; C962= 48          H
                ldx $032A                    ; C963= AE 2A 03    .*.
                jsr LCC7D                    ; C966= 20 7D CC     }L
                bra LC97F                    ; C969= 80 14       ..

LC96B:
                sec                          ; C96B= 38          8
                lda $034F                    ; C96C= AD 4F 03    -O.
                sbc $032A                    ; C96F= ED 2A 03    m*.
                pha                          ; C972= 48          H
                jsr getDefaultBoundsForCurrentScreenMODE                    ; C973= 20 A2 E2     "b
                phx                          ; C976= DA          Z
                lda #$00                     ; C977= A9 00       ).
                ldx $032A                    ; C979= AE 2A 03    .*.
                jsr LCC5D                    ; C97C= 20 5D CC     ]L
LC97F:
                ; scroll left/right
                stx vduv.screenTopLeftAddress+0
                sta vduv.screenTopLeftAddress+1
                plx                          ; C985= FA          z
                ldy #$00                     ; C986= A0 00        .
                jsr getAddressForTextPosition
                plx                          ; C98B= FA          z
                lda #$00                     ; C98C= A9 00       ).
                jsr LCC5D                    ; C98E= 20 5D CC     ]L
                stx ZMEMT+0                      ; C991= 86 D8       .X
                sta ZMEMT+1                      ; C993= 85 D9       .Y
                jsr getDefaultBoundsForCurrentScreenMODE                    ; C995= 20 A2 E2     "b
                jsr LCAAE                    ; C998= 20 AE CA     .J
                bra LC9B8                    ; C99B= 80 1B       ..

LC99D:
                ldy #$00                     ; C99D= A0 00        .
                jsr LCC77                    ; C99F= 20 77 CC     wL
                bra LC9AA                    ; C9A2= 80 06       ..

LC9A4:
                jsr getDefaultBoundsForCurrentScreenMODE                    ; C9A4= 20 A2 E2     "b
                jsr LCC57                    ; C9A7= 20 57 CC     WL
LC9AA:
                stx vduv.screenTopLeftAddress+0
                sta vduv.screenTopLeftAddress+1
                ldx #$00                     ; C9B0= A2 00       ".
                jsr getAddressForTextPosition                    ; C9B2= 20 B0 CC     0L
                jsr LCAE8                    ; C9B5= 20 E8 CA     hJ
LC9B8:
                ldy #$0C
                lda vduv.screenTopLeftAddress+1
                ldx vduv.screenTopLeftAddress+0
                jmp setCRTCAddress

LC9C3:
                jsr LCCA0                    ; C9C3= 20 A0 CC      L
LC9C6:
                sta $DD                      ; C9C6= 85 DD       .]
                stx $DC                      ; C9C8= 86 DC       .\
                jsr LCC2C                    ; C9CA= 20 2C CC     ,L
                lda $0329                    ; C9CD= AD 29 03    -).
                ldx $0328                    ; C9D0= AE 28 03    .(.
                jsr LCC5D                    ; C9D3= 20 5D CC     ]L
                jsr LCC88                    ; C9D6= 20 88 CC     .L
                stx ZMEMT+0                      ; C9D9= 86 D8       .X
                sta ZMEMT+1                      ; C9DB= 85 D9       .Y
                lda #$00                     ; C9DD= A9 00       ).
                ldx $032A                    ; C9DF= AE 2A 03    .*.
                jsr LCC7D                    ; C9E2= 20 7D CC     }L
                jsr LCC88                    ; C9E5= 20 88 CC     .L
                stx $DA                      ; C9E8= 86 DA       .Z
                sta $DB                      ; C9EA= 85 DB       .[
                ldy $0328                    ; C9EC= AC 28 03    ,(.
                ldx $0329                    ; C9EF= AE 29 03    .).
                bvc LCA17                    ; C9F2= 50 23       P#
                ldy $E0                      ; C9F4= A4 E0       $`
                ldx $E1                      ; C9F6= A6 E1       &a
                jsr LCBE7                    ; C9F8= 20 E7 CB     gK
                ldy $E0                      ; C9FB= A4 E0       $`
                bcc LCA08                    ; C9FD= 90 09       ..
                ldx #$80                     ; C9FF= A2 80       ".
                stx $DB                      ; CA01= 86 DB       .[
                stz $DA                      ; CA03= 64 DA       dZ
                ldy $032A                    ; CA05= AC 2A 03    ,*.
LCA08:
                ldx #$00                     ; CA08= A2 00       ".
                jsr LCBF3                    ; CA0A= 20 F3 CB     sK
                ldx #$80                     ; CA0D= A2 80       ".
                stx ZMEMT+1                      ; CA0F= 86 D9       .Y
                stz ZMEMT+0                      ; CA11= 64 D8       dX
                ldy $DE                      ; CA13= A4 DE       $^
                ldx $DF                      ; CA15= A6 DF       &_
LCA17:
                jsr LCBE7                    ; CA17= 20 E7 CB     gK
                jsr LCC97                    ; CA1A= 20 97 CC     .L
                jsr LCC94                    ; CA1D= 20 94 CC     .L
                jsr LCC57                    ; CA20= 20 57 CC     WL
                stx ZMEMT+0                      ; CA23= 86 D8       .X
                sta ZMEMT+1                      ; CA25= 85 D9       .Y
                dec $032B                    ; CA27= CE 2B 03    N+.
                bpl LC9C6                    ; CA2A= 10 9A       ..
                rts                          ; CA2C= 60          `

LCA2D:
                jsr LCCA0                    ; CA2D= 20 A0 CC      L
LCA30:
                jsr LCC2C                    ; CA30= 20 2C CC     ,L
                lda #$00                     ; CA33= A9 00       ).
                ldx $032A                    ; CA35= AE 2A 03    .*.
                jsr LCC5D                    ; CA38= 20 5D CC     ]L
                stx $DA                      ; CA3B= 86 DA       .Z
                sta $DB                      ; CA3D= 85 DB       .[
                jsr LCC57                    ; CA3F= 20 57 CC     WL
                stx $DC                      ; CA42= 86 DC       .\
                sta $DD                      ; CA44= 85 DD       .]
                ldy $0328                    ; CA46= AC 28 03    ,(.
                ldx $0329                    ; CA49= AE 29 03    .).
                bvc LCA73                    ; CA4C= 50 25       P%
                ldy $DE                      ; CA4E= A4 DE       $^
                ldx $DF                      ; CA50= A6 DF       &_
                jsr LCBA8                    ; CA52= 20 A8 CB     (K
                ldy $DE                      ; CA55= A4 DE       $^
                bcc LCA63                    ; CA57= 90 0A       ..
                ldx $034E                    ; CA59= AE 4E 03    .N.
                stx $DB                      ; CA5C= 86 DB       .[
                stz $DA                      ; CA5E= 64 DA       dZ
                ldy $032A                    ; CA60= AC 2A 03    ,*.
LCA63:
                ldx #$00                     ; CA63= A2 00       ".
                jsr LCBB4                    ; CA65= 20 B4 CB     4K
                ldx $034E                    ; CA68= AE 4E 03    .N.
                stx ZMEMT+1                      ; CA6B= 86 D9       .Y
                stz ZMEMT+0                      ; CA6D= 64 D8       dX
                ldy $E0                      ; CA6F= A4 E0       $`
                ldx $E1                      ; CA71= A6 E1       &a
LCA73:
                jsr LCBA8                    ; CA73= 20 A8 CB     (K
                jsr LCC94                    ; CA76= 20 94 CC     .L
                dec $032B                    ; CA79= CE 2B 03    N+.
                bpl LCA30                    ; CA7C= 10 B2       .2
LCA7E:
                rts                          ; CA7E= 60          `

LCA7F:
                stx $DC                      ; CA7F= 86 DC       .\
                tax                          ; CA81= AA          *
                sec                          ; CA82= 38          8
                sbc $DC                      ; CA83= E5 DC       e\
                beq LCA7E                    ; CA85= F0 F7       pw
                sta $DD                      ; CA87= 85 DD       .]
                phx                          ; CA89= DA          Z
                jsr getBytesPerExclusiveTextRow                    ; CA8A= 20 3C C9     <I
                plx                          ; CA8D= FA          z
                lda $0366                    ; CA8E= AD 66 03    -f.
                bit #$08                     ; CA91= 89 08       ..
                bne LCAA0                    ; CA93= D0 0B       P.
                bit #$02                     ; CA95= 89 02       ..
                jsr LCCCA                    ; CA97= 20 CA CC     JL
                ldy $DA                      ; CA9A= A4 DA       $Z
                ldx $DB                      ; CA9C= A6 DB       &[
                bra LCACE                    ; CA9E= 80 2E       ..

LCAA0:
                bit #$04                     ; CAA0= 89 04       ..
                jsr LCCCA                    ; CAA2= 20 CA CC     JL
                lda $034F                    ; CAA5= AD 4F 03    -O.
                sta $032A                    ; CAA8= 8D 2A 03    .*.
                ldy $DD                      ; CAAB= A4 DD       $]
                dey                          ; CAAD= 88          .
LCAAE:
                tya                          ; CAAE= 98          .
                beq LCAC9                    ; CAAF= F0 18       p.
                sty $DC                      ; CAB1= 84 DC       .\
LCAB3:
                jsr LCC57                    ; CAB3= 20 57 CC     WL
                stx $DA                      ; CAB6= 86 DA       .Z
                sta $DB                      ; CAB8= 85 DB       .[
                jsr LCAC9                    ; CABA= 20 C9 CA     IJ
                ldx $DA                      ; CABD= A6 DA       &Z
                stx ZMEMT+0                      ; CABF= 86 D8       .X
                lda $DB                      ; CAC1= A5 DB       %[
                sta ZMEMT+1                      ; CAC3= 85 D9       .Y
                dec $DC                      ; CAC5= C6 DC       F\
                bne LCAB3                    ; CAC7= D0 EA       Pj
LCAC9:
                ldx #$00                     ; CAC9= A2 00       ".
                ldy $032A                    ; CACB= AC 2A 03    ,*.
LCACE:
                lda $0328                    ; CACE= AD 28 03    -(.
                pha                          ; CAD1= 48          H
                lda $0329                    ; CAD2= AD 29 03    -).
                pha                          ; CAD5= 48          H
                sty $0328                    ; CAD6= 8C 28 03    .(.
                stx $0329                    ; CAD9= 8E 29 03    .).
                jsr LCAE8                    ; CADC= 20 E8 CA     hJ
                pla                          ; CADF= 68          h
                sta $0329                    ; CAE0= 8D 29 03    .).
                pla                          ; CAE3= 68          h
                sta $0328                    ; CAE4= 8D 28 03    .(.
                rts                          ; CAE7= 60          `

;-------------------------------------------------------------------------

LCAE8:
                ldx ZMEMT+0                      ; CAE8= A6 D8       &X
                lda ZMEMT+1                      ; CAEA= A5 D9       %Y
                jsr LCC2C                    ; CAEC= 20 2C CC     ,L
                bra LCB6A                    ; CAEF= 80 79       .y

;-------------------------------------------------------------------------

LCAF1:
                ldx #<LCC77                     ; CAF1= A2 77       "w
                lda #>LCC77                     ; CAF3= A9 CC       )L
                ldy $032D                    ; CAF5= AC 2D 03    ,-.
                bra LCB01                    ; CAF8= 80 07       ..

LCAFA:
                ldx #<LCC57                     ; CAFA= A2 57       "W
                lda #>LCC57                     ; CAFC= A9 CC       )L
                ldy $032F                    ; CAFE= AC 2F 03    ,/.
LCB01:
                stx $035D                    ; CB01= 8E 5D 03    .].
                sta $035E                    ; CB04= 8D 5E 03    .^.
                sec                          ; CB07= 38          8
                lda $032D                    ; CB08= AD 2D 03    --.
                sbc $032F                    ; CB0B= ED 2F 03    m/.
                sta $032B                    ; CB0E= 8D 2B 03    .+.
                ldx $032C                    ; CB11= AE 2C 03    .,.
                jsr getAddressForTextPosition                    ; CB14= 20 B0 CC     0L
                sta $DD                      ; CB17= 85 DD       .]
                stx $DC                      ; CB19= 86 DC       .\
                jsr LCC2C                    ; CB1B= 20 2C CC     ,L
                lda $032B                    ; CB1E= AD 2B 03    -+.
                beq LCB6A                    ; CB21= F0 47       pG
LCB23:
                php                          ; CB23= 08          .
                jsr LC024                    ; CB24= 20 24 C0     $@
                stx $DA                      ; CB27= 86 DA       .Z
                sta $DB                      ; CB29= 85 DB       .[
                stx $DC                      ; CB2B= 86 DC       .\
                sta $DD                      ; CB2D= 85 DD       .]
                plp                          ; CB2F= 28          (
                bvc LCB4F                    ; CB30= 50 1D       P.
                clv                          ; CB32= B8          8
LCB33:
                ldx $DF                      ; CB33= A6 DF       &_
                ldy $DE                      ; CB35= A4 DE       $^
                jsr LCBB4                    ; CB37= 20 B4 CB     4K
                lda $034E                    ; CB3A= AD 4E 03    -N.
                bvs LCB45                    ; CB3D= 70 06       p.
                sta ZMEMT+1                      ; CB3F= 85 D9       .Y
                stz ZMEMT+0                      ; CB41= 64 D8       dX
                bra LCB49                    ; CB43= 80 04       ..

LCB45:
                sta $DB                      ; CB45= 85 DB       .[
                stz $DA                      ; CB47= 64 DA       dZ
LCB49:
                ldx $E1                      ; CB49= A6 E1       &a
                ldy $E0                      ; CB4B= A4 E0       $`
                bra LCB5A                    ; CB4D= 80 0B       ..

LCB4F:
                jsr LCC2C                    ; CB4F= 20 2C CC     ,L
                bvs LCB33                    ; CB52= 70 DF       p_
                ldx $0329                    ; CB54= AE 29 03    .).
                ldy $0328                    ; CB57= AC 28 03    ,(.
LCB5A:
                jsr LCBB4                    ; CB5A= 20 B4 CB     4K
                ldx $DC                      ; CB5D= A6 DC       &\
                stx ZMEMT+0                      ; CB5F= 86 D8       .X
                lda $DD                      ; CB61= A5 DD       %]
                sta ZMEMT+1                      ; CB63= 85 D9       .Y
                dec $032B                    ; CB65= CE 2B 03    N+.
                bne LCB23                    ; CB68= D0 B9       P9
LCB6A:
                ldx $0329                    ; CB6A= AE 29 03    .).
                ldy $0328                    ; CB6D= AC 28 03    ,(.
                bvc clearTextMemory
                ldx $DF                      ; CB72= A6 DF       &_
                ldy $DE                      ; CB74= A4 DE       $^
                jsr clearTextMemory
                lda $034E                    ; CB79= AD 4E 03    -N.
                sta ZMEMT+1                      ; CB7C= 85 D9       .Y
                stz ZMEMT+0                      ; CB7E= 64 D8       dX
                ldx $E1                      ; CB80= A6 E1       &a
                ldy $E0                      ; CB82= A4 E0       $`

;-------------------------------------------------------------------------
;
; Clear a block of text screen memory.
;
; entry:
;
; (ZMEMT),y - first byte to clear
;
; X = number of pages (including first, possibly partial page) to clear
;
clearTextMemory:
                ; align memory so that Y=0 on each page boundary
                ; crossing.
                ;
                ; e.g., on entry ZMEMT=$30f8, Y=$08 - then after,
                ; ZMEMT=$3000, Y=$F7; or, ZMEMT=$30f0, Y=$08 -> ZMEMT=$2ff8, Y=$F7.
                tya                          ;A=initial offset
                clc
                adc ZMEMT+0                  ;add to dest address
                sta ZMEMT+0                  
                bcs +
                dec ZMEMT+1                      ; CB8C= C6 D9       FY
+
                tya
                eor #$FF
                tay
                lsr a                        ;C set if odd
                lda vduv.backgroundTextColour
                bcs nextByte                    ;taken if odd - slightly different loop
                bra clearTextMemoryByte

clearTextMemoryLoop:
                sta (ZMEMT),y                  ; CB9A= 91 D8       .X
clearTextMemoryByte:
                iny                          ; CB9C= C8          H
                sta (ZMEMT),y                  ; CB9D= 91 D8       .X
nextByte:
                iny                          ; CB9F= C8          H
                bne clearTextMemoryLoop
                inc ZMEMT+1                      ; CBA2= E6 D9       fY
                dex                          ; CBA4= CA          J
                bpl clearTextMemoryLoop
                rts                          ; CBA7= 60          `

;-------------------------------------------------------------------------

LCBA8:
                sec                          ; CBA8= 38          8
                tya                          ; CBA9= 98          .
                sbc $032A                    ; CBAA= ED 2A 03    m*.
                tay                          ; CBAD= A8          (
                bcs LCBB4                    ; CBAE= B0 04       0.
                dex                          ; CBB0= CA          J
                bmi LCBE6                    ; CBB1= 30 33       03
                sec                          ; CBB3= 38          8
LCBB4:
                php                          ; CBB4= 08          .
                tya                          ; CBB5= 98          .
                clc                          ; CBB6= 18          .
                adc ZTEMP+0                      ; CBB7= 65 DA       eZ
                sta ZTEMP+0                      ; CBB9= 85 DA       .Z
                bcs LCBBF                    ; CBBB= B0 02       0.
                dec ZTEMP+1                      ; CBBD= C6 DB       F[
LCBBF:
                tya                          ; CBBF= 98          .
                clc                          ; CBC0= 18          .
                adc ZMEMT+0                      ; CBC1= 65 D8       eX
                sta ZMEMT+0                      ; CBC3= 85 D8       .X
                bcs LCBC9                    ; CBC5= B0 02       0.
                dec ZMEMT+1                      ; CBC7= C6 D9       FY
LCBC9:
                tya                          ; CBC9= 98          .
                eor #$FF                     ; CBCA= 49 FF       I.
                tay                          ; CBCC= A8          (
                lsr a                        ; CBCD= 4A          J
                bcs LCBDB                    ; CBCE= B0 0B       0.
                bra LCBD6                    ; CBD0= 80 04       ..

LCBD2:
                lda ($DA),y                  ; CBD2= B1 DA       1Z
                sta (ZMEMT),y                  ; CBD4= 91 D8       .X
LCBD6:
                iny                          ; CBD6= C8          H
                lda ($DA),y                  ; CBD7= B1 DA       1Z
                sta (ZMEMT),y                  ; CBD9= 91 D8       .X
LCBDB:
                iny                          ; CBDB= C8          H
                bne LCBD2                    ; CBDC= D0 F4       Pt
                inc $DB                      ; CBDE= E6 DB       f[
                inc ZMEMT+1                      ; CBE0= E6 D9       fY
                dex                          ; CBE2= CA          J
                bpl LCBD2                    ; CBE3= 10 ED       .m
LCBE5:
                plp                          ; CBE5= 28          (
LCBE6:
                rts                          ; CBE6= 60          `

LCBE7:
                sec                          ; CBE7= 38          8
                tya                          ; CBE8= 98          .
                sbc $032A                    ; CBE9= ED 2A 03    m*.
                tay                          ; CBEC= A8          (
                bcs LCBF3                    ; CBED= B0 04       0.
                dex                          ; CBEF= CA          J
                bmi LCBE6                    ; CBF0= 30 F4       0t
                sec                          ; CBF2= 38          8
LCBF3:
                php                          ; CBF3= 08          .
                tya                          ; CBF4= 98          .
                eor #$FF                     ; CBF5= 49 FF       I.
                pha                          ; CBF7= 48          H
                sec                          ; CBF8= 38          8
                adc $DA                      ; CBF9= 65 DA       eZ
                sta $DA                      ; CBFB= 85 DA       .Z
                bcs LCC01                    ; CBFD= B0 02       0.
                dec $DB                      ; CBFF= C6 DB       F[
LCC01:
                pla                          ; CC01= 68          h
                sec                          ; CC02= 38          8
                adc ZMEMT+0                      ; CC03= 65 D8       eX
                sta ZMEMT+0                      ; CC05= 85 D8       .X
                bcs LCC0B                    ; CC07= B0 02       0.
                dec ZMEMT+1                      ; CC09= C6 D9       FY
LCC0B:
                tya                          ; CC0B= 98          .
                lsr a                        ; CC0C= 4A          J
                bcs LCC23                    ; CC0D= B0 14       0.
                bne LCC1E                    ; CC0F= D0 0D       P.
LCC11:
                dex                          ; CC11= CA          J
                bmi LCBE5                    ; CC12= 30 D1       0Q
                dec $DB                      ; CC14= C6 DB       F[
                dec ZMEMT+1                      ; CC16= C6 D9       FY
                bra LCC1E                    ; CC18= 80 04       ..

LCC1A:
                lda ($DA),y                  ; CC1A= B1 DA       1Z
                sta (ZMEMT),y                  ; CC1C= 91 D8       .X
LCC1E:
                dey                          ; CC1E= 88          .
                lda ($DA),y                  ; CC1F= B1 DA       1Z
                sta (ZMEMT),y                  ; CC21= 91 D8       .X
LCC23:
                dey                          ; CC23= 88          .
                bne LCC1A                    ; CC24= D0 F4       Pt
                lda ($DA)                    ; CC26= B2 DA       2Z
                sta (ZMEMT)                    ; CC28= 92 D8       .X
                bra LCC11                    ; CC2A= 80 E5       .e

;-------------------------------------------------------------------------
;
; Get pointers for a text window row.
;
; entry:
;
; vduv.workspace._28; = text window stride, in bytes
;
; >A, <X = address
;
; exit:
;
; V=0: >A, <X = new address
;
; V=1: (ZTEMPC) = 

LCC2C:
                pha                          ;save >address
                txa                          ;A=<address
                clc
                adc vduv.workspace._28       ;A=<(new address)
                tax                          ;X=<(new address)
                pla                          ;restore >addcess
                adc vduv.workspace._29       ;A=>(new address)
                bvc rtsCC56                  ;taken if no address wrap
                stx ZTEMPD+0
                and #$7F                     ;
                sta ZTEMPD+1
                ora ZTEMPD+0
                beq clv_rts
                php
                sec
                lda vduv.workspace._28
                sbc ZTEMPD+0
                sta ZTEMPC+0
                lda vduv.workspace._29
                sbc ZTEMPD+1
                sta ZTEMPC+1
                plp
                rts

;-------------------------------------------------------------------------

clv_rts:
                clv                          ; CC55= B8          8
rtsCC56:
                rts                          ; CC56= 60          `

LCC57:
                lda vduv.bytesPerCharacterRow+1
                ldx vduv.bytesPerCharacterRow+0
LCC5D:
                clc                          ; CC5D= 18          .
LCC5E:
                php                          ; CC5E= 08          .
                pha                          ; CC5F= 48          H
                txa                          ; CC60= 8A          .
                adc ZMEMT+0                      ; CC61= 65 D8       eX
                tax                          ; CC63= AA          *
                pla                          ; CC64= 68          h
                adc ZMEMT+1                      ; CC65= 65 D9       eY
                bpl +
                sec
                sbc vduv.screenSizeHighByte ;handle wraparound at end
+
                cmp vduv.startScreenAddressHighByte
                bcs +
                adc vduv.screenSizeHighByte ;handle wraparound at start
+
                plp                          ; CC75= 28          (
                rts                          ; CC76= 60          `

LCC77:
                lda $0353                    ; CC77= AD 53 03    -S.
                ldx $0352                    ; CC7A= AE 52 03    .R.
LCC7D:
                pha                          ; CC7D= 48          H
                txa                          ; CC7E= 8A          .
                eor #$FF                     ; CC7F= 49 FF       I.
                tax                          ; CC81= AA          *
                pla                          ; CC82= 68          h
                eor #$FF                     ; CC83= 49 FF       I.
                sec                          ; CC85= 38          8
                bra LCC5E                    ; CC86= 80 D6       .V

LCC88:
                cmp $034E                    ; CC88= CD 4E 03    MN.
                bne LCC93                    ; CC8B= D0 06       P.
                cpx #$00                     ; CC8D= E0 00       `.
                bne LCC93                    ; CC8F= D0 02       P.
                lda #$80                     ; CC91= A9 80       ).
LCC93:
                rts                          ; CC93= 60          `

LCC94:
                jsr LCAC9                    ; CC94= 20 C9 CA     IJ
LCC97:
                ldx $DC                      ; CC97= A6 DC       &\
                stx ZMEMT+0                      ; CC99= 86 D8       .X
                lda $DD                      ; CC9B= A5 DD       %]
                sta ZMEMT+1                      ; CC9D= 85 D9       .Y
                rts                          ; CC9F= 60          `

LCCA0:
                sec                          ; CCA0= 38          8
                lda $032D                    ; CCA1= AD 2D 03    --.
                sbc $032F                    ; CCA4= ED 2F 03    m/.
                sta $032B                    ; CCA7= 8D 2B 03    .+.
                ldx $032C                    ; CCAA= AE 2C 03    .,.
                ldy $032F                    ; CCAD= AC 2F 03    ,/.

;-------------------------------------------------------------------------
;
; Get display address for a text position.
; 
getAddressForTextPosition:
                lda vduv.textCursorXPosition
                pha                          ; CCB3= 48          H
                lda vduv.textCursorYPosition
                pha                          ; CCB7= 48          H
                stx vduv.textCursorXPosition
                sty vduv.textCursorYPosition
                jsr updateZMEMTWithTextCursorPosition                    ; CCBE= 20 FA CC     zL
                ply                          ; CCC1= 7A          z
                sty vduv.textCursorYPosition
                ply                          ; CCC5= 7A          z
                sty vduv.textCursorXPosition
                rts                          ; CCC9= 60          `

;-------------------------------------------------------------------------

LCCCA:
                beq LCCCF
                dex
                stx ZTEMPB+0
LCCCF:
                lda vduv.cursorFlags
                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
                tax
                lda ZTEMPB+0
LCCD7:
                jsr setTextCursorXPositionWithCursorFlags
LCCDA:
                ldx vduv.textCursorXPosition
                cpx vduv.textWindowLeft
                bmi LCCF8            ;taken if off left edge of window
                cpx vduv.textWindowRight
                beq LCCE9            ;taken if at right edge of window
                bpl LCCF8            ;taken if off right edge of window
LCCE9:
                ldx vduv.textCursorYPosition
                cpx vduv.textWindowTop
                bmi LCCF8
                cpx vduv.textWindowBottom
                bmi updateZMEMTWithTextCursorPosition
                beq updateZMEMTWithTextCursorPosition
LCCF8:
                sec
                rts

;-------------------------------------------------------------------------
;
; Get display address for current text cursor position.
; 
; Set up display address without using BBC lookup table at &E0/1
; 
updateZMEMTWithTextCursorPosition:
                lda vduv.currentScreenMODEGroup
                and #$fe                     ; Reduce to 0,0,2,2,4
                tax                          ; Index into jump table
                ldy vduv.textCursorYPosition  ; Get current line
                jmp (multiplyRoutinesTable,x) ; Jump to calculation setup
                
multiplyRoutinesTable:
                .word multiplyBy640     ; Memory map 0,1  MODE 0,1,2,3
                .word multiplyBy320       ; Memory map 2,3  MODE 4,5,6
                .word multiplyBy40        ; Memory map 4    MODE 7

multiplyBy40:
                ldx multiplyBy40TableHigh,y ; Get offset high byte for start of this line
                lda multiplyBy40TableLow,y ; Get offset low byte for start of this line
                clc
                bra LCD29                    ; CD13= 80 14       ..

multiplyBy320:
                lda multiplyBy640TableHigh,y 
                lsr a                        
                tax                          
                tya                          
                and #$03                     
                lsr a                        
                ror a                        
                bra LCD28                    

multiplyBy640:
                ldx multiplyBy640TableHigh,y
                tya
                and #$01
                lsr a
LCD28:
                ror a                        ; A=A/2 +(128*carry)

LCD29:
                adc vduv.screenTopLeftAddress+0
                sta ZMEMT+0                      ; store it
                txa
                adc vduv.screenTopLeftAddress+1 ; window start address hi
                tay
                lda vduv.textCursorXPosition  ; text column
                ldx vduv.bytesPerCharacter    ; bytes per character
                dex
                beq LCD4E                    ; 1 colour, MODE 7
                cpx #$0F
                beq LCD43                    ; 4 colours, MODE 1 or MODE 5
                bcc LCD44                    ; 2 colours, MODE 0,3,4,6
                asl a                        ; 16 colours, MODE 2
LCD43:
                asl a                        ; CD43= 0A          .
LCD44:
                asl a                        ; CD44= 0A          .
                asl a                        ; CD45= 0A          .
                bcc LCD4A                    ; CD46= 90 02       ..
                iny                          ; CD48= C8          H
                iny                          ; CD49= C8          H
LCD4A:
                asl a                        ; CD4A= 0A          .
                bcc LCD4F                    ; CD4B= 90 02       ..
                iny                          ; CD4D= C8          H
LCD4E:
                clc                          ; CD4E= 18          .
LCD4F:
                adc ZMEMT+0                      ; CD4F= 65 D8       eX
                sta ZMEMT+0                      ; CD51= 85 D8       .X
                sta vduv.textCursorCRTCAddress+0
                tax                          ; CD56= AA          *
                tya                          ; CD57= 98          .
                adc #$00                     ; CD58= 69 00       i.
                sta vduv.textCursorCRTCAddress+1
                bpl LCD63                    ; CD5D= 10 04       ..
                sec                          ; CD5F= 38          8
                sbc vduv.screenSizeHighByte
LCD63:
                sta ZMEMT+1                      ; CD63= 85 D9       .Y
                clc                          ; CD65= 18          .
                rts                          ; CD66= 60          `

;-------------------------------------------------------------------------

nextMaskedCharColumn
                inc vduv.graphicsCursorPixelsX+0
                bne +
                inc vduv.graphicsCursorPixelsX+1
+
                asl a
plotMaskedCharRow:
                ; find next pixel to plot, updating graphics cursor X
                ; as it goes. A is non-zero, so this loop will finish
                ; eventually.
                bpl nextMaskedCharColumn
                phy
                sta ZTEMPB+1                 ;
                ldx #VDUVariables.graphicsCursorPixels
                jsr gaddrEntryPoint                    ; CD77= 20 C8 DE     H^
                bra plotMaskedCharPixel

plotMaskedCharPixelsLoop:
                bpl nextMaskedCharPixel
plotMaskedCharPixel:
                jsr plbyteEntryPoint
nextMaskedCharPixel
                lsr ZMASK
                bcc +
                jsr nextColumnAndResetMask
+
                asl ZTEMPB+1
                bne plotMaskedCharPixelsLoop
                ldx #VDUVariables.workspace._28
                ldy #VDUVariables.graphicsCursorPixelsX
                jsr copyTwoBytesWithinVDUVariables
                ply
                bra nextMaskedCharY

plotCharAtGraphicsCursor:
                jsr getSoftCharacterDefinitionAddress
                stz vduv.graphicsPlotState   ;plot in foreground colour
                lda vduv.foregroundGCOLMode
                and #$0F
plotFontDataAtGraphicsCursorWithPlotMode:
                sta vduv.graphicsPlotMode
                ldy #VDUVariables.workspace._28
                jsr copyGraphicsCursorPixels
                ldy #VDUVariables.graphicsCursorPixelsX
                ldx #VDUVariables.graphicsWindowPixelsLeft
                jsr getDistanceMask
                sta ZTEMPB+0                 
                ldx #VDUVariables.graphicsWindowPixelsRight
                jsr getDistanceMask
                ror a                        
                trb ZTEMPB+0
                ldx #VDUVariables.graphicsCursorPixelsY
                ldy #VDUVariables.graphicsWindowPixelsTop
                jsr getDistanceMask
                sta ZTEMPB+1
                ldx #VDUVariables.graphicsCursorPixelsY
                ldy #VDUVariables.graphicsWindowPixelsBottom
                jsr getDistanceMask
                ror a                        ; CDCA= 6A          j
                trb ZTEMPB+1
                ldy #$07                     ; CDCD= A0 07        .
copyMaskedCharLoop:
                lda (ZTEMPC),y               ;get font byte
                and ZTEMPB+0                 ;mask out columns
                lsr ZTEMPB+1                 ;test row
                bcs +
                lda #$00                     ;mask out this row
+
                sta vduv.workspace._2C,y
                dey
                bpl copyMaskedCharLoop
                ldy #$F8                     
plotMaskedCharLoop:
                lda vduv.workspace._2C-$f8,y ;get masked byte
                bne plotMaskedCharRow        ;taken if data to write
nextMaskedCharY:
                ldx vduv.graphicsCursorPixelsY+0
                bne +
                dec vduv.graphicsCursorPixelsY+1
+
                dec vduv.graphicsCursorPixelsY+0
                iny
                bne plotMaskedCharLoop
                ldx #VDUVariables.workspace._2A
                ldy #VDUVariables.graphicsCursorPixelsY
                jmp copyTwoBytesWithinVDUVariables

vdu127AtGraphicsCursor:
                ; CHR$127 is a solid block, not a backspace.
                lda #<terminal.chr127
                sta ZTEMPC+0
                lda #>terminal.chr127
                sta ZTEMPC+1
                ldx #$08
                stx vduv.graphicsPlotState   ;plot in background colour
                lda #$00
                bra plotFontDataAtGraphicsCursorWithPlotMode

LCE0C:
                jsr handleColumn81                    
                bcs plotCharAtGraphicsCursor          ;taken if VDU5
                ldx vduv.numberOfLogicalColoursMinusOne
                beq writeTeletextChar
                jsr getSoftCharacterDefinitionAddress
writeBitmapChar:
                ldy #$07                     ; CE19= A0 07        .
                cpx #$03
                beq write2bppChar            ;taken if MODE 1/5
                bcs write4bppChar                    ;taken if MODE 2
write1bppChar:
                lda (ZTEMPC),y                  ; CE21= B1 DE       1^
                ora ZORA                      ; CE23= 05 D2       .R
                eor ZEOR                      ; CE25= 45 D3       ES
                sta (ZMEMT),y                  ; CE27= 91 D8       .X
                dey                          ; CE29= 88          .
                bpl write1bppChar
                rts                          ; CE2C= 60          `

vdu127EntryPoint:
                lda #$20                     ; CE2D= A9 20       )
                bit $0366                    ; CE2F= 2C 66 03    ,f.
                bne LCE37                    ; CE32= D0 03       P.
                jsr vdu8EntryPoint           ; CE34= 20 9A C2     .B
LCE37:
                jsr testVDU5State            ; CE37= 20 D2 E2     Rb
                bne vdu127AtGraphicsCursor
                ldx vduv.numberOfLogicalColoursMinusOne
                beq writeTeletextSpaceChar   ;taken if teletext mode

                ; Address of space char is known.
                lda #<terminal.LB900
                sta ZTEMPC+0
                lda #>terminal.LB900
                sta ZTEMPC+1
                bra writeBitmapChar

writeTeletextSpaceChar:
                lda #$20                     ; CE4B= A9 20       )
writeTeletextChar:
                jsr getSAA5050FromASCII
                sta (ZMEMT)                    ; CE50= 92 D8       .X
                rts                          ; CE52= 60          `

write2bppChar:
                lda ZMEMT+1
                ldx ZMEMT+0
                jsr getNextColumnAddress
-
                lda (ZTEMPC),y               ;get font byte
                and #$0F                     ;get data for right 4 pixels
                tax
                lda LE013,x                  ;form byte
                ora ZORA
                eor ZEOR
                sta (ZTEMPD),y               ;write to right column
                lda (ZTEMPC),y               ;get font byte
                .if version==350
                jsr LE520
                .else
                lsr a                        ;
                lsr a                        ;
                lsr a                        ;
                lsr a                        ;get data for left 4 pixels
                .endif
                tax                          ;
                lda LE013,x                  ;form byte
                ora ZORA                      
                eor ZEOR                      
                sta (ZMEMT),y                ;write to left column
                dey                          ; CE78= 88          .
                bpl -
                rts                          ; CE7B= 60          `

write4bppChar:
                lda ZMEMT+1                      ; CE7C= A5 D9       %Y
                ldx ZMEMT+0                      ; CE7E= A6 D8       &X
                jsr getNext3ColumnAddresses
-
                lda (ZTEMPC),y               ;get font byte - %abcdefgh
                jsr get4bppScreenByteFor2Pixels ;pixels g and h
                sta ($E0),y                  
                lda (ZTEMPC),y               ;get font byte - %abcdefgh
                lsr a                        ;%0abcdefg
                lsr a                        ;%00abcdef
                pha                          ;save %00abcdef
                jsr get4bppScreenByteFor2Pixels ;pixels e and f
                sta (ZTEMPB),y                  
                pla                          ;restore %00abcdef
                lsr a                        ;%000abcde
                lsr a                        ;%0000abcd
                pha                          ;save %0000abcd
                jsr get4bppScreenByteFor2Pixels ;pixels c and d
                sta (ZTEMP),y                  
                pla                          ;restore %0000abcd
                lsr a                        ;%00000abc
                lsr a                        ;%000000ab
                jsr get4bppScreenByteFor2Pixels ;pixels a and b
                sta (ZMEMT),y                  
                dey                          
                bpl -
                rts                          

get4bppScreenByteFor2Pixels:
                and #$03                     ;mask out 2 pixels
                tax                          
                lda LE023,x                  ;form byte
                ora ZORA
                eor ZEOR
                rts

;-------------------------------------------------------------------------
;
; Get mask indicating the distance between two 16-bit VDU variable
; values - >=8, or some amount less than that.
;
; (These can be used for masking pixels, or counting loops, or
; whatever.)
;
; entry:
;
; X = offset of value A in VDU variables
;
; Y = offset of value B in VDU variables
;
; exit:
;
; if distance<=0, A=255, C=1
;
; if distance>=8, A=0, C=0
;
; otherwise, A=255>>distance, C=0
; 
getDistanceMask:
                sec
                lda vduv+0,x
                sbc vduv+0,y
                sta ZTEMP                    ;get result LSB
                lda vduv+1,x
                sbc vduv+1,y
                bmi distanceMask255                  ;taken if result -ve
                bne distanceMask0                  ;taken if result >=256
                ldx ZTEMP
                cpx #$08
                bcs distanceMask0                    ;taken if result>=8
                lda distanceMasksTable,x             ;get mask for <8 items
                rts

distanceMask255:
                lda #%11111111
                sec
                rts

distanceMask0:
                lda #$00
                clc
                rts

;-------------------------------------------------------------------------
;
; Get addresses of next 3 columns on screen.
;
; entry:
;
; A (MSB)/X (LSB) = address
;
; exit:
;
; (ZTEMP) = column N+1
; (ZTEMPB) = column N+2
; (ZTEMPC) = column N+3
; 
getNext3ColumnAddresses:
                jsr getNextColumnAddress
                stx ZTEMP+0
                sta ZTEMP+1
                jsr getNextColumnAddress
                stx ZTEMPB+0
                sta ZTEMPB+1

;-------------------------------------------------------------------------
;
; Get address of next column on screen.
;
; entry:
;
; A (MSB)/X (LSB) = address
;
; exit:
;
; A (MSB)/X (LSB) = address of next column
; (ZTEMPD) = address of next column
; 
getNextColumnAddress:
                pha                          
                txa                          
                clc                          
                adc #$08                     ;next column...
                tax                          
                pla                          
                bcc +                        ;taken if no carry
                inc a                        
                bpl +           ;taken if no screen address wraparound
                lda vduv.startScreenAddressHighByte
+
                stx ZTEMPD+0
                sta ZTEMPD+1
                rts                          

;-------------------------------------------------------------------------
;
; VDU 23 0 Control 6845 CRTC directly [MasRef E.3-12]
; 
vdu23_0_EntryPoint:
                lda vduv.queueEnd-7           ;get value
                ldy vduv.queueEnd-8           ;get register

                ; fall through to setCRTCRegister

;-------------------------------------------------------------------------
;
; Set a CRTC register, adjusting and/or noting values if appropriate.
;
; entry:
;
; Y = register to set
;
; A = value

setCRTCRegister:
                cpy #$07
                bcc setCRTCRegisterRaw
                bne +        ;taken if not setting R7

                ; Setting R7 (vsync position), so apply the *TV offset.
                adc tvOffset
+
                cpy #$08
                bne +                    ;taken if not setting R8

                ; Setting R8 (interlace/delay register), so apply the
                ; *TV interlace setting.
                ora #$00
                bmi +       ;branch taken if bit 7 set - this is taken
                            ;to imply the mode being set is Mode 7
                eor tvInterlace ;apply *TV interlace setting
+
                cpy #$0A                     ; CF15= C0 0A       @.
                bne setCRTCRegisterRaw

                ; Setting R10 (cursor start register). Note the new
                ; setting in the VDU variable. If in VDU5 mode, reuse
                ; the result of testVDU5State - i.e., 32 - as the
                ; setting, hiding the cursor.
                sta vduv.lastCursorStartRegisterValue
                jsr testVDU5State
                bne rtsCF2A
                lda vduv.lastCursorStartRegisterValue

                ; fall through to setCRTCRegisterRaw

;-------------------------------------------------------------------------
;
; Set a CRTC register.
; 
setCRTCRegisterRaw:
                sty CRTC+0                   ; CF24= 8C 00 FE    ..~
                sta CRTC+1                   ; CF27= 8D 01 FE    ..~
rtsCF2A:
                rts                          ; CF2A= 60          `

;-------------------------------------------------------------------------
;
; VDU 23 1 Turn cursor on/off [MasRef E.3-12]
; 
vdu23_1_EntryPoint:
                jsr testVDU5State
                bne rtsCF2A                  ;taken if VDU5
                lda vduv.queueEnd-8           ;get new cursor state
                and #$03                     ;mask off bits of interest
                asl a
                tax
                lda #$20 ;R10 value for hiding the cursor - save a few
                         ;bytes by loading this here
                jmp (LCF3C,x)

LCF3C:
                .word setCRTCRegister10            ; 23,1,0... - hide
                .word showCursor            ; 23,1,1... - show
                .word steadyCursor          ; 23,1,2... - steady
                .word slowFlashCursor       ; 23,1,3... - flash slowly

steadyCursor:
                lda #%01100000
                trb vduv.lastCursorStartRegisterValue ;steady cursor
                bra showCursor

slowFlashCursor:
                lda #%01100000
                tsb vduv.lastCursorStartRegisterValue ;slow blink cursor
showCursor:
                lda vduv.lastCursorStartRegisterValue
setCRTCRegister10:
                ldy #$0A
                bra setCRTCRegisterRaw

;-------------------------------------------------------------------------
;
; VDU 23 2–5 Set ECF patterns [MasRef E.3-13]
; 
vdu23_2_EntryPoint:
vdu23_3_EntryPoint:
vdu23_4_EntryPoint:
vdu23_5_EntryPoint:
                sbc #$01  ;subtract 2 (C=0 on entry...) to get pattern
                          ;index
                asl a                 
                asl a                 
                asl a                        ;index*8
                adc #$07                     ;index*8+7
                tay
                ldx #$07
-
                lda vduv.queueEnd-8,x
                sta andy.ecfPatterns,y
                dey
                dex
                bpl -
                bra LCF93                    ; CF6B= 80 26       .&

;-------------------------------------------------------------------------

vdu23_11_EntryPoint:
                lda vduv.currentScreenMODE
                bne +
                ; Use a different table for MODE 0 - see MasRef E.3-16.
                dec a                        ;
+
                and #$03 ;index=0 (mode 4); 1 (mode 1/5); 2 (mode 2);
                         ;3 (mode 0)
                inc a  
                asl a  
                asl a  
                asl a  
                asl a                        ;(index+1)*16
                tax
                ldy #32-4
setDefaultECFPatterns:
                lda defaultECFPatterns-1,x
                sta andy.ecfPatterns-1,y     ;copy first repeat
                sta andy.ecfPatterns+4-1,y   ;copy second repeat
                dex                          ;next byte in defaults table
                dey
                tya
                bit #$07
                bne setDefaultECFPatterns ;taken if pattern not filled
                ; skip to start of previous pattern
                dey
                dey
                dey
                dey
                bpl setDefaultECFPatterns
LCF93:
                jmp initializeCurrentECFPatterns

;-------------------------------------------------------------------------
;
; VDU 23 12–15 Set simple ECF pattern [MasRef E.3-17]
; 
vdu23_12_EntryPoint:
vdu23_13_EntryPoint:
vdu23_14_EntryPoint:
vdu23_15_EntryPoint:
                sbc #$0B                     ;-12 to get pattern index
                asl a                        ;index*2
                asl a                        ;index*4
                asl a                        ;index*8, C=0
                adc #$03                     ;index*8+3, C=0
                pha                          ;save offset
                ldx #$07                     ;
LCFA0:
                lda vduv.queueEnd-8,x        ;get simple pattern byte
                and vduv.numberOfLogicalColoursMinusOne ;apply logical colour limit
                sta ZTEMP+0
                lda vduv.numberOfLogicalColoursMinusOne
                and #$07                     ;1/3/7
                adc ZTEMP+0                  ;select 2/4/16 colour table
                tay
                lda solidColoursTable-1,y
                sta vduv.queueEnd-8,x
                dex
                bpl LCFA0
                lda #%01010101
                ldx vduv.currentScreenMODE
                bne +                 ;taken if not MODE 0
                lda #%00110011        ;double-width pattern for MODE 0
+
                sta ZTEMP+0
                ply
                ldx #$07
LCFC7:
                lda vduv.queueEnd-8,x
                dex
                eor vduv.queueEnd-8,x
                and ZTEMP+0
                eor vduv.queueEnd-8,x
                sta andy.ecfPatterns+0,y
                sta andy.ecfPatterns+4,y
                dey
                dex
                bpl LCFC7
                bra LCF93

;-------------------------------------------------------------------------
;
; VDU 23 6 Set dotted lines pattern [MasRef E.3-13]
; 
vdu23_6_EntryPoint:
                lda vduv.queueEnd-8
                sta vduv.dotPattern
                rts

;-------------------------------------------------------------------------
;
; VDU 23 7 Scroll window directly [MasRef E.3-14]
; 
vdu23_7_EntryPoint:
                lda vduv.queueEnd-8           ;get <m>
                bne scrollEntireScreen
                jsr copyTextWindowToWorkspace2C
                lda STATE
                and #STATE.isTextWindow
                asl a ;A=$10 (text window active) or $00 (no text window)
                bra +

scrollEntireScreen:
                lda #$00
                sta vduv.workspace._2C          ;left
                sta vduv.workspace._2F          ;top
                jsr getDefaultBoundsForCurrentScreenMODE
                stx vduv.workspace._2E          ;right
                sty vduv.workspace._2D          ;bottom
+
                sta ZTEMPB+0
                sec
                lda vduv.workspace._2E          ;right
                sbc vduv.workspace._2C          ;right-left
                jsr getBytesPerInclusiveTextRow
                sta vduv.workspace._28+0        ;bytes per row LSB
                stx vduv.workspace._28+1        ;bytes per row MSB
                ldx vduv.bytesPerCharacter
                cpx #$01
                beq +  ;when 1 byte/char, no cell/byte distinction
                lda vduv.queueEnd-6       ;get <z>
                beq +                ;taken if scrolling by 1 cell
                ldx #$08                 ;scroll by 1 horizontal byte
+
                stx vduv.workspace._2A

; <d> is a bitmask - %00000AVN.
;
; A is set if scrolling by axis (controlled by the VDU cursor flags)
; rather than by direction.
;
; V is set to scroll vertically/in Y rather than horizontally/in X.
;
; N is set to scroll in the negative direction.
                
                lda vduv.queueEnd-7           ;00000avn C=?
                lsr a                        ;000000av C=n
                php
                rol a                        ;00000avn C=0
                plp                          ;00000avn C=n
                rol a                        ;0000avnn C=0
                asl a                        ;000avnn0 C=0
                cmp #$10                     ;$10 = 000a0000
                bcc LD039                 ;taken if scrolling by direction
                eor vduv.cursorFlags       ;adjust axes
LD039:
                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
                ora ZTEMPB+0
LD03D:
                tax
                lda vduv.screenTopLeftAddress+0
                sta ZMEMT+0
                lda vduv.screenTopLeftAddress+1
                sta ZMEMT+1
                jsr callScrollRoutine
                jmp updateCRTCTextCursor                    ; D04B= 4C D8 C6    LXF

callScrollRoutine:
                jmp (scrollRoutinesTable,x)

LD051:
                phx                          ; D051= DA          Z
                jsr copyTextWindowToWorkspace2C
                jsr copyTextWindowWidthInBytesToWorkspace28                    ; D055= 20 08 C9     .I
                ldx $034F                    ; D058= AE 4F 03    .O.
                stx $032A                    ; D05B= 8E 2A 03    .*.
                pla                          ; D05E= 68          h
                lsr a                        ; D05F= 4A          J
                eor STATE                      ; D060= 45 D0       EP
                and #(~STATE.isTextWindow)&$ff
                eor STATE                      ; D064= 45 D0       EP
                asl a                        ; D066= 0A          .
                bra LD03D                    ; D067= 80 D4       .T

;-------------------------------------------------------------------------
;
; VDU 23 8 Clear block [MasRef E.3-15]
; 
vdu23_8_EntryPoint:
                stz $0334                    ; D069= 9C 34 03    .4.
                stz $0335                    ; D06C= 9C 35 03    .5.
                jsr getTextCursorPositionWithColumn81                    ; D06F= 20 52 E2     Rb
                stx $0336                    ; D072= 8E 36 03    .6.
                sty $0337                    ; D075= 8C 37 03    .7.
                jsr LE25C                    ; D078= 20 5C E2     \b
                inx                          ; D07B= E8          h
                stx $0338                    ; D07C= 8E 38 03    .8.
                sty $0339                    ; D07F= 8C 39 03    .9.
                ldy #$00                     ; D082= A0 00        .
                lda $031C                    ; D084= AD 1C 03    -..
                jsr LD0E5                    ; D087= 20 E5 D0     eP
                lda $031D                    ; D08A= AD 1D 03    -..
                jsr LD0E5                    ; D08D= 20 E5 D0     eP
                lda $0333                    ; D090= AD 33 03    -3.
                cmp $0331                    ; D093= CD 31 03    M1.
                bcc LD10E                    ; D096= 90 76       .v
                bne LD0A2                    ; D098= D0 08       P.
                lda $0330                    ; D09A= AD 30 03    -0.
                cmp $0332                    ; D09D= CD 32 03    M2.
                bcs LD10E                    ; D0A0= B0 6C       0l
LD0A2:
                lda $0318                    ; D0A2= AD 18 03    -..
                pha                          ; D0A5= 48          H
                lda $0319                    ; D0A6= AD 19 03    -..
                pha                          ; D0A9= 48          H
                ldy $0331                    ; D0AA= AC 31 03    ,1.
LD0AD:
                phy                          ; D0AD= 5A          Z
                lda $0366                    ; D0AE= AD 66 03    -f.
                eor #$08                     ; D0B1= 49 08       I.
                and #$0E                     ; D0B3= 29 0E       ).
                tax                          ; D0B5= AA          *
                tya                          ; D0B6= 98          .
                jsr setTextCursorXPositionWithCursorFlags                    ; D0B7= 20 C7 C2     GB
                ldx #$00                     ; D0BA= A2 00       ".
                lda $0338                    ; D0BC= AD 38 03    -8.
                cpy $0331                    ; D0BF= CC 31 03    L1.
                bne LD0C7                    ; D0C2= D0 03       P.
                ldx $0330                    ; D0C4= AE 30 03    .0.
LD0C7:
                cpy $0333                    ; D0C7= CC 33 03    L3.
                beq LD0D3                    ; D0CA= F0 07       p.
                jsr LCA7F                    ; D0CC= 20 7F CA     .J
                ply                          ; D0CF= 7A          z
                iny                          ; D0D0= C8          H
                bra LD0AD                    ; D0D1= 80 DA       .Z

LD0D3:
                lda $0332                    ; D0D3= AD 32 03    -2.
                jsr LCA7F                    ; D0D6= 20 7F CA     .J
                ply                          ; D0D9= 7A          z
                pla                          ; D0DA= 68          h
                sta $0319                    ; D0DB= 8D 19 03    ...
                pla                          ; D0DE= 68          h
                sta $0318                    ; D0DF= 8D 18 03    ...
                jmp updateZMEMTWithTextCursorPosition                    ; D0E2= 4C FA CC    LzL

LD0E5:
                pha                          ; D0E5= 48          H
                and #$03                     ; D0E6= 29 03       ).
                asl a                        ; D0E8= 0A          .
                jsr LD0F0                    ; D0E9= 20 F0 D0     pP
                pla                          ; D0EC= 68          h
                lsr a                        ; D0ED= 4A          J
                ora #$01                     ; D0EE= 09 01       ..
LD0F0:
                tax                          ; D0F0= AA          *
                and #$01                     ; D0F1= 29 01       ).
                pha                          ; D0F3= 48          H
                lda $0334,x                  ; D0F4= BD 34 03    =4.
                plx                          ; D0F7= FA          z
                clc                          ; D0F8= 18          .
                iny                          ; D0F9= C8          H
                adc $031D,y                  ; D0FA= 79 1D 03    y..
                bmi LD109                    ; D0FD= 30 0A       0.
                cmp $0338,x                  ; D0FF= DD 38 03    ]8.
                bcc LD10B                    ; D102= 90 07       ..
                lda $0338,x                  ; D104= BD 38 03    =8.
                bra LD10B                    ; D107= 80 02       ..

LD109:
                lda #$00                     ; D109= A9 00       ).
LD10B:
                sta $032F,y                  ; D10B= 99 2F 03    ./.
LD10E:
                rts                          ; D10E= 60          `

;-------------------------------------------------------------------------
;
; VDU 23 9 Set 1st flash time [MasRef E.3-16]
;
vdu23_9_EntryPoint:
                sec

;-------------------------------------------------------------------------
;
; VDU 23 10 Set 2nd flash time [MasRef E.3-16]
;
vdu23_10_EntryPoint:
                ldx vduv.queueEnd-8          ;get flash value
                ldy #$00                     ;Y=0 for OSBYTE call
                bcc doOSBYTE0A               ;taken if VDU23,10
                jmp osbyte09
doOSBYTE0A:
                sec                          ; D11A= 38          8
                jmp osbyte0A                    ; D11B= 4C 94 EC    L.l

;-------------------------------------------------------------------------
;
; VDU 23 16 Cursor movement control [MasRef E.3-17]
; 
vdu23_16_EntryPoint:
                lda vduv.cursorFlags
                and vduv.queueEnd-7          ;value AND <y>
                eor vduv.queueEnd-8          ;(value AND <y>) EOR <x>
                sta vduv.cursorFlags
                lsr a
                bcs rtsD145            ;taken if scrollProtect flag on
                ; scroll protect flag is off, so handle column 81 if
                ; necessary.

;-------------------------------------------------------------------------
;
; Handle column 81, if necessary.
;
; TODO - probably misnamed due to the return value
;
; exit:
;
; C=0 if not VDU 5
;
; C=1 if VDU 5
; 
handleColumn81:
                pha
                phx
                jsr testVDU5State
                sec
                bne plx_pla_rts        ;taken if VDU5
                clc
                bit vduv.column81
                bpl plx_pla_rts        ;taken if not column 81
                php
                jsr vdu13EntryPoint          ;CR
                jsr vdu10EntryPoint          ;LF
                plp
plx_pla_rts:
                plx                          ; D143= FA          z
                pla                          ; D144= 68          h
rtsD145:
                rts                          ; D145= 60          `

;-------------------------------------------------------------------------
; 
; Handle PLOT. [MasRef E.3-21]
;
; PLOT numbers are of the form %pppppamm, where %ppppp is the PLOT
; type, %a the absolute flag and %mm the PLOT mode.
;
; Absolute flag and mode are clear enough from [MasRef E.3-22]. The
; %ppppp part isn't documented as such, so here's a list:
;
; %00000 =  0 = 0-7 = Plot solid line (both endpoints included) [MasRef E.3-23]
; %00001 =  1 = 8-15 = Plot solid line (final point omitted) [MasRef E.3-23]
; %00010 =  2 = 16-23 = Plot solid line (final point omitted) [MasRef E.3-23]
; %00011 =  3 = 24-31 = Plot dotted line (final point omitted) [MasRef E.3-23]
; %00100 =  4 = 32-39 = Plot solid line (initial point omitted) [MasRef E.3-24]
; %00101 =  5 = 40-47 = Plot solid line (both endpoints omitted) [MasRef E.3-24]
; %00110 =  6 = 48-55 = Plot dotted line (initial point omitted) [MasRef E.3-24]
; %00111 =  7 = 56–63 = Plot dotted line (both endpoints omitted) [MasRef E.3-24]
; %01000 =  8 = 64–71 = Plot point [MasRef E.3-24]
; %01001 =  9 = 72–79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
; %01010 = 10 = 80–87 = Plot triangle [MasRef E.3-25]
; %01011 = 11 = 88–95 = Horizontal line fill (right to background) [MasRef E.3-25]
; %01100 = 12 = 96–103 = Plot rectangle [MasRef E.3-26]
; %01101 = 13 = 104–111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
; %01110 = 14 = 112–119 = Plot parallelogram [MasRef E.3-27]
; %01111 = 15 = 120–127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
; %10000 = 16 = 128–135 = Flood fill to non-background [MasRef E.3-28]
; %10001 = 17 = 136–143 = Flood fill to foreground [MasRef E.3-28]
; %10010 = 18 = 144–151 = Plot circle outline [MasRef E.3-28]
; %10011 = 19 = 152–159 = Plot filled circle [MasRef E.3-29]
; %10100 = 20 = 160–167 = Plot circular arc [MasRef E.3-29]
; %10101 = 21 = 168–175 = Plot filled chord segment [MasRef E.3-30]
; %10110 = 22 = 176–183 = Plot filled sector [MasRef E.3-30]
; %10111 = 23 = 184–191 = Move/copy rectangle [MasRef E.3-31]
; %11000 = 24 = 192–199 = Plot ellipse outline [MasRef E.3-32]
; %11001 = 25 = 200–207 = Plot solid ellipse [MasRef E.3-32]
; %11010 = 26 = 208-215 = Reserved [MasRef E.3-34]
; %11011 = 27 = 215-223 = Reserved [MasRef E.3-34]
; %11100 = 28 = 224-231 = Reserved [MasRef E.3-34]
; %11101 = 29 = 232-239 = Reserved for Acornsoft sprites [MasRef E.3-34]
; %11110 = 30 = 240-247 = User program calls [MasRef E.3-34]
; %11111 = 31 = 248-255 = User program calls [MasRef E.3-34]
;
; entry:
;
; vduQueueEnd-5 = PLOT number
;
; vduQueueEnd-3 = X coordinate
;
; vduQueueEnd-1 = Y coordinate
;; 
                
handlePLOT:
                ldx #VDUVariables.queueEnd-4
                jsr eigabsForPLOT
                lda vduv.queueEnd-5          ;get PLOT number
                ldy #gcolModeLeave                     ;
                and #$03                     ;mask out colour/plot mode [MasRef E.3-22]
                beq LD160 ;taken if <p> MOD 4=0 - early out
                lsr a                        ;C=1 if using VDU18 settings
                dey                          ;Y=gcolModeInvert
                bcc LD160                    ;taken if invert mode
                tax              ;X=0 if fg settings, 1 if bg settings
                ldy vduv.foregroundGCOLMode,x
                asl a
                asl a
                asl a
                tax              ;X=0 if fg settings, 8 if bg settings
LD160:
                stx vduv.graphicsPlotState
                tya
                and #$0F                     ; D164= 29 0F       ).
                sta vduv.graphicsPlotMode
                lda vduv.queueEnd-5          ;get PLOT number pppppmmm
                lsr a                        ;0pppppmm
                lsr a                        ;00pppppm
                and #$fe                     ;00ppppp0
                tax
                cmp #208/4
                bcs LD190                    ;taken if reserved PLOT
                and #$F3                     ;00pp00p0
                cmp #$12                     ;
                php                          ;
                beq LD184                ;taken if horizonal line fill
                cpx #184/4
                beq LD184                ;taken if move/copy rectangle
                cpy #gcolModeLeave
                beq LD19D
LD184:
                lda vduv.queueEnd-5          ;get PLOT number
                jsr LD193
                plp                          ; D18A= 28          (
                bne LD19E                    ; D18B= D0 11       P.
                jmp LC4DF                    ; D18D= 4C DF C4    L_D

LD190:
                jmp callVDUVForPLOT

LD193:
                cpx #64/4                     ; D193= E0 10       `.
                bcs LD19A                     ;taken if PLOT >=64
                jmp LD8A9                    ;handle line PLOTs

LD19A:
                jmp (plotEntryPointTable-8*2,x)

LD19D:
                pla                          ; D19D= 68          h
LD19E:
                jsr copyGraphicsCursorPixelsToOldGraphicsCursorPixels                    ; D19E= 20 1A C9     .I
                ldy #$24                     ; D1A1= A0 24        $
                jmp copyLastFourVDUQueueBytes                    ; D1A3= 4C 16 C9    L.I

LD1A6:
                ldx #VDUVariables.graphicsCursorPixelsX

;-------------------------------------------------------------------------
;
; WIND [MasRef E.4-7]. The result is a bit field, %vvhh, where %vv is
; the outcode for the vertical axis and %hh the outcode for the
; horizontal axis. Each outcode is %xn, where x is set if point above
; maximum and n set if point below minimum. (Of course, %11 is then
; not possible.)
;
; See https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm
;
; So the possible results, in binary, are:
;
; %1001 | %1000 | %1010
; ------+-------+------
; %0001 | %0000 | %0010
; ------+-------+------
; %0101 | %0100 | %0110
;
windEntryPoint:
                inx
                inx                          ;point to Y coordinate
                jsr getOutcodeForYAxis                    ;process Y coordinate
                dex
                dex                          ;point to X coordinate
                asl a
                asl a                        ;shift Y outcode into bits 2/3
                ldy #$00                     ;doing Y axis
                bra updateOutcodeForAxis

;-------------------------------------------------------------------------
;
getOutcodeForYAxis:
                ldy #$02                     ;Y=2 for Y coordinate
;-------------------------------------------------------------------------
;
; Get outcode for X or Y axis.
;
; entry:
;
; X = offset in VDU variables of coordinate
;
; Y = 0 if X axis, 2 if Y axis
;
; exit:
;
; ZTEMP?0 = outcode - 0, 1 or 2
;
; A = outcode
;
; N/Z set as per outcode
;
getOutcodeForAxis:
                lda #$00                     ;initialize result

;-------------------------------------------------------------------------
;
; Update outcode for X or Y axis
;
; entry: as per getOutcodeForAxis
;
; exit:
;
; ZTEMP?0 = updated; outcode is added to its existing value
;
updateOutcodeForAxis:
                sta ZTEMP+0                  ;save current result
                ; set flags for coordinate-minimum
                lda vduv+0,x                 
                cmp vduv.graphicsWindowPixelsLeft+0,y
                lda vduv+1,x                  
                sbc vduv.graphicsWindowPixelsLeft+1,y
                bmi add1ToOutcode ;taken if point below minimum - outcode is 1

                ; set flags for maximum-coordinate
                lda vduv.graphicsWindowPixelsRight+0,y
                cmp vduv+0,x                  ; D1CC= DD 00 03    ]..
                lda vduv.graphicsWindowPixelsRight+1,y
                sbc vduv+1,x
                bpl gotOutcode ;taken if point below maximum - axis outcode is 0
                ; point is above maximum - axis outcode is 2
add2ToOutcode:
                inc ZTEMP+0
add1ToOutcode:
                inc ZTEMP+0
gotOutcode:
                lda ZTEMP+0
                rts

;-------------------------------------------------------------------------
;
; EIGABS entry point.
; 
eigabsEntryPoint:
                lda #$FF ;pretend it's PLOT 255 (as that would be absolute coordinates)
                bra eigabsCommon

;-------------------------------------------------------------------------
;
; EIGABS, but for a VDU 25. Handles relative/absolute addressing,
; based on the PLOT number in the VDU queue.
; 
eigabsForPLOT:
                lda vduv.queueEnd-5          ;get PLOT number

;-------------------------------------------------------------------------
;
; EIGABS shared code.
;
eigabsCommon:
                sta ZTEMP+0                  ;save PLOT number
                ldy #$02                     ;process Y
                jsr handleExternalCoordinate
                jsr divideCoordinatesBy2     ;divide Y by 4 - convert 0-1023 to 0-255
                ldy #$00                     ;process X
                dex                          ;...
                dex                          ;...
                jsr handleExternalCoordinate
                ldy vduv.pixelsPerByteMinusOne
                cpy #$03  ;
                beq +     ;branch taken if mode 1/5 - divide by 4 or 8
                bcs ++    ;branch taken if mode 0/4 - divide by 2 or 4
                jsr divideCoordinatesBy2     ;mode 2 - divide by 8
+
                jsr divideCoordinatesBy2
+
                lda vduv.currentScreenMODEGroup
                bne divideCoordinatesBy2     ;branch taken if MODE 4/5
                rts

;-------------------------------------------------------------------------
;
; Handle external coordinate.
;
; 1. Deal with absolute or relative PLOTting
;
; 2. Update graphics cursor position
;
; 3. Handle window origin
;
; 4. Update input coordinate
;
; 5. Divide result by 2 (as this always needs doing at least once)
;
; entry:
;
; ZTEMP?0 = PLOT number
;
; X = offset-2 of external coordinates
;
; Y = 0 to process X coordinate, 2 to process Y coordinate
;
handleExternalCoordinate:
                clc
                lda ZTEMP+0                  ;get PLOT number
                and #$04                     ;get absolute/relative flag
                beq relativePLOT             ;branch taken if relative
absolutePLOT:
                lda vduv+2,x                 ;get coordinate LSB
                pha                          ;save coordinate LSB
                lda vduv+3,x                 ;get coordinate MSB
                bra LD229                    ;

relativePLOT:
                lda vduv+2,x                 ;get coordinate LSB
                adc vduv.graphicsCursorPositionX+0,y ;add current position LSB
                pha                                  ;save coordinate LSB
                lda vduv+3,x                 ;get coordinate MSB
                adc vduv.graphicsCursorPositionX+1,y ;add current position MSB
                clc
LD229:
                sta vduv.graphicsCursorPositionX+1,y ;update current position MSB
                adc vduv.graphicsWindowOriginX+1,y   ;add window origin MSB
                sta vduv+3,x                  ;update coordinate MSB
                pla                          ;restore coordinate LSB
                sta vduv.graphicsCursorPositionX+0,y ;update current position LSB
                clc
                adc vduv.graphicsWindowOriginX+0,y ;add window origin LSB
                sta vduv+2,x                       ;update coordinate LSB
                bcc +
                inc vduv+3,x       ;handle carry, ignored earlier
+
                
divideCoordinatesBy2:
                lda vduv+3,x
                asl a                        ;C=bit 7
                ror vduv+3,x                  ;signed divide by 2
                ror vduv+2,x                  ;signed divide by 2
                rts

;-------------------------------------------------------------------------

LD24D:
                phx                          ; D24D= DA          Z
                phy                          ; D24E= 5A          Z
                phy                          ; D24F= 5A          Z
                phx                          ; D250= DA          Z
                phy                          ; D251= 5A          Z
                jsr LD280                    ; D252= 20 80 D2     .R
                plx                          ; D255= FA          z
                jsr LD280                    ; D256= 20 80 D2     .R
                plx                          ; D259= FA          z
                ply                          ; D25A= 7A          z
                jsr LDAE8                    ; D25B= 20 E8 DA     hZ
                plx                          ; D25E= FA          z
                jsr LD268                    ; D25F= 20 68 D2     hR
                plx                          ; D262= FA          z
                bra LD268                    ; D263= 80 03       ..

LD265:
                jsr terminal.L9B09           ; D265= 20 09 9B     ..
LD268:
                ldy #$00                     ; D268= A0 00        .
                jsr LD270                    ; D26A= 20 70 D2     pR
                inx                          ; D26D= E8          h
                ldy #$02                     ; D26E= A0 02        .
LD270:
                sec                          ; D270= 38          8
                jsr LD276                    ; D271= 20 76 D2     vR
                inx                          ; D274= E8          h
                iny                          ; D275= C8          H
LD276:
                lda $0300,x                  ; D276= BD 00 03    =..
                sbc $0314,y                  ; D279= F9 14 03    y..
                sta $0300,x                  ; D27C= 9D 00 03    ...
LD27F:
                rts                          ; D27F= 60          `

LD280:
                ldy #$00                     ; D280= A0 00        .
                jsr LD288                    ; D282= 20 88 D2     .R
                inx                          ; D285= E8          h
                ldy #$02                     ; D286= A0 02        .
LD288:
                clc                          ; D288= 18          .
                jsr LD28E                    ; D289= 20 8E D2     .R
                inx                          ; D28C= E8          h
                iny                          ; D28D= C8          H
LD28E:
                lda $0300,x                  ; D28E= BD 00 03    =..
                adc $0314,y                  ; D291= 79 14 03    y..
                sta $0300,x                  ; D294= 9D 00 03    ...
                rts                          ; D297= 60          `

LD298:
                sta $E1                      ; D298= 85 E1       .a
                jsr LD425                    ; D29A= 20 25 D4     %T
                beq LD27F                    ; D29D= F0 E0       p`
                ldy #$14                     ; D29F= A0 14        .
                lda #$20                     ; D2A1= A9 20       )
                ldx #$2C                     ; D2A3= A2 2C       ",
                jsr LD265                    ; D2A5= 20 65 D2     eR
                jsr LD3AA                    ; D2A8= 20 AA D3     *S
                lda #$01                     ; D2AB= A9 01       ).
LD2AD:
                sty $E0                      ; D2AD= 84 E0       .`
                tsb $E0                      ; D2AF= 04 E0       .`
                ldx #VDUVariables.workspace._2C
                ldy #VDUVariables.workspace._28
                jsr copyFourBytesWithinVDUVariables
                bit $0335                    ; D2B8= 2C 35 03    ,5.
                php                          ; D2BB= 08          .
                ldx #$2C                     ; D2BC= A2 2C       ",
                jsr LD726                    ; D2BE= 20 26 D7     &W
                plp                          ; D2C1= 28          (
                bpl LD2C7                    ; D2C2= 10 03       ..
                jsr LD3AA                    ; D2C4= 20 AA D3     *S
LD2C7:
                ldy $032C                    ; D2C7= AC 2C 03    ,,.
                lda $032D                    ; D2CA= AD 2D 03    --.
                bmi LD2D2                    ; D2CD= 30 03       0.
                jsr negateAY                    ; D2CF= 20 2E C9     .I
LD2D2:
                pha                          ; D2D2= 48          H
                clc                          ; D2D3= 18          .
                tya                          ; D2D4= 98          .
                adc L8830                    ; D2D5= 6D 30 88    m0.
                tay                          ; D2D8= A8          (
                pla                          ; D2D9= 68          h
                adc L8831                    ; D2DA= 6D 31 88    m1.
                bpl LD2AD                    ; D2DD= 10 CE       .N
                inc a                        ; D2DF= 1A          .
                bne LD305                    ; D2E0= D0 23       P#
                iny                          ; D2E2= C8          H
                bne LD305                    ; D2E3= D0 20       P
                lda $E0                      ; D2E5= A5 E0       %`
                beq LD305                    ; D2E7= F0 1C       p.
                lda $032C                    ; D2E9= AD 2C 03    -,.
                cmp $0328                    ; D2EC= CD 28 03    M(.
                beq LD305                    ; D2EF= F0 14       p.
                ldx #$2C                     ; D2F1= A2 2C       ",
                ldy #$28                     ; D2F3= A0 28        (
                lda $0336                    ; D2F5= AD 36 03    -6.
                asl a                        ; D2F8= 0A          .
                eor $0336                    ; D2F9= 4D 36 03    M6.
                bpl LD302                    ; D2FC= 10 04       ..
                inx                          ; D2FE= E8          h
                inx                          ; D2FF= E8          h
                iny                          ; D300= C8          H
                iny                          ; D301= C8          H
LD302:
                jsr copyTwoBytesWithinVDUVariables                    ; D302= 20 0C C9     .I
LD305:
                jsr LD425                    ; D305= 20 25 D4     %T
                lda $0329                    ; D308= AD 29 03    -).
                tax                          ; D30B= AA          *
                eor $031C                    ; D30C= 4D 1C 03    M..
                bmi LD329                    ; D30F= 30 18       0.
                ldy #$02                     ; D311= A0 02        .
                jsr LD46F                    ; D313= 20 6F D4     oT
                bne LD324                    ; D316= D0 0C       P.
                ldx $032B                    ; D318= AE 2B 03    .+.
                ldy #$00                     ; D31B= A0 00        .
                jsr LD46F                    ; D31D= 20 6F D4     oT
                beq LD333                    ; D320= F0 11       p.
                eor #$80                     ; D322= 49 80       I.
LD324:
                stx $DA                      ; D324= 86 DA       .Z
                eor $DA                      ; D326= 45 DA       EZ
                tax                          ; D328= AA          *
LD329:
                txa                          ; D329= 8A          .
                and #$80                     ; D32A= 29 80       ).
                beq LD330                    ; D32C= F0 02       p.
                lda #$C0                     ; D32E= A9 C0       )@
LD330:
                tsb $E1                      ; D330= 04 E1       .a
                clc                          ; D332= 18          .
LD333:
                rts                          ; D333= 60          `

LD334:
                lda $E1                      ; D334= A5 E1       %a
                sta L8848                    ; D336= 8D 48 88    .H.
                bit #$03                     ; D339= 89 03       ..
                beq LD333                    ; D33B= F0 F6       pv
                lda #$10                     ; D33D= A9 10       ).
                sta $DC                      ; D33F= 85 DC       .\
                asl a                        ; D341= 0A          .
                sta $DD                      ; D342= 85 DD       .]
                ldx #$1B                     ; D344= A2 1B       ".
                jsr LD34F                    ; D346= 20 4F D3     OS
                asl $DC                      ; D349= 06 DC       .\
                lsr $DD                      ; D34B= 46 DD       F]
                ldx #$28                     ; D34D= A2 28       "(
LD34F:
                lda #$80                     ; D34F= A9 80       ).
                sta $DA                      ; D351= 85 DA       .Z
                lda $0302,x                  ; D353= BD 02 03    =..
                cmp L8832                    ; D356= CD 32 88    M2.
                bne LD333                    ; D359= D0 D8       PX
                lda $0303,x                  ; D35B= BD 03 03    =..
                cmp L8833                    ; D35E= CD 33 88    M3.
                bne LD333                    ; D361= D0 D0       PP
                ldy $0300,x                  ; D363= BC 00 03    <..
                lda $0301,x                  ; D366= BD 01 03    =..
                bpl LD370                    ; D369= 10 05       ..
                lsr $DA                      ; D36B= 46 DA       FZ
                jsr negateAY                    ; D36D= 20 2E C9     .I
LD370:
                cpy L8830                    ; D370= CC 30 88    L0.
                bne LD333                    ; D373= D0 BE       P>
                cmp L8831                    ; D375= CD 31 88    M1.
                bne LD333                    ; D378= D0 B9       P9
                lda $E1                      ; D37A= A5 E1       %a
                bit #$02                     ; D37C= 89 02       ..
                beq LD399                    ; D37E= F0 19       p.
                ldy #$30                     ; D380= A0 30        0
                bit #$01                     ; D382= 89 01       ..
                beq LD388                    ; D384= F0 02       p.
                ldy $DC                      ; D386= A4 DC       $\
LD388:
                tya                          ; D388= 98          .
                lsr a                        ; D389= 4A          J
                lsr a                        ; D38A= 4A          J
                bit $E1                      ; D38B= 24 E1       $a
                bne LD395                    ; D38D= D0 06       P.
                ora $DC                      ; D38F= 05 DC       .\
                tsb $E1                      ; D391= 04 E1       .a
                bra LD399                    ; D393= 80 04       ..

LD395:
                ora $DD                      ; D395= 05 DD       .]
                trb $E1                      ; D397= 14 E1       .a
LD399:
                lda $DA                      ; D399= A5 DA       %Z
                bit $E1                      ; D39B= 24 E1       $a
                beq LD330                    ; D39D= F0 91       p.
                trb $E1                      ; D39F= 14 E1       .a
                lda $E1                      ; D3A1= A5 E1       %a
                sta L8848                    ; D3A3= 8D 48 88    .H.
                sta L8849                    ; D3A6= 8D 49 88    .I.
                rts                          ; D3A9= 60          `

LD3AA:
                lda $032E                    ; D3AA= AD 2E 03    -..
                sta L8832                    ; D3AD= 8D 32 88    .2.
                lda $032F                    ; D3B0= AD 2F 03    -/.
                sta L8833                    ; D3B3= 8D 33 88    .3.
                jsr LD3FC                    ; D3B6= 20 FC D3     |S
                jsr LD513                    ; D3B9= 20 13 D5     .U
                sty L8830                    ; D3BC= 8C 30 88    .0.
                lda L8846                    ; D3BF= AD 46 88    -F.
                lsr a                        ; D3C2= 4A          J
                lda L883D                    ; D3C3= AD 3D 88    -=.
                bcc LD3CE                    ; D3C6= 90 06       ..
                cmp #$80                     ; D3C8= C9 80       I.
                ror a                        ; D3CA= 6A          j
                ror L8830                    ; D3CB= 6E 30 88    n0.
LD3CE:
                sta L8831                    ; D3CE= 8D 31 88    .1.
                rts                          ; D3D1= 60          `

LD3D2:
                stz L8847                    ; D3D2= 9C 47 88    .G.
                stz L8830                    ; D3D5= 9C 30 88    .0.
                stz L8831                    ; D3D8= 9C 31 88    .1.
                stz L8834                    ; D3DB= 9C 34 88    .4.
                stz L8835                    ; D3DE= 9C 35 88    .5.
                lda L8832                    ; D3E1= AD 32 88    -2.
                asl a                        ; D3E4= 0A          .
                sta L8836                    ; D3E5= 8D 36 88    .6.
                lda L8833                    ; D3E8= AD 33 88    -3.
                rol a                        ; D3EB= 2A          *
                sta L8837                    ; D3EC= 8D 37 88    .7.
                lda L8846                    ; D3EF= AD 46 88    -F.
                bit #$02                     ; D3F2= 89 02       ..
                beq LD3FC                    ; D3F4= F0 06       p.
                asl L8836                    ; D3F6= 0E 36 88    .6.
                rol L8837                    ; D3F9= 2E 37 88    .7.
LD3FC:
                lda L8846                    ; D3FC= AD 46 88    -F.
                lsr a                        ; D3FF= 4A          J
                lsr a                        ; D400= 4A          J
                ldy L8832                    ; D401= AC 32 88    ,2.
                lda L8833                    ; D404= AD 33 88    -3.
                jsr LD4C5                    ; D407= 20 C5 D4     ET
                sec                          ; D40A= 38          8
                ldx #$FC                     ; D40B= A2 FC       "|
LD40D:
                lda L873C,x                  ; D40D= BD 3C 87    =<.
                sbc L8744,x                  ; D410= FD 44 87    }D.
                sta L8744,x                  ; D413= 9D 44 87    .D.
                inx                          ; D416= E8          h
                bne LD40D                    ; D417= D0 F4       Pt
                rts                          ; D419= 60          `

LD41A:
                jsr copyGraphicsCursorPixelsToOldGraphicsCursorPixels
                stz $E1                      ; D41D= 64 E1       da
                ldx #$20                     ; D41F= A2 20       "
                jsr LD427                    ; D421= 20 27 D4     'T
                rts                          ; D424= 60          `

LD425:
                ldx #VDUVariables.graphicsCursorPixelsX
LD427:
                ldy #VDUVariables.queueEnd-9
                jsr copyFourBytesWithinVDUVariables
                ldx #$1B                     ; D42C= A2 1B       ".
                jsr LD268                    ; D42E= 20 68 D2     hR
                jsr LD486                    ; D431= 20 86 D4     .T
                jsr LD513                    ; D434= 20 13 D5     .U
                ldy #$0C                     ; D437= A0 0C        .
                jsr LD4AB                    ; D439= 20 AB D4     +T
                jsr LD513                    ; D43C= 20 13 D5     .U
                cmp #$20                     ; D43F= C9 20       I
                bcc LD448                    ; D441= 90 05       ..
                pla                          ; D443= 68          h
                pla                          ; D444= 68          h
                pla                          ; D445= 68          h
                pla                          ; D446= 68          h
                rts                          ; D447= 60          `

LD448:
                sty L8844                    ; D448= 8C 44 88    .D.
                sta L8845                    ; D44B= 8D 45 88    .E.
                lda L8846                    ; D44E= AD 46 88    -F.
                bit #$02                     ; D451= 89 02       ..
                beq LD45B                    ; D453= F0 06       p.
                lsr L8845                    ; D455= 4E 45 88    NE.
                ror L8844                    ; D458= 6E 44 88    nD.
LD45B:
                ldy L8844                    ; D45B= AC 44 88    ,D.
                lda L8845                    ; D45E= AD 45 88    -E.
                jsr negateAY                    ; D461= 20 2E C9     .I
                sty L8832                    ; D464= 8C 32 88    .2.
                sta L8833                    ; D467= 8D 33 88    .3.
                ora L8832                    ; D46A= 0D 32 88    .2.
                sec                          ; D46D= 38          8
                rts                          ; D46E= 60          `

LD46F:
                stz $DA                      ; D46F= 64 DA       dZ
                lda $031B,y                  ; D471= B9 1B 03    9..
                cmp $0328,y                  ; D474= D9 28 03    Y(.
                beq LD47B                    ; D477= F0 02       p.
                inc $DA                      ; D479= E6 DA       fZ
LD47B:
                lda $031C,y                  ; D47B= B9 1C 03    9..
                sbc $0329,y                  ; D47E= F9 29 03    y).
                bne LD485                    ; D481= D0 02       P.
                lda $DA                      ; D483= A5 DA       %Z
LD485:
                rts                          ; D485= 60          `

LD486:
                ldx $0355                    ; D486= AE 55 03    .U.
                lda LD4BF,x                  ; D489= BD BF D4    =?T
                sta L8846                    ; D48C= 8D 46 88    .F.
                lsr a                        ; D48F= 4A          J
                pha                          ; D490= 48          H
                ldx #$04                     ; D491= A2 04       ".
LD493:
                stz L8837,x                  ; D493= 9E 37 88    .7.
                dex                          ; D496= CA          J
                bne LD493                    ; D497= D0 FA       Pz
                jsr LD4A0                    ; D499= 20 A0 D4      T
                pla                          ; D49C= 68          h
                lsr a                        ; D49D= 4A          J
                ldx #$02                     ; D49E= A2 02       ".
LD4A0:
                ldy $031B,x                  ; D4A0= BC 1B 03    <..
                lda $031C,x                  ; D4A3= BD 1C 03    =..
                jsr LD4C5                    ; D4A6= 20 C5 D4     ET
                ldy #$10                     ; D4A9= A0 10        .
LD4AB:
                clc                          ; D4AB= 18          .
                ldx #$FC                     ; D4AC= A2 FC       "|
LD4AE:
                lda L873C,x                  ; D4AE= BD 3C 87    =<.
                adc L8830,y                  ; D4B1= 79 30 88    y0.
                sta L873C,x                  ; D4B4= 9D 3C 87    .<.
                sta L8744,x                  ; D4B7= 9D 44 87    .D.
                iny                          ; D4BA= C8          H
                inx                          ; D4BB= E8          h
                bne LD4AE                    ; D4BC= D0 F0       Pp
                rts                          ; D4BE= 60          `

LD4BF:
                .byte $02                    ; D4BF= 02          .
                brk                          ; D4C0= 00          .
                ora ($FF,x)                  ; D4C1= 01 FF       ..
                brk                          ; D4C3= 00          .
;ORA (&8C,x)      :\ D4C4= 01       ..
                .byte $01
LD4C5:
                sty L883C                    ; D4C5= 8C 3C 88
                bcc LD4CE                    ; D4C8= 90 04
                asl L883C                    ; D4CA= 0E 3C 88
                rol a                        ; D4CD= 2A
LD4CE:
                sta L883D                    ; D4CE= 8D 3D 88
                ldy L883C                    ; D4D1= AC 3C 88    ,<.
                tax                          ; D4D4= AA          *
                bpl LD4DA                    ; D4D5= 10 03       ..
                jsr negateAY                    ; D4D7= 20 2E C9     .I
LD4DA:
                sty L883C                    ; D4DA= 8C 3C 88    .<.
                sta L883D                    ; D4DD= 8D 3D 88    .=.
                sty L8840                    ; D4E0= 8C 40 88    .@.
                stz L8842                    ; D4E3= 9C 42 88    .B.
                stz L8843                    ; D4E6= 9C 43 88    .C.
                ldy #$0F                     ; D4E9= A0 0F        .
                lsr a                        ; D4EB= 4A          J
                sta L8841                    ; D4EC= 8D 41 88    .A.
                ror L8840                    ; D4EF= 6E 40 88    n@.
LD4F2:
                bcc LD507                    ; D4F2= 90 13       ..
                clc                          ; D4F4= 18          .
                lda L883C                    ; D4F5= AD 3C 88    -<.
                adc L8842                    ; D4F8= 6D 42 88    mB.
                sta L8842                    ; D4FB= 8D 42 88    .B.
                lda L883D                    ; D4FE= AD 3D 88    -=.
                adc L8843                    ; D501= 6D 43 88    mC.
                sta L8843                    ; D504= 8D 43 88    .C.
LD507:
                ldx #$03                     ; D507= A2 03       ".
LD509:
                ror L8840,x                  ; D509= 7E 40 88    ~@.
                dex                          ; D50C= CA          J
                bpl LD509                    ; D50D= 10 FA       .z
                dey                          ; D50F= 88          .
                bpl LD4F2                    ; D510= 10 E0       .`
                rts                          ; D512= 60          `

LD513:
                ldx #$02                     ; D513= A2 02       ".
LD515:
                stz L883C,x                  ; D515= 9E 3C 88    .<.
                stz $DB,x                    ; D518= 74 DB       t[
                dex                          ; D51A= CA          J
                bpl LD515                    ; D51B= 10 F8       .x
                ldy #$03                     ; D51D= A0 03        .
LD51F:
                lda L8840,y                  ; D51F= B9 40 88    9@.
                sta $DA                      ; D522= 85 DA       .Z
                phy                          ; D524= 5A          Z
                ldy #$03                     ; D525= A0 03        .
LD527:
                phy                          ; D527= 5A          Z
                sec                          ; D528= 38          8
                rol L883C                    ; D529= 2E 3C 88    .<.
                rol L883D                    ; D52C= 2E 3D 88    .=.
                rol L883E                    ; D52F= 2E 3E 88    .>.
                ldx #$01                     ; D532= A2 01       ".
                lda $DB                      ; D534= A5 DB       %[
LD536:
                asl $DA                      ; D536= 06 DA       .Z
                rol a                        ; D538= 2A          *
                rol $DC                      ; D539= 26 DC       &\
                rol $DD                      ; D53B= 26 DD       &]
                dex                          ; D53D= CA          J
                bpl LD536                    ; D53E= 10 F6       .v
                sta $DB                      ; D540= 85 DB       .[
                sec                          ; D542= 38          8
                sbc L883C                    ; D543= ED 3C 88    m<.
                tax                          ; D546= AA          *
                lda $DC                      ; D547= A5 DC       %\
                sbc L883D                    ; D549= ED 3D 88    m=.
                tay                          ; D54C= A8          (
                lda $DD                      ; D54D= A5 DD       %]
                sbc L883E                    ; D54F= ED 3E 88    m>.
                bcc LD55F                    ; D552= 90 0B       ..
                sta $DD                      ; D554= 85 DD       .]
                sty $DC                      ; D556= 84 DC       .\
                stx $DB                      ; D558= 86 DB       .[
                inc L883C                    ; D55A= EE 3C 88    n<.
                bra LD562                    ; D55D= 80 03       ..

LD55F:
                dec L883C                    ; D55F= CE 3C 88    N<.
LD562:
                ply                          ; D562= 7A          z
                dey                          ; D563= 88          .
                bpl LD527                    ; D564= 10 C1       .A
                ply                          ; D566= 7A          z
                dey                          ; D567= 88          .
                bpl LD51F                    ; D568= 10 B5       .5
                lsr L883E                    ; D56A= 4E 3E 88    N>.
                ror L883D                    ; D56D= 6E 3D 88    n=.
                ror L883C                    ; D570= 6E 3C 88    n<.
                stz L883E                    ; D573= 9C 3E 88    .>.
                stz L883F                    ; D576= 9C 3F 88    .?.
                ldy L883C                    ; D579= AC 3C 88    ,<.
                lda L883D                    ; D57C= AD 3D 88    -=.
                rts                          ; D57F= 60          `

;-------------------------------------------------------------------------
;
; Add dimension of region to a coordinate.
;
; entry:
;
; X = VDU variable offset of coordinate
;
; A = VDU variable offset of minimum coordinate of region
;
; Y = VDU variable offset of maximum coordinate of region
;
; ZTEMP?0 = VDU variable offset for result
;
; exit:
;
; result variable = coordinate+(min-max)
;
addRegionDimensionsToVDUVariableCoordinates:
                jsr addRegionDimensionToVDUVariableCoordinate ;do X

                ; bump offsets to do Y.
                iny
                iny
                inx
                inx
                inc a
                inc a
                inc ZTEMP+0
                inc ZTEMP+0

                ; TODO - not a great name. Could probably just be
                ; addDifference, or something.
addRegionDimensionToVDUVariableCoordinate:
                phx                          ;save VX
                phy                          ;save VY
                pha                          ;save VA
                clc
                lda vduv+0,x                 ;<VX
                adc vduv+0,y                 ;<(VX+VY)
                sta ZTEMPC+0                 ;ZTEMPC?0=<(VX+VY)
                lda vduv+1,x                 ;>VX
                adc vduv+1,y                 ;>(VX+VY)
                plx                          ;X=VA
                pha                          ;save >(VX+VY)
                ldy ZTEMP+0                  ;Y=VT
                sec
                lda ZTEMPC+0                 ;<(VX+VY)
                sbc vduv+0,x                 ;<(VX+VY-VA)
                sta vduv+0,y                 ;<VT=<(VX+VY-VA)
                pla                          ;>(VX+VY)
                sbc vduv+1,x                 ;>(VX+VY-VA)
                sta vduv+1,y                 ;>VT=<(VX+VY-VA)
                txa                          ;restore old A
                ply                          ;restore old Y
                plx                          ;restore old X
                rts

;-------------------------------------------------------------------------
;
; Sort points by Y coordinate, then X.
;
; entry:
;
; X = VDU variable offset of point A (4 bytes: X;Y;)
;
; Y = VDU variable offset of point B (4 bytes: X;Y;)
;
; exit:
;
; X = offset of point with lesser Y (or lesser X, if same Y)
;
; Y = offset of point with greater Y (or greater X, if same Y)
; 
sortVDUVariableCoordinates:
                sec
                lda vduv+2,y
                sbc vduv+2,x
                sta ZTEMPC
                lda vduv+3,y
                sbc vduv+3,x
                bmi exchangeXAndY           ;taken if PX.y>PY.y
                ora ZTEMPC
                bne rtsD5D5                  ;taken if PX.y<PY.y

;-------------------------------------------------------------------------
;
; Sort words by value.
;
; entry:
;
; X = VDU variable offset of word A
;
; Y = VDU variable offset of word B
;
; exit:
;
; X = offset of lesser value
;
; Y = offset of greater value
; 
sortVDUVariableWords:
                jsr compareVDUVariableWords
                bpl rtsD5D5
exchangeXAndY:
                txa
                phy
                plx
                tay
rtsD5D5:
                rts

;-------------------------------------------------------------------------
;
; Compare 2 16-bit VDU variable values.
;
; entry:
;
; X = offset of one variable
;
; Y = offset of the other variable
;
; exit:
;
; N=1 if X>Y
; 
compareVDUVariableWords:
                lda vduv+0,y
                cmp vduv+0,x
                lda vduv+1,y
                sbc vduv+1,x
                rts

;-------------------------------------------------------------------------

LD5E3:
                inc L8847                    ; D5E3= EE 47 88    nG.
LD5E6:
                lda L8847                    ; D5E6= AD 47 88    -G.
                bne LD5FA                    ; D5E9= D0 0F       P.
                lda L8832                    ; D5EB= AD 32 88    -2.
                ora L8833                    ; D5EE= 0D 33 88    .3.
                beq LD5E3                    ; D5F1= F0 F0       pp
                ldx #$00                     ; D5F3= A2 00       ".
                jsr LD644                    ; D5F5= 20 44 D6     DV
                bpl LD643                    ; D5F8= 10 49       .I
LD5FA:
                ldx #$02                     ; D5FA= A2 02       ".
                jsr LD644                    ; D5FC= 20 44 D6     DV
                bpl LD643                    ; D5FF= 10 42       .B
                ldx #$00                     ; D601= A2 00       ".
                jsr LD60A                    ; D603= 20 0A D6     .V
                bpl LD643                    ; D606= 10 3B       .;
                ldx #$02                     ; D608= A2 02       ".
LD60A:
                lda L8830,x                  ; D60A= BD 30 88    =0.
                bne LD612                    ; D60D= D0 03       P.
                dec L8831,x                  ; D60F= DE 31 88    ^1.
LD612:
                dec L8830,x                  ; D612= DE 30 88    ^0.
                txa                          ; D615= 8A          .
                lsr a                        ; D616= 4A          J
                inc a                        ; D617= 1A          .
                bit L8846                    ; D618= 2C 46 88    ,F.
                beq LD620                    ; D61B= F0 03       p.
                jsr LD620                    ; D61D= 20 20 D6      V
LD620:
                jsr LD636                    ; D620= 20 36 D6     6V
                clc                          ; D623= 18          .
                lda L8840                    ; D624= AD 40 88    -@.
                adc L8834,x                  ; D627= 7D 34 88    }4.
                sta L8840                    ; D62A= 8D 40 88    .@.
                lda L8841                    ; D62D= AD 41 88    -A.
                adc L8835,x                  ; D630= 7D 35 88    }5.
                sta L8841                    ; D633= 8D 41 88    .A.
LD636:
                php                          ; D636= 08          .
                lda L8834,x                  ; D637= BD 34 88    =4.
                bne LD63F                    ; D63A= D0 03       P.
                dec L8835,x                  ; D63C= DE 35 88    ^5.
LD63F:
                dec L8834,x                  ; D63F= DE 34 88    ^4.
                plp                          ; D642= 28          (
LD643:
                rts                          ; D643= 60          `

LD644:
                inc L8830,x                  ; D644= FE 30 88    ~0.
                bne LD64C                    ; D647= D0 03       P.
                inc L8831,x                  ; D649= FE 31 88    ~1.
LD64C:
                txa                          ; D64C= 8A          .
                lsr a                        ; D64D= 4A          J
                inc a                        ; D64E= 1A          .
                bit L8846                    ; D64F= 2C 46 88    ,F.
                beq LD657                    ; D652= F0 03       p.
                jsr LD657                    ; D654= 20 57 D6     WV
LD657:
                jsr LD66D                    ; D657= 20 6D D6     mV
                sec                          ; D65A= 38          8
                lda L8840                    ; D65B= AD 40 88    -@.
                sbc L8834,x                  ; D65E= FD 34 88    }4.
                sta L8840                    ; D661= 8D 40 88    .@.
                lda L8841                    ; D664= AD 41 88    -A.
                sbc L8835,x                  ; D667= FD 35 88    }5.
                sta L8841                    ; D66A= 8D 41 88    .A.
LD66D:
                php                          ; D66D= 08          .
                inc L8834,x                  ; D66E= FE 34 88    ~4.
                bne LD676                    ; D671= D0 03       P.
                inc L8835,x                  ; D673= FE 35 88    ~5.
LD676:
                plp                          ; D676= 28          (
                rts                          ; D677= 60          `

LD678:
                pha                          ; D678= 48          H
                sec                          ; D679= 38          8
                lda $0300,y                  ; D67A= B9 00 03    9..
                sbc $0300,x                  ; D67D= FD 00 03    }..
                pha                          ; D680= 48          H
                lda $0301,y                  ; D681= B9 01 03    9..
                sbc $0301,x                  ; D684= FD 01 03    }..
                ply                          ; D687= 7A          z
                cmp #$80                     ; D688= C9 80       I.
                bcc LD68F                    ; D68A= 90 03       ..
                jsr negateAY                    ; D68C= 20 2E C9     .I
LD68F:
                plx                          ; D68F= FA          z
                sta $0301,x                  ; D690= 9D 01 03    ...
                tya                          ; D693= 98          .
                sta $0300,x                  ; D694= 9D 00 03    ...
                rts                          ; D697= 60          `

LD698:
                ldx #$37                     ; D698= A2 37       "7
                jsr LD723                    ; D69A= 20 23 D7     #W
LD69D:
                bit $030A,x                  ; D69D= 3C 0A 03    <..
                bvs LD6B2                    ; D6A0= 70 10       p.
                rts                          ; D6A2= 60          `

LD6A3:
                ldx #$2C                     ; D6A3= A2 2C       ",
                jsr LD723                    ; D6A5= 20 23 D7     #W
LD6A8:
                bit $030A,x                  ; D6A8= 3C 0A 03    <..
                bvc LD6B2                    ; D6AB= 50 05       P.
                rts                          ; D6AD= 60          `

LD6AE:
                plx                          ; D6AE= FA          z
                jsr LD726                    ; D6AF= 20 26 D7     &W
LD6B2:
                lda $0309,x                  ; D6B2= BD 09 03    =..
                bmi LD6C7                    ; D6B5= 30 10       0.
                ldy #$03                     ; D6B7= A0 03        .
                phx                          ; D6B9= DA          Z
LD6BA:
                lda $0300,x                  ; D6BA= BD 00 03    =..
                cmp L881E,x                  ; D6BD= DD 1E 88    ]..
                bne LD6AE                    ; D6C0= D0 EC       Pl
                inx                          ; D6C2= E8          h
                dey                          ; D6C3= 88          .
                bpl LD6BA                    ; D6C4= 10 F4       .t
                plx                          ; D6C6= FA          z
LD6C7:
                rts                          ; D6C7= 60          `

LD6C8:
                jsr LD6FD                    ; D6C8= 20 FD D6     }V
                lda $030A,x                  ; D6CB= BD 0A 03    =..
                asl a                        ; D6CE= 0A          .
                asl a                        ; D6CF= 0A          .
                lda $030A,x                  ; D6D0= BD 0A 03    =..
                ror a                        ; D6D3= 6A          j
                sta $DA                      ; D6D4= 85 DA       .Z
                clc                          ; D6D6= 18          .
                bpl LD6E8                    ; D6D7= 10 0F       ..
                lda $0302,x                  ; D6D9= BD 02 03    =..
                sbc $0304                    ; D6DC= ED 04 03    m..
                tay                          ; D6DF= A8          (
                lda $0303,x                  ; D6E0= BD 03 03    =..
                sbc $0305                    ; D6E3= ED 05 03    m..
                bra LD6F5                    ; D6E6= 80 0D       ..

LD6E8:
                lda $0300                    ; D6E8= AD 00 03    -..
                sbc $0302,x                  ; D6EB= FD 02 03    }..
                tay                          ; D6EE= A8          (
                lda $0301                    ; D6EF= AD 01 03    -..
                sbc $0303,x                  ; D6F2= FD 03 03    }..
LD6F5:
                jsr LD7A4                    ; D6F5= 20 A4 D7     $W
                jsr LD6FD                    ; D6F8= 20 FD D6     }V
                bra LD755                    ; D6FB= 80 58       .X

LD6FD:
                txa                          ; D6FD= 8A          .
                inc a                        ; D6FE= 1A          .
                pha                          ; D6FF= 48          H
                inc a                        ; D700= 1A          .
                tay                          ; D701= A8          (
                jsr exchangeTwoVDUBytes     ; D702= 20 B2 E2     2b
                inx                          ; D705= E8          h
                inx                          ; D706= E8          h
                iny                          ; D707= C8          H
                iny                          ; D708= C8          H
                jsr exchangeTwoVDUBytes     ; D709= 20 B2 E2     2b
                plx                          ; D70C= FA          z
                jsr LD711                    ; D70D= 20 11 D7     .W
                dex                          ; D710= CA          J
LD711:
                lda $0308,x                  ; D711= BD 08 03    =..
                eor #$FF                     ; D714= 49 FF       I.
                sta $0308,x                  ; D716= 9D 08 03    ...
                rts                          ; D719= 60          `

LD71A:
                jsr LD726                    ; D71A= 20 26 D7     &W
LD71D:
                lda $0309,x                  ; D71D= BD 09 03    =..
                bpl LD71A                    ; D720= 10 F8       .x
                rts                          ; D722= 60          `

LD723:
                jsr LD71D                    ; D723= 20 1D D7     .W
LD726:
                lda $0309,x                  ; D726= BD 09 03    =..
                bpl LD755                    ; D729= 10 2A       .*
LD72B:
                clc                          ; D72B= 18          .
                lda $0308,x                  ; D72C= BD 08 03    =..
                adc $0304,x                  ; D72F= 7D 04 03    }..
                sta $0308,x                  ; D732= 9D 08 03    ...
                lda $0309,x                  ; D735= BD 09 03    =..
                adc $0305,x                  ; D738= 7D 05 03    }..
                sta $0309,x                  ; D73B= 9D 09 03    ...
                bmi LD743                    ; D73E= 30 03       0.
                jsr LD755                    ; D740= 20 55 D7     UW
LD743:
                phx                          ; D743= DA          Z
                inx                          ; D744= E8          h
                inx                          ; D745= E8          h
                bit $0308,x                  ; D746= 3C 08 03    <..
                bmi LD76E                    ; D749= 30 23       0#
LD74B:
                inc $0300,x                  ; D74B= FE 00 03    ~..
                bne LD753                    ; D74E= D0 03       P.
                inc $0301,x                  ; D750= FE 01 03    ~..
LD753:
                plx                          ; D753= FA          z
                rts                          ; D754= 60          `

LD755:
                sec                          ; D755= 38          8
                lda $0308,x                  ; D756= BD 08 03    =..
                sbc $0306,x                  ; D759= FD 06 03    }..
                sta $0308,x                  ; D75C= 9D 08 03    ...
                lda $0309,x                  ; D75F= BD 09 03    =..
                sbc $0307,x                  ; D762= FD 07 03    }..
                sta $0309,x                  ; D765= 9D 09 03    ...
                phx                          ; D768= DA          Z
                bit $030A,x                  ; D769= 3C 0A 03    <..
                bvc LD74B                    ; D76C= 50 DD       P]
LD76E:
                lda $0300,x                  ; D76E= BD 00 03    =..
                bne LD776                    ; D771= D0 03       P.
                dec $0301,x                  ; D773= DE 01 03    ^..
LD776:
                dec $0300,x                  ; D776= DE 00 03    ^..
                plx                          ; D779= FA          z
                rts                          ; D77A= 60          `

LD77B:
                clc                          ; D77B= 18          .
                lda $030A,x                  ; D77C= BD 0A 03    =..
                sta $DA                      ; D77F= 85 DA       .Z
                bpl LD792                    ; D781= 10 0F       ..
                lda $0302,x                  ; D783= BD 02 03    =..
                sbc $0306                    ; D786= ED 06 03    m..
                tay                          ; D789= A8          (
                lda $0303,x                  ; D78A= BD 03 03    =..
                sbc $0307                    ; D78D= ED 07 03    m..
                bra LD79F                    ; D790= 80 0D       ..

LD792:
                lda $0302                    ; D792= AD 02 03    -..
                sbc $0302,x                  ; D795= FD 02 03    }..
                tay                          ; D798= A8          (
                lda $0303                    ; D799= AD 03 03    -..
                sbc $0303,x                  ; D79C= FD 03 03    }..
LD79F:
                jsr LD7A4                    ; D79F= 20 A4 D7     $W
                bra LD72B                    ; D7A2= 80 87       ..

LD7A4:
                sty $DE                      ; D7A4= 84 DE       .^
                sta $DF                      ; D7A6= 85 DF       ._
                lda $0302,x                  ; D7A8= BD 02 03    =..
                ldy $0303,x                  ; D7AB= BC 03 03    <..
                asl $DA                      ; D7AE= 06 DA       .Z
                bcs LD7BC                    ; D7B0= B0 0A       0.
                adc $DE                      ; D7B2= 65 DE       e^
                sta $0302,x                  ; D7B4= 9D 02 03    ...
                tya                          ; D7B7= 98          .
                adc $DF                      ; D7B8= 65 DF       e_
                bra LD7C4                    ; D7BA= 80 08       ..

LD7BC:
                sbc $DE                      ; D7BC= E5 DE       e^
                sta $0302,x                  ; D7BE= 9D 02 03    ...
                tya                          ; D7C1= 98          .
                sbc $DF                      ; D7C2= E5 DF       e_
LD7C4:
                sta $0303,x                  ; D7C4= 9D 03 03    ...
                lda #$00                     ; D7C7= A9 00       ).
                bit $0309,x                  ; D7C9= 3C 09 03    <..
                bpl LD7CF                    ; D7CC= 10 01       ..
                dec a                        ; D7CE= 3A          :
LD7CF:
                sta $DC                      ; D7CF= 85 DC       .\
                lsr a                        ; D7D1= 4A          J
                sta $DD                      ; D7D2= 85 DD       .]
                ldy #$10                     ; D7D4= A0 10        .
LD7D6:
                lda $DD                      ; D7D6= A5 DD       %]
                asl a                        ; D7D8= 0A          .
                rol $0308,x                  ; D7D9= 3E 08 03    >..
                rol $0309,x                  ; D7DC= 3E 09 03    >..
                rol $DC                      ; D7DF= 26 DC       &\
                rol $DD                      ; D7E1= 26 DD       &]
                asl $DE                      ; D7E3= 06 DE       .^
                rol $DF                      ; D7E5= 26 DF       &_
                bcc LD802                    ; D7E7= 90 19       ..
                clc                          ; D7E9= 18          .
                lda $DC                      ; D7EA= A5 DC       %\
                adc $0304,x                  ; D7EC= 7D 04 03    }..
                sta $DC                      ; D7EF= 85 DC       .\
                lda $DD                      ; D7F1= A5 DD       %]
                adc $0305,x                  ; D7F3= 7D 05 03    }..
                sta $DD                      ; D7F6= 85 DD       .]
                bcc LD802                    ; D7F8= 90 08       ..
                inc $0308,x                  ; D7FA= FE 08 03    ~..
                bne LD802                    ; D7FD= D0 03       P.
                inc $0309,x                  ; D7FF= FE 09 03    ~..
LD802:
                dey                          ; D802= 88          .
                bne LD7D6                    ; D803= D0 D1       PQ
                bit $0309,x                  ; D805= 3C 09 03    <..
                bvc LD815                    ; D808= 50 0B       P.
                lda $DC                      ; D80A= A5 DC       %\
                sta $0308,x                  ; D80C= 9D 08 03    ...
                lda $DD                      ; D80F= A5 DD       %]
                sta $0309,x                  ; D811= 9D 09 03    ...
                rts                          ; D814= 60          `

LD815:
                ldy #$10                     ; D815= A0 10        .
LD817:
                rol $DC                      ; D817= 26 DC       &\
                rol $DD                      ; D819= 26 DD       &]
                rol $0308,x                  ; D81B= 3E 08 03    >..
                rol $0309,x                  ; D81E= 3E 09 03    >..
                sec                          ; D821= 38          8
                lda $0308,x                  ; D822= BD 08 03    =..
                sbc $0306,x                  ; D825= FD 06 03    }..
                sta $DE                      ; D828= 85 DE       .^
                lda $0309,x                  ; D82A= BD 09 03    =..
                sbc $0307,x                  ; D82D= FD 07 03    }..
                bcc LD83A                    ; D830= 90 08       ..
                sta $0309,x                  ; D832= 9D 09 03    ...
                lda $DE                      ; D835= A5 DE       %^
                sta $0308,x                  ; D837= 9D 08 03    ...
LD83A:
                dey                          ; D83A= 88          .
                bne LD817                    ; D83B= D0 DA       PZ
                rol $DC                      ; D83D= 26 DC       &\
                rol $DD                      ; D83F= 26 DD       &]
                sec                          ; D841= 38          8
                lda $0308,x                  ; D842= BD 08 03    =..
                sbc $0306,x                  ; D845= FD 06 03    }..
                sta $0308,x                  ; D848= 9D 08 03    ...
                lda $0309,x                  ; D84B= BD 09 03    =..
                sbc $0307,x                  ; D84E= FD 07 03    }..
                sta $0309,x                  ; D851= 9D 09 03    ...
                lda $0300,x                  ; D854= BD 00 03    =..
                ldy $0301,x                  ; D857= BC 01 03    <..
                asl $DA                      ; D85A= 06 DA       .Z
                bcs LD869                    ; D85C= B0 0B       0.
                sec                          ; D85E= 38          8
                adc $DC                      ; D85F= 65 DC       e\
                sta $0300,x                  ; D861= 9D 00 03    ...
                tya                          ; D864= 98          .
                adc $DD                      ; D865= 65 DD       e]
                bra LD872                    ; D867= 80 09       ..

LD869:
                clc                          ; D869= 18          .
                sbc $DC                      ; D86A= E5 DC       e\
                sta $0300,x                  ; D86C= 9D 00 03    ...
                tya                          ; D86F= 98          .
                sbc $DD                      ; D870= E5 DD       e]
LD872:
                sta $0301,x                  ; D872= 9D 01 03    ...
LD875:
                rts                          ; D875= 60          `

LD876:
                asl $0332                    ; D876= 0E 32 03    .2.
                ldy #$2C                     ; D879= A0 2C        ,
                jsr copyLastFourVDUQueueBytes                    ; D87B= 20 16 C9     .I
                asl $DB                      ; D87E= 06 DB       .[
                bcc LD88F                    ; D880= 90 0D       ..
                jsr LDA26                    ; D882= 20 26 DA     &Z
                beq LD875                    ; D885= F0 EE       pn
                ldx #$00                     ; D887= A2 00       ".
                lda $0332                    ; D889= AD 32 03    -2.
                jsr LDA0F                    ; D88C= 20 0F DA     .Z
LD88F:
                bit $DB                      ; D88F= 24 DB       $[
                bvc LD8A2                    ; D891= 50 0F       P.
                jsr LDA26                    ; D893= 20 26 DA     &Z
                beq LD875                    ; D896= F0 DD       p]
                ldx #$04                     ; D898= A2 04       ".
                lda $0332                    ; D89A= AD 32 03    -2.
                eor #$80                     ; D89D= 49 80       I.
                jsr LDA0F                    ; D89F= 20 0F DA     .Z
LD8A2:
                ldx #$28                     ; D8A2= A2 28       "(
                ldy #$2C                     ; D8A4= A0 2C        ,
                jmp LDAE8                    ; D8A6= 4C E8 DA    LhZ

LD8A9:
                asl a                        ; D8A9= 0A          .
                asl a                        ; D8AA= 0A          .
                sta $DB                      ; D8AB= 85 DB       .[
                and #$C0                     ; D8AD= 29 C0       )@
                eor #$40                     ; D8AF= 49 40       I@
                bne LD8B9                    ; D8B1= D0 06       P.
                lda $0367                    ; D8B3= AD 67 03    -g.
                sta $0368                    ; D8B6= 8D 68 03    .h.
LD8B9:
                jsr LD1A6                    ; D8B9= 20 A6 D1     &Q
                sta $DC                      ; D8BC= 85 DC       .\
                beq LD8C4                    ; D8BE= F0 04       p.
                lda #$80                     ; D8C0= A9 80       ).
                trb $DB                      ; D8C2= 14 DB       .[
LD8C4:
                ldx #$20                     ; D8C4= A2 20       "
                jsr windEntryPoint           ; D8C6= 20 A8 D1     (Q
                sta $E0                      ; D8C9= 85 E0       .`
                beq LD8D7                    ; D8CB= F0 0A       p.
                tax                          ; D8CD= AA          *
                lda #$20                     ; D8CE= A9 20       )
                trb $DB                      ; D8D0= 14 DB       .[
                txa                          ; D8D2= 8A          .
                bit $DC                      ; D8D3= 24 DC       $\
LD8D5:
                bne LD875                    ; D8D5= D0 9E       P.
LD8D7:
                ldy #$24                     ; D8D7= A0 24        $
                lda #$20                     ; D8D9= A9 20       )
                ldx #$28                     ; D8DB= A2 28       "(
                jsr terminal.L9B09           ; D8DD= 20 09 9B     ..
                bit $DB                      ; D8E0= 24 DB       $[
                bvs LD8EC                    ; D8E2= 70 08       p.
                lda $032E                    ; D8E4= AD 2E 03    -..
                ora $032F                    ; D8E7= 0D 2F 03    ./.
                beq LD876                    ; D8EA= F0 8A       p.
LD8EC:
                lda $DC                      ; D8EC= A5 DC       %\
                bit #$0C                     ; D8EE= 89 0C       ..
                beq LD900                    ; D8F0= F0 0E       p.
                ldx #$28                     ; D8F2= A2 28       "(
                jsr LD77B                    ; D8F4= 20 7B D7     {W
                ldx #$28                     ; D8F7= A2 28       "(
                jsr windEntryPoint           ; D8F9= 20 A8 D1     (Q
                bit $E0                      ; D8FC= 24 E0       $`
                bne LD8D5                    ; D8FE= D0 D5       PU
LD900:
                bit #$03                     ; D900= 89 03       ..
                beq LD90E                    ; D902= F0 0A       p.
                ldx #$28                     ; D904= A2 28       "(
                jsr LD6C8                    ; D906= 20 C8 D6     HV
                ldx #$28                     ; D909= A2 28       "(
                jsr windEntryPoint           ; D90B= 20 A8 D1     (Q
LD90E:
                tay                          ; D90E= A8          (
                bne LD8D5                    ; D90F= D0 C4       PD
                ldy #$20                     ; D911= A0 20
                ldx #$22                     ; D913= A2 22       ""
                lda $E0                      ; D915= A5 E0       %`
                beq LD928                    ; D917= F0 0F       p.
                ldy #$04                     ; D919= A0 04        .
                ldx #$06                     ; D91B= A2 06       ".
                bit $0332                    ; D91D= 2C 32 03    ,2.
                bpl LD924                    ; D920= 10 02       ..
                ldx #$02                     ; D922= A2 02       ".
LD924:
                bvc LD928                    ; D924= 50 02       P.
                ldy #$00                     ; D926= A0 00        .
LD928:
                clc                          ; D928= 18          .
                lda $0300,x                  ; D929= BD 00 03    =..
                sbc $032A                    ; D92C= ED 2A 03    m*.
                bcc LD934                    ; D92F= 90 03       ..
                inc a                        ; D931= 1A          .
                eor #$FF                     ; D932= 49 FF       I.
LD934:
                sta $DC                      ; D934= 85 DC       .\
                clc                          ; D936= 18          .
                lda $0300,y                  ; D937= B9 00 03    9..
                sbc $0328                    ; D93A= ED 28 03    m(.
                tax                          ; D93D= AA          *
                lda $0301,y                  ; D93E= B9 01 03    9..
                sbc $0329                    ; D941= ED 29 03    m).
                bmi LD952                    ; D944= 30 0C       0.
                inx                          ; D946= E8          h
                bne LD94A                    ; D947= D0 01       P.
                inc a                        ; D949= 1A          .
LD94A:
                eor #$FF                     ; D94A= 49 FF       I.
                tay                          ; D94C= A8          (
                txa                          ; D94D= 8A          .
                eor #$FF                     ; D94E= 49 FF       I.
                tax                          ; D950= AA          *
                tya                          ; D951= 98          .
LD952:
                sta $DD                      ; D952= 85 DD       .]
                stx $E0                      ; D954= 86 E0       .`
                ldx #$28                     ; D956= A2 28       "(
                jsr LDF41                    ; D958= 20 41 DF     A_
                asl $DB                      ; D95B= 06 DB       .[
                bcs LD989                    ; D95D= B0 2A       0*
LD95F:
                bit $DB                      ; D95F= 24 DB       $[
                bvc LD96E                    ; D961= 50 0B       P.
                lda $E0                      ; D963= A5 E0       %`
                and $DC                      ; D965= 25 DC       %\
                and $DD                      ; D967= 25 DD       %]
                inc a                        ; D969= 1A          .
                beq LD9A0                    ; D96A= F0 34       p4
                bit $DB                      ; D96C= 24 DB       $[
LD96E:
                bpl LD979                    ; D96E= 10 09       ..
                lda $0368                    ; D970= AD 68 03    -h.
                asl a                        ; D973= 0A          .
                rol $0368                    ; D974= 2E 68 03    .h.
                bcc LD989                    ; D977= 90 10       ..
LD979:
                lda ZMASK                      ; D979= A5 D1       %Q
                and ZGORA                      ; D97B= 25 D4       %T
                ora (ZMEMG),y                  ; D97D= 11 D6       .V
                sta $DA                      ; D97F= 85 DA       .Z
                lda ZMASK                      ; D981= A5 D1       %Q
                and ZGEOR                      ; D983= 25 D5       %U
                eor $DA                      ; D985= 45 DA       EZ
                sta (ZMEMG),y                  ; D987= 91 D6       .V
LD989:
                lda $0331                    ; D989= AD 31 03    -1.
                bpl LD9DC                    ; D98C= 10 4E       .N
                inc $DC                      ; D98E= E6 DC       f\
                beq LD9A0                    ; D990= F0 0E       p.
                bit $0332                    ; D992= 2C 32 03    ,2.
                bmi LD9A1                    ; D995= 30 0A       0.
                dey                          ; D997= 88          .
                dex                          ; D998= CA          J
                bpl LD9BF                    ; D999= 10 24       .$
                jsr LDA4C                    ; D99B= 20 4C DA     LZ
                bra LD9BF                    ; D99E= 80 1F       ..

LD9A0:
                rts                          ; D9A0= 60          `

LD9A1:
                iny                          ; D9A1= C8          H
                inx                          ; D9A2= E8          h
                cpx #$08                     ; D9A3= E0 08       `.
                bne LD9BF                    ; D9A5= D0 18       P.
                sec                          ; D9A7= 38          8
                tya                          ; D9A8= 98          .
                sbc #$08                     ; D9A9= E9 08       i.
                clc                          ; D9AB= 18          .
                adc $0352                    ; D9AC= 6D 52 03    mR.
                tay                          ; D9AF= A8          (
                lda ZMEMG+1                      ; D9B0= A5 D7       %W
                adc $0353                    ; D9B2= 6D 53 03    mS.
                bpl LD9BB                    ; D9B5= 10 04       ..
                sec                          ; D9B7= 38          8
                sbc $0354                    ; D9B8= ED 54 03    mT.
LD9BB:
                sta ZMEMG+1                      ; D9BB= 85 D7       .W
                ldx #$00                     ; D9BD= A2 00       ".
LD9BF:
                lda $0369                    ; D9BF= AD 69 03    -i.
                beq LD9C7                    ; D9C2= F0 03       p.
                jsr setupColourMasks        ; D9C4= 20 7C DA     |Z
LD9C7:
                clc                          ; D9C7= 18          .
                lda $0330                    ; D9C8= AD 30 03    -0.
                adc $032C                    ; D9CB= 6D 2C 03    m,.
                sta $0330                    ; D9CE= 8D 30 03    .0.
                lda $0331                    ; D9D1= AD 31 03    -1.
                adc $032D                    ; D9D4= 6D 2D 03    m-.
                sta $0331                    ; D9D7= 8D 31 03    .1.
                bmi LD95F                    ; D9DA= 30 83       0.
LD9DC:
                inc $E0                      ; D9DC= E6 E0       f`
                bne LD9E4                    ; D9DE= D0 04       P.
                inc $DD                      ; D9E0= E6 DD       f]
                beq LD9A0                    ; D9E2= F0 BC       p<
LD9E4:
                bit $0332                    ; D9E4= 2C 32 03    ,2.
                bvs LD9F2                    ; D9E7= 70 09       p.
                lsr ZMASK                      ; D9E9= 46 D1       FQ
                bcc LD9F9                    ; D9EB= 90 0C       ..
                jsr nextColumnAndResetMask                    ; D9ED= 20 67 DA     gZ
                bra LD9F9                    ; D9F0= 80 07       ..

LD9F2:
                asl ZMASK                      ; D9F2= 06 D1       .Q
                bcc LD9F9                    ; D9F4= 90 03       ..
                jsr previousColumnAndResetMask                    ; D9F6= 20 34 DA     4Z
LD9F9:
                sec                          ; D9F9= 38          8
                lda $0330                    ; D9FA= AD 30 03    -0.
                sbc $032E                    ; D9FD= ED 2E 03    m..
                sta $0330                    ; DA00= 8D 30 03    .0.
                lda $0331                    ; DA03= AD 31 03    -1.
                sbc $032F                    ; DA06= ED 2F 03    m/.
                sta $0331                    ; DA09= 8D 31 03    .1.
                jmp LD95F                    ; DA0C= 4C 5F D9    L_Y

LDA0F:
                bmi LDA1A                    ; DA0F= 30 09       0.
                inc $0328,x                  ; DA11= FE 28 03    ~(.
                bne LDA25                    ; DA14= D0 0F       P.
                inc $0329,x                  ; DA16= FE 29 03    ~).
                rts                          ; DA19= 60          `

LDA1A:
                lda $0328,x                  ; DA1A= BD 28 03    =(.
                bne LDA22                    ; DA1D= D0 03       P.
                dec $0329,x                  ; DA1F= DE 29 03    ^).
LDA22:
                dec $0328,x                  ; DA22= DE 28 03    ^(.
LDA25:
                rts                          ; DA25= 60          `

LDA26:
                ldy #$04                     ; DA26= A0 04        .
LDA28:
                lda $0327,y                  ; DA28= B9 27 03    9'.
                cmp $032B,y                  ; DA2B= D9 2B 03    Y+.
                bne LDA33                    ; DA2E= D0 03       P.
                dey                          ; DA30= 88          .
                bne LDA28                    ; DA31= D0 F5       Pu
LDA33:
                rts                          ; DA33= 60          `

;-------------------------------------------------------------------------

previousColumnAndResetMask:
                lda vduv.colourMaskRight
                sta ZMASK                      
                tya                          
                sbc #$08                     
                tay                          
                bcs rtsDA4B                  
                lda ZMEMG+1                  
                dec a                        
                cmp vduv.startScreenAddressHighByte
                bcs +
                lda #$7F                     ; DA47= A9 7F       ).
+
                sta ZMEMG+1                      ; DA49= 85 D7       .W
rtsDA4B:
                rts                          ; DA4B= 60          `
                
;-------------------------------------------------------------------------

LDA4C:
                clc                          ; DA4C= 18          .
                tya                          ; DA4D= 98          .
                adc #$08                     ; DA4E= 69 08       i.
                sec                          ; DA50= 38          8
                sbc $0352                    ; DA51= ED 52 03    mR.
                tay                          ; DA54= A8          (
                lda ZMEMG+1                      ; DA55= A5 D7       %W
                sbc $0353                    ; DA57= ED 53 03    mS.
                cmp $034E                    ; DA5A= CD 4E 03    MN.
                bcs LDA62                    ; DA5D= B0 03       0.
                adc $0354                    ; DA5F= 6D 54 03    mT.
LDA62:
                sta ZMEMG+1                      ; DA62= 85 D7       .W
                ldx #$07                     ; DA64= A2 07       ".
                rts                          ; DA66= 60          `

;-------------------------------------------------------------------------
;
nextColumnAndResetMask:
                lda vduv.colourMaskLeft
                sta ZMASK

;-------------------------------------------------------------------------
;
; Add 8 to (ZMEMG),Y, taking into account screen wrap.
;
; entry:
;
; C=1
;
; (ZMEMG),Y = screen address
;
; exit:
;
; (ZMEMG),Y = new screen address
;
nextColumn:
                tya                          ; DA6C= 98          .
                adc #$07                     ; DA6D= 69 07       i.
                tay                          ; DA6F= A8          (
                bcc +
                inc ZMEMG+1                      ; DA72= E6 D7       fW
                bpl +
                lda vduv.startScreenAddressHighByte
                sta ZMEMG+1                      ; DA79= 85 D7       .W
+
                rts                          ; DA7B= 60          `

;-------------------------------------------------------------------------
;
; Set up colour masks, taking into account ECF pattern.
;
; entry:
;
; X = scanline in row, 0-7
;
setupColourMasks:
                phx                          ;save scanline
                txa                          ;A=scanline
                ora vduv.graphicsPlotState   ;0-7 if fg, 8-15 if bg
                tax
                lda andy.fgECFPattern,x      ;get appropriate ECF byte
                ldx vduv.graphicsPlotMode
                pha
                ora zgoraORTable,x
                eor zgoraEORTable,x
                sta ZGORA
                pla
                ora zgeorORTable,x
                eor zgeorEORTable,x
                sta ZGEOR
                plx
                rts

;-------------------------------------------------------------------------

LDA9C:
                lda $0301,y                  ; DA9C= B9 01 03    9..
                pha                          ; DA9F= 48          H
                lda $0300,y                  ; DAA0= B9 00 03    9..
                pha                          ; DAA3= 48          H
                and $0361                    ; DAA4= 2D 61 03    -a.
                clc                          ; DAA7= 18          .
                adc $0361                    ; DAA8= 6D 61 03    ma.
                tay                          ; DAAB= A8          (
                lda pixelMasks-1,y                ; DAAC= B9 2E E1    9.a
                eor LE120,y                  ; DAAF= 59 20 E1    Y a
                sta $DC                      ; DAB2= 85 DC       .\
                lda $0300,x                  ; DAB4= BD 00 03    =..
                and $0361                    ; DAB7= 2D 61 03    -a.
                adc $0361                    ; DABA= 6D 61 03    ma.
                tay                          ; DABD= A8          (
                lda LE120,y                  ; DABE= B9 20 E1    9 a
                sta ZMASK                      ; DAC1= 85 D1       .Q
                sec                          ; DAC3= 38          8
                pla                          ; DAC4= 68          h
                ora $0361                    ; DAC5= 0D 61 03    .a.
                sbc $0300,x                  ; DAC8= FD 00 03    }..
                tay                          ; DACB= A8          (
                pla                          ; DACC= 68          h
                sbc $0301,x                  ; DACD= FD 01 03    }..
                sta $DD                      ; DAD0= 85 DD       .]
                tya                          ; DAD2= 98          .
                ldy $0361                    ; DAD3= AC 61 03    ,a.
                cpy #$03                     ; DAD6= C0 03       @.
                beq LDADF                    ; DAD8= F0 05       p.
                bcc LDAE2                    ; DADA= 90 06       ..
                lsr $DD                      ; DADC= 46 DD       F]
                ror a                        ; DADE= 6A          j
LDADF:
                lsr $DD                      ; DADF= 46 DD       F]
                ror a                        ; DAE1= 6A          j
LDAE2:
                lsr a                        ; DAE2= 4A          J
LDAE3:
                rts                          ; DAE3= 60          `

LDAE4:
                ldx #$42                     ; DAE4= A2 42       "B
                ldy #$46                     ; DAE6= A0 46        F
LDAE8:
                jsr sortVDUVariableWords                    ; DAE8= 20 CC D5     LU
                stx $DE                      ; DAEB= 86 DE       .^
                sty $DF                      ; DAED= 84 DF       ._
                ldx $DF                      ; DAEF= A6 DF       &_
                ldy #$00                     ; DAF1= A0 00        .
                jsr getOutcodeForAxis        ; DAF3= 20 B7 D1     7Q
                beq LDAFF                    ; DAF6= F0 07       p.
                lsr a                        ; DAF8= 4A          J
                beq LDAE3                    ; DAF9= F0 E8       ph
                ldx #$04                     ; DAFB= A2 04       ".
                stx $DF                      ; DAFD= 86 DF       ._
LDAFF:
                ldx $DE                      ; DAFF= A6 DE       &^
                jsr windEntryPoint           ; DB01= 20 A8 D1     (Q
                lsr a                        ; DB04= 4A          J
                bne LDAE3                    ; DB05= D0 DC       P\
                lda $0302,x                  ; DB07= BD 02 03    =..
                bcc LDB10                    ; DB0A= 90 04       ..
                ldx #$00                     ; DB0C= A2 00       ".
                stx $DE                      ; DB0E= 86 DE       .^
LDB10:
                jsr LDECB                    ; DB10= 20 CB DE     K^
                ldx $DE                      ; DB13= A6 DE       &^
                ldy $DF                      ; DB15= A4 DF       $_
                jsr LDA9C                    ; DB17= 20 9C DA     .Z
                tax                          ; DB1A= AA          *
                ldy $031A                    ; DB1B= AC 1A 03    ,..
                txa                          ; DB1E= 8A          .
                beq LDB44                    ; DB1F= F0 23       p#
                jsr plbyteEntryPoint         ; DB21= 20 51 DB     Q[
                bra LDB2E                    ; DB24= 80 08       ..

LDB26:
                lda (ZMEMG),y                  ; DB26= B1 D6       1V
                ora ZGORA                      ; DB28= 05 D4       .T
                eor ZGEOR                      ; DB2A= 45 D5       EU
                sta (ZMEMG),y                  ; DB2C= 91 D6       .V
LDB2E:
                tya                          ; DB2E= 98          .
                clc                          ; DB2F= 18          .
                adc #$08                     ; DB30= 69 08       i.
                tay                          ; DB32= A8          (
                bcc LDB3E                    ; DB33= 90 09       ..
                inc ZMEMG+1                      ; DB35= E6 D7       fW
                bpl LDB3E                    ; DB37= 10 05       ..
                lda $034E                    ; DB39= AD 4E 03    -N.
                sta ZMEMG+1                      ; DB3C= 85 D7       .W
LDB3E:
                dex                          ; DB3E= CA          J
                bne LDB26                    ; DB3F= D0 E5       Pe
                dex                          ; DB41= CA          J
                stx ZMASK                      ; DB42= 86 D1       .Q
LDB44:
                lda $DC                      ; DB44= A5 DC       %\
                trb ZMASK                      ; DB46= 14 D1       .Q
                bra plbyteEntryPoint           ; DB48= 80 07       ..

;-------------------------------------------------------------------------
;
; mem mask ora eor | result
; --- ---- --- --- | ------
;  0    0   0   0  |   0
;  0    0   0   1  |   0
;  0    0   1   0  |   0
;  0    0   1   1  |   0
;  0    1   0   0  |   0
;  0    1   0   1  |   1
;  0    1   1   0  |   1
;  0    1   1   1  |   0
;  1    0   0   0  |   1
;  1    0   0   1  |   1
;  1    0   1   0  |   1
;  1    0   1   1  |   1
;  1    1   0   0  |   1
;  1    1   0   1  |   0
;  1    1   1   0  |   1
;  1    1   1   1  |   0
;
plotPoint:
                ldx #VDUVariables.queueEnd-4
LDB4C:
                jsr windGADDR
                bne rtsDB61                  ;taken if point outside window
plbyteEntryPoint:
                lda ZMASK                      
                and ZGORA                      
                ora (ZMEMG),y                  
                sta ZTEMP+0                  
                lda ZGEOR                      
                and ZMASK                      
                eor ZTEMP+0
oswrscCode:
                sta (ZMEMG),y                  
rtsDB61:
                rts                          ; DB61= 60          `

;-------------------------------------------------------------------------

LDB62:                
                ldx #VDUVariables.workspace._2A
                ldy #VDUVariables.workspace._32
                jsr copyTwoBytesWithinVDUVariables                    ; DB66= 20 0C C9     .I
                ldx #VDUVariables.workspace._36
                ldy #VDUVariables.workspace._3E
                jsr copyTwoBytesWithinVDUVariables                    ; DB6D= 20 0C C9     .I
                ldx #$2A                     ; DB70= A2 2A       "*
                jsr getOutcodeForYAxis       ; DB72= 20 B5 D1     5Q
                pha                          ; DB75= 48          H
                ldx #$36                     ; DB76= A2 36       "6
                jsr getOutcodeForYAxis       ; DB78= 20 B5 D1     5Q
                beq LDB8C                    ; DB7B= F0 0F       p.
                pla                          ; DB7D= 68          h
                bne LDB85                    ; DB7E= D0 05       P.
                lda $0345                    ; DB80= AD 45 03    -E.
                beq LDB86                    ; DB83= F0 01       p.
LDB85:
                rts                          ; DB85= 60          `

LDB86:
                ldx #$28                     ; DB86= A2 28       "(
                ldy #$2C                     ; DB88= A0 2C        ,
                bra LDB93                    ; DB8A= 80 07       ..

LDB8C:
                pla                          ; DB8C= 68          h
                beq LDB96                    ; DB8D= F0 07       p.
                ldx #$34                     ; DB8F= A2 34       "4
                ldy #$38                     ; DB91= A0 38        8
LDB93:
                jmp LDAE8                    ; DB93= 4C E8 DA    LhZ

LDB96:
                ldx #$30                     ; DB96= A2 30       "0
                jsr gaddrEntryPoint                    ; DB98= 20 C8 DE     H^
                bit $0347                    ; DB9B= 2C 47 03    ,G.
                bmi LDBA9                    ; DB9E= 30 09       0.
                tya                          ; DBA0= 98          .
                sec                          ; DBA1= 38          8
                sbc #$08                     ; DBA2= E9 08       i.
                tay                          ; DBA4= A8          (
                bcs LDBA9                    ; DBA5= B0 02       0.
                dec ZMEMG+1                      ; DBA7= C6 D7       FW
LDBA9:
                lda $0344                    ; DBA9= AD 44 03    -D.
                sta $DD                      ; DBAC= 85 DD       .]
LDBAE:
                lda (ZMEMG),y                  ; DBAE= B1 D6       1V
                ldx $0342                    ; DBB0= AE 42 03    .B.
                beq LDBB9                    ; DBB3= F0 04       p.
LDBB5:
                asl a                        ; DBB5= 0A          .
                dex                          ; DBB6= CA          J
                bne LDBB5                    ; DBB7= D0 FC       P|
LDBB9:
                sta $DA                      ; DBB9= 85 DA       .Z
                sec                          ; DBBB= 38          8
                jsr nextColumn                    ; DBBC= 20 6C DA     lZ
                lda (ZMEMG),y                  ; DBBF= B1 D6       1V
                ldx $0343                    ; DBC1= AE 43 03    .C.
                beq LDBCA                    ; DBC4= F0 04       p.
LDBC6:
                lsr a                        ; DBC6= 4A          J
                dex                          ; DBC7= CA          J
                bne LDBC6                    ; DBC8= D0 FC       P|
LDBCA:
                eor $DA                      ; DBCA= 45 DA       EZ
                and $E1                      ; DBCC= 25 E1       %a
                eor $DA                      ; DBCE= 45 DA       EZ
                ldx $DD                      ; DBD0= A6 DD       &]
                sta L8830,x                  ; DBD2= 9D 30 88    .0.
                dec $DD                      ; DBD5= C6 DD       F]
                bpl LDBAE                    ; DBD7= 10 D5       .U
                ldx #$34                     ; DBD9= A2 34       "4
                ldy #$38                     ; DBDB= A0 38        8
                jsr LDAE8                    ; DBDD= 20 E8 DA     hZ
                lda $0345                    ; DBE0= AD 45 03    -E.
                bne LDBE8                    ; DBE3= D0 03       P.
                jsr LDB86                    ; DBE5= 20 86 DB     .[
LDBE8:
                ldx #$3C                     ; DBE8= A2 3C       "<
                jsr gaddrEntryPoint                    ; DBEA= 20 C8 DE     H^
                lda $0346                    ; DBED= AD 46 03    -F.
                sta $DA                      ; DBF0= 85 DA       .Z
                ldx $0344                    ; DBF2= AE 44 03    .D.
                beq LDC0C                    ; DBF5= F0 15       p.
                jsr LDC10                    ; DBF7= 20 10 DC     .\
                lda #$FF                     ; DBFA= A9 FF       ).
                sta $DA                      ; DBFC= 85 DA       .Z
                bra LDC05                    ; DBFE= 80 05       ..

LDC00_code:
                lda L8830,x                  ; DC00= BD 30 88    =0.
                sta (ZMEMG),y                  ; DC03= 91 D6       .V
LDC05:
                sec                          ; DC05= 38          8
                jsr nextColumn                    ; DC06= 20 6C DA     lZ
                dex                          ; DC09= CA          J
                bne LDC00_code               ; DC0A= D0 F4       Pt
LDC0C:
                lda $E0                      ; DC0C= A5 E0       %`
                trb $DA                      ; DC0E= 14 DA       .Z
LDC10:
                lda L8830,x                  ; DC10= BD 30 88    =0.
                eor (ZMEMG),y                  ; DC13= 51 D6       QV
                and $DA                      ; DC15= 25 DA       %Z
                eor (ZMEMG),y                  ; DC17= 51 D6       QV
                sta (ZMEMG),y                  ; DC19= 91 D6       .V
                rts                          ; DC1B= 60          `

LDC1C:
                lda $0337                    ; DC1C= AD 37 03    -7.
                inc a                        ; DC1F= 1A          .
                cmp $0336                    ; DC20= CD 36 03    M6.
                beq LDC47                    ; DC23= F0 22       p"
                sta $0337                    ; DC25= 8D 37 03    .7.
                tax                          ; DC28= AA          *
                lda $032E                    ; DC29= AD 2E 03    -..
                sta L8400,x                  ; DC2C= 9D 00 84    ...
                lda $0332                    ; DC2F= AD 32 03    -2.
                sta L8500,x                  ; DC32= 9D 00 85    ...
                lda $032F                    ; DC35= AD 2F 03    -/.
                asl a                        ; DC38= 0A          .
                asl a                        ; DC39= 0A          .
                ora $0333                    ; DC3A= 0D 33 03    .3.
                sta L8600,x                  ; DC3D= 9D 00 86    ...
                lda $0330                    ; DC40= AD 30 03    -0.
                sta L8700,x                  ; DC43= 9D 00 87    ...
LDC46:
                clc                          ; DC46= 18          .
LDC47:
                rts                          ; DC47= 60          `

LDC48:
                sta $032A                    ; DC48= 8D 2A 03    .*.
                ldx #$28                     ; DC4B= A2 28       "(
                jsr LDCB0                    ; DC4D= 20 B0 DC     0\
                bne LDC5C                    ; DC50= D0 0A       P.
LDC52:
                jsr LDC1C                    ; DC52= 20 1C DC     .\
                bcs LDC47                    ; DC55= B0 F0       0p
                jsr terminal.L9D57           ; DC57= 20 57 9D     W.
                bcs LDC46                    ; DC5A= B0 EA       0j
LDC5C:
                jsr LDCC1                    ; DC5C= 20 C1 DC     A\
                jsr terminal.L9D57           ; DC5F= 20 57 9D     W.
                bcs LDC46                    ; DC62= B0 E2       0b
                jsr LDCD7                    ; DC64= 20 D7 DC     W\
                jsr LDCB8                    ; DC67= 20 B8 DC     8\
                bra LDC52                    ; DC6A= 80 E6       .f

;-------------------------------------------------------------------------
;
; 72–79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
; 88–95 = Horizontal line fill (right to background) [MasRef E.3-25]
; 104–111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
; 120–127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
;
plotHorizontalLineFill:
                jsr copyECFPatternForLineFill                    ; DC6C= 20 9F DD     .]
                jsr LDCB0                    ; DC6F= 20 B0 DC     0\
                clc                          ; DC72= 18          .
                bra LDC83                    ; DC73= 80 0E       ..

plotHorizontalLineFillRight:
                jsr copyECFPatternForLineFill                    ; DC75= 20 9F DD     .]
                jsr LDCC9                    ; DC78= 20 C9 DC     I\
                jsr LDCD2                    ; DC7B= 20 D2 DC     R\
                bne LDC83                    ; DC7E= D0 03       P.
                jsr LDCB8                    ; DC80= 20 B8 DC     8\
LDC83:
                php                          ; DC83= 08          .
                ldx #VDUVariables.hlfw.pixelsX
                ldy #VDUVariables.oldGraphicsCursorPixelsX
                jsr copyFourBytesWithinVDUVariables
                plp
                php
                beq LDC91
                ldx #VDUVariables.hlfw.pixelsX
LDC91:
                ldy #VDUVariables.graphicsCursorPixelsX
                jsr copyTwoBytesWithinVDUVariables
                ldx #VDUVariables.hlfw.pixelsY
                jsr copyTwoBytesWithinVDUVariables
                plp                          ; DC9B= 28          (
                beq LDCA3                    ; DC9C= F0 05       p.
                bcs LDCA4                    ; DC9E= B0 04       0.
                inc $0316                    ; DCA0= EE 16 03    n..
LDCA3:
                rts                          ; DCA3= 60          `

LDCA4:
                lda $0324                    ; DCA4= AD 24 03    -$.
                bne LDCAC                    ; DCA7= D0 03       P.
                dec $0325                    ; DCA9= CE 25 03    N%.
LDCAC:
                dec $0324                    ; DCAC= CE 24 03    N$.
                rts                          ; DCAF= 60          `

;-------------------------------------------------------------------------

LDCB0:
                jsr LDCD2                    ; DCB0= 20 D2 DC     R\
                bne rtsDD0A                    ; DCB3= D0 55       PU
                jsr LDD0B                    ; DCB5= 20 0B DD     .]
LDCB8:
                ldx #$2E                     ; DCB8= A2 2E       ".
                ldy #$32                     ; DCBA= A0 32        2
                jsr LDAE8                    ; DCBC= 20 E8 DA     hZ
                bra LDD07                    ; DCBF= 80 46       .F

LDCC1:
                jsr LDCC9                    ; DCC1= 20 C9 DC     I\
                ldx #$2C                     ; DCC4= A2 2C       ",
                jsr LDCD9                    ; DCC6= 20 D9 DC     Y\
LDCC9:
                php                          ; DCC9= 08          .
                lda $E1                      ; DCCA= A5 E1       %a
                eor #$08                     ; DCCC= 49 08       I.
                sta $E1                      ; DCCE= 85 E1       .a
                plp                          ; DCD0= 28          (
                rts                          ; DCD1= 60          `

;-------------------------------------------------------------------------

LDCD2:
                ldy #VDUVariables.hlfw.pixelsX
                jsr copyFourBytesWithinVDUVariables
LDCD7:
                ldx #VDUVariables.graphicsWindowPixelsRight
LDCD9:
                ldy #VDUVariables.hlfw.pixelsLimitX
                jsr copyTwoBytesWithinVDUVariables
                ldx #VDUVariables.hlfw.pixelsLimitX
                jsr shouldFillPixel
                bne rtsDD0A  ;taken if pixel not to be filled, so done
LDCE5:
                lsr ZMASK                    ;next pixel
                bcc LDCF1                    ;taken if still in same byte
LDCE9:
                jsr nextColumnAndResetMask                    ; DCE9= 20 67 DA     gZ
                jsr shouldFillByte                    ; DCEC= 20 65 DD     e]
                bcs LDCE9                    ; DCEF= B0 F8       0x
LDCF1:
                jsr LDD85                    ; DCF1= 20 85 DD     .]
                bcs LDCE5                    ; DCF4= B0 EF       0o
                sec                          ; DCF6= 38          8
                lda vduv.hlfw.pixelsLimitX+0
                sbc zhlfw.pixelsX+0
                sta vduv.hlfw.pixelsRightEndX+0
                lda vduv.hlfw.pixelsLimitX+1
                sbc zhlfw.pixelsX+1
                sta vduv.hlfw.pixelsRightEndX+1
LDD07:
                lda #$00                     ; DD07= A9 00       ).
                sec                          ; DD09= 38          8
rtsDD0A:
                rts                          ; DD0A= 60          `

LDD0B:
                ldx #VDUVariables.graphicsWindowPixelsLeft
                jsr shouldFillPixel                   
                bne rtsDD0A                    ;taken if pixel not to be filled, so done
LDD12:
                asl ZMASK                      ;next pixel
                bcc LDD1E                    ;taken if still in same byte
LDD16:
                jsr previousColumnAndResetMask
                jsr shouldFillByte                    ; DD19= 20 65 DD     e]
                bcs LDD16                    ; DD1C= B0 F8       0x
LDD1E:
                jsr LDD85                    ; DD1E= 20 85 DD     .]
                bcs LDD12                    ; DD21= B0 EF       0o
                lda vduv.graphicsWindowPixelsLeft+0
                adc zhlfw.pixelsX+0
                sta vduv.hlfw.pixelsX+0
                lda vduv.graphicsWindowPixelsLeft+1
                adc zhlfw.pixelsX+1
                sta vduv.hlfw.pixelsX+1
                bra LDD07

;-------------------------------------------------------------------------
;
; Check whether line fill should fill a pixel.
;
; entry:
;
; X = VDU variable offset of edge of window
;
; vduv.workspace._2E - pixel X, Y coordinates
;
; exit:
;
; Z=1 if pixel should be filled
;
; ZTEMPC = ???
;
shouldFillPixel:
                sec
                lda vduv.workspace._2E+0
                sbc vduv+0,x
                tay
                lda vduv.workspace._2E+1
                sbc vduv+1,x
                bpl +
                jsr negateAY
+
                sty zhlfw.pixelsX+0
                sta zhlfw.pixelsX+1
                ldx #VDUVariables.workspace._2E
                jsr windGADDR
                clc
                bne rtsDD64                    ;taken if point outside window
                lda (ZMEMG),y                  ;get screen byte
                eor andy.hlfw.ecfPattern,x     ;EOR with appropriate pattern
                sta zhlfw.notByteMatch ;0 if whole byte matches
                and ZMASK                      ;0 if masked byte matches
                beq +              ;taken if masked byte matches - A=0
                lda #$08              ;masked byte doesn't match - A=8
+
                eor zhlfw.resultEOR ;maybe invert result
                sec                          ; DD63= 38          8
rtsDD64:
                rts                          ; DD64= 60          `

;-------------------------------------------------------------------------

shouldFillByte:
                lda (ZMEMG),y                  
                eor andy.hlfw.ecfPattern,x     
                sta zhlfw.notByteMatch         
                ora zhlfw.resultEOR            
                clc                          
                bne rtsDD84                    
                lda zhlfw.pixelsX+0           
                sbc vduv.pixelsPerByteMinusOne
                pha                
                lda zhlfw.pixelsX+1
                sbc #$00           
                bcc pla_rts_DD83             ;taken if past X=0
                sta zhlfw.pixelsX+1
                pla
                sta zhlfw.pixelsX+0
                rts                

pla_rts_DD83:
                pla                
rtsDD84:
                rts                

;-------------------------------------------------------------------------

LDD85:
                lda zhlfw.notByteMatch
                and ZMASK
                beq +
                lda #$08
+
                eor zhlfw.resultEOR
                bne rtsDD9E

                ; pixelsX -= 1
                lda zhlfw.pixelsX+0
                bne +
                lda zhlfw.pixelsX+1
                beq rtsDD9E
                dec zhlfw.pixelsX+1
+
                dec zhlfw.pixelsX+0
                sec
rtsDD9E:
                rts

;-------------------------------------------------------------------------
;
; Copy appropriate ECF pattern for line fill.
;
; entry:
;
; A = horizontal line fill PLOT code
;
; exit:
;
; andy.hlfw.ecfPattern = holds bg/fg ECF pattern as required
;
; ZTEMPD?1 = 0 for fill to matching, 8 to fill to non-matching
;
copyECFPatternForLineFill:
                lsr a                        ;36-39; 44-47; 52-55; 60-63
                lsr a                        ;18-19; 42-43; 26-27; 30-31
LDDA1:
                and #$08                     ;8 if PLOT >= 104
                sta zhlfw.resultEOR
                eor #$0F                     ;
                tax                          ; DDA7= AA          *
                ldy #$07                     ; DDA8= A0 07        .
-
                lda andy.currentECFPatterns,x
                sta andy.hlfw.ecfPattern,y
                dex                          ; DDB0= CA          J
                dey                          ; DDB1= 88          .
                bpl -
                ldx #VDUVariables.queueEnd-4
                rts                          ; DDB6= 60          `

;-------------------------------------------------------------------------
;
;
; entry:
;
; A = offset into VDU variables of coordinates
;
; exit:
;
; A = colour, or $ff if off screen/teletext (as per OSWORD $09)
; 
readPixelColour: .proc
                jsr stopCursorEditing
                ldx vduv.pixelsPerByteMinusOne
                beq invalid             ;taken if teletext
                pha
                tax
                jsr eigabsEntryPoint
                plx
                jsr windGADDR                    
                bne invalid             ;taken if off screen
                lda (ZMEMG),y
                stz ZTEMP+0
                bra shiftMask

                ; Keep shifting the byte and the mask. When a 1 bit is
                ; shifted out of the mask, shift the corresponding
                ; byte bit bit into ZTEMP+0, building up the pixel
                ; colour a bit at a time.
                ;
                ; When the mask becomes 0, done.
shiftByteAndMask:
                asl a
shiftMask:
                asl ZMASK
                bcc shiftByteAndMask
                asl a
                rol ZTEMP+0
                ldx ZMASK
                bne shiftMask
                lda ZTEMP+0
                bra done

invalid:
                lda #$FF
done:
                jmp reinstateCursorEditing
                .endproc
                
;-------------------------------------------------------------------------
;
; Translate ASCII char to the SAA5050 character set.
;
; # ($23) becomes $5f
; _ ($5f) becomes $60
; GBP ($60) becomes $23
;
; Because the mapping is a kind of cycle, you can call this routine
; twice to translate from SAA5050 to ASCII.
;
; entry:
;
; A = ASCII char
;
; exit:
;
; A = SAA550 char
;
getSAA5050FromASCII:
                cmp #$23                     
                beq translateHash
                cmp #$5F                     
                beq translateUnderscore
                cmp #$60                     
                bne rtsDDF7
translateGBP:
                eor #$3F                     ;0x60->0x5f
translateHash:
                eor #$43                     ;0x23->0x5f or 0x5f->0x1c
translateUnderscore:
                eor #$3F                     ;0x5f->0x60 or 0x1c->0x23
rtsDDF7:
                rts                          

;-------------------------------------------------------------------------

readCharacterAtTextCursor: .proc
                cli
                bit STATE
                bvc +                      ;taken if not cursor editing
                jsr stopCursorEditing
                jsr exchangeCursors
+
                ldy vduv.numberOfLogicalColoursMinusOne
                bne bitmapMode
readTeletextChar:
                lda (ZMEMT)                  ;read character from screen
                jsr getSAA5050FromASCII      ;call 2x to convert to ASCII
                jsr getSAA5050FromASCII      ;call 2x to convert to ASCII
done:
                bit STATE
                bvc +                     ;taken if not cursor editing
                jsr exchangeCursors                    
                jsr reinstateCursorEditing                    
+
                ldy vduv.currentScreenMODE
                tax
                rts

bitmapMode:
                jsr LDE56                   
                lda $F4                     
                pha                         
                jsr selectTerminalROMAndANDY
                lda #$20
                tax                          ;X = ASCII code for char
                jsr getSoftCharacterDefinitionAddress
compare:
                ldy #$07                     
-
                lda vduv.workspace._28,y
                eor (ZTEMPC),y
                bne nextFontChar ;taken if no match - can't be this char
                dey
                bpl -

                txa                          ;A = char found
                .if version==350
                bpl bitmapModeDone
                eor #$7f
                .endif
bitmapModeDone:
                plx
                jsr selectROMX
                bra done

nextFontChar:
                inx                          ;next ASCII code
                .if version==350
                txa
                bpl LDE4A
                eor #$7f
LDE4A:
                jsr getSoftCharacterDefinitionAddress
                .else
                clc
                lda ZTEMPC+0
                adc #$08                     ;8 bytes/font char
                sta ZTEMPC+0
                bcc gotCharAddress
                inc ZTEMPC+1
                .endif
gotCharAddress:
                cpx #$7F                     
                beq nextFontChar                 ;skip CHR$127
                txa
                bne compare           ;taken if more chars to consider
                bra bitmapModeDone ;finish with A=0 - i.e., no match found
                .endproc
                
;-------------------------------------------------------------------------
;
; Copy character out of screen memory, and store as a 1 bpp bitmap in
; VDU variables workspace.
; 
LDE56: .proc
                ldx ZMEMT+0
                lda ZMEMT+1
                jsr getNext3ColumnAddresses
                ldy #$07
loop:
                ldx vduv.numberOfLogicalColoursMinusOne
                cpx #$03
                beq read2bppChar
                bcs read4bppChar
read1bppChar:
                lda (ZMEMT),y
                eor vduv.backgroundTextColour
                bra next

read2bppChar:
                lda (ZMEMT),y                ;get pixels 0-3
                jsr get4Pixels
                lda (ZTEMP),y                  ;get pixels 4-7
                jsr get4Pixels
                bra LDE8F                    

read4bppChar:
                lda (ZMEMT),y                ;get pixels 0/1
                jsr get2Pixels                    
                lda (ZTEMP),y                ;get pixels 2/3
                jsr get2Pixels                    
                lda (ZTEMPB),y               ;get pixels 4/5
                jsr get2Pixels                    
                lda (ZTEMPD),y               ;get pixels 6/7
                jsr get2Pixels                    
LDE8F:
                lda ZTEMPC+1
next:
                sta vduv.workspace._28,y
                dey
                bpl loop
                rts

get2Pixels:
                eor vduv.backgroundTextColour ;reset background pixel bits
                jsr or2Pixels
                and #%00000011               ;2 pixels/byte
                bra shiftIn2

get4Pixels:
                eor vduv.backgroundTextColour ;
                jsr or4Pixels
                and #%00001111               ;4 pixels/byte

                ; Build up the 1bpp char row in ZTEMPC?1, 2 or 4 bits
                ; at a time.
                asl ZTEMPC+1
                asl ZTEMPC+1
shiftIn2:
                asl ZTEMPC+1
                asl ZTEMPC+1
                tsb ZTEMPC+1
                rts                          ; DEB4= 60          `

                ; OR together all the N bits for each pixel, making a
                ; byte in which the bottom N bits have a bit set for
                ; each non-0 pixel in the byte.
or2Pixels:
                sta ZTEMPC+0
                jsr shiftOut2
or4Pixels:
                sta ZTEMPC+0                 ;%abcdABCD
                lsr a                        ;%0abcdABC
                lsr a                        ;%00abcdAB
shiftOut2:
                lsr a                        ;%000abcdA
                lsr a                        ;%0000abcd
                ora ZTEMPC+0                 ;%0000abcd|%abcdABCD
                .endproc
rtsDEC2:
                rts                          ; DEC2= 60          `
                
;-------------------------------------------------------------------------
;
; Do WIND. If point not in window, return with Z=0. Otherwise, call
; GADDR and return with Z=1.
;
windGADDR:
                jsr windEntryPoint
                bne rtsDEC2                  ;taken if point outside window
gaddrEntryPoint:
                lda vduv+2,x                 ;get Y coordinate
LDECB:
                eor #$FF                     ;invert Y coordinate
                tay                          ;Y=Y coordinate
                and #$07                ;get scanline in character row
                sta ZTEMP+0             ;save scanline
                tya                          ;A=Y coordinate
                and #$F8                     ;row*8
                lsr a                        ;row*4
                sta ZMEMG+1                  ;>(row*1024)
                lsr a                        ;>(row*512)
                lsr a                        ;>(row*256)
                adc ZMEMG+1                  ;>(row*1280)
                lsr a                        ;>(row*640)
                sta ZMEMG+1                  ;
                lda #$00                     ;
                ror a                        ;<(row*640) - $00/$80
                ldy vduv.currentScreenMODEGroup
                beq +                      ;taken if 640 bytes per row
                lsr ZMEMG+1                ;>(row*320)
                ror a                    ;<(row*320) - $00/$40/$80/$c0
+
                ora ZTEMP+0               ;include the scanline offset
                adc vduv.screenTopLeftAddress+0 ;include LSB of screen base
                sta vduv.graphicsAddressOffset

                ; add MSB of screen base to ZMEMG+1 
                lda ZMEMG+1
                adc vduv.screenTopLeftAddress+1
                sta ZMEMG+1

                lda vduv+1,x                 ;get >X
                sta ZMEMG+0                  ;save >X
                lda vduv+0,x                 ;get <X
                and vduv.pixelsPerByteMinusOne ;index for pixel
                adc vduv.pixelsPerByteMinusOne ;offset into pixel mask table
                tay
                lda pixelMasks-1,y
                sta ZMASK

                ; Form 16-bit column address offset (LSB in A, MSB in
                ; ZMEMG+0), assuming 8 bits/pixel. No adjustment
                ; needed if MODE 0/4, but scale up by 2 if MODE 1/5 or
                ; 4 if MODE 2.
                
                lda vduv+0,x                 ;A = <X
                ldy vduv.pixelsPerByteMinusOne
                cpy #$03
                beq LDF1C         ;taken if 4 px/byte - i.e., MODE 1/5
                bcs LDF1F        ;taken if >4 px/byte - i.e., MODE 0/4
                asl a
                rol ZMEMG+0
LDF1C:
                asl a
                rol ZMEMG+0
LDF1F:
                and #$F8                     ;<column offset
                clc
                adc vduv.graphicsAddressOffset
                sta vduv.graphicsAddressOffset
                lda ZMEMG+0                  ;>column offset
                adc ZMEMG+1                  ;add to address MSB
                bpl +                        ;taken if no wrap
                sec                          
                sbc vduv.screenSizeHighByte ;handle wrap at end of screen
+
                sta ZMEMG+1                  ;got MSB
                stz ZMEMG+0 ;LSB always 0 - the offset takes care of this
                ldx ZTEMP+0 ;get scanline in row
                jsr setupColourMasks
                ldy vduv.graphicsAddressOffset
ldaim00_rts_DF3E:
                lda #$00                     ;return with Z=1, as per WIND
                rts                          ; DF40= 60          `

;-------------------------------------------------------------------------

LDF41:
                jsr gaddrEntryPoint
                phx
                ldx #$00
                lda $035A
                cmp #$04
                bcs LDF59
                ldx $036A
                lda $0359
                beq LDF59
                ldx $036B
LDF59:
                stx $0369
                plx
                rts

;-------------------------------------------------------------------------

handleCopyKey:
                lda #STATE.isVDU5
                bit STATE
                bvc ldaim00_rts_DF3E      ;taken if not cursor editing
                bne ldaim00_rts_DF3E      ;taken if VDU5
                .if version==350&&!finmos329
                jsr LFB0A
                .elsif (version<511||autocue)&&!finmos329
                jsr readCharacterAtTextCursor
                .else
                lda #$87
                jsr OSBYTE
                txa
                .endif
                beq rtsDF77              ;taken if char not recognised
                pha                      ;save char recognised
                jsr isCursorEditingPossible
                bne pla_rts_DF76
                lda #$09
                jsr moveEditCursor
pla_rts_DF76:
                pla
rtsDF77:
                rts

;-------------------------------------------------------------------------
;
; Handle cursor key press.
;
; Entry: A = one of the cursor key codes:
;            $88 = left
;            $89 = right
;            $8a = down
;            $8b = up

handleCursorKey:
                pha                          ;save cursor key code
                jsr isCursorEditingPossible
                bne pla_rts_DF76             ;bail if editing not possible
                bvs editing                  ;taken if already editing
beginEditing:
                lda vduv.lastCursorStartRegisterValue
                and #%11011111
                jsr setCRTCRegister10        ;hide cursor
                ldx #VDUVariables.textCursorXPosition
                ldy #VDUVariables.editCursorXPosition
                jsr copyTwoBytesWithinVDUVariables ;edit cursor pos =
                                                   ;text cursor pos
                jsr activateEditCursor
                lda #STATE.isScrollingDisabled
                tsb STATE
editing:
                pla                          ;restore cursor key code

                ; Form appropriate VDU command (8/9/10/11) for the
                ; key, assuming no VDU axis rearrangement.
                and #$7F
                sta ZTEMP                    ;save VDU command

                ; Adjust VDU command based on axis swap/inversion. 
                cmp #$0A
                bcs handleCursorUpOrDown     ;taken if up/down
handleCursorLeftOrRightOrCopy:
                lda vduv.cursorFlags
                lsr a
                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertHorizontal)>>1
                bit #vduv.cursorFlags.swapAxes>>1
                beq gotActualMoveCommand

                eor #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal)>>1
                bra gotActualMoveCommand

handleCursorUpOrDown:
                lda vduv.cursorFlags
                lsr a               
                lsr a
                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical)>>2 ;000000SV
                bit #vduv.cursorFlags.swapAxes>>2
                beq gotActualMoveCommand
                
                eor #vduv.cursorFlags.invertVertical>>2
gotActualMoveCommand:
                eor ZTEMP
moveEditCursor:
                tay                          ;save command
                lda #STATE.isCursorEditing
                trb STATE            ;temporarily disable edit mode
                tya                  ;restore command
                ldx vduv.column81
                phx                  ;save old column 81 flag
                lsr vduv.column81    ;temporarily reset column 81 flag
                jsr outputToVDU      ;print the cursor movement command
                pla                  
                sta vduv.column81            ;restore column 81 flag
                lda #STATE.isCursorEditing
                tsb STATE                    ;reinstate edit mode
                rts

; Check if cursor editing is possible.
;
; Exit: Z=1 - editing is possible
;             V reflects current STATE.isCursorEditing bit
;       Z=0 - editing not possible
isCursorEditingPossible:
                ldx vduQueueNegativeLength
                bne +                        ;return with Z=0 if VDU
                                             ;queue not empty
                lda #STATE.isVDU21|STATE.isVDU5
                bit STATE   ;return with Z=0 if neither VDU21 nor VDU5
+
                rts

;-------------------------------------------------------------------------
;
; 184–191 = Move/copy rectangle [MasRef E.3-31]
;
                .if version!=400
plotMoveOrCopyRectangle:
                ldx #$80|extROM   ; select VIEW+ANDY
                jsr selectROMX
                jsr ext.plotMoveOrCopyRectangle
                bra LDFF1
                .endif
                
;-------------------------------------------------------------------------
;
; 192–199 = Plot ellipse outline [MasRef E.3-32]
;
                .if version!=400
plotEllipseOutline:
                ldx #$80|extROM
                jsr selectROMX
                jsr ext.plotEllipseOutline
LDFF1:
                jmp selectTerminalROMAndANDY
                .endif
                
;-------------------------------------------------------------------------
;
; 200–207 = Plot solid ellipse [MasRef E.3-32]
;
                .if version!=400
plotSolidEllipse:
                ldx #$80|extROM
                jsr selectROMX
                jsr ext.plotSolidEllipse
                bra LDFF1
                .endif

                .if version==400
                .align 256
                .endif
                
;-------------------------------------------------------------------------

; Pretty sure I have the logic for this all wrong...

                .if !finmos329
                .align 16
                .endif
startupMessages: .block
                .if version==500||version==510||autocue
                .fill 16,0
                .endif

                .if version>=511&&!autocue
                .byte 0
                .endif
acornMOS:
                .text 13
                .if olivetti
                .text "Olivetti MOS"
                .elsif version==350
                .if CFA3000
                .text "ACORN MOS (Tinsley 64K)"
                .elsif finmos329
                .text "Acorn FinMOS"
                .else
                .text "ACORN MOS"
                .endif
                .else
                .text "Acorn MOS"
                .endif
                .if version==400||version==350
                .text " "
                .endif
                .byte 0
beep:
                .byte 7
                .byte 0
                .if version!=400&&version!=350
                .byte 0,0,0   ;space for "xxK"
                .endif
                
twoNewlines:
                .byte 8
                .byte $0D
                .byte $0D
                ; terminating 0 comes from following table!
                .cerror *!=LE013,"startupMessages needs a terminating 0"
                .endblock
LE013:
                .byte %00000000;$00
                .byte %00010001;$11
                .byte %00100010;$22
                .byte %00110011;$33
                .byte %01000100;$44
                .byte %01010101;$55
                .byte %01100110;$66
                .byte %01110111;$77
                .byte %10001000;$88
                .byte %10011001;$99
                .byte %10101010;$AA
                .byte %10111011;$BB
                .byte %11001100;$CC
                .byte %11011101;$DD
                .byte %11101110;$EE
                .byte %11111111;$FF
LE023:
                .byte %00000000;$00
                .byte %01010101;$55
                .byte %10101010;$AA
                .byte %11111111;$FF

; VDU control code dispatch tables
; ================================
;
; entry:
;
; 

; each routine is (address, number of additional VDU bytes)
_:=[(vdu0EntryPoint,0)] ; VDU0
_..=[(vdu1EntryPoint,1)] ; VDU1
_..=[(vdu2EntryPoint,0)] ; VDU2
_..=[(vdu3EntryPoint,0)] ; VDU3
_..=[(vdu4EntryPoint,0)] ; VDU4
_..=[(vdu5EntryPoint,0)] ; VDU5
_..=[(vdu6EntryPoint,0)] ; VDU6
_..=[(vdu7EntryPoint,0)] ; VDU7
_..=[(vdu8EntryPoint,0)] ; VDU8
_..=[(vdu9EntryPoint,0)] ; VDU9
_..=[(vdu10EntryPoint,0)] ; VDU10
_..=[(vdu11EntryPoint,0)] ; VDU11
_..=[(vdu12EntryPoint,0)] ; VDU12
_..=[(vdu13EntryPoint,0)] ; VDU13
_..=[(vdu14EntryPoint,0)] ; VDU14
_..=[(vdu15EntryPoint,0)] ; VDU15
_..=[(vdu16EntryPoint,0)] ; VDU16
_..=[(vdu17EntryPoint,1)] ; VDU17
_..=[(vdu18EntryPoint,2)] ; VDU18
_..=[(vdu19EntryPoint,5)] ; VDU19
_..=[(vdu20EntryPoint,0)] ; VDU20
_..=[(vdu21EntryPoint,0)] ; VDU21
_..=[(vdu22EntryPoint,1)] ; VDU22
_..=[(vdu23EntryPoint,9)] ; VDU23
_..=[(vdu24EntryPoint,8)] ; VDU24
_..=[(vdu25EntryPoint,5)] ; VDU25
_..=[(vdu26EntryPoint,0)] ; VDU26
_..=[(vdu27EntryPoint,0)] ; VDU27
_..=[(vdu28EntryPoint,4)] ; VDU28
_..=[(vdu29EntryPoint,4)] ; VDU29
_..=[(vdu30EntryPoint,0)] ; VDU30
_..=[(vdu31EntryPoint,2)] ; VDU31
_..=[(vdu127EntryPoint,0)] ; VDU127
vdu_routines=_
                
; LSB of routine address
vduRoutinesLSBTable:
                .for i=0,i<len(vdu_routines),i+=1
                .byte <vdu_routines[i][0]
                .next

; If bit 7 set: MSB of routine address
;
; If bit 7 clear:
;
; Top 4 bits are bits 8-11 of routine address (bits 12-15 are %1010,
; so address is $C0xx to $C7xx)
;
; Bottom 4 bits are ORed with $f0 and stored in $26a - -ve bytes left
; in VDU queue.
vduRoutinesMSBTable:
                .for i=0,i<len(vdu_routines),i+=1
                .if vdu_routines[i][1]==0
                .byte >vdu_routines[i][0]
                .else
                .cerror vdu_routines[i][0]<(vduRoutinesPage<<8) || vdu_routines[i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",i,vdu_routines[i][0])
                .cerror vdu_routines[i][1]<0 || vdu_routines[i][1]>15,format("illegal VDU parameter count for VDU %d: %d",i,vdu_routines[i][1])
                .byte (16-vdu_routines[i][1])|(((>vdu_routines[i][0])&$0f)<<4)
                .endif
                .next

;-------------------------------------------------------------------------
;
; entry:
;
; C=0
;
; A = vdu 23 code
;
; VDU queue = the full 9 bytes of the VDU 23
; 
vdu23EntryPointTable:
                .word vdu23_0_EntryPoint
                .word vdu23_1_EntryPoint
                .word vdu23_2_EntryPoint
                .word vdu23_3_EntryPoint
                .word vdu23_4_EntryPoint
                .word vdu23_5_EntryPoint
                .word vdu23_6_EntryPoint
                .word vdu23_7_EntryPoint
                .word vdu23_8_EntryPoint
                .word vdu23_9_EntryPoint
                .word vdu23_10_EntryPoint
                .word vdu23_11_EntryPoint
                .word vdu23_12_EntryPoint
                .word vdu23_13_EntryPoint
                .word vdu23_14_EntryPoint
                .word vdu23_15_EntryPoint
                .word vdu23_16_EntryPoint

;-------------------------------------------------------------------------
;
; entry:
;
; A = plot number
;
plotEntryPointTable:                
                .word plotPoint    ;64–71 = Plot point [MasRef E.3-24]
                .word plotHorizontalLineFill ;72–79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
                .word terminal.L9BF7 ;80–87 = Plot triangle [MasRef E.3-25]
                .word plotHorizontalLineFillRight ;88–95 = Horizontal line fill (right to background) [MasRef E.3-25]
                .word LC448 ;96–103 = Plot rectangle [MasRef E.3-26]
                .word plotHorizontalLineFill ;104–111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
                .word terminal.plotParallelogram ;112–119 = Plot parallelogram [MasRef E.3-27]
                .word plotHorizontalLineFillRight ;120–127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
                .word terminal.L9CF9 ;128–135 = Flood fill to non-background [MasRef E.3-28]
                .word terminal.L9CF9 ;136–143 = Flood fill to foreground [MasRef E.3-28]
                .word terminal.L99A4 ;144–151 = Plot circle outline [MasRef E.3-28]
                .word terminal.L9944 ;152–159 = Plot filled circle [MasRef E.3-29]
                .word terminal.L9999 ;160–167 = Plot circular arc [MasRef E.3-29]
                .word terminal.L9935 ;168–175 = Plot filled chord segment [MasRef E.3-30]
                .word terminal.L9923 ;176–183 = Plot filled sector [MasRef E.3-30]
                .word plotMoveOrCopyRectangle ;184–191 = Move/copy rectangle [MasRef E.3-31]
                .word plotEllipseOutline ;192–199 = Plot ellipse outline [MasRef E.3-32]
                .word plotSolidEllipse ;200–207 = Plot solid ellipse [MasRef E.3-32]

; Times 40 lookup table, high bytes
multiplyBy40TableHigh:
                .for i=0,i<25,i+=1
                .byte >i*40
                .next

; Times 40 lookup table, low bytes
multiplyBy40TableLow:
                .for i=0,i<25,i+=1
                .byte <i*40
                .next

; Times 640 lookup table, high bytes
multiplyBy640TableHigh:
                .for i=0,i<32,i+=1
                .byte >i*640
                .next

;-------------------------------------------------------------------------

modeMaxRow:
                .byte 31                     ;MODE 0 = 32 rows
                .byte 31                     ;MODE 1 = 32 rows
                .byte 31                     ;MODE 2 = 32 rows
                .byte 24                     ;MODE 3 = 25 rows
                .byte 31                     ;MODE 4 = 32 rows
                .byte 31                     ;MODE 5 = 32 rows
                .byte 24                     ;MODE 6 = 25 rows
                .byte 24                     ;MODE 7 = 25 rows
                
;-------------------------------------------------------------------------

modeMaxColumn:
                .byte 79                     ;MODE 0 = 80 columns
                .byte 39                     ;MODE 1 = 40 columns
                .byte 19                     ;MODE 2 = 20 columns
                .byte 79                     ;MODE 3 = 80 columns
                .byte 39                     ;MODE 4 = 40 columns
                .byte 19                     ;MODE 5 = 20 columns
                .byte 39                     ;MODE 6 = 40 columns
                .byte 39                     ;MODE 7 = 40 columns
                
;-------------------------------------------------------------------------

vcontrolForScreenMODE:
                .byte VCONTROL.cursorX___|VCONTROL.crtc2MHz|VCONTROL.shift16MHz ; $9C - MODE 0
                .byte VCONTROL.cursorXX__|VCONTROL.crtc2MHz|VCONTROL.shift8MHz ; $d8 - MODE 1
                .byte VCONTROL.cursorXXXX|VCONTROL.crtc2MHz|VCONTROL.shift4MHz ; $F4 - MODE 2
                .byte VCONTROL.cursorX___|VCONTROL.crtc2MHz|VCONTROL.shift16MHz ; $9C - MODE 3
                .byte VCONTROL.cursorX___|VCONTROL.crtc1MHz|VCONTROL.shift8MHz ; $88 - MODE 4
                .byte VCONTROL.cursorXX__|VCONTROL.crtc1MHz|VCONTROL.shift4MHz ; $C4 - MODE 5
                .byte VCONTROL.cursorX___|VCONTROL.crtc1MHz|VCONTROL.shift8MHz ; $88 - MODE 6
                .byte VCONTROL.cursor_X__|VCONTROL.crtc1MHz|VCONTROL.shift8MHz|VCONTROL.isTeletext|VCONTROL.flash ; $4B - MODE 7

;-------------------------------------------------------------------------

bytesPerCharacterForMODE:
                .byte 8                      ;MODE 0
                .byte 16                     ;MODE 1
                .byte 32                     ;MODE 2
                .byte 8                      ;MODE 3
                .byte 8                      ;MODE 4
                .byte 16                     ;MODE 5
                .byte 8                      ;MODE 6
LE120:
                .byte %00000001              ;MODE 7
                .byte %11111111
                .byte %01010101
                .byte %11111111
                .byte %01110111
                .byte %00110011
                .byte %00010001

;-------------------------------------------------------------------------

distanceMasksTable:
                .byte %11111111
                .byte %01111111
                .byte %00111111
                .byte %00011111
                .byte %00001111
                .byte %00000111
                .byte %00000011
                .byte %00000001

;-------------------------------------------------------------------------
;
; These graphics tables often overlap. I haven't always bothered
; commenting the MODEs for the MODE-indexed tables, as even those
; sometimes overlap.
;
;------------------------------------------------------------------------

;-------------------------------------------------------------------------
;
; This is 3 tables in one. Use the numberOfLogicalColoursMinusOne VDU
; variable to access it:
; pixelMasks[(numberOfLogicalColoursMinusOne&7)-1+colour&numberOfLogicalColoursMinusOne=
;
pixelMasks:
                .byte %10101010
                .byte %01010101

                .byte %10001000
                .byte %01000100
                .byte %00100010
                .byte %00010001

                .byte %10000000
                .byte %01000000
                .byte %00100000
                .byte %00010000
                .byte %00001000
                .byte %00000100
                .byte %00000010
numberOfLogicalColoursMinusOneForMODE:
                .byte %00000001              ;MODE 0 (also part of pixelMasks)
                .byte 3                      ;MODE 1
                .byte 15                     ;MODE 2
                .byte 1                      ;MODE 3
                .byte 1                      ;MODE 4
                .byte 3                      ;MODE 5
                .byte 1                      ;MODE 6
                ; MODE 7 value (0) is in next table

;-------------------------------------------------------------------------
;
; Overwrite: ZGORA=$ff, ZGEOR=$ff
; OR: ZGORA=value, ZGEOR=$00
; AND: ZGORA=~value, ZGEOR=$00
; EOR: ZGORA=$00, ZGEOR=value
; Invert: ZGORA=$00, ZGEOR=$ff
; Leave: ZGORA=$00, ZGEOR=$ff
;
zgeorORTable:
                .byte $00
zgoraORTable:
                .byte $FF                    ; E144= FF          .
zgoraEORTable:
                .byte $00
                .byte $00
                .byte $FF                    ; E147= FF          .
zgeorEORTable:
                .byte $FF                    ; E148= FF          .
                .byte $FF                    ; E149= FF          .
                .byte $FF                    ; E14A= FF          .
                .byte $00

;-------------------------------------------------------------------------
; 
; Index using logical colour value to get a byte with that colour
; value in every pixel.
;
; This is 3 tables in one. Use the numberOfLogicalColoursMinusOne VDU
; variable to access it:
; solidColoursTable[(numberOfLogicalColoursMinusOne&7)-1+colour&numberOfLogicalColoursMinusOne=
;
solidColoursTable:

                ; 1 bpp
                .byte %00000000
                .byte %11111111

                ; 2 bpp
                .byte %00000000
                .byte %00001111
                .byte %11110000
                .byte %11111111

                ; 4 bpp
                .byte %00000000
                .byte %00000011
                .byte %00001100
                .byte %00001111
                .byte %00110000
                .byte %00110011
                .byte %00111100
                .byte %00111111
                .byte %11000000
                .byte %11000011
                .byte %11001100
                .byte %11001111
                .byte %11110000
                .byte %11110011
                .byte %11111100
                .byte %11111111
                
pixelsPerByteMinusOneForMODE:
                .byte 7                      
                .byte 3                      
                .byte 1                      
LE165:
                .byte 0                      
                .byte 7                      
                .byte 3                      
screenMODEGroupForMODE:
                .byte 0
                .byte 0
                brk                          ; E16A= 00          .
                ora ($02,x)                  ; E16B= 01 02       ..
                .byte $02                    ; E16D= 02          .
                .byte $03                    ; E16E= 03          .
;TSB &0D          :\ E16F= 04 0D       ..
                .byte $04

;-------------------------------------------------------------------------
;
; Hardware scrolling wraparound size settings for screen mode group.
;
; The values for group 4 (1 KB) are bogus - the Mode 7 addressing
; wraparound is handled differently.
;
latchBit5ForScreenMODEGroup:
                .byte 5|8                    ;20 KB
                .byte 5|0                    ;16 KB
                .byte 5|8                    ;10 KB
                .byte 5|0                    ; 8 KB
latchBit4ForScreenMODEGroup:
                .byte 4|0                    ;20 KB (also benign value for 1 KB)
                .byte 4|0                    ;16 KB
                .byte 4|8                    ;10 KB
                .byte 4|8                    ; 8 KB
                .byte 4|0                    ;(benign value for 1 KB)

;-------------------------------------------------------------------------

screenSizeHighByteForScreenMODEGroup:
                .byte $50
                .byte $40
                .byte $28
                .byte $20
                .byte $04
startScreenAddressHighByteForScreenMODEGroup:
                .byte $30
                .byte $40
                .byte $58
                .byte $60
                .byte $7c
crtcRegisterLastIndexForScreenMODEGroup:
                .byte (crtcRegisterValues20KB-crtcRegisterValues)+$0B
                .byte (crtcRegisterValues16KB-crtcRegisterValues)+$0B
                .byte (crtcRegisterValues10KB-crtcRegisterValues)+$0B
                .byte (crtcRegisterValues8KB-crtcRegisterValues)+$0B
                .byte (crtcRegisterValues1KB-crtcRegisterValues)+$0B
crtcRegisterValues:
crtcRegisterValues20KB:                   ;MODEs 0/1/2
                .byte $7F            ;R0 - Horizontal Total
                .byte $50            ;R1 - Horizontal Displayed
                .byte $62            ;R2 - Horizontal Sync
                .byte $28            ;R3 - Sync Width (%vvvvhhhh)
                .byte $26            ;R4 - Vertical Total
                .byte $00            ;R5 - Vertical Total Adjust
                .byte $20            ;R6 - Vertical Displayed
                .byte $22            ;R7 - Vertical Sync Position
                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                    ;R11 - Cursor End
crtcRegisterValues16KB:                    ;MODE 3
                .byte $7F                 ;R0 - Horizontal Total      
                .byte $50                 ;R1 - Horizontal Displayed  
                .byte $62                 ;R2 - Horizontal Sync       
                .byte $28                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $1e                 ;R4 - Vertical Total        
                .byte $02                 ;R5 - Vertical Total Adjust 
                .byte $19                 ;R6 - Vertical Displayed    
                .byte $1B                 ;R7 - Vertical Sync Position
                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $09               ;R9 - Scan lines per character
                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 9                      ;R11 - Cursor End
crtcRegisterValues10KB:                      ;MODEs 4/5
                .byte $3f                 ;R0 - Horizontal Total      
                .byte $28                 ;R1 - Horizontal Displayed  
                .byte $31                 ;R2 - Horizontal Sync       
                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $26                 ;R4 - Vertical Total        
                .byte $00                 ;R5 - Vertical Total Adjust 
                .byte $20                 ;R6 - Vertical Displayed    
                .byte $22                 ;R7 - Vertical Sync Position
                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                      ;R11 - Cursor End
crtcRegisterValues8KB:                       ;MODE 6
                .byte $3F                 ;R0 - Horizontal Total      
                .byte $28                 ;R1 - Horizontal Displayed  
                .byte $31                 ;R2 - Horizontal Sync       
                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $1e                 ;R4 - Vertical Total        
                .byte $02                 ;R5 - Vertical Total Adjust 
                .byte $19                 ;R6 - Vertical Displayed    
                .byte $1B                 ;R7 - Vertical Sync Position
                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $09               ;R9 - Scan lines per character
                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 9                      ;R11 - Cursor End
crtcRegisterValues1KB:                       ;MODE 7
                .byte $3f                 ;R0 - Horizontal Total      
                .byte $28                 ;R1 - Horizontal Displayed  
                .byte $33                 ;R2 - Horizontal Sync       
                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $1e                 ;R4 - Vertical Total        
                .byte $02                 ;R5 - Vertical Total Adjust 
                .byte $19                 ;R6 - Vertical Displayed    
                .byte $1b                 ;R7 - Vertical Sync Position
                .byte CRTC.R8.cursorDelay2|CRTC.R8.displayDelay1|CRTC.R8.interlaceSyncAndVideo ;R8 - Interlace/Delay
                .byte $12               ;R9 - Scan lines per character
                .byte CRTC.R10.blink|CRTC.R10.slowBlink|18 ;R10 - Cursor blink/start
                .byte 19                     ;R11 - Cursor End
                
;-------------------------------------------------------------------------
;
; Default ECF patterns [MasRef E.3-16]
;
; Only half the pattern is stored. Each pattern repeats every 4
; scanlines.
; 
defaultECFPatterns:
                ; MODE 4
                .byte $aa,$00,$aa,$00        ;1 - Dark grey
                .byte $aa,$55,$aa,$55        ;2 - Grey
                .byte $ff,$55,$ff,$55        ;3 - Light grey
                .byte $11,$22,$44,$88        ;4 - Hatching

                ; MODE 1/5
                .byte $a5,$0f,$a5,$0f        ;1 - Red-orange
                .byte $a5,$5a,$a5,$5a        ;2 - Orange
                .byte $f0,$5a,$f0,$5a        ;3 - Yellow-orange
                .byte $f5,$fa,$f5,$fa        ;4 - Cream

                ; MODE 2
                .byte $0b,$07,$0b,$07        ;1 - Orange
                .byte $23,$13,$23,$13        ;2 - Pink
                .byte $0e,$0d,$0e,$0d        ;3 - Yellow-green
                .byte $1f,$2f,$1f,$2f        ;4 - Cream

                ; MODE 0
                .byte $cc,$00,$cc,$00        ;0 - Dark grey
                .byte $cc,$33,$cc,$33        ;1 - Grey
                .byte $ff,$33,$ff,$33        ;2 - Light grey
                .byte $03,$0c,$30,$c0        ;4 - Hatching
                
LE204:
                .byte $01                    ;---
                .byte $01                    ;--h
                .byte $03                    ;-v-
                .byte $03                    ;-vh
                .byte $02                    ;x--
                .byte $00                    ;x-h
                .byte $02                    ;xv-
                .byte $00                    ;xvh
                
scrollRoutinesTable:
                .word LC95F     ; E20C= 5F C9        _.
                .word LC96B     ; E20E= 6B C9        k.
                .word LC95F     ; E210= 5F C9        _.
                .word LC96B     ; E212= 6B C9        k.
                .word LC99D     ; E214= 9D C9        ..
                .word LC99D     ; E216= 9D C9        ..
                .word LC9A4     ; E218= A4 C9        ..
                .word LC9A4     ; E21A= A4 C9        ..
                .word LC9C3     ; E21C= C3 C9        ..
                .word LCA2D     ; E21E= 2D CA        -.
                .word LC9C3     ; E220= C3 C9        ..
                .word LCA2D     ; E222= 2D CA        -.
                .word LCAF1     ; E224= F1 CA        ..
                .word LCAF1     ; E226= F1 CA        ..
                .word LCAFA     ; E228= FA CA        ..
                .word LCAFA     ; E22A= FA CA

;-------------------------------------------------------------------------
;
; Get address of soft character definition.
;
; entry:
;
; A = character (32-255)
;
; exit:
;
; (ZTEMPC) = address
; 
getSoftCharacterDefinitionAddress:
                asl a                        ;a bcdefgh0
                rol a                        ;b cdefgh0a
                rol a                        ;c defgh0ab
                tay
                and #$03                     ;c 000000ab
                rol a                        ;0 00000abc
                adc #(>andy.softCharacterDefinitions)-1
                sta ZTEMPC+1
                tya                          ;0 defgh0ab
                and #$F8                     ;0 defgh000
                sta ZTEMPC+0
                rts                          ;

;-------------------------------------------------------------------------
;
; OSBYTE 165 (&A5) Read output cursor position [MasRef D.2-50]
;
osbyteA5:
                jsr withMOSROM
                bit STATE
                bvc getTextCursorPositionWithColumn81                    ;taken if cursor editing
                jsr exchangeEditCursorPositionAndTextCursorPosition
                jsr getTextCursorPositionWithColumn81                    ; E247= 20 52 E2     Rb
                phx                          ; E24A= DA          Z
                phy                          ; E24B= 5A          Z
                jsr exchangeEditCursorPositionAndTextCursorPosition
                ply                          ; E24F= 7A          z
                plx                          ; E250= FA          z
                rts                          ; E251= 60          `

;-------------------------------------------------------------------------
;
; Get text cursor position, taking the column 81 flag into account and
; reporting the X coordinate as N+1 in that case.
; 
getTextCursorPositionWithColumn81:
                jsr getTextCursorPosition
                bit vduv.column81
                bpl +                       ;taken if not at column 81
                inx                         ;X=81
+
                rts                          ; E25B= 60          `

;-------------------------------------------------------------------------

LE25C:
                sec
                lda vduv.textWindowRight
                sbc vduv.textWindowLeft
                pha
                lda #$00
                tay
                bra LE279

;-------------------------------------------------------------------------
;
; OSBYTE 134 (&86) Read text cursor position [MasRef D.2-41]
;
osbyte86:
                bit STATE
                bvc osbyteA5       ;taken if not cursor editing
getTextCursorPosition:
                lda #VDUVariables.cursorFlags.invertHorizontal
                ldy #VDUVariables.textCursorXPosition-VDUVariables.textWindow
                ldx #VDUVariables.textWindowLeft-VDUVariables.textWindow
                jsr getTextWindowRelativePosition
                pha                          ;save X position
                lda #VDUVariables.cursorFlags.invertVertical
LE279:
                iny               ;i.e., offset of textCursorYPosition
                ldx #VDUVariables.textWindowTop-VDUVariables.textWindow
                jsr getTextWindowRelativePosition
                tax                          ;X = Y position
                tay                          ;Y = Y position
                lda #vduv.cursorFlags.swapAxes
                bit vduv.cursorFlags
                beq plx_rts ;taken if axes unswapped - so X = X position, Y = Y position
                ply                          ;Y = Y position, X = X position
                rts                          

;-------------------------------------------------------------------------
;
; Get text window-relative cursor position, taking into account cursor
; flags.
;
; entry:
;
; A = cursorFlags bit for axis of interest - invertHorizontal or invertVertical
;
; X = offset in VDU variables of text window minimum for axis of interest
;
; Y = offset in VDU variables of cursor position for axis of interest
;
; exit:
;
; A = text window-relative coordinate
;
getTextWindowRelativePosition:
                sec                     ;C=1 ready for the subtraction
                bit vduv.cursorFlags ;test cursor flags inversion bit of interest
                beq axisNotInverted
axisInverted:
                txa
                eor #$02                     ;swap min and max
                tax
                lda vduv.textWindow,x
                sbc vduv.textWindow,y
                rts

axisNotInverted:
                lda vduv.textWindow,y
                sbc vduv.textWindow,x
                rts                  

;-------------------------------------------------------------------------
;
; Get default bounds for current mode.
;
; exit:
;
; X = max column (19, 39 or 79)
;
; Y = max row (24 or 31)
;
; preserves: A, C
; 
getDefaultBoundsForCurrentScreenMODE:
                ldx vduv.currentScreenMODE
                ldy modeMaxColumn,x          ;Y = max column
                phy                          ;save max column
                ldy modeMaxRow,x             ;Y = max row
plx_rts:
                plx                          ;X = max column
                rts

;-------------------------------------------------------------------------
;
; Swap edit cursor position and text cursor position.
;
exchangeEditCursorPositionAndTextCursorPosition:
                ldx #VDUVariables.textCursorXPosition
                ldy #VDUVariables.editCursorXPosition

;-------------------------------------------------------------------------
;
; Swap 2 bytes in the VDU variables.
;
; entry:
;
; X = offset of one set of 2 bytes
;
; Y = offset of the other set of 2 bytes
;
exchangeTwoVDUBytes:
                lda #$02
                bra exchangeVDUVariables

;-------------------------------------------------------------------------
;
; Swap graphics cursor and old graphics cursor.
;
LE2B6:
                ldx #VDUVariables.graphicsCursorPixelsX
LE2B8:
                ldy #VDUVariables.oldGraphicsCursorPixelsX

;-------------------------------------------------------------------------
;
; Swap 4 bytes in the VDU variables.
;
; entry:
;
; X = offset of one set of 4 bytes
;
; Y = offset of the other set of 4 bytes
;
exchangeFourVDUBytes:
                lda #$04                     ; E2BA= A9 04       ).

;-------------------------------------------------------------------------
;
; Swap bytes in the VDU variables.
;
; entry:
;
; A = number of bytes to swap
;
; X = offset of one set of bytes
;
; Y = offset of the other set of bytes
;
exchangeVDUVariables:
                pha                          ;save count remaining
                lda vduv,x
                pha
                lda vduv,y
                sta vduv,x
                pla
                sta vduv,y
                inx
                iny
                pla
                dec a
                bne exchangeVDUVariables
                rts                          ; E2D1= 60          `

;-------------------------------------------------------------------------
;
; Test current VDU4/VDU5 status.
;
; exit:
;
; Z=0 if VDU5 mode
testVDU5State:
                lda STATE
                and #STATE.isVDU5
                rts

;-------------------------------------------------------------------------

                .if version>=350
LE2E7:
                jsr withMOSROM
                jmp callPrinterDriverWithPrinterBuffer
                .endif

;-------------------------------------------------------------------------

                .if version>=350
LE2ED:
                jsr withMOSROM
                jmp LE8B9
                .endif

;-------------------------------------------------------------------------

                .if version>=350
LE2F3:
                jsr withMOSROM
                jmp (VDUV)
                .endif

;-------------------------------------------------------------------------

; Default vector table
; ====================
defaultVectorTable: .block
                .word badCommandError ; USERV=$200
                .word defaultBRKHandler ; BRKV=$202
                .word irq1EntryPoint ; IRQ1V=$204
                .word irq2EntryPoint ; IRQ2V=$206
                .word oscliEntryPoint ; CLIV=$208
                .word osbyteEntryPoint ; BYTEV=$20a
                .word oswordEntryPoint ; WORDV=$20c
                .word oswrchEntryPoint ; WRCHV=$20e
                .word osrdchEntryPoint ; RDCHV=$210
fsVectors: .block
                .word E_FILEV ; FILEV=$212
                .word E_ARGSV ; ARGSV=$214
                .word E_BGETV ; BGETV=$216
                .word E_BPUTV ; BPUTV=$218
                .word E_GBPBV ; GBPBV=$21a
                .word E_FINDV ; FINDV=$21c
                .word E_FSCV ; FSCV=$21e
end:
                .bend
                .word rtsFFAA ; EVENTV=$220
                .word rtsFFAA ; UPTV=$222
                .word rtsFFAA ; NETV=$224
                .word rtsFFAA ; VDUV=$226 
                .word keyEntryPoint ; KEYV=$228 
                .word insEntryPoint ; INSV=$22a 
                .word remEntryPoint ; REMV=$22c 
                .word cnpEntryPoint ; CNPV=$22e 
                .word rtsFFAA ; IND1V=$230
                .word rtsFFAA ; IND2V=$232
                .word rtsFFAA ; IND3V=$234
end:
                .bend

                ; valueFF is a (presumably arbitrary) byte with the
                ; value 255, that's BIT'd in a few places to set the V
                ; flag.
defaultMOSVariables:
                .word mosVariables-166       ;mosVariablesAddress
                .word extendedVectorSpace    ;extendedVectorSpaceAddress
                .word romInformationTable  ;romInformationTableAddress
                .word keyTranslationTable-16 ;keyboardTranslationTableAddress
                .word vduv                   ;vduVariablesAddress
                .byte $00                    ;cfsTimeoutCounter
                .byte $00                    ;inputSource
                .byte $FF                    ;keyboardSemaphore
                .byte $00                    ;romPollingSemaphore
                .byte $00                    ;oshwm
                .byte $01                    ;rs423InputInterpretationStatus
                .byte $00                    ;noignoreState
                .byte $00                    ;cfsRFSFSSwitch
                .byte $00                    ;vcontrolRegister
                .byte $00                    ;vpaletteRegister
                .byte $00                    ;romActiveAtLastBRK
                .byte $FF                    ;basicROMNumber
                .if version<500
                .byte $04                    ;currentADCChannel
                .byte $04                    ;maximumADCChannel
                .elsif version>=500
                .byte $02                    ;currentADCChannel
                .byte $02                    ;maximumADCChannel
                .endif
                .byte $00                    ;adcConversionType
                .byte $FF                    ;rs423Busy
                .if version==400
                .byte $00                    ;aciaControlRegister
                .else
                .byte $42                    ;aciaControlRegister
                .endif
                .byte $19                    ;flashCounter
                .byte $19                    ;firstFlashColourDuration
                .byte $19                    ;secondFlashColourDuration
                .byte $32                    ;keyboardAutoRepeatDelay
                .byte $08                    ;keyboardAutoRepeatRate
                .byte $00                    ;execFileHandle
                .byte $00                    ;spoolFileHandle
                .byte $00                    ;breakAndESCAPEEffect
                .byte $00                    ;keyboardStatus
                .byte $20                    ;keyboardStatusByte
                .byte $09                    ;rs423InputBufferMinimumSpace
                .byte $00                    ;rs423Ignore
                .byte $00                    ;rs423Destination
                .byte $00                    ;econetInterceptionStatus
                .byte $00                    ;econetInputInterpretationStatus
                .byte $00                    ;econetOutputInterpretationStatus
                .byte $00                    ;speechSystemByte1
                .byte $00                    ;soundSuppressionStatus
                .byte $03                    ;bellChannel
                .byte $90                    ;bellSound
                .byte $64                    ;bellFrequency
                .byte $06                    ;bellDuration
                .byte $81                    ;startupMessageSuppressionStatus
                .byte $00                    ;softKeyStringLength
                .byte $00                    ;pagedModeCounter
                .byte $00                    ;vduQueueNegativeLength
                .byte $09                    ;tabKeyCode
                .byte $1B                    ;escapeCharacter
                .byte $01                    ;input192To207Interpretation
                .byte $D0                    ;input208To223Interpretation
                .byte $E0                    ;input224To239Interpretation
                .byte $F0                    ;input240To255Interpretation
                .byte $01                    ;softKeyInterpretation
                .byte $80                    ;shiftSoftKeyInterpretation
                .byte $90                    ;ctrlSoftKeyInterpretation
                .byte $00                    ;shiftCtrlSoftKeyInterpretation
                .byte $00                    ;escapeKeyStatus
                .byte $00                    ;escapeEffects
valueFF:        .byte $FF                    ;userVIAInterruptMask
                .byte $FF                    ;rs423InterruptMask
                .byte $FF                    ;systemVIAInterruptMask
                .byte $00                    ;tubePresence
                .byte $00                    ;speechSystemByte2
                .byte $00                    ;characterDestinationStatus
                .byte editKeysMode.editKeys  ;editKeysMode
                .byte $30                    ;numericKeypadInterpretation
                .byte $01                    ;shadowRAMState
                .byte $00                    ;countryFlag
                .byte $00                    ;userFlag
                .if version==400
                .byte $00                    ;serialULARegister
                .else
                .byte $64                    ;serialULARegister
                .endif
                .byte initialTimerSwitchState ;timerSwitchState
                .byte $FF                    ;softKeyConsistencyFlag
                .if version==400
                .byte $00                    ;printerDriverType
                .else
                .byte $01                    ;printerDriverType
                .endif
                .byte $0a                    ;printerIgnoreChar
                .byte $00                    ;breakVectorByte0
                .byte $00                    ;breakVectorByte1
                .byte $00                    ;breakVectorByte2
                .byte $00                    ;vduDriverMemory
                .byte $00                    ;displayMemory
                .byte $FF                    ;currentLanguageROM

;-------------------------------------------------------------------------
; 
; STARTUP
; =======
; 
resetEntryPoint:                ;e364
                lda #$40        ; $40 = RTI
                sta nmiEntryPoint ; make NMI routine a no-op
                sei
                lda #$53                 ; ???
                sta LFE8E                ; ???
                .if version==350
                lda #~ACCCON.D
                trb ACCCON
                trb vduv.cursorFlags
                lda ACCCON
                ora #ACCCON.TST|ACCCON.Y|ACCCON.X
                .endif
                .if version==350
                jsr staSEIWKAAndACCCON
                jmp LFC00
                .else
                jsr selectTerminalROM ; Page in ROM 15 and continue
                jmp terminal.reset
                .endif

;-------------------------------------------------------------------------

                .if version==350
                ; D'oh! I got confused, and gave this completely the
                ; wrong name.
staSEIWKAAndACCCON:
                sta $fc
                sta ACCCON
                rts
                .endif

;-------------------------------------------------------------------------
; 
; Check if a coprocessor is attached to the Tube
;
; exit:
;
; C=0 = no Tube
;
; C=1 = Tube
;
                .if version!=350
LE375:
                ldx #$01                     
                stx tube.status1
                lda tube.status1                   
                eor #$01
                ldx #$81                     
                stx tube.status1             
                and tube.status1       ; Cy=0 if no Tube, Cy=1 if Tube
                ror a
                rts
                .endif
                
;-------------------------------------------------------------------------
;
; 
; 
                .if version==350
setTSTAndLE389:
                jsr callWithTST
                .endif

LE389:
                phy
                phx
                .if version==350
                jsr selectTerminalROM
                jsr terminal.L873F
                .elsif version<500
                jsr getROMInsertedFlagRTCAddressAndMask
                sta $FC                      ;save mask
                jsr selectTerminalROM
                jsr terminal.readRTCByte     ;read inserted flag
                tya                          ;A = byte read
                and $FC                      ;do mask
                .elsif version>=500
                jsr selectTerminalROM
                jsr terminal.L873F
                .endif
                cmp #$01                     ;C set if ROM is inserted
                plx
                ply
                jmp selectROMX

;-------------------------------------------------------------------------
;
; Scan ROMs and fill in the rom information table.
;
; entry:
;
; X = first ROM to scan
;
                .if version!=350
scanROMs: .proc
                .include "scan_roms.s65"
                jmp terminal.romsScanned     ;not sure why not RTS.
                .endproc
                .endif

;-------------------------------------------------------------------------
;
; Checks a ROM is valid - i.e., has a valid-looking copyright string.
;
; Entry:
;
; X = ROM to check
;
; Exit:
;
; C=0 if ROM invalid; C=1 if ROM valid
;
; ROM of interest is selected
; 
isROMValid: .proc ;e3f7
                jsr selectROMX
                ldx #$03
                ldy $8007       ; fetch ROM copyright offset pointer
                clc             ; assume no match
-
                lda $8000,y     ; fetch possible ROM copyright char
                eor sidewaysROMCopyrightPrefix,x     ; Z=1 if it matches "\x0(C)"
                bne +           ; branch taken if no match
                iny             ; next copyright byte
                dex             ; count 4 chars
                bpl -
                sec             ; C=1 means a match
+
                rts
                .pend

;-------------------------------------------------------------------------

; End of STARTUP code
; ===================
LE40E:
                sec                      ; Call Break Intercept Vector
                .if version==350
                jsr osbyte247EntryPointWithTST
                .else
                jsr osbyte247EntryPoint
                .endif
                ldx #romServiceCallInformReset
                jsr makeROMServiceCall
                ldy execFileHandle ; Get Exec handle, skip past if closed
                beq LE424
                stz execFileHandle           ; Clear Exec handle
                lda #$00                     ; Close Exec channel
                jsr OSFIND
LE424:
                sec                          ;
                ror hazel.currentFS
                lda lastBREAKType            ; Soft Break
                beq LE431
                sec                          ;
                ror hazel.libFS
LE431:
                jsr LEE64                    ; Set default ROMFS/TAPEFS settings
                jsr osbyte76                    ; Test Shift and Ctrl keys
                .if version==350
                jsr LE520
                .else
                lsr a                        ; Move SHIFT status from b7 to b3
                lsr a
                lsr a
                lsr a
                .endif
                eor startupOptions ; Toggle with OSBYTE 255 boot status
                and #$08
                tay
                ldx hazel.currentFSROM
                lda lastBREAKType ; Soft Break, use current filing system
                beq LE454
                jsr selectTerminalROM
                .if version<500&&version!=350
                phy
                jsr terminal.readDefaultROMs
                and #$0F                     ;get default FS ROM
                ply
                .else
                ldx #terminal.configureTable.file.metadata-terminal.configureTable
                jsr terminal.readConfigurationByte
                .endif
                
                tax
LE454:
                bit romInformationTable,x
                bpl LE478
                jsr selectROMX
                cpx #terminalROM
                bne LE46C
                jsr osbyte7A
                inx
                beq LE47F
                cpx #$63
                beq LE47F
                bra LE478

LE46C:
                lda #romServiceCallAutoBoot  ; Filing System selection
                jsr $8003
                tax
                jsr selectTerminalROM
                txa
                beq LE4A3
LE478:
                ldx #romServiceCallAutoBoot
                jsr makeROMServiceCall
                beq LE4A3
LE47F:
                tya
                bne LE499
                lda #$8D
                jsr osbyte8C8D
                ldx #<starRunBOOT
                ldy #>starRunBOOT
                dec startupMessageSuppressionStatus
                jsr OSCLI
                inc startupMessageSuppressionStatus
                bra LE4A3

;-------------------------------------------------------------------------

LE496:
                inc startupMessageSuppressionStatus ;set bit 0
LE499:
                sec
                ror hazel.currentFS
                .if version<400
                lda #$00
                tax
                jsr selectROMOrTAPE
                .elsif version<500
                jsr selectROMOrTAPEByOSBYTE
                .elsif version>=500
                lda #$8d
                jsr osbyte8C8D
                .endif
LE4A3:
                lda #$05                     ;
                ldx printerDriverType        ; *FX5,<current printer>
                jsr osbyteEntryPoint
                lda lastBREAKType ; If not Soft Break, select default language
                bne LE4BB
                ldx currentLanguageROM      ; Get current language ROM
                .if version==350&&!finmos329
                txa
                and #$bf
                cmp #$10
                .else
                cpx #$10                     ; <16, normal ROM number, use it
                .endif
                bcc LE4C2
                .if version==350&&!finmos329
                cmp #$1f
                .else
                cpx #$1F                     ; 16+UTILS ROM, re-enter Supervisor or Tube CLI
                .endif
                beq LE509
LE4BB:
                jsr selectTerminalROM     ; Page in ROM 15 - UTILS ROM
                .if version<500&&version!=350
                jsr terminal.readDefaultLanguageROM        ; Read configured LANG
                .else
                ldx #terminal.configureTable.lang.metadata-terminal.configureTable
                jsr terminal.readConfigurationByte
                .endif
                tax
LE4C2:
                clc

;-------------------------------------------------------------------------
;
; OSBYTE 142 (&8E) Enter language ROM [MasRef D.2-44]
; 
osbyte8E:
                .if version==350
                phx
                txa
                and #$f
                tax
                .endif
                bit romInformationTable,x ; b6=0, error Not a language
                .if version==350
                plx
                .endif
                bvc thisIsNotALanguageError
                php
                bcc LE4E1 ;taken if not OSBYTE 142 - so skip ROM check
                jsr selectROMX
                lda sidewaysROMType
                and #%00001101
                beq is6502ROM ;taken if low nybble is 0 (6502 BASIC) or 2 (other 6502 ROM)
                bit tubePresence
                bpl iCannotRunThisCodeError  ;taken if no Tube - assume impossible to run
is6502ROM:
                phx                          ;save ROM slot
                ldx #romServiceCallLanguageChange
                jsr makeROMServiceCall
                plx                          ;restore ROM slot
LE4E1:
                stx currentLanguageROM
                jsr selectROMX
                lda #>sidewaysROMName
                ldy #(<sidewaysROMName)-1
                jsr print0TerminatedString
                sty errPtr+0
                jsr OSNEWL
                jsr OSNEWL
                plp
                .if version<500
                lda #$01
                bit tubePresence
                bmi copyLanguageOverTube     ;taken if Tube is present
                .endif
                lda sidewaysROMType
                and #%00001101
                bne iCannotRunThisCodeError ;taken if low nybble isn't 0 (6502 BASIC) or 2 (other 6502 ROM)
                inc a                       ;
                jmp sidewaysROMLanguageEntry

LE509:
                lda #$00
                .if version<500
                bit tubePresence
                bpl startCommandLineUI
copyLanguageOverTube:
                jmp terminal.tubeHost.copyLanguage
                .elsif version>=500
                bra startCommandLineUI
                .endif

;-------------------------------------------------------------------------

sidewaysROMCopyrightPrefix: .block
                .text ")C("
end:
                .endblock

;-------------------------------------------------------------------------

thisIsNotALanguageError:
                brk
                .text 0,"This is not a language"

;-------------------------------------------------------------------------

iCannotRunThisCodeError:
                brk
                .text 0,"I cannot run this code",0

;-------------------------------------------------------------------------
;
; OSBYTE 164 (&A4) Check processor type [MasRef D.2-50]
; 
osbyteA4:
                ldx #sidewaysROMCopyrightPrefix.end-sidewaysROMCopyrightPrefix
                ldy #<sidewaysROMCopyrightOffset
                lda (originalX),y
                tay
-
                lda (originalX),y
                cmp sidewaysROMCopyrightPrefix,x
                bne rtsE564 ;taken if (C) not found - must be OK, if it's not a ROM?
                iny
                dex
                bpl -
                ldy #<sidewaysROMType
                lda (originalX),y
                asl a
                bpl thisIsNotALanguageError ;taken if no language entry point
                and #%00001101<<1
                bne iCannotRunThisCodeError ;taken if low nybble wasn't 0 (6502 BASIC) or 2 (other 6502 ROM)
rtsE564:
                rts                          ; E564= 60          `

;-------------------------------------------------------------------------

                .if version==350
LE520:
                lsr a
                lsr a
                lsr a
                lsr a
                rts
                .endif

;-------------------------------------------------------------------------

                .if version==350
LE525:
                ldx #$2c                     ;???
                ldy #$03
                jsr terminal.writeCMOSByte
                jmp terminal.printCMOSRamResetMessage
                .endif
                
;-------------------------------------------------------------------------

defaultBRKHandler:
                ldy #$00
                jsr printBRKMessage
                jsr OSNEWL
                lda startupMessageSuppressionStatus
                ror a
                bcs startCommandLineUI                   ;taken if bit 0 was set
                jsr OSNEWL
                jmp LE496

;-------------------------------------------------------------------------

startCommandLineUI:
                jsr selectTerminalROM
                jmp terminal.commandLineUI

;-------------------------------------------------------------------------
;
; Select paged ROM bank 15 - TERMINAL - with ANDY paged in,
;
; Preserves A/Y
selectTerminalROMAndANDY:   ;e57f
                ldx #$80|terminalROM
                ; fall through into selectROMX

;-------------------------------------------------------------------------
;-------------------------------------------------------------------------
;
; Select paged ROM bank.
;
; Entry:
;
; X = bank to select.
;
; Preserves A/X/Y/P
selectROMX:   ;e581
                stx $F4
                stx ROMSEL
                rts

;-------------------------------------------------------------------------
;
isROMValidThenSelectTerminalROM:
                phy
                jsr isROMValid
                jsr selectTerminalROM
                ply
                rts

;-------------------------------------------------------------------------
;
; Select paged ROM bank 15 - TERMINAL.
;
; Preserves X/Y
selectTerminalROM:            ;e590
                lda #terminalROM
                ; fall through into selectROMA
                
;-------------------------------------------------------------------------
;
; Select paged ROM bank.
;
; A = bank to select.
;
; Preserves A/X/Y/P
selectROMA:                   ;e592
                sta $F4         ;update ROMSEL copy
                sta ROMSEL
                rts

;-------------------------------------------------------------------------
;
; Select paged ROM bank 15 - TERMINAL - with ANDY paged in,
;
; Preserves A/X/Y

selectTerminalROMAndANDY2:
                phx
                jsr selectTerminalROMAndANDY
                plx
                rts

;-------------------------------------------------------------------------

irqEntryPoint:
                sta irqTempA
                pla                          ;restore P
                pha                          ;save P
                and #$10
                bne brkEntryPoint
                jmp (IRQ1V)

brkEntryPoint:
                phx
                tsx
                lda $0103,x                  ;get BRK address+1 LSB
                cld                          ;
                sec                          ;
                sbc #$01                     ;get BRK address LSB
                sta errPtr+0
                lda $0104,x                  ;get BRK address+1 MSB
                sbc #$00                     ;get BRK address MSB
                sta errPtr+1
                lda $F4                      
                sta romActiveAtLastBRK
                stx originalX                    
                ldx #romServiceCallBreakInstruction
                jsr makeROMServiceCall
                ldx currentLanguageROM
                jsr selectROMX
                plx
                lda irqTempA
                cli
                jmp (BRKV)

;-------------------------------------------------------------------------

                .if version!=400
LE5D4:
                sec
                ror rs423Busy
                bit aciaControlRegister
                bpl LE5E4
                jsr getRS423InputBufferFreeBytes
                ldx #$00
                bcs LE5E6
LE5E4:
                ldx #$40
LE5E6:
                jmp resetACIA

LE5E9:
                ldy ACIA+1
                and #$3A
                bne LE628
                ldx rs423Ignore
                bne LE5FE
                inx
                jsr osbyte99
                jsr getRS423InputBufferFreeBytes
                bcc LE5E4
LE5FE:
                rts
                .endif

;-------------------------------------------------------------------------

irq1EntryPoint:
                lda irqTempA
                pha
                phx
                phy
                .if version!=400
                clv
                .endif
                jsr irq1Handler
                ply
                plx
                pla
                rti

;-------------------------------------------------------------------------

irq2EntryPoint:
                lda irqTempA
                rti

;-------------------------------------------------------------------------

                .if version==400
rtsE64D:
                rts
                .else
irq1Handler:
                lda ACIA+0
                .if version>=500
                and rs423InterruptMask
                .endif
                bvs LE616
                bpl checkForSystemVIAInterrupt
LE616:
                ldx $EA
                dex
                bmi LE64E
                bvs rtsE64D
                jsr withTerminalROM
                jmp terminal.LA45D

LE623:
                ldy ACIA+1
                rol a
                asl a
LE628:
                tax
                tya
                ldy #$07
                jmp eventEntryPoint

LE62F:
                ldx #$02
                jsr osbyte91
                bcc LE646
                lda printerDriverType
                cmp #$02
                bne LE5D4
                inx
                jsr osbyte91
                ror bufferEmptyFlags+bufferPrinter
                bmi LE5D4
LE646:
                sta ACIA+1
                lda #$E7
                sta $EA
rtsE64D:
                rts

LE64E:
                .if version<500
                and rs423InterruptMask
                .endif
                lsr a
                bcc LE65B
                bvs LE65B
                ldy aciaControlRegister
                bmi LE5E9
LE65B:
                lsr a
                ror a
                bcs LE623
                bmi LE62F
                bvs rtsE64D
                .endif

;-------------------------------------------------------------------------

handleUnrecogisedInterrupt:
                ldx #romServiceCallUnrecognisedInterrupt
                jsr makeROMServiceCall
                beq rtsE64D                  ;taken if handled

                ; Pass unrecognised, unhandled interrupts to IRQ2V.
                pla                          
                pla                          
                ply                          
                plx                          
                pla
                .if version==350
                sta $fc
                .endif
                jmp (IRQ2V)                  

;-------------------------------------------------------------------------

                .if version==400
irq1Handler:
                .else
checkForSystemVIAInterrupt:
                .endif
                lda systemVIA.ifr            ; E672= AD 4D FE    -M~
                .if version==400
                bpl handleUnrecogisedInterrupt
                .else
                bpl checkForUserVIAInterrupt
                .endif
                and systemVIAInterruptMask
                and systemVIA.ier
                bit #VIA.irq.ca1
                beq checkForSystemVIAT1Interrupt

                ; Handle CA1 interrupt - CRTC vsync.
                
                dec cfsTimeoutCounter
                .if version!=400
                lda $EA                      ; E684= A5 EA       %j
                bpl +
                inc $EA                      ; E688= E6 EA       fj
+
                .endif
                lda flashCounter
                beq flashDone                    ;taken if no flash
                dec flashCounter             ;count down
                bne flashDone
                ldx firstFlashColourDuration ;assume first flash colour is next
                lda vcontrolRegister
                lsr a                        ;C=flash bit
                bcc +                        ;taken if first flash colour is next
                ldx secondFlashColourDuration ;actually, second flash colour is next
+
                rol a                        ;reinstate old register value
                eor #VCONTROL.flash          ;toggle flash bit
                jsr setVCONTROL                   
                stx flashCounter
flashDone:
                ldy #eventStartOfVerticalSync
                jsr eventEntryPoint
                lda #VIA.irq.ca1
                .if version==400
                bra staSystemVIAIFR
                .else
                jmp staSystemVIAIFR          ;acknowledge CA1
                .endif

                .if version!=400
checkForUserVIAInterrupt:
                lda userVIA.ifr
                bpl handleUnrecogisedInterrupt
                and userVIAInterruptMask
                and userVIA.ier              
                ror a                        ;C=CA2
                ror a                        ;C=CA1
                bcc handleUnrecogisedInterrupt
                ldy printerDriverType
                dey                          
                bne handleUnrecogisedInterrupt ;taken if printerDriverType not 1
                lda #VIA.irq.ca1
                sta userVIA.ifr              ;acknowledge CA1
                sta userVIA.ier              ;inhibit CA1
                ldx #bufferPrinter
                jmp LE8D5
                .endif

checkForSystemVIAT1Interrupt:
                bit #VIA.irq.t1
                .if version<400
                beq checkForSystemVIACB1Interrupt
                .else
                beq checkForSystemVIACA2Interrupt
                .endif

                ; Handle T1 interrupt - 100 Hz timer.
                
                lda #VIA.irq.t1
                sta systemVIA.ifr            ;acknowledge T1 interrupt
                lda timerSwitchState         
                tax                          ;X=old timerSwitchState
                eor #$0F                     
                pha                          ;save new timerSwitchState
                tay                          ;Y=new timerSwitchState
                sec                          ;C=1 - increment
updateTIMELoop:
                lda timer0-1,x
                adc #$00
                sta timer0-1,y

                ; one of X or Y will get to 0 to indicate the end of
                ; the loop.
                dex
                beq updateTIMEDone
                dey
                bne updateTIMELoop
updateTIMEDone:
                pla                          ;restore new timerSwitchState
                sta timerSwitchState
                ldx #$05
incrementIntervalTimer:
                inc intervalTimer-1,x
                bne intervalTimerDone
                dex
                bne incrementIntervalTimer
                ldy #eventIntervalTimerCrossingZero
                jsr eventEntryPoint
intervalTimerDone:
                lda inkeyTimeoutCounter+0
                bne LE715
                lda inkeyTimeoutCounter+1
                beq LE718
                dec inkeyTimeoutCounter+1
LE715:
                dec inkeyTimeoutCounter+0
LE718:
                bit previousKeyPressedWhenReadingOSBYTE
                bpl LE728
                inc previousKeyPressedWhenReadingOSBYTE
                cli
                .if version==350
                jsr LF3C5_350
                .else
                jsr LF416                    ;update sound???
                .endif
                sei
                dec previousKeyPressedWhenReadingOSBYTE
LE728:
                bit valueFF                  ;V=1
                .if version!=400
                jsr irq1Handler
                .endif
                lda lastKeyPressedInternal
                ora firstKeyPressedInternal
                and keyboardSemaphore
                beq +
                sec
                jsr LF8FF
+
                .if version>=500
                jsr handleDigitalJoystick
                .endif
                jsr pollPrinterDriver
                ldy romPollingSemaphore
                .if version==400
                beq rtsE6B6
                .else
                beq LE748
                .endif
                ldx #romServiceCallPollingInterrupt
                .if version==400
                jmp makeROMServiceCall
                .else
                jsr makeROMServiceCall
LE748:
                .if version<500
                bit HADC+0
                bvs LE752
                .endif
                rts
                .endif

                .if version!=400
checkForSystemVIACB1Interrupt:
                .if version<500
                bit #VIA.irq.cb1
                beq checkForSystemVIACA2Interrupt

                ; Handle CB1 interrupt - ADC conversion complete.
LE752:
                ldx currentADCChannel
                beq acknowledgeSystemVIACB1Interrupt
                lda HADC+2           
                sta adcResultLSBs-1,x
                lda HADC+1           
                sta adcResultMSBs-1,x
                stx adcLastConvertedChannel
                ldy #eventADCConversionComplete
                jsr eventEntryPoint
                dex                          ;next ADC channel
                bne initiateADCConversion
                ldx maximumADCChannel
initiateADCConversion:
                cpx #$05
                bcc +
                ldx #$04                     ;clamp ADC channel
+
                stx currentADCChannel
                lda adcConversionType
                dec a            ;$FF=default, $07=8 bits, $0b=12 bits
                and #$08         ;8=12 bits, 0=8 bits
                clc
                adc currentADCChannel        ;mix in ADC channel, 1-4
                dec a ;convert to hardware ADC channel, 0-3 (no risk of borrow)
                sta HADC+0                   ;initiate conversion
acknowledgeSystemVIACB1Interrupt:
                lda #$10
staSystemVIAIFR:
                sta systemVIA.ifr
                rts
                .elsif version>=500
initiateADCConversion:
                rts
                .endif
                .endif

checkForSystemVIACA2Interrupt:
                lsr a                        ;C = CA2
                bcc handleUnrecognisedInterruptE799

                ; Handle CA2 interrupt - keyboard.
                
                clc                          ; E791= 18          .
                jsr LF8FF                    ; E792= 20 FF F8     .x
                lda #VIA.irq.ca2
                .if version<400
                bra staSystemVIAIFR
                .else
staSystemVIAIFR:
                sta systemVIA.ifr
rtsE6B6:
                rts
                .endif                

handleUnrecognisedInterruptE799:
                jmp handleUnrecogisedInterrupt

;-------------------------------------------------------------------------
;
; OSBYTE 17 (&11) Write next ADC channel to be sampled [MasRef D.2-25]
;
osbyte11:
                .if version!=400
                .if version<500
                sty adcLastConvertedChannel
                .elsif version>=500
                sty currentADCChannel
                .endif
                bra initiateADCConversion
                .endif

;-------------------------------------------------------------------------
;
; Print a 0-terminated string at some offset from startupMessages.
;
; entry:
;
; Y = offset-1 of message
;
printStartupMessage:
                lda #>startupMessages
                ; .cerror (<startupMessages)!=0,"startupMessages must be page-aligned" ;it's more flexible than this, but this'll do for now

;-------------------------------------------------------------------------
;
; Print a 0-terminated string.
;
; entry:
;
; A = address MSB
;
; Y = (address LSB)-1
;
print0TerminatedString:
                sta errPtr+1
                stz errPtr+0

;-------------------------------------------------------------------------
;
; Print the BRK message.
;
; entry:
;
; (errPtr) = pointer to the error number (as will be the case after a
; BRK)
;
; Y=0
;
printBRKMessage:
                iny
                lda (errPtr),y
                jsr OSASCI
                tax       
                bne printBRKMessage
rtsE7B0:
                rts       

;-------------------------------------------------------------------------

                .if version>=500
;-------------------------------------------------------------------------

unk_E78B:       .byte 0
                .byte $8D       ;
                .byte $8F       ;
                .byte $8E       ;
                .byte $8C       ;
                .byte $7F       ;
                .byte $D
                .byte $8B       ;
                .byte $8B       ;
unk_E794:       .byte $96
                .byte $E6       ;
                .byte $D6       ;
                .byte $C6       ;
                .byte $86       ;

;-------------------------------------------------------------------------

handleDigitalJoystick:.block
                lda maximumADCChannel
                beq rtsE7B0
                bit adcConversionType
                bvc LE7DE
                lda adcResultLSBs
                ldx #0

LE7A8:
                inx
                asl a
                bcs LE7AF
                bne LE7A8
                tax

LE7AF:
                ldy unk_E78B,x
                cpy adcLastChannelRead
                sty adcLastChannelRead
                beq LE7C6
                tya
                beq LE7C6
                jsr insertCharacterIntoKeyboardBuffer
                lda keyboardAutoRepeatDelay
                sta adcResultMSBs+3

LE7C6:
                lda adcResultMSBs+3
                beq LE7DE
                dec adcResultMSBs+3
                bne LE7DE
                lda keyboardAutoRepeatRate
                sta adcResultMSBs+3
                ldy adcLastChannelRead
                beq LE7DE
                jsr insertCharacterIntoKeyboardBuffer

LE7DE:
                bit adcConversionType
                bpl LE7EA
                ldy #$B6
                ldx #$2C        ; Master Compact joystick call
                jmp makeROMServiceCall

;-------------------------------------------------------------------------

LE7EA:
                lda #$FF
                ldx editKeysMode
                cpx #3
                bne LE807
                inx

LE7F4:
                pha
                phx
                lda unk_E794,x
                tax
                sec
                clv
                jsr LED01
                plx
                pla
                rol a
                dex
                bpl LE7F4
                eor #$FF

LE807:
                and userVIA.irb
                eor #$1F
                lsr a
                php
                asl a
                asl a
                asl a
                plp
                rol a
                tax
                eor adcResultLSBs
                bit adcConversionType
                and #$F0
                stx adcResultLSBs
                bvs locret_E826
                beq LE827
                stz adcResultMSBs+3

locret_E826:
                rts

;-------------------------------------------------------------------------

LE827:
                lda adcConversionType
                beq LE832
                cmp #8
                bcc LE834
                lda #4

LE832:
                eor #3

LE834:
                tay
                dec a
                tax
                lda adcResultMSBs+3
                stz adcResultMSBs+2

LE83D:
                dex
                bmi LE846
                asl a
                rol adcResultMSBs+2
                bra LE83D

;-------------------------------------------------------------------------

LE846:
                sta adcResultMSBs+1
                cpy adcResultMSBs+2
                bcs LE854
                sty adcResultMSBs+1
                sty adcResultMSBs+2

LE854:
                lda adcConversionType
                and #$20
                beq LE86A
                lda #$FF
                sta adcResultLSBs+1
                sta adcResultLSBs+3
                lsr a
                sta adcResultLSBs+2
                sta adcResultMSBs

LE86A:
                ldx #9

LE86C:
                lda adcResultLSBs
                bit unk_E8D5,x
                beq LE8B2
                lda unk_E8D5+1,x
                asl a
                tay
                lda adcConversionType
                and #$20        ; ' '
                beq LE885
                lda unk_E8D5+2,x
                bra LE8AC

;-------------------------------------------------------------------------

LE885:
                lda adcResultLSBs+1,y
                bcs LE89C
                adc adcResultMSBs+1
                sta adcResultLSBs+1,y
                lda adcResultLSBs+2,y
                adc adcResultMSBs+2
                bcc LE8AF
                lda #$FF
                bra LE8AC

;-------------------------------------------------------------------------

LE89C:
                sbc adcResultMSBs+1
                sta adcResultLSBs+1,y
                lda adcResultLSBs+2,y
                sbc adcResultMSBs+2
                bcs LE8AF
                lda #0

LE8AC:
                sta adcResultLSBs+1,y

LE8AF:
                sta adcResultLSBs+2,y

LE8B2:
                dex
                dex
                dex
                bpl LE86C
                inc adcResultMSBs+3
                bne LE8BF
                dec adcResultMSBs+3

LE8BF:
                ldx currentADCChannel
                ldy #3
                jsr eventEntryPoint
                dec currentADCChannel
                beq LE8CE
                bpl locret_E8D4

LE8CE:
                lda maximumADCChannel
                sta currentADCChannel

locret_E8D4:
                rts
                .endblock

;-------------------------------------------------------------------------

unk_E8D5:       .byte $40; @
                .byte 1
                .byte $FF
                .byte $20
                .byte $81       ;
                .byte 0
                .byte $80       ;
                .byte $80       ;
                .byte 0
                .byte $10
                .byte 0
                .byte $FF
                .endif
                
;-------------------------------------------------------------------------

osbyte81Timed:
                stx inkeyTimeoutCounter+0
                sty inkeyTimeoutCounter+1
                ror readCharacterTimedFlag   ;set the timed flag
                cli
                bra osrdchWithTimeout

;-------------------------------------------------------------------------

osrdchEntryPoint:
                stz readCharacterTimedFlag   ;clear the timed flag
osrdchWithTimeout:
                phx
                phy
                ldy execFileHandle
                beq osrdchLoop               ;taken if not *EXEC'ing
                sec
                ror tapeCritical
                jsr OSBGET             ;get 1 byte from the *EXEC file
                stz tapeCritical
                bcc osrdchDone                    ;taken if byte valid
                lda #$00                     ;OSFIND close file
                stz execFileHandle           ;reset *EXEC handle
                jsr OSFIND                   ;close *EXEC file
osrdchLoop:
                lda escapeFlag               ;b7 set if ESCAPE pressed
                asl a                        ;C=1 if ESCAPE pressed
                lda #27                      ;ASCII for ESCAPE
                bcs osrdchDone               ;exit with C=1 if ESCAPE
                                             ;pressed
                .if version!=400
                ldx inputSource
                .endif
                jsr readFromEconetOrSoftKeyOrInputBufferA ;handle Econet/soft key stuff???
                bcc osrdchDone
                bit readCharacterTimedFlag
                bpl osrdchLoop     ;taken if no timeout - keep looping
                lda inkeyTimeoutCounter+1
                ora inkeyTimeoutCounter+0
                bne osrdchLoop     ;taken if timeout not timed out yet
                dec a              ;timed out: A=$ff, C=1
osrdchDone:
                ply
                plx
                rts

;-------------------------------------------------------------------------

starLIBFS:
                lda hazel.activeFS
                sta hazel.libFS
                rts                          ; E7FC= 60          `

;-------------------------------------------------------------------------

                .if version<500
starX:
                sta TUBE+8                   ; E7FD= 8D E8 FE    .h~
LE800:
                bra LE800                    ; E800= 80 FE       .~
                .endif

;-------------------------------------------------------------------------
;
; OSCLI
;
; MasRef D.4-1
;

oscliEntryPoint: .block
                jsr selectHAZEL
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                ldy #$00
-
                lda (stringInputBufferAddress),y
                sta hazel.commandLine,y
emptyCommandLine=*+1                         ;arbitrary place that's
                                             ;just a 13 byte...
                cmp #$0D
                beq +     ;branch taken if end of command line reached
                iny
                bne -
                
                ; OSCLI is a no-op if the command line is too long.
                rts

+
                ldy #>hazel.commandLine      ; E818= A0 DC        \
                ldx #<hazel.commandLine      ; E81A= A2 00       ".
                jsr withTerminalROM          ; E81C= 20 84 F3     .s
                jmp terminal.oscli           ; E81F= 4C FF 84    L..
                .endblock

emptyCommandLine=oscliEntryPoint.emptyCommandLine
                
                ; OSWRCH
                ; ======
oswrchEntryPoint:
                pha                          ;S=[ch]
                phx                          ;S=[x; ch]
                phy                          ;S=[y; x; ch]
                pha                          ;S=[ch; y; x; ch]
                bit econetOutputInterpretationStatus
                bpl LE833
                tay
                lda #netWriteCharacterAttempted
                jsr callNETV
                bcs LE8A5
LE833:
                lda #$02
                bit characterDestinationStatus
                bne LE862
                pla                          ;restore char to print
                pha                          ;save it again
                tax                          ;X=char to print
                lda ACCCON                   ;
                pha                          ;S=[old ACCCON; ch; y; x; ch]
                .if version==350
                jsr selectMOS
                .else
                lda #ACCCON.Y
                trb ACCCON                   ;MOS ROM at $c000
                .endif
                lda $F4
                pha          ;S=[old ROMSEL; old ACCCON; ch; y; x; ch]
                lda #$80|terminalROM
                sta $F4
                sta ROMSEL                   ;page in ANDY+Terminal
                txa                          ;A=char to print
                jsr outputToVDU
                pla
                sta $F4
                sta ROMSEL
                pla
                and #ACCCON.Y
                tsb ACCCON
                bcs LE869
LE862:
                lda #$08
                bit characterDestinationStatus
                beq LE86E
LE869:
                pla
                pha
                jsr LE8AA
LE86E:
                .if version!=400
                lda characterDestinationStatus
                ror a
                bcc LE88F
                ldy $EA
                dey
                bpl LE88F
                pla
                pha
                php
                sei
                ldx #$02
                pha
                jsr osbyte98
                bcc LE888
                jsr clearRS423BusyAndSetRS423Active
LE888:
                pla
                ldx #$02
                jsr LE9A3
                plp
LE88F:
                .endif
                
                lda #$10
                bit characterDestinationStatus
                bne LE8A5
                ldy spoolFileHandle
                beq LE8A5
                pla
                pha
                sec
                ror $EB
                jsr OSBPUT
                lsr $EB
LE8A5:
                pla
                ply
                plx
                pla
                rts

LE8AA:
                bit characterDestinationStatus
                bvs LE8D4
                cmp printerIgnoreChar
                bne LE8B9
                bit noignoreState
                bpl LE8D4
LE8B9:
                php
                sei
                tax
                lda #$04
                bit characterDestinationStatus
                bne LE8D3
                txa
                ldx #$03
                jsr LE9A3
                bcs LE8D3
                bit bufferEmptyFlags+bufferPrinter
                bpl LE8D3
                jsr LE8D5
LE8D3:
                plp
LE8D4:
                rts

LE8D5:                                       ;E7CA in MOS 4.00
                lda printerDriverType
                .if version!=400
                beq LE959
                dec a
                bne LE8FD
                jsr osbyte91
                ror bufferEmptyFlags+bufferPrinter
                bmi rtsE928
                ldy #$82
                sty userVIA.ier
                sta userVIA.ora
                lda userVIA.pcr
                and #$F1
                ora #$0C
                sta userVIA.pcr
                ora #$0E
                sta userVIA.pcr
                rts

LE8FD:
                dec a
                bne activatePrinterDriver
                ldy $EA
                dey
                bpl LE959
                lsr bufferEmptyFlags+bufferPrinter
clearRS423BusyAndSetRS423Active:
                lsr rs423Busy
setRS423Active:
                jsr getRS423InputBufferFreeBytes
                bcc rtsE928
                ldx #ACIA.control.rtsLowTXInterruptEnabled
resetACIA:
                ldy #ACIA.control.rtsRTSInterruptEnabled|ACIA.control.word8DataOddParity1Stop|ACIA.control.reset

;-------------------------------------------------------------------------
;
; OSBYTE 156 (&9C) Read/write serial ACIA control [MasRef D.2-47]
; 
osbyte9C:
                php
                sei
                tya
                stx SEIWKA
                and aciaControlRegister
                eor SEIWKA
                ldx aciaControlRegister
writeACIAControlRegister:
                sta aciaControlRegister
                sta ACIA.control
                plp
rtsE928:
                rts

                .else

                cmp #printerDriverTypeUser
                bcc LE959

writeACIAControlRegister:
osbyte9C:
setRS423Active:
                
                .endif

;-------------------------------------------------------------------------

activatePrinterDriver:
                clc                          ; E929= 18          .
                lda #printerDriverActivate
                jsr callPrinterDriverWithPrinterBuffer
                
                ; printer driver will set C=0 if active, C=1 if
                ; inactive.

;-------------------------------------------------------------------------
;
; OSBYTE 123 (&7B) Inform MOS of printer driver going dormant [MasRef
; D.2-36]
;
osbyte7B:
                ror bufferEmptyFlags+bufferPrinter   ;C=1 on entry, so set bit 7
rtsE932:
                rts

;-------------------------------------------------------------------------

pollPrinterDriver:
                bit bufferEmptyFlags+bufferPrinter
                bmi rtsE932           ;taken if printer driver dormant
                lda #printerDriverPoll
callPrinterDriverWithPrinterBuffer:
                ldx #bufferPrinter
callPrinterDriver:
                ldy printerDriverType
                jsr callNETV                    ; E93F= 20 04 EB     .k
                jmp (UPTV)                  ; E942= 6C 22 02    l".

;-------------------------------------------------------------------------
;
; OSBYTE 15 (&0F) Flush buffer
; 
osbyte0F:
                bne LE956
LE947:
                ldx #$08
LE949:
                cli
                sei
                jsr osbyte15
                dex
                bpl LE949

;-------------------------------------------------------------------------
;
; OSBYTE 21 (&15) Flush selected buffer
; 
osbyte15:                                    ;e951
                cpx #bufferMax+1
                bcc LE959
                rts

LE956:
                ldx inputSource
LE959:
                clc
LE95A:
                pha
                php
                sei
                bcs LE967
                txa
                and #$04                     ;buffer 4-7?
                beq LE967                    ;taken if not sound buffer
                jsr clearSoundChannelBuffer
LE967:
                sec
                ror bufferEmptyFlags,x
                cpx #bufferFirstOutput
                bcs LE975                    ;taken if output buffer
                stz softKeyStringLength
                stz vduQueueNegativeLength
LE975:
                jsr purgeBufferViaCNPV
                plp
                pla
                rts

;-------------------------------------------------------------------------
;
; Count/purge entry point [AUG p264]
; 
cnpEntryPoint:
                bvc countBuffer
purgeBuffer:
                lda bufferStartIndices,x
                sta bufferEndIndices,x
                rts                          

countBuffer:
                php                          
                sei                          
                php                          
                sec                          
                lda bufferEndIndices,x
                sbc bufferStartIndices,x
                bcs LE994                    
                sec                          
                sbc bufferIndex0Offsets,x                  
LE994:
                plp                          
                bcc LE99D                    
                clc                          
                adc bufferIndex0Offsets,x                  
                eor #$FF                     
LE99D:
                ldy #$00                     
                tax                          
                plp                          
rtsE9A1:
                rts                          

;-------------------------------------------------------------------------

LE9A2:
                cli
LE9A3:
                sei
LE9A4:
                jsr callINSV
                bcc rtsE9A1
                jsr LF241
                pha
                jsr updateKeyboardLEDs
                asl a
                pla
                bcc LE9A2
                rts

;-------------------------------------------------------------------------
;
; OSBYTE $77
;
; D.2-33
;
                .if version!=350
osbyte77:                       ;e9b5
                jsr withTerminalROM
                jmp terminal.L9423
                .endif

;-------------------------------------------------------------------------
;
; Get *IGNORE CMOS byte offset and mask for a given ROM.
;
; entry:
;
; Y = ROM number
;
; exit:
;
; A = mask
;
; X = RTC address of byte
;
getROMInsertedFlagRTCAddressAndMask:
                lda #$00                     
                sec                          
                ldx #CMOSBytes.insertedROMs+0+cmosBytesOffset
-
                rol a                        
                bne +
                inx                          
                rol a                        
+
                dey                          
                bpl -
                rts                          

;-------------------------------------------------------------------------

_:=[]
_..=[(bufferKeyboardAddress,bufferKeyboardSize)]
_..=[(bufferRS423InputAddress,bufferRS423InputSize)]
_..=[(bufferRS423OutputAddress,bufferRS423OutputSize)]
_..=[(bufferPrinterAddress,bufferPrinterSize)]
_..=[(bufferSoundChannel0Address,bufferSoundChannel0Size)]
_..=[(bufferSoundChannel1Address,bufferSoundChannel1Size)]
_..=[(bufferSoundChannel2Address,bufferSoundChannel2Size)]
_..=[(bufferSoundChannel3Address,bufferSoundChannel3Size)]
_..=[(buffer8Address,buffer8Size)]
buffers=_

BufferTableIndex0Offset: .function buffer
                .endfunction 256-buffer[1]
                
BufferTableBase: .function buffer
                .endfunction buffer[0]-BufferTableIndex0Offset(buffer)

;-------------------------------------------------------------------------
;
; Buffer base addresses - each buffer's address, offset by the offset
; for index 0 (see bufferIndex0Offsets).
;
bufferBaseAddressMSBs:
                .for i=0,i<len(buffers),i+=1
                .byte >BufferTableBase(buffers[i])
                .endfor
                
bufferBaseAddressLSBs:
                .for i=0,i<len(buffers),i+=1
                .byte <BufferTableBase(buffers[i])
                .endfor
                
;-------------------------------------------------------------------------

; Offset of buffer index 0 for each buffer. Index 0 is (-buffer size)
; - buffer indexes count up, and wrap once they reach 0.

bufferIndex0Offsets:
                .for i=0,i<len(buffers),i+=1
                .byte BufferTableIndex0Offset(buffers[i])
                .endfor

;-------------------------------------------------------------------------
;
; Get base address for a buffer.
;
; entry:
;
; X = buffer number
;
; exit:
;
; (SEIWKA) = buffer base address
;
getBufferBaseAddress:
                lda bufferBaseAddressLSBs,x
                sta SEIWKA
                lda bufferBaseAddressMSBs,x
                sta SEIWKB
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 152 (&98) Examine buffer status [MasRef D.2-45]
;
osbyte98:
                bit valueFF                  ;V=1
                bra callREMV

;-------------------------------------------------------------------------
;
; OSBYTE 145 (&91) Get character from buffer [MasRef D.2-45]
;
; X = buffer number
osbyte91:
                clv                          ;remove
callREMV:
                jmp (REMV)  

;-------------------------------------------------------------------------
;
; Buffer remove entry point. [AUG p263]
;
; Even in remove mode, A is the character removed on exit. Some of the
; other MOS routines rely on this.
; 
remEntryPoint:
                php
                sei
                lda bufferStartIndices,x
                cmp bufferEndIndices,x
                beq plp_sec_rts  ;taken if buffer empty
                tay                          ;Y=start index
                jsr getBufferBaseAddress
                lda (SEIWKA),y               ;get byte from buffer
                bvs tay_plp_clc_rts                  ;taken if only looking
                pha                          ;save buffered byte
                iny                          ;next char in buffer
                tya                          ;set Z if wrap
                bne +                        ;branch taken if no wrap
                lda bufferIndex0Offsets,x    ;reset index on wrap
+
                sta bufferStartIndices,x

                ; Issue output buffer empty event when appropriate.
                cpx #bufferFirstOutput
                bcc pla_tay_plp_clc_rts ;taken if keyboard or RS423
                                        ;input - i.e., buffer is input
                cmp bufferEndIndices,x       ;buffer now empty?
                bne pla_tay_plp_clc_rts           ;taken if not empty
                ldy #eventOutputBufferEmpty
                jsr eventEntryPoint
pla_tay_plp_clc_rts:
                pla                          ;restore buffered byte
tay_plp_clc_rts:
                tay                          ;Y=buffered byte
plp_clc_rts:
                plp
                clc
                rts

;-------------------------------------------------------------------------
;
; [MasRef D.9-1]
; 
eventEntryPoint:
                php                          
                sei                          
                pha                          
                lda eventEnabledFlags,y      ;is the event enabled?
                beq pla_plp_sec_rts                    ;
                tya                          
                ply                          
                phy                          
                jsr LF8BF                    
                bra pla_tay_plp_clc_rts                    

;-------------------------------------------------------------------------
;
; Insert character into buffer and issue an event for it.
;
; entry:
;
; Y = buffer number
; 
insertCharacterIntoBuffer:
                tya                          
                ldy #eventCharacterEnteringBuffer
                jsr eventEntryPoint
                tay                          

;-------------------------------------------------------------------------
;
; OSBYTE 138 (&8A) Insert character code into buffer [MasRef D.2-43]
; 
osbyte8A:
                tya                          
callINSV:
                jmp (INSV)                  

;-------------------------------------------------------------------------
;
; Default INSV entry point [AUG p263]
; 
insEntryPoint:
                php
                sei
                pha                          ;save value to insert
                lda bufferEndIndices,x       ;get buffer index
                inc a                        ;bump index
                bne +          ;taken if index hasn't wrapped around
                lda bufferIndex0Offsets,x        ;reset index due to wrap
+
                cmp bufferStartIndices,x     ;are we at the start index?
                beq bufferFull       ;taken if yes - i.e., buffer full
                ldy bufferEndIndices,x       ;note old buffer end
                sta bufferEndIndices,x       ;update buffer end
                jsr getBufferBaseAddress
                pla                          ;restore value to insert
                sta (SEIWKA),y               ;store byte in buffer
                bra plp_clc_rts              ;done

bufferFull
                ; Issue input buffer full event when appropriate.
                pla                          
                cpx #bufferFirstOutput
                bcs plp_sec_rts  ;taken if output buffer
                ldy #eventInputBufferFull
                jsr eventEntryPoint
                pha
pla_plp_sec_rts:
                pla
plp_sec_rts:
                plp
                sec
                rts

;-------------------------------------------------------------------------
;
; Check if character is a letter - A-Z or a-z.
;
; Entry:
;
; A = character to test
;
; Exit:
;
; C=0 if character is letter, C=1 otherwise
;
; Preserves: A/X/Y
isLetter: .proc                 ;EA71
                pha
                and #$DF        ;convert to upper case
                cmp #'Z'+1
                bcs +           ;branch taken with C=1 if past Z
                eor #$FF
                cmp #-'A'       ;C=1 if past A
+
                pla
                rts
                .pend

;-------------------------------------------------------------------------
;
; OSBYTE 153 (&99) Insert character code into buffer, checking for
; ESCAPE [MasRef D.2-46]
;
insertCharacterIntoKeyboardBuffer:
                .if version==350
                jsr callWithTST
insertCharacterIntoKeyboardBufferWithTST:
                .endif
                ldx #$00                     
osbyte99:
                .if version!=400
                txa                          ;X=1 if RS423, 0 if keyboard
                and rs423InputInterpretationStatus ;A=0 if RS423 simulates keyboard, 1=default
                bne osbyte8A ;taken if default - don't treat RS423 as keyboard
                .endif
                tya          ;A=char
                eor escapeCharacter
                ora escapeKeyStatus
                bne insertCharacterIntoBuffer
                lda breakAndESCAPEEffect
                ror a                        ;C=0 if normal ESCAPE action
                tya                          ;A=char
                bcs osbyte99Done             ;taken if ESCAPE inhibited
                ldy #eventESCAPEPressed
                jsr eventEntryPoint
                bcc osbyte99Done             ;taken if event handled
                jsr osbyte7D
osbyte99Done:
                clc                          ; EAA0= 18          .
                rts                          ; EAA1= 60          `

;-------------------------------------------------------------------------

; A = 0 (edit keys)/1 (ascii keys)/2 (F keys)
handleCursorKeysAndCopy:
                .if version<500
                ror a                        ;test edit keys mode bit 0
                pla                          ;restore translated value
                bcs clc_rts_EABD       ;taken if value was asciiKeys
                .else
                cmp #2
                pla
                bcc clc_rts_EABD
                .endif
                
handleFunctionKey:
                tya
                .if version<500&&version!=350
                and #$0F
                .endif
                .if version==350
                pha
                jsr LE520
                .else
                pha
                tya
                lsr a
                lsr a
                lsr a
                lsr a
                .endif
                eor #$04
                tay
                lda input192To207Interpretation-8,y
                lsr a
                .if version<500&&version!=350
                beq LEB32
                pla
                clc
                adc input192To207Interpretation-8,y
                .else
                bne +
                jmp LEC99
+
                rol a
                cmp #2
                bne LEBF5
LEBEA:
                pla
                sta softKeyExpansionPtr
                lda #$ff
                sta softKeyStringLength
                inc a
                bra clc_rts_EABD

LEBF5:
                pla
                and #$0f
                clc
                adc input192To207Interpretation-8,y
                .endif
                
clc_rts_EABD:
                clc
                rts

;-------------------------------------------------------------------------

copyCharNotRecognised:
                jsr vdu7EntryPoint           ;beep
                plx
readFromInputBufferX:
                jsr osbyte91          ;extract character from buffer X
                .if version<500&&version!=350
                bcs rtsEB28           ;taken if buffer empty
                .elsif version>=500||version==350
                bcs LEC0D
                tay
                bne LEAC8
                .if version>=511||version==350
                txa
                and rs423InputInterpretationStatus
                bne LEC29
                .endif
                .if version==350&&!finmos329
                jsr LEB75
                .else
                jsr osbyte91
                .endif
LEC0D:
                bcs rtsEB28
                tay
                bne clc_rts_EABD
                pha
                ldy #8

LEC15:
                lda shiftCtrlSoftKeyInterpretation-8,y
                cmp #2
                beq LEBEA
                dey
                bne LEC15
                pla
                bra clc_rts_EABD
                .endif

                .if version>=511||version==350
LEC29:
                tya
                .endif

                .if version!=400
LEAC8:
                pha                   ;save character extracted
                cpx #bufferRS423Input ;was it RS423 input buffer?
                bne LEAD3             ;taken if not RS423 input buffer
                jsr setRS423Active
                sec
                ldx #bufferRS423Input

LEAD3:
                pla                          ;restore char extracted
                bcc LEADB                    ;taken if keyboard buffer
                ldy rs423InputInterpretationStatus ;D.2-54
                bne clc_rts_EB27             ;taken if default mode
                .endif
                
LEADB:
                tay                          ;Y = char
                bpl clc_rts_EB27             ;if normal char, all good
                and #$0F
                cmp #$0B
                bcc handleFunctionKey        ;taken if F key
                adc #$7B    ;C=1, so +$7c - convert $0b-0$f to $87-$8B
                pha         ;save translated value
                lda editKeysMode
                bne handleCursorKeysAndCopy  ;taken if not editKeys
                lda characterDestinationStatus
                ror a                        ;C=rs423_enable
                ror a                        ;C=vdu_disable
                pla                          ;restore translated value
                bcs readFromInputBufferX     ;taken if VDU output disabled
                cmp #$87                     ;COPY?
                beq readCopyChar
                phx                          ;save buffer number
                jsr handleCursorKeyThunk     ;handle cursor key
                plx
readFromEconetOrSoftKeyOrInputBufferA:
                .if version==400
                ldx #0
                .endif
                bit econetInputInterpretationStatus
                bpl readFromSoftKeyOrInputBufferA
                lda #netReadCharacterAttempted
callNETV:
                jmp (NETV)

readFromSoftKeyOrInputBufferA:
                lda softKeyStringLength
                beq readFromInputBufferX
                .if version>=500||version==350
                inc a
                bne LEC70
                stz softKeyStringLength
                lda softKeyExpansionPtr
                bra clc_rts_EB27
LEC70:
                .endif
                .if version!=400
                txa
                and rs423InputInterpretationStatus
                bne readFromInputBufferX
                .endif
                lda $F4
                pha
                jsr selectTerminalROMAndANDY2
                lda (softKeyExpansionPtr)
                plx
                jsr selectROMX
                dec softKeyStringLength
                inc softKeyExpansionPtr+0
                bne clc_rts_EB27
                inc softKeyExpansionPtr+1
clc_rts_EB27:
                clc
rtsEB28:
                rts

readCopyChar:
                phx
                jsr handleCopyKeyThunk
                .if version<500&&version!=350
                beq copyCharNotRecognised
                .else
                bne +
                jmp copyCharNotRecognised
+
                .endif
                plx
                clc
rtsEB31:
                rts

                .if version>=500||version==350
LEC99:
                pla
                and #$0f
                tay
                bcs LECA2
                jmp readFromInputBufferX

LECA2:
                sta currentSoftKey

                .elsif version<500

LEB32:
                ply
                bcc readFromInputBufferX
                tya
                sta currentSoftKey

                .endif
                
                lda $F4
                pha                           ;save old ROMSEL
                jsr selectTerminalROMAndANDY2
                jsr getSoftKeyStringLength
                sta softKeyStringLength
                lda andy.softKeys.stringLSBs,y
                sta softKeyExpansionPtr+0
                lda andy.softKeys.stringMSBs,y
                sta softKeyExpansionPtr+1
                pla
                jsr selectROMA               ;restore old ROMSEL
                bra readFromEconetOrSoftKeyOrInputBufferA

;-------------------------------------------------------------------------

getSoftKeyStringLength:
                lda andy.softKeys.stringLSBs+1,y
                sec                          
                sbc andy.softKeys.stringLSBs+0,y
                rts                          

;-------------------------------------------------------------------------
;
; Page HAZEL out, page MOS in, call handleCursorKey.
; 
handleCursorKeyThunk:
                jsr withMOSROM
                jmp handleCursorKey     

;-------------------------------------------------------------------------
;
; Page HAZEL out, page MOS in, call handleCopyKey.
; 
handleCopyKeyThunk:
                jsr withMOSROM
                jmp handleCopyKey     

;-------------------------------------------------------------------------

                .if version==350&&!finmos329
LEB75:
                jsr osbyte91
                bcc LEB7E
                bit $ff
                bpl LEB75
LEB7E:
                rts
                .endif
                
;-------------------------------------------------------------------------

                .if version<500&&version!=350
                .include "osbyte_osword_table.s65"
                .endif

;-------------------------------------------------------------------------

osbyte88: ;LEC37:
                lda #$00

callUSERV:
                jmp (USERV)

osbyte7E:                       ;ec3c
                ldx #$00
                bit $FF
                bpl osbyte7C
                lda escapeEffects
                bne LEC54
                cli
                stz pagedModeCounter
                jsr withTerminalROM
                jsr terminal.starEXEC
                jsr LE947
LEC54:
                ldx #$FF
osbyte7C: ;EC56
                clc
osbyte7D: ;EC57
                .if version<500
                .if version==350
                php
                rol $ff
                plp
                .endif
                ror $FF
                bit tubePresence
                bpl LECD9
                jmp terminal.tubeHost.copyEscapeStatus
                .elsif version>=500
                php
                sei
                php
                asl escapeFlag
                plp
                ror escapeFlag
                plp
                bra LECD9
                .endif

;-------------------------------------------------------------------------

                .if version<400
osbyte89:
                lda serialULARegister
                tay
                rol a
                cpx #$01
                ror a
                bra LEC89
                .endif
                
;-------------------------------------------------------------------------
;
; ;OSBYTE 8 (&08) Write RS423 transmit rate
;
; This call sets the RS423 baud rate for transmitting data. The actual format of
; the data is set using OSBYTE 156/&9C (see below).
;
; Entry parameters :
; X=0 selects 9600 baud
; X=1 selects 75 baud
; X=2 selects 150 baud
; X=3 selects 300 baud
; X=4 selects 1200 baud
; X=5 selects 2400 baud
; X=6 selects 4800 baud
; X=7 selects 9600 baud
; X=8 selects 19200 baud
; Y=0
;                 
; On exit : X=Y=<old serial ACIA control register contents>

                .if version!=400
osbyte08:
                lda #$38
                ; fall through to OSBYTE &07
                .endif
                
;-------------------------------------------------------------------------
;
; OSBYTE 7 (&07) Write RS423 receive rate
;
; This call sets the RS423 baud rate for receiving data. The actual
; format of the data is set using OSBYTE 156/&9C (see below).
;
; Entry parameters :
; X=0 selects 9600 baud
; X=1 selects 75 baud
; X=2 selects 150 baud
; X=3 selects 300 baud
; X=4 selects 1200 baud
; X=5 selects 2400 baud
; X=6 selects 4800 baud
; X=7 selects 9600 baud
; X=8 selects 19200 baud
; Y=0
;                 
; On exit : X=Y=<old serial ACIA control register contents>

                .if version!=400
osbyte07:                                    ;ec6d
                eor #$3F                     ;if OSBYTE 8,
                                             ;A=%00000111, mask for
                                             ;transmit rate; if OSBYTE
                                             ;8, A=%000111000, mask
                                             ;for receive rate.
                sta $FA                      ;save mask
                ldy serialULARegister                    ;
                cpx #$09                     ;check for invalid baud rate
                bcs LEC8F                    ;branch taken if invalid
                and serialBaudRatesTable,x   ;get setting in A
                sta $FB                      ;store setting
                tya                          ;
                ora $FA                      ; EC7E= 05 FA       .z
                eor $FA                      ; EC80= 45 FA       Ez
                ora $FB                      ; EC82= 05 FB       .{
                ora #$40                     ; EC84= 09 40       .@
                eor rs423Destination ;mask in tape/serial flag set by OSBYTE 205ac
LEC89:
                sta serialULARegister
                sta SERPROC+0
LEC8F:
                tya
LEC90:
                tax
                rts
                .endif

                .if version==400
osbyte08:
osbyte07:
LEC89:
LEC90:
                .endif

;-------------------------------------------------------------------------

; Y=0 on entry.

osbyte09:                       ;ec92
                iny
                clc
osbyte0A:                                    ;ec94
                lda firstFlashColourDuration,y
                pha
                txa
                sta firstFlashColourDuration,y
                ply
                lda flashCounter
                bne LEC8F
                stx flashCounter
                lda vcontrolRegister
                php
                ror a
                plp
                rol a
                sta vcontrolRegister
                sta VCONTROL
                bra LEC8F

;-------------------------------------------------------------------------
;
; OSBYTE 2 (&02) Specify input stream
;
; Input may be taken from either the keyboard (by default) or the
; RS423 port. This call specifies the selection for all subsequent
; input.
;
; Entry parameters :
; X=0 selects keyboard input and disables RS423
; X=1 selects and enables RS423 input
; X=2 selects keyboard input and enables RS423
; Y=0
; 
; On exit : X=0 indicates previous input was from the keyboard
;           X=1 indicates previous input was from RS423
;           Y is undefined
;
; D.2-18
                .if version!=400                
osbyte02:                       ;ecb4
                txa
                and #$01
                pha
                lda aciaControlRegister
                rol a
                cpx #$01
                ror a
                cmp aciaControlRegister
                php
                sta aciaControlRegister
                sta ACIA+0
                jsr setRS423Active
                plp
                beq LECD2
                bit ACIA+1
LECD2:
                ldx inputSource
                pla
                sta inputSource
LECD9:
                rts
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 13 (&0D) Disable event
;
; All events are assigned a unique number and this call provides a
; means of disabling specific events.
;
; Entry parameters:
; X = event number
;
; On exit: X = Y = <old enable state> (0=disabled)
osbyte0D:
                tya             ;A=0

;-------------------------------------------------------------------------
;
; OSBYTE 14 (&0E) Enable event
;
; This call provides a means of enabling specific events.
;
; 
osbyte0E:
                cpx #eventMax+1
                .if version!=400
                bcs LEC90
                .else
                bcs LEB22
                .endif
                ldy eventEnabledFlags,x
                sta eventEnabledFlags,x
                .if version!=400
                bra LEC8F
                .else
LEC8F:
LEB21:
                tya
LEB22:
                tax
LECD9:
                rts
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 16 (&10) Write number of ADC channels
;
; By default, each of the four ADC channels is sampled and converted
; in turn so that each reading is updated every 40 milliseconds. This
; call enables the number of channels to be changed so that if, for
; example, only two channels are required, each will be updated every
; 20 milliseconds.
;
                .if version!=400
osbyte10:
                .if version<500
                beq +                        ;taken if X=0
                jsr osbyte11
+
                .endif
                lda maximumADCChannel
                stx maximumADCChannel
                tax
                rts
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 129 (&81) Read key with time limit
;
; This call may be used to read a key from the keyboard subject to a
; specified time limit or to perform a keyboard scan for a specified
; key depression.

osbyte81:
                tya
                bmi LED01          ;taken if scanning for specific key
                jsr osbyte81Timed
                bcs LECFF                 ;taken if timed out or error
                tax                       ;X = ASCII char
LECFD:
                lda #$00
LECFF:
                tay
                rts

LED01:
                txa
                beq LED14
                eor #$7F
                tax
                jsr callKEYV
                rol a
                ; fall through

;-------------------------------------------------------------------------

osbyte82:
                ldx #$FF
                ldy #$FF
                bcs LEB13                    ;if OSBYTE $82, done
                inx
                iny
LEB13:
                rts

LED14:
                .if version==320
                ldx #$FD
                .elsif version==400
                ldx #$f7
                .elsif version==500||version==510
                ldx #$f5
                .elsif version==511||finmos329
                ldx #$f4
                .elsif version==350
                ldx #$fd
                .endif
                bra LECFD

LED18:
                .if version==400
                bpl LEB13
                .endif
                txa
                eor #$FF
                tax
                cpx #$02
                ; fall through

;-------------------------------------------------------------------------

countBufferViaCNPV:
                clv                          ; ED1E= B8          8
                bra callCNPV                    ; ED1F= 80 03       ..

purgeBufferViaCNPV:
                bit valueFF                  ;V=1
callCNPV:
                jmp (CNPV)                  ; ED24= 6C 2E 02    l..

;-------------------------------------------------------------------------

                .if version!=400
getRS423InputBufferFreeBytes:
                sec
                ldx #bufferRS423Input
                jsr countBufferViaCNPV
                cpy #$01                     ;check MSB
                bcs +                        ;if >= 256 bytes, all good
                cpx rs423InputBufferMinimumSpace ;compare to min space
+
                rts
                .endif

;-------------------------------------------------------------------------

                .if version!=400
osbyte80:
                bmi LED18
                beq LED45
                .if version<500
                cpx #$05
                bcs osbyte82                 ;return with X=$ff Y=$ff
                ldy adcResultMSBs-1,x
                lda adcResultLSBs-1,x
                tax
                .elsif version>=500
                inx
                txa
                and #1
                asl a
                tax
                ldy adcResultLSBs+3-1,x
                lda adcResultLSBs+2-1,x
                tax
                .endif
                rts
                .endif

;-------------------------------------------------------------------------

                .if version!=400
LED45:
                .if version<500
                ; Put joystick buttons in bits 0/1.
                lda systemVIA.irb
                ror a
                ror a
                ror a
                ror a
                eor #$FF
                and #$03
                ldy adcLastChannelRead
                stx adcLastChannelRead
                tax
                .elsif version>=500
                ldy currentADCChannel
                ldx adcResultLSBs
                .endif
                rts
                .endif
                
;-------------------------------------------------------------------------
;
; OSBYTE $70
;
; D.2-31
;
osbyte70:                       ;ed58
                jsr osbyte7071
                asl a
                beq clearACCCCONE
LED5E:
                tsb ACCCON
                rts

clearACCCCONE:
                lda #ACCCON.E
LED64:
                trb ACCCON
                rts

;-------------------------------------------------------------------------

osbyte71:                       ;ed68
                jsr osbyte7071
                bne LED5E
                inc a
                bra LED64

;-------------------------------------------------------------------------
;
; Handle OSBYTE $70 or OSBYTE $71
;
; Entry: A=$70 or $71
; 
osbyte7071:
                tay
                txa
                .cerror vduDriverMemory+1!=displayMemory
                sta vduDriverMemory-$70,y
                bne LED80
                lda STATE
                and #STATE.isShadowMode
                beq LED83
LED7D:
                lda #$01
                rts

LED80:
                dec a
                bne LED7D
LED83:
                rts

;-------------------------------------------------------------------------

; OSBYTE &6E (110), &6F (111)
; ===========================
; Pass to sideways ROMs
osbyteUnused:                   ;ed84
                ldx #romServiceCallUnrecognisedOSBYTE
                jsr makeROMServiceCall
                ldx originalX
                .if version!=400
                eor #$00
                .endif
                rts

;-------------------------------------------------------------------------

                .if version!=350
osbyteA1:
                jsr withTerminalROM
                jmp terminal.readCMOSByte
                .endif

;-------------------------------------------------------------------------

                .if version!=350
osbyteA2:
                jsr withTerminalROM
                jmp terminal.writeCMOSByte
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 140 (&8C) Select Cassette Filing System [MasRef D.2-43]
; OSBYTE 141 (&8D) Select ROM Filing System [MasRef D.2-43]
;
osbyte8C8D:
                jsr selectROMOrTAPEByOSBYTE
                lda ACCCON                    ; Save ACCON register
                pha
                jsr selectHAZEL         ; Page Hazel workspace in
                ldx hazel.activeFS
                stx hazel.currentFS
                lda #terminalROM
                sta hazel.currentFSROM
                pla                          ; Restore ACCON
selectMOSOrHAZEL:                                       ;edb0
                and #ACCCON.Y   ;get just the HAZEL/MOS bit
                bne tsbACCCON   ;branch taken if HAZEL at $c000
selectMOS:
                lda #ACCCON.Y
                trb ACCCON      ;page in MOS at $c000
                rts

selectHAZEL:
                lda #ACCCON.Y
tsbACCCON:
                tsb ACCCON      ;page in HAZEL at $c000
                rts

;-------------------------------------------------------------------------

                .if version==400
LEBBF:
                jsr LEE64
                jsr LF1EE
                .endif
                
;-------------------------------------------------------------------------
; 
; Select ROM or TAPE.
;
; Two entry points: selectROMOrTAPEByOSBYTE picks FS by OSBYTE number
; ($8c=TAPE, $8d=ROM), and selectROMOrTAPE picks FS by number (0=TAPE,
; 1=ROM).
;
; entry:
;
; A = FS to select
; 
selectROMOrTAPEByOSBYTE:
                .if version==400

LEDD0:
                lda #2
                sta cfsRFSFSSwitch

                lda #6
                jsr callFSCV

                stz $ce
                
                .else

                eor #$8C                     ;A=0 if tape, A=1 if ROM
selectROMOrTAPE:
                asl a           ; Set CFS/RFS switch to 0=CFS or 2=RFS
                sta cfsRFSFSSwitch
                bne LEDCC                    ;taken if ROM
                lda #$04                     ; CFS, clear b2 of status
                trb $E2
LEDCC:
                cpx #$03                     ; EQ=TAPE 300, NE=TAPE 1200
                bra LEDD6
                
LEDD0:
                .if version==350
                jsr callWithTST
                .endif
                jsr LEE64
                jsr LF1EE
LEDD6:
                php                          ; Save baud flag in Carry
                lda #$06                     ; Vectors about to change
                jsr callFSCV
                lda cfsRFSFSSwitch           ; Jump if RFS selected
                bne LEDEE
                ldx #$06                     ; Prepare baud=6 for TAPE300
                plp                          ; Skip past if TAPE300
                beq LEDEB
                lda #$04                     ; TAPE1200, set bit 2 of status
                tsb $E2
                dex                          ; Change to baud=5 for TAPE1200
LEDEB:
                stx $C6                      ; Store baud rate setting
                php
LEDEE:
                stz $CE                      ; Clear byte (unused on BBC)
                plp
                .endif
                
                ldx #defaultVectorTable.fsVectors.end-defaultVectorTable.fsVectors ; Prepare to set 7 vectors
LEDF3:
                lda defaultVectorTable.fsVectors-1,x ; Set filing
                                                     ; system vectors
                                                     ; to point to
                                                     ; extended
                                                     ; vectors
                sta FILEV-1,x
                dex
                bne LEDF3
                jsr LF1EE                    ; Set extended vectors
                stz $C2                      ; Set Progress=idle
                ldx #romServiceCallVectorsClaimed ; Send service call &0F - vectors changed

;-------------------------------------------------------------------------
;
; OSBYTE 143 (&8F) Issue paged ROM service request [MasRef D.2-44]
;
osbyte8F: .proc                    ;ee03
                phy
                phx                          ; Send service call
                jsr makeROMServiceCall
                plx
                cpx #romServiceCallVectorsClaimed ; If VectorsClaimed,
                                                  ; hook FileSwitch
                                                  ; back in
                beq handleVectorsClaimed
                inc a       ; If claimed, check for
                            ; InitialiseFilingSystem or
                            ; UnrecognisedCommand
                dec a       ;Z=1 if claimed
                beq wasClaimed  ;branch taken if claimed
done:
                plx             ; Return with result in X, EQ=Claimed
                tax
                rts

wasClaimed:
                cpx #romServiceCallInitialiseFilingSystem
                beq +
                cpx #romServiceCallUnrecognisedCommand
                bne done                    ; EE1A= D0 F5       Pu
+

; handle InitialiseFilingSystem ($12) or UnrecognisedCommand ($04)
                
                ply                     ;Y=service call arg
                pha                     ;save A (though actually it's
                                        ;always $00...)
                lda ACCCON
                pha                     ;save ACCCON
                jsr selectHAZEL
                sec
                ror hazel.currentFS ;set currentFS bit 7
LEE29:
                phy             ;save ROM service call argument
                lda #$00                     
                tay                          
                jsr callARGSV   ;A=0, Y=0 - get active FS number
                sta hazel.activeFS ;save active FS number
                bit hazel.currentFS
                bpl LEE3B
                jsr osbyte6D
LEE3B:
                ply                          ; EE3B= 7A          z
                pla                          ; EE3C= 68          h
                jsr selectMOSOrHAZEL
                pla                          ; EE40= 68          h
                tax                          ; EE41= AA          *
                rts                          ; EE42= 60          `

handleVectorsClaimed:
                ply                          ; EE43= 7A          z
                pha                          ; EE44= 48          H
                lda ACCCON                    ; EE45= AD 34 FE    -4~
                pha                          ; EE48= 48          H
                jsr selectHAZEL                    ; EE49= 20 BA ED     :m
                lda FSCV+0
                sta hazel.activeFSCV+0
                lda FSCV+1
                sta hazel.activeFSCV+1
                lda #<fileswitchFSCEntryPoint
                sta FSCV+0
                lda #>fileswitchFSCEntryPoint          
                sta FSCV+1
                bra LEE29                    ; EE62= 80 C5       .E
                .pend

;-------------------------------------------------------------------------

LEE64:
                lda #$A1                     ; EE64= A9 A1       )!
                sta $E3                      ; EE66= 85 E3       .c
                lda #$19                     ; EE68= A9 19       ).
                sta $03D1                    ; EE6A= 8D D1 03    .Q.
                lda #$04                     ; EE6D= A9 04       ).
                tsb $E2                      ; EE6F= 04 E2       .b
                rts                          ; EE71= 60          `
                
;-------------------------------------------------------------------------
; 
; Pass service call around sideways ROMs
;
; Entry:
; X=service call number
; Y=any parameters
;
; Exit:
; X=0 or preserved
; Y=any returned parameters
; EQ=call claimed if called directly
;
makeROMServiceCall: .proc                    ;ee72
                lda $F4         ; Save current ROM
                pha
                lda ACCCON      ; Save current paging state
                pha
                jsr selectHAZEL ; Page in Hazel
                txa             ; Pass service call number to A
                ldx #$0F     ; Start at ROM 15, and always call ROM 15
                bra callServiceEntry
callServiceEntriesLoop:
                bit romInformationTable,x ;check if ROM X has a service entry
                bpl nextROM       ;branch taken if no service entry
callServiceEntry:
                jsr selectROMX  ; Page in ROM X
                jsr $8003       ; Call ROM service entry point
                tax             ; X = service call result
                beq done       ;branch taken if service call claimed
                ldx $F4         ; Get ROM number
nextROM:
                dex       ; Step down to next ROM, loop until all done
                bpl callServiceEntriesLoop

done:
                pla                          ; Restore paging state
                jsr selectMOSOrHAZEL
                pla                          ; Restore current ROM
                jsr selectROMA
                txa                          ; Pass claim/noclaim to A
                rts
                .pend

;-------------------------------------------------------------------------

; OSBYTE &6B (107) - Select memory for direct access
; ==============================================
osbyte6B:                       ;ee9e
                ldy #$20                     ; Y=&20 to change 1MHz bit
                bra LEEA4

;-------------------------------------------------------------------------

; OSBYTE &6C (108) - Select memory for direct access
; ==============================================
osbyte6C:
                ldy #ACCCON.X                ; Y=&04 to change RAM bit
LEEA4:
                tya                          ; Clear RAM or 1MHz bit
                trb ACCCON
                txa                          ; If X=0, exit with normal RAM/1MHz selected
                beq LEEB0
                .if version==350
                tya
                .else
                lda #ACCCON.X                ; BUG! This should be TYA
                .endif
                tsb ACCCON                   ; Page in shadow RAM
LEEB0:
                rts                          ; X preserved, Y=&04 or &20

;-------------------------------------------------------------------------

osword06Macro: .macro
                jsr getAddressFromOSWORDParameterBlock
                lda (originalX),y
                sta (SEIWKA)
ret:
                lda #$00
                rts
                .endmacro

LEF1BMacro: .macro
                lda $EB
                bmi osword06.ret
                lda spoolFileHandle
                bne osword06.ret
                lda #$08        
                and $E2         
                bne LEF2E       
                lda #$88        
                and $BB         
LEF2E:
                rts                          ; EF2E= 60          `
                .endmacro

;-------------------------------------------------------------------------

                .if version>=350
osword06: .osword06Macro
LEF1B: .LEF1BMacro
                .endif

;-------------------------------------------------------------------------

                .if version>=500
oswordEntryPoint:
                pha
                php
                sei
                sta originalA
                stx originalX
                sty originalY
                ldx #romServiceCallUnrecognisedOSWORD
                cmp #$e0
                bcs osbyteOrUSERV
                cmp #$10
                bcc LEF76
                cmp #$44
                bcs LEF71
                cmp #$42
                bcs LEF74
                sec
                
LEF71:
                jmp handleUnrecognisedOSBYTEOrOSWORD

LEF74:
                .if version<500
                sbc #$34                     ; :(
                .elsif version>=500
                sbc #$33
                .endif

LEF76:
                adc #$59                     ; :(
                asl a
                bra callOSBYTEOrOSWORDFromTable
                .endif
                
;-------------------------------------------------------------------------

                .if version>=350
osword0E:
                cmp #3
                bcs handleUnrecognisedOSWORD
                jsr withTerminalROM
                jmp terminal.osword0E
                .endif

;-------------------------------------------------------------------------

                .if version>=500||version==350
LEF85:
                plp
                pla
                bit valueFF
                rts
                .endif
                
;-------------------------------------------------------------------------

                
; OSBYTE
; ======
osbyteEntryPoint:
                pha
                php
                sei
                sta originalA
                stx originalX
                sty originalY
                ldx #romServiceCallUnrecognisedOSBYTE
                cmp #$6B                     
                bcc osbyte00To6A
                cmp #$A6
                bcc osbyte6BToA5
                cmp #$A6
                bcc handleUnrecognisedOSBYTEOrOSWORD       ;??? - wait... didn't we just do this?

osbyteA6ToFF:
                clc
osbyteOrUSERV:      ;call OSBYTE A6+ routine if C=0; call USERV if C=1
                lda #$A6
                adc #$00
                .if version<350
osbyte6BToA5:
                sbc #$50        ;map $6b-$a5 to $1b-$56
                .elsif version>=350
osbyte6BToA5:
                sbc #$24
LEFA9:
                sbc #$2A
                .endif
osbyteUseTable:
                asl a           ;table is of words
                sec
callOSBYTEOrOSWORDFromTable:
                sty originalY
                tay             ;get table offset in Y
                bit econetInterceptionStatus
                bpl LEEE0             ;taken if no Econet interception
                txa
                .cerror (netOSBYTEAttempted!=romServiceCallUnrecognisedOSBYTE),"net/rom reason codes mismatch"
                .cerror (netOSWORDAttempted!=romServiceCallUnrecognisedOSWORD),"net/rom reason codes mismatch"
                clv
                jsr callNETV
                bvs LEEFA
LEEE0:
                .if version>=500
                lda $f4
                pha
                jsr selectTerminalROM
                .elsif version==350
                ldx $f4
                jsr selectTerminalROM
                .endif
                .if version==350
                lda osbyteAndOSWORDRoutineTable,y
                sta SEIWKA
                lda osbyteAndOSWORDRoutineTable+1,y
                sta SEIWKB
                .else
                lda osbyteAndOSWORDRoutineTable+1,y
                sta SEIWKB
                lda osbyteAndOSWORDRoutineTable,y
                sta SEIWKA
                .endif
                .if version>=500
                plx
                jsr selectROMX
                .elsif version==350
                jsr selectROMX
                and #$40
                tax
                .endif
                lda originalA
                ldy originalY
                bcs +
                ldy #$00            ;??? - is this actually desirable?
                lda ($F0)           ;fetch 0th byte of parameter block
+
                sec
                .if version==350
                jsr LF198
                .else
                ldx originalX

; on entry to the OSBYTE handlers, C=1, N/Z set as per X.
                
                jsr callSEIWKA
                .endif
LEEFA:
                ror a                        ; EEFA= 6A          j
                plp                          ; EEFB= 28          (
                rol a                        ; EEFC= 2A          *
                pla                          ; EEFD= 68          h
                clv                          ; EEFE= B8          8
                rts                          ; EEFF= 60          `

osbyte00To6A:
                ldy #$00        ;Y=0 on entry for this lot
                cmp #$1A        ;OSBYTE <=$19 is table-driven
                bcc osbyteUseTable ;taken if OSBYTE $00-$19
                .if version>=350
                cmp #$44
                beq LEFA9
                cmp #$45
                beq LEFA9
                .endif
                bra handleUnrecognisedOSBYTEOrOSWORD       

handleUnrecognisedOSWORD:
                ldx #romServiceCallUnrecognisedOSWORD
                pla
                pla
handleUnrecognisedOSBYTEOrOSWORD:
                jsr makeROMServiceCall
                .if version<500&&version!=350
                bne LEF15
                .else
                bne LEF85
                .endif
                ldx originalX
                bra LEEFA
                .if version<500&&version!=350
LEF15:
                plp
                pla
                bit valueFF
                rts
                .endif

;-------------------------------------------------------------------------

                .if version<350
LEF1B: .LEF1BMacro
                .endif

;-------------------------------------------------------------------------
;
; OSWORD 14 (&0E) Read CMOS clock [MasRef D.3-22]
;
                .if version<350
osword0E:
                cmp #$03                   ;only codes 0/1/2 are valid
                bcs handleUnrecognisedOSWORD
                jsr withTerminalROM
                jmp terminal.osword0E
                .endif
                
;-------------------------------------------------------------------------
;
; Entry point for OSWORD.
;
; D.3-3
;
                .if version<500
oswordEntryPoint:
                pha             ;save OSWORD request
                php
                sei
                sta originalA
                stx originalX
                sty originalY
                ldx #romServiceCallUnrecognisedOSWORD
                cmp #$E0
                bcs osbyteOrUSERV ;taken if OSWORD $E0 or higher -
                                  ;these go via USERV

                .if version<350
                cmp #16
                bcs handleUnrecognisedOSBYTEOrOSWORD ;taken if unknown OSWORD

; adjust request number so it's a suitable index into the
; OSBYTE/OSWORD routine table.
                
                adc #(oswordRoutineTable-osbyteAndOSWORDRoutineTable)/2
                asl a
                bra callOSBYTEOrOSWORDFromTable
                
                .else

                cmp #16
                bcc LED4D
                cmp #$44
                bcs handleUnrecognisedOSBYTEOrOSWORD
                cmp #$42
                bcs LED4B
                sec
                bra handleUnrecognisedOSBYTEOrOSWORD

LED4B:
                sbc #$33
LED4D:
                adc #$59
                asl a
                bra callOSBYTEOrOSWORDFromTable
                .endif
                .endif
                
;-------------------------------------------------------------------------
;
; OSWORD 5 (&05) Read byte from I/O processor memory [MasRef D.3-9]
; 
osword05:
                jsr getAddressFromOSWORDParameterBlock
                lda (SEIWKA)                 ;read byte from the address
                sta (originalX),y                  ;update parameter block
                rts                            

;-------------------------------------------------------------------------
;
; OSWORD 6 (&06) Write byte to I/O processor memory [MasRef D.3-9]
;

                .if version<350
osword06: .osword06Macro
                .endif

;-------------------------------------------------------------------------
;
; Get address from OSWORD parameter block.
;
; entry:
;
; A = 0th byte of parameter block
;
; Y = 0
; 
; (originalX) = parameter block
;
; exit:
;
; (SEIWKA) = address, first two bytes from parameter block
;
; Y = 4 (this is just convenient for both callers)
; 
getAddressFromOSWORDParameterBlock:
                sta SEIWKA
                iny
                lda (originalX),y
                sta SEIWKA+1
                ldy #$04
ldxim03_rts:
                .if version<400
                ldx #$03
                .elsif version<500
                ldx #$04
                .else
                ldx #$05
                .endif
                rts
                
;-------------------------------------------------------------------------
; 
; OSBYTE 0 (&00) Display MOS version
;
; OSBYTE 0 has the effect of performing a BRK instruction and
; displaying the MOS version number.
;
; Entry parameters :
;
; X=0 executes a BRK and displays the OS version
;
; X=1 executes an RTS and returns the Operating system version
;
; On exit : X=<OS version>
;
; D.2-18
;
osbyte00:                       ;ef6f
                bne ldxim03_rts ;branch taken if X<>0 - return with
                                 ;X=3

; do a BRK and print MOS version number.
                
                brk                          
                .byte $f7
                .if version==320
                .text "OS 3.20"
                .elsif version==400
                .text "MOS 4.00"
                .elsif version==500
                .text "MOS 5.00"
                .elsif version==510
                .if olivetti
                .text "MOS I5.10C"
                .else
                .text "MOS 5.10"
                .endif
                .elsif version==511
                .if autocue
                .text "MOS 5.10i"
                .else
                .text "MOS 5.11i"
                .endif
                .elsif version==350
                .if CFA3000
                .text "MOS 3.5a"
                .elsif finmos329
                .text "MOS 3.29"
                .else
                .text "MOS 3.50"
                .endif
                .endif
                .byte 0

;-------------------------------------------------------------------------
;
; OSWORD 7 (&07) Generate a sound [MasRef D.3-10]
; 
osword07:
                iny                          ; EF7B= C8          H
                lda ($F0),y                  ; EF7C= B1 F0       1p
                cmp #$20                     ; EF7E= C9 20       I
                bcs handleUnrecognisedOSWORD
                dey                          ; EF82= 88          .
                jsr LEFF6                    ; EF83= 20 F6 EF     vo
                ora #$04                     ; EF86= 09 04       ..
                tax                          ; EF88= AA          *
                bcc LEF90                    ; EF89= 90 05       ..
                jsr LE95A                    ; EF8B= 20 5A E9     Zi
                ldy #$01                     ; EF8E= A0 01        .
LEF90:
                jsr LEFF6                    ; EF90= 20 F6 EF     vo
                sta $FA                      ; EF93= 85 FA       .z
                php                          ; EF95= 08          .
                ldy #$06                     ; EF96= A0 06        .
                lda ($F0),y                  ; EF98= B1 F0       1p
                pha                          ; EF9A= 48          H
                ldy #$04                     ; EF9B= A0 04        .
                lda ($F0),y                  ; EF9D= B1 F0       1p
                pha                          ; EF9F= 48          H
                ldy #$02                     ; EFA0= A0 02        .
                lda ($F0),y                  ; EFA2= B1 F0       1p
                rol a                        ; EFA4= 2A          *
                dec a                        ; EFA5= 3A          :
                dec a                        ; EFA6= 3A          :
                asl a                        ; EFA7= 0A          .
                asl a                        ; EFA8= 0A          .
                ora $FA                      ; EFA9= 05 FA       .z
                jsr LE9A3                    ; EFAB= 20 A3 E9     #i
                bcc LEFCE                    ; EFAE= 90 1E       ..
                pla                          ; EFB0= 68          h
                pla                          ; EFB1= 68          h
                plp                          ; EFB2= 28          (

                ; WTF... fall through to OSBYTE $75!

;-------------------------------------------------------------------------
;
; OSBYTE 117 (&75) Read VDU status [MasRef D.2-32]
;
osbyte75:
                ldx STATE
                rts

;-------------------------------------------------------------------------
;
; VDU 7 (&07) Produce BELL sound [MasRef E.3-4]
; 
vdu7EntryPoint:
                php
                sei
                lda bellChannel
                and #$07                     ; EFBB= 29 07       ).
                ora #$04                     ; EFBD= 09 04       ..
                tax                          ; EFBF= AA          *
                lda bellSound
                jsr callINSV                    ; EFC3= 20 40 EA     @j
                lda bellDuration
                pha                          ; EFC9= 48          H
                lda bellFrequency
                pha                          ; EFCD= 48          H
LEFCE:
                sec                          ; EFCE= 38          8
                ror $0800,x                  ; EFCF= 7E 00 08    ~..
                pla                          ; EFD2= 68          h
                jsr callINSV                    ; EFD3= 20 40 EA     @j
                pla                          ; EFD6= 68          h
                jsr callINSV                    ; EFD7= 20 40 EA     @j
                plp                          ; EFDA= 28          (
                rts                          ; EFDB= 60          `

;-------------------------------------------------------------------------
;
; OSWORD 8 (&08) Define a sound envelope [MasRef D.3-14]
; 
osword08:
                dec a                   ;get index of 1-based envelope
                asl a                        
                asl a                        
                asl a                        
                asl a                        ;index*16
                ora #$0F                     ;index*16+15
                tax                          ;
                lda #$00                     ;
                ldy #16             ;16 bytes of envelope data get set
-
                cpy #$0E                     ;
                bcs + ;taken if last 2 bytes of data - they get initialized to $00
                lda (originalX),y        ;fetch byte from OSWORD block
+
                sta envelope1Data,x          ;set envelope data bytes
                dex                          
                dey                          
                bne -
                rts                          

;-------------------------------------------------------------------------

LEFF6:
                lda ($F0),y                  ; EFF6= B1 F0       1p
                cmp #$10                     ; EFF8= C9 10       I.
                and #$03                     ; EFFA= 29 03       ).
                iny                          ; EFFC= C8          H
                rts                          ; EFFD= 60          `

;-------------------------------------------------------------------------
;
; OSWORD 3 (&03) Read interval timer [MasRef D.3-8]
; 
osword03:
                ldx #$0F                     ; EFFE= A2 0F       ".
                bra LF005                    ; F000= 80 03       ..

;-------------------------------------------------------------------------
;
; OSWORD 1 (&01) Read system clock [MasRef D.3-7]
; 
osword01:
                ldx timerSwitchState
LF005:
                ldy #$04
-
                lda timer0-initialTimerSwitchState,x
                sta (originalX),y
                inx
                dey
                bpl -
rtsF010:
                rts                          ; F010= 60          `

;-------------------------------------------------------------------------
;
; OSWORD 4 (&04) Write interval timer [MasRef D.3-9]
; 
osword04:
                lda #intervalTimer-(timer0-initialTimerSwitchState)
                bra copyTIMEValue

;-------------------------------------------------------------------------
;
; OSWORD 2 (&02) Write system clock [MasRef D.3-8]
; 
osword02:
                lda timerSwitchState
                eor #$0F       ;select the timer that isn't being used
                clc
copyTIMEValue:
                pha
                tax
                ldy #$04
-
                lda (originalX),y
                sta timer0-initialTimerSwitchState,x
                inx
                dey
                bpl -
                pla
                bcs rtsF010
                sta timerSwitchState
                rts

;-------------------------------------------------------------------------
;
; OSWORD 0 (&00) Read line from input stream to memory [MasRef D.3-6]
; 
osword00:
                ldy #$04
LF031:
                lda (originalX),y
                .cerror osword0MaxLineLength+1!=osword0MinASCIICharacter
                .cerror osword0MinASCIICharacter+1!=osword0MaxASCIICharacter
                sta osword0MaxLineLength-2,y
                dey
                cpy #$02
                bcs LF031
                lda ($F0),y
                sta $E9
                dey
                stz pagedModeCounter
                lda ($F0)
                sta $E8
                cli
                bra LF051

LF04A:
                lda #$07
LF04C:
                dey
LF04D:
                iny
LF04E:
                jsr OSWRCH
LF051:
                jsr OSRDCH
                bcs LF09F
                tax
                lda characterDestinationStatus
                ror a
                ror a
                txa
                bcs LF064
                ldx vduQueueNegativeLength
                bne LF04E
LF064:
                cmp #$7F
                bne LF06F
                cpy #$00
                beq LF051
                dey
                bra LF04E

LF06F:
                cmp #$15
                bne LF080
                tya
                beq LF051
                lda #$7F
LF078:
                jsr OSWRCH
                dey
                bne LF078
                bra LF051

LF080:
                sta ($E8),y
                cmp #$0D
                beq LF099
                cpy osword0MaxLineLength
                bcs LF04A
                cmp osword0MinASCIICharacter
                bcc LF04C
                cmp osword0MaxASCIICharacter
                beq LF04D
                bcc LF04D
                bra LF04C

LF099:
                jsr OSNEWL
                jsr callNETV
LF09F:
                lda $FF
                rol a
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 3 (&03) Specify output stream [MasRef D.2-19]
; 
osbyte03:
                phx
                ldx characterDestinationStatus
                lda #printerDriverFX3
                jsr callPrinterDriver
                plx
                lda #$03
                ldy #$00
                bra osbyte04

;-------------------------------------------------------------------------
;
; OSBYTE 6 (&06) Write printer ignore character [MasRef D.2-21]
;
osbyte06:                       ;f0b3
                lsr noignoreState
                bra osbyte01

;-------------------------------------------------------------------------
;
; OSBYTE 114 (&72) Write usage of shadow memory [MasRef D.2-32]
;
osbyte72:                       ;f0b8
                lda #$1F
                bra LF0CC

;-------------------------------------------------------------------------
;
; OSBYTE 5 (&05) Write printer driver type [MasRef D.2-20]
;
osbyte05:
waitForPrinterDriverDormant:
                cli
                sei
                bit $FF                      ;test for ESCAPE
                bmi rtsF0EB                  ;taken if ESCAPE pressed
                bit bufferEmptyFlags+bufferPrinter
                bpl waitForPrinterDriverDormant ;taken if printer driver active
                jsr callPrinterDriver    ;call with A=printerDriverFX5
                ldy #$00
LF0CC:
                stz $F1

                ; fall through to standard MOS variable handling,
                ; affecting printerDriverType

;-------------------------------------------------------------------------
;
; OSBYTE 1 (&01) Write user flag [MasRef D.2-18]
;                 
osbyte01:                       
                eor #firstMOSVariableOSBYTE+(userFlag-mosVariables)-1 ;-1 because OSBYTE 1
                bra osbyteA6X  ;jump to standard MOS variable handling

;-------------------------------------------------------------------------
;
; OSBYTE 12 (&0C) Write keyboard auto-repeat rate [MasRef D.2-23]
; 
osbyte0C:
                beq resetKeyRepeat    ;taken if X=0
                
;-------------------------------------------------------------------------
;
; OSBYTE 11 (&0B) Write keyboard auto-repeat delay [MasRef D.2-22]
;
osbyte0B:
                ; TODO - turn this constant into an expression
                adc #$CF

                ;if osbyte0C, A=$db
                ;if osbyteOD, A=$dc

;-------------------------------------------------------------------------
;
; OSBYTE 4 (&04) Enable/disable cursor editing [MasRef D.2-19]
;
osbyte04:
                clc
                adc #firstMOSVariableOSBYTE+(editKeysMode-mosVariables)-4 ;-4 because OSBYTE 4

                ;if originally OSBYTE 4 (&04) Enable/disable cursor
                ;editing [MasRef D.2-19], it's now OSBYTE 237 (&ED)
                ;Read/write cursor editing status [MasRef D.2-77].
                ; 
                ;if originally OSBYTE 12 (&0C) Write keyboard
                ;auto-repeat rate [MasRef D.2-23], it's now OSBYTE 197
                ;(&C5) Read/write keyboard auto-repeat rate [MasRef
                ;D.2-60].
                ;
                ;if originally OSBYTE 11 (&0B) Write keyboard
                ;auto-repeat delay [MasRef D.2-22], it's now OSBYTE
                ;196 (&C4) Read/write keyboard auto-repeat delay
                ;[MasRef D.2-60].
                
osbyteA6X:
                stx originalX

;-------------------------------------------------------------------------
;
; OSBYTE 166 (&A6) Read start address of MOS variables [MasRef D.2-50]
; 
osbyteA6:
                tay             ;
                lda mosVariables-firstMOSVariableOSBYTE,y;
                tax             ;save old value
                and originalY   ;AND old value with Y
                eor originalX   ;EOR old value with X
                sta mosVariables-firstMOSVariableOSBYTE,y     ;set new variable value
                lda mosVariables-firstMOSVariableOSBYTE+1,y
                tay             ;Y=contents of next location
rtsF0EB:
                rts                          ; F0EB= 60          `

;-------------------------------------------------------------------------
;
; This table is used to set the serial baud rate.
;
;   - bit 7 is not used (always clear)
;   - bit 6 is not used (always set)
;   - bits 3,4,5 indicate the serial receive baud rate
;   - bits 0,1,2 indicate the serial transmit baud rate
;
;       111 =    75 baud
;       011 =   150 baud
;       101 =   300 baud
;       001 =  1200 baud
;       110 =  2400 baud
;       010 =  4800 baud
;       100 =  9600 baud
;       000 = 19200 baud
;
                .if version!=400                
serialBaudRatesTable:
                .byte %01100100;$64
                .byte %01111111;$7f
                .byte %01011011;$5b
                .byte %01101101;$6d
                .byte %01001001;$49
                .byte %01110110;$76
                .byte %01010010;$52
                .byte %01100100;$64
                .byte %01000000;$40
                .endif
                
;-------------------------------------------------------------------------
;
; OSBYTE 19 (&13) Wait for vertical sync [MasRef D.2-26]
; 
osbyte13:
                lda cfsTimeoutCounter
-
                cli
                sei
                cmp cfsTimeoutCounter
                beq -

                ; fall through to OSBYTE $a0 (!!)

;-------------------------------------------------------------------------
;
; OSBYTE 160 (&A0) Read VDU variable value [MasRef D.2-49]
; 
osbyteA0:
                ldy vduv+1,x
                lda vduv+0,x
                tax
                rts

;-------------------------------------------------------------------------
;
; Reset key auto repeat settings to the defaults set in CMOS.
; 
                .if version==350
setTSTAndResetKeyRepeat:
                jsr callWithTST
                .endif
resetKeyRepeat:
                jsr withTerminalROM
                .if version<500&&version!=350
                jsr terminal.getDefaultKeyboardAutoRepeatDelay
                sty keyboardAutoRepeatDelay
                jsr terminal.getDefaultKeyboardAutoRepeatRate
                .else
                ldx #CMOSBytes.keyboardAutoRepeatDelay+cmosBytesOffset
                jsr terminal.readRTCByte
                sta keyboardAutoRepeatDelay
                ldx #CMOSBytes.keyboardAutoRepeatRate+cmosBytesOffset
                jsr terminal.readRTCByte
                tay
                .endif
                ldx keyboardAutoRepeatRate
                sty keyboardAutoRepeatRate
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 18 (&12) Reset soft keys [MasRef D.2-26]
;
; MasRef says X undefined on exit; in fact, X=0, and terminal.scanROMs
; relies on this.
; 
osbyte12:                                    
                sec
                ror softKeyConsistencyFlag   ;mark soft keys inconsistent
                lda $F4
                pha                          ;push selected paged ROM
                jsr selectTerminalROMAndANDY

                ; point each soft key at the 0th byte of the strings -
                ; they all then have length 0.
                ldx #softKeyCount
-
                lda #<andy.softKeys.strings
                sta andy.softKeys.stringLSBs,x
                lda #>andy.softKeys.strings
                sta andy.softKeys.stringMSBs,x
                dex
                bpl -
                
                pla                 ;pop previously selected paged ROM
                jsr selectROMA
                
                stz softKeyStringLength
                stz softKeyConsistencyFlag   ;mark soft keys consistent
                inx
                rts

;-------------------------------------------------------------------------
;
; OSWORD 11 (&0B) Read the palette [MasRef D.3-20]
; 
osword0B:
                and vduv.numberOfLogicalColoursMinusOne
                tax
                lda vduv.currentPalette,x
LF146:
                iny
LF147:
                sta (originalX),y
                lda #$00                     ;fill last 3 bytes with 0
                cpy #$04
                bne LF146
                rts

;-------------------------------------------------------------------------
;
; OSWORD 9 (&09) Read pixel logical colour [MasRef D.3-19]
; 
osword09:                                    ;f150
                jsr withMOSROM               ; sF150= 20 AB F3     +s
                ldy #$03                     ; F153= A0 03        .
-
                lda (originalX),y
                sta vduv.workspace._28,y
                lda $0310,y                  ; F15A= B9 10 03    9..
                pha                          ; F15D= 48          H
                dey                          ; F15E= 88          .
                bpl -
                lda #VDUVariables.workspace._28
                jsr readPixelColour
                tax                          ; F166= AA          *
                ldy #$00                     ; F167= A0 00        .
LF169:
                pla                          ; F169= 68          h
                sta $0310,y                  ; F16A= 99 10 03    ...
                iny                          ; F16D= C8          H
                cpy #$04                     ; F16E= C0 04       @.
                bne LF169                    ; F170= D0 F7       Pw
                txa                          ; F172= 8A          .
                bra LF147                    ; F173= 80 D2       .R

osword0A:                                    ;f175
                jsr getSoftCharacterDefinitionAddress                    ; F175= 20 2C E2     ,b
                ldy #$00                     ; F178= A0 00        .
                lda $F4                      ; F17A= A5 F4       %t
                pha                          ; F17C= 48          H
                jsr selectTerminalROMAndANDY                    ; F17D= 20 7F E5     .e
LF180:
                lda ($DE),y                  ; F180= B1 DE       1^
                iny                          ; F182= C8          H
                sta ($F0),y                  ; F183= 91 F0       .p
                cpy #$08                     ; F185= C0 08       @.
                bne LF180                    ; F187= D0 F7       Pw
                plx                          ; F189= FA          z
                jmp selectROMX                    ; F18A= 4C 81 E5    L.e

osword0C:                                    ;f18d
                jsr withMOSROM               ; F18D= 20 AB F3     +s
                php                          ; F190= 08          .
                and $0360                    ; F191= 2D 60 03    -`.
                tax                          ; F194= AA          *
                iny                          ; F195= C8          H
                lda ($F0),y                  ; F196= B1 F0       1p
                jmp LC639                    ; F198= 4C 39 C6    L9F

osword0D:                                    ;f19b
                jsr withMOSROM               ; F19B= 20 AB F3     +s
                lda #$03                     ; F19E= A9 03       ).
                jsr LF1A5                    ; F1A0= 20 A5 F1     %q
                lda #$07                     ; F1A3= A9 07       ).
LF1A5:
                pha                          ; F1A5= 48          H
                jsr LE2B6                    ; F1A6= 20 B6 E2     6b
                jsr LC4DF                    ; F1A9= 20 DF C4     _D
                ldx #$03                     ; F1AC= A2 03       ".
                pla                          ; F1AE= 68          h
                tay                          ; F1AF= A8          (
LF1B0:
                lda $0310,x                  ; F1B0= BD 10 03    =..
                sta ($F0),y                  ; F1B3= 91 F0       .p
                dey                          ; F1B5= 88          .
                dex                          ; F1B6= CA          J
                bpl LF1B0                    ; F1B7= 10 F7       .w
                rts                          ; F1B9= 60          `

; Read address of bottom of screen/top of user memory
; ===================================================
osbyte84:                     ;f1ba
                lda STATE     ; Get VDU status
                bit #STATE.isShadowMode ; If shadow screen, jump to return &8000
                bne LF1D8
LF1C0:
                lda $0355                    ; Get current screen MODE

; Return start of screen for non-shadow MODE in X
; -----------------------------------------------
LF1C3:
                and #$07
                tay
                ldx screenMODEGroupForMODE,y ; Get screen map for supplied MODE
                lda startScreenAddressHighByteForScreenMODEGroup,x ; Get address top byte for this screen map
LF1CC:
                ldx #$00                     ; Address=&xx00
                tay
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 133 (&85) Read top of user RAM for given mode [MasRef D.2-41]
; 
osbyte85:
                txa                          ; If MODE &80+n, return &8000
                bmi LF1D8
                ldx shadowRAMState ; If *SHADOW<>0, jump to return non-shadow address
                bne LF1C3
LF1D8:
                lda #$80                     ; Return &8000
                bra LF1CC

;-------------------------------------------------------------------------
;
; OSBYTE 135 (&87) Read screen mode and character at text cursor
; position [MasRef D.2-42]
; 
osbyte87: ;F1DC:
                jsr withMOSROM
                jmp readCharacterAtTextCursor     

;-------------------------------------------------------------------------
;
; OSBYTE 139 (&8B) Write Filing System options [MasRef D.2-43]
; 
osbyte8B:
                asl a

;-------------------------------------------------------------------------
;
; OSBYTE 127 (&7F) Check for end of file on an opened file [MasRef D.2-37]
; 
osbyte7F:
                and #$01

;-------------------------------------------------------------------------
;
; Call OSFSC. There's no entry point for this.
; 
callFSCV:
                jmp (FSCV)

;-------------------------------------------------------------------------
;
; OSWORD 15 (&0F) Write CMOS clock [MasRef D.3-24]
;
                .if version!=350
osword0F:
                jsr withTerminalROM       ; Page in ROM 15
                jmp terminal.osword0F
                .endif
                
;-------------------------------------------------------------------------

; Set TAPE/ROM extended vectors
; =============================
LF1EE:
                ldx #$15
LF1F0:
                lda LF1FA-1,x
                sta ExtendedVectorAddress(FILEV)-1,x
                dex
                bne LF1F0
LF1F9:
                rts

; TAPE/ROM extended vector values
; -------------------------------
LF1FA:
                .word terminal.osfileTapeOrROM ; FILEV
                .byte terminalROM
                .word terminal.osargsTapeOrROM ; ARGSV
                .byte terminalROM
                .word terminal.bputTapeOrROM ; BPUTV
                .byte terminalROM
                .if version==400
                .word mos.badCommandError
                .else
                .word terminal.bgetTapeOrROM ; BGETV
                .endif
                .byte terminalROM
                .word terminal.osgbpbTapeOrROM ; GBPBV
                .byte terminalROM
                .word terminal.osfindTapeOrROM ; FINDV
                .byte terminalROM
                .word terminal.fscTapeOrROM  ; FSCV
                .byte terminalROM

;-------------------------------------------------------------------------
;
; OSBYTE 109 (&6D) Make temporary Filing System permanent
;
; MasRef D.2-30
; 
osbyte6D:;f20f
                ldx hazel.activeFS; Copy active FS to current FS
                stx hazel.currentFS
                lda ExtendedVectorAddress(FILEV)+2 ; Copy XFILEV ROM to current FS ROM number
                sta hazel.currentFSROM
rtsF180:
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 20 (&14) Restore default font definitions
;
; MasRef D.2-24
; 
                .if version!=350
osbyte14:                       ;f21c
                jsr withTerminalROM
                jmp terminal.restoreFont32To126
                .endif
                
;-------------------------------------------------------------------------
;
; OSBYTE 25 (&19) Restore a group of font definitions
;
; MasRef D.2-28
;
osbyte19:                       ;f222
                .if version>=511||version==350
                ldx #romServiceCallUnrecognisedOSBYTE
                jsr makeROMServiceCall
                .if version==350
                beq rtsF180
                .else
                beq LF2EB
                .endif
                ldx originalX
                .endif
                jsr withTerminalROM
                jmp terminal.osbyte19

;-------------------------------------------------------------------------

; OSBYTE &16 - Increment ROM polling semaphore
; ========================================
osbyte16:                       ;f228
                inc romPollingSemaphore
LF2EB:
                rts

;-------------------------------------------------------------------------

; OSBYTE &17 - Decrement ROM polling semaphore
osbyte17:                       ;f22c
; ========================================
                dec romPollingSemaphore
                rts

;-------------------------------------------------------------------------

                .if version==350
LF198:
                dex
                bpl LF19E
                jsr withTerminalROM
LF19E:
                ldx originalX
                jmp (SEIWKA)
                .endif
                
;-------------------------------------------------------------------------

; OSBYTE &76 - Set LEDs to keyboard state
; =======================================
osbyte76:
                php                          ; Disable IRQs
                sei
                lda #$40                     ; Turn on LEDs
                jsr LF241
                bmi LF23E                    ; Exit if Escape pending
                clc                          ; Call KEYV to read SHIFT and CTRL
                clv
                jsr callKEYV
; Returns A.b7=CTRL, A.b6=SHIFT, MI=CTRL, VS=SHIFT
LF23E:
                plp                          ; Restore IRQs
                rol a                        ; Set Carry from A bit 7 and return
                rts
; Returns A.b7=SHIFT, CS=CTRL

; Set keyboard LEDs
; -----------------
LF241:
                bcc LF24C                    ; Skip if not called from OSBYTE
                ldy #$07                     ; Turn ShiftLock LED on
                sty systemVIA.orb
                dey                          ; Turn CapsLock LED on
                sty systemVIA.orb
LF24C:
                bit $FF                      ; Test Escape and return
                rts

;-------------------------------------------------------------------------

osbyte9A:
                txa
setVCONTROL:
                php
                sei
                sta vcontrolRegister
                sta VCONTROL
                lda secondFlashColourDuration
                sta flashCounter
                plp
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 155 (&9B) Write to video ULA palette register and copy
;
osbyte9B:
                txa
writeVPALETTE:
                eor #$07
                php
                sei
                sta vpaletteRegister
                sta VPALETTE
                plp
                rts

;-------------------------------------------------------------------------

gsinitForFilenameParsing:
                clc


;-------------------------------------------------------------------------
;
; GSINIT
;
; MasRef D.10-1
; 
gsinitEntryPoint:
                ror stringInputOptions    ;put C into bit 7
                jsr skipSpacesAndCheckForCRInStringInput
                iny
                cmp #'"'
                beq +                       ; C=1 if double quotes
                dey
                clc                         ; clear double quotes flag
+
                ror stringInputOptions ; set doubleQuotes; move bit 7 into spaceNotATerminator
                cmp #$0D                     ; set Z if initial CR
                rts

;-------------------------------------------------------------------------
;
; GSREAD
;
; MasRef D.10-2
; MasRef C.5-8 has the | syntax
; 
gsreadEntryPoint:
                lda #stringInputOptions.goodString
                tsb stringInputOptions
                jsr LF29C                    ; F283= 20 9C F2     .r
                php                          ; save flags
                lsr stringInputOptions       ; move goodString into C
                bcc badStringError           ; branch taken if bad string
                rol stringInputOptions       ; reinstate goodString
                plp                          ; restore flags
                rts                          ;

badStringError:
                brk                          ; 
                .text $fd,"Bad string",0
LF29C:
                clc                          ; last char not !
LF29D:
                ; C=1 at this point if |! was the last sequence seen.
                stz stringInputPlingFlag
                ror stringInputPlingFlag     ; set ! flag as required
                lda (stringInputBufferAddress),y
                cmp #13                      ;EOL?
                bne notRETURN                ;taken if not EOL
                bit stringInputOptions
                bpl finishedString           ;taken if !doubleQuotes
badString:
                lda #stringInputOptions.goodString
                trb stringInputOptions
                rts

notRETURN:
                cmp #' '
                bcc badString ;taken if unprintable control char
                bne notSPACE
                bit stringInputOptions ;N=doubleQuotes, V=spaceNotATerminator
                bmi finishUpReadClearV ;taken if quoted
                bvc finishedString ;taken if space is a terminator
notSPACE:
                cmp #'"'
                bne notDOUBLEQUOTE         ;taken if not quotes
                bit stringInputOptions ;N=doubleQuotes, V=spaceNotATerminator
                bpl finishUpReadClearV ;taken if not double quotes
                iny
                lda (stringInputBufferAddress),y
                cmp #'"'
                beq finishUpReadClearV       ;taken if quotes
finishedString:
                jsr skipSpacesAndCheckForCRInStringInput
                sec
                rts

notDOUBLEQUOTE:
                cmp #'|'
                bne finishUpReadClearV       ;taken if not |
                iny                          ;skip |
                lda (stringInputBufferAddress),y
                cmp #'|'
                beq finishUpReadClearV ;branch taken if "||" - literal |
                cmp #'"'
                beq finishUpReadClearV ;branch taken if "|\"" - literal "
                cmp #'!'
                bne LF2E6                    ;taken if not "|!"

                ; Handle |! - ASCII 128-255
                iny                          ;skip !
                bra LF29D

LF2E6:
                cmp #' '
                bcc badString ;taken if | followed by a non-printable char
                cmp #'?'                     
                beq ascii127                 ;taken if "|?" - CHR$127
                jsr implementCTRLCodes       ; F2EE= 20 36 F3     6s
                bit valueFF                    ; F2F1= 2C 4E E3    ,Nc
                bra LF2F9                    ; F2F4= 80 03       ..

ascii127:
                lda #$7F
finishUpReadClearV:
                clv                          ; F2F8= B8          8
LF2F9:
                iny                          
                ora stringInputPlingFlag ;if it was a |! char, set bit 7
                clc
                rts

;-------------------------------------------------------------------------

incAndSkipSpaces:
                iny
skipSpacesAndCheckForCRInStringInput:
                lda (stringInputBufferAddress),y 
                cmp #' '             
                beq incAndSkipSpaces   
checkForCR:
                cmp #13         
                rts          

;-------------------------------------------------------------------------

LF308:
                bcc skipSpacesAndCheckForCRInStringInput
LF30A:
                jsr skipSpacesAndCheckForCRInStringInput
                cmp #','
                bne checkForCR
                iny
                rts

;-------------------------------------------------------------------------

                .if version==510&&olivetti

LF3C6o:
                ldx #0
LF3C8o:
                pha
                lda LF3F0o,x
                tay
                pla
                cpy #32
                beq LF3EAo
                inx
                cpy countryFlag
                bne LF3C8o

LF3D8o:
                pha
                lda LF3F0o,x
                tay
                pla
                cpy #33
                bcc LF3EAo
                cmp LF3F0o,x
                beq LF3EBo
                inx
                bra LF3D8o

LF3EAo:
                rts

LF3EBo:
                clv
                lda LF3F0o+1,x
                rts

LF3F0o:
                .byte $20
LF3F1o:
                ldx #$00
LF3F3o:
                pha
                lda LF41Bo,x
                tay
                pla
                cpy #32
                beq LF415o
                inx
                cpy countryFlag
                bne LF3F3o

LF403o:
                pha
                lda LF41Bo,x
                tay
                pla
                cpy #33
                bcc LF415o
                cmp LF41Bo,x
                beq LF416o
                inx
                bra LF403o

LF415o:
                rts

LF416o:
                clv
                lda LF424o,x
                rts

LF41Bo:
                .byte $04
                .byte $7b
                .byte $5b
                .byte $5e
                .byte $3b
                .byte $3a
                .byte $5d
                .byte $7d
                .byte $20
LF424o:
                .byte $04
                .byte $94
                .byte $8d
                .byte $97
                .byte $99
                .byte $8c
                .byte $9b
                .byte $9f
                .endif
                
;-------------------------------------------------------------------------
;
; Modify character in A as if the SHIFT key is being pressed.
;

implementShift:
                .if version<500&&version!=350
                
                cmp #'0'
                beq gotShiftedChar           ;taken if SHIFT+0 - no change
                cmp #$40
                beq gotShiftedChar           ;taken if SHIFT+@ - no change
                bcc shiftMaybeNumber ;taken if probably a "number" (ASCII 33-63)
                cmp #$7F
                beq gotShiftedChar  ;taken if SHIFT+DELETE - no change
                bcs shiftNumber     ;taken if SHIFT+CHR$>=127 - ???
flipBitsForShift:
                eor #$30                     ;
                cmp #$6F                     ;
                beq +                        ;taken if originally _
                cmp #$50                     ;
                bne shiftMaybeNumber         ;taken if not originally GBP
+
                eor #$1F                     ;extra step for GBP/_ toggle
shiftMaybeNumber:
                cmp #' '+1
                bcc gotShiftedChar         ;taken if non-printing char
shiftNumber:
                eor #$10                     ;
gotShiftedChar:
                rts                          ; F335= 60          `

                .else

                ldx #2
                bvc LF3C5
LF3C5:
                cmp LF3E7-1,x
                beq LF3E2
                dex
                bne LF3C5
                bvc LF3E1
                cmp #'!'
                bcc LF3E1
                cmp #'@'
                .if version==350
                beq LF3E1
                .endif
                bcc LF3DF
                cmp #$7f
                beq LF3E1
                bcs LF3DF

LF3DD:
                eor #$30
LF3DF:
                eor #$10
LF3E1:
                rts

LF3E2:
                clv
                lda LF3E9-1,x
                rts

LF3E7:
                .byte '_'
                .byte '0'
LF3E9:
                .byte '`'
                .if version==350
                .byte '0'
                .else
                .byte '@'
                .endif
                
                .endif

;-------------------------------------------------------------------------
;
; See MasRef C.5-8
;
; 
implementCTRLCodes:
                .if version<500&&version!=350
                
                cmp #$7F                     ; F336= C9 7F       I.
                beq gotCtrlChar
                bcs flipBitsForShift         ;taken if CHR$>=128
                cmp #$60
                bne +                        ;taken if not GBP
                lda #'_'                     ;GBP and _ are equivalent
+
                cmp #$40                     ;
                bcc gotCtrlChar              ;taken if CHR$<64
                and #$1F                     ;|@=0, |A=1, |a=1, etc.
gotCtrlChar:
                rts                          ; F348= 60          `

                .else

                phx
                ldx #2
LF3EE:
                cmp LF40A-1,x
                beq LF404
                dex
                bne LF3EE
                plx
                cmp #'?'
                bcc LF403
                cmp #$7f
                beq LF403
                bcs LF3DD
                and #$1f
LF403:
                rts

LF404:
                clv
                lda LF40C-1,x
                plx
                rts

LF40A:
                .text '0','@'
LF40C:
                .text 0,0

                .endif

;-------------------------------------------------------------------------

osbyte247EntryPoint:
                .if version==350
                jsr callWithTST
osbyte247EntryPointWithTST:
                .endif
                lda breakVectorByte0
                eor #$4C                     ; JMP abs
                bne rtsF363
                .if version==350
                jsr breakVectorByte0
                jmp selectTerminalROM
                .elsif version<500
                jmp breakVectorByte0
                .else
                lda $f4
                pha
                jsr breakVectorByte0
                pla
                sta $f4
                rts
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 144 (&90)
; Set vertical screen shift and interlace
;
; MasRef D.2-44
; 
osbyte90:
                lda tvOffset                    ; F353= AD 90 02    -..
                stx tvOffset                    ; F356= 8E 90 02    ...
                tax                          ; F359= AA          *
                tya                          ; F35A= 98          .
                and #$01                     ; F35B= 29 01       ).
                ldy tvInterlace                    ; F35D= AC 91 02    ,..
                sta tvInterlace                    ; F360= 8D 91 02    ...
rtsF363:
                rts                          ; F363= 60          `

;-------------------------------------------------------------------------
;
; OSBYTE 149 (&95) – write to JIM
;
; MasRef D.2-45
; 
osbyte95:
                tya
                sta $FD00,x
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 151 (&97) – write to SHEILA
;
; MasRef D.2-45
; 
osbyte97:
                tya
                sta $FE00,x
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 147 (&93) – write to FRED
;
; MasRef D.2-45
; 
osbyte93:
                tya
                sta $FC00,x
                rts

;-------------------------------------------------------------------------
;
; *SHUT [MasRef G.5-10]
; 
starSHUT:
                ldx #romServiceCallCloseAllOpenFiles 
                jmp makeROMServiceCall

;-------------------------------------------------------------------------
;
; Return thunk used by withTerminalROM.
;
; On entry here, the old value of $f4 is at the top of the stack.
; 
withTerminalROMReturnThunk:
                php                          ; S=[p; old ROMSEL]
                pha                          ; S=[a; p; old ROMSEL]
                phx                          ; S=[x; a; p; old ROMSEL]
                tsx
                lda $0104,x                  ; get old ROMSEL
                jsr selectROMA               ; re-select old ROM
                bra returnThunkSuffix

;-------------------------------------------------------------------------
;
; Select the Terminal ROM. Rearrange the stack so that the original
; ROM is re-selected when withTerminalROM's caller itself returns.
;
withTerminalROM:
                .if version==350
                jsr LF381
                lda $f4
                sta $109,x
                lda #>(withTerminalROMReturnThunk-1)
                sta $108,x
                lda #<(withTerminalROMReturnThunk-1)
                sta $107,x
                .else
                pha                          ; S=[A]
                pha                          ; S=[A; A]
                pha                          ; S=[A; A; A]
                php                          ; S=[P; A; A; A]
                pha                          ; S=[A; P; A; A; A]
                phx                          ; S=[X; A; P; A; A; A]
                tsx                          ; S=[X; A; P; A; A; A; RL; RH]
                lda $0107,x                  ; get RL
                sta $0104,x                  ; overwrite placeholder A
                lda $0108,x                  ; get RH
                sta $0105,x                  ; overwrite placeholder A
                lda $F4                      ; get ROMSEL
                sta $0108,x                  ; overwrite RH

                ; put return thunk in the right spot
                lda #>withTerminalROMReturnThunk-1                
                sta $0107,x                  
                lda #<withTerminalROMReturnThunk-1                
                sta $0106,x
                .endif                
                jsr selectTerminalROM      ; F3A6= 20 90 E5     .e
                bra plx_pla_plp_rts

;-------------------------------------------------------------------------
;
; Select the MOS ROM (i.e., no HAZEL). Rearrange the stack so that the
; original HAZEL state is restored when withMOSROM's caller itself
; returns.
; 
withMOSROM:
                .if version==350
                jsr LF381
                lda #>(withMOSROMReturnThunk-1)
                sta $108,x
                lda #<(withMOSROMReturnThunk-1)
                sta $107,x
                lda ACCCON
                sta $109,x
                jsr selectMOS
                .else
                pha                          ; S=[A]
                pha                          ; S=[A; A]
                pha                          ; S=[A; A; A]
                php                          ; S=[P; A; A; A]
                pha                          ; S=[A; P; A; A; A]
                phx                          ; S=[X; A; P; A; A; A]
                tsx                          ; S=[X; A; P; A; A; A; RL; RH]
                lda $0108,x                  ; get RH
                sta $0105,x                  ; overwrite placeholder A
                lda $0107,x                  ; get RL
                sta $0104,x                  ; overwrite placeholder A

                ; put return thunk in the right spot
                lda #>withMOSROMReturnThunk-1 ; F3BE= A9 F3       )s
                sta $0107,x                  ; F3C0= 9D 07 01    ...
                lda #<withMOSROMReturnThunk-1 ; F3C3= A9 D6       )V
                sta $0106,x                  ; F3C5= 9D 06 01    ...

                lda ACCCON                   ; get ACCCON
                sta $0108,x                  ; overwrite RH
                lda #ACCCON.Y
                trb ACCCON
                ; HAZEL off
                .endif
plx_pla_plp_rts:
                ; S=[X; A; P; RL; RH; thunkRL; thunkRH; old ACCCON/ROMSEL]
                plx                          ; F3D3= FA          z
                pla                          ; F3D4= 68          h
                plp                          ; F3D5= 28          (
                rts                          ; F3D6= 60          `

withMOSROMReturnThunk:
                php                          ; S=[P]
                pha                          ; S=[A; P]
                phx                          ; S=[X; A; P]
                tsx                          ; S=[X; A; P; old ACCCON]
                lda $0104,x                  ; get old ACCCON
                jsr selectMOSOrHAZEL         ; re-select old HAZEL state
returnThunkSuffix:
                ; double up P, as that's the easiest way of ending up
                ; discarding the TOS without affecting the flags.
                lda $0103,x
                sta $0104,x
                plx
                pla
                plp
                plp
                rts

;-------------------------------------------------------------------------

                .if version==350
                ; Should be called something more like runWithTST
callWithTST:
                jsr LF381
                lda $fc
                and #$bf
                sta ACCCON
                lda #<(withTSTReturnThunk-1)
                sta $107,x
                lda #>(withTSTReturnThunk-1)
                sta $108,x
                bra plx_pla_plp_rts

withTSTReturnThunk:
                php
                pha
                phx
                tsx
                sei
                lda ACCCON
                ora #$40
                jsr staSEIWKAAndACCCON
                bra returnThunkSuffix
                .endif

;-------------------------------------------------------------------------

                .if version==350
LF381:
                pha
                php
                pha
                phx
                tsx
                lda $106,x
                pha
                lda $105,x
                pha
                jsr LF392
                dex
LF392:
                lda $108,x
                sta $105,x
                rts
                .endif
                
;-------------------------------------------------------------------------

vduChrEntryPoint:
                jsr withMOSROM
                ldx $F4
                phx
                jsr selectTerminalROMAndANDY
                jsr outputToVDU
                plx
                jmp selectROMX

;-------------------------------------------------------------------------
;
; OSRDSC [MasRef D.6-1]
;
osrdscEntryPoint:
                jsr withMOSROM
                jmp LC018

;-------------------------------------------------------------------------
;
; OSWRSC [MasRef D.8-1]
;
oswrscEntryPoint:
                jsr withMOSROM
                jmp oswrscCode

;-------------------------------------------------------------------------

starRunBOOT:
                .text "/!BOOT",13

;-------------------------------------------------------------------------

                .if version<500&&version!=350
                .include "sound_stuff.s65"
                .endif

;-------------------------------------------------------------------------

                .if version>=500

LF416:
                lda $f4
                pha
                jsr selectTerminalROM
                jsr terminal.LF416
                plx
                jmp selectROMX

clearSoundChannelBuffer:
                phx
                lda $f4
                pha
                jsr selectTerminalROM
                jsr terminal.clearSoundChannelBuffer
                plx
                jsr selectROMX
                plx
                rts

                .endif

;-------------------------------------------------------------------------

                .if version==350
clearSoundChannelBuffer:
                jsr selectExtROM
                phy
                jsr clearSoundChannelBufferInternal
                bra selectOldROM
                .endif

;-------------------------------------------------------------------------

                .if version==350
LF3C5_350:
                jsr selectExtROM
                phy
                jsr LF416
selectOldROM:
                pla
                jmp selectROMA
                .endif

;-------------------------------------------------------------------------

                .if version==350
selectExtROM:
                ldy $f4
                lda #extROM
                jmp selectROMA
                .endif
                
;-------------------------------------------------------------------------

LF6FC:
                lda #$FF                     ; F6FC= A9 FF       ).
                sta $F5                      ; F6FE= 85 F5       .u
                rts                          ; F700= 60          `

LF701:
                inc $F5                      ; F701= E6 F5       fu
                ldy $F5                      ; F703= A4 F5       $u
                ldx #romServiceCallROMFilingSystemInitialize
LF707:
                php                          ; F707= 08          .
                jsr makeROMServiceCall                    ; F708= 20 72 EE     rn
                plp                          ; F70B= 28          (
                cmp #$01                     ; F70C= C9 01       I.
                tya                          ; F70E= 98          .
                rts                          ; F70F= 60          `

LF710:
                ldx #$0E                     ; F710= A2 0E       ".
                ldy #$FF                     ; F712= A0 FF        .
                jmp LF707                    ; F714= 4C 07 F7    L.w

LF717:
                lda $03CB                    ; F717= AD CB 03    -K.
                sta $F6                      ; F71A= 85 F6       .v
                lda $03CC                    ; F71C= AD CC 03    -L.
                sta $F7                      ; F71F= 85 F7       .w
                lda $F5                      ; F721= A5 F5       %u
                rts                          ; F723= 60          `

tidyUpAfterKeyboardProcessing:
                ldx #$FF
                lda lastKeyPressedInternal
                ora firstKeyPressedInternal
                bne +                    ;taken if any keys pressed
                lda #$81
                sta systemVIA.ier            ;re-enable keyboard IRQ
                inx                          ;X=0
+
                stx keyboardSemaphore
updateKeyboardLEDs:
                php
                lda keyboardStatusByte
                lsr a

                ; bit 3 = caps lock off
                ; bit 4 = shift lock off
                and #(keyboardStatusByte.capsLockDisengaged|keyboardStatusByte.shiftLockDisengaged)>>1
                ora #$06                     ;latch B6 - caps lock
                sta systemVIA.orb            ;update caps lock LED
                lsr a                        ;bit 3 = shift lock off
                ora #$07                     ;latch B7 - shift lock
                sta systemVIA.orb            ;update shift lock LED
                jsr enableKeyboardScanning
                pla
                rts

; KEYV handler
; ============
keyEntryPoint:
                bvc keyVClear
                lda #$01
                sta systemVIA.ier
                bcs keyboardTimerInterrupt
                jmp keyPressedInterrupt

keyVClear:
                bcc keyTestSHIFTAndCTRLOrTimerInterrupt
                jmp scanKeyboard

keyboardTimerInterrupt:
                inc keyboardSemaphore

;-------------------------------------------------------------------------
; 
; Test Shift & Ctrl keys, or deal with timer interrupt.
;
; Entry: C=0 if KEYV V=0 C=0 - test SHIFT+CTRL keys
;        C=1 if KEYV V=1 C=1 - keyboard timer interrupt
;
keyTestSHIFTAndCTRLOrTimerInterrupt:
                lda keyboardStatusByte
                and #~(keyboardStatusByte.shiftPressed|keyboardStatusByte.ctrlPressed)
                ldx #key_shift
                jsr interrogateKeyboard      ;X=$80 if SHIFT pressed
                bcc +                        ;taken if testing
                                             ;SHIFT+CTRL only
                stx SEIWKA                   ;b7 set if SHIFT pressed
+
                clv                        ;V=0
                bpl testCTRL               ;taken if SHIFT not pressed
                bit valueFF                ;V=1 N=1
                ora #keyboardStatusByte.shiftPressed
testCTRL:
                inx                          ;X=1 - key_ctrl
                jsr interrogateKeyboard
                bcc updateKeyboardLEDs ;taken if testing SHIFT+CTRL only
                bpl updateKeyboardStatusByte ;taken if CTRL not pressed
                ora #keyboardStatusByte.ctrlPressed
updateKeyboardStatusByte:
                sta keyboardStatusByte
                ldx lastKeyPressedInternal
                beq braRolloverChecks        ;taken if no key pressed
                jsr interrogateKeyboard      ;still pressed?
                bmi checkForKeyAutoRepeat    ;taken if still pressed
                cpx lastKeyPressedInternal   ;X=0 at this point
storeLastKeyPressed:
                stx lastKeyPressedInternal   ;update last key pressed
                bne braRolloverChecks  ;taken if still nothing pressed
                stz lastKeyPressedInternal   ;reset last key pressed
resetAutoRepeatAndContinue:
                jsr resetAutoRepeatCounters
                bra braRolloverChecks

checkForKeyAutoRepeat:
                cpx lastKeyPressedInternal
                bne storeLastKeyPressed      ;taken if new key pressed
                lda autoRepeatCountdownTimer
                beq braRolloverChecks      ;taken if countdown timer 0
                dec autoRepeatCountdownTimer ;timer--
                bne braRolloverChecks        ;taken if timer newly 0
                lda keyboardFirstAutoRepeatCount
                sta autoRepeatCountdownTimer
                lda keyboardAutoRepeatRate
                sta keyboardFirstAutoRepeatCount
                lda keyboardStatusByte
                ldx lastKeyPressedInternal
                cpx #$80|key_shift_lock
                beq shiftLockPressed
                cpx #$80|key_caps_lock
                .if version>=511||version==350
                bne LF5E5_511
                .else
                bne getASCIICode
                .endif
capsLockPressed:
                ora #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
                bit SEIWKA                   ;test SHIFT status
                bpl +                        ;taken if SHIFT not pressed
                ; Do the SHIFT+CAPS LOCK thing
                ora #keyboardStatusByte.capsLockDisengaged
                eor #keyboardStatusByte.shiftEnabled
+
                eor #keyboardStatusByte.shiftEnabled|keyboardStatusByte.capsLockDisengaged
                bra resetKeyboardStatusAndTimer

shiftLockPressed:
                ora #keyboardStatusByte.shiftEnabled|keyboardStatusByte.capsLockDisengaged
                eor #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
resetKeyboardStatusAndTimer:
                sta keyboardStatusByte
                stz autoRepeatCountdownTimer
braRolloverChecks:
                .if version<500&&version!=350
                bra keyboardRolloverChecks
                .else
                jmp keyboardRolloverChecks
                .endif

;-------------------------------------------------------------------------

                .if version>=511||version==350
LF5E5_511:
                bit keyboardTranslationTableAddress+1
                bmi getASCIICode
                phx
                phx
                ply
                ldx #romServiceCall30
                jsr makeROMServiceCall
                bne LF607
                plx
                tya
                ror a
                ror a
                bcc LF5FC
                stz autoRepeatCountdownTimer
LF5FC:
                bmi braRolloverChecks
                lda keyboardTranslationTableAddress+0
                bit keyboardTranslationTableAddress+1
                .if version==350
                jmp LF839
                .else
                jmp LF6A8
                .endif

LF607:
                plx
                .endif
;-------------------------------------------------------------------------
;
; Convert internal key number (with bit 7 set) to ASCII code, taking
; into account state of CTRL, SHIFT, CAPS LOCK and SHIFT LOCK.
; 
getASCIICode:
                ; -$80 to adjust for bit 7 set; -16 because
                ; interesting keys start at 16
                lda keyTranslationTable-$80-16,x
                .if version>=500
                ldx editKeysMode
                cpx #3
                bne LF5E5
                cmp #$8b
                bcc LF5E5
                cmp #$90
                bcc braRolloverChecks
LF5E5:
                pha
                cmp #27
                bne LF5EF
                lda #7
                trb keyboardStatusByte
LF5EF:
                pla
                .endif
                beq handleTAB                ;taken if TAB
                cmp #$9D                     ;was it key_numpad_return?
                .if version<500&&version!=350
                bne handleKey                ;taken if not
                .else
                bne LF5FD
                .endif
                
                ;Transform $9d into $8d, aka 13|$80. ($8d is already
                ; used in the table for right arrow.)
                eor #$10
                bra getNumpadASCIICode

handleTAB:
                lda tabKeyCode
                .if version>=500
LF5FD:
                cmp #1
                bne LF61F
                lda keyboardStatusByte
                and #$f8
                sta keyboardStatusByte
                ldx #1
                bit #keyboardStatusByte.shiftPressed
                beq LF610
                inx
LF610:
                bit #keyboardStatusByte.ctrlPressed
                beq LF616
                inx
                inx
LF616:
                txa
                ora keyboardStatusByte
                sta keyboardStatusByte
                bra braRolloverChecks

LF61F:
                bit valueFF
                cmp #$90
                bcc handleKey
                clv
                .elsif version==350
LF5FD:
                bit valueFF
                cmp #$90
                bcc handleKey
                clv
                .endif
handleKey:
                cmp #$A0                     ;numpad key?
                bcc processModifiers         ;taken if not
getNumpadASCIICode:
                .if version>=500||version==350
                php
                .endif
                ; C=1 at this point
                sbc #'0'+1      ;+1 to compensate for C=1 in the next
                                ;addition
                adc numericKeypadInterpretation ;form actual ASCII value
                .if version>=500||version==350
                plp
                .endif
                eor #$80                     ;clear bit 7
                ldx numericKeypadShiftEffect ;does SHIFT affect the
                                             ;keypad?
                bne LF839                    ;taken if no
processModifiers:
                ldx keyboardStatusByte
                stx SEIWKA
                rol SEIWKA                  ;b7 = ctrlPressed
                bpl testShiftLock           ;taken if ctrl not pressed
                ldx firstKeyPressedInternal
localResetAutoRepeatAndContinue:
                .if version<500&&version!=350
                bne resetAutoRepeatAndContinue
                jsr implementCTRLCodes
                .else
                beq +
                jmp resetAutoRepeatAndContinue
+
                jsr implementCTRLCodes
                .endif
testShiftLock:
                rol SEIWKA                   ;b7 = shiftLockDisengaged
                bmi testCapsLock             ;taken if shift lock off
                jsr implementShift           ;shift lock on - apply shift
                rol SEIWKA                   ;b7 = capsLockDisengaged
                bra testShiftEnabled

testCapsLock:
                rol SEIWKA                   ;b7 = capsLockDisengaged
                bmi testShift                ;taken if caps lock off
                jsr isLetter
                bcs testShift                ;taken if not a letter
                jsr implementShift ;letter + caps lock - make upper case
testShiftEnabled:
                ldx keyboardStatusByte       ;b7 = shiftEnabled
                bpl testEscape               ;taken if not shiftEnabled
testShift:
                rol SEIWKA                   ;b7 = shiftPressed
                bpl testEscape               ;taken if not shiftPressed
                ldx firstKeyPressedInternal
                bne localResetAutoRepeatAndContinue
                jsr implementShift
testEscape:
                cmp escapeCharacter
                bne LF839
                ldx escapeKeyStatus
                bne LF839
                stz autoRepeatCountdownTimer

LF839:

                .if version==350

                tay
                bvc LF54A
                bne LF555
LF54A:
                tya
                beq LF54F
                bpl LF555
LF54F:
                jsr LF6D3
                bcc LF55D_350
                tay
LF555:
                lda keyboardStatus
                bne LF55D_350
                jsr insertCharacterIntoKeyboardBufferWithTST
LF55D_350:
                jsr enableKeyboardScanningFlippingInterrupts
                
                .elsif version<500
                
                tay
                jsr enableKeyboardScanningFlippingInterrupts
                lda keyboardStatus
                bne keyboardRolloverChecks
                jsr insertCharacterIntoKeyboardBuffer

                .elsif version>=500

                pha
                lda keyboardStatusByte
                and #7
                tax
                .if version<511
                lda #7
                .endif
                trb keyboardStatusByte
                pla
                pha
                dex
                .if version<511
                bne LF693
                pla
                .if olivetti
                bra LF718o
                .else
                bra LF6A8
                .endif
                .endif

LF693:
                dex
                .if version<511
                bne LF699
                pla
                .if olivetti
                bra LF718o
                .else
                bra LF6A8
                .endif
                .endif

LF699:
                dex
                .if version<511
                bne LF69F
                pla
                .if olivetti
                bra LF718o
                .else
                bra LF6A8
                .endif
                .endif

LF69F:
                dex
                .if olivetti
                bne LF712o
                .else
                bne LF6A7
                .endif
                pla
                ora #$80
                bra LF6AD

                .if olivetti
LF712o:
                pla
                jsr LF3C6o
                bra LF6A7

LF718o:
                jsr LF3F1o
                .endif

LF6A7:
                .if !olivetti
                pla
LF6A8:
                .endif
                tay
                bvc LF6AD
                bne LF6B3
LF6AD:
                jsr LF82B
                bcc LF6BB
                tay

LF6B3:
                lda keyboardStatus
                bne LF6BB
                jsr insertCharacterIntoKeyboardBuffer
LF6BB:
                jsr enableKeyboardScanningFlippingInterrupts

                .endif
                
keyboardRolloverChecks:
                ldx firstKeyPressedInternal
                beq LF852                    ;taken if 1 key down
                jsr interrogateKeyboard      ;test first key pressed
                stx firstKeyPressedInternal  ;save it
                bmi LF868                    ;taken if still pressed
                stz firstKeyPressedInternal  ;reset first key
LF852:
                ldy #lastKeyPressedInternal
                jsr scanKeyboardWithExclusion
                bmi LF862
                lda lastKeyPressedInternal
                sta firstKeyPressedInternal
updateLastKeyPressedInternal:
                stx lastKeyPressedInternal
                jsr resetAutoRepeatCounters
LF862:
                jmp tidyUpAfterKeyboardProcessing

keyPressedInterrupt:
                jsr interrogateKeyboard
LF868:
                lda lastKeyPressedInternal
                bne LF862
                ldy #firstKeyPressedInternal
                jsr scanKeyboardWithExclusion
                bmi LF862
                bra updateLastKeyPressedInternal

resetAutoRepeatCounters:
                ldx #$01
                stx autoRepeatCountdownTimer
                ldx keyboardAutoRepeatDelay
                stx keyboardFirstAutoRepeatCount
                rts

;-------------------------------------------------------------------------
;
; Read a single key's state from the keyboard
;
; Entry:
;
; X = key to test
;
; Exit:
;
; X=$80, N=1 if key pressed; X=$00, N=0 if key not pressed
;
; Preserves: A/C
; 
                .if version==350
setTSTAndInterrogateKeyboard:
                jsr callWithTST
                .endif
interrogateKeyboard:
                ldy #$03                     ;write to keyboard
                sty systemVIA.orb
                ldy #$7F
                sty systemVIA.ddra           ;bit 7=input, bits 6-0=output
                stx systemVIA.oraNoHandshake ;store key value
                nop
                ldx systemVIA.iraNoHandshake ;read key state
                rts

; Default keyboard table
; ======================

keyTranslationTable:
                .text "q"                    ;10 q
                .byte "3"                    ;11 3
                .byte "4"                    ;12 4
                .byte "5"                    ;13 5
                .byte $84                    ;14 f4
                .text "8"                    ;15 8
                .byte $87                    ;16 f7
                .text "-"                    ;17 minus
                .text "^"                    ;18 caret
                .byte $8C                    ;19 left
                .byte "6"|$80                ;1a numpad_6
                .byte "7"|$80                ;1b numpad_7
osbyte92:
                ldy $FC00,x                  ;1c 1d 1e
                rts                          ;1f

                .cerror *-keyTranslationTable!=16,'oops'
                .byte $80                    ;20 f0
                .text "w"                    ;21 w
                .text "e"                    ;22 e 
                .text "t"                    ;23 t
                .text "7"                    ;24 7
                .text "i"                    ;25 i
                .text "9"                    ;26 9
                .text "0"                    ;27 0
                .text "_"                    ;28 underline
                .byte $8E                    ;29 down
                .byte "8"|$80                ;2a numpad_8
                .byte "9"|$80                ;2b numpad_9
osbyte94:
                ldy $FD00,x                  ;2c 2d 2e
                rts                          ;2f
                
                .cerror *-keyTranslationTable!=32,'oops'
                .text "1"                    ;30 1
                .text "2"                    ;31 2
                .text "d"                    ;32 d
                .text "r"                    ;33 r
                .text "6"                    ;34 6
                .text "u"                    ;35 u
                .text "o"                    ;36 o
                .text "p"                    ;37 p
                .text "["                    ;38 left_square_bracket
                .byte $8F                    ;39 up
                .byte "+"|$80                ;3a numpad_plus
                .byte "-"|$80                ;3b numpad_minus
                .byte $9D                    ;3c numpad_return
LF8BF:
                jmp (EVENTV)                 ;3d 3e 3f
                .cerror *-keyTranslationTable!=48,'oops'
                .byte 1                      ;40 caps_lock
                .text "a"                    ;41 a
                .text "x"                    ;42 x
                .text "f"                    ;43 f
                .text "y"                    ;44 y
                .text "j"                    ;45 j
                .text "k"                    ;46 k
                .if version<500
                .text "@"                    ;47 at
                .elsif version>=500
                .byte 1                      ;47 special
                .endif
                .text ":"                    ;48 colon
                .byte $0D                    ;49 return
                .byte "/"|$80                ;4a numpad_divide
                .byte 127|$80                ;4b numpad_delete
                .byte "."|$80                ;4c numpad_stop
call1MHzBusHook:
                jmp ($FDFE)                  ;4d 4e 4f
                
                .cerror *-keyTranslationTable!=64,'oops'
                .byte 2                      ;50 shift_lock
                .text "s"                    ;51 s
                .text "c"                    ;52 c
                .text "g"                    ;53 g
                .text "h"                    ;54 h
                .text "n"                    ;55 n
                .text "l"                    ;56 l
                .text ";"                    ;57 semicolon
                .text "]"                    ;58 right_square_bracket
                .byte $7F                    ;59 delete
                .byte "#"|$80                ;5a numpad_hash
                .byte "*"|$80                ;5b numpad_multiply
                .byte ","|$80                ;5c numpad_comma
callSEIWKA:
                jmp (SEIWKA)                 ;5d 5e 5f
                .cerror *-keyTranslationTable!=80,'oops'
                .byte 0                      ;60 tab
                .text "z"                    ;61 z
                .text " "                    ;62 space
                .text "v"                    ;63 v
                .text "b"                    ;64 b
                .text "m"                    ;65 m
                .text ","                    ;66 comma
                .text "."                    ;67 stop
                .text "/"                    ;68 divide
                .byte $8B                    ;69 copy
                .byte "0"|$80                ;6a numpad_0
                .byte "1"|$80                ;6b numpad_1
                .byte "3"|$80                ;6c numpad_3
                .byte 0                      ;6d
                .byte 0                      ;6e
                .byte 0                      ;6f
                .cerror *-keyTranslationTable!=96,'oops'
                .byte 27                     ;70 escape
                .byte $81                    ;71 f1
                .byte $82                    ;72 f2
                .byte $83                    ;73 f3
                .byte $85                    ;74 f5
                .byte $86                    ;75 f6
                .byte $88                    ;76 f8
                .byte $89                    ;77 f9
                .byte $5C                    ;78 backslash
                .byte $8D                    ;79 right
                .byte "4"|$80                ;7a numpad_4
                .byte "5"|$80                ;7b numpad_5
                .byte "2"|$80                ;7c numpad_2
LF8FF:
                bit valueFF                  ; Set V
callKEYV:                                    
                jmp (KEYV)                   ; Jump to KEYV

;-------------------------------------------------------------------------
;
; OSBYTE 131 (&83) - Read Operating System High Water Mark (OSHWM)
;
; MasRef D.2-40
; 
osbyte83:
                ldy oshwm
                ldx #$00
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 120 ($78) - Write keys pressed information
;
; MasRef D.2-33
;
osbyte78:                          ;f90b
                sty lastKeyPressedInternal
                stx firstKeyPressedInternal
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 122 (&7A) Keyboard scan from 16 decimal
;
; MasRef D.2-36
; 
                .if version==350
setTSTAndOSBYTE7A:
                jsr callWithTST
                .endif
osbyte7A:
                ldx #$10
                clv
                sec
                bra callKEYV

;-------------------------------------------------------------------------

scanKeyboard:
                txa
                bpl LF923
                jsr interrogateKeyboard
enableKeyboardScanning:
                lda #8|3                     ;set latch B3 - auto scan mode
                sta systemVIA.orb            ;set auto scan mode
                txa
                rts

LF923:
                stx previousKeyPressedWhenReadingLastKey
                lda #$FF
                sta previousKeyPressedWhenReadingFirstKey
                ldx #$0C
                lda #$7F
                sta systemVIA.ddra
                lda #0|3            ;reset latch B3 - manual scan mode
                sta systemVIA.orb
loopKeyboardColumns:
                lda #$0F
                sta systemVIA.oraNoHandshake ;select a non-existent column
                lda #$01
                sta systemVIA.ifr            ;cancel keyboard interrupts
                stx systemVIA.oraNoHandshake ;select column
                bit systemVIA.ifr            ;any key in this column
                                             ;pressed?
                beq tryNextKeyboardColumn    ;taken if no key
                txa                          ;A = first key in column
loopKeyboardRows:
                clc
                adc #$10                     ;next row
                bmi tryNextKeyboardColumn    ;taken if done
                sta systemVIA.oraNoHandshake ;store key
                bit systemVIA.iraNoHandshake ;pressed?
                bpl loopKeyboardRows         ;taken if not
                cmp previousKeyPressedWhenReadingLastKey
                bcc loopKeyboardRows
                cmp previousKeyPressedWhenReadingFirstKey
                bcs loopKeyboardRows
                sta previousKeyPressedWhenReadingFirstKey
tryNextKeyboardColumn:
                dex
                bpl loopKeyboardColumns
                ldx previousKeyPressedWhenReadingFirstKey
                bra enableKeyboardScanning

scanKeyboardWithExclusion:
                ldx #$0c
LF96E:
                jsr enableKeyboardScanningFlippingInterrupts
                lda #$7F
                sta systemVIA.ddra
                lda #0|3
                sta systemVIA.orb
                lda #$0F
                sta systemVIA.oraNoHandshake ;select non-existent column
                lda #$01
                sta systemVIA.ifr            ;cancel keyboard interrupts
                stx systemVIA.oraNoHandshake
                bit systemVIA.ifr
                beq LF9AD
                txa
LF98E:
                clc
                adc #$10
                bmi LF9AD                    ;taken if done
                sta systemVIA.oraNoHandshake ;test key
                bit systemVIA.iraNoHandshake ;pressed?
                bpl LF98E                    ;taken if not
                pha                          ;save key number
LF99C:
                eor $0000,y                  ;compare to value
                asl a                        ;discard irrelevant bit 7
                cmp #$01                     ;C set if different
                pla                          ;restore key number
                bcc LF98E                    ;same key found - keep going
                tax
enableKeyboardScanningFlippingInterrupts:
                jsr enableKeyboardScanning
                cli
                sei
                txa
                rts

LF9AD:
                dex
                bpl LF96E
                bra enableKeyboardScanningFlippingInterrupts

;-------------------------------------------------------------------------

                .if version==400
                .include "sram_access_helpers.s65"
                .endif
                
;-------------------------------------------------------------------------

                .if version>=500
                ; dup of what's called LF6D3 in MOS 3.50
LF82B:
                pha
                ldx #0
                clv
                sec
                jsr countBufferViaCNPV
                tya
                bne LF83A
                cpx #2
                bcc LF844
LF83A:
                ldy keyboardStatus
                clc
                bne LF844
                jsr insertCharacterIntoKeyboardBuffer
                sec
LF844:
                pla
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
LF846: .block
                jsr selectROMA
LF849:
                lda ($b0),y
                sta ($b2),y
                iny
                bne LF85D
                inc $b1
                inc $b3
                jsr selectTerminalROM
                jsr terminal.L8D0F
                jsr selectROMA
LF85D:
                cpy $2ef
                bne LF849
                lda 1,x
                cmp $2f0
                bne LF849
                jmp selectTerminalROM
                .endblock
                .endif

;-------------------------------------------------------------------------

                .if version>=400
                .include "sram_access_helpers_2.s65"
                .endif

;-------------------------------------------------------------------------

                .if version>=400
LF8B4:
                jsr selectROMX
                .if version==400
                lda #$80
                sta 1
                stz 0
                lda #0
                .else
                ldy #$80
                sty 1
                stz 0
                .endif
                tay
LF8BE:
                sta (0),y
                iny
                bne LF8BE
                inc 1
                bit 1
                bvc LF8BE
                dex
                cpx #4
                bcs LF8B4
                jmp selectTerminalROM
                .endif
                
;-------------------------------------------------------------------------

LF8D1Macro: .macro
                lda $02ee
                cmp #$a0
                bne LF8B1
                ldy $2f1
                tya
                tax
                jsr LE389
                bcc LF8B1
                lda $8006
                sta romInformationTable,x
                bra LF8B1
                .endmacro
                
                .if version>=500
LF8D1: .LF8D1Macro
                .endif

;-------------------------------------------------------------------------

                .if version>=400
LF8EA:
                jsr withTerminalROM
                jmp terminal.L8EDC
                .endif

;-------------------------------------------------------------------------

                .if version>=400
LF8F0:
                jsr withTerminalROM
                jmp terminal.L8F8C
                .endif
                
;-------------------------------------------------------------------------

                .if version>=400
osword10:
                jsr withTerminalROM
                jmp terminal.L8BF2
                .endif
                
;-------------------------------------------------------------------------

                .if version>=400
osword11:
                jsr withTerminalROM
                jmp terminal.L8E2E
                .endif

;-------------------------------------------------------------------------

                .if version==350
                ; dup of what's called LF82B in MOS 5.00+
LF6D3:
                pha
                ldx #0
                clv
                sec
                jsr countBufferViaCNPV
                tya
                bne LF6E2
                cpx #bufferFirstOutput
                bcc LF6EC
LF6E2:
                ldy keyboardStatus
                clc
                bne LF6EC
                jsr insertCharacterIntoKeyboardBufferWithTST
                sec
LF6EC:
                pla
                rts
                .endif
                
;-------------------------------------------------------------------------
;
; OSBPUT [AUG p339]
;
osbputEntryPoint:
                jsr selectFSForHandle
                jmp (BPUTV)

;-------------------------------------------------------------------------
;
; OSBGET [AUG p338]
;
osbgetEntryPoint:
                jsr selectFSForHandle
                jmp (BGETV)

;-------------------------------------------------------------------------
;
; OSGBPB [AUG p339]
;
osgbpbEntryPoint: .proc
                cmp #gbpbGetMediaMetadata
                bcs nonFileOperation
                cmp #$00
                beq nonFileOperation

                ; Handle OSGBPB call that's an operation on a file
                ; handle. Select the appropriate FS, given the file
                ; handle, and pass the request along.
                phy                          ;save OSGBPB Y
                pha                          ;save OSGBPB A
                stx osgbpbWorkspace.ptr+0
                sty osgbpbWorkspace.ptr+1
                lda (osgbpbWorkspace.ptr)    ;get file handle
                tay                          
                pla                          ;restore OSGBPB A
                jsr selectFSForHandle
passToCurrentFS:
                ply                          ;restore OSGBPB Y
                jmp (GBPBV)                  

;-------------------------------------------------------------------------
;
; Handle OSGBPB call that isn't an operation on a file handle. Select
; current FS and pass the request along.
; 
nonFileOperation:
                phy
                phx
                pha
                jsr selectHAZEL    
                lda hazel.currentFS
                jsr selectFS       
                pla                
                plx                
                bra passToCurrentFS
                .endproc
                
;-------------------------------------------------------------------------
;
; OSARGS [AUG p337[
;
;
osargsEntryPoint: .proc
                cpy #$00
                bne fileOperation            ;taken if file operation
                cmp #$04
                bcs fileOperation ;taken if Y=0, A>=4 - honorary file operation
                pha
                jsr selectHAZEL
                pla
                bne notGetFS
getFS:
                ; OSARGS Y=0 A=0 - read current FS number
                lda hazel.currentFS
                rts

notGetFS:
                dec a
                bne notGetCommandLine
getCommandLine:
                ; OSARGS Y=0 A=1 - read command line tail address
                dec a                        ;A=$ff
                sta 2,x                    ;store full 32-bit address
                sta 3,x                    ;store full 32-bit address
                lda hazel.commandLinePointer+0
                sta 0,x                    ;
                lda hazel.commandLinePointer+1
                sta 1,x                    
                rts                          

notGetCommandLine:
                cmp #argsCheckANFS-1    ;-1 due to the dec a above
                beq rtsFA14            ; OSARGS Y=0 A=2 - Read OldNFS flag
getLibFS:
                lda hazel.libFS      ;OSARGS Y=0 A=3 - Read libfs filing system number
rtsFA14:
                rts                          ; FA14= 60          `
                
fileOperation:
                ; Operating on a file. Select appropriate FS first.
                jsr selectFSForHandle                    
                .endproc


;-------------------------------------------------------------------------
;
; Call current FS's OSARGS routine, bypassing the FileSwitch stuff.
;
callARGSV:                      ;fa18
                jmp (ARGSV)

;-------------------------------------------------------------------------
;
; OSFIND [AUG p342]
; 
osfindEntryPoint: .proc
                ora #$00        ;A=$00 if a file is to be closed
                beq close       ;branch taken if closing a file
                jsr parseFileNameAndSelectFS       ;handle something other than a file close
                bra callFINDV

close:
                jsr selectFSForHandle                    ; FA24= 20 97 FA     .z
callFINDV:
                jmp (FINDV)                  ; FA27= 6C 1C 02    l..
                .pend
                
;-------------------------------------------------------------------------
;
; OSFILE [AUG p335]
; 
osfileEntryPoint:               ;fa2a
                phx
                phy
                pha
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                ldy #size(OSFILEParameterBlock)-1
-
                lda (stringInputBufferAddress),y
                sta osfileParameterBlock,y
                dey                          ; FA38= 88          .
                bpl -
                ldx osfileParameterBlock+OSFILEParameterBlock.fileName+0
                ldy osfileParameterBlock+OSFILEParameterBlock.fileName+1
                jsr parseFileNameAndSelectFS
                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
                pla
                ldx #<osfileParameterBlock
                ldy #>osfileParameterBlock
                jsr callFILEV
                ply
                sty stringInputBufferAddress+1
                plx
                stx stringInputBufferAddress+0
                pha
                ldy #size(OSFILEParameterBlock)-1
-
                lda osfileParameterBlock,y
                sta (stringInputBufferAddress),y
                dey
                cpy #$02                     ;don't overwrite file name
                bcs -
                pla
                ldx stringInputBufferAddress+0
                ldy stringInputBufferAddress+1
                rts

callFILEV:
                jmp (FILEV)

;-------------------------------------------------------------------------
;
; Parse file name. Handle (and skip) any -FS- tempfs syntax, selecting
; the FS specified if required.
;
; entry:
;
; Y (MSB)/X (LSB) = address of file name string
;
; exit:
;
; Y (MSB)/X (LSB) = address of file name part
;
; - New FS may have been selected
; 
parseFileNameAndSelectFS:
                pha                          
                lda stringInputBufferAddress+0
                pha                          
                lda stringInputBufferAddress+1 
                pha                          
                jsr selectHAZEL
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                ldy #$00
                jsr parseFileNameFS      ;find -FS- prefix, if any
                phy                      ;save offset
                jsr selectFS                 ;select desired FS
                pla                          
                clc                          
                adc stringInputBufferAddress+0
                tax                          ;save string address LSB
                ldy stringInputBufferAddress+1
                bcc +
                iny
+
                pla                          
                sta stringInputBufferAddress+1
                pla                          
                sta stringInputBufferAddress+0
                pla                          
                rts                          

;-------------------------------------------------------------------------
;
; Select appropriate FS for the given file handle.
;
; entry:
;
; Y = file handle
;
; exit:
;
; - appropriate FS selected
;
; preserves: Y/X/A

selectFSForHandle:
                phx                          ; FA97= DA          Z
                pha                          ; FA98= 48          H
                jsr selectHAZEL                    ; FA99= 20 BA ED     :m
                jsr findFSForHandle                    ; FA9C= 20 23 FB     #{
                txa                          ; FA9F= 8A          .
                jsr selectFS                    ; FAA0= 20 4D FB     M{
                pla                          ; FAA3= 68          h
                plx                          ; FAA4= FA          z
                rts                          ; FAA5= 60          `

;-------------------------------------------------------------------------
;
; Parse the FS part of a file name, if any, and return the filing
; system to use.
;
; Entry:
;
; (stringInputBufferAddress),y = the string
;
; Exit:
;
; A = FS number to use
;
; (stringInputBufferAddress),y = next char after any tempfs prefix has
; been consumed
parseFileNameFS: .proc
                
                lsr hazel.tempFSFlag
                jsr skipSpacesAndCheckForCRInStringInput
                lda (stringInputBufferAddress),y
                cmp #'-'
                beq parseFSNamePrefix ; branch taken if tempfs syntax
                bit hazel.tempFSFlag
                lda hazel.currentFS
                bvc +
                lda hazel.activeFS
+
                rts

parseFSNamePrefix:
                iny                          ; FABE= C8          H
                ldx #$00                     ; FABF= A2 00       ".
LFAC1:
                lda hazel.fsInfoBlocks,x ;get FS name char
                beq badFilingSystemName
                txa                      ;A=offset in info blocks
                clc
                adc #size(fsInfoBlock.name)
                sta parseFileNameFSWorkspace.fsInfoOffset
                phy
compareFSNameLoop:
                lda (stringInputBufferAddress),y

; validate FS name char. Must be letter or digit.
                
                jsr isLetter
                bcc validFSNameChar           ;branch taken if letter
                cmp #'0'
                bcc notValidFSNameChar       ;branch taken if not digit
                cmp #'9'+1
                bcs notValidFSNameChar       ;branch taken if not digit
validFSNameChar:
                cpx parseFileNameFSWorkspace.fsInfoOffset
                bcs nextFSInfoBlock ;branch taken if end of FS
                                         ;info block name was reached
                eor hazel.fsInfoBlocks,x
                and #$DF                 ;Z=1 if char matches FS name
                bne nextFSInfoBlock      ;branch taken if not a match
                inx                      ;next fs info block byte
                iny                      ;next input string byte
                bra compareFSNameLoop

nextFSInfoBlock:
                ply                          
                ldx parseFileNameFSWorkspace.fsInfoOffset ;offset of end of name
                inx                          
                inx                          
                inx             ;advance to next entry
                bra LFAC1                    

notValidFSNameChar:

; Matching FS name must be terminated with -. Otherwise, it's bad
; syntax, or perhaps an overly long name.
                
                cmp #'-'
                bne badFilingSystemName
                iny                       ;consume input '-'
                cpx parseFileNameFSWorkspace.fsInfoOffset                   
                beq foundFSInfoBlock     ;branch taken if a match due
                                         ;to being right at end of the
                                         ;FS info block name
                lda hazel.fsInfoBlocks,x ;
                cmp #' '
                bne nextFSInfoBlock      ;branch taken if not a match
                                         ;as tthe supplied name was a
                                         ;prefix of this FS's name
foundFSInfoBlock:
                pla
                ldx parseFileNameFSWorkspace.fsInfoOffset
                lda hazel.fsInfoBlocks+(fsInfoBlock.fsNumber-(fsInfoBlock.name+size(fsInfoBlock.name))),x
                rts

badFilingSystemName:
                brk
                .text $f8,'Bad filing system name',0
                .pend

;-------------------------------------------------------------------------
;
; Find FS for the given handle
;
; entry:
;
; Y = file handle
;
; exit:
;
; X = FS number - will just use current FS if none suitable found
;
findFSForHandle: .proc
                pha                          ;
                phy                          ;
                tya                          ;A = handle to search for
                ldy #$00                     ;
loop:
                ldx hazel.fsInfoBlocks.name+0,y
                beq notFound                  ;taken if terminating entry
                cmp hazel.fsInfoBlocks.minHandle,y
                bcc next                     ;taken if not this FS
                cmp hazel.fsInfoBlocks.maxHandle,y
                bcc found                    ;taken if this FS
                beq found                    ;taken if this FS
                
next:
                pha                          ; FB39= 48          H
                tya                          ; FB3A= 98          .
                clc                          ; FB3B= 18          .
                adc #size(fsInfoBlock)       ; FB3C= 69 0B       i.
                tay                          ; FB3E= A8          (
                pla                          ; FB3F= 68          h
                bra loop

notFound:
                ldx hazel.currentFS
                bra done

found:
                ldx hazel.fsInfoBlocks.fsNumber,y
done:
                ply                          ; FB4A= 7A          z
                pla                          ; FB4B= 68          h
                rts                          ; FB4C= 60
                .endproc

;-------------------------------------------------------------------------
;
; Select filing system in A.
;
; Entry:
;
; A = FS number
;
selectFS:                               ;fb4d
                cmp hazel.activeFS      ; Check active fs
                beq rtsFB68               ; Already active fs, return
                phy
                phx
                tay
                dec a
                bne LFB5F       ;taken if not FS 1 (tape)

; ??? - only if trying to select tape FS
                
                lda #$04                     ; FB58= A9 04       ).
                bit $E2                      ; FB5A= 24 E2       $b
                bne LFB5F                    ; FB5C= D0 01       P.
                iny                          ; FB5E= C8          H
LFB5F:
                phy                          ; FB5F= 5A          Z
                ldx #romServiceCallInitialiseFilingSystem
                jsr makeROMServiceCall
                pla                          ; FB65= 68          h
                plx                          ; FB66= FA          z
                ply                          ; FB67= 7A          z
rtsFB68:
                rts                          ; FB68= 60          `

;-------------------------------------------------------------------------
; 
; FileSwitch FSC
; ==============
; 
fileswitchFSCEntryPoint:
                pha                          ;save request type
                jsr selectHAZEL
                lsr hazel.tempFSFlag
                pla                          ;restore request type
                pha                          ;save request type
                phx                          ;save request X
                asl a
                tax
                cmp #11*2+1
                bcs fileswitchPassFSCToCurrentFS ;taken if out of range
                jmp (fileswitchFSCRoutinesTable,x)

;-------------------------------------------------------------------------
;
; Pass to filing system's FSC
;
; There's 2 entry points - fileswitchPassFSCToCurrentFS, for
; when X and A are both on the stack, and
; fileswitchPassFSCToCurrentFS_X, for when only A is on the
; stack.
;
fileswitchPassFSCToCurrentFS:
fileswitchFSCNewFS:
fileswitchFSCFileHandleRange:
fileswitchFSCStarCommand:
                plx                          ;restore request X
fileswitchPassFSCToCurrentFS_X:
                pla                          ;restore request type
                jmp (hazel.activeFSCV) ;call active FS's real FSCV entry point

;-------------------------------------------------------------------------
; 
; FileSwitch FSC table
; 
fileswitchFSCRoutinesTable:
                .word fileswitchFSCOPT
                .word fileswitchFSCCheckEOF
                .word fileswitchFSCStarSlash
                .word fileswitchFSCUnknownCommand
                .word fileswitchFSCStarRUN
                .word fileswitchFSCStarCAT
                .word fileswitchFSCNewFS
                .word fileswitchFSCFileHandleRange
                .word fileswitchFSCStarCommand
                .word fileswitchFSCStarEX
                .word fileswitchFSCStarINFO
                .word fileswitchFSCRUNLibrary

;-------------------------------------------------------------------------
; 
; FSC 3 - *command [AUG p344]
; 
fileswitchFSCUnknownCommand:
                plx
                jsr getCommandLinePointer
                bra fileswitchPassFSCToCurrentFS_X

;-------------------------------------------------------------------------
; 
; FSC 1 - check EOF [AUG p343]
;
fileswitchFSCCheckEOF:
                ply                         ;Y = file handle
                phy                         ;restore stack arrangement
                jsr selectFSForHandle
                bra fileswitchPassFSCToCurrentFS

;-------------------------------------------------------------------------
; 
; FSC 0 - *OPT [AUG p343]
;
fileswitchFSCOPT:
                bit hazel.tempFSFlag   ; Check temporary fs flag
                bvs fileswitchPassFSCToCurrentFS
                lda hazel.currentFS ; Get current filing system number

;-------------------------------------------------------------------------
;
; Pass FSCV request through to a particular FS.
;
; entry:
;
; A = FS to select
;
; Y = FSCV Y
;
; S = [FSCV X; FSCV A]
;
fileswitchPassFSCToSpecificFS:
                jsr selectFS        ; Select filing system
                bra fileswitchPassFSCToCurrentFS

;-------------------------------------------------------------------------
; 
; FSC 2 - */filename [AUG p343]
; FSC 4 - *RUN filename [AUG p344]
; 
fileswitchFSCStarSlash:
fileswitchFSCStarRUN:
                plx
                jsr getCommandLinePointer ; Skip '*'s and spaces, set command line address
                phx             ; Continue on to pass to filing system


;-------------------------------------------------------------------------
;
; FSC 5 - *CAT [AUG p344]
; FSC 9 - *EX [NAUG p257]
; FSC, 10 - *INFO [NAUG p257]
; 
fileswitchFSCStarCAT:
fileswitchFSCStarEX:
fileswitchFSCStarINFO:
                plx
                asl hazel.tempFSFlag
                jsr parseFileNameAndSelectFS
                bra fileswitchPassFSCToCurrentFS_X

;-------------------------------------------------------------------------
;
; Get command line pointer.
;
; Entry:
;
; X/Y - pointer to CR-terminated command line string
;
; Exit:
;
; X/Y, (hazel.commandLinePointer) - pointer to first non-space char in
; command line string
getCommandLinePointer: .proc ;fbc1
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1

; skip spaces. Stop if terminating CR encountered.
                
                ldy #$FF                     ; FBC5= A0 FF        .
-
                iny
                lda (stringInputBufferAddress),y
                cmp #$0D
                beq +
                cmp #' '
                bne -
                
+

; Hmm. Didn't we just do this bit already?
                
                jsr skipSpacesAndCheckForCRInStringInput

; Store address of first non-space char in the HAZEL command line
; pointer.
                
                tya
                clc
                adc stringInputBufferAddress+0
                sta hazel.commandLinePointer+0
                lda stringInputBufferAddress+1
                adc #$00                     
                sta hazel.commandLinePointer+1
                ldy stringInputBufferAddress+1
                ldx stringInputBufferAddress+0
                rts                          
                .pend

;-------------------------------------------------------------------------
; 
; FSC 11 - RUN from libfs [NAUG p257]
;
fileswitchFSCRUNLibrary:
                lda hazel.libFS      ; Is a libfs set?
                bpl fileswitchPassFSCToSpecificFS
badCommandError:
                brk
                .byte 254
                .text "Bad command"
                brk

;-------------------------------------------------------------------------

                .if version==350
                .include "sram_access_helpers.s65"
                .include "sram_access_helpers_2.s65"
LF8D1: .LF8D1Macro

LF9FA:
                ; TODO - all the 0/1/2/3 references here are
                ; presumably tubeLanguageHostAddr
                
                ldy #0
                sty 0

LF9FE:
                lda (0),y
                ldx L04F9
                beq LFA18
                .if finmos329
                cmp #$80
                .else
                cmp #$7F        ; ''
                .endif
                bcc LFA18
                cmp #$C0        ; ''
                bcs LFA18
                pha
                jsr LFACE
                pla
                bcc LFA18
                clc
                adc $4F9

LFA18:
                sta $700,y
                iny
                bne LF9FE
                inc @w 1
                rts

;-------------------------------------------------------------------------

LFA22:
                sta @w tubeLanguageParasiteAddr+3
                sty @w tubeLanguageParasiteAddr+2
                bit $f4
                bvs LFA9D
                lda $8006
                and #$D
                bne LFAAB
                lda @w tubeLanguageParasiteAddr+3
                sta @w 3
                ora @w tubeLanguageParasiteAddr+2
                beq LFAAB
                lda @w tubeLanguageParasiteAddr+2
                sta @w 2
                ldy #2
                lda (2),y
                tax
                dey
                lda (2),y
                tay
                lda (2)
                sta @w 2
                sty @w 3
                lda @w tubeLanguageParasiteAddr+1
                sec
                sbc #$80        ; ''
                sta L04F9
                stz @w tubeLanguageParasiteAddr+3
                stz @w tubeLanguageParasiteAddr+2
                txa
                bpl LFA6A
                clc
                adc $f4

LFA6A:
                and #$F
                sta L04F8
                ldx $f4
                phx
                jsr selectROMA
                jsr LFAAF
                eor #$DE        ; ''
                bne LFA97
                jsr LFAAF
                eor #$C0        ; ''
                bne LFA97
                sta L04F7
                jsr LFAAF
                sta L04F6
                jsr LFAAF
                sta L04F5
                pla
                jsr selectROMA
                rts

;-------------------------------------------------------------------------

LFA97:
                pla
                jsr selectROMA
                bra LFAAB

;-------------------------------------------------------------------------

LFA9D:
                lda #$80        ; ''
                sta @w tubeLanguageParasiteAddr+1
                stz @w tubeLanguageParasiteAddr+0
                stz @w tubeLanguageParasiteAddr+2
                stz @w tubeLanguageParasiteAddr+3

LFAAB:
                stz L04F9
                rts

;-------------------------------------------------------------------------

LFAAF:       .block
                lda @w 2
                php
                dec @w 2
                plp
                bne LFABC
                dec @w 3

LFABC:
                lda $f4
                pha
                lda L04F8
                jsr selectROMA
                lda (2)
                tax
                pla
                jsr selectROMA
                txa
                rts
                .endblock

;-------------------------------------------------------------------------

LFACE:       .block
                asl L04F7
                bne locret_FADD
                jsr LFADE
                clc
                beq locret_FADD
                sec
                rol L04F7

locret_FADD:
                rts
                .endblock

;-------------------------------------------------------------------------

LFADE:       .block
                jsr LFAAF
                sta L04F7
                lda L04F5
                php
                dec L04F5
                plp
                bne LFAF1
                dec L04F6

LFAF1:
                lda L04F6
                eor #$80        ; ''
                and #$80        ; ''
                rts
                .endblock

;-------------------------------------------------------------------------

LFAF9:
                txa
                ora #$40        ; '@'
                tax
                lda #$8E        ; ''
                jmp OSBYTE

;-------------------------------------------------------------------------

LFB02:
                jsr terminal.tubeHost.getLanguageParasiteAddr
                lda #$40        ; '@'
                trb $f4
                rts

;-------------------------------------------------------------------------

                .if !finmos329
                
LFB0A:       .block
                php
                sei
                lda econetInterceptionStatus
                pha
                lda #$80        ; ''
                trb econetInterceptionStatus
                lda #$87        ; ''
                jsr OSBYTE
                pla
                sta econetInterceptionStatus
                plp
                txa
                rts
                .endblock

                .if CFA3000
LFB2F:
                ldx #size(RTC.ram)-1
LFB31:
                phx
                ldy #0
                cpx #size(CMOSBytes)
                bcs LFB3B
                ldy LFC00.LFEA2-1,x
LFB3B:
                jsr terminal.writeCMOSByte
                plx
                dex
                bne LFB31
                rts
                .endif

                .endif

                .endif


;-------------------------------------------------------------------------

                .fill $fc00-*,$ff

                .if version==350

;-------------------------------------------------------------------------
;
; Some init code - normally hidden by the I/O region

LFC00: .block
                .include "reset.s65"

softReset:
                lda #8
                jsr terminal.tsbACCCON
                stz hazel.moveSrcHandle
                stz hazel.moveDestHandle
                ldy #$CA        ; ''
                jsr insertCharacterIntoKeyboardBuffer
                jsr osbyte247EntryPoint
                lda lastBREAKType
                beq LFECD
                jsr LEDD0

LFECD:
                jsr terminal.setTSTAndReadDefaults2
                lsr a
                bcc LFEF2
                jsr terminal.readDefaults3
                lsr a
                lsr a
                lsr a
                lda #$10
                jsr terminal.trbACCCON
                bcs LFEE3

LFEE0:
                jsr terminal.tsbACCCON

LFEE3:
                jsr terminal.LE375

LFEE6:
                bcs LFEF2

LFEE8:
                lda $FC
                eor #$10
                jsr staSEIWKAAndACCCON
                jsr terminal.LE375

LFEF2:
                jmp terminal.reset
                .endblock

;-------------------------------------------------------------------------

clearAllSoundChannelBuffers: .block
                ldx #8
loop:
                dex
                jsr clearSoundChannelBuffer
                cpx #4
                bne loop
                rts
                .endblock

                .fill $ff00-*

;-------------------------------------------------------------------------

                .else                

;-------------------------------------------------------------------------
;
; Credits - normally hidden by the I/O region.
;

                .if version<500
                .text "(C) 1984 Acorn Computers Ltd."
                .text "Thanks are due to the following contributors to the BBC Computer (among others too numerous to mention):- "
                .elsif version>=500
                .if olivetti
                .text "(C) 1986 Olivetti."
                .else
                .text "(C) 1986 Acorn Computers Ltd."
                .endif
                .text "Thanks are due to the following contributors to this Computer (among many others):- "
                .endif
                .text "David Allen,"
                .if version<500
                .text "Clive Angel,"
                .endif
                .text "David Bell,"
                .text "Paul Bond,"
                .if version<500
                .text "Allen Boothroyd,"
                .endif
                .text "Julian Brown,"
                .text "Tudor Brown,"
                .if version>=500
                .text "Tim Caspell,"
                .endif
                .text "Brian Cockburn,"
                .if version>=500
                .text "Barbara Cole,"
                .endif
                .if version<500
                .text "Pete Cockerell,"
                .endif
                .text "Mark Colton,"
                .text "Chris Curry,"
                .if version>=500
                .text "Jim Day,"
                .text "Tim Dobson,"
                .endif
                .text "Joe Dunn,"
                .if version==400
                .text "Wendy Frazer,"
                .endif
                .if version<500
                .text "Paul Freakley,"
                .endif
                .if version>=500
                .text "Paul Fellows,"
                .text "Alan Fournier,"
                .endif
                .text "Steve Furber,"
                .text "Martyn Gilbert,"
                .text "John Harrison,"
                .text "Hermann Hauser,"
                .if version!=400
                .text "Mike Hill,"
                .endif
                .if version>=500
                .text "Paul Holding,"
                .endif
                .text "John Horton,"
                .if version==400
                .text "Richard Hughes,"
                .endif
                .if version>=500
                .text "Dave Ireland,"
                .endif
                .if version<500
                .text "Neil Johnson,"
                .endif
                .text "Richard King,"
                .text "David Kitson,"
                .if version>=500
                .text "Andy Knight,"
                .endif
                .text "Julian Lomberg,"
                .text "Rob Macmillan,"
                .if version>=500
                .text "Tom McNamara,"
                .endif
                .text "Richard Manby,"
                .if version<500
                .text "Peter McKenna,"
                .text "Andrew McKernan,"
                .if version==400
                .text "Mick Neal,"
                .else
                .text "Mick Neil,"
                .endif
                .text "Ian Niblock,"
                .endif
                .if version>=500
                .text "David Morgan,"
                .text "Richard Murphy,"
                .endif
                .text "Glen Nicholls,"
                .text "Robert Nokes,"
                .if version>=500
                .text "Jean Nunn,"
                .endif
                .text "Richard Page,"
                .if version<400
                .text "Steve Parsons,"
                .endif
                .if version<=400
                .text "Ed Phipps,"
                .endif
                .text "John Radcliffe,"
                .text "Rick Rand,"
                .if version>=400
                .text "Nick Reeves,"
                .endif
                .text "Brian Robertson,"
                .if version>=500
                .text "Paul Rose,"
                .endif
                .text "Richard Russell,"
                .if version<500
                .text "Gordon Sage,"
                .text "Terry Scotcher,"
                .endif
                .if version>=500
                .text "Robert Sack,"
                .text "Roger Sale,"
                .endif
                .text "David Seal,"
                .if version>=500
                .text "Phil Smith,"
                .text "Tony Sumner,"
                .endif
                .if version!=400
                .text "Paul Swindell,"
                .endif
                .text "Jon Thackray,"
                .if version>=500
                .text "Tony Thompson,"
                .endif
                .text "Hugo Tyson,"
                .if version<500
                .text "Adrian Warner,"
                .if version==400
                .text "Jes Wills,"
                .else
                .text "Jess Wills,"
                .endif
                .endif
                .if version<500
                .text "Roger Wilson,"
                .text "Graham Winterflood."
                ;.text "   "
                .endif
                .if version>=500
                .text "Roger Wilson."
                .endif
                .if version!=400
                .if olivetti
                .align 256,$ff
                .else
                .align 256,' '
                .endif
                .else
                .align 256
                .endif

;-------------------------------------------------------------------------

                .endif
                
;-------------------------------------------------------------------------

E_USERV: ; ff00
                jsr extendedVectorEntryPoint
E_BRKV: ; ff03
                jsr extendedVectorEntryPoint
E_IRQ1V: ; ff06
                jsr extendedVectorEntryPoint
E_IRQ2V: ; ff09
                jsr extendedVectorEntryPoint
E_CLIV: ; ff0c
                jsr extendedVectorEntryPoint
E_BYTEV: ; ff0f
                jsr extendedVectorEntryPoint
E_WORDV: ; ff12
                jsr extendedVectorEntryPoint
E_WRCHV: ; ff15
                jsr extendedVectorEntryPoint
E_RDCHV: ; ff18
                jsr extendedVectorEntryPoint
E_FILEV: ; ff1b
                jsr extendedVectorEntryPoint
E_ARGSV: ; ff1e
                jsr extendedVectorEntryPoint
E_BGETV: ; ff21
                jsr extendedVectorEntryPoint
E_BPUTV: ; ff24
                jsr extendedVectorEntryPoint
E_GBPBV: ; ff27
                jsr extendedVectorEntryPoint
E_FINDV: ; ff2a
                jsr extendedVectorEntryPoint
E_FSCV: ; ff2d
                jsr extendedVectorEntryPoint
E_EVENTV: ; ff30
                jsr extendedVectorEntryPoint
E_UPTV: ; ff33
                jsr extendedVectorEntryPoint
E_NETV: ; ff36
                jsr extendedVectorEntryPoint
E_VDUV: ; ff39
                jsr extendedVectorEntryPoint
E_KEYV: ; ff3c
                jsr extendedVectorEntryPoint
E_INSV: ; ff3f
                jsr extendedVectorEntryPoint
E_REMV: ; ff42
                jsr extendedVectorEntryPoint
E_CNPV: ; ff45
                jsr extendedVectorEntryPoint
E_IND1V: ; ff48
                jsr extendedVectorEntryPoint
E_IND2V: ; ff4b
                jsr extendedVectorEntryPoint
E_IND3V: ; ff4e
                jsr extendedVectorEntryPoint

;-------------------------------------------------------------------------

extendedVectorEntryPoint:
                ; .if CFA3000
                ; ;...
                ; .else
                ; $10b,x = rL
                pha                 ; $10a,x  (old ROMSEL)
                pha                 ; $109,x  (old ACCCON)
                pha                 ; $108,x  (thunk rH)
                pha                 ; $107,x  (thunk rL)
                pha                 ; $106,x  (jump dest MSB)
                pha                 ; $105,x  (jump dest LSB)
                php                 ; $104,x  (P for RTI)
                pha                 ; $103,x  (old A)
                phx                 ; $102,x  (old X)
                phy                 ; $101,x  (old Y)
                tsx
                lda #>extendedVectorReturnThunk-1
                sta $0108,x
                lda #<extendedVectorReturnThunk-1
                sta $0107,x

                ; this routine is only ever called from $ff00, $ff03,
                ; $ff06, etc. - so rL holds vectorIndex*3+2, suitable
                ; for indexing into the extended vector space.
                ldy $010B,x                  ;Y=vectorIndex*3+2
                lda extendedVectorSpace-2,y  ;get vector LSB
                sta $0105,x                  ;
                lda extendedVectorSpace-1,y  ;get vector MSB
                sta $0106,x
                lda $F4
                sta $010A,x
                lda ACCCON
                sta $0109,x

                ; New stack layout:
                ; 
                ; $10a,x - old ROMSEL
                ; $109,x - old ACCCON
                ; $108,x - thunk rH
                ; $107,x - thunk rL
                ; $106,x - jump dest MSB
                ; $105,x - jump dest LSB
                ; $104,x - P (for RTI)
                ; $103,x - old A
                ; $102,x - old X
                ; $101,x - old Y
                
                jsr mos.selectHAZEL
                lda extendedVectorSpace,y    ;get vector ROM number
                jsr mos.selectROMA
                ply
                plx
                pla
                rti
;                .endif

;-------------------------------------------------------------------------

extendedVectorReturnThunk:
                php                          ; FF8D= 08          .
                pha                          ; FF8E= 48          H
                phx                          ; FF8F= DA          Z
                tsx                          ; FF90= BA          :
                lda $0102,x                  ; FF91= BD 02 01    =..
                sta $0106,x                  ; FF94= 9D 06 01    ...
                lda $0103,x                  ; FF97= BD 03 01    =..
                sta $0107,x                  ; FF9A= 9D 07 01    ...
                plx                          ; FF9D= FA          z
                pla                          ; FF9E= 68          h
                pla                          ; FF9F= 68          h
                pla                          ; FFA0= 68          h
                jsr mos.selectMOSOrHAZEL     ; FFA1= 20 B0 ED     0m
                pla                          ; FFA4= 68          h
                jsr mos.selectROMA           ; FFA5= 20 92 E5     .e
                pla                          ; FFA8= 68          h
                plp                          ; FFA9= 28          (
rtsFFAA:
                rts                          ; FFAA= 60          `

;-------------------------------------------------------------------------
;
; OSBYTE 150 (&96) Read from SHEILA (&FE00 – &FEFF) [MasRef D.2-45]
; 
osbyte96:
                ldy $fe00,x
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 157 (&9D) Write byte across Tube [MasRef D.2-48]
; 
osbyte9D:
                txa
                bra OSBPUT

                brk

;-------------------------------------------------------------------------

; MOS block ends here, so that the standard entry points have
; unadorned names.
;
; A couple of the E_ entry points need namespacing in the Terminal
; ROM.
                .endblock
                

;-------------------------------------------------------------------------
OSWRSC:
                jmp mos.oswrscEntryPoint ; FFB3
                .byte mos.defaultVectorTable.end-mos.defaultVectorTable ;
                .word mos.defaultVectorTable ;
OSRDSC:
                jmp mos.osrdscEntryPoint ; FFB9
VDUCHR:
                jmp mos.vduChrEntryPoint ; FFBC
OSEVEN:
                jmp mos.eventEntryPoint ; FFBF
GSINIT:
                jmp mos.gsinitEntryPoint ; FFC2
GSREAD:
                jmp mos.gsreadEntryPoint ; FFC5
NVRDCH:
                jmp mos.osrdchEntryPoint                    ; FFC8
NVWRCH:
                jmp mos.oswrchEntryPoint                    ; FFCB
OSFIND:
                jmp mos.osfindEntryPoint                    ; FFCE
OSGBPB:
                jmp mos.osgbpbEntryPoint                    ; FFD1
OSBPUT:
                jmp mos.osbputEntryPoint                    ; FFD4
OSBGET:
                jmp mos.osbgetEntryPoint                    ; FFD7
OSARGS:
                jmp mos.osargsEntryPoint ; FFDA
OSFILE:         
                jmp mos.osfileEntryPoint ; FFDD
OSRDCH:
                jmp (RDCHV)                  ; FFE0
OSASCI:
                cmp #$0D                     ; FFE3
                bne OSWRCH                   ; FFE5
OSNEWL:
                lda #$0A                     ; FFE7
                jsr OSWRCH                   ; FFE9
                lda #$0D                     ; FFEC
OSWRCH:
                jmp (WRCHV)                  ; FFEE
OSWORD:
                jmp (WORDV)                  ; FFF1
OSBYTE:
                jmp (BYTEV)                  ; FFF4
OSCLI:
                jmp (CLIV)                  ; FFF7

LFFFA:                                       ; FFFA NMIV
                .word nmiEntryPoint
LFFFC:                                       ; FFFB RESETV
                .word mos.resetEntryPoint
LFFFE:                                       ; FFFE IRQV
                .word mos.irqEntryPoint

                