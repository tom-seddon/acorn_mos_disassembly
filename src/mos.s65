; -*- comment-column:45; -*-

testVDU5State: .macro
                .if fasterOSWRCH
                lda STATE
                and #STATE.isVDU5
                .else
                jsr testVDU5StateNonInlined
                .endif
                .endmacro
                
; VDU driver entry block
; ======================
LC000:                                       ; Read from VDU memory
                lda (ZMEMG),y
                rts
LC003:                                       ; Write to VDU memory
                sta (ZMEMG),y
                rts

; MasRef E.4-6
;
; JSR PLBYTE plots the mask held in ZMASK into the byte pointed to by
; (ZMEMG),y, using ZGORA and ZGEOR as colour masks. See GADDR below
; for an example of its use.
;
; PLBYTE uses ZTEMP as workspace and preserves X, Y, V and C.
PLBYTE:
                jmp plbyteEntryPoint

; MasRef E.4-6
;
; JSR HPLOT plots a fast horizontal line in the current graphics
; colour or ECF and the current graphics mode (all as set by VDU 18)
; between two specified points. It is the low level primitive used by
; all the MOS area fill commands.
;
; On entry, two 4 byte areas at &300+X and &300+Y contain the
; coordinates of the two endpoints, in the standard
; lowX,highX,lowY,highY order. Should the Y coordinates differ, the Y
; coordinate of the line plotted is taken from the leftmost of the two
; points specified.
;
; Only portions of the line inside the graphics window are plotted.
; Subject to this, both endpoints of the line are plotted.
;
; HPLOT uses ZGORA, ZGEOR, ZMASK, ZMEMG, ZTEMP (but not ZTEMP+1),
; ZTEMPB, ZTEMPB+1, ZTEMPC and ZTEMPC+1 as workspace. No registers or
; flags are preserved.
HPLOT:
                jmp LDAE8

; MasRef E.4-6
;
; JSR EIGABS converts the 4 byte pair of external coordinates at
; &300+X where X>=2 (in standard lowX,highX,lowY,highY order) into the
; corresponding pair of pixel coordinates by offsetting by the
; graphics origin, then dividing by an appropriate power of 2.
;
; EIGABS uses ZTEMP as workspace, and corrupts all registers and
; flags.
EIGABS:
                jmp eigabsEntryPoint

; MasRef E.4-7
;
; JSR WIND windows the 4 byte pair of pixel coordinates (in standard
; lowX,highX,lowY,highY order) at &300+X, and returns a result in A
; according to its position with respect to the window:

; 9 | 8 | 10
; --+---+---
; 1 | 0 | 2
; --+---+---
; 5 | 4 | 6

; WIND uses ZTEMP as workspace, preserves X and sets N and Z according
; to A.
WIND:
                jmp windEntryPoint

; MasRef E.4-7
;
; JSR GADDR addresses the pixel whose 4 byte pair of pixel coordinates
; (in standard lowX,highX,lowY,highY order) is at &300+X. GADDR should
; not be called without first ensuring (typically by means of WIND)
; that the point concerned does lie within the screen.
;
; GADDR initialises the following variables:
;
; . ZMEMG to the start of the page of memory containing the pixel.
;
; . Y and VDU variable &1A (i.e. location &31A) to contain the offset
; of the byte containing the pixel within this page - i.e. (ZMEMG),y
; points to the byte containing the pixel.
;
; . ZMASK to a mask indicating which bits of this byte constitute the
; pixel.
;
; . ZGORA and ZGEOR to the correct colour masks for the current
; graphics plot mode (found in VDU variable &5A) and colour/ECF
;
; . X to Y MOD 7, i.e. the scan line within a character row of the
; pixel.
;
; Additionally, GADDR uses ZTEMP as workspace and returns A=0, Z=1.
;
; An example of the use of PLBYTE, WIND and GADDR is the following
; code, which effectively re-implements the VDU 25 64-71 (plot a
; point) calls. It assumes that the routine addresses have been
; previously defined and that the graphics plot mode, etc. were set up
; by the VDU 25 code before the unknown PLOT codes vector was entered:

; .POINT
;  LDX #&20   ;Addresses new point within VDU queue, as
;             ;left on entry to the unknown PLOT codes
;             ;vector.
;  JSR WIND   ;Is the point inside the window?
;  BNE END    ;Return if not.
;  JSR GADDR  ;Address the point now we know it's on
;             ;screen.
;  JSR PLBYTE ;And plot the point.
; .END
;  RTS
GADDR:
                jmp gaddrEntryPoint

; MasRef E.4-8
;
; JSR IEG takes the internal pixel coordinates of the graphics cursor
; (in VDU variables &24-&27), converts it back to external coordinates
; and stores the result in VDU variables &10-&13.
;
; It should be called whenever the graphics code generates a new
; graphics cursor position (e.g. in the VDU drivers, it is called
; after a character is printed in VDU 5 mode). Its purpose is to make
; the two versions of the graphics cursor agree again, and thus
; prevent errors occurring with relative plots.
;
; IEG uses no page zero locations and corrupts all registers and
; flags.
IEG:
                jmp LC4DF

;-------------------------------------------------------------------------

LC018:                                       ; Fetch byte from ROM Y
                ldx $F4                      ; Get current ROM
                sty $F4                      ; Select ROM in Y
                sty ROMSEL
                lda ($F6)                    ; Get byte with ROM Y paged in
                jmp selectROMX                    ; Page in ROM X and return

LC024:
                jmp (vduv.jumpVector)

;-------------------------------------------------------------------------
;
; VDU driver entry point
;
; Output to VDU.
;
outputToVDU:
                ldx vduQueueNegativeLength  ;get VDU queue length
                beq outputCharToVDU         ;taken if empty
                sta vduv.queueEnd-1-255,x   ;add to queue
                inc vduQueueNegativeLength  ;one more in the queue...
                beq outputQueueToVDU        ;taken if queue now filled
clc_rts_c034:
                clc

;-------------------------------------------------------------------------
;
; VDU 0 (&00) Null [MasRef E.3-1]
; VDU 6 (&06) Enable VDU driver [MasRef E.3-3]
; VDU 27 (&1B) Null [MasRef E.3-34]
;
vdu0EntryPoint:
vdu6EntryPoint:
vdu27EntryPoint:
rtsC035:
                rts

;-------------------------------------------------------------------------

outputQueueToVDU:
                bit STATE
                bpl LC053              ;branch taken if not VDU21 mode

                ; VDU disabled. But if outputting to printer
                ; specifically with VDU1, let the char through,
                ldy vduv.jumpVector+1
                cpy #>vdu1EntryPoint
                bne clc_rts_c034
                ldy vduv.jumpVector+0
                cpy #<vdu1EntryPoint
                bne clc_rts_c034

outputCharToPrinter:
                tax                          ;save char to print
                lda STATE
                lsr a                       ;C set if isPrinterEnabled
                bcc rtsC035 ;taken if printer disabled - VDU 1 then a no-op
                txa                          ;restore char to print
                clc
                .if version<350
                jmp LE8B9
                .else
                jmp LE2ED
                .endif

LC053:
                jsr stopCursorEditing
                clc
                bra LC0C0

outputCharToVDU:
                .if fasterOSWRCH
                ; Skip stopCursorEditing if it'll be a no-op.
                bit STATE
                bvc LC06D
                .endif
                jsr stopCursorEditing
                .if fasterOSWRCH
                ; Already covered the not editing case above.
                .else
                bvc LC06D             ;taken if not previously editing
                .endif
                bmi LC06D             ;taken if VDU 21
                cmp #$0D
                bne LC06D                  ;taken if not printing a CR
                pha                        ;save char to print
                lda #STATE.isCursorEditing|STATE.isScrollingDisabled
                trb STATE
                jsr showCursor
                pla                          ;restore char to print
LC06D:
                cmp #$20
                bcc handleControlChar
                cmp #$7F
                bne handlePrintableChar       ;taken if not backspace
                lda #$20 ;backspace is entry 32 in the VDU routines table
handleControlChar:
                tay                          ;Y=index in table
                lda vduRoutinesLSBTable,y
                sta vduv.jumpVector+0 ; Store jump address LSB (see MasRef E.4-3)
                lda vduRoutinesMSBTable,y
                bmi LC0B3           ;branch taken if MSB directly
                tax                          ; Save original MSB value
                ora #$F0
                sta vduQueueNegativeLength ;initialise initial VDU queue length
                txa                          ; Restore original MSB value
                .if version==350&&!fasterOSWRCH
                jsr LE520
                .else
                lsr a                        ;
                lsr a                        ;
                lsr a                        ;
                lsr a                        ; Extract value in top 4 bits
                .endif
                clc                          ;
                adc #vduRoutinesPage         ; form MSB
                sta vduv.jumpVector+1
                bra reinstateCursorEditing                    ; Continue

handlePrintableChar:
                bit STATE
                bmi LC0C7                    ;taken if VDU21
                jsr plotCharAtTextCursor
                lda #vduv.cursorFlags.noMoveCursorAfterPrint
                bit vduv.cursorFlags
                bne LC0C7                    ; taken if not moving cursor
                .if fasterOSWRCH
                .cerror vduv.cursorFlags.noMoveCursorAfterPrint!=$20
                jsr LC276withAccumulator20
                .else
                jsr LC276
                .endif
                bra LC0C7

LC0A9:
                eor #$06                     ; compare to VDU6?
                bne LC0C5                    ; taken if not VUD6
                lda #STATE.isVDU21
                trb STATE                    ; reset VDU21 flag
                bra reinstateCursorEditing

LC0B3:
                sta vduv.jumpVector+1

                .if !fasterOSWRCH
                tya
                eor #$F7
                cmp #$FA
                .endif
                
                tya
                bit STATE
                bmi LC0A9             ;branch taken if VDU21 in effect
LC0C0:
                php
                jsr LC024
                plp
LC0C5:
                bcc reinstateCursorEditing
LC0C7:
                lda STATE
                lsr a                          ;C=1 if printer enabled
reinstateCursorEditing:
                bit STATE
                bvc rtsC0E1               ;taken if not cursor editing
                jsr activateEditCursor
exchangeCursors:
                php
                pha
                lda STATE
                eor #STATE.isScrollingDisabled
                sta STATE
                jsr exchangeEditCursorPositionAndTextCursorPosition
                jsr updateCRTCTextCursor
                pla
                plp
rtsC0E1:
                rts

;-------------------------------------------------------------------------
;
; VDU 1 (&01) Send next character to printer only [MasRef E.3-2]
;
vdu1EntryPoint:
                jsr reinstateCursorEditing
                jsr outputCharToPrinter
                bra stopCursorEditing

;-------------------------------------------------------------------------
;
; VDU 2 (&02) Enable printer [MasRef E.3-2]
; VDU 3 (&03) Disable printer [MasRef E.3-3]
;
vdu2EntryPoint:
vdu3EntryPoint:
                pha                          ;
                jsr reinstateCursorEditing
                .if version<350
                jsr callPrinterDriverWithPrinterBuffer
                .else
                jsr LE2E7
                .endif
                lda #STATE.isPrinterEnabled  ;
                tsb STATE
                pla
                and #STATE.isPrinterEnabled
                trb STATE

;-------------------------------------------------------------------------
;
; Stop cursor editing, if it's on.
;
; exit:
;
; V=1 if cursor editing previous on
; N=1 if VDU 21 on
;
stopCursorEditing:
                bit STATE
                bvc rtsC0E1                    ;taken if not cursor editing
                jsr exchangeCursors
                php
deactivateEditCursor:
                sec
                bra updateEditCursorState

;-------------------------------------------------------------------------

activateEditCursor:
                php
                clc

;-------------------------------------------------------------------------
;
; Handle cursor editing on/off.
;
; entry:
;
; C=0 - cursor editing on; add fake cursor
;
; C=1 = cursor editing off; remove fake cursor and restore screen
;
updateEditCursorState: .proc
                pha
                lda ZMEMT+0
                sta ZTEMPD+0
                lda ZMEMT+1
                sta ZTEMPD+1
                ldy vduv.bytesPerCharacter
                dey
                bne bitmap

teletext:
                lda vduv.workspace._38 ;get old byte under fake cursor (may be bogus)
                bcs storeToScreen      ;taken if switching off
                lda (ZMEMT)            ;get screen byte
                sta vduv.workspace._38 ;store old byte
                lda #$7F               ;store solid block to screen
                bra storeToScreen

bitmap:
                lda #%11111111          ;invert all bits
                cpy #$1F      ;check for 32 chars/byte - i.e., MODE 2
                bne +         ;taken if not MODE 2
                lda #%00111111       ;avoid flashing colours in MODE 2
+
                sta ZTEMP
loop:
                lda (ZTEMPD)
                eor ZTEMP
storeToScreen:
                sta (ZTEMPD)
                inc ZTEMPD+0
                bne +                    ;taken if no carry out of LSB
                inc ZTEMPD+1
                bpl +                 ;taken if no screen address wrap
                lda vduv.startScreenAddressHighByte
                sta ZTEMPD+1
+
                dey               ;Y=$ff after 1 iteration in teletext
                bpl loop
                pla
                plp
                rts
                .endproc

;-------------------------------------------------------------------------

LC147:
                .word LC1BE
                .word LC1B1
                .word LC1BE
                .word LC1B1
                .word LC195
                .word LC195
                .word LC1A2
                .word LC1A2

;-------------------------------------------------------------------------

LC157:
                .word LC201
                .word LC1EE
                .word LC201
                .word LC1EE
                .word LC221
                .word LC221
                .word LC210
                .word LC210

;-------------------------------------------------------------------------
;
; Indexed by the swapAxes, invertVertical and invertHorizontal cursor
; flags bits.
;
setTextCursorXPositionRoutinesTable:
                .word setTextCursorXPosition           ;0
                .word setTextCursorXPositionInvertHorizontal ;invertHorizontal
                .word setTextCursorXPosition ;invertVertical
                .word setTextCursorXPositionInvertHorizontal ;invertVertical|invertHorizontal
                .word setTextCursorXPositionSwapAxes         ;swapAxes
                .word setTextCursorXPositionSwapAxes ;swapAxes|invertHorizontal
                .word setTextCursorXPositionSwapAxesInvertVertical ;swapAxes|invertVertical
                .word setTextCursorXPositionSwapAxesInvertVertical ;swapAxes|invertVertical|invertHorizontal

;-------------------------------------------------------------------------

moveTextCursorRoutinesTable:
                .word moveTextCursorPositiveX
                .word moveTextCursorNegativeX
                .word moveTextCursorPositiveX
                .word moveTextCursorNegativeX
                .word moveTextCursorPositiveY
                .word moveTextCursorPositiveY
                .word moveTextCursorNegativeY
                .word moveTextCursorNegativeY

;-------------------------------------------------------------------------

LC187:
                eor vduv.cursorFlags
                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal)
                pha
                jsr LD1A6
                plx
                sec
                jmp (LC147,x)

LC195:
                lda $0326
                sbc #$08
                sta $0326
                dec $0327
                bra LC1AA

LC1A2:
                lda $0326
                adc #$07
                sta $0326
LC1AA:
                bcc LC1CB
                inc $0327
                bra LC1CB

LC1B1:
                lda $0324
                sbc #$08
                sta $0324
                dec $0325
                bra LC1C6

LC1BE:
                lda $0324
                adc #$07
                sta $0324
LC1C6:
                bcc LC1CB
                inc $0325
LC1CB:
                lda $DA
                bne LC1DB
                bit $0366
                bvs LC1DB
                phx
                jsr LD1A6
                plx
                tay
                rts

LC1DB:
                lda #$00
                rts

LC1DE:
                lda #$00
LC1E0:
                stz $DA
                asl a
                rol $DA
                asl a
                rol $DA
                asl a
                rol $DA
                jmp (LC157,x)

LC1EE:
                eor #$F9
                adc $0304
                sta $0324
                lda $DA
                eor #$FF
                adc $0305
                sta $0325
                rts

LC201:
                adc $0300
                sta $0324
                lda $DA
                adc $0301
                sta $0325
                rts

LC210:
                eor #$07
                adc $0302
                sta $0326
                lda $DA
                adc $0303
                sta $0327
                rts

LC221:
                sec
                eor #$FF
                adc $0306
                sta $0326
                lda $DA
                eor #$FF
                adc $0307
                sta $0327
                rts

LC235:
                lda #$00
                jsr LC187
                beq LC249
                jsr LC1DE
LC23F:
                lda #$08
LC241:
                jsr LC187
                beq LC249
                jsr LC1DE
LC249:
                jmp LC4DF

vdu9EntryPoint:
                jsr handleColumn81
                bcs LC235
                lda #$00                     ; X+
                jsr moveTextCursor
                bcc LC273
LC258:
                jsr LC38F
vdu10EntryPoint:
                .testVDU5State
                bne LC23F
                clc
                jsr LC88E
                lda #$08
                jsr moveTextCursor           ; Y-
LC269:
                bcc LC273
                jsr LC37B
                bcc LC273
                jmp LD051

LC273:
                jmp updateCRTCCursorAddress

LC276:
                .if fasterOSWRCH
                .cerror STATE.isVDU5!=$20
                lda #STATE.isVDU5
LC276withAccumulator20:
                and STATE
                .else
                jsr testVDU5StateNonInlined
                .endif
                ; .testVDU5State
                bne LC235                    ; taken if VDU5
                jsr moveTextCursor           ; A=0, so X+
                bcc LC273
                lda #vduv.cursorFlags.scrollProtect
                bit vduv.cursorFlags
                beq LC258
                sec
                ror vduv.column81
LC28B:
                rts

LC28C:
                lda #$06
                jsr LC187
                beq LC249
                jsr LC1DE
LC296:
                lda #$0E
                bra LC241

vdu8EntryPoint:
                .testVDU5State
                bne LC28C
                lsr $036C
                bit $036C
                bvs LC28B
                lda #$06
                jsr moveTextCursor           ; X-
                bcc LC273
                jsr LC38F
vdu11EntryPoint:
                .testVDU5State
                bne LC296
                dec pagedModeCounter
                bpl LC2BE
                inc pagedModeCounter
LC2BE:
                lda #$0E
                jsr moveTextCursor           ; Y+
                bra LC269

;-------------------------------------------------------------------------
;
; Set/reset cursor position, taking cursor flags into account.
;
; entry:
;
; (set only) A = cursor position
;
; X = cursorFlags bits: swapAxes, invertVertical, invertHorizontal
;
resetTextCursorXPositionWithCursorFlags:
                lda #$00
setTextCursorXPositionWithCursorFlags:
                clc
                jmp (setTextCursorXPositionRoutinesTable,x)

;-------------------------------------------------------------------------

setTextCursorXPositionInvertHorizontal:
                sec                          ;+1
                eor #$FF          ;^$ff+1 (i.e., adc will add the -ve)
                adc vduv.textWindowRight
                bra staTextCursorXPosition

;-------------------------------------------------------------------------

setTextCursorXPosition:
                adc vduv.textWindowLeft
staTextCursorXPosition:
                sta vduv.textCursorXPosition
                rts

;-------------------------------------------------------------------------

setTextCursorXPositionSwapAxesInvertVertical:
                sec
                eor #$FF
                adc vduv.textWindowBottom
                bra staTextCursorYPosition

setTextCursorXPositionSwapAxes:
                adc vduv.textWindowTop
staTextCursorYPosition:
                sta vduv.textCursorYPosition
                rts

;-------------------------------------------------------------------------
;
; Move text cursor.
;
; Entry:
;
; A = direction to move: 0 = X+
;                        2 = X-
;                        4 = X+
;                        6 = X-
;                        8 = Y-
;                        10 = Y-
;                        12 = Y+
;                        14 = Y+
;
; Exit:
;
; X = actual jump table index
; C = something...

                .if !fasterOSWRCH
moveTextCursor:
                eor vduv.cursorFlags
                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal)
                tax
                .cerror *!=callMoveTextCursorRoutine
                .endif
callMoveTextCursorRoutine:
                jmp (moveTextCursorRoutinesTable,x)
                
;-------------------------------------------------------------------------

moveTextCursorNegativeX:
                lda vduv.textWindowLeft
                cmp vduv.textCursorXPosition
                bcs rtsC337
                dec vduv.textCursorXPosition
                sec
                lda vduv.textCursorCRTCAddress+0
                sbc vduv.bytesPerCharacter
                sta vduv.textCursorCRTCAddress+0
                sta ZMEMT+0
                bcs clc_rts_C336
                dec vduv.textCursorCRTCAddress+1
                bra fixUpZMEMTHiFromTextCursorCRTCAddressHi

;-------------------------------------------------------------------------

                .if fasterOSWRCH
moveTextCursor:
                eor vduv.cursorFlags
                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal)
                tax
                bne callMoveTextCursorRoutine
                .cerror *!=moveTextCursorPositiveX
                .endif
                
moveTextCursorPositiveX:
                lda vduv.textCursorXPosition
                cmp vduv.textWindowRight
                bcs rtsC337
                inc vduv.textCursorXPosition
                lda vduv.textCursorCRTCAddress+0
                adc vduv.bytesPerCharacter
                sta vduv.textCursorCRTCAddress+0
                sta ZMEMT+0
                bcc rtsC337
                inc vduv.textCursorCRTCAddress+1
fixUpZMEMTHiFromTextCursorCRTCAddressHi:
                lda vduv.textCursorCRTCAddress+1
fixUpZMEMTHi:
                bpl LC334
                sec
                sbc vduv.screenSizeHighByte
LC334:
                sta ZMEMT+1
clc_rts_C336:
                clc
rtsC337:
                rts

;-------------------------------------------------------------------------

moveTextCursorNegativeY:
                lda vduv.textWindowTop
                cmp vduv.textCursorYPosition
                bcs rtsC337
                dec vduv.textCursorYPosition
                sec
                lda vduv.textCursorCRTCAddress+0
                sbc $0352
                sta vduv.textCursorCRTCAddress+0
                sta ZMEMT+0
                lda vduv.textCursorCRTCAddress+1
                sbc $0353
                sta vduv.textCursorCRTCAddress+1
                bra fixUpZMEMTHi

;-------------------------------------------------------------------------

moveTextCursorPositiveY:
                lda vduv.textCursorYPosition
                cmp vduv.textWindowBottom
                bcs rtsC337
                inc vduv.textCursorYPosition
                lda vduv.textCursorCRTCAddress+0
                adc vduv.bytesPerCharacterRow+0
                sta vduv.textCursorCRTCAddress+0
                sta ZMEMT+0
                lda vduv.textCursorCRTCAddress+1
                adc vduv.bytesPerCharacterRow+1
                sta vduv.textCursorCRTCAddress+1
                bra fixUpZMEMTHi

;-------------------------------------------------------------------------

LC37B:
                lda #vduv.cursorFlags.noVerticalScroll
                bit vduv.cursorFlags
                bne LC38F
                txa
                eor #$06
                pha
                lda #STATE.isCursorEditing|STATE.isScrollingDisabled
                bit STATE
                beq LC3A2
                bvs LC397
                pla
LC38F:
                jsr resetTextCursorXPositionWithCursorFlags
                jsr updateZMEMTWithTextCursorPosition
                clc
                rts

LC397:
                jsr exchangeEditCursorPositionAndTextCursorPosition
                plx
                phx
                jsr callMoveTextCursorRoutine
                jsr exchangeEditCursorPositionAndTextCursorPosition
LC3A2:
                plx
                sec
rtsC3A4:
                rts

;-------------------------------------------------------------------------

vdu28EntryPoint:
                ldx vduv.currentScreenMODE
                lda vduv.queueEnd-3          ; max Y
                cmp vduv.queueEnd-1          ; min Y
                bcc rtsC3A4                  ; bail if max Y<min Y
                cmp modeMaxRow,x             ; 
                beq +                        ; taken if max Y==max row
                bcs rtsC3A4                  ; bail if max Y>max row
+
                lda vduv.queueEnd-2          ; max X
                cmp modeMaxColumn,x
                beq +                        ; taken if max X==max col
                bcs rtsC3A4                  ; bail if max X>max col
                sec
+
                sbc vduv.queueEnd-4          ; form window width
                bcc rtsC3A4                  ; bail if negative
                jsr setTextWindowWidthInBytes
                lda #STATE.isTextWindow
                tsb STATE                    ; set isTextWIndow bit

                ; set text window value from the 4 VDU 28 argument
                ; bytes in the VDU queue
                ldx #VDUVariables.queueEnd-4
                ldy #VDUVariables.textWindowLeft
                jsr copyFourBytesWithinVDUVariables
                
                jsr exchangeEditCursorPositionAndTextCursorPosition
                jsr updateZMEMTWithTextCursorPositionIfValid
                bcc LC3E0         ; taken if text cursor pos was valid
                jsr resetTextCursorPosition
LC3E0:
                jsr exchangeEditCursorPositionAndTextCursorPosition
                jsr updateZMEMTWithTextCursorPositionIfValid
                bcc LC407         ; taken if text cursor pos was valid
resetTextCursorPosition:
                lda STATE
                pha
                and #~STATE.isVDU5
                sta STATE
                jsr vdu30EntryPoint
                pla
                sta STATE
                rts

vdu13EntryPoint:
                lda vduv.cursorFlags
                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal;$0E
                tax
                .testVDU5State
                bne LC40A
                lsr vduv.column81
                jsr LC38F
LC407:
                jmp updateCRTCCursorAddress

LC40A:
                jsr LC1DE
                jmp LC4DF

jsrVDU30EntryPoint:
                jsr vdu30EntryPoint

;-------------------------------------------------------------------------
;
; VDU 16 (&10) Clear graphics window [MasRef E.3-7]
;
vdu16EntryPoint:
                lda vduv.pixelsPerByteMinusOne
                beq rtsC3A4                    ;taken if MODE 7
                ldx #VDUVariables.graphicsWindowPixelsLeft
                jsr copyEightBytesToWorkspace28
                jsr prepareForPlotBackground
LC420:
                ldx #$2A
                ldy #$2E
                jsr exchangeTwoVDUBytes
LC427:
                ldx #$28
                ldy #$2C
                jsr LDAE8
                lda $032A
                bne LC436
                dec $032B
LC436:
                dec $032A
                lda $032A
                cmp $032E
                lda $032B
                sbc $032F
                bpl LC427
                rts

LC448:
                ldx #VDUVariables.queueEnd-4
                jsr prepareAABB
                bra LC420

;-------------------------------------------------------------------------
;
; VDU 12 (&0C) Clear text window [MasRef E.3-5]
;
vdu12EntryPoint:
                lda #STATE.isVDU5
                bit STATE
                bne jsrVDU30EntryPoint       ;taken if VDU 5 mode
                lda #STATE.isTextWindow
                bit STATE
                bne clearTextWindow                    ;taken if text window
                jmp clsFastPath

                ; Clear screen within text window
                ; -------------------------------
clearTextWindow:
                jsr copyTextWindowWidthInBytesToWorkspace28
                ldx vduv.textWindowLeft
                stx vduv.textCursorXPosition
                ldx vduv.textWindowTop
clearTextWindowRowsLoop:
                stx vduv.textCursorYPosition
                jsr updateZMEMTWithTextCursorPosition
                jsr LCAE8
                ldx vduv.textCursorYPosition
                cpx vduv.textWindowBottom
                inx
                bcc clearTextWindowRowsLoop

;-------------------------------------------------------------------------
;
; VDU 30 (&1E) Home cursor [MasRef E.3-36]
;
vdu30EntryPoint:
                ; pretend it's VDU 31,0,0
                stz vduv.queueEnd-1
                stz vduv.queueEnd-2

;-------------------------------------------------------------------------
;
; VDU 31 (&1F) Tab cursor [MasRef E.3-36]
;
vdu31EntryPoint:
                lda vduv.cursorFlags
                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
                tax
LC488:
                .testVDU5State
                bne LC4CF                    ;taken if VDU 5
                lda vduv.textCursorXPosition
                pha                          ;save old X pos
                lda vduv.textCursorYPosition
                pha                          ;save old Y pos
                lda vduv.queueEnd-2          ;X coordinate
                jsr setTextCursorXPositionWithCursorFlags
                phx                          ;save true cursorFlags bits
                txa
                eor #vduv.cursorFlags.swapAxes ;cheekily do the other axis by just changing the cursor flags
                tax
                lda vduv.queueEnd-1          ;Y coordinate
                jsr LCCD7
                plx                    ;restore true cursorFlags bits
                bcc LC4BA              ;taken if no scrolling required
                lda #vduv.cursorFlags.scrollProtect
                bit $0366
                beq LC4C1                 ;taken if scroll protect off

                ; Wrap text cursor X.
                lda vduv.queueEnd-2       ;X coordinate
                dec a
                jsr LCCD7
                bcs LC4C1
                sec
LC4BA:
                ror vduv.column81
                pla                          ;discard old Y pos
                pla                          ;discard old X pos
                bra LC4CC

LC4C1:
                pla
                sta vduv.textCursorYPosition ;restore old Y pos
                pla
                sta vduv.textCursorXPosition ;restore old X pos
                jsr updateZMEMTWithTextCursorPosition
LC4CC:
                jmp updateCRTCCursorAddress

LC4CF:
                lda $0322
                jsr LC1E0
                txa
                eor #$08
                tax
                lda $0323
                jsr LC1E0
LC4DF:
                ldy #$10
                jsr copyGraphicsCursorPixels
                ldx #$02
                ldy #$02
                jsr LC4FC
                ldx #$00
                ldy #$04
                lda $0361
LC4F2:
                dey
                lsr a
                bne LC4F2
                lda $0356
                beq LC4FC
                iny
LC4FC:
                asl $0310,x
                rol $0311,x
                dey
                bne LC4FC
                sec
                jsr LC50A
                inx
LC50A:
                lda $0310,x
                sbc $030C,x
                sta $0310,x
                rts

;-------------------------------------------------------------------------
;
; VDU 14 (&0E) Page mode on [MasRef E.3-6]
;
vdu14EntryPoint:
                stz pagedModeCounter
                lda #$91

;-------------------------------------------------------------------------
;
; VDU 21 (&15) Disable VDU driver [MasRef E.3-11]
;
vdu21EntryPoint:
                eor #$95
LC51B:
                tsb STATE
                rts

;-------------------------------------------------------------------------
;
; VDU 4 (&04) Print at text cursor [MasRef E.3-2]
;
vdu4EntryPoint:
                lda $0361
                beq LC52C
                jsr showCursor
                lda #$2B

                ; fall through to vdu15EntryPoint

;-------------------------------------------------------------------------
;
; VDU 15 (&0F) Page mode off [MasRef E.3-6]
;
vdu15EntryPoint:
                eor #$0B
                trb STATE
LC52C:
                rts

;-------------------------------------------------------------------------
;
; VDU 5 (&05) Print text at graphics cursor [MasRef E.3-3]
;
vdu5EntryPoint:
                lda $0361
                beq LC52C
                lda #$20
                jsr setCRTCRegister10
                bra LC51B

;-------------------------------------------------------------------------
;
; VDU 17 (&11) Define text colour [MasRef E.3-7]
;
vdu17EntryPoint:
                ldy #$00
                lda $0323
                bpl LC541
                iny
LC541:
                and $0360
                sta $DA
                lda $0360
                beq LC563
                and #$07
                clc
                adc $DA
                tax
                lda solidColoursTable-1,x
                sta $0357,y
                lda $0357
                eor #$FF
                sta ZEOR
                eor $0358
                sta ZORA
LC563:
                rts

;-------------------------------------------------------------------------
;
; VDU 18 (&12) Define graphics colour [MasRef E.3-7]
;
vdu18EntryPoint:
                ldy #$00                    ;assume setting foreground
                lda vduv.queueEnd-1         ;get colour
                bpl +                     ;taken if setting foreground
                iny                       ;setting background
+
                and vduv.numberOfLogicalColoursMinusOne
                sta vduv.foregroundGraphicsColour,y
                lda vduv.queueEnd-2          ;get GCOL mode
                sta vduv.foregroundGCOLMode,y
                and #$F0                     ;non-zero if ECF
                sta vduv.isForegroundECF,y
initializeCurrentECFPatterns:
                lda vduv.foregroundGCOLMode
                ldx vduv.foregroundGraphicsColour
                ldy #andy.fgECFPattern-andy.currentECFPatterns
                jsr initializeCurrentECFPattern
                lda vduv.backgroundGCOLMode
                ldx vduv.backgroundGraphicsColour
                ldy #andy.bgECFPattern-andy.currentECFPatterns
initializeCurrentECFPattern:
                and #$F0                     ;GCOL mode ECF bits
                bne initializeECFPatternFromPattern

initializeECFPatternFromColour:
                stx ZTEMP+0                  ;colour low bits
                lda vduv.numberOfLogicalColoursMinusOne
                and #$07
                clc
                adc ZTEMP+0
                tax
                ; use solid colour as ECF "pattern".
                lda solidColoursTable-1,x
                ldx #$07
-
                sta andy.fgECFPattern,y
                iny
                dex
                bpl -
                rts

initializeECFPatternFromPattern:
                lsr a                        ;(index+1)*8
                tax
                lda #$07
                sta ZTEMP+0
-
                lda andy.ecfPatterns-8,x     ;-8 due to index+1 above
                sta andy.fgECFPattern,y
                inx
                iny
                dec ZTEMP+0
                bpl -
                rts

;-------------------------------------------------------------------------
;
; VDU 20 (&14) Restore default logical colours [MasRef E.3-10]
;
setBackgroundTextColourForTeletext:
                lda #' '
                sta vduv.backgroundTextColour
                rts

vdu20EntryPoint:
                ldx #$05
-
                stz vduv.foregroundTextColour,x
                dex
                bpl -
                stz vduv.backgroundGraphicsColour
                stz vduv.isBackgroundECF
                lda #%11111111
                ldx vduv.numberOfLogicalColoursMinusOne
                beq setBackgroundTextColourForTeletext
                cpx #$0F
                bne +                        ;taken unless MODE 2
                lda #%00111111               ;MODE 2 default foreground colour is 7
+
                sta vduv.foregroundTextColour
                eor #$FF
                sta ZORA
                sta ZEOR
                txa
                and #$07
                sta vduv.foregroundGraphicsColour
                stz vduv.isForegroundECF
                phx                          ;save numberOfLogicalColoursMinusOne
                jsr initializeCurrentECFPatterns
                plx                          ;restore numberOfLogicalColoursMinusOne
                stx vduv.queueEnd-5          ;Prepare VDU19,<max logical colour>
                cpx #$03
                beq reset4Colours            ;taken if MODE 1/5
                bcc reset2Colours            ;taken if MODE 0/3/4/6
reset16Colours:
                stx vduv.queueEnd-4          ;start with VDU19,15,15,_,_,_
-
                jsr vdu19EntryPoint
                dec vduv.queueEnd-4
                dec vduv.queueEnd-5
                bpl -
                rts

reset4Colours:
                ldx #$07
                stx vduv.queueEnd-4          ;start with VDU19,3,7,_,_,_
-
                jsr vdu19EntryPoint          ;2,3, then 1,1, then 0,0
                lsr vduv.queueEnd-4
                dec vduv.queueEnd-5
                bpl -
                rts

reset2Colours:
                ldx #$07
                jsr +                        ;VDU19,1,7,_,_,_
                ldx #$00
                stz vduv.queueEnd-5          ;VDU19,0,0,_,_,_
+
                stx vduv.queueEnd-4          ;VDU19,N,X,_,_,_

                ; fall through to VDU19

;-------------------------------------------------------------------------
;
; VDU 19 (&13) Define logical colour [MasRef E.3-9]
;
vdu19EntryPoint:
                php
                sei
                lda vduv.queueEnd-5          ;get logical colour
                and vduv.numberOfLogicalColoursMinusOne ;apply logical colour limit
                tax                        ;X = clamped logical colour
                lda vduv.queueEnd-4        ;get physical colour
LC639:
                and #$0F                     ;apply physical colour limit
                sta vduv.currentPalette,x    ;update palette
                tay                          ;Y = physical colour
                lda vduv.numberOfLogicalColoursMinusOne
                sta SEIWKA
                cmp #$03 ;Z=1 C=1 if 4 colour; Z=0 C=1 if 16 colour; Z=0 C=0 if 2 colour
                php      ;save flags
                txa                          ;A = logical colour

                ;put the logical colour value in the top 1, 2 or 4
                ;bits of SEIWKA, depending on the colour depth.
                ;
                ; 2 colours: turn %0000000a into %a0000000
                ; 4 colours: turn %000000ab into %ab000000
                ;16 colours: turn %0000abcd into %abcd0000
-
                lsr a
                ror SEIWKA
                bcs -
                asl SEIWKA

                tya                          ;A = physical colour
                ora SEIWKA                   ;mix in logical colour
                tax                          ;X = VPALETTE value
                ldy #$F0 ;counts up to zero - counter for setting
                         ;multiple logical colours [AUG p380]
LC655:
                plp                          ;restore flags
                php                          ;save flags
                bne +                     ;taken if 2 colour/16 colour
                jsr fixUpVPALETTEFor4Colours
+
                jsr writeVPALETTE
                clc
                tya
                adc vduv.numberOfLogicalColoursMinusOne
                tay
                txa
                adc #$10                     ;next logical colour
                tax
                iny                          ;Y+=numberOfLogicalColours
                bne LC655                    ;all logical colours set once zero
                plp
                plp
                rts

fixUpVPALETTEFor4Colours:
                rol a                        ;A BCDabcd1
                sta ZTEMP+0                  ;  BCDabcd1
                rol a                        ;B CDabcd1A
                rol a                        ;C Dabcd1AB
                php                          ;C
                rol ZTEMP+0                  ;B CDabcd1C
                ror a                        ;B BDabcd1A
                plp                          ;C BDabcd1A
                ror a                        ;A CBDabcd1
                ror a                        ;1 ACBDabcd
                rts                          ;

;-------------------------------------------------------------------------
;
; VDU 23 (&17) Various functions [MasRef E.3-12]
;
vdu23EntryPoint:
                lda vduv.queueEnd-9           ;get VDU 23 code
                cmp #$20
                bcc LC691         ;branch taken if <32 - i.e., special

                ; copy the 8 bytes of character definition to the
                ; appropriate place.
                jsr getSoftCharacterDefinitionAddress
                ldy #$07
LC688:
                lda vduv.queueEnd-8,y
                sta ($DE),y
                dey
                bpl LC688
                rts

LC691:
                asl a
                tax
                lsr a
                cmp #$11
                bcs callVDUV    ;call with C=1 - invalid code [MasRef
                                ;E.3-19]
                jmp (vdu23EntryPointTable,x)

;-------------------------------------------------------------------------
;
; VDU 25 (&19) PLOT commands [MasRef E.3-21]
;
vdu25EntryPoint:
                ldx vduv.pixelsPerByteMinusOne
                beq callVDUVForPLOT          ;non-graphics PLOT
                jmp handlePLOT

;-------------------------------------------------------------------------
;
; Call VDUV for a PLOT call, either to handle non-graphics PLOT
; [MasRef E.3-21] or PLOT 240-255 [MasRef E.3-34].
;
callVDUVForPLOT:
                lda vduv.queueEnd-5          ;get PLOT code
                clc ;call with C=0 - non-graphics PLOT [MasRef E.3-21]

;-------------------------------------------------------------------------
;
; Call VDUV.
;
callVDUV:
                .if version<350
                jmp (VDUV)
                .else
                jmp LE2F3
                .endif

;-------------------------------------------------------------------------
;
; VDU 26 (&1A) Restore default windows [MasRef E.3-34]
;
vdu26EntryPoint:
                ldx #VDUVariables.workspace._2C
-
                stz vduv,x                    ;reset workspace
                dex
                bpl -

                jsr getDefaultBoundsForCurrentScreenMODE
                stx vduv.textWindowRight
                sty vduv.textWindowBottom

                txa
                jsr setTextWindowWidthInBytes

                ; Set up the VDU queue as if VDU 24,0;0;1279;1023;,
                ; then call the VDU 24 entry point.

                ; 1c - ll - $00
                ; 1d - lh - $00
                ; 1e - tl - $00
                ; 1f - th - $00
                ; 20 - rl - $ff
                ; 21 - rh - $04
                ; 22 - tl - $ff
                ; 23 - th - $03

                ldy #$03
                sty $0323
                iny
                sty $0321
                dec $0322
                dec $0320
                jsr vdu24EntryPoint

                lda #STATE.isTextWindow
                trb STATE                    ;reset isTextWindow

                jmp vdu30EntryPoint          ;reset text cursor

;-------------------------------------------------------------------------
;
; Update CRTC cursor address to reflect text cursor position.
;
updateCRTCTextCursor:
                jsr updateZMEMTWithTextCursorPosition
                bra updateCRTCCursorAddress

;-------------------------------------------------------------------------

setCRTCCursorAddress:
                stx vduv.textCursorCRTCAddress+0
                sta vduv.textCursorCRTCAddress+1
                bpl +
                sec
                sbc vduv.screenSizeHighByte
+
                stx ZMEMT+0
                sta ZMEMT+1

;-------------------------------------------------------------------------
;
;
updateCRTCCursorAddress:
                .if fasterOSWRCH
                ; Set C=1 if Mode 7
                lda vduv.currentScreenMODE
                cmp #$07
                .endif
                ldx vduv.textCursorCRTCAddress+0
                lda vduv.textCursorCRTCAddress+1
                ldy #$0E

;-------------------------------------------------------------------------
;
; Set CRTC address - cursor, or screen start.
;
; entry:
;
; A (msb), X (msb) = 6502 address to set
;
; Y = first CRTC register to set
;
.if !fasterOSWRCH
; C = 1 if in Mode 7
.endif
;
setCRTCAddress:
                .if !fasterOSWRCH
                pha                          ;save screen address MSB
                lda vduv.currentScreenMODE
                cmp #$07
                pla                        ;restore screen address MSB
                .endif
                bcs adjustAddressForMODE7
                stx ZTEMP+0
                lsr a
                ror ZTEMP+0                  ;/2
                lsr a
                ror ZTEMP+0                  ;/4
                lsr a
                ror ZTEMP+0                  ;/8
                ldx ZTEMP+0
                bra setCRTCAddressRegisters

adjustAddressForMODE7:
                ; C=1
                .if fasterOSWRCH
                ; only the top 2 bits of the result differ from the
                ; 2-step calculation, and they're irrelevant as the
                ; CRTC is 14-bit addressing.
                sbc #$54
                .else
                sbc #$74                 ;adjust for Mode 7 addressing
                eor #$20                 ;adjust for Mode 7 addressing
                .endif
setCRTCAddressRegisters:
                sty CRTC+0
                sta CRTC+1
                iny
                sty CRTC+0
                stx CRTC+1
                rts

;-------------------------------------------------------------------------
;
; VDU 24 (&18) Define graphics window [MasRef E.3-21]
;
; VDU queue:
;
; -8 = <left
; -7 = >left
; -6 = <bottom
; -5 = >bottom
; -4 = <right
; -3 = >right
; -2 = <top
; -1 = >top
;
vdu24EntryPoint:
                jsr LC779

                ldx #2
-
                sec

                ; <height when X=2, then <width when X=0
                lda vduv.queueEnd-4+0,x
                sbc vduv.queueEnd-8+0,x
                sta vduv.workspace._2C+0,x

                ; >height when X=2, then >width when X=0
                lda vduv.queueEnd-4+1,x
                sbc vduv.queueEnd-8+1,x
                sta vduv.workspace._2C+1,x

                dex
                dex
                bpl -

                ora vduv.workspace._2C+3     ;A=>width|>height
                bmi LC779 ;taken if either dimension negative - window invalid
                ldx #VDUVariables.queueEnd-4 ;left bottom
                jsr eigabsEntryPoint         ;convert to pixels
                ldx #VDUVariables.queueEnd-8 ;right top
                jsr eigabsEntryPoint         ;convert to pixels
                lda vduv.queueEnd-5          ;>bottom
                ora vduv.queueEnd-7          ;>left
                bmi LC779 ;taken if either bottom or left negative - window invalid
                lda vduv.queueEnd-1          ;>top
                bne LC779          ;taken if top>=256 - window invalid
                ldx vduv.currentScreenMODE
                lda vduv.queueEnd-3          ;>right
                sta ZTEMP+0
                lda vduv.queueEnd-4          ;<right
                lsr ZTEMP+0                  ;>(right/2)
                ror a                        ;<(right/2)
                lsr ZTEMP+0                  ;>(right/4)

                ; 639>>2=159 - so any valid pixel X in any mode will
                ; have an MSB of 0 after being shifted right 2.
                bne LC779 ;taken if right edge definitely off screen - window invalid
                ror a     ;<(right/4)
                lsr a     ;<(right/8)
                cmp modeMaxColumn,x
                beq LC772                    ;taken if right edge just on screen
                bpl LC779 ;taken if right edge off screen - window definitely invalid
LC772:
                ldy #VDUVariables.graphicsWindowPixelsLeft
                ldx #VDUVariables.queueEnd-8
                jsr copyEightBytesWithinVDUVariables
LC779:
                ldx #VDUVariables.graphicsCursorPositionX
                ldy #VDUVariables.workspace._28
                jmp exchangeFourVDUBytes

;-------------------------------------------------------------------------
;
; Call getBytesPerInclusiveTextRow, and store the result in the
; textWindowWidthInBytes VDU variable.
;
setTextWindowWidthInBytes:
                jsr getBytesPerInclusiveTextRow
                sta vduv.textWindowWidthInBytes+0
                stx vduv.textWindowWidthInBytes+1
                rts

;-------------------------------------------------------------------------
;
; VDU 29 (&1D) Define graphics origin [MasRef E.3-35]
;
vdu29EntryPoint:
                ldx #VDUVariables.queueEnd-4
                ldy #VDUVariables.graphicsWindowOriginX
                jsr copyFourBytesWithinVDUVariables
                jmp LC4DF

;-------------------------------------------------------------------------
;
; VDU 22 (&16) Select screen mode [MasRef E.3-11]
;
vdu22EntryPoint:
                lda vduv.queueEnd-1          ;get MODE number
                bra setMODE

;-------------------------------------------------------------------------
;
setStartupMODE:
                .if version==350
                jsr withTSTClear
                .endif
                sta ZTEMP+0                  ;save MODE
                lda $F4
                pha
                ora #$80                     ;page in ANDY
                jsr selectROMA
                jsr +
                pla
                jmp selectROMA               ;restore old ROM

+
                ; TODO but what of the reserved byte here?
                ldx #size(VDUVariables)-1
                stz STATE
                lda vduv.cursorFlags
-
                stz vduv-1,x
                dex
                bne -
                sta vduv.cursorFlags
                lda ZTEMP                    ;restore MODE

                ; fall through to setMODE

;-------------------------------------------------------------------------
;
;
;
setMODE:
                stz vduDriverMemory
                stz displayMemory
                tay                          ;Y=mode
                bmi setShadowMODE
                ldx shadowRAMState
                beq setShadowMODE
                lda #STATE.isShadowMode
                trb STATE
                lda #ACCCON.D|ACCCON.E
                trb ACCCON ;display main RAM, VDU code accesses main RAM
                bra +

setShadowMODE:
                lda #STATE.isShadowMode
                tsb STATE
                lda #ACCCON.D|ACCCON.E
                tsb ACCCON ;display shadow RAM, VDU code accesses shadow RAM
+
                tya                          ;A=mode
                and #$07                     ;get MODE 0-7
                tax                          ;X=MODE 0-7
                stx vduv.currentScreenMODE
                lda numberOfLogicalColoursMinusOneForMODE,x
                sta vduv.numberOfLogicalColoursMinusOne
                lda bytesPerCharacterForMODE,x
                sta vduv.bytesPerCharacter
                lda pixelsPerByteMinusOneForMODE,x
                sta vduv.pixelsPerByteMinusOne
                bne +                        ;taken if graphics mode
                lda #$07                     ;assume 8 px/byte for non-graphics modes
+
                asl a            ;convert to pixelMasks index for rightmost pixel
                tay
                lda pixelMasks-1,y
                sta vduv.colourMaskRight
-
                asl a
                bpl -   ;keep shifting until leftmost pixel mask found
                sta vduv.colourMaskLeft
                ldy screenMODEGroupForMODE,x
                sty vduv.currentScreenMODEGroup
                lda latchBit4ForScreenMODEGroup,y
                php
                sei
                sta systemVIA.orb
                lda latchBit5ForScreenMODEGroup,y
                sta systemVIA.orb
                plp
                lda screenSizeHighByteForScreenMODEGroup,y
                sta vduv.screenSizeHighByte
                lda startScreenAddressHighByteForScreenMODEGroup,y
                sta vduv.startScreenAddressHighByte
                lda #STATE.isVDU21|STATE.isCursorEditing|STATE.isVDU5|STATE.isTextWindow|STATE.isPagedScrolling|STATE.isScrollingDisabled
                trb STATE
                ldx vduv.currentScreenMODE
                lda vcontrolForScreenMODE,x
                jsr setVCONTROL
                php
                sei
                ldx crtcRegisterLastIndexForScreenMODEGroup,y
                ldy #$0B
-
                lda crtcRegisterValues,x
                jsr setCRTCRegister
                dex
                dey
                bpl -
                plp
                jsr vdu20EntryPoint
                jsr vdu23_11_EntryPoint
                lda #%10101010
                sta vduv.dotPattern
                sta vduv.dotPatternState
                jsr vdu26EntryPoint
                lda vduv.textWindowWidthInBytes+0
                ldx vduv.textWindowWidthInBytes+1
                sta vduv.bytesPerCharacterRow+0
                stx vduv.bytesPerCharacterRow+1

                ; Do a fast hardware CLS of the whole screen
                ; ------------------------------------------
clsFastPath:
                ldx #$00
                lda vduv.startScreenAddressHighByte
                stz vduv.screenTopLeftAddress+0
                sta vduv.screenTopLeftAddress+1
                jsr setCRTCCursorAddress
                ldy #$0C
                jsr setCRTCAddressRegisters
                stz pagedModeCounter
                sec
                lda #$80
                sbc vduv.startScreenAddressHighByte
                tax
                ldy #$00
                jsr clearTextMemory
                jmp vdu30EntryPoint

LC88B:
                jsr LC8CF                    ; Clear paged mode counter
LC88E:
                jsr osbyte76    ; Call KEYV to test Shift & Ctrl keys
                bcc LC895                    ; Ctrl not pressed, exit loop
                bmi LC88B                    ; Shift pressed, loop back
LC895:
                lda STATE
                eor #STATE.isPagedScrolling
                and #STATE.isCursorEditing|STATE.isPagedScrolling|STATE.isScrollingDisabled;
                bne LC8D6
                jsr LC8D7
                lda vduv.textCursorXPosition,y
                cmp vduv.textWindowLeft,x
                bne LC8D3
                .if version==400||version==350
                cpy #0
                .else
                sec
                iny
                dey
                .endif
                bne LC8B5
                lda vduv.textWindowRight
                sbc vduv.textWindowLeft
                bra LC8BB

LC8B5:
                lda vduv.textWindowBottom
                sbc vduv.textWindowTop
LC8BB:
                pha
                lsr a
                lsr a
                sta ZTEMP+0
                sec
                pla
                sbc ZTEMP+0
                cmp pagedModeCounter
                bcs LC8D3
LC8C9:
                jsr osbyte76
                sec
                bpl LC8C9

LC8CF:
                stz pagedModeCounter        ; Clear paged mode counter
                .if version!=400&&version!=350
                nop
                .endif
LC8D3:
                inc pagedModeCounter
LC8D6:
                rts

LC8D7:
                lda vduv.cursorFlags
                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
                lsr a                        ;xvh
                tax
                lda LE204,x
                tax
                and #$01
                tay
                rts

;-------------------------------------------------------------------------
;
; Prepare AABB based on the current graphics cursor and some other
; coordinate.
;
; entry:
;
; X = VDU variable offset of other coordinate (4 bytes: X;Y;)
;
; exit:
;
; vduv.workspace._28 = minimum
;
; vduv.workspace._2c = maximum
;
prepareAABB:
                ldy #VDUVariables.graphicsCursorPixels
                jsr sortVDUVariableCoordinates
                phy                          ;save greater Y
                phx                          ;save lesser Y
                jsr sortVDUVariableWords     ;X=lesser X, Y=greater X
                pla                          ;A=lesser Y
                phy                          ;save greater X
                ldy #VDUVariables.workspace._28
                jsr +
                plx                          ;X=greater X
                pla                          ;A=greater Y
+
                ; Copy VDU variable word +X to VDU variable word+Y.
                ; Then cropy VDU variable word +A+2 to VDU variable
                ; word+Y+2. Return with updated Y.
                pha
                jsr copyTwoBytesWithinVDUVariables
                plx
                inx
                inx
                bra copyTwoBytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; Copy 8 bytes to workspace 28 in the VDU variables.
;
; entry:
;
; X = source offset
;
copyEightBytesToWorkspace28:
                ldy #VDUVariables.workspace._28

;-------------------------------------------------------------------------
;
; Copy 8 bytes in the VDU variables.
;
; entry:
;
; X = source offset
;
; Y = dest offset
;
copyEightBytesWithinVDUVariables:
                lda #$08
                bra copyABytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; copyTextWindowWidthInBytesToWorkspace28
copyTextWindowWidthInBytesToWorkspace28:
                ldx #VDUVariables.textWindowWidthInBytes
                ldy #VDUVariables.workspace._28

;-------------------------------------------------------------------------
;
;
copyTwoBytesWithinVDUVariables:
                lda #$02
                bra copyABytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; Copy text window info to workspace2C.
;
copyTextWindowToWorkspace2C:
                ldx #VDUVariables.textWindowLeft
                ldy #VDUVariables.workspace._2C
                bra copyFourBytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; Copy last 4 bytes of VDU queue somewhere.
;
copyLastFourVDUQueueBytes:
                ldx #VDUVariables.queueEnd-4
                bra copyFourBytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; Copy old graphics cursor position to current graphics cursor position.
;
copyGraphicsCursorPixelsToOldGraphicsCursorPixels:
                ldy #VDUVariables.oldGraphicsCursorPixelsX

;-------------------------------------------------------------------------
;
; Copy the graphics cursor position somewhere.
;
copyGraphicsCursorPixels:
                ldx #VDUVariables.graphicsCursorPixelsX

;-------------------------------------------------------------------------
;
; Copy 4 bytes in the VDU variables.
;
; entry:
;
; X = source offset
;
; Y = dest offset
;
copyFourBytesWithinVDUVariables:
                lda #$04

                ; fall through to copyABytesWithinVDUVariables

;-------------------------------------------------------------------------
;
; Copy some bytes in the VDU variables.
;
; entry:
;
; A = number of bytes
;
; X = source offset
;
; Y = dest offset
;
; exit:
;
; X = updated source offset
;
; Y = updated dest offset
;
copyABytesWithinVDUVariables:
                pha
                lda vduv,x
                sta vduv,y
                inx
                iny
                pla
                dec a
                bne copyABytesWithinVDUVariables
                rts

;-------------------------------------------------------------------------
;
; Negate a 16-bit value stored in Y/A
;
; entry:
;
; Y (LSB), A (MSB) = value
;
; exit:
;
; Y (LSB), A (MSB) = -value
;
negateAY:
                pha
                tya
                eor #$FF
                tay
                pla
                eor #$FF
                iny
                bne +
                inc a
+
                rts

;-------------------------------------------------------------------------
;
; Multiply a text window width by the number of bytes per char. There
; are inclusive and exclusive versions, depending on how the width was
; calculated.
;
; entry:
;
; A = value-1 to multiply (inclusive), value to multiply (exclusive)
;
; exit:
;
; A (lsb), X (msb) = value*vduv.bytesPerCharacter
;
getBytesPerInclusiveTextRow:
                inc a
getBytesPerExclusiveTextRow:
                sta $DA
                stz $DB
                lda vduv.bytesPerCharacter    ;A=1/8/16/32
-
                lsr a
                bcs +                     ;taken when multiply is done
                asl $DA              ;shift size LSB
                rol $DB              ;carry into size MSB
                bra -

+
                lda $DA
                ldx $DB
                rts

;-------------------------------------------------------------------------
;
;
prepareForPlotBackground:
                ldx #$08                     ;plot background
                stx vduv.graphicsPlotState
                lda vduv.backgroundGCOLMode
                and #$0F
                sta vduv.graphicsPlotMode
                rts

;-------------------------------------------------------------------------

LC95F:
                lda #$00
                pha
                pha
                ldx $032A
                jsr LCC7D
                bra LC97F

LC96B:
                sec
                lda $034F
                sbc $032A
                pha
                jsr getDefaultBoundsForCurrentScreenMODE
                phx
                lda #$00
                ldx $032A
                jsr LCC5D
LC97F:
                ; scroll left/right
                stx vduv.screenTopLeftAddress+0
                sta vduv.screenTopLeftAddress+1
                plx
                ldy #$00
                jsr getAddressForTextPosition
                plx
                lda #$00
                jsr LCC5D
                stx ZMEMT+0
                sta ZMEMT+1
                jsr getDefaultBoundsForCurrentScreenMODE
                jsr LCAAE
                bra LC9B8

LC99D:
                ldy #$00
                jsr LCC77
                bra LC9AA

LC9A4:
                jsr getDefaultBoundsForCurrentScreenMODE
                jsr LCC57
LC9AA:
                stx vduv.screenTopLeftAddress+0
                sta vduv.screenTopLeftAddress+1
                ldx #$00
                jsr getAddressForTextPosition
                jsr LCAE8
LC9B8:
                .if fasterOSWRCH
                ; Set C=1 if Mode 7
                lda vduv.currentScreenMODE
                cmp #7
                .endif
                ldy #$0C
                lda vduv.screenTopLeftAddress+1
                ldx vduv.screenTopLeftAddress+0
                jmp setCRTCAddress

LC9C3:
                jsr LCCA0
LC9C6:
                sta $DD
                stx $DC
                jsr LCC2C
                lda $0329
                ldx $0328
                jsr LCC5D
                jsr LCC88
                stx ZMEMT+0
                sta ZMEMT+1
                lda #$00
                ldx $032A
                jsr LCC7D
                jsr LCC88
                stx $DA
                sta $DB
                ldy $0328
                ldx $0329
                bvc LCA17
                ldy $E0
                ldx $E1
                jsr LCBE7
                ldy $E0
                bcc LCA08
                ldx #$80
                stx $DB
                stz $DA
                ldy $032A
LCA08:
                ldx #$00
                jsr LCBF3
                ldx #$80
                stx ZMEMT+1
                stz ZMEMT+0
                ldy $DE
                ldx $DF
LCA17:
                jsr LCBE7
                jsr LCC97
                jsr LCC94
                jsr LCC57
                stx ZMEMT+0
                sta ZMEMT+1
                dec $032B
                bpl LC9C6
                rts

LCA2D:
                jsr LCCA0
LCA30:
                jsr LCC2C
                lda #$00
                ldx $032A
                jsr LCC5D
                stx $DA
                sta $DB
                jsr LCC57
                stx $DC
                sta $DD
                ldy $0328
                ldx $0329
                bvc LCA73
                ldy $DE
                ldx $DF
                jsr LCBA8
                ldy $DE
                bcc LCA63
                ldx $034E
                stx $DB
                stz $DA
                ldy $032A
LCA63:
                ldx #$00
                jsr LCBB4
                ldx $034E
                stx ZMEMT+1
                stz ZMEMT+0
                ldy $E0
                ldx $E1
LCA73:
                jsr LCBA8
                jsr LCC94
                dec $032B
                bpl LCA30
LCA7E:
                rts

LCA7F:
                stx $DC
                tax
                sec
                sbc $DC
                beq LCA7E
                sta $DD
                phx
                jsr getBytesPerExclusiveTextRow
                plx
                lda $0366
                bit #$08
                bne LCAA0
                bit #$02
                jsr LCCCA
                ldy $DA
                ldx $DB
                bra LCACE

LCAA0:
                bit #$04
                jsr LCCCA
                lda $034F
                sta $032A
                ldy $DD
                dey
LCAAE:
                tya
                beq LCAC9
                sty $DC
LCAB3:
                jsr LCC57
                stx $DA
                sta $DB
                jsr LCAC9
                ldx $DA
                stx ZMEMT+0
                lda $DB
                sta ZMEMT+1
                dec $DC
                bne LCAB3
LCAC9:
                ldx #$00
                ldy $032A
LCACE:
                lda $0328
                pha
                lda $0329
                pha
                sty $0328
                stx $0329
                jsr LCAE8
                pla
                sta $0329
                pla
                sta $0328
                rts

;-------------------------------------------------------------------------

LCAE8:
                ldx ZMEMT+0
                lda ZMEMT+1
                jsr LCC2C
                bra LCB6A

;-------------------------------------------------------------------------

LCAF1:
                ldx #<LCC77
                lda #>LCC77
                ldy $032D
                bra LCB01

LCAFA:
                ldx #<LCC57
                lda #>LCC57
                ldy $032F
LCB01:
                stx $035D
                sta $035E
                sec
                lda $032D
                sbc $032F
                sta $032B
                ldx $032C
                jsr getAddressForTextPosition
                sta $DD
                stx $DC
                jsr LCC2C
                lda $032B
                beq LCB6A
LCB23:
                php
                jsr LC024
                stx $DA
                sta $DB
                stx $DC
                sta $DD
                plp
                bvc LCB4F
                clv
LCB33:
                ldx $DF
                ldy $DE
                jsr LCBB4
                lda $034E
                bvs LCB45
                sta ZMEMT+1
                stz ZMEMT+0
                bra LCB49

LCB45:
                sta $DB
                stz $DA
LCB49:
                ldx $E1
                ldy $E0
                bra LCB5A

LCB4F:
                jsr LCC2C
                bvs LCB33
                ldx $0329
                ldy $0328
LCB5A:
                jsr LCBB4
                ldx $DC
                stx ZMEMT+0
                lda $DD
                sta ZMEMT+1
                dec $032B
                bne LCB23
LCB6A:
                ldx $0329
                ldy $0328
                bvc clearTextMemory
                ldx $DF
                ldy $DE
                jsr clearTextMemory
                lda $034E
                sta ZMEMT+1
                stz ZMEMT+0
                ldx $E1
                ldy $E0

;-------------------------------------------------------------------------
;
; Clear a block of text screen memory.
;
; entry:
;
; (ZMEMT),y - first byte to clear
;
; X = number of pages (including first, possibly partial page) to clear
;
clearTextMemory:
                ; align memory so that Y=0 on each page boundary
                ; crossing.
                ;
                ; e.g., on entry ZMEMT=$30f8, Y=$08 - then after,
                ; ZMEMT=$3000, Y=$F7; or, ZMEMT=$30f0, Y=$08 -> ZMEMT=$2ff8, Y=$F7.
                tya                          ;A=initial offset
                clc
                adc ZMEMT+0                  ;add to dest address
                sta ZMEMT+0
                bcs +
                dec ZMEMT+1
+
                tya
                eor #$FF
                tay
                lsr a                        ;C set if odd
                lda vduv.backgroundTextColour
                bcs nextByte                    ;taken if odd - slightly different loop
                bra clearTextMemoryByte

clearTextMemoryLoop:
                sta (ZMEMT),y
clearTextMemoryByte:
                iny
                sta (ZMEMT),y
nextByte:
                iny
                bne clearTextMemoryLoop
                inc ZMEMT+1
                dex
                bpl clearTextMemoryLoop
                rts

;-------------------------------------------------------------------------

LCBA8:
                sec
                tya
                sbc $032A
                tay
                bcs LCBB4
                dex
                bmi LCBE6
                sec
LCBB4:
                php
                tya
                clc
                adc ZTEMP+0
                sta ZTEMP+0
                bcs LCBBF
                dec ZTEMP+1
LCBBF:
                tya
                clc
                adc ZMEMT+0
                sta ZMEMT+0
                bcs LCBC9
                dec ZMEMT+1
LCBC9:
                tya
                eor #$FF
                tay
                lsr a
                bcs LCBDB
                bra LCBD6

LCBD2:
                lda ($DA),y
                sta (ZMEMT),y
LCBD6:
                iny
                lda ($DA),y
                sta (ZMEMT),y
LCBDB:
                iny
                bne LCBD2
                inc $DB
                inc ZMEMT+1
                dex
                bpl LCBD2
LCBE5:
                plp
LCBE6:
                rts

LCBE7:
                sec
                tya
                sbc $032A
                tay
                bcs LCBF3
                dex
                bmi LCBE6
                sec
LCBF3:
                php
                tya
                eor #$FF
                pha
                sec
                adc $DA
                sta $DA
                bcs LCC01
                dec $DB
LCC01:
                pla
                sec
                adc ZMEMT+0
                sta ZMEMT+0
                bcs LCC0B
                dec ZMEMT+1
LCC0B:
                tya
                lsr a
                bcs LCC23
                bne LCC1E
LCC11:
                dex
                bmi LCBE5
                dec $DB
                dec ZMEMT+1
                bra LCC1E

LCC1A:
                lda ($DA),y
                sta (ZMEMT),y
LCC1E:
                dey
                lda ($DA),y
                sta (ZMEMT),y
LCC23:
                dey
                bne LCC1A
                lda ($DA)
                sta (ZMEMT)
                bra LCC11

;-------------------------------------------------------------------------
;
; Get pointers for a text window row.
;
; entry:
;
; vduv.workspace._28; = text window stride, in bytes
;
; >A, <X = address
;
; exit:
;
; V=0: >A, <X = new address
;
; V=1: (ZTEMPC) =

LCC2C:
                pha                          ;save >address
                txa                          ;A=<address
                clc
                adc vduv.workspace._28       ;A=<(new address)
                tax                          ;X=<(new address)
                pla                          ;restore >addcess
                adc vduv.workspace._29       ;A=>(new address)
                bvc rtsCC56                  ;taken if no address wrap
                stx ZTEMPD+0
                and #$7F                     ;
                sta ZTEMPD+1
                ora ZTEMPD+0
                beq clv_rts
                php
                sec
                lda vduv.workspace._28
                sbc ZTEMPD+0
                sta ZTEMPC+0
                lda vduv.workspace._29
                sbc ZTEMPD+1
                sta ZTEMPC+1
                plp
                rts

;-------------------------------------------------------------------------

clv_rts:
                clv
rtsCC56:
                rts

LCC57:
                lda vduv.bytesPerCharacterRow+1
                ldx vduv.bytesPerCharacterRow+0
LCC5D:
                clc
LCC5E:
                php
                pha
                txa
                adc ZMEMT+0
                tax
                pla
                adc ZMEMT+1
                bpl +
                sec
                sbc vduv.screenSizeHighByte ;handle wraparound at end
+
                cmp vduv.startScreenAddressHighByte
                bcs +
                adc vduv.screenSizeHighByte ;handle wraparound at start
+
                plp
                rts

LCC77:
                lda $0353
                ldx $0352
LCC7D:
                pha
                txa
                eor #$FF
                tax
                pla
                eor #$FF
                sec
                bra LCC5E

LCC88:
                cmp $034E
                bne LCC93
                cpx #$00
                bne LCC93
                lda #$80
LCC93:
                rts

LCC94:
                jsr LCAC9
LCC97:
                ldx $DC
                stx ZMEMT+0
                lda $DD
                sta ZMEMT+1
                rts

LCCA0:
                sec
                lda $032D
                sbc $032F
                sta $032B
                ldx $032C
                ldy $032F

;-------------------------------------------------------------------------
;
; Get display address for a text position.
;
getAddressForTextPosition:
                lda vduv.textCursorXPosition
                pha
                lda vduv.textCursorYPosition
                pha
                stx vduv.textCursorXPosition
                sty vduv.textCursorYPosition
                jsr updateZMEMTWithTextCursorPosition
                ply
                sty vduv.textCursorYPosition
                ply
                sty vduv.textCursorXPosition
                rts

;-------------------------------------------------------------------------

LCCCA:
                beq LCCCF
                dex
                stx ZTEMPB+0
LCCCF:
                lda vduv.cursorFlags
                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
                tax
                lda ZTEMPB+0
LCCD7:
                jsr setTextCursorXPositionWithCursorFlags

updateZMEMTWithTextCursorPositionIfValid:
LCCDA:
                ldx vduv.textCursorXPosition
                cpx vduv.textWindowLeft
                bmi LCCF8            ;taken if off left edge of window
                cpx vduv.textWindowRight
                beq LCCE9            ;taken if at right edge of window
                bpl LCCF8            ;taken if off right edge of window
LCCE9:
                ldx vduv.textCursorYPosition
                cpx vduv.textWindowTop
                bmi LCCF8
                cpx vduv.textWindowBottom
                bmi updateZMEMTWithTextCursorPosition
                beq updateZMEMTWithTextCursorPosition
LCCF8:
                sec
                rts

;-------------------------------------------------------------------------
;
; Get display address for current text cursor position.
;
; Set up display address without using BBC lookup table at &E0/1
;
; Exit: C=0
;
updateZMEMTWithTextCursorPosition:
                lda vduv.currentScreenMODEGroup
                and #$fe                     ; Reduce to 0,0,2,2,4
                tax                          ; Index into jump table
                ldy vduv.textCursorYPosition  ; Get current line
                jmp (multiplyRoutinesTable,x) ; Jump to calculation setup

multiplyRoutinesTable:
                .word multiplyBy640     ; Memory map 0,1  MODE 0,1,2,3
                .word multiplyBy320       ; Memory map 2,3  MODE 4,5,6
                .word multiplyBy40        ; Memory map 4    MODE 7

multiplyBy40:
                ldx multiplyBy40TableHigh,y ; Get offset high byte for start of this line
                lda multiplyBy40TableLow,y ; Get offset low byte for start of this line
                clc
                bra LCD29

multiplyBy320:
                lda multiplyBy640TableHigh,y
                lsr a
                tax
                tya
                and #$03
                lsr a
                ror a
                bra LCD28

multiplyBy640:
                ldx multiplyBy640TableHigh,y
                tya
                and #$01
                lsr a
LCD28:
                ror a                        ; A=A/2 +(128*carry)

LCD29:
                adc vduv.screenTopLeftAddress+0
                sta ZMEMT+0                      ; store it
                txa
                adc vduv.screenTopLeftAddress+1 ; window start address hi
                tay
                lda vduv.textCursorXPosition  ; text column
                ldx vduv.bytesPerCharacter    ; bytes per character
                dex
                beq LCD4E                    ; 1 colour, MODE 7
                cpx #$0F
                beq LCD43                    ; 4 colours, MODE 1 or MODE 5
                bcc LCD44                    ; 2 colours, MODE 0,3,4,6
                asl a                        ; 16 colours, MODE 2
LCD43:
                asl a
LCD44:
                asl a
                asl a
                bcc LCD4A
                iny
                iny
LCD4A:
                asl a
                bcc LCD4F
                iny
LCD4E:
                clc
LCD4F:
                adc ZMEMT+0
                sta ZMEMT+0
                sta vduv.textCursorCRTCAddress+0
                tax
                tya
                adc #$00
                sta vduv.textCursorCRTCAddress+1
                bpl LCD63
                sec
                sbc vduv.screenSizeHighByte
LCD63:
                sta ZMEMT+1
                clc
                rts

;-------------------------------------------------------------------------

nextMaskedCharColumn
                inc vduv.graphicsCursorPixelsX+0
                bne +
                inc vduv.graphicsCursorPixelsX+1
+
                asl a
plotMaskedCharRow:
                ; find next pixel to plot, updating graphics cursor X
                ; as it goes. A is non-zero, so this loop will finish
                ; eventually.
                bpl nextMaskedCharColumn
                phy
                sta ZTEMPB+1                 ;
                ldx #VDUVariables.graphicsCursorPixels
                jsr gaddrEntryPoint
                bra plotMaskedCharPixel

plotMaskedCharPixelsLoop:
                bpl nextMaskedCharPixel
plotMaskedCharPixel:
                jsr plbyteEntryPoint
nextMaskedCharPixel
                lsr ZMASK
                bcc +
                jsr nextColumnAndResetMask
+
                asl ZTEMPB+1
                bne plotMaskedCharPixelsLoop
                ldx #VDUVariables.workspace._28
                ldy #VDUVariables.graphicsCursorPixelsX
                jsr copyTwoBytesWithinVDUVariables
                ply
                bra nextMaskedCharY

plotCharAtGraphicsCursor:
                jsr getSoftCharacterDefinitionAddress
                stz vduv.graphicsPlotState   ;plot in foreground colour
                lda vduv.foregroundGCOLMode
                and #$0F
plotFontDataAtGraphicsCursorWithPlotMode:
                sta vduv.graphicsPlotMode
                ldy #VDUVariables.workspace._28
                jsr copyGraphicsCursorPixels
                ldy #VDUVariables.graphicsCursorPixelsX
                ldx #VDUVariables.graphicsWindowPixelsLeft
                jsr getDistanceMask
                sta ZTEMPB+0
                ldx #VDUVariables.graphicsWindowPixelsRight
                jsr getDistanceMask
                ror a
                trb ZTEMPB+0
                ldx #VDUVariables.graphicsCursorPixelsY
                ldy #VDUVariables.graphicsWindowPixelsTop
                jsr getDistanceMask
                sta ZTEMPB+1
                ldx #VDUVariables.graphicsCursorPixelsY
                ldy #VDUVariables.graphicsWindowPixelsBottom
                jsr getDistanceMask
                ror a
                trb ZTEMPB+1
                ldy #$07
copyMaskedCharLoop:
                lda (ZTEMPC),y               ;get font byte
                and ZTEMPB+0                 ;mask out columns
                lsr ZTEMPB+1                 ;test row
                bcs +
                lda #$00                     ;mask out this row
+
                sta vduv.workspace._2C,y
                dey
                bpl copyMaskedCharLoop
                ldy #$F8
plotMaskedCharLoop:
                lda vduv.workspace._2C-$f8,y ;get masked byte
                bne plotMaskedCharRow        ;taken if data to write
nextMaskedCharY:
                ldx vduv.graphicsCursorPixelsY+0
                bne +
                dec vduv.graphicsCursorPixelsY+1
+
                dec vduv.graphicsCursorPixelsY+0
                iny
                bne plotMaskedCharLoop
                ldx #VDUVariables.workspace._2A
                ldy #VDUVariables.graphicsCursorPixelsY
                jmp copyTwoBytesWithinVDUVariables

vdu127AtGraphicsCursor:
                ; CHR$127 is a solid block, not a backspace.
                lda #<chr127
                sta ZTEMPC+0
                lda #>chr127
                sta ZTEMPC+1
                ldx #$08
                stx vduv.graphicsPlotState   ;plot in background colour
                lda #$00
                bra plotFontDataAtGraphicsCursorWithPlotMode

plotCharAtTextCursor:
                jsr handleColumn81
                bcs plotCharAtGraphicsCursor          ;taken if VDU5
                ldx vduv.numberOfLogicalColoursMinusOne
                .if fasterOSWRCH
                bne writeBitmapSoftCharacter
                cmp #$23
                beq writeTeletextHashChar
                cmp #$5F
                beq writeTeletextUnderscoreChar
                cmp #$60
                beq writeTeletextGBPChar
writeTeletextChar:
                sta (ZMEMT)
                rts
                
writeTeletextGBPChar:
                eor #$3f
writeTeletextHashChar:
                eor #$43
writeTeletextUnderscoreChar:
                eor #$3f
                sta (ZMEMT)
                rts
                
                .else
                beq writeTeletextChar
                .endif
writeBitmapSoftCharacter:
                jsr getSoftCharacterDefinitionAddress
writeBitmapChar:
                ldy #$07
                cpx #$03
                beq write2bppChar            ;taken if MODE 1/5
                bcs write4bppChar                    ;taken if MODE 2
write1bppChar:
                lda (ZTEMPC),y
                ora ZORA
                eor ZEOR
                sta (ZMEMT),y
                dey
                .if fasterOSWRCH
                lda (ZTEMPC),y
                ora ZORA
                eor ZEOR
                sta (ZMEMT),y
                dey
                .endif                
                bpl write1bppChar
                rts

vdu127EntryPoint:
                lda #$20
                bit $0366
                bne LCE37
                jsr vdu8EntryPoint
LCE37:
                .testVDU5State
                bne vdu127AtGraphicsCursor
                ldx vduv.numberOfLogicalColoursMinusOne
                beq writeTeletextSpaceChar   ;taken if teletext mode

                ; Address of space char is known.
                lda #<LB900
                sta ZTEMPC+0
                lda #>LB900
                sta ZTEMPC+1
                bra writeBitmapChar

writeTeletextSpaceChar:
                lda #$20
                .if fasterOSWRCH
                sta (ZMEMT)
                rts
                .else
writeTeletextChar:
                jsr getSAA5050FromASCII
                sta (ZMEMT)
                rts
                .endif

write2bppChar:
                lda ZMEMT+1
                ldx ZMEMT+0
                jsr getNextColumnAddress
-
                lda (ZTEMPC),y               ;get font byte
                and #$0F                     ;get data for right 4 pixels
                tax
                lda LE013,x                  ;form byte
                ora ZORA
                eor ZEOR
                sta (ZTEMPD),y               ;write to right column
                lda (ZTEMPC),y               ;get font byte
                .if version==350&&!fasterOSWRCH
                jsr LE520
                .else
                lsr a                        ;
                lsr a                        ;
                lsr a                        ;
                lsr a                        ;get data for left 4 pixels
                .endif
                tax                          ;
                lda LE013,x                  ;form byte
                ora ZORA
                eor ZEOR
                sta (ZMEMT),y                ;write to left column
                dey
                bpl -
                rts

get4bppScreenByteFor2Pixels: .macro
                tax
                lda LE023,x                  ;form byte
                ora ZORA
                eor ZEOR
                .endm

write4bppChar:
                lda ZMEMT+1
                ldx ZMEMT+0
                jsr getNext3ColumnAddresses
-
                lda (ZTEMPC),y               ;get font byte - %abcdefgh
                .if fasterOSWRCH
                and #$03                     ;mask out 2 pixels
                .get4bppScreenByteFor2Pixels
                .else
                jsr get4bppScreenByteFor2PixelsNonInlined ;pixels g and h
                .endif
                sta (ZTEMPD),y
                lda (ZTEMPC),y               ;get font byte - %abcdefgh
                lsr a                        ;%0abcdefg
                lsr a                        ;%00abcdef
                pha                          ;save %00abcdef
                .if fasterOSWRCH
                and #$03                     ;mask out 2 pixels
                .get4bppScreenByteFor2Pixels
                .else
                jsr get4bppScreenByteFor2PixelsNonInlined ;pixels e and f
                .endif
                sta (ZTEMPB),y
                pla                          ;restore %00abcdef
                lsr a                        ;%000abcde
                lsr a                        ;%0000abcd
                pha                          ;save %0000abcd
                .if fasterOSWRCH
                and #$03                     ;mask out 2 pixels
                .get4bppScreenByteFor2Pixels
                .else
                jsr get4bppScreenByteFor2PixelsNonInlined ;pixels c and d
                .endif
                sta (ZTEMP),y
                pla                          ;restore %0000abcd
                lsr a                        ;%00000abc
                lsr a                        ;%000000ab
                .if fasterOSWRCH
                .get4bppScreenByteFor2Pixels
                .else
                jsr get4bppScreenByteFor2PixelsNonInlined ;pixels a and b
                .endif
                sta (ZMEMT),y
                dey
                bpl -
                rts

                .if !fasterOSWRCH
get4bppScreenByteFor2PixelsNonInlined:
                and #$03                     ;mask out 2 pixels
                .get4bppScreenByteFor2Pixels
                rts
                .endif

;-------------------------------------------------------------------------
;
; Get mask indicating the distance between two 16-bit VDU variable
; values - >=8, or some amount less than that.
;
; (These can be used for masking pixels, or counting loops, or
; whatever.)
;
; entry:
;
; X = offset of value A in VDU variables
;
; Y = offset of value B in VDU variables
;
; exit:
;
; if distance<=0, A=255, C=1
;
; if distance>=8, A=0, C=0
;
; otherwise, A=255>>distance, C=0
;
getDistanceMask:
                sec
                lda vduv+0,x
                sbc vduv+0,y
                sta ZTEMP                    ;get result LSB
                lda vduv+1,x
                sbc vduv+1,y
                bmi distanceMask255                  ;taken if result -ve
                bne distanceMask0                  ;taken if result >=256
                ldx ZTEMP
                cpx #$08
                bcs distanceMask0                    ;taken if result>=8
                lda distanceMasksTable,x             ;get mask for <8 items
                rts

distanceMask255:
                lda #%11111111
                sec
                rts

distanceMask0:
                lda #$00
                clc
                rts

;-------------------------------------------------------------------------
;
; Get addresses of next 3 columns on screen.
;
; entry:
;
; A (MSB)/X (LSB) = address
;
; exit:
;
; (ZTEMP) = column N+1
; (ZTEMPB) = column N+2
; (ZTEMPD) = column N+3
;
getNext3ColumnAddresses:
                jsr getNextColumnAddress
                stx ZTEMP+0
                sta ZTEMP+1
                jsr getNextColumnAddress
                stx ZTEMPB+0
                sta ZTEMPB+1
                .cerror *!=getNextColumnAddress

;-------------------------------------------------------------------------
;
; Get address of next column on screen.
;
; entry:
;
; A (MSB)/X (LSB) = address
;
; exit:
;
; A (MSB)/X (LSB) = address of next column
; (ZTEMPD) = address of next column
;
getNextColumnAddress:
                pha
                txa
                clc
                adc #$08                     ;next column...
                tax
                pla
                bcc +                        ;taken if no carry
                inc a
                bpl +           ;taken if no screen address wraparound
                lda vduv.startScreenAddressHighByte
+
                stx ZTEMPD+0
                sta ZTEMPD+1
                rts

;-------------------------------------------------------------------------
;
; VDU 23 0 Control 6845 CRTC directly [MasRef E.3-12]
;
vdu23_0_EntryPoint:
                lda vduv.queueEnd-7           ;get value
                ldy vduv.queueEnd-8           ;get register

                ; fall through to setCRTCRegister

;-------------------------------------------------------------------------
;
; Set a CRTC register, adjusting and/or noting values if appropriate.
;
; entry:
;
; Y = register to set
;
; A = value

setCRTCRegister:
                cpy #$07
                bcc setCRTCRegisterRaw
                bne +        ;taken if not setting R7

                ; Setting R7 (vsync position), so apply the *TV offset.
                adc tvOffset
+
                cpy #$08
                bne +                    ;taken if not setting R8

                ; Setting R8 (interlace/delay register), so apply the
                ; *TV interlace setting.
                ora #$00
                bmi +       ;branch taken if bit 7 set - this is taken
                            ;to imply the mode being set is Mode 7
                eor tvInterlace ;apply *TV interlace setting
+
                cpy #$0A
                bne setCRTCRegisterRaw

                ; Setting R10 (cursor start register). Note the new
                ; setting in the VDU variable. If in VDU5 mode, reuse
                ; the result of testVDU5State - i.e., 32 - as the
                ; setting, hiding the cursor.
                sta vduv.lastCursorStartRegisterValue
                .testVDU5State
                bne rtsCF2A
                lda vduv.lastCursorStartRegisterValue

                ; fall through to setCRTCRegisterRaw

;-------------------------------------------------------------------------
;
; Set a CRTC register.
;
setCRTCRegisterRaw:
                sty CRTC+0
                sta CRTC+1
rtsCF2A:
                rts

;-------------------------------------------------------------------------
;
; VDU 23 1 Turn cursor on/off [MasRef E.3-12]
;
vdu23_1_EntryPoint:
                .testVDU5State
                bne rtsCF2A                  ;taken if VDU5
                lda vduv.queueEnd-8           ;get new cursor state
                and #$03                     ;mask off bits of interest
                asl a
                tax
                lda #$20 ;R10 value for hiding the cursor - save a few
                         ;bytes by loading this here
                jmp (LCF3C,x)

LCF3C:
                .word setCRTCRegister10            ; 23,1,0... - hide
                .word showCursor            ; 23,1,1... - show
                .word steadyCursor          ; 23,1,2... - steady
                .word slowFlashCursor       ; 23,1,3... - flash slowly

steadyCursor:
                lda #%01100000
                trb vduv.lastCursorStartRegisterValue ;steady cursor
                bra showCursor

slowFlashCursor:
                lda #%01100000
                tsb vduv.lastCursorStartRegisterValue ;slow blink cursor
showCursor:
                lda vduv.lastCursorStartRegisterValue
setCRTCRegister10:
                ldy #$0A
                bra setCRTCRegisterRaw

;-------------------------------------------------------------------------
;
; VDU 23 2-5 Set ECF patterns [MasRef E.3-13]
;
vdu23_2_EntryPoint:
vdu23_3_EntryPoint:
vdu23_4_EntryPoint:
vdu23_5_EntryPoint:
                sbc #$01  ;subtract 2 (C=0 on entry...) to get pattern
                          ;index
                asl a
                asl a
                asl a                        ;index*8
                adc #$07                     ;index*8+7
                tay
                ldx #$07
-
                lda vduv.queueEnd-8,x
                sta andy.ecfPatterns,y
                dey
                dex
                bpl -
                bra LCF93

;-------------------------------------------------------------------------

vdu23_11_EntryPoint:
                lda vduv.currentScreenMODE
                bne +
                ; Use a different table for MODE 0 - see MasRef E.3-16.
                dec a                        ;
+
                and #$03 ;index=0 (mode 4); 1 (mode 1/5); 2 (mode 2);
                         ;3 (mode 0)
                inc a
                asl a
                asl a
                asl a
                asl a                        ;(index+1)*16
                tax
                ldy #32-4
setDefaultECFPatterns:
                lda defaultECFPatterns-1,x
                sta andy.ecfPatterns-1,y     ;copy first repeat
                sta andy.ecfPatterns+4-1,y   ;copy second repeat
                dex                          ;next byte in defaults table
                dey
                tya
                bit #$07
                bne setDefaultECFPatterns ;taken if pattern not filled
                ; skip to start of previous pattern
                dey
                dey
                dey
                dey
                bpl setDefaultECFPatterns
LCF93:
                jmp initializeCurrentECFPatterns

;-------------------------------------------------------------------------
;
; VDU 23 12-15 Set simple ECF pattern [MasRef E.3-17]
;
vdu23_12_EntryPoint:
vdu23_13_EntryPoint:
vdu23_14_EntryPoint:
vdu23_15_EntryPoint:
                sbc #$0B                     ;-12 to get pattern index
                asl a                        ;index*2
                asl a                        ;index*4
                asl a                        ;index*8, C=0
                adc #$03                     ;index*8+3, C=0
                pha                          ;save offset
                ldx #$07                     ;
LCFA0:
                lda vduv.queueEnd-8,x        ;get simple pattern byte
                and vduv.numberOfLogicalColoursMinusOne ;apply logical colour limit
                sta ZTEMP+0
                lda vduv.numberOfLogicalColoursMinusOne
                and #$07                     ;1/3/7
                adc ZTEMP+0                  ;select 2/4/16 colour table
                tay
                lda solidColoursTable-1,y
                sta vduv.queueEnd-8,x
                dex
                bpl LCFA0
                lda #%01010101
                ldx vduv.currentScreenMODE
                bne +                 ;taken if not MODE 0
                lda #%00110011        ;double-width pattern for MODE 0
+
                sta ZTEMP+0
                ply
                ldx #$07
LCFC7:
                lda vduv.queueEnd-8,x
                dex
                eor vduv.queueEnd-8,x
                and ZTEMP+0
                eor vduv.queueEnd-8,x
                sta andy.ecfPatterns+0,y
                sta andy.ecfPatterns+4,y
                dey
                dex
                bpl LCFC7
                bra LCF93

;-------------------------------------------------------------------------
;
; VDU 23 6 Set dotted lines pattern [MasRef E.3-13]
;
vdu23_6_EntryPoint:
                lda vduv.queueEnd-8
                sta vduv.dotPattern
                rts

;-------------------------------------------------------------------------
;
; VDU 23 7 Scroll window directly [MasRef E.3-14]
;
vdu23_7_EntryPoint:
                lda vduv.queueEnd-8           ;get <m>
                bne scrollEntireScreen
                jsr copyTextWindowToWorkspace2C
                lda STATE
                and #STATE.isTextWindow
                asl a ;A=$10 (text window active) or $00 (no text window)
                bra +

scrollEntireScreen:
                lda #$00
                sta vduv.workspace._2C          ;left
                sta vduv.workspace._2F          ;top
                jsr getDefaultBoundsForCurrentScreenMODE
                stx vduv.workspace._2E          ;right
                sty vduv.workspace._2D          ;bottom
+
                sta ZTEMPB+0
                sec
                lda vduv.workspace._2E          ;right
                sbc vduv.workspace._2C          ;right-left
                jsr getBytesPerInclusiveTextRow
                sta vduv.workspace._28+0        ;bytes per row LSB
                stx vduv.workspace._28+1        ;bytes per row MSB
                ldx vduv.bytesPerCharacter
                cpx #$01
                beq +  ;when 1 byte/char, no cell/byte distinction
                lda vduv.queueEnd-6       ;get <z>
                beq +                ;taken if scrolling by 1 cell
                ldx #$08                 ;scroll by 1 horizontal byte
+
                stx vduv.workspace._2A

; <d> is a bitmask - %00000AVN.
;
; A is set if scrolling by axis (controlled by the VDU cursor flags)
; rather than by direction.
;
; V is set to scroll vertically/in Y rather than horizontally/in X.
;
; N is set to scroll in the negative direction.

                lda vduv.queueEnd-7           ;00000avn C=?
                lsr a                        ;000000av C=n
                php
                rol a                        ;00000avn C=0
                plp                          ;00000avn C=n
                rol a                        ;0000avnn C=0
                asl a                        ;000avnn0 C=0
                cmp #$10                     ;$10 = 000a0000
                bcc LD039                 ;taken if scrolling by direction
                eor vduv.cursorFlags       ;adjust axes
LD039:
                and #vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal
                ora ZTEMPB+0
LD03D:
                tax
                lda vduv.screenTopLeftAddress+0
                sta ZMEMT+0
                lda vduv.screenTopLeftAddress+1
                sta ZMEMT+1
                jsr callScrollRoutine
                jmp updateCRTCTextCursor

callScrollRoutine:
                jmp (scrollRoutinesTable,x)

LD051:
                phx
                jsr copyTextWindowToWorkspace2C
                jsr copyTextWindowWidthInBytesToWorkspace28
                ldx $034F
                stx $032A
                pla
                lsr a
                eor STATE
                and #(~STATE.isTextWindow)&$ff
                eor STATE
                asl a
                bra LD03D

;-------------------------------------------------------------------------
;
; VDU 23 8 Clear block [MasRef E.3-15]
;
vdu23_8_EntryPoint:
                stz $0334
                stz $0335
                jsr getTextCursorPositionWithColumn81
                stx $0336
                sty $0337
                jsr LE25C
                inx
                stx $0338
                sty $0339
                ldy #$00
                lda $031C
                jsr LD0E5
                lda $031D
                jsr LD0E5
                lda $0333
                cmp $0331
                bcc LD10E
                bne LD0A2
                lda $0330
                cmp $0332
                bcs LD10E
LD0A2:
                lda $0318
                pha
                lda $0319
                pha
                ldy $0331
LD0AD:
                phy
                lda $0366
                eor #$08
                and #$0E
                tax
                tya
                jsr setTextCursorXPositionWithCursorFlags
                ldx #$00
                lda $0338
                cpy $0331
                bne LD0C7
                ldx $0330
LD0C7:
                cpy $0333
                beq LD0D3
                jsr LCA7F
                ply
                iny
                bra LD0AD

LD0D3:
                lda $0332
                jsr LCA7F
                ply
                pla
                sta $0319
                pla
                sta $0318
                jmp updateZMEMTWithTextCursorPosition

LD0E5:
                pha
                and #$03
                asl a
                jsr LD0F0
                pla
                lsr a
                ora #$01
LD0F0:
                tax
                and #$01
                pha
                lda $0334,x
                plx
                clc
                iny
                adc $031D,y
                bmi LD109
                cmp $0338,x
                bcc LD10B
                lda $0338,x
                bra LD10B

LD109:
                lda #$00
LD10B:
                sta $032F,y
LD10E:
                rts

;-------------------------------------------------------------------------
;
; VDU 23 9 Set 1st flash time [MasRef E.3-16]
;
vdu23_9_EntryPoint:
                sec

;-------------------------------------------------------------------------
;
; VDU 23 10 Set 2nd flash time [MasRef E.3-16]
;
vdu23_10_EntryPoint:
                ldx vduv.queueEnd-8          ;get flash value
                ldy #$00                     ;Y=0 for OSBYTE call
                bcc doOSBYTE0A               ;taken if VDU23,10
                jmp osbyte09
doOSBYTE0A:
                sec
                jmp osbyte0A

;-------------------------------------------------------------------------
;
; VDU 23 16 Cursor movement control [MasRef E.3-17]
;
vdu23_16_EntryPoint:
                lda vduv.cursorFlags
                and vduv.queueEnd-7          ;value AND <y>
                eor vduv.queueEnd-8          ;(value AND <y>) EOR <x>
                sta vduv.cursorFlags
                lsr a
                bcs rtsD145            ;taken if scrollProtect flag on
                ; scroll protect flag is off, so handle column 81 if
                ; necessary.

;-------------------------------------------------------------------------
;
; Handle column 81, if necessary.
;
; TODO - probably misnamed due to the return value
;
; exit:
;
; C=0 if not VDU 5
;
; C=1 if VDU 5
;
handleColumn81:
                .if fasterOSWRCH

                pha

                lda STATE
                and #STATE.isVDU5
                cmp #$20       ; C=1 if VDU5
                bcs pla_rts    ; taken if VDU5 - return with carry set

                ; not VDU5
                bit vduv.column81
                bpl pla_rts                  ; taken if not column 81

                php
                phx
                jsr vdu13EntryPoint          ; CR
                jsr vdu10EntryPoint          ; LF
                plx
                plp

pla_rts:
                pla
rtsD145:
                rts

                .else
                
                pha
                phx
                jsr testVDU5StateNonInlined
                sec
                bne plx_pla_rts        ;taken if VDU5
                clc
                bit vduv.column81
                bpl plx_pla_rts        ;taken if not column 81
                php
                jsr vdu13EntryPoint          ;CR
                jsr vdu10EntryPoint          ;LF
                plp
plx_pla_rts:
                plx
                pla
rtsD145:
                rts

                .endif

;-------------------------------------------------------------------------
;
; Handle PLOT. [MasRef E.3-21]
;
; PLOT numbers are of the form %pppppamm, where %ppppp is the PLOT
; type, %a the absolute flag and %mm the PLOT mode.
;
; Absolute flag and mode are clear enough from [MasRef E.3-22]. The
; %ppppp part isn't documented as such, so here's a list:
;
; %00000 =  0 = 0-7 = Plot solid line (both endpoints included) [MasRef E.3-23]
; %00001 =  1 = 8-15 = Plot solid line (final point omitted) [MasRef E.3-23]
; %00010 =  2 = 16-23 = Plot solid line (final point omitted) [MasRef E.3-23]
; %00011 =  3 = 24-31 = Plot dotted line (final point omitted) [MasRef E.3-23]
; %00100 =  4 = 32-39 = Plot solid line (initial point omitted) [MasRef E.3-24]
; %00101 =  5 = 40-47 = Plot solid line (both endpoints omitted) [MasRef E.3-24]
; %00110 =  6 = 48-55 = Plot dotted line (initial point omitted) [MasRef E.3-24]
; %00111 =  7 = 56-63 = Plot dotted line (both endpoints omitted) [MasRef E.3-24]
; %01000 =  8 = 64-71 = Plot point [MasRef E.3-24]
; %01001 =  9 = 72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
; %01010 = 10 = 80-87 = Plot triangle [MasRef E.3-25]
; %01011 = 11 = 88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
; %01100 = 12 = 96-103 = Plot rectangle [MasRef E.3-26]
; %01101 = 13 = 104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
; %01110 = 14 = 112-119 = Plot parallelogram [MasRef E.3-27]
; %01111 = 15 = 120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
; %10000 = 16 = 128-135 = Flood fill to non-background [MasRef E.3-28]
; %10001 = 17 = 136-143 = Flood fill to foreground [MasRef E.3-28]
; %10010 = 18 = 144-151 = Plot circle outline [MasRef E.3-28]
; %10011 = 19 = 152-159 = Plot filled circle [MasRef E.3-29]
; %10100 = 20 = 160-167 = Plot circular arc [MasRef E.3-29]
; %10101 = 21 = 168-175 = Plot filled chord segment [MasRef E.3-30]
; %10110 = 22 = 176-183 = Plot filled sector [MasRef E.3-30]
; %10111 = 23 = 184-191 = Move/copy rectangle [MasRef E.3-31]
; %11000 = 24 = 192-199 = Plot ellipse outline [MasRef E.3-32]
; %11001 = 25 = 200-207 = Plot solid ellipse [MasRef E.3-32]
; %11010 = 26 = 208-215 = Reserved [MasRef E.3-34]
; %11011 = 27 = 215-223 = Reserved [MasRef E.3-34]
; %11100 = 28 = 224-231 = Reserved [MasRef E.3-34]
; %11101 = 29 = 232-239 = Reserved for Acornsoft sprites [MasRef E.3-34]
; %11110 = 30 = 240-247 = User program calls [MasRef E.3-34]
; %11111 = 31 = 248-255 = User program calls [MasRef E.3-34]
;
; entry:
;
; vduQueueEnd-5 = PLOT number
;
; vduQueueEnd-3 = X coordinate
;
; vduQueueEnd-1 = Y coordinate
;;

handlePLOT:
                ldx #VDUVariables.queueEnd-4
                jsr eigabsForPLOT
                lda vduv.queueEnd-5          ;get PLOT number
                ldy #gcolModeLeave                     ;
                and #$03                     ;mask out colour/plot mode [MasRef E.3-22]
                beq LD160 ;taken if <p> MOD 4=0 - early out
                lsr a                        ;C=1 if using VDU18 settings
                dey                          ;Y=gcolModeInvert
                bcc LD160                    ;taken if invert mode
                tax              ;X=0 if fg settings, 1 if bg settings
                ldy vduv.foregroundGCOLMode,x
                asl a
                asl a
                asl a
                tax              ;X=0 if fg settings, 8 if bg settings
LD160:
                stx vduv.graphicsPlotState
                tya
                and #$0F
                sta vduv.graphicsPlotMode
                lda vduv.queueEnd-5          ;get PLOT number pppppmmm
                lsr a                        ;0pppppmm
                lsr a                        ;00pppppm
                and #$fe                     ;00ppppp0
                tax
                cmp #208/4
                bcs LD190                    ;taken if reserved PLOT
                and #$F3                     ;00pp00p0
                cmp #$12                     ;
                php                          ;
                beq LD184                ;taken if horizonal line fill
                cpx #184/4
                beq LD184                ;taken if move/copy rectangle
                cpy #gcolModeLeave
                beq LD19D
LD184:
                lda vduv.queueEnd-5          ;get PLOT number
                jsr LD193
                plp
                bne LD19E
                jmp LC4DF

LD190:
                jmp callVDUVForPLOT

LD193:
                cpx #64/4
                bcs LD19A                     ;taken if PLOT >=64
                jmp LD8A9                    ;handle line PLOTs

LD19A:
                jmp (plotEntryPointTable-8*2,x)

LD19D:
                pla
LD19E:
                jsr copyGraphicsCursorPixelsToOldGraphicsCursorPixels
                ldy #$24
                jmp copyLastFourVDUQueueBytes

LD1A6:
                ldx #VDUVariables.graphicsCursorPixelsX

;-------------------------------------------------------------------------
;
; WIND [MasRef E.4-7]. The result is a bit field, %vvhh, where %vv is
; the outcode for the vertical axis and %hh the outcode for the
; horizontal axis. Each outcode is %xn, where x is set if point above
; maximum and n set if point below minimum. (Of course, %11 is then
; not possible.)
;
; See https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm
;
; So the possible results, in binary, are:
;
; %1001 | %1000 | %1010
; ------+-------+------
; %0001 | %0000 | %0010
; ------+-------+------
; %0101 | %0100 | %0110
;
windEntryPoint:
                inx
                inx                          ;point to Y coordinate
                jsr getOutcodeForYAxis                    ;process Y coordinate
                dex
                dex                          ;point to X coordinate
                asl a
                asl a                        ;shift Y outcode into bits 2/3
                ldy #$00                     ;doing Y axis
                bra updateOutcodeForAxis

;-------------------------------------------------------------------------
;
getOutcodeForYAxis:
                ldy #$02                     ;Y=2 for Y coordinate
;-------------------------------------------------------------------------
;
; Get outcode for X or Y axis.
;
; entry:
;
; X = offset in VDU variables of coordinate
;
; Y = 0 if X axis, 2 if Y axis
;
; exit:
;
; ZTEMP?0 = outcode - 0, 1 or 2
;
; A = outcode
;
; N/Z set as per outcode
;
getOutcodeForAxis:
                lda #$00                     ;initialize result

;-------------------------------------------------------------------------
;
; Update outcode for X or Y axis
;
; entry: as per getOutcodeForAxis
;
; exit:
;
; ZTEMP?0 = updated; outcode is added to its existing value
;
updateOutcodeForAxis:
                sta ZTEMP+0                  ;save current result
                ; set flags for coordinate-minimum
                lda vduv+0,x
                cmp vduv.graphicsWindowPixelsLeft+0,y
                lda vduv+1,x
                sbc vduv.graphicsWindowPixelsLeft+1,y
                bmi add1ToOutcode ;taken if point below minimum - outcode is 1

                ; set flags for maximum-coordinate
                lda vduv.graphicsWindowPixelsRight+0,y
                cmp vduv+0,x
                lda vduv.graphicsWindowPixelsRight+1,y
                sbc vduv+1,x
                bpl gotOutcode ;taken if point below maximum - axis outcode is 0
                ; point is above maximum - axis outcode is 2
add2ToOutcode:
                inc ZTEMP+0
add1ToOutcode:
                inc ZTEMP+0
gotOutcode:
                lda ZTEMP+0
                rts

;-------------------------------------------------------------------------
;
; EIGABS entry point.
;
eigabsEntryPoint:
                lda #$FF ;pretend it's PLOT 255 (as that would be absolute coordinates)
                bra eigabsCommon

;-------------------------------------------------------------------------
;
; EIGABS, but for a VDU 25. Handles relative/absolute addressing,
; based on the PLOT number in the VDU queue.
;
eigabsForPLOT:
                lda vduv.queueEnd-5          ;get PLOT number

;-------------------------------------------------------------------------
;
; EIGABS shared code.
;
eigabsCommon:
                sta ZTEMP+0                  ;save PLOT number
                ldy #$02                     ;process Y
                jsr handleExternalCoordinate
                jsr divideCoordinatesBy2     ;divide Y by 4 - convert 0-1023 to 0-255
                ldy #$00                     ;process X
                dex                          ;...
                dex                          ;...
                jsr handleExternalCoordinate
                ldy vduv.pixelsPerByteMinusOne
                cpy #$03  ;
                beq +     ;branch taken if mode 1/5 - divide by 4 or 8
                bcs ++    ;branch taken if mode 0/4 - divide by 2 or 4
                jsr divideCoordinatesBy2     ;mode 2 - divide by 8
+
                jsr divideCoordinatesBy2
+
                lda vduv.currentScreenMODEGroup
                bne divideCoordinatesBy2     ;branch taken if MODE 4/5
                rts

;-------------------------------------------------------------------------
;
; Handle external coordinate.
;
; 1. Deal with absolute or relative PLOTting
;
; 2. Update graphics cursor position
;
; 3. Handle window origin
;
; 4. Update input coordinate
;
; 5. Divide result by 2 (as this always needs doing at least once)
;
; entry:
;
; ZTEMP?0 = PLOT number
;
; X = offset-2 of external coordinates
;
; Y = 0 to process X coordinate, 2 to process Y coordinate
;
handleExternalCoordinate:
                clc
                lda ZTEMP+0                  ;get PLOT number
                and #$04                     ;get absolute/relative flag
                beq relativePLOT             ;branch taken if relative
absolutePLOT:
                lda vduv+2,x                 ;get coordinate LSB
                pha                          ;save coordinate LSB
                lda vduv+3,x                 ;get coordinate MSB
                bra LD229                    ;

relativePLOT:
                lda vduv+2,x                 ;get coordinate LSB
                adc vduv.graphicsCursorPositionX+0,y ;add current position LSB
                pha                                  ;save coordinate LSB
                lda vduv+3,x                 ;get coordinate MSB
                adc vduv.graphicsCursorPositionX+1,y ;add current position MSB
                clc
LD229:
                sta vduv.graphicsCursorPositionX+1,y ;update current position MSB
                adc vduv.graphicsWindowOriginX+1,y   ;add window origin MSB
                sta vduv+3,x                  ;update coordinate MSB
                pla                          ;restore coordinate LSB
                sta vduv.graphicsCursorPositionX+0,y ;update current position LSB
                clc
                adc vduv.graphicsWindowOriginX+0,y ;add window origin LSB
                sta vduv+2,x                       ;update coordinate LSB
                bcc +
                inc vduv+3,x       ;handle carry, ignored earlier
+

divideCoordinatesBy2:
                lda vduv+3,x
                asl a                        ;C=bit 7
                ror vduv+3,x                  ;signed divide by 2
                ror vduv+2,x                  ;signed divide by 2
                rts

;-------------------------------------------------------------------------

LD24D:
                phx
                phy
                phy
                phx
                phy
                jsr LD280
                plx
                jsr LD280
                plx
                ply
                jsr LDAE8
                plx
                jsr LD268
                plx
                bra LD268

LD265:
                jsr L9B09
LD268:
                ldy #$00
                jsr LD270
                inx
                ldy #$02
LD270:
                sec
                jsr LD276
                inx
                iny
LD276:
                lda $0300,x
                sbc $0314,y
                sta $0300,x
LD27F:
                rts

LD280:
                ldy #$00
                jsr LD288
                inx
                ldy #$02
LD288:
                clc
                jsr LD28E
                inx
                iny
LD28E:
                lda $0300,x
                adc $0314,y
                sta $0300,x
                rts

LD298:
                sta $E1
                jsr LD425
                beq LD27F
                ldy #$14
                lda #$20
                ldx #$2C
                jsr LD265
                jsr LD3AA
                lda #$01
LD2AD:
                sty $E0
                tsb $E0
                ldx #VDUVariables.workspace._2C
                ldy #VDUVariables.workspace._28
                jsr copyFourBytesWithinVDUVariables
                bit $0335
                php
                ldx #$2C
                jsr LD726
                plp
                bpl LD2C7
                jsr LD3AA
LD2C7:
                ldy $032C
                lda $032D
                bmi LD2D2
                jsr negateAY
LD2D2:
                pha
                clc
                tya
                adc L8830
                tay
                pla
                adc L8831
                bpl LD2AD
                inc a
                bne LD305
                iny
                bne LD305
                lda $E0
                beq LD305
                lda $032C
                cmp $0328
                beq LD305
                ldx #$2C
                ldy #$28
                lda $0336
                asl a
                eor $0336
                bpl LD302
                inx
                inx
                iny
                iny
LD302:
                jsr copyTwoBytesWithinVDUVariables
LD305:
                jsr LD425
                lda $0329
                tax
                eor $031C
                bmi LD329
                ldy #$02
                jsr LD46F
                bne LD324
                ldx $032B
                ldy #$00
                jsr LD46F
                beq LD333
                eor #$80
LD324:
                stx $DA
                eor $DA
                tax
LD329:
                txa
                and #$80
                beq LD330
                lda #$C0
LD330:
                tsb $E1
                clc
LD333:
                rts

LD334:
                lda $E1
                sta L8848
                bit #$03
                beq LD333
                lda #$10
                sta $DC
                asl a
                sta $DD
                ldx #$1B
                jsr LD34F
                asl $DC
                lsr $DD
                ldx #$28
LD34F:
                lda #$80
                sta $DA
                lda $0302,x
                cmp L8832
                bne LD333
                lda $0303,x
                cmp L8833
                bne LD333
                ldy $0300,x
                lda $0301,x
                bpl LD370
                lsr $DA
                jsr negateAY
LD370:
                cpy L8830
                bne LD333
                cmp L8831
                bne LD333
                lda $E1
                bit #$02
                beq LD399
                ldy #$30
                bit #$01
                beq LD388
                ldy $DC
LD388:
                tya
                lsr a
                lsr a
                bit $E1
                bne LD395
                ora $DC
                tsb $E1
                bra LD399

LD395:
                ora $DD
                trb $E1
LD399:
                lda $DA
                bit $E1
                beq LD330
                trb $E1
                lda $E1
                sta L8848
                sta L8849
                rts

LD3AA:
                lda $032E
                sta L8832
                lda $032F
                sta L8833
                jsr LD3FC
                jsr LD513
                sty L8830
                lda L8846
                lsr a
                lda L883D
                bcc LD3CE
                cmp #$80
                ror a
                ror L8830
LD3CE:
                sta L8831
                rts

LD3D2:
                stz L8847
                stz L8830
                stz L8831
                stz L8834
                stz L8835
                lda L8832
                asl a
                sta L8836
                lda L8833
                rol a
                sta L8837
                lda L8846
                bit #$02
                beq LD3FC
                asl L8836
                rol L8837
LD3FC:
                lda L8846
                lsr a
                lsr a
                ldy L8832
                lda L8833
                jsr LD4C5
                sec
                ldx #$FC
LD40D:
                lda L873C,x
                sbc L8744,x
                sta L8744,x
                inx
                bne LD40D
                rts

LD41A:
                jsr copyGraphicsCursorPixelsToOldGraphicsCursorPixels
                stz $E1
                ldx #$20
                jsr LD427
                rts

LD425:
                ldx #VDUVariables.graphicsCursorPixelsX
LD427:
                ldy #VDUVariables.queueEnd-9
                jsr copyFourBytesWithinVDUVariables
                ldx #$1B
                jsr LD268
                jsr LD486
                jsr LD513
                ldy #$0C
                jsr LD4AB
                jsr LD513
                cmp #$20
                bcc LD448
                pla
                pla
                pla
                pla
                rts

LD448:
                sty L8844
                sta L8845
                lda L8846
                bit #$02
                beq LD45B
                lsr L8845
                ror L8844
LD45B:
                ldy L8844
                lda L8845
                jsr negateAY
                sty L8832
                sta L8833
                ora L8832
                sec
                rts

LD46F:
                stz $DA
                lda $031B,y
                cmp $0328,y
                beq LD47B
                inc $DA
LD47B:
                lda $031C,y
                sbc $0329,y
                bne LD485
                lda $DA
LD485:
                rts

LD486:
                ldx $0355
                lda LD4BF,x
                sta L8846
                lsr a
                pha
                ldx #$04
LD493:
                stz L8837,x
                dex
                bne LD493
                jsr LD4A0
                pla
                lsr a
                ldx #$02
LD4A0:
                ldy $031B,x
                lda $031C,x
                jsr LD4C5
                ldy #$10
LD4AB:
                clc
                ldx #$FC
LD4AE:
                lda L873C,x
                adc L8830,y
                sta L873C,x
                sta L8744,x
                iny
                inx
                bne LD4AE
                rts

LD4BF:
                .byte $02
                brk
                ora ($FF,x)
                brk
;ORA (&8C,x)      :\ D4C4= 01       ..
                .byte $01
LD4C5:
                sty L883C
                bcc LD4CE
                asl L883C
                rol a
LD4CE:
                sta L883D
                ldy L883C
                tax
                bpl LD4DA
                jsr negateAY
LD4DA:
                sty L883C
                sta L883D
                sty L8840
                stz L8842
                stz L8843
                ldy #$0F
                lsr a
                sta L8841
                ror L8840
LD4F2:
                bcc LD507
                clc
                lda L883C
                adc L8842
                sta L8842
                lda L883D
                adc L8843
                sta L8843
LD507:
                ldx #$03
LD509:
                ror L8840,x
                dex
                bpl LD509
                dey
                bpl LD4F2
                rts

LD513:
                ldx #$02
LD515:
                stz L883C,x
                stz $DB,x
                dex
                bpl LD515
                ldy #$03
LD51F:
                lda L8840,y
                sta $DA
                phy
                ldy #$03
LD527:
                phy
                sec
                rol L883C
                rol L883D
                rol L883E
                ldx #$01
                lda $DB
LD536:
                asl $DA
                rol a
                rol $DC
                rol $DD
                dex
                bpl LD536
                sta $DB
                sec
                sbc L883C
                tax
                lda $DC
                sbc L883D
                tay
                lda $DD
                sbc L883E
                bcc LD55F
                sta $DD
                sty $DC
                stx $DB
                inc L883C
                bra LD562

LD55F:
                dec L883C
LD562:
                ply
                dey
                bpl LD527
                ply
                dey
                bpl LD51F
                lsr L883E
                ror L883D
                ror L883C
                stz L883E
                stz L883F
                ldy L883C
                lda L883D
                rts

;-------------------------------------------------------------------------
;
; Add dimension of region to a coordinate.
;
; entry:
;
; X = VDU variable offset of coordinate
;
; A = VDU variable offset of minimum coordinate of region
;
; Y = VDU variable offset of maximum coordinate of region
;
; ZTEMP?0 = VDU variable offset for result
;
; exit:
;
; result variable = coordinate+(min-max)
;
addRegionDimensionsToVDUVariableCoordinates:
                jsr addRegionDimensionToVDUVariableCoordinate ;do X

                ; bump offsets to do Y.
                iny
                iny
                inx
                inx
                inc a
                inc a
                inc ZTEMP+0
                inc ZTEMP+0

                ; TODO - not a great name. Could probably just be
                ; addDifference, or something.
addRegionDimensionToVDUVariableCoordinate:
                phx                          ;save VX
                phy                          ;save VY
                pha                          ;save VA
                clc
                lda vduv+0,x                 ;<VX
                adc vduv+0,y                 ;<(VX+VY)
                sta ZTEMPC+0                 ;ZTEMPC?0=<(VX+VY)
                lda vduv+1,x                 ;>VX
                adc vduv+1,y                 ;>(VX+VY)
                plx                          ;X=VA
                pha                          ;save >(VX+VY)
                ldy ZTEMP+0                  ;Y=VT
                sec
                lda ZTEMPC+0                 ;<(VX+VY)
                sbc vduv+0,x                 ;<(VX+VY-VA)
                sta vduv+0,y                 ;<VT=<(VX+VY-VA)
                pla                          ;>(VX+VY)
                sbc vduv+1,x                 ;>(VX+VY-VA)
                sta vduv+1,y                 ;>VT=<(VX+VY-VA)
                txa                          ;restore old A
                ply                          ;restore old Y
                plx                          ;restore old X
                rts

;-------------------------------------------------------------------------
;
; Sort points by Y coordinate, then X.
;
; entry:
;
; X = VDU variable offset of point A (4 bytes: X;Y;)
;
; Y = VDU variable offset of point B (4 bytes: X;Y;)
;
; exit:
;
; X = offset of point with lesser Y (or lesser X, if same Y)
;
; Y = offset of point with greater Y (or greater X, if same Y)
;
sortVDUVariableCoordinates:
                sec
                lda vduv+2,y
                sbc vduv+2,x
                sta ZTEMPC
                lda vduv+3,y
                sbc vduv+3,x
                bmi exchangeXAndY           ;taken if PX.y>PY.y
                ora ZTEMPC
                bne rtsD5D5                  ;taken if PX.y<PY.y

;-------------------------------------------------------------------------
;
; Sort words by value.
;
; entry:
;
; X = VDU variable offset of word A
;
; Y = VDU variable offset of word B
;
; exit:
;
; X = offset of lesser value
;
; Y = offset of greater value
;
sortVDUVariableWords:
                jsr compareVDUVariableWords
                bpl rtsD5D5
exchangeXAndY:
                txa
                phy
                plx
                tay
rtsD5D5:
                rts

;-------------------------------------------------------------------------
;
; Compare 2 16-bit VDU variable values.
;
; entry:
;
; X = offset of one variable
;
; Y = offset of the other variable
;
; exit:
;
; N=1 if X>Y
;
compareVDUVariableWords:
                lda vduv+0,y
                cmp vduv+0,x
                lda vduv+1,y
                sbc vduv+1,x
                rts

;-------------------------------------------------------------------------

LD5E3:
                inc L8847
LD5E6:
                lda L8847
                bne LD5FA
                lda L8832
                ora L8833
                beq LD5E3
                ldx #$00
                jsr LD644
                bpl LD643
LD5FA:
                ldx #$02
                jsr LD644
                bpl LD643
                ldx #$00
                jsr LD60A
                bpl LD643
                ldx #$02
LD60A:
                lda L8830,x
                bne LD612
                dec L8831,x
LD612:
                dec L8830,x
                txa
                lsr a
                inc a
                bit L8846
                beq LD620
                jsr LD620
LD620:
                jsr LD636
                clc
                lda L8840
                adc L8834,x
                sta L8840
                lda L8841
                adc L8835,x
                sta L8841
LD636:
                php
                lda L8834,x
                bne LD63F
                dec L8835,x
LD63F:
                dec L8834,x
                plp
LD643:
                rts

LD644:
                inc L8830,x
                bne LD64C
                inc L8831,x
LD64C:
                txa
                lsr a
                inc a
                bit L8846
                beq LD657
                jsr LD657
LD657:
                jsr LD66D
                sec
                lda L8840
                sbc L8834,x
                sta L8840
                lda L8841
                sbc L8835,x
                sta L8841
LD66D:
                php
                inc L8834,x
                bne LD676
                inc L8835,x
LD676:
                plp
                rts

LD678:
                pha
                sec
                lda $0300,y
                sbc $0300,x
                pha
                lda $0301,y
                sbc $0301,x
                ply
                cmp #$80
                bcc LD68F
                jsr negateAY
LD68F:
                plx
                sta $0301,x
                tya
                sta $0300,x
                rts

LD698:
                ldx #$37
                jsr LD723
LD69D:
                bit $030A,x
                bvs LD6B2
                rts

LD6A3:
                ldx #$2C
                jsr LD723
LD6A8:
                bit $030A,x
                bvc LD6B2
                rts

LD6AE:
                plx
                jsr LD726
LD6B2:
                lda $0309,x
                bmi LD6C7
                ldy #$03
                phx
LD6BA:
                lda $0300,x
                cmp L881E,x
                bne LD6AE
                inx
                dey
                bpl LD6BA
                plx
LD6C7:
                rts

LD6C8:
                jsr LD6FD
                lda $030A,x
                asl a
                asl a
                lda $030A,x
                ror a
                sta $DA
                clc
                bpl LD6E8
                lda $0302,x
                sbc $0304
                tay
                lda $0303,x
                sbc $0305
                bra LD6F5

LD6E8:
                lda $0300
                sbc $0302,x
                tay
                lda $0301
                sbc $0303,x
LD6F5:
                jsr LD7A4
                jsr LD6FD
                bra LD755

LD6FD:
                txa
                inc a
                pha
                inc a
                tay
                jsr exchangeTwoVDUBytes
                inx
                inx
                iny
                iny
                jsr exchangeTwoVDUBytes
                plx
                jsr LD711
                dex
LD711:
                lda $0308,x
                eor #$FF
                sta $0308,x
                rts

LD71A:
                jsr LD726
LD71D:
                lda $0309,x
                bpl LD71A
                rts

LD723:
                jsr LD71D
LD726:
                lda $0309,x
                bpl LD755
LD72B:
                clc
                lda $0308,x
                adc $0304,x
                sta $0308,x
                lda $0309,x
                adc $0305,x
                sta $0309,x
                bmi LD743
                jsr LD755
LD743:
                phx
                inx
                inx
                bit $0308,x
                bmi LD76E
LD74B:
                inc $0300,x
                bne LD753
                inc $0301,x
LD753:
                plx
                rts

LD755:
                sec
                lda $0308,x
                sbc $0306,x
                sta $0308,x
                lda $0309,x
                sbc $0307,x
                sta $0309,x
                phx
                bit $030A,x
                bvc LD74B
LD76E:
                lda $0300,x
                bne LD776
                dec $0301,x
LD776:
                dec $0300,x
                plx
                rts

LD77B:
                clc
                lda $030A,x
                sta $DA
                bpl LD792
                lda $0302,x
                sbc $0306
                tay
                lda $0303,x
                sbc $0307
                bra LD79F

LD792:
                lda $0302
                sbc $0302,x
                tay
                lda $0303
                sbc $0303,x
LD79F:
                jsr LD7A4
                bra LD72B

LD7A4:
                sty $DE
                sta $DF
                lda $0302,x
                ldy $0303,x
                asl $DA
                bcs LD7BC
                adc $DE
                sta $0302,x
                tya
                adc $DF
                bra LD7C4

LD7BC:
                sbc $DE
                sta $0302,x
                tya
                sbc $DF
LD7C4:
                sta $0303,x
                lda #$00
                bit $0309,x
                bpl LD7CF
                dec a
LD7CF:
                sta $DC
                lsr a
                sta $DD
                ldy #$10
LD7D6:
                lda $DD
                asl a
                rol $0308,x
                rol $0309,x
                rol $DC
                rol $DD
                asl $DE
                rol $DF
                bcc LD802
                clc
                lda $DC
                adc $0304,x
                sta $DC
                lda $DD
                adc $0305,x
                sta $DD
                bcc LD802
                inc $0308,x
                bne LD802
                inc $0309,x
LD802:
                dey
                bne LD7D6
                bit $0309,x
                bvc LD815
                lda $DC
                sta $0308,x
                lda $DD
                sta $0309,x
                rts

LD815:
                ldy #$10
LD817:
                rol $DC
                rol $DD
                rol $0308,x
                rol $0309,x
                sec
                lda $0308,x
                sbc $0306,x
                sta $DE
                lda $0309,x
                sbc $0307,x
                bcc LD83A
                sta $0309,x
                lda $DE
                sta $0308,x
LD83A:
                dey
                bne LD817
                rol $DC
                rol $DD
                sec
                lda $0308,x
                sbc $0306,x
                sta $0308,x
                lda $0309,x
                sbc $0307,x
                sta $0309,x
                lda $0300,x
                ldy $0301,x
                asl $DA
                bcs LD869
                sec
                adc $DC
                sta $0300,x
                tya
                adc $DD
                bra LD872

LD869:
                clc
                sbc $DC
                sta $0300,x
                tya
                sbc $DD
LD872:
                sta $0301,x
LD875:
                rts

LD876:
                asl $0332
                ldy #$2C
                jsr copyLastFourVDUQueueBytes
                asl $DB
                bcc LD88F
                jsr LDA26
                beq LD875
                ldx #$00
                lda $0332
                jsr LDA0F
LD88F:
                bit $DB
                bvc LD8A2
                jsr LDA26
                beq LD875
                ldx #$04
                lda $0332
                eor #$80
                jsr LDA0F
LD8A2:
                ldx #$28
                ldy #$2C
                jmp LDAE8

LD8A9:
                asl a
                asl a
                sta $DB
                and #$C0
                eor #$40
                bne LD8B9
                lda $0367
                sta $0368
LD8B9:
                jsr LD1A6
                sta $DC
                beq LD8C4
                lda #$80
                trb $DB
LD8C4:
                ldx #$20
                jsr windEntryPoint
                sta $E0
                beq LD8D7
                tax
                lda #$20
                trb $DB
                txa
                bit $DC
LD8D5:
                bne LD875
LD8D7:
                ldy #$24
                lda #$20
                ldx #$28
                jsr L9B09
                bit $DB
                bvs LD8EC
                lda $032E
                ora $032F
                beq LD876
LD8EC:
                lda $DC
                bit #$0C
                beq LD900
                ldx #$28
                jsr LD77B
                ldx #$28
                jsr windEntryPoint
                bit $E0
                bne LD8D5
LD900:
                bit #$03
                beq LD90E
                ldx #$28
                jsr LD6C8
                ldx #$28
                jsr windEntryPoint
LD90E:
                tay
                bne LD8D5
                ldy #$20
                ldx #$22
                lda $E0
                beq LD928
                ldy #$04
                ldx #$06
                bit $0332
                bpl LD924
                ldx #$02
LD924:
                bvc LD928
                ldy #$00
LD928:
                clc
                lda $0300,x
                sbc $032A
                bcc LD934
                inc a
                eor #$FF
LD934:
                sta $DC
                clc
                lda $0300,y
                sbc $0328
                tax
                lda $0301,y
                sbc $0329
                bmi LD952
                inx
                bne LD94A
                inc a
LD94A:
                eor #$FF
                tay
                txa
                eor #$FF
                tax
                tya
LD952:
                sta $DD
                stx $E0
                ldx #$28
                jsr LDF41
                asl $DB
                bcs LD989
LD95F:
                bit $DB
                bvc LD96E
                lda $E0
                and $DC
                and $DD
                inc a
                beq LD9A0
                bit $DB
LD96E:
                bpl LD979
                lda $0368
                asl a
                rol $0368
                bcc LD989
LD979:
                lda ZMASK
                and ZGORA
                ora (ZMEMG),y
                sta $DA
                lda ZMASK
                and ZGEOR
                eor $DA
                sta (ZMEMG),y
LD989:
                lda $0331
                bpl LD9DC
                inc $DC
                beq LD9A0
                bit $0332
                bmi LD9A1
                dey
                dex
                bpl LD9BF
                jsr LDA4C
                bra LD9BF

LD9A0:
                rts

LD9A1:
                iny
                inx
                cpx #$08
                bne LD9BF
                sec
                tya
                sbc #$08
                clc
                adc $0352
                tay
                lda ZMEMG+1
                adc $0353
                bpl LD9BB
                sec
                sbc $0354
LD9BB:
                sta ZMEMG+1
                ldx #$00
LD9BF:
                lda $0369
                beq LD9C7
                jsr setupColourMasks
LD9C7:
                clc
                lda $0330
                adc $032C
                sta $0330
                lda $0331
                adc $032D
                sta $0331
                bmi LD95F
LD9DC:
                inc $E0
                bne LD9E4
                inc $DD
                beq LD9A0
LD9E4:
                bit $0332
                bvs LD9F2
                lsr ZMASK
                bcc LD9F9
                jsr nextColumnAndResetMask
                bra LD9F9

LD9F2:
                asl ZMASK
                bcc LD9F9
                jsr previousColumnAndResetMask
LD9F9:
                sec
                lda $0330
                sbc $032E
                sta $0330
                lda $0331
                sbc $032F
                sta $0331
                jmp LD95F

LDA0F:
                bmi LDA1A
                inc $0328,x
                bne LDA25
                inc $0329,x
                rts

LDA1A:
                lda $0328,x
                bne LDA22
                dec $0329,x
LDA22:
                dec $0328,x
LDA25:
                rts

LDA26:
                ldy #$04
LDA28:
                lda $0327,y
                cmp $032B,y
                bne LDA33
                dey
                bne LDA28
LDA33:
                rts

;-------------------------------------------------------------------------

previousColumnAndResetMask:
                lda vduv.colourMaskRight
                sta ZMASK
                tya
                sbc #$08
                tay
                bcs rtsDA4B
                lda ZMEMG+1
                dec a
                cmp vduv.startScreenAddressHighByte
                bcs +
                lda #$7F
+
                sta ZMEMG+1
rtsDA4B:
                rts

;-------------------------------------------------------------------------

LDA4C:
                clc
                tya
                adc #$08
                sec
                sbc $0352
                tay
                lda ZMEMG+1
                sbc $0353
                cmp $034E
                bcs LDA62
                adc $0354
LDA62:
                sta ZMEMG+1
                ldx #$07
                rts

;-------------------------------------------------------------------------
;
nextColumnAndResetMask:
                lda vduv.colourMaskLeft
                sta ZMASK

;-------------------------------------------------------------------------
;
; Add 8 to (ZMEMG),Y, taking into account screen wrap.
;
; entry:
;
; C=1
;
; (ZMEMG),Y = screen address
;
; exit:
;
; (ZMEMG),Y = new screen address
;
nextColumn:
                tya
                adc #$07
                tay
                bcc +
                inc ZMEMG+1
                bpl +
                lda vduv.startScreenAddressHighByte
                sta ZMEMG+1
+
                rts

;-------------------------------------------------------------------------
;
; Set up colour masks, taking into account ECF pattern.
;
; entry:
;
; X = scanline in row, 0-7
;
setupColourMasks:
                phx                          ;save scanline
                txa                          ;A=scanline
                ora vduv.graphicsPlotState   ;0-7 if fg, 8-15 if bg
                tax
                lda andy.fgECFPattern,x      ;get appropriate ECF byte
                ldx vduv.graphicsPlotMode
                pha
                ora zgoraORTable,x
                eor zgoraEORTable,x
                sta ZGORA
                pla
                ora zgeorORTable,x
                eor zgeorEORTable,x
                sta ZGEOR
                plx
                rts

;-------------------------------------------------------------------------

LDA9C:
                lda $0301,y
                pha
                lda $0300,y
                pha
                and $0361
                clc
                adc $0361
                tay
                lda pixelMasks-1,y
                eor LE120,y
                sta $DC
                lda $0300,x
                and $0361
                adc $0361
                tay
                lda LE120,y
                sta ZMASK
                sec
                pla
                ora $0361
                sbc $0300,x
                tay
                pla
                sbc $0301,x
                sta $DD
                tya
                ldy $0361
                cpy #$03
                beq LDADF
                bcc LDAE2
                lsr $DD
                ror a
LDADF:
                lsr $DD
                ror a
LDAE2:
                lsr a
LDAE3:
                rts

LDAE4:                                       ; fillRow?
                ldx #$42
                ldy #$46
LDAE8:                                       ; fillRowInternal?
                jsr sortVDUVariableWords
                stx $DE
                sty $DF
                ldx $DF
                ldy #$00
                jsr getOutcodeForAxis
                beq LDAFF
                lsr a
                beq LDAE3
                ldx #$04
                stx $DF
LDAFF:
                ldx $DE
                jsr windEntryPoint
                lsr a
                bne LDAE3
                lda $0302,x
                bcc LDB10
                ldx #$00
                stx $DE
LDB10:
                jsr LDECB
                ldx $DE
                ldy $DF
                jsr LDA9C
                tax
                ldy $031A
                txa
                beq LDB44
                jsr plbyteEntryPoint
                bra LDB2E

LDB26:
                lda (ZMEMG),y
                ora ZGORA
                eor ZGEOR
                sta (ZMEMG),y
LDB2E:
                tya
                clc
                adc #$08
                tay
                bcc LDB3E
                inc ZMEMG+1
                bpl LDB3E
                lda $034E
                sta ZMEMG+1
LDB3E:
                dex
                bne LDB26
                dex
                stx ZMASK
LDB44:
                lda $DC
                trb ZMASK
                bra plbyteEntryPoint

;-------------------------------------------------------------------------
;
; mem mask ora eor | result
; --- ---- --- --- | ------
;  0    0   0   0  |   0
;  0    0   0   1  |   0
;  0    0   1   0  |   0
;  0    0   1   1  |   0
;  0    1   0   0  |   0
;  0    1   0   1  |   1
;  0    1   1   0  |   1
;  0    1   1   1  |   0
;  1    0   0   0  |   1
;  1    0   0   1  |   1
;  1    0   1   0  |   1
;  1    0   1   1  |   1
;  1    1   0   0  |   1
;  1    1   0   1  |   0
;  1    1   1   0  |   1
;  1    1   1   1  |   0
;
plotPoint:
                ldx #VDUVariables.queueEnd-4
plotPointInternal:
                jsr windGADDR
                bne rtsDB61                  ;taken if point outside window
plbyteEntryPoint:
                lda ZMASK
                and ZGORA
                ora (ZMEMG),y
                sta ZTEMP+0
                lda ZGEOR
                and ZMASK
                eor ZTEMP+0
oswrscCode:
                sta (ZMEMG),y
rtsDB61:
                rts

;-------------------------------------------------------------------------

LDB62:
                ldx #VDUVariables.workspace._2A
                ldy #VDUVariables.workspace._32
                jsr copyTwoBytesWithinVDUVariables
                ldx #VDUVariables.workspace._36
                ldy #VDUVariables.workspace._3E
                jsr copyTwoBytesWithinVDUVariables
                ldx #$2A
                jsr getOutcodeForYAxis
                pha
                ldx #$36
                jsr getOutcodeForYAxis
                beq LDB8C
                pla
                bne LDB85
                lda $0345
                beq LDB86
LDB85:
                rts

LDB86:
                ldx #$28
                ldy #$2C
                bra LDB93

LDB8C:
                pla
                beq LDB96
                ldx #$34
                ldy #$38
LDB93:
                jmp LDAE8

LDB96:
                ldx #$30
                jsr gaddrEntryPoint
                bit $0347
                bmi LDBA9
                tya
                sec
                sbc #$08
                tay
                bcs LDBA9
                dec ZMEMG+1
LDBA9:
                lda $0344
                sta $DD
LDBAE:
                lda (ZMEMG),y
                ldx $0342
                beq LDBB9
LDBB5:
                asl a
                dex
                bne LDBB5
LDBB9:
                sta $DA
                sec
                jsr nextColumn
                lda (ZMEMG),y
                ldx $0343
                beq LDBCA
LDBC6:
                lsr a
                dex
                bne LDBC6
LDBCA:
                eor $DA
                and $E1
                eor $DA
                ldx $DD
                sta L8830,x
                dec $DD
                bpl LDBAE
                ldx #$34
                ldy #$38
                jsr LDAE8
                lda $0345
                bne LDBE8
                jsr LDB86
LDBE8:
                ldx #$3C
                jsr gaddrEntryPoint
                lda $0346
                sta $DA
                ldx $0344
                beq LDC0C
                jsr LDC10
                lda #$FF
                sta $DA
                bra LDC05

LDC00_code:
                lda L8830,x
                sta (ZMEMG),y
LDC05:
                sec
                jsr nextColumn
                dex
                bne LDC00_code
LDC0C:
                lda $E0
                trb $DA
LDC10:
                lda L8830,x
                eor (ZMEMG),y
                and $DA
                eor (ZMEMG),y
                sta (ZMEMG),y
                rts

LDC1C:
                lda $0337
                inc a
                cmp $0336
                beq LDC47
                sta $0337
                tax
                lda $032E
                sta L8400,x
                lda $0332
                sta L8500,x
                lda $032F
                asl a
                asl a
                ora $0333
                sta L8600,x
                lda $0330
                sta L8700,x
LDC46:
                clc
LDC47:
                rts

LDC48:
                sta $032A
                ldx #$28
                jsr LDCB0
                bne LDC5C
LDC52:
                jsr LDC1C
                bcs LDC47
                jsr L9D57
                bcs LDC46
LDC5C:
                jsr LDCC1
                jsr L9D57
                bcs LDC46
                jsr LDCD7
                jsr LDCB8
                bra LDC52

;-------------------------------------------------------------------------
;
; 72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
; 88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
; 104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
; 120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
;
plotHorizontalLineFill:
                jsr copyECFPatternForLineFill
                jsr LDCB0
                clc
                bra LDC83

plotHorizontalLineFillRight:
                jsr copyECFPatternForLineFill
                jsr LDCC9
                jsr LDCD2
                bne LDC83
                jsr LDCB8
LDC83:
                php
                ldx #VDUVariables.hlfw.pixelsX
                ldy #VDUVariables.oldGraphicsCursorPixelsX
                jsr copyFourBytesWithinVDUVariables
                plp
                php
                beq LDC91
                ldx #VDUVariables.hlfw.pixelsX
LDC91:
                ldy #VDUVariables.graphicsCursorPixelsX
                jsr copyTwoBytesWithinVDUVariables
                ldx #VDUVariables.hlfw.pixelsY
                jsr copyTwoBytesWithinVDUVariables
                plp
                beq LDCA3
                bcs LDCA4
                inc $0316
LDCA3:
                rts

LDCA4:
                lda $0324
                bne LDCAC
                dec $0325
LDCAC:
                dec $0324
                rts

;-------------------------------------------------------------------------

LDCB0:
                jsr LDCD2
                bne rtsDD0A
                jsr LDD0B
LDCB8:
                ldx #$2E
                ldy #$32
                jsr LDAE8
                bra LDD07

LDCC1:
                jsr LDCC9
                ldx #$2C
                jsr LDCD9
LDCC9:
                php
                lda $E1
                eor #$08
                sta $E1
                plp
                rts

;-------------------------------------------------------------------------

LDCD2:
                ldy #VDUVariables.hlfw.pixelsX
                jsr copyFourBytesWithinVDUVariables
LDCD7:
                ldx #VDUVariables.graphicsWindowPixelsRight
LDCD9:
                ldy #VDUVariables.hlfw.pixelsLimitX
                jsr copyTwoBytesWithinVDUVariables
                ldx #VDUVariables.hlfw.pixelsLimitX
                jsr shouldFillPixel
                bne rtsDD0A  ;taken if pixel not to be filled, so done
LDCE5:
                lsr ZMASK                    ;next pixel
                bcc LDCF1                    ;taken if still in same byte
LDCE9:
                jsr nextColumnAndResetMask
                jsr shouldFillByte
                bcs LDCE9
LDCF1:
                jsr LDD85
                bcs LDCE5
                sec
                lda vduv.hlfw.pixelsLimitX+0
                sbc zhlfw.pixelsX+0
                sta vduv.hlfw.pixelsRightEndX+0
                lda vduv.hlfw.pixelsLimitX+1
                sbc zhlfw.pixelsX+1
                sta vduv.hlfw.pixelsRightEndX+1
LDD07:
                lda #$00
                sec
rtsDD0A:
                rts

LDD0B:
                ldx #VDUVariables.graphicsWindowPixelsLeft
                jsr shouldFillPixel
                bne rtsDD0A                    ;taken if pixel not to be filled, so done
LDD12:
                asl ZMASK                      ;next pixel
                bcc LDD1E                    ;taken if still in same byte
LDD16:
                jsr previousColumnAndResetMask
                jsr shouldFillByte
                bcs LDD16
LDD1E:
                jsr LDD85
                bcs LDD12
                lda vduv.graphicsWindowPixelsLeft+0
                adc zhlfw.pixelsX+0
                sta vduv.hlfw.pixelsX+0
                lda vduv.graphicsWindowPixelsLeft+1
                adc zhlfw.pixelsX+1
                sta vduv.hlfw.pixelsX+1
                bra LDD07

;-------------------------------------------------------------------------
;
; Check whether line fill should fill a pixel.
;
; entry:
;
; X = VDU variable offset of edge of window
;
; vduv.workspace._2E - pixel X, Y coordinates
;
; exit:
;
; Z=1 if pixel should be filled
;
; ZTEMPC = ???
;
shouldFillPixel:
                sec
                lda vduv.workspace._2E+0
                sbc vduv+0,x
                tay
                lda vduv.workspace._2E+1
                sbc vduv+1,x
                bpl +
                jsr negateAY
+
                sty zhlfw.pixelsX+0
                sta zhlfw.pixelsX+1
                ldx #VDUVariables.workspace._2E
                jsr windGADDR
                clc
                bne rtsDD64                    ;taken if point outside window
                lda (ZMEMG),y                  ;get screen byte
                eor andy.hlfw.ecfPattern,x     ;EOR with appropriate pattern
                sta zhlfw.notByteMatch ;0 if whole byte matches
                and ZMASK                      ;0 if masked byte matches
                beq +              ;taken if masked byte matches - A=0
                lda #$08              ;masked byte doesn't match - A=8
+
                eor zhlfw.resultEOR ;maybe invert result
                sec
rtsDD64:
                rts

;-------------------------------------------------------------------------

shouldFillByte:
                lda (ZMEMG),y
                eor andy.hlfw.ecfPattern,x
                sta zhlfw.notByteMatch
                ora zhlfw.resultEOR
                clc
                bne rtsDD84
                lda zhlfw.pixelsX+0
                sbc vduv.pixelsPerByteMinusOne
                pha
                lda zhlfw.pixelsX+1
                sbc #$00
                bcc pla_rts_DD83             ;taken if past X=0
                sta zhlfw.pixelsX+1
                pla
                sta zhlfw.pixelsX+0
                rts

pla_rts_DD83:
                pla
rtsDD84:
                rts

;-------------------------------------------------------------------------

LDD85:
                lda zhlfw.notByteMatch
                and ZMASK
                beq +
                lda #$08
+
                eor zhlfw.resultEOR
                bne rtsDD9E

                ; pixelsX -= 1
                lda zhlfw.pixelsX+0
                bne +
                lda zhlfw.pixelsX+1
                beq rtsDD9E
                dec zhlfw.pixelsX+1
+
                dec zhlfw.pixelsX+0
                sec
rtsDD9E:
                rts

;-------------------------------------------------------------------------
;
; Copy appropriate ECF pattern for line fill.
;
; entry:
;
; A = horizontal line fill PLOT code
;
; exit:
;
; andy.hlfw.ecfPattern = holds bg/fg ECF pattern as required
;
; ZTEMPD?1 = 0 for fill to matching, 8 to fill to non-matching
;
copyECFPatternForLineFill:
                lsr a                        ;36-39; 44-47; 52-55; 60-63
                lsr a                        ;18-19; 42-43; 26-27; 30-31
LDDA1:
                and #$08                     ;8 if PLOT >= 104
                sta zhlfw.resultEOR
                eor #$0F                     ;
                tax
                ldy #$07
-
                lda andy.currentECFPatterns,x
                sta andy.hlfw.ecfPattern,y
                dex
                dey
                bpl -
                ldx #VDUVariables.queueEnd-4
                rts

;-------------------------------------------------------------------------
;
;
; entry:
;
; A = offset into VDU variables of coordinates
;
; exit:
;
; A = colour, or $ff if off screen/teletext (as per OSWORD $09)
;
readPixelColour: .proc
                jsr stopCursorEditing
                ldx vduv.pixelsPerByteMinusOne
                beq invalid             ;taken if teletext
                pha
                tax
                jsr eigabsEntryPoint
                plx
                jsr windGADDR
                bne invalid             ;taken if off screen
                lda (ZMEMG),y
                stz ZTEMP+0
                bra shiftMask

                ; Keep shifting the byte and the mask. When a 1 bit is
                ; shifted out of the mask, shift the corresponding
                ; byte bit bit into ZTEMP+0, building up the pixel
                ; colour a bit at a time.
                ;
                ; When the mask becomes 0, done.
shiftByteAndMask:
                asl a
shiftMask:
                asl ZMASK
                bcc shiftByteAndMask
                asl a
                rol ZTEMP+0
                ldx ZMASK
                bne shiftMask
                lda ZTEMP+0
                bra done

invalid:
                lda #$FF
done:
                jmp reinstateCursorEditing
                .endproc

;-------------------------------------------------------------------------
;
; Translate ASCII char to the SAA5050 character set.
;
; # ($23) becomes $5f
; _ ($5f) becomes $60
; GBP ($60) becomes $23
;
; Because the mapping is a kind of cycle, you can call this routine
; twice to translate from SAA5050 to ASCII.
;
; entry:
;
; A = ASCII char
;
; exit:
;
; A = SAA550 char
;
getSAA5050FromASCII: .block
                cmp #$23
                beq translateHash
                cmp #$5F
                beq translateUnderscore
                cmp #$60
                bne rtsDDF7
translateGBP:
                eor #$3F                     ;0x60->0x5f
translateHash:
                eor #$43                     ;0x23->0x5f or 0x5f->0x1c
translateUnderscore:
                eor #$3F                     ;0x5f->0x60 or 0x1c->0x23
rtsDDF7:
                rts
                .endblock

;-------------------------------------------------------------------------

readCharacterAtTextCursor: .proc
                cli
                bit STATE
                bvc +                      ;taken if not cursor editing
                jsr stopCursorEditing
                jsr exchangeCursors
+
                ldy vduv.numberOfLogicalColoursMinusOne
                bne bitmapMode
readTeletextChar:
                lda (ZMEMT)                  ;read character from screen
                jsr getSAA5050FromASCII      ;call 2x to convert to ASCII
                jsr getSAA5050FromASCII      ;call 2x to convert to ASCII
done:
                bit STATE
                bvc +                     ;taken if not cursor editing
                jsr exchangeCursors
                jsr reinstateCursorEditing
+
                ldy vduv.currentScreenMODE
                tax
                rts

bitmapMode:
                jsr LDE56
                lda $F4
                pha
                jsr selectTerminalROMAndANDY
                lda #$20
                tax                          ;X = ASCII code for char
                jsr getSoftCharacterDefinitionAddress
compare:
                ldy #$07
-
                lda vduv.workspace._28,y
                eor (ZTEMPC),y
                bne nextFontChar ;taken if no match - can't be this char
                dey
                bpl -

                txa                          ;A = char found
                .if version==350
                bpl bitmapModeDone
                eor #$7f
                .endif
bitmapModeDone:
                plx
                jsr selectROMX
                bra done

nextFontChar:
                inx                          ;next ASCII code
                .if version==350
                txa
                bpl LDE4A
                eor #$7f
LDE4A:
                jsr getSoftCharacterDefinitionAddress
                .else
                clc
                lda ZTEMPC+0
                adc #$08                     ;8 bytes/font char
                sta ZTEMPC+0
                bcc gotCharAddress
                inc ZTEMPC+1
                .endif
gotCharAddress:
                cpx #$7F
                beq nextFontChar                 ;skip CHR$127
                txa
                bne compare           ;taken if more chars to consider
                bra bitmapModeDone ;finish with A=0 - i.e., no match found
                .endproc

;-------------------------------------------------------------------------
;
; Copy character out of screen memory, and store as a 1 bpp bitmap in
; VDU variables workspace.
;
LDE56: .proc
                ldx ZMEMT+0
                lda ZMEMT+1
                jsr getNext3ColumnAddresses
                ldy #$07
loop:
                ldx vduv.numberOfLogicalColoursMinusOne
                cpx #$03
                beq read2bppChar
                bcs read4bppChar
read1bppChar:
                lda (ZMEMT),y
                eor vduv.backgroundTextColour
                bra next

read2bppChar:
                lda (ZMEMT),y                ;get pixels 0-3
                jsr get4Pixels
                lda (ZTEMP),y                  ;get pixels 4-7
                jsr get4Pixels
                bra LDE8F

read4bppChar:
                lda (ZMEMT),y                ;get pixels 0/1
                jsr get2Pixels
                lda (ZTEMP),y                ;get pixels 2/3
                jsr get2Pixels
                lda (ZTEMPB),y               ;get pixels 4/5
                jsr get2Pixels
                lda (ZTEMPD),y               ;get pixels 6/7
                jsr get2Pixels
LDE8F:
                lda ZTEMPC+1
next:
                sta vduv.workspace._28,y
                dey
                bpl loop
                rts

get2Pixels:
                eor vduv.backgroundTextColour ;reset background pixel bits
                jsr or2Pixels
                and #%00000011               ;2 pixels/byte
                bra shiftIn2

get4Pixels:
                eor vduv.backgroundTextColour ;
                jsr or4Pixels
                and #%00001111               ;4 pixels/byte

                ; Build up the 1bpp char row in ZTEMPC?1, 2 or 4 bits
                ; at a time.
                asl ZTEMPC+1
                asl ZTEMPC+1
shiftIn2:
                asl ZTEMPC+1
                asl ZTEMPC+1
                tsb ZTEMPC+1
                rts

                ; OR together all the N bits for each pixel, making a
                ; byte in which the bottom N bits have a bit set for
                ; each non-0 pixel in the byte.
or2Pixels:
                sta ZTEMPC+0
                jsr shiftOut2
or4Pixels:
                sta ZTEMPC+0                 ;%abcdABCD
                lsr a                        ;%0abcdABC
                lsr a                        ;%00abcdAB
shiftOut2:
                lsr a                        ;%000abcdA
                lsr a                        ;%0000abcd
                ora ZTEMPC+0                 ;%0000abcd|%abcdABCD
                .endproc
rtsDEC2:
                rts

;-------------------------------------------------------------------------
;
; Do WIND. If point not in window, return with Z=0. Otherwise, call
; GADDR and return with Z=1.
;
windGADDR:
                jsr windEntryPoint
                bne rtsDEC2                  ;taken if point outside window
gaddrEntryPoint:
                lda vduv+2,x                 ;get Y coordinate
LDECB:
                eor #$FF                     ;invert Y coordinate
                tay                          ;Y=Y coordinate
                and #$07                ;get scanline in character row
                sta ZTEMP+0             ;save scanline
                tya                          ;A=Y coordinate
                and #$F8                     ;row*8
                lsr a                        ;row*4
                sta ZMEMG+1                  ;>(row*1024)
                lsr a                        ;>(row*512)
                lsr a                        ;>(row*256)
                adc ZMEMG+1                  ;>(row*1280)
                lsr a                        ;>(row*640)
                sta ZMEMG+1                  ;
                lda #$00                     ;
                ror a                        ;<(row*640) - $00/$80
                ldy vduv.currentScreenMODEGroup
                beq +                      ;taken if 640 bytes per row
                lsr ZMEMG+1                ;>(row*320)
                ror a                    ;<(row*320) - $00/$40/$80/$c0
+
                ora ZTEMP+0               ;include the scanline offset
                adc vduv.screenTopLeftAddress+0 ;include LSB of screen base
                sta vduv.graphicsAddressOffset

                ; add MSB of screen base to ZMEMG+1
                lda ZMEMG+1
                adc vduv.screenTopLeftAddress+1
                sta ZMEMG+1

                lda vduv+1,x                 ;get >X
                sta ZMEMG+0                  ;save >X
                lda vduv+0,x                 ;get <X
                and vduv.pixelsPerByteMinusOne ;index for pixel
                adc vduv.pixelsPerByteMinusOne ;offset into pixel mask table
                tay
                lda pixelMasks-1,y
                sta ZMASK

                ; Form 16-bit column address offset (LSB in A, MSB in
                ; ZMEMG+0), assuming 8 bits/pixel. No adjustment
                ; needed if MODE 0/4, but scale up by 2 if MODE 1/5 or
                ; 4 if MODE 2.

                lda vduv+0,x                 ;A = <X
                ldy vduv.pixelsPerByteMinusOne
                cpy #$03
                beq LDF1C         ;taken if 4 px/byte - i.e., MODE 1/5
                bcs LDF1F        ;taken if >4 px/byte - i.e., MODE 0/4
                asl a
                rol ZMEMG+0
LDF1C:
                asl a
                rol ZMEMG+0
LDF1F:
                and #$F8                     ;<column offset
                clc
                adc vduv.graphicsAddressOffset
                sta vduv.graphicsAddressOffset
                lda ZMEMG+0                  ;>column offset
                adc ZMEMG+1                  ;add to address MSB
                bpl +                        ;taken if no wrap
                sec
                sbc vduv.screenSizeHighByte ;handle wrap at end of screen
+
                sta ZMEMG+1                  ;got MSB
                stz ZMEMG+0 ;LSB always 0 - the offset takes care of this
                ldx ZTEMP+0 ;get scanline in row
                jsr setupColourMasks
                ldy vduv.graphicsAddressOffset
ldaim00_rts_DF3E:
                lda #$00                     ;return with Z=1, as per WIND
                rts

;-------------------------------------------------------------------------

LDF41:
                jsr gaddrEntryPoint
                phx
                ldx #$00
                lda $035A
                cmp #$04
                bcs LDF59
                ldx $036A
                lda $0359
                beq LDF59
                ldx $036B
LDF59:
                stx $0369
                plx
                rts

;-------------------------------------------------------------------------

handleCopyKey:
                lda #STATE.isVDU5
                bit STATE
                bvc ldaim00_rts_DF3E      ;taken if not cursor editing
                bne ldaim00_rts_DF3E      ;taken if VDU5
                .if version==350&&!finmos329
                jsr LFB0A
                .elsif (version<511||autocue)&&!finmos329
                jsr readCharacterAtTextCursor
                .else
                lda #$87
                jsr OSBYTE
                txa
                .endif
                beq rtsDF77              ;taken if char not recognised
                pha                      ;save char recognised
                jsr isCursorEditingPossible
                bne pla_rts_DF76
                lda #$09
                jsr moveEditCursor
pla_rts_DF76:
                pla
rtsDF77:
                rts

;-------------------------------------------------------------------------
;
; Handle cursor key press.
;
; Entry: A = one of the cursor key codes:
;            $88 = left
;            $89 = right
;            $8a = down
;            $8b = up

handleCursorKey:
                pha                          ;save cursor key code
                jsr isCursorEditingPossible
                bne pla_rts_DF76             ;bail if editing not possible
                bvs editing                  ;taken if already editing
beginEditing:
                lda vduv.lastCursorStartRegisterValue
                and #%11011111
                jsr setCRTCRegister10        ;hide cursor
                ldx #VDUVariables.textCursorXPosition
                ldy #VDUVariables.editCursorXPosition
                jsr copyTwoBytesWithinVDUVariables ;edit cursor pos =
                                                   ;text cursor pos
                jsr activateEditCursor
                lda #STATE.isScrollingDisabled
                tsb STATE
editing:
                pla                          ;restore cursor key code

                ; Form appropriate VDU command (8/9/10/11) for the
                ; key, assuming no VDU axis rearrangement.
                and #$7F
                sta ZTEMP                    ;save VDU command

                ; Adjust VDU command based on axis swap/inversion.
                cmp #$0A
                bcs handleCursorUpOrDown     ;taken if up/down
handleCursorLeftOrRightOrCopy:
                lda vduv.cursorFlags
                lsr a
                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertHorizontal)>>1
                bit #vduv.cursorFlags.swapAxes>>1
                beq gotActualMoveCommand

                eor #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical|vduv.cursorFlags.invertHorizontal)>>1
                bra gotActualMoveCommand

handleCursorUpOrDown:
                lda vduv.cursorFlags
                lsr a
                lsr a
                and #(vduv.cursorFlags.swapAxes|vduv.cursorFlags.invertVertical)>>2 ;000000SV
                bit #vduv.cursorFlags.swapAxes>>2
                beq gotActualMoveCommand

                eor #vduv.cursorFlags.invertVertical>>2
gotActualMoveCommand:
                eor ZTEMP
moveEditCursor:
                tay                          ;save command
                lda #STATE.isCursorEditing
                trb STATE            ;temporarily disable edit mode
                tya                  ;restore command
                ldx vduv.column81
                phx                  ;save old column 81 flag
                lsr vduv.column81    ;temporarily reset column 81 flag
                jsr outputToVDU      ;print the cursor movement command
                pla
                sta vduv.column81            ;restore column 81 flag
                lda #STATE.isCursorEditing
                tsb STATE                    ;reinstate edit mode
                rts

; Check if cursor editing is possible.
;
; Exit: Z=1 - editing is possible
;             V reflects current STATE.isCursorEditing bit
;       Z=0 - editing not possible
isCursorEditingPossible:
                ldx vduQueueNegativeLength
                bne +                        ;return with Z=0 if VDU
                                             ;queue not empty
                lda #STATE.isVDU21|STATE.isVDU5
                bit STATE   ;return with Z=0 if neither VDU21 nor VDU5
+
                rts

;-------------------------------------------------------------------------
;
; 184-191 = Move/copy rectangle [MasRef E.3-31]
;
                .if version!=400
selectExtROMAndPlotMoveOrCopyRectangle:
                ldx #$80|extROM   ; select VIEW+ANDY
                jsr selectROMX
                jsr plotMoveOrCopyRectangle
                bra LDFF1
                .endif

;-------------------------------------------------------------------------
;
; 192-199 = Plot ellipse outline [MasRef E.3-32]
;
                .if version!=400
selectExtROMAndPlotEllipseOutline:
                ldx #$80|extROM
                jsr selectROMX
                jsr plotEllipseOutline
LDFF1:
                jmp selectTerminalROMAndANDY
                .endif

;-------------------------------------------------------------------------
;
; 200-207 = Plot solid ellipse [MasRef E.3-32]
;
                .if version!=400
selectExtROMAndPlotEllipseFilled:
                ldx #$80|extROM
                jsr selectROMX
                jsr plotEllipseFilled
                bra LDFF1
                .endif

                .if version==400
                .align 256
                .endif

;-------------------------------------------------------------------------

; Pretty sure I have the logic for this all wrong...

                .if !finmos329
                .align 16
                .endif
startupMessages: .block
                .if version==500||version==510||autocue
                .fill 16,0
                .endif

                .if version>=511&&!autocue
                .byte 0
                .endif
acornMOS:
                .text 13

                .if refreshVersion
                .text versionString
                .elsif olivetti
                .text "Olivetti MOS"
                .elsif version==350
                .if CFA3000
                .text "ACORN MOS (Tinsley 64K)"
                .elsif finmos329
                .text "Acorn FinMOS"
                .else
                .text "ACORN MOS"
                .endif
                .else
                .text "Acorn MOS"
                .endif
                .if version==400||version==350
                .text " "
                .endif
                .byte 0
beep:
                .byte 7
                .byte 0
                .if version!=400&&version!=350
                .byte 0,0,0   ;space for "xxK"
                .endif

twoNewlines:
                .byte 8
                .byte $0D
                .byte $0D
                ; terminating 0 comes from following table!
                .cerror *!=LE013,"startupMessages needs a terminating 0"
                .endblock
LE013:
                .byte %00000000;$00
                .byte %00010001;$11
                .byte %00100010;$22
                .byte %00110011;$33
                .byte %01000100;$44
                .byte %01010101;$55
                .byte %01100110;$66
                .byte %01110111;$77
                .byte %10001000;$88
                .byte %10011001;$99
                .byte %10101010;$AA
                .byte %10111011;$BB
                .byte %11001100;$CC
                .byte %11011101;$DD
                .byte %11101110;$EE
                .byte %11111111;$FF
LE023:
                .byte %00000000;$00
                .byte %01010101;$55
                .byte %10101010;$AA
                .byte %11111111;$FF

; VDU control code dispatch tables
; ================================
;
; entry:
;
;

; each routine is (address, number of additional VDU bytes)
_:=[(vdu0EntryPoint,0)] ; VDU0
_..=[(vdu1EntryPoint,1)] ; VDU1
_..=[(vdu2EntryPoint,0)] ; VDU2
_..=[(vdu3EntryPoint,0)] ; VDU3
_..=[(vdu4EntryPoint,0)] ; VDU4
_..=[(vdu5EntryPoint,0)] ; VDU5
_..=[(vdu6EntryPoint,0)] ; VDU6
_..=[(vdu7EntryPoint,0)] ; VDU7
_..=[(vdu8EntryPoint,0)] ; VDU8
_..=[(vdu9EntryPoint,0)] ; VDU9
_..=[(vdu10EntryPoint,0)] ; VDU10
_..=[(vdu11EntryPoint,0)] ; VDU11
_..=[(vdu12EntryPoint,0)] ; VDU12
_..=[(vdu13EntryPoint,0)] ; VDU13
_..=[(vdu14EntryPoint,0)] ; VDU14
_..=[(vdu15EntryPoint,0)] ; VDU15
_..=[(vdu16EntryPoint,0)] ; VDU16
_..=[(vdu17EntryPoint,1)] ; VDU17
_..=[(vdu18EntryPoint,2)] ; VDU18
_..=[(vdu19EntryPoint,5)] ; VDU19
_..=[(vdu20EntryPoint,0)] ; VDU20
_..=[(vdu21EntryPoint,0)] ; VDU21
_..=[(vdu22EntryPoint,1)] ; VDU22
_..=[(vdu23EntryPoint,9)] ; VDU23
_..=[(vdu24EntryPoint,8)] ; VDU24
_..=[(vdu25EntryPoint,5)] ; VDU25
_..=[(vdu26EntryPoint,0)] ; VDU26
_..=[(vdu27EntryPoint,0)] ; VDU27
_..=[(vdu28EntryPoint,4)] ; VDU28
_..=[(vdu29EntryPoint,4)] ; VDU29
_..=[(vdu30EntryPoint,0)] ; VDU30
_..=[(vdu31EntryPoint,2)] ; VDU31
_..=[(vdu127EntryPoint,0)] ; VDU127
vdu_routines=_

; LSB of routine address
vduRoutinesLSBTable:
                .for _i=0,_i<len(vdu_routines),_i+=1
                .byte <vdu_routines[_i][0]
                .next

; If bit 7 set: MSB of routine address
;
; If bit 7 clear:
;
; Top 4 bits are bits 8-11 of routine address (bits 12-15 are %1010,
; so address is $C0xx to $C7xx)
;
; Bottom 4 bits are ORed with $f0 and stored in $26a - -ve bytes left
; in VDU queue.
vduRoutinesMSBTable:
                .for _i=0,_i<len(vdu_routines),_i+=1
                .if vdu_routines[_i][1]==0
                .byte >vdu_routines[_i][0]
                .else
                .cerror vdu_routines[_i][0]<(vduRoutinesPage<<8) || vdu_routines[_i][0]>(vduRoutinesPage<<8)+$7ff,format("illegal VDU routine address for VDU %d: $%04x",_i,vdu_routines[_i][0])
                .cerror vdu_routines[_i][1]<0 || vdu_routines[_i][1]>15,format("illegal VDU parameter count for VDU %d: %d",_i,vdu_routines[_i][1])
                .byte (16-vdu_routines[_i][1])|(((>vdu_routines[_i][0])&$0f)<<4)
                .endif
                .next

;-------------------------------------------------------------------------
;
; entry:
;
; C=0
;
; A = vdu 23 code
;
; VDU queue = the full 9 bytes of the VDU 23
;
vdu23EntryPointTable:
                .word vdu23_0_EntryPoint
                .word vdu23_1_EntryPoint
                .word vdu23_2_EntryPoint
                .word vdu23_3_EntryPoint
                .word vdu23_4_EntryPoint
                .word vdu23_5_EntryPoint
                .word vdu23_6_EntryPoint
                .word vdu23_7_EntryPoint
                .word vdu23_8_EntryPoint
                .word vdu23_9_EntryPoint
                .word vdu23_10_EntryPoint
                .word vdu23_11_EntryPoint
                .word vdu23_12_EntryPoint
                .word vdu23_13_EntryPoint
                .word vdu23_14_EntryPoint
                .word vdu23_15_EntryPoint
                .word vdu23_16_EntryPoint

;-------------------------------------------------------------------------
;
; entry:
;
; A = plot number
;
plotEntryPointTable:
                .word plotPoint    ;64-71 = Plot point [MasRef E.3-24]
                .word plotHorizontalLineFill ;72-79 = Horizontal line fill (left and right to non-background) [MasRef E.3-24]
                .word L9BF7 ;80-87 = Plot triangle [MasRef E.3-25]
                .word plotHorizontalLineFillRight ;88-95 = Horizontal line fill (right to background) [MasRef E.3-25]
                .word LC448 ;96-103 = Plot rectangle [MasRef E.3-26]
                .word plotHorizontalLineFill ;104-111 = Horizontal line fill (left and right to foreground) [MasRef E.3-26]
                .word plotParallelogram ;112-119 = Plot parallelogram [MasRef E.3-27]
                .word plotHorizontalLineFillRight ;120-127 = Horizontal line fill (right to non-foreground) [MasRef E.3-27]
                .word L9CF9 ;128-135 = Flood fill to non-background [MasRef E.3-28]
                .word L9CF9 ;136-143 = Flood fill to foreground [MasRef E.3-28]
                .word L99A4 ;144-151 = Plot circle outline [MasRef E.3-28]
                .word L9944 ;152-159 = Plot filled circle [MasRef E.3-29]
                .word L9999 ;160-167 = Plot circular arc [MasRef E.3-29]
                .word L9935 ;168-175 = Plot filled chord segment [MasRef E.3-30]
                .word L9923 ;176-183 = Plot filled sector [MasRef E.3-30]
                .word selectExtROMAndPlotMoveOrCopyRectangle ;184-191 = Move/copy rectangle [MasRef E.3-31]
                .word selectExtROMAndPlotEllipseOutline ;192-199 = Plot ellipse outline [MasRef E.3-32]
                .word selectExtROMAndPlotEllipseFilled ;200-207 = Plot solid ellipse [MasRef E.3-32]

; Times 40 lookup table, high bytes
multiplyBy40TableHigh:
                .for _i=0,_i<25,_i+=1
                .byte >_i*40
                .next

; Times 40 lookup table, low bytes
multiplyBy40TableLow:
                .for _i=0,_i<25,_i+=1
                .byte <_i*40
                .next

; Times 640 lookup table, high bytes
multiplyBy640TableHigh:
                .for _i=0,_i<32,_i+=1
                .byte >_i*640
                .next

;-------------------------------------------------------------------------

modeMaxRow:
                .byte 31                     ;MODE 0 = 32 rows
                .byte 31                     ;MODE 1 = 32 rows
                .byte 31                     ;MODE 2 = 32 rows
                .byte 24                     ;MODE 3 = 25 rows
                .byte 31                     ;MODE 4 = 32 rows
                .byte 31                     ;MODE 5 = 32 rows
                .byte 24                     ;MODE 6 = 25 rows
                .byte 24                     ;MODE 7 = 25 rows

;-------------------------------------------------------------------------

modeMaxColumn:
                .byte 79                     ;MODE 0 = 80 columns
                .byte 39                     ;MODE 1 = 40 columns
                .byte 19                     ;MODE 2 = 20 columns
                .byte 79                     ;MODE 3 = 80 columns
                .byte 39                     ;MODE 4 = 40 columns
                .byte 19                     ;MODE 5 = 20 columns
                .byte 39                     ;MODE 6 = 40 columns
                .byte 39                     ;MODE 7 = 40 columns

;-------------------------------------------------------------------------

vcontrolForScreenMODE:
                .byte VCONTROL.cursorX___|VCONTROL.crtc2MHz|VCONTROL.shift16MHz ; $9C - MODE 0
                .byte VCONTROL.cursorXX__|VCONTROL.crtc2MHz|VCONTROL.shift8MHz ; $d8 - MODE 1
                .byte VCONTROL.cursorXXXX|VCONTROL.crtc2MHz|VCONTROL.shift4MHz ; $F4 - MODE 2
                .byte VCONTROL.cursorX___|VCONTROL.crtc2MHz|VCONTROL.shift16MHz ; $9C - MODE 3
                .byte VCONTROL.cursorX___|VCONTROL.crtc1MHz|VCONTROL.shift8MHz ; $88 - MODE 4
                .byte VCONTROL.cursorXX__|VCONTROL.crtc1MHz|VCONTROL.shift4MHz ; $C4 - MODE 5
                .byte VCONTROL.cursorX___|VCONTROL.crtc1MHz|VCONTROL.shift8MHz ; $88 - MODE 6
                .byte VCONTROL.cursor_X__|VCONTROL.crtc1MHz|VCONTROL.shift8MHz|VCONTROL.isTeletext|VCONTROL.flash ; $4B - MODE 7

;-------------------------------------------------------------------------

bytesPerCharacterForMODE:
                .byte 8                      ;MODE 0
                .byte 16                     ;MODE 1
                .byte 32                     ;MODE 2
                .byte 8                      ;MODE 3
                .byte 8                      ;MODE 4
                .byte 16                     ;MODE 5
                .byte 8                      ;MODE 6
LE120:
                .byte %00000001              ;MODE 7
                .byte %11111111
                .byte %01010101
                .byte %11111111
                .byte %01110111
                .byte %00110011
                .byte %00010001

;-------------------------------------------------------------------------

distanceMasksTable:
                .byte %11111111
                .byte %01111111
                .byte %00111111
                .byte %00011111
                .byte %00001111
                .byte %00000111
                .byte %00000011
                .byte %00000001

;-------------------------------------------------------------------------
;
; These graphics tables often overlap. I haven't always bothered
; commenting the MODEs for the MODE-indexed tables, as even those
; sometimes overlap.
;
;------------------------------------------------------------------------

;-------------------------------------------------------------------------
;
; This is 3 tables in one. Use the numberOfLogicalColoursMinusOne VDU
; variable to access it:
; pixelMasks[(numberOfLogicalColoursMinusOne&7)-1+colour&numberOfLogicalColoursMinusOne=
;
pixelMasks:
                .byte %10101010
                .byte %01010101

                .byte %10001000
                .byte %01000100
                .byte %00100010
                .byte %00010001

                .byte %10000000
                .byte %01000000
                .byte %00100000
                .byte %00010000
                .byte %00001000
                .byte %00000100
                .byte %00000010
numberOfLogicalColoursMinusOneForMODE:
                .byte %00000001              ;MODE 0 (also part of pixelMasks)
                .byte 3                      ;MODE 1
                .byte 15                     ;MODE 2
                .byte 1                      ;MODE 3
                .byte 1                      ;MODE 4
                .byte 3                      ;MODE 5
                .byte 1                      ;MODE 6
                ; MODE 7 value (0) is in next table

;-------------------------------------------------------------------------
;
; Overwrite: ZGORA=$ff, ZGEOR=$ff
; OR: ZGORA=value, ZGEOR=$00
; AND: ZGORA=~value, ZGEOR=$00
; EOR: ZGORA=$00, ZGEOR=value
; Invert: ZGORA=$00, ZGEOR=$ff
; Leave: ZGORA=$00, ZGEOR=$ff
;
zgeorORTable:
                .byte $00
zgoraORTable:
                .byte $FF
zgoraEORTable:
                .byte $00
                .byte $00
                .byte $FF
zgeorEORTable:
                .byte $FF
                .byte $FF
                .byte $FF
                .byte $00

;-------------------------------------------------------------------------
;
; Index using logical colour value to get a byte with that colour
; value in every pixel.
;
; This is 3 tables in one. Use the numberOfLogicalColoursMinusOne VDU
; variable to access it:
; solidColoursTable[(numberOfLogicalColoursMinusOne&7)-1+colour&numberOfLogicalColoursMinusOne=
;
solidColoursTable:

                ; 1 bpp
                .byte %00000000
                .byte %11111111

                ; 2 bpp
                .byte %00000000
                .byte %00001111
                .byte %11110000
                .byte %11111111

                ; 4 bpp
                .byte %00000000
                .byte %00000011
                .byte %00001100
                .byte %00001111
                .byte %00110000
                .byte %00110011
                .byte %00111100
                .byte %00111111
                .byte %11000000
                .byte %11000011
                .byte %11001100
                .byte %11001111
                .byte %11110000
                .byte %11110011
                .byte %11111100
                .byte %11111111

pixelsPerByteMinusOneForMODE:
                .byte 7
                .byte 3
                .byte 1
LE165:
                .byte 0
                .byte 7
                .byte 3
screenMODEGroupForMODE:
                .byte 0
                .byte 0
                brk
                ora ($02,x)
                .byte $02
                .byte $03
;TSB &0D          :\ E16F= 04 0D       ..
                .byte $04

;-------------------------------------------------------------------------
;
; Hardware scrolling wraparound size settings for screen mode group.
;
; The values for group 4 (1 KB) are bogus - the Mode 7 addressing
; wraparound is handled differently.
;
latchBit5ForScreenMODEGroup:
                .byte 5|8                    ;20 KB
                .byte 5|0                    ;16 KB
                .byte 5|8                    ;10 KB
                .byte 5|0                    ; 8 KB
latchBit4ForScreenMODEGroup:
                .byte 4|0                    ;20 KB (also benign value for 1 KB)
                .byte 4|0                    ;16 KB
                .byte 4|8                    ;10 KB
                .byte 4|8                    ; 8 KB
                .byte 4|0                    ;(benign value for 1 KB)

;-------------------------------------------------------------------------

screenSizeHighByteForScreenMODEGroup:
                .byte $50
                .byte $40
                .byte $28
                .byte $20
                .byte $04
startScreenAddressHighByteForScreenMODEGroup:
                .byte $30
                .byte $40
                .byte $58
                .byte $60
                .byte $7c
crtcRegisterLastIndexForScreenMODEGroup:
                .byte (crtcRegisterValues20KB-crtcRegisterValues)+$0B
                .byte (crtcRegisterValues16KB-crtcRegisterValues)+$0B
                .byte (crtcRegisterValues10KB-crtcRegisterValues)+$0B
                .byte (crtcRegisterValues8KB-crtcRegisterValues)+$0B
                .byte (crtcRegisterValues1KB-crtcRegisterValues)+$0B
crtcRegisterValues:
crtcRegisterValues20KB:                   ;MODEs 0/1/2
                .byte $7F            ;R0 - Horizontal Total
                .byte $50            ;R1 - Horizontal Displayed
                .byte $62            ;R2 - Horizontal Sync
                .byte $28            ;R3 - Sync Width (%vvvvhhhh)
                .byte $26            ;R4 - Vertical Total
                .byte $00            ;R5 - Vertical Total Adjust
                .byte $20            ;R6 - Vertical Displayed
                .byte $22            ;R7 - Vertical Sync Position
                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                    ;R11 - Cursor End
crtcRegisterValues16KB:                    ;MODE 3
                .byte $7F                 ;R0 - Horizontal Total
                .byte $50                 ;R1 - Horizontal Displayed
                .byte $62                 ;R2 - Horizontal Sync
                .byte $28                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $1e                 ;R4 - Vertical Total
                .byte $02                 ;R5 - Vertical Total Adjust
                .byte $19                 ;R6 - Vertical Displayed
                .byte $1B                 ;R7 - Vertical Sync Position
                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $09               ;R9 - Scan lines per character
                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 9                      ;R11 - Cursor End
crtcRegisterValues10KB:                      ;MODEs 4/5
                .byte $3f                 ;R0 - Horizontal Total
                .byte $28                 ;R1 - Horizontal Displayed
                .byte $31                 ;R2 - Horizontal Sync
                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $26                 ;R4 - Vertical Total
                .byte $00                 ;R5 - Vertical Total Adjust
                .byte $20                 ;R6 - Vertical Displayed
                .byte $22                 ;R7 - Vertical Sync Position
                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                      ;R11 - Cursor End
crtcRegisterValues8KB:                       ;MODE 6
                .byte $3F                 ;R0 - Horizontal Total
                .byte $28                 ;R1 - Horizontal Displayed
                .byte $31                 ;R2 - Horizontal Sync
                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $1e                 ;R4 - Vertical Total
                .byte $02                 ;R5 - Vertical Total Adjust
                .byte $19                 ;R6 - Vertical Displayed
                .byte $1B                 ;R7 - Vertical Sync Position
                .byte CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $09               ;R9 - Scan lines per character
                .byte CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 9                      ;R11 - Cursor End
crtcRegisterValues1KB:                       ;MODE 7
                .byte $3f                 ;R0 - Horizontal Total
                .byte $28                 ;R1 - Horizontal Displayed
                .byte $33                 ;R2 - Horizontal Sync
                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $1e                 ;R4 - Vertical Total
                .byte $02                 ;R5 - Vertical Total Adjust
                .byte $19                 ;R6 - Vertical Displayed
                .byte $1b                 ;R7 - Vertical Sync Position
                .byte CRTC.R8.cursorDelay2|CRTC.R8.displayDelay1|CRTC.R8.interlaceSyncAndVideo ;R8 - Interlace/Delay
                .byte $12               ;R9 - Scan lines per character
                .byte CRTC.R10.blink|CRTC.R10.slowBlink|18 ;R10 - Cursor blink/start
                .byte 19                     ;R11 - Cursor End

;-------------------------------------------------------------------------
;
; Default ECF patterns [MasRef E.3-16]
;
; Only half the pattern is stored. Each pattern repeats every 4
; scanlines.
;
defaultECFPatterns:
                ; MODE 4
                .byte $aa,$00,$aa,$00        ;1 - Dark grey
                .byte $aa,$55,$aa,$55        ;2 - Grey
                .byte $ff,$55,$ff,$55        ;3 - Light grey
                .byte $11,$22,$44,$88        ;4 - Hatching

                ; MODE 1/5
                .byte $a5,$0f,$a5,$0f        ;1 - Red-orange
                .byte $a5,$5a,$a5,$5a        ;2 - Orange
                .byte $f0,$5a,$f0,$5a        ;3 - Yellow-orange
                .byte $f5,$fa,$f5,$fa        ;4 - Cream

                ; MODE 2
                .byte $0b,$07,$0b,$07        ;1 - Orange
                .byte $23,$13,$23,$13        ;2 - Pink
                .byte $0e,$0d,$0e,$0d        ;3 - Yellow-green
                .byte $1f,$2f,$1f,$2f        ;4 - Cream

                ; MODE 0
                .byte $cc,$00,$cc,$00        ;0 - Dark grey
                .byte $cc,$33,$cc,$33        ;1 - Grey
                .byte $ff,$33,$ff,$33        ;2 - Light grey
                .byte $03,$0c,$30,$c0        ;4 - Hatching

LE204:
                .byte $01                    ;---
                .byte $01                    ;--h
                .byte $03                    ;-v-
                .byte $03                    ;-vh
                .byte $02                    ;x--
                .byte $00                    ;x-h
                .byte $02                    ;xv-
                .byte $00                    ;xvh

scrollRoutinesTable:
                .word LC95F
                .word LC96B
                .word LC95F
                .word LC96B
                .word LC99D
                .word LC99D
                .word LC9A4
                .word LC9A4
                .word LC9C3
                .word LCA2D
                .word LC9C3
                .word LCA2D
                .word LCAF1
                .word LCAF1
                .word LCAFA
                .word LCAFA

;-------------------------------------------------------------------------
;
; Get address of soft character definition.
;
; entry:
;
; A = character (32-255)
;
; exit:
;
; (ZTEMPC) = address
;
getSoftCharacterDefinitionAddress:
                asl a                        ;a bcdefgh0
                rol a                        ;b cdefgh0a
                rol a                        ;c defgh0ab
                tay
                and #$03                     ;c 000000ab
                rol a                        ;0 00000abc
                adc #(>andy.softCharacterDefinitions)-1
                sta ZTEMPC+1
                tya                          ;0 defgh0ab
                and #$F8                     ;0 defgh000
                sta ZTEMPC+0
                rts                          ;

;-------------------------------------------------------------------------
;
; OSBYTE 165 (&A5) Read output cursor position [MasRef D.2-50]
;
osbyteA5:
                jsr withMOSROM
                bit STATE
                bvc getTextCursorPositionWithColumn81                    ;taken if cursor editing
                jsr exchangeEditCursorPositionAndTextCursorPosition
                jsr getTextCursorPositionWithColumn81
                phx
                phy
                jsr exchangeEditCursorPositionAndTextCursorPosition
                ply
                plx
                rts

;-------------------------------------------------------------------------
;
; Get text cursor position, taking the column 81 flag into account and
; reporting the X coordinate as N+1 in that case.
;
getTextCursorPositionWithColumn81:
                jsr getTextCursorPosition
                bit vduv.column81
                bpl +                       ;taken if not at column 81
                inx                         ;X=81
+
                rts

;-------------------------------------------------------------------------

LE25C:
                sec
                lda vduv.textWindowRight
                sbc vduv.textWindowLeft
                pha
                lda #$00
                tay
                bra LE279

;-------------------------------------------------------------------------
;
; OSBYTE 134 (&86) Read text cursor position [MasRef D.2-41]
;
osbyte86:
                bit STATE
                bvc osbyteA5       ;taken if not cursor editing
getTextCursorPosition:
                lda #VDUVariables.cursorFlags.invertHorizontal
                ldy #VDUVariables.textCursorXPosition-VDUVariables.textWindow
                ldx #VDUVariables.textWindowLeft-VDUVariables.textWindow
                jsr getTextWindowRelativePosition
                pha                          ;save X position
                lda #VDUVariables.cursorFlags.invertVertical
LE279:
                iny               ;i.e., offset of textCursorYPosition
                ldx #VDUVariables.textWindowTop-VDUVariables.textWindow
                jsr getTextWindowRelativePosition
                tax                          ;X = Y position
                tay                          ;Y = Y position
                lda #vduv.cursorFlags.swapAxes
                bit vduv.cursorFlags
                beq plx_rts ;taken if axes unswapped - so X = X position, Y = Y position
                ply                          ;Y = Y position, X = X position
                rts

;-------------------------------------------------------------------------
;
; Get text window-relative cursor position, taking into account cursor
; flags.
;
; entry:
;
; A = cursorFlags bit for axis of interest - invertHorizontal or invertVertical
;
; X = offset in VDU variables of text window minimum for axis of interest
;
; Y = offset in VDU variables of cursor position for axis of interest
;
; exit:
;
; A = text window-relative coordinate
;
getTextWindowRelativePosition:
                sec                     ;C=1 ready for the subtraction
                bit vduv.cursorFlags ;test cursor flags inversion bit of interest
                beq axisNotInverted
axisInverted:
                txa
                eor #$02                     ;swap min and max
                tax
                lda vduv.textWindow,x
                sbc vduv.textWindow,y
                rts

axisNotInverted:
                lda vduv.textWindow,y
                sbc vduv.textWindow,x
                rts

;-------------------------------------------------------------------------
;
; Get default bounds for current mode.
;
; exit:
;
; X = max column (19, 39 or 79)
;
; Y = max row (24 or 31)
;
; preserves: A, C
;
getDefaultBoundsForCurrentScreenMODE:
                ldx vduv.currentScreenMODE
                ldy modeMaxColumn,x          ;Y = max column
                phy                          ;save max column
                ldy modeMaxRow,x             ;Y = max row
plx_rts:
                plx                          ;X = max column
                rts

;-------------------------------------------------------------------------
;
; Swap edit cursor position and text cursor position.
;
exchangeEditCursorPositionAndTextCursorPosition:
                ldx #VDUVariables.textCursorXPosition
                ldy #VDUVariables.editCursorXPosition

;-------------------------------------------------------------------------
;
; Swap 2 bytes in the VDU variables.
;
; entry:
;
; X = offset of one set of 2 bytes
;
; Y = offset of the other set of 2 bytes
;
exchangeTwoVDUBytes:
                lda #$02
                bra exchangeVDUVariables

;-------------------------------------------------------------------------
;
; Swap graphics cursor and old graphics cursor.
;
LE2B6:
                ldx #VDUVariables.graphicsCursorPixelsX
LE2B8:
                ldy #VDUVariables.oldGraphicsCursorPixelsX

;-------------------------------------------------------------------------
;
; Swap 4 bytes in the VDU variables.
;
; entry:
;
; X = offset of one set of 4 bytes
;
; Y = offset of the other set of 4 bytes
;
exchangeFourVDUBytes:
                lda #$04

;-------------------------------------------------------------------------
;
; Swap bytes in the VDU variables.
;
; entry:
;
; A = number of bytes to swap
;
; X = offset of one set of bytes
;
; Y = offset of the other set of bytes
;
exchangeVDUVariables:
                pha                          ;save count remaining
                lda vduv,x
                pha
                lda vduv,y
                sta vduv,x
                pla
                sta vduv,y
                inx
                iny
                pla
                dec a
                bne exchangeVDUVariables
                rts

;-------------------------------------------------------------------------
;
; Test current VDU4/VDU5 status.
;
; exit:
;
; Z=0 if VDU5 mode
testVDU5StateNonInlined:
                lda STATE
                and #STATE.isVDU5
                rts

;-------------------------------------------------------------------------

                .if version>=350
LE2E7:
                jsr withMOSROM
                jmp callPrinterDriverWithPrinterBuffer
                .endif

;-------------------------------------------------------------------------

                .if version>=350
LE2ED:
                jsr withMOSROM
                jmp LE8B9
                .endif

;-------------------------------------------------------------------------

                .if version>=350
LE2F3:
                jsr withMOSROM
                jmp (VDUV)
                .endif

;-------------------------------------------------------------------------

; Default vector table
; ====================
defaultVectorTable: .block
                .word badCommandError        ; USERV=$200
                .word defaultBRKHandler      ; BRKV=$202
                .word irq1EntryPoint         ; IRQ1V=$204
                .word irq2EntryPoint         ; IRQ2V=$206
                .word oscliEntryPoint        ; CLIV=$208
                .word osbyteEntryPoint       ; BYTEV=$20a
                .word oswordEntryPoint       ; WORDV=$20c
                .word oswrchEntryPoint       ; WRCHV=$20e
                .word osrdchEntryPoint       ; RDCHV=$210
fsVectors: .block
                .word E_FILEV                ; FILEV=$212
                .word E_ARGSV                ; ARGSV=$214
                .word E_BGETV                ; BGETV=$216
                .word E_BPUTV                ; BPUTV=$218
                .word E_GBPBV                ; GBPBV=$21a
                .word E_FINDV                ; FINDV=$21c
                .word E_FSCV                 ; FSCV=$21e 
end:
                .bend
                .word rtsFFAA                ; EVENTV=$220
                .word rtsFFAA                ; UPTV=$222
                .word rtsFFAA                ; NETV=$224
                .word rtsFFAA                ; VDUV=$226
                .word keyEntryPoint          ; KEYV=$228
                .word insEntryPoint          ; INSV=$22a
                .word remEntryPoint          ; REMV=$22c
                .word cnpEntryPoint          ; CNPV=$22e
                .word rtsFFAA                ; IND1V=$230
                .word rtsFFAA                ; IND2V=$232
                .word rtsFFAA                ; IND3V=$234
end:
                .bend

                ; valueFF is a (presumably arbitrary) byte with the
                ; value 255, that's BIT'd in a few places to set the V
                ; flag.
defaultMOSVariables:
                .word mosVariables-166       ;mosVariablesAddress
                .word extendedVectorSpace    ;extendedVectorSpaceAddress
                .word romInformationTable  ;romInformationTableAddress
                .word keyTranslationTable-16 ;keyboardTranslationTableAddress
                .word vduv                   ;vduVariablesAddress
                .byte $00                    ;cfsTimeoutCounter
                .byte $00                    ;inputSource
                .byte $FF                    ;keyboardSemaphore
                .byte $00                    ;romPollingSemaphore
                .byte $00                    ;oshwm
                .byte $01                    ;rs423InputInterpretationStatus
                .byte $00                    ;noignoreState
                .byte $00                    ;cfsRFSFSSwitch
                .byte $00                    ;vcontrolRegister
                .byte $00                    ;vpaletteRegister
                .byte $00                    ;romActiveAtLastBRK
                .byte $FF                    ;basicROMNumber
                .if version<500
                .byte $04                    ;currentADCChannel
                .byte $04                    ;maximumADCChannel
                .else
                .byte $02                    ;currentADCChannel
                .byte $02                    ;maximumADCChannel
                .endif
                .byte $00                    ;adcConversionType
                .byte $FF                    ;rs423Busy
                .if version==400
                .byte $00                    ;aciaControlRegister
                .else
                .byte $42                    ;aciaControlRegister
                .endif
                .byte $19                    ;flashCounter
                .byte $19                    ;firstFlashColourDuration
                .byte $19                    ;secondFlashColourDuration
                .byte $32                    ;keyboardAutoRepeatDelay
                .byte $08                    ;keyboardAutoRepeatRate
                .byte $00                    ;execFileHandle
                .byte $00                    ;spoolFileHandle
                .byte $00                    ;breakAndESCAPEEffect
                .byte $00                    ;keyboardStatus
                .byte $20                    ;keyboardStatusByte
                .byte $09                    ;rs423InputBufferMinimumSpace
                .byte $00                    ;rs423Ignore
                .byte $00                    ;rs423Destination
                .byte $00                    ;econetInterceptionStatus
                .byte $00                    ;econetInputInterpretationStatus
                .byte $00                    ;econetOutputInterpretationStatus
                .byte $00                    ;speechSystemByte1
                .byte $00                    ;soundSuppressionStatus
                .byte $03                    ;bellChannel
                .byte $90                    ;bellSound
                .byte $64                    ;bellFrequency
                .byte $06                    ;bellDuration
                .byte $81                    ;startupMessageSuppressionStatus
                .byte $00                    ;softKeyStringLength
                .byte $00                    ;pagedModeCounter
                .byte $00                    ;vduQueueNegativeLength
                .byte $09                    ;tabKeyCode
                .byte $1B                    ;escapeCharacter
                .byte $01                    ;input192To207Interpretation
                .byte $D0                    ;input208To223Interpretation
                .byte $E0                    ;input224To239Interpretation
                .byte $F0                    ;input240To255Interpretation
                .byte $01                    ;softKeyInterpretation
                .byte $80                    ;shiftSoftKeyInterpretation
                .byte $90                    ;ctrlSoftKeyInterpretation
                .byte $00                    ;shiftCtrlSoftKeyInterpretation
                .byte $00                    ;escapeKeyStatus
                .byte $00                    ;escapeEffects
valueFF:        .byte $FF                    ;userVIAInterruptMask
                .byte $FF                    ;rs423InterruptMask
                .byte $FF                    ;systemVIAInterruptMask
                .byte $00                    ;tubePresence
                .byte $00                    ;speechSystemByte2
                .byte $00                    ;characterDestinationStatus
                .byte editKeysMode.editKeys  ;editKeysMode
                .byte $30                    ;numericKeypadInterpretation
                .byte $01                    ;shadowRAMState
                .byte $00                    ;countryFlag
                .byte $00                    ;userFlag
                .if version==400
                .byte $00                    ;serialULARegister
                .else
                .byte $64                    ;serialULARegister
                .endif
                .byte initialTimerSwitchState ;timerSwitchState
                .byte $FF                    ;softKeyConsistencyFlag
                .if version==400
                .byte $00                    ;printerDriverType
                .else
                .byte $01                    ;printerDriverType
                .endif
                .byte $0a                    ;printerIgnoreChar
                .byte $00                    ;breakVectorByte0
                .byte $00                    ;breakVectorByte1
                .byte $00                    ;breakVectorByte2
                .byte $00                    ;vduDriverMemory
                .byte $00                    ;displayMemory
                .byte $FF                    ;currentLanguageROM

;-------------------------------------------------------------------------
;
; STARTUP
; =======
;
resetEntryPoint:                ;e364
                lda #$40        ; $40 = RTI
                sta nmiEntryPoint ; make NMI routine a no-op
                sei
                lda #$53                 ; ???
                sta LFE8E                ; ???
                .if version==350
                lda #~ACCCON.D
                trb ACCCON
                trb vduv.cursorFlags
                lda ACCCON
                ora #ACCCON.TST|ACCCON.Y|ACCCON.X
                .endif
                .if version==350
                jsr staTEMPAAndACCCON
                jmp reset
                .else
                jsr selectTerminalROM ; Page in ROM 15 and continue
                jmp reset
                .endif

;-------------------------------------------------------------------------

                .if version==350
staTEMPAAndACCCON:
                sta TEMPA
                sta ACCCON
                rts
                .endif

;-------------------------------------------------------------------------

                .if version!=350&&(includeTubeSupport||version>=500)
                .include "isSecondProcessorPresent.s65"
                .endif

;-------------------------------------------------------------------------
;
;
;
                .if version==350
clearTSTAndLE389:
                jsr withTSTClear
                .endif

LE389:
                phy
                phx
                .if useTableDrivenConfigure
                jsr selectTerminalROM
                jsr L873F
                .else
                jsr getROMInsertedFlagRTCAddressAndMask
                sta TEMPA                    ;save mask
                jsr selectTerminalROM
                jsr readRTCByte     ;read inserted flag
                tya                          ;A = byte read
                and TEMPA                    ;do mask
                .endif
                cmp #$01                     ;C set if ROM is inserted
                plx
                ply
                jmp selectROMX

;-------------------------------------------------------------------------
;
; Scan ROMs and fill in the rom information table.
;
; entry:
;
; X = first ROM to scan
;
                .if version!=350
scanROMs: .proc
                .include "scan_roms.s65"
                jmp romsScanned     ;not sure why not RTS.
                .endproc
                .endif

;-------------------------------------------------------------------------
;
; Checks a ROM is valid - i.e., has a valid-looking copyright string.
;
; Entry:
;
; X = ROM to check
;
; Exit:
;
; C=0 if ROM invalid; C=1 if ROM valid
;
; ROM of interest is selected
;
isROMValid: .proc ;e3f7
                jsr selectROMX
                ldx #$03
                ldy $8007       ; fetch ROM copyright offset pointer
                clc             ; assume no match
-
                lda $8000,y     ; fetch possible ROM copyright char
                eor sidewaysROMCopyrightPrefix,x     ; Z=1 if it matches "\x0(C)"
                bne +           ; branch taken if no match
                iny             ; next copyright byte
                dex             ; count 4 chars
                bpl -
                sec             ; C=1 means a match
+
                rts
                .pend

;-------------------------------------------------------------------------

; End of STARTUP code
; ===================
LE40E:
                sec                      ; Call Break Intercept Vector
                jsr osbyte247EntryPoint
                ldx #romServiceCallInformReset
                jsr makeROMServiceCall
                ldy execFileHandle ; Get Exec handle, skip past if closed
                beq LE424
                stz execFileHandle           ; Clear Exec handle
                lda #$00                     ; Close Exec channel
                jsr OSFIND
LE424:
                sec                          ;
                ror hazel.currentFS
                lda lastBREAKType            ; Soft Break
                beq LE431
                sec                          ;
                ror hazel.libFS
LE431:
                jsr LEE64                    ; Set default ROMFS/TAPEFS settings
                jsr osbyte76                    ; Test Shift and Ctrl keys
                .if version==350
                jsr LE520
                .else
                lsr a                        ; Move SHIFT status from b7 to b3
                lsr a
                lsr a
                lsr a
                .endif
                eor startupOptions ; Toggle with OSBYTE 255 boot status
                and #$08
                tay
                ldx hazel.currentFSROM
                lda lastBREAKType ; Soft Break, use current filing system
                beq LE454
                jsr selectTerminalROM
                .if useTableDrivenConfigure
                ldx #configureTable.file.metadata-configureTable
                jsr readConfigurationByte
                .else
                phy
                jsr readDefaultROMs
                and #$0F                     ;get default FS ROM
                ply
                .endif

                tax
LE454:
                bit romInformationTable,x
                bpl LE478
                jsr selectROMX
                cpx #terminalROM
                bne LE46C
                jsr osbyte7A
                inx
                beq LE47F
                cpx #$63
                beq LE47F
                bra LE478

LE46C:
                lda #romServiceCallAutoBoot  ; Filing System selection
                jsr $8003
                tax
                jsr selectTerminalROM
                txa
                beq LE4A3
LE478:
                ldx #romServiceCallAutoBoot
                jsr makeROMServiceCall
                beq LE4A3
LE47F:
                tya
                bne LE499
                lda #$8D
                jsr osbyte8C8D
                ldx #<starRunBOOT
                ldy #>starRunBOOT
                dec startupMessageSuppressionStatus
                jsr OSCLI
                inc startupMessageSuppressionStatus
                bra LE4A3

;-------------------------------------------------------------------------

LE496:
                inc startupMessageSuppressionStatus ;set bit 0
LE499:
                sec
                ror hazel.currentFS
                .if version<400
                lda #$00
                tax
                jsr selectROMOrTAPE
                .elsif version<500
                jsr selectROMOrTAPEByOSBYTE
                .elsif version>=500
                lda #$8d
                jsr osbyte8C8D
                .endif
LE4A3:
                lda #$05                     ;
                ldx printerDriverType        ; *FX5,<current printer>
                jsr osbyteEntryPoint
                lda lastBREAKType ; If not Soft Break, select default language
                bne LE4BB
                ldx currentLanguageROM      ; Get current language ROM
                .if version==350&&!finmos329
                txa
                and #$bf
                cmp #$10
                .else
                cpx #$10                     ; <16, normal ROM number, use it
                .endif
                bcc LE4C2
                .if version==350&&!finmos329
                cmp #$10+terminalROM
                .else
                cpx #$10+terminalROM ; 16+UTILS ROM, re-enter Supervisor or Tube CLI
                .endif
                beq LE509
LE4BB:
                jsr selectTerminalROM     ; Page in ROM 15 - UTILS ROM
                .if useTableDrivenConfigure
                ldx #configureTable.lang.metadata-configureTable
                jsr readConfigurationByte
                .else
                jsr readDefaultLanguageROM        ; Read configured LANG
                .endif
                tax
LE4C2:
                clc

;-------------------------------------------------------------------------
;
; OSBYTE 142 (&8E) Enter language ROM [MasRef D.2-44]
;
osbyte8E:
                .if version==350
                phx
                txa
                and #$f
                tax
                .endif
                bit romInformationTable,x ; b6=0, error Not a language
                .if version==350
                plx
                .endif
                bvc thisIsNotALanguageError
                php
                bcc LE4E1 ;taken if not OSBYTE 142 - so skip ROM check
                jsr selectROMX
                lda sidewaysROMType
                and #%00001101
                beq is6502ROM ;taken if low nybble is 0 (6502 BASIC) or 2 (other 6502 ROM)
                .if includeTubeSupport
                bit tubePresence
                .else
                bit tubePresenceUnused
                .endif
                bpl iCannotRunThisCodeError  ;taken if no Tube - assume impossible to run
is6502ROM:
                phx                          ;save ROM slot
                ldx #romServiceCallLanguageChange
                jsr makeROMServiceCall
                plx                          ;restore ROM slot
LE4E1:
                stx currentLanguageROM
                jsr selectROMX
                lda #>sidewaysROMName
                ldy #(<sidewaysROMName)-1
                jsr print0TerminatedString
                sty errPtr+0
                jsr OSNEWL
                jsr OSNEWL
                plp
                .if includeTubeSupport
                lda #$01               ; A=1 on default language entry
                bit tubePresence
                bmi copyLanguageOverTube     ;taken if Tube is present
                .endif
                lda sidewaysROMType
                and #%00001101
                bne iCannotRunThisCodeError ;taken if low nybble isn't 0 (6502 BASIC) or 2 (other 6502 ROM)
                inc a                   ;A=1 on default language entry
                jmp sidewaysROMLanguageEntry

LE509:
                lda #$00
                .if includeTubeSupport
                bit tubePresence
                bpl startCommandLineUI
copyLanguageOverTube:
                jmp tubeHost.copyLanguage
                .else
                bra startCommandLineUI
                .endif

;-------------------------------------------------------------------------

sidewaysROMCopyrightPrefix: .block
                .text ")C("
end:
                .endblock

;-------------------------------------------------------------------------

thisIsNotALanguageError:
                brk
                .text 0,"This is not a language"

;-------------------------------------------------------------------------

iCannotRunThisCodeError:
                brk
                .text 0,"I cannot run this code",0

;-------------------------------------------------------------------------
;
; OSBYTE 164 (&A4) Check processor type [MasRef D.2-50]
;
osbyteA4:
                ldx #sidewaysROMCopyrightPrefix.end-sidewaysROMCopyrightPrefix
                ldy #<sidewaysROMCopyrightOffset
                lda (originalX),y
                tay
-
                lda (originalX),y
                cmp sidewaysROMCopyrightPrefix,x
                bne rtsE564 ;taken if (C) not found - must be OK, if it's not a ROM?
                iny
                dex
                bpl -
                ldy #<sidewaysROMType
                lda (originalX),y
                asl a
                bpl thisIsNotALanguageError ;taken if no language entry point
                and #%00001101<<1
                bne iCannotRunThisCodeError ;taken if low nybble wasn't 0 (6502 BASIC) or 2 (other 6502 ROM)
rtsE564:
                rts

;-------------------------------------------------------------------------

                .if version==350
LE520:
                lsr a
                lsr a
                lsr a
                lsr a
                rts
                .endif

;-------------------------------------------------------------------------

                .if version==350
LE525:
                ldx #$2c                     ;???
                ldy #$03
                jsr writeCMOSByte
                jmp printCMOSRamResetMessage
                .endif

;-------------------------------------------------------------------------

defaultBRKHandler:
                ldy #$00
                jsr printBRKMessage
                jsr OSNEWL
                lda startupMessageSuppressionStatus
                ror a
                bcs startCommandLineUI                   ;taken if bit 0 was set
                jsr OSNEWL
                jmp LE496

;-------------------------------------------------------------------------

startCommandLineUI:
                jsr selectTerminalROM
                jmp commandLineUI

;-------------------------------------------------------------------------
;
; Select paged ROM bank 15 - TERMINAL - with ANDY paged in,
;
; Preserves A/Y
selectTerminalROMAndANDY:   ;e57f
                ldx #$80|terminalROM
                ; fall through into selectROMX

;-------------------------------------------------------------------------
;-------------------------------------------------------------------------
;
; Select paged ROM bank.
;
; Entry:
;
; X = bank to select.
;
; Preserves A/X/Y/P
selectROMX:   ;e581
                stx $F4
                stx ROMSEL
                rts

;-------------------------------------------------------------------------
;
isROMValidThenSelectTerminalROM:
                phy
                jsr isROMValid
                jsr selectTerminalROM
                ply
                rts

;-------------------------------------------------------------------------
;
; Select paged ROM bank 15 - 
;
; Preserves X/Y
selectTerminalROM:            ;e590
                lda #terminalROM
                ; fall through into selectROMA

;-------------------------------------------------------------------------
;
; Select paged ROM bank.
;
; A = bank to select.
;
; Preserves A/X/Y/P
selectROMA:                   ;e592
                sta $F4         ;update ROMSEL copy
                sta ROMSEL
                rts

;-------------------------------------------------------------------------
;
; Select paged ROM bank 15 - TERMINAL - with ANDY paged in,
;
; Preserves A/X/Y

selectTerminalROMAndANDY2:
                phx
                jsr selectTerminalROMAndANDY
                plx
                rts

;-------------------------------------------------------------------------

irqEntryPoint:
                sta TEMPA
                pla                          ;restore P
                pha                          ;save P
                and #$10
                bne brkEntryPoint
                jmp (IRQ1V)

brkEntryPoint:
                phx
                tsx
                lda $0103,x                  ;get BRK address+1 LSB
                cld                          ;
                sec                          ;
                sbc #$01                     ;get BRK address LSB
                sta errPtr+0
                lda $0104,x                  ;get BRK address+1 MSB
                sbc #$00                     ;get BRK address MSB
                sta errPtr+1
                lda $F4
                sta romActiveAtLastBRK
                stx originalX
                ldx #romServiceCallBreakInstruction
                jsr makeROMServiceCall
                ldx currentLanguageROM
                jsr selectROMX
                plx
                lda TEMPA
                cli
                jmp (BRKV)

;-------------------------------------------------------------------------

                .if version!=400
LE5D4:
                sec
                ror rs423Busy
                bit aciaControlRegister
                bpl LE5E4
                jsr getRS423InputBufferFreeBytes
                ldx #$00
                bcs LE5E6
LE5E4:
                ldx #$40
LE5E6:
                jmp resetACIAState

LE5E9:
                ldy ACIA+1
                and #$3A
                bne LE628
                ldx rs423Ignore
                bne LE5FE
                inx
                jsr osbyte99
                jsr getRS423InputBufferFreeBytes
                bcc LE5E4
LE5FE:
                rts
                .endif

;-------------------------------------------------------------------------

irq1EntryPoint:
                lda TEMPA
                pha
                phx
                phy
                .if version!=400
                clv
                .endif
                jsr irq1Handler
                ply
                plx
                pla
                rti

;-------------------------------------------------------------------------

irq2EntryPoint:
                lda TEMPA
                rti

;-------------------------------------------------------------------------

                .if version==400
rtsE64D:
                rts
                .else
irq1Handler:
                lda ACIA+0
                .if version>=500
                and rs423InterruptMask
                .endif
                bvs LE616
                bpl checkForSystemVIAInterrupt
LE616:
                ldx $EA
                dex
                bmi LE64E
                bvs rtsE64D
                jsr withTerminalROM
                jmp LA45D

LE623:
                ldy ACIA+1
                rol a
                asl a
LE628:
                tax
                tya
                ldy #$07
                jmp eventEntryPoint

LE62F:
                ldx #$02
                jsr osbyte91
                bcc LE646
                lda printerDriverType
                cmp #$02
                bne LE5D4
                inx
                jsr osbyte91
                ror bufferEmptyFlags+bufferPrinter
                bmi LE5D4
LE646:
                sta ACIA+1
                lda #$E7
                sta $EA
rtsE64D:
                rts

LE64E:
                .if version<500
                and rs423InterruptMask
                .endif
                lsr a
                bcc LE65B
                bvs LE65B
                ldy aciaControlRegister
                bmi LE5E9
LE65B:
                lsr a
                ror a
                bcs LE623
                bmi LE62F
                bvs rtsE64D
                .endif

;-------------------------------------------------------------------------

handleUnrecogisedInterrupt:
                ldx #romServiceCallUnrecognisedInterrupt
                jsr makeROMServiceCall
                beq rtsE64D                  ;taken if handled

                ; Pass unrecognised, unhandled interrupts to IRQ2V.
                pla
                pla
                ply
                plx
                pla
                .if version==350
                sta TEMPA
                .endif
                jmp (IRQ2V)

;-------------------------------------------------------------------------

                .if version==400
irq1Handler:
                .else
checkForSystemVIAInterrupt:
                .endif
                lda systemVIA.ifr
                .if version==400
                bpl handleUnrecogisedInterrupt
                .else
                bpl checkForUserVIAInterrupt
                .endif
                and systemVIAInterruptMask
                and systemVIA.ier
                bit #VIA.irq.ca1
                beq checkForSystemVIAT1Interrupt

                ; Handle CA1 interrupt - CRTC vsync.

                dec cfsTimeoutCounter
                .if version!=400
                lda $EA
                bpl +
                inc $EA
+
                .endif
                lda flashCounter
                beq flashDone                    ;taken if no flash
                dec flashCounter             ;count down
                bne flashDone
                ldx firstFlashColourDuration ;assume first flash colour is next
                lda vcontrolRegister
                lsr a                        ;C=flash bit
                bcc +                        ;taken if first flash colour is next
                ldx secondFlashColourDuration ;actually, second flash colour is next
+
                rol a                        ;reinstate old register value
                eor #VCONTROL.flash          ;toggle flash bit
                jsr setVCONTROL
                stx flashCounter
flashDone:
                ldy #eventStartOfVerticalSync
                jsr eventEntryPoint
                lda #VIA.irq.ca1
                .if version==400
                bra staSystemVIAIFR
                .else
                jmp staSystemVIAIFR          ;acknowledge CA1
                .endif

                .if version!=400
checkForUserVIAInterrupt:
                lda userVIA.ifr
                bpl handleUnrecogisedInterrupt
                and userVIAInterruptMask
                and userVIA.ier
                ror a                        ;C=CA2
                ror a                        ;C=CA1
                bcc handleUnrecogisedInterrupt
                ldy printerDriverType
                dey
                bne handleUnrecogisedInterrupt ;taken if printerDriverType not 1
                lda #VIA.irq.ca1
                sta userVIA.ifr              ;acknowledge CA1
                sta userVIA.ier              ;inhibit CA1
                ldx #bufferPrinter
                jmp LE8D5
                .endif

checkForSystemVIAT1Interrupt:
                bit #VIA.irq.t1
                .if version<400
                beq checkForSystemVIACB1Interrupt
                .else
                beq checkForSystemVIACA2Interrupt
                .endif

                ; Handle T1 interrupt - 100 Hz timer.

                lda #VIA.irq.t1
                sta systemVIA.ifr            ;acknowledge T1 interrupt
                lda timerSwitchState
                tax                          ;X=old timerSwitchState
                eor #$0F
                pha                          ;save new timerSwitchState
                tay                          ;Y=new timerSwitchState
                sec                          ;C=1 - increment
updateTIMELoop:
                lda timer0-1,x
                adc #$00
                sta timer0-1,y

                ; one of X or Y will get to 0 to indicate the end of
                ; the loop.
                dex
                beq updateTIMEDone
                dey
                bne updateTIMELoop
updateTIMEDone:
                pla                          ;restore new timerSwitchState
                sta timerSwitchState
                ldx #$05
incrementIntervalTimer:
                inc intervalTimer-1,x
                bne intervalTimerDone
                dex
                bne incrementIntervalTimer
                ldy #eventIntervalTimerCrossingZero
                jsr eventEntryPoint
intervalTimerDone:
                lda inkeyTimeoutCounter+0
                bne LE715
                lda inkeyTimeoutCounter+1
                beq LE718
                dec inkeyTimeoutCounter+1
LE715:
                dec inkeyTimeoutCounter+0
LE718:
                bit previousKeyPressedWhenReadingOSBYTE
                bpl LE728
                inc previousKeyPressedWhenReadingOSBYTE
                cli
                .if soundStuffInExtROM
                jsr LF3C5_350
                .else
                jsr LF416                    ;update sound???
                .endif
                sei
                dec previousKeyPressedWhenReadingOSBYTE
LE728:
                bit valueFF                  ;V=1
                .if version!=400
                jsr irq1Handler
                .endif
                lda lastKeyPressedInternal
                ora firstKeyPressedInternal
                and keyboardSemaphore
                beq +
                sec
                jsr LF8FF
+
                .if version>=500
                jsr handleDigitalJoystick
                .endif
                jsr pollPrinterDriver
                ldy romPollingSemaphore
                .if version==400
                beq rtsE6B6
                .else
                beq LE748
                .endif
                ldx #romServiceCallPollingInterrupt
                .if version==400
                jmp makeROMServiceCall
                .else
                jsr makeROMServiceCall
LE748:
                .if version<500
                bit HADC+0
                bvs LE752
                .endif
                rts
                .endif

                .if version!=400
checkForSystemVIACB1Interrupt:
                .if version<500
                bit #VIA.irq.cb1
                beq checkForSystemVIACA2Interrupt

                ; Handle CB1 interrupt - ADC conversion complete.
LE752:
                ldx currentADCChannel
                beq acknowledgeSystemVIACB1Interrupt
                lda HADC+2
                sta adcResultLSBs-1,x
                lda HADC+1
                sta adcResultMSBs-1,x
                stx adcLastConvertedChannel
                ldy #eventADCConversionComplete
                jsr eventEntryPoint
                dex                          ;next ADC channel
                bne initiateADCConversion
                ldx maximumADCChannel
initiateADCConversion:
                cpx #$05
                bcc +
                ldx #$04                     ;clamp ADC channel
+
                stx currentADCChannel
                lda adcConversionType
                dec a            ;$FF=default, $07=8 bits, $0b=12 bits
                and #$08         ;8=12 bits, 0=8 bits
                clc
                adc currentADCChannel        ;mix in ADC channel, 1-4
                dec a ;convert to hardware ADC channel, 0-3 (no risk of borrow)
                sta HADC+0                   ;initiate conversion
acknowledgeSystemVIACB1Interrupt:
                lda #$10
staSystemVIAIFR:
                sta systemVIA.ifr
                rts
                .elsif version>=500
initiateADCConversion:
                rts
                .endif
                .endif

checkForSystemVIACA2Interrupt:
                lsr a                        ;C = CA2
                bcc handleUnrecognisedInterruptE799

                ; Handle CA2 interrupt - keyboard.

                clc
                jsr LF8FF
                lda #VIA.irq.ca2
                .if version<400
                bra staSystemVIAIFR
                .else
staSystemVIAIFR:
                sta systemVIA.ifr
rtsE6B6:
                rts
                .endif

handleUnrecognisedInterruptE799:
                jmp handleUnrecogisedInterrupt

;-------------------------------------------------------------------------
;
; OSBYTE 17 (&11) Write next ADC channel to be sampled [MasRef D.2-25]
;
osbyte11:
                .if version!=400
                .if version<500
                sty adcLastConvertedChannel
                .elsif version>=500
                sty currentADCChannel
                .endif
                bra initiateADCConversion
                .endif

;-------------------------------------------------------------------------
;
; Print a 0-terminated string at some offset from startupMessages.
;
; entry:
;
; Y = offset-1 of message
;
printStartupMessage:
                lda #>startupMessages
                ; .cerror (<startupMessages)!=0,"startupMessages must be page-aligned" ;it's more flexible than this, but this'll do for now

;-------------------------------------------------------------------------
;
; Print a 0-terminated string.
;
; entry:
;
; A = address MSB
;
; Y = (address LSB)-1
;
print0TerminatedString:
                sta errPtr+1
                stz errPtr+0

;-------------------------------------------------------------------------
;
; Print the BRK message.
;
; entry:
;
; (errPtr) = pointer to the error number (as will be the case after a
; BRK)
;
; Y=0
;
printBRKMessage:
                iny
                lda (errPtr),y
                jsr OSASCI
                tax
                bne printBRKMessage
rtsE7B0:
                rts

;-------------------------------------------------------------------------

                .if version>=500
;-------------------------------------------------------------------------

unk_E78B:       .byte 0
                .byte $8D       ;
                .byte $8F       ;
                .byte $8E       ;
                .byte $8C       ;
                .byte $7F       ;
                .byte $D
                .byte $8B       ;
                .byte $8B       ;
unk_E794:       .byte $96
                .byte $E6       ;
                .byte $D6       ;
                .byte $C6       ;
                .byte $86       ;

;-------------------------------------------------------------------------

handleDigitalJoystick:.block
                lda maximumADCChannel
                beq rtsE7B0
                bit adcConversionType
                bvc LE7DE
                lda adcResultLSBs
                ldx #0

LE7A8:
                inx
                asl a
                bcs LE7AF
                bne LE7A8
                tax

LE7AF:
                ldy unk_E78B,x
                cpy adcLastChannelRead
                sty adcLastChannelRead
                beq LE7C6
                tya
                beq LE7C6
                jsr insertCharacterIntoKeyboardBuffer
                lda keyboardAutoRepeatDelay
                sta adcResultMSBs+3

LE7C6:
                lda adcResultMSBs+3
                beq LE7DE
                dec adcResultMSBs+3
                bne LE7DE
                lda keyboardAutoRepeatRate
                sta adcResultMSBs+3
                ldy adcLastChannelRead
                beq LE7DE
                jsr insertCharacterIntoKeyboardBuffer

LE7DE:
                bit adcConversionType
                bpl LE7EA
                ldy #$B6
                ldx #romServiceCallCompactJoystick
                jmp makeROMServiceCall

;-------------------------------------------------------------------------

LE7EA:
                lda #$FF
                ldx editKeysMode
                cpx #3
                bne LE807
                inx

LE7F4:
                pha
                phx
                lda unk_E794,x
                tax
                sec
                clv
                jsr LED01
                plx
                pla
                rol a
                dex
                bpl LE7F4
                eor #$FF

LE807:
                and userVIA.irb
                eor #$1F
                lsr a
                php
                asl a
                asl a
                asl a
                plp
                rol a
                tax
                eor adcResultLSBs
                bit adcConversionType
                and #$F0
                stx adcResultLSBs
                bvs locret_E826
                beq LE827
                stz adcResultMSBs+3

locret_E826:
                rts

;-------------------------------------------------------------------------

LE827:
                lda adcConversionType
                beq LE832
                cmp #8
                bcc LE834
                lda #4

LE832:
                eor #3

LE834:
                tay
                dec a
                tax
                lda adcResultMSBs+3
                stz adcResultMSBs+2

LE83D:
                dex
                bmi LE846
                asl a
                rol adcResultMSBs+2
                bra LE83D

;-------------------------------------------------------------------------

LE846:
                sta adcResultMSBs+1
                cpy adcResultMSBs+2
                bcs LE854
                sty adcResultMSBs+1
                sty adcResultMSBs+2

LE854:
                lda adcConversionType
                and #$20
                beq LE86A
                lda #$FF
                sta adcResultLSBs+1
                sta adcResultLSBs+3
                lsr a
                sta adcResultLSBs+2
                sta adcResultMSBs

LE86A:
                ldx #9

LE86C:
                lda adcResultLSBs
                bit unk_E8D5,x
                beq LE8B2
                lda unk_E8D5+1,x
                asl a
                tay
                lda adcConversionType
                and #$20        ; ' '
                beq LE885
                lda unk_E8D5+2,x
                bra LE8AC

;-------------------------------------------------------------------------

LE885:
                lda adcResultLSBs+1,y
                bcs LE89C
                adc adcResultMSBs+1
                sta adcResultLSBs+1,y
                lda adcResultLSBs+2,y
                adc adcResultMSBs+2
                bcc LE8AF
                lda #$FF
                bra LE8AC

;-------------------------------------------------------------------------

LE89C:
                sbc adcResultMSBs+1
                sta adcResultLSBs+1,y
                lda adcResultLSBs+2,y
                sbc adcResultMSBs+2
                bcs LE8AF
                lda #0

LE8AC:
                sta adcResultLSBs+1,y

LE8AF:
                sta adcResultLSBs+2,y

LE8B2:
                dex
                dex
                dex
                bpl LE86C
                inc adcResultMSBs+3
                bne LE8BF
                dec adcResultMSBs+3

LE8BF:
                ldx currentADCChannel
                ldy #3
                jsr eventEntryPoint
                dec currentADCChannel
                beq LE8CE
                bpl locret_E8D4

LE8CE:
                lda maximumADCChannel
                sta currentADCChannel

locret_E8D4:
                rts
                .endblock

;-------------------------------------------------------------------------

unk_E8D5:       .byte $40; @
                .byte 1
                .byte $FF
                .byte $20
                .byte $81       ;
                .byte 0
                .byte $80       ;
                .byte $80       ;
                .byte 0
                .byte $10
                .byte 0
                .byte $FF
                .endif

;-------------------------------------------------------------------------

osbyte81Timed:
                stx inkeyTimeoutCounter+0
                sty inkeyTimeoutCounter+1
                ror readCharacterTimedFlag   ;set the timed flag
                cli
                bra osrdchWithTimeout

;-------------------------------------------------------------------------

osrdchEntryPoint:
                stz readCharacterTimedFlag   ;clear the timed flag
osrdchWithTimeout:
                phx
                phy
                ldy execFileHandle
                beq osrdchLoop               ;taken if not *EXEC'ing
                sec
                ror tapeCritical
                jsr OSBGET             ;get 1 byte from the *EXEC file
                stz tapeCritical
                bcc osrdchDone                    ;taken if byte valid
                lda #$00                     ;OSFIND close file
                stz execFileHandle           ;reset *EXEC handle
                jsr OSFIND                   ;close *EXEC file
osrdchLoop:
                lda escapeFlag               ;b7 set if ESCAPE pressed
                asl a                        ;C=1 if ESCAPE pressed
                lda #27                      ;ASCII for ESCAPE
                bcs osrdchDone               ;exit with C=1 if ESCAPE
                                             ;pressed
                .if version!=400
                ldx inputSource
                .endif
                jsr readFromEconetOrSoftKeyOrInputBufferA ;handle Econet/soft key stuff???
                bcc osrdchDone
                bit readCharacterTimedFlag
                bpl osrdchLoop     ;taken if no timeout - keep looping
                lda inkeyTimeoutCounter+1
                ora inkeyTimeoutCounter+0
                bne osrdchLoop     ;taken if timeout not timed out yet
                dec a              ;timed out: A=$ff, C=1
osrdchDone:
                ply
                plx
                rts

;-------------------------------------------------------------------------

starLIBFS:
                lda hazel.activeFS
                sta hazel.libFS
                rts

;-------------------------------------------------------------------------

                .if includeStarX
starX:
                sta TUBE+8
LE800:
                bra LE800
                .endif

;-------------------------------------------------------------------------
;
; OSCLI
;
; MasRef D.4-1
;

oscliEntryPoint: .block
                jsr selectHAZEL
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                ldy #$00
-
                lda (stringInputBufferAddress),y
                sta hazel.commandLine,y
emptyCommandLine=*+1                         ;arbitrary place that's
                                             ;just a 13 byte...
                cmp #$0D
                beq +     ;branch taken if end of command line reached
                iny
                bne -

                ; OSCLI is a no-op if the command line is too long.
                rts

+
                ldy #>hazel.commandLine
                ldx #<hazel.commandLine
                jsr withTerminalROM
                jmp oscli
                .endblock

emptyCommandLine=oscliEntryPoint.emptyCommandLine

;-------------------------------------------------------------------------

                ; OSWRCH
                ; ======
oswrchEntryPoint:
                pha                          ;S=[ch]
                phx                          ;S=[x; ch]
                phy                          ;S=[y; x; ch]
                pha                          ;S=[ch; y; x; ch]
                bit econetOutputInterpretationStatus
                bpl LE833
                tay
                lda #netWriteCharacterAttempted
                jsr callNETV
                bcs LE8A5
LE833:
                lda #characterDestinationStatus.vdu_disable
                bit characterDestinationStatus
                bne LE862                ; taken if VDU disabled
                .if fasterOSWRCH
                plx                          ; X=char to print
                phx                          ; save it again
                .else
                pla                          ;restore char to print
                pha                          ;save it again
                tax                          ;X=char to print
                .endif
                lda ACCCON                   ;
                pha                          ;S=[old ACCCON; ch; y; x; ch]
                .if fasterOSWRCH
                ; I think it's safe to clear Y like this in this case.
                and #~ACCCON.Y               ; MOS ROM at $c000
                sta ACCCON
                .elsif version==350
                jsr selectMOS
                .else
                lda #ACCCON.Y
                trb ACCCON                   ;MOS ROM at $c000
                .endif
                lda $F4
                pha          ;S=[old ROMSEL; old ACCCON; ch; y; x; ch]
                lda #$80|terminalROM
                sta $F4
                sta ROMSEL                   ;page in ANDY+Terminal
                txa                          ;A=char to print
                jsr outputToVDU
                pla
                sta $F4
                sta ROMSEL
                pla
                ; Only the saved Y bit is valid. For example, a mode
                ; change might have adjusted the shadow RAM setup.
                and #ACCCON.Y
                tsb ACCCON

                .if fasterOSWRCH
                ; Early out when doing VDU output only.
                ;
                ; (The spool disable + spool handle case is treated as
                ; spool enabled.)
                lda characterDestinationStatus
                and #(~characterDestinationStatus.spool_disable)&$ff
                ora spoolFileHandle
                beq LE8A5
                .endif
                
                bcs LE869
LE862:
                lda #characterDestinationStatus.printer_enable
                bit characterDestinationStatus
                beq LE86E                    ; taken if printer disabled
LE869:
                pla
                pha
                jsr LE8AA
LE86E:
                .if version!=400
                lda characterDestinationStatus
                ror a                      ; extract rs423_enable flag
                bcc LE88F                  ; taken if RS423 disabled
                ldy $EA
                dey
                bpl LE88F
                pla
                pha
                php
                sei
                ldx #$02
                pha
                jsr osbyte98
                bcc LE888
                jsr clearRS423BusyAndSetRS423Active
LE888:
                pla
                ldx #$02
                jsr LE9A3
                plp
LE88F:
                .endif

                lda #characterDestinationStatus.spool_disable
                bit characterDestinationStatus
                bne LE8A5
                ldy spoolFileHandle
                beq LE8A5
                pla
                pha
                sec
                ror tapeCritical
                jsr OSBPUT
                lsr tapeCritical
LE8A5:
                pla
                ply
                plx
                pla
                rts

LE8AA:
                bit characterDestinationStatus
                bvs LE8D4
                cmp printerIgnoreChar
                bne LE8B9
                bit noignoreState
                bpl LE8D4
LE8B9:
                php
                sei
                tax
                lda #characterDestinationStatus.printer_disable
                bit characterDestinationStatus
                bne LE8D3
                txa
                ldx #$03
                jsr LE9A3
                bcs LE8D3
                bit bufferEmptyFlags+bufferPrinter
                bpl LE8D3
                jsr LE8D5
LE8D3:
                plp
LE8D4:
                rts

LE8D5:                                       ;E7CA in MOS 4.00
                lda printerDriverType
                .if version!=400
                beq LE959
                dec a
                bne LE8FD
                jsr osbyte91
                ror bufferEmptyFlags+bufferPrinter
                bmi rtsE928
                ldy #$82
                sty userVIA.ier
                sta userVIA.ora
                lda userVIA.pcr
                and #$F1
                ora #$0C
                sta userVIA.pcr
                ora #$0E
                sta userVIA.pcr
                rts

LE8FD:
                dec a
                bne activatePrinterDriver
                ldy $EA
                dey
                bpl LE959
                lsr bufferEmptyFlags+bufferPrinter
clearRS423BusyAndSetRS423Active:
                lsr rs423Busy
setRS423Active:
                jsr getRS423InputBufferFreeBytes
                bcc rtsE928
                ldx #ACIA.control.rtsLowTXInterruptEnabled
resetACIAState:
                ldy #ACIA.control.rtsRTSInterruptEnabled|ACIA.control.word8DataOddParity1Stop|ACIA.control.reset

;-------------------------------------------------------------------------
;
; OSBYTE 156 (&9C) Read/write serial ACIA control [MasRef D.2-47]
;
osbyte9C:
                php
                sei
                tya
                stx SEIWKA
                and aciaControlRegister
                eor SEIWKA
                ldx aciaControlRegister
writeACIAControlRegisterAndCopy:
                sta aciaControlRegister
                sta ACIA.control
                plp
rtsE928:
                rts

                .else

                cmp #printerDriverTypeUser
                bcc LE959

writeACIAControlRegister:
osbyte9C:
setRS423Active:

                .endif

;-------------------------------------------------------------------------

activatePrinterDriver:
                clc
                lda #printerDriverActivate
                jsr callPrinterDriverWithPrinterBuffer

                ; printer driver will set C=0 if active, C=1 if
                ; inactive.

;-------------------------------------------------------------------------
;
; OSBYTE 123 (&7B) Inform MOS of printer driver going dormant [MasRef
; D.2-36]
;
osbyte7B:
                ror bufferEmptyFlags+bufferPrinter   ;C=1 on entry, so set bit 7
rtsE932:
                rts

;-------------------------------------------------------------------------

pollPrinterDriver:
                bit bufferEmptyFlags+bufferPrinter
                bmi rtsE932           ;taken if printer driver dormant
                lda #printerDriverPoll
callPrinterDriverWithPrinterBuffer:
                ldx #bufferPrinter
callPrinterDriver:
                ldy printerDriverType
                jsr callNETV
                jmp (UPTV)

;-------------------------------------------------------------------------
;
; OSBYTE 15 (&0F) Flush buffer
;
osbyte0F:
                bne LE956
LE947:
                ldx #$08
LE949:
                cli
                sei
                jsr osbyte15
                dex
                bpl LE949

;-------------------------------------------------------------------------
;
; OSBYTE 21 (&15) Flush selected buffer
;
osbyte15:                                    ;e951
                cpx #bufferMax+1
                bcc LE959
                rts

LE956:
                ldx inputSource
LE959:
                clc
LE95A:
                pha
                php
                sei
                bcs LE967
                txa
                and #$04                     ;buffer 4-7?
                beq LE967                    ;taken if not sound buffer
                jsr clearSoundChannelBuffer
LE967:
                sec
                ror bufferEmptyFlags,x
                cpx #bufferFirstOutput
                bcs LE975                    ;taken if output buffer
                stz softKeyStringLength
                stz vduQueueNegativeLength
LE975:
                jsr purgeBufferViaCNPV
                plp
                pla
                rts

;-------------------------------------------------------------------------
;
; Count/purge entry point [AUG p264]
;
cnpEntryPoint:
                bvc countBuffer
purgeBuffer:
                lda bufferStartIndices,x
                sta bufferEndIndices,x
                rts

countBuffer:
                php
                sei
                php
                sec
                lda bufferEndIndices,x
                sbc bufferStartIndices,x
                bcs LE994
                sec
                sbc bufferIndex0Offsets,x
LE994:
                plp
                bcc LE99D
                clc
                adc bufferIndex0Offsets,x
                eor #$FF
LE99D:
                ldy #$00
                tax
                plp
rtsE9A1:
                rts

;-------------------------------------------------------------------------

LE9A2:
                cli
LE9A3:
                sei
LE9A4:
                jsr callINSV
                bcc rtsE9A1
                jsr LF241
                pha
                jsr updateKeyboardLEDs
                asl a
                pla
                bcc LE9A2
                rts

;-------------------------------------------------------------------------
;
; OSBYTE $77
;
; D.2-33
;
                .if version!=350
selectTerminalROMAndOSBYTE77:
                jsr withTerminalROM
                jmp osbyte77
                .endif

;-------------------------------------------------------------------------
;
; Get *IGNORE CMOS byte offset and mask for a given ROM.
;
; entry:
;
; Y = ROM number
;
; exit:
;
; A = mask
;
; X = RTC address of byte
;
getROMInsertedFlagRTCAddressAndMask:
                lda #$00
                sec
                ldx #CMOSBytes.insertedROMs+0+cmosBytesOffset
-
                rol a
                bne +
                inx
                rol a
+
                dey
                bpl -
                rts

;-------------------------------------------------------------------------

_:=[]
_..=[(bufferKeyboardAddress,bufferKeyboardSize)]
_..=[(bufferRS423InputAddress,bufferRS423InputSize)]
_..=[(bufferRS423OutputAddress,bufferRS423OutputSize)]
_..=[(bufferPrinterAddress,bufferPrinterSize)]
_..=[(bufferSoundChannel0Address,bufferSoundChannel0Size)]
_..=[(bufferSoundChannel1Address,bufferSoundChannel1Size)]
_..=[(bufferSoundChannel2Address,bufferSoundChannel2Size)]
_..=[(bufferSoundChannel3Address,bufferSoundChannel3Size)]
_..=[(buffer8Address,buffer8Size)]
buffers=_

BufferTableIndex0Offset: .function buffer
                .endfunction 256-buffer[1]

BufferTableBase: .function buffer
                .endfunction buffer[0]-BufferTableIndex0Offset(buffer)

;-------------------------------------------------------------------------
;
; Buffer base addresses - each buffer's address, offset by the offset
; for index 0 (see bufferIndex0Offsets).
;
bufferBaseAddressMSBs:
                .for _i=0,_i<len(buffers),_i+=1
                .byte >BufferTableBase(buffers[_i])
                .endfor

bufferBaseAddressLSBs:
                .for _i=0,_i<len(buffers),_i+=1
                .byte <BufferTableBase(buffers[_i])
                .endfor

;-------------------------------------------------------------------------

; Offset of buffer index 0 for each buffer. Index 0 is (-buffer size)
; - buffer indexes count up, and wrap once they reach 0.

bufferIndex0Offsets:
                .for _i=0,_i<len(buffers),_i+=1
                .byte BufferTableIndex0Offset(buffers[_i])
                .endfor

;-------------------------------------------------------------------------
;
; Get base address for a buffer.
;
; entry:
;
; X = buffer number
;
; exit:
;
; (SEIWKA) = buffer base address
;
getBufferBaseAddress:
                lda bufferBaseAddressLSBs,x
                sta SEIWKA
                lda bufferBaseAddressMSBs,x
                sta SEIWKB
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 152 (&98) Examine buffer status [MasRef D.2-45]
;
osbyte98:
                bit valueFF                  ;V=1
                bra callREMV

;-------------------------------------------------------------------------
;
; OSBYTE 145 (&91) Get character from buffer [MasRef D.2-45]
;
; X = buffer number
osbyte91:
                clv                          ;remove
callREMV:
                jmp (REMV)

;-------------------------------------------------------------------------
;
; Buffer remove entry point. [AUG p263]
;
; Even in remove mode, A is the character removed on exit. Some of the
; other MOS routines rely on this.
;
remEntryPoint:
                php
                sei
                lda bufferStartIndices,x
                cmp bufferEndIndices,x
                beq plp_sec_rts  ;taken if buffer empty
                tay                          ;Y=start index
                jsr getBufferBaseAddress
                lda (SEIWKA),y               ;get byte from buffer
                bvs tay_plp_clc_rts                  ;taken if only looking
                pha                          ;save buffered byte
                iny                          ;next char in buffer
                tya                          ;set Z if wrap
                bne +                        ;branch taken if no wrap
                lda bufferIndex0Offsets,x    ;reset index on wrap
+
                sta bufferStartIndices,x

                ; Issue output buffer empty event when appropriate.
                cpx #bufferFirstOutput
                bcc pla_tay_plp_clc_rts ;taken if keyboard or RS423
                                        ;input - i.e., buffer is input
                cmp bufferEndIndices,x       ;buffer now empty?
                bne pla_tay_plp_clc_rts           ;taken if not empty
                ldy #eventOutputBufferEmpty
                jsr eventEntryPoint
pla_tay_plp_clc_rts:
                pla                          ;restore buffered byte
tay_plp_clc_rts:
                tay                          ;Y=buffered byte
plp_clc_rts:
                plp
                clc
                rts

;-------------------------------------------------------------------------
;
; [MasRef D.9-1]
;
eventEntryPoint:
                php
                sei
                pha
                lda eventEnabledFlags,y      ;is the event enabled?
                beq pla_plp_sec_rts                    ;
                tya
                ply
                phy
                jsr LF8BF
                bra pla_tay_plp_clc_rts

;-------------------------------------------------------------------------
;
; Insert character into buffer and issue an event for it.
;
; entry:
;
; Y = buffer number
;
insertCharacterIntoBuffer:
                tya
                ldy #eventCharacterEnteringBuffer
                jsr eventEntryPoint
                tay

;-------------------------------------------------------------------------
;
; OSBYTE 138 (&8A) Insert character code into buffer [MasRef D.2-43]
;
osbyte8A:
                tya
callINSV:
                jmp (INSV)

;-------------------------------------------------------------------------
;
; Default INSV entry point [AUG p263]
;
insEntryPoint:
                php
                sei
                pha                          ;save value to insert
                lda bufferEndIndices,x       ;get buffer index
                inc a                        ;bump index
                bne +          ;taken if index hasn't wrapped around
                lda bufferIndex0Offsets,x        ;reset index due to wrap
+
                cmp bufferStartIndices,x     ;are we at the start index?
                beq bufferFull       ;taken if yes - i.e., buffer full
                ldy bufferEndIndices,x       ;note old buffer end
                sta bufferEndIndices,x       ;update buffer end
                jsr getBufferBaseAddress
                pla                          ;restore value to insert
                sta (SEIWKA),y               ;store byte in buffer
                bra plp_clc_rts              ;done

bufferFull
                ; Issue input buffer full event when appropriate.
                pla
                cpx #bufferFirstOutput
                bcs plp_sec_rts  ;taken if output buffer
                ldy #eventInputBufferFull
                jsr eventEntryPoint
                pha
pla_plp_sec_rts:
                pla
plp_sec_rts:
                plp
                sec
                rts

;-------------------------------------------------------------------------
;
; Check if character is a letter - A-Z or a-z.
;
; Entry:
;
; A = character to test
;
; Exit:
;
; C=0 if character is letter, C=1 otherwise
;
; Preserves: A/X/Y
isLetter: .proc                 ;EA71
                pha
                and #$DF        ;convert to upper case
                cmp #'Z'+1
                bcs +           ;branch taken with C=1 if past Z
                eor #$FF
                cmp #-'A'       ;C=1 if past A
+
                pla
                rts
                .pend

;-------------------------------------------------------------------------
;
; OSBYTE 153 (&99) Insert character code into buffer, checking for
; ESCAPE [MasRef D.2-46]
;
                .if version==350
clearTSTAndInsertCharacterIntoKeyboardBuffer:
                jsr withTSTClear
                .endif
insertCharacterIntoKeyboardBuffer:
                ldx #$00
osbyte99:
                .if version!=400
                txa                          ;X=1 if RS423, 0 if keyboard
                and rs423InputInterpretationStatus ;A=0 if RS423 simulates keyboard, 1=default
                bne osbyte8A ;taken if default - don't treat RS423 as keyboard
                .endif
                tya          ;A=char
                eor escapeCharacter
                ora escapeKeyStatus
                bne insertCharacterIntoBuffer
                lda breakAndESCAPEEffect
                ror a                        ;C=0 if normal ESCAPE action
                tya                          ;A=char
                bcs osbyte99Done             ;taken if ESCAPE inhibited
                ldy #eventESCAPEPressed
                jsr eventEntryPoint
                bcc osbyte99Done             ;taken if event handled
                jsr osbyte7D
osbyte99Done:
                clc
                rts

;-------------------------------------------------------------------------

; A = 0 (edit keys)/1 (ascii keys)/2 (F keys)
handleCursorKeysAndCopy:
                .if version<500
                ror a                        ;test edit keys mode bit 0
                pla                          ;restore translated value
                bcs clc_rts_EABD       ;taken if value was asciiKeys
                .else
                cmp #2
                pla
                bcc clc_rts_EABD
                .endif

handleFunctionKey:
                tya
                .if version<500&&version!=350
                and #$0F
                .endif
                .if version==350
                pha
                jsr LE520
                .else
                pha
                tya
                lsr a
                lsr a
                lsr a
                lsr a
                .endif
                eor #$04
                tay
                lda input192To207Interpretation-8,y
                lsr a
                .if version<500&&version!=350
                beq LEB32
                pla
                clc
                adc input192To207Interpretation-8,y
                .else
                bne +
                jmp LEC99
+
                rol a
                cmp #2
                bne LEBF5
LEBEA:
                pla
                sta softKeyExpansionPtr
                lda #$ff
                sta softKeyStringLength
                inc a
                bra clc_rts_EABD

LEBF5:
                pla
                and #$0f
                clc
                adc input192To207Interpretation-8,y
                .endif

clc_rts_EABD:
                clc
                rts

;-------------------------------------------------------------------------

copyCharNotRecognised:
                jsr vdu7EntryPoint           ;beep
                plx
readFromInputBufferX:
                jsr osbyte91          ;extract character from buffer X
                .if version<500&&version!=350
                bcs rtsEB28           ;taken if buffer empty
                .elsif version>=500||version==350
                bcs LEC0D
                tay
                bne LEAC8
                .if version>=511||version==350
                txa
                and rs423InputInterpretationStatus
                bne LEC29
                .endif
                .if version==350&&!finmos329
                jsr LEB75
                .else
                jsr osbyte91
                .endif
LEC0D:
                bcs rtsEB28
                tay
                bne clc_rts_EABD
                pha
                ldy #8

LEC15:
                lda shiftCtrlSoftKeyInterpretation-8,y
                cmp #2
                beq LEBEA
                dey
                bne LEC15
                pla
                bra clc_rts_EABD
                .endif

                .if version>=511||version==350
LEC29:
                tya
                .endif

                .if version!=400
LEAC8:
                pha                   ;save character extracted
                cpx #bufferRS423Input ;was it RS423 input buffer?
                bne LEAD3             ;taken if not RS423 input buffer
                jsr setRS423Active
                sec
                ldx #bufferRS423Input

LEAD3:
                pla                          ;restore char extracted
                bcc LEADB                    ;taken if keyboard buffer
                ldy rs423InputInterpretationStatus ;D.2-54
                bne clc_rts_EB27             ;taken if default mode
                .endif

LEADB:
                tay                          ;Y = char
                bpl clc_rts_EB27             ;if normal char, all good
                and #$0F
                cmp #$0B
                bcc handleFunctionKey        ;taken if F key
                adc #$7B    ;C=1, so +$7c - convert $0b-0$f to $87-$8B
                pha         ;save translated value
                lda editKeysMode
                bne handleCursorKeysAndCopy  ;taken if not editKeys
                lda characterDestinationStatus
                ror a                        ;C=rs423_enable
                ror a                        ;C=vdu_disable
                pla                          ;restore translated value
                bcs readFromInputBufferX     ;taken if VDU output disabled
                cmp #$87                     ;COPY?
                beq readCopyChar
                phx                          ;save buffer number
                jsr handleCursorKeyThunk     ;handle cursor key
                plx
readFromEconetOrSoftKeyOrInputBufferA:
                .if version==400
                ldx #0
                .endif
                bit econetInputInterpretationStatus
                bpl readFromSoftKeyOrInputBufferA
                lda #netReadCharacterAttempted
callNETV:
                jmp (NETV)

readFromSoftKeyOrInputBufferA:
                lda softKeyStringLength
                beq readFromInputBufferX
                .if version>=500||version==350
                inc a
                bne LEC70
                stz softKeyStringLength
                lda softKeyExpansionPtr
                bra clc_rts_EB27
LEC70:
                .endif
                .if version!=400
                txa
                and rs423InputInterpretationStatus
                bne readFromInputBufferX
                .endif
                lda $F4
                pha
                jsr selectTerminalROMAndANDY2
                lda (softKeyExpansionPtr)
                plx
                jsr selectROMX
                dec softKeyStringLength
                inc softKeyExpansionPtr+0
                bne clc_rts_EB27
                inc softKeyExpansionPtr+1
clc_rts_EB27:
                clc
rtsEB28:
                rts

readCopyChar:
                phx
                jsr handleCopyKeyThunk
                .if version<500&&version!=350
                beq copyCharNotRecognised
                .else
                bne +
                jmp copyCharNotRecognised
+
                .endif
                plx
                clc
rtsEB31:
                rts

                .if version>=500||version==350
LEC99:
                pla
                and #$0f
                tay
                bcs LECA2
                jmp readFromInputBufferX

LECA2:
                sta currentSoftKey

                .elsif version<500

LEB32:
                ply
                bcc readFromInputBufferX
                tya
                sta currentSoftKey

                .endif

                lda $F4
                pha                           ;save old ROMSEL
                jsr selectTerminalROMAndANDY2
                jsr getSoftKeyStringLength
                sta softKeyStringLength
                lda andy.softKeys.stringLSBs,y
                sta softKeyExpansionPtr+0
                lda andy.softKeys.stringMSBs,y
                sta softKeyExpansionPtr+1
                pla
                jsr selectROMA               ;restore old ROMSEL
                bra readFromEconetOrSoftKeyOrInputBufferA

;-------------------------------------------------------------------------

getSoftKeyStringLength:
                lda andy.softKeys.stringLSBs+1,y
                sec
                sbc andy.softKeys.stringLSBs+0,y
                rts

;-------------------------------------------------------------------------
;
; Page HAZEL out, page MOS in, call handleCursorKey.
;
handleCursorKeyThunk:
                jsr withMOSROM
                jmp handleCursorKey

;-------------------------------------------------------------------------
;
; Page HAZEL out, page MOS in, call handleCopyKey.
;
handleCopyKeyThunk:
                jsr withMOSROM
                jmp handleCopyKey

;-------------------------------------------------------------------------

                .if version==350&&!finmos329
LEB75:
                jsr osbyte91
                bcc LEB7E
                bit $ff
                bpl LEB75
LEB7E:
                rts
                .endif

;-------------------------------------------------------------------------

                .if version<500&&version!=350
                .include "osbyte_osword_table.s65"
                .endif

;-------------------------------------------------------------------------

osbyte88: ;LEC37:
                lda #$00

callUSERV:
                jmp (USERV)

osbyte7E:                       ;ec3c
                ldx #$00
                bit $FF
                bpl osbyte7C
                lda escapeEffects
                bne LEC54
                cli
                stz pagedModeCounter
                jsr withTerminalROM
                jsr starEXEC
                jsr LE947
LEC54:
                ldx #$FF
osbyte7C: ;EC56
                clc
osbyte7D: ;EC57
                .if includeTubeSupport
                .if version==350
                php
                rol escapeFlag
                plp
                .endif
                ror escapeFlag
                bit tubePresence
                bpl LECD9
                jmp tubeHost.copyEscapeStatus
                .else
                php
                sei
                php
                asl escapeFlag
                plp
                ror escapeFlag
                plp
                bra LECD9
                .endif

;-------------------------------------------------------------------------

                .if version<400
osbyte89:
                lda serialULARegister
                tay
                rol a
                cpx #$01
                ror a
                bra LEC89
                .endif

;-------------------------------------------------------------------------
;
; ;OSBYTE 8 (&08) Write RS423 transmit rate
;
; This call sets the RS423 baud rate for transmitting data. The actual format of
; the data is set using OSBYTE 156/&9C (see below).
;
; Entry parameters :
; X=0 selects 9600 baud
; X=1 selects 75 baud
; X=2 selects 150 baud
; X=3 selects 300 baud
; X=4 selects 1200 baud
; X=5 selects 2400 baud
; X=6 selects 4800 baud
; X=7 selects 9600 baud
; X=8 selects 19200 baud
; Y=0
;
; On exit : X=Y=<old serial ACIA control register contents>

                .if version!=400
osbyte08:
                lda #$38
                ; fall through to OSBYTE &07
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 7 (&07) Write RS423 receive rate
;
; This call sets the RS423 baud rate for receiving data. The actual
; format of the data is set using OSBYTE 156/&9C (see below).
;
; Entry parameters :
; X=0 selects 9600 baud
; X=1 selects 75 baud
; X=2 selects 150 baud
; X=3 selects 300 baud
; X=4 selects 1200 baud
; X=5 selects 2400 baud
; X=6 selects 4800 baud
; X=7 selects 9600 baud
; X=8 selects 19200 baud
; Y=0
;
; On exit : X=Y=<old serial ACIA control register contents>

                .if version!=400
osbyte07:                                    ;ec6d
                eor #$3F                     ;if OSBYTE 8,
                                             ;A=%00000111, mask for
                                             ;transmit rate; if OSBYTE
                                             ;8, A=%000111000, mask
                                             ;for receive rate.
                sta $FA                      ;save mask
                ldy serialULARegister                    ;
                cpx #$09                     ;check for invalid baud rate
                bcs LEC8F                    ;branch taken if invalid
                and serialBaudRatesTable,x   ;get setting in A
                sta $FB                      ;store setting
                tya                          ;
                ora $FA
                eor $FA
                ora $FB
                ora #$40
                eor rs423Destination ;mask in tape/serial flag set by OSBYTE 205ac
LEC89:
                sta serialULARegister
                sta SERPROC+0
LEC8F:
                tya
LEC90:
                tax
                rts
                .endif

                .if version==400
osbyte08:
osbyte07:
LEC89:
LEC90:
                .endif

;-------------------------------------------------------------------------

; Y=0 on entry.

osbyte09:                       ;ec92
                iny
                clc
osbyte0A:                                    ;ec94
                lda firstFlashColourDuration,y
                pha
                txa
                sta firstFlashColourDuration,y
                ply
                lda flashCounter
                bne LEC8F
                stx flashCounter
                lda vcontrolRegister
                php
                ror a
                plp
                rol a
                sta vcontrolRegister
                sta VCONTROL
                bra LEC8F

;-------------------------------------------------------------------------
;
; OSBYTE 2 (&02) Specify input stream
;
; Input may be taken from either the keyboard (by default) or the
; RS423 port. This call specifies the selection for all subsequent
; input.
;
; Entry parameters :
; X=0 selects keyboard input and disables RS423
; X=1 selects and enables RS423 input
; X=2 selects keyboard input and enables RS423
; Y=0
;
; On exit : X=0 indicates previous input was from the keyboard
;           X=1 indicates previous input was from RS423
;           Y is undefined
;
; D.2-18
                .if version!=400
osbyte02:                       ;ecb4
                txa
                and #$01
                pha
                lda aciaControlRegister
                rol a
                cpx #$01
                ror a
                cmp aciaControlRegister
                php
                sta aciaControlRegister
                sta ACIA+0
                jsr setRS423Active
                plp
                beq LECD2
                bit ACIA+1
LECD2:
                ldx inputSource
                pla
                sta inputSource
LECD9:
                rts
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 13 (&0D) Disable event
;
; All events are assigned a unique number and this call provides a
; means of disabling specific events.
;
; Entry parameters:
; X = event number
;
; On exit: X = Y = <old enable state> (0=disabled)
osbyte0D:
                tya             ;A=0

;-------------------------------------------------------------------------
;
; OSBYTE 14 (&0E) Enable event
;
; This call provides a means of enabling specific events.
;
;
osbyte0E:
                cpx #eventMax+1
                .if version!=400
                bcs LEC90
                .else
                bcs LEB22
                .endif
                ldy eventEnabledFlags,x
                sta eventEnabledFlags,x
                .if version!=400
                bra LEC8F
                .else
LEC8F:
LEB21:
                tya
LEB22:
                tax
LECD9:
                rts
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 16 (&10) Write number of ADC channels
;
; By default, each of the four ADC channels is sampled and converted
; in turn so that each reading is updated every 40 milliseconds. This
; call enables the number of channels to be changed so that if, for
; example, only two channels are required, each will be updated every
; 20 milliseconds.
;
                .if version!=400
osbyte10:
                .if version<500
                beq +                        ;taken if X=0
                jsr osbyte11
+
                .endif
                lda maximumADCChannel
                stx maximumADCChannel
                tax
                rts
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 129 (&81) Read key with time limit
;
; This call may be used to read a key from the keyboard subject to a
; specified time limit or to perform a keyboard scan for a specified
; key depression.

osbyte81:
                tya
                bmi LED01          ;taken if scanning for specific key
                jsr osbyte81Timed
                bcs LECFF                 ;taken if timed out or error
                tax                       ;X = ASCII char
LECFD:
                lda #$00
LECFF:
                tay
                rts

LED01:
                txa
                beq LED14
                eor #$7F
                tax
                jsr callKEYV
                rol a
                ; fall through

;-------------------------------------------------------------------------

osbyte82:
                ldx #$FF
                ldy #$FF
                bcs LEB13                    ;if OSBYTE $82, done
                inx
                iny
LEB13:
                rts

LED14:
                .if version==320
                ldx #$FD
                .elsif version==400
                ldx #$f7
                .elsif version==500||version==510
                ldx #$f5
                .elsif version==511||finmos329
                ldx #$f4
                .elsif version==350
                ldx #$fd
                .endif
                bra LECFD

LED18:
                .if version==400
                bpl LEB13
                .endif
                txa
                eor #$FF
                tax
                cpx #$02
                ; fall through

;-------------------------------------------------------------------------

countBufferViaCNPV:
                clv
                bra callCNPV

purgeBufferViaCNPV:
                bit valueFF                  ;V=1
callCNPV:
                jmp (CNPV)

;-------------------------------------------------------------------------

                .if version!=400
getRS423InputBufferFreeBytes:
                sec
                ldx #bufferRS423Input
                jsr countBufferViaCNPV
                cpy #$01                     ;check MSB
                bcs +                        ;if >= 256 bytes, all good
                cpx rs423InputBufferMinimumSpace ;compare to min space
+
                rts
                .endif

;-------------------------------------------------------------------------

                .if version!=400
osbyte80:
                bmi LED18
                beq LED45
                .if version<500
                cpx #$05
                bcs osbyte82                 ;return with X=$ff Y=$ff
                ldy adcResultMSBs-1,x
                lda adcResultLSBs-1,x
                tax
                .elsif version>=500
                inx
                txa
                and #1
                asl a
                tax
                ldy adcResultLSBs+3-1,x
                lda adcResultLSBs+2-1,x
                tax
                .endif
                rts
                .endif

;-------------------------------------------------------------------------

                .if version!=400
LED45:
                .if version<500
                ; Put joystick buttons in bits 0/1.
                lda systemVIA.irb
                ror a
                ror a
                ror a
                ror a
                eor #$FF
                and #$03
                ldy adcLastChannelRead
                stx adcLastChannelRead
                tax
                .elsif version>=500
                ldy currentADCChannel
                ldx adcResultLSBs
                .endif
                rts
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE $70
;
; D.2-31
;
osbyte70:                       ;ed58
                jsr osbyte7071
                asl a
                beq clearACCCCONE
LED5E:
                tsb ACCCON
                rts

clearACCCCONE:
                lda #ACCCON.E
LED64:
                trb ACCCON
                rts

;-------------------------------------------------------------------------

osbyte71:                       ;ed68
                jsr osbyte7071
                bne LED5E
                inc a
                bra LED64

;-------------------------------------------------------------------------
;
; Handle OSBYTE $70 or OSBYTE $71
;
; Entry: A=$70 or $71
;
osbyte7071:
                tay
                txa
                .cerror vduDriverMemory+1!=displayMemory
                sta vduDriverMemory-$70,y
                bne LED80
                lda STATE
                and #STATE.isShadowMode
                beq LED83
LED7D:
                lda #$01
                rts

LED80:
                dec a
                bne LED7D
LED83:
                rts

;-------------------------------------------------------------------------

; OSBYTE &6E (110), &6F (111)
; ===========================
; Pass to sideways ROMs
osbyteUnused:                   ;ed84
                ldx #romServiceCallUnrecognisedOSBYTE
                jsr makeROMServiceCall
                ldx originalX
                .if version!=400
                eor #$00
                .endif
                rts

;-------------------------------------------------------------------------

                .if version!=350
osbyteA1:
                jsr withTerminalROM
                jmp readCMOSByte
                .endif

;-------------------------------------------------------------------------

                .if version!=350
osbyteA2:
                jsr withTerminalROM
                jmp writeCMOSByte
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 140 (&8C) Select Cassette Filing System [MasRef D.2-43]
; OSBYTE 141 (&8D) Select ROM Filing System [MasRef D.2-43]
;
osbyte8C8D:
                jsr selectROMOrTAPEByOSBYTE
                lda ACCCON                    ; Save ACCON register
                pha
                jsr selectHAZEL         ; Page Hazel workspace in
                ldx hazel.activeFS
                stx hazel.currentFS
                lda #terminalROM
                sta hazel.currentFSROM
                pla                          ; Restore ACCON
selectMOSOrHAZEL:                                       ;edb0
                and #ACCCON.Y   ;get just the HAZEL/MOS bit
                bne setACCCONBits      ;branch taken if HAZEL at $c000
selectMOS:
                lda #ACCCON.Y
                trb ACCCON      ;page in MOS at $c000
                rts

selectHAZEL:
                lda #ACCCON.Y
setACCCONBits:
                tsb ACCCON      ;page in HAZEL at $c000
                rts

;-------------------------------------------------------------------------

                .if version==400
LEBBF:
                jsr LEE64
                jsr LF1EE
                .endif

;-------------------------------------------------------------------------
;
; Select ROM or TAPE.
;
; Two entry points: selectROMOrTAPEByOSBYTE picks FS by OSBYTE number
; ($8c=TAPE, $8d=ROM), and selectROMOrTAPE picks FS by number (0=TAPE,
; 1=ROM).
;
; entry:
;
; A = FS to select
;
selectROMOrTAPEByOSBYTE:
                .if version==400

LEDD0:
                lda #2
                sta cfsRFSFSSwitch

                lda #6
                jsr callFSCV

                stz $ce

                .else

                eor #$8C                     ;A=0 if tape, A=1 if ROM
selectROMOrTAPE:
                asl a           ; Set CFS/RFS switch to 0=CFS or 2=RFS
                sta cfsRFSFSSwitch
                bne LEDCC                    ;taken if ROM
                lda #$04                     ; CFS, clear b2 of status
                trb $E2
LEDCC:
                cpx #$03                     ; EQ=TAPE 300, NE=TAPE 1200
                bra LEDD6

LEDD0:
                .if version==350
                jsr withTSTClear
                .endif
                jsr LEE64
                jsr LF1EE
LEDD6:
                php                          ; Save baud flag in Carry
                lda #$06                     ; Vectors about to change
                jsr callFSCV
                lda cfsRFSFSSwitch           ; Jump if RFS selected
                bne LEDEE
                ldx #$06                     ; Prepare baud=6 for TAPE300
                plp                          ; Skip past if TAPE300
                beq LEDEB
                lda #$04                     ; TAPE1200, set bit 2 of status
                tsb $E2
                dex                          ; Change to baud=5 for TAPE1200
LEDEB:
                stx $C6                      ; Store baud rate setting
                php
LEDEE:
                stz $CE                      ; Clear byte (unused on BBC)
                plp
                .endif

                ldx #defaultVectorTable.fsVectors.end-defaultVectorTable.fsVectors ; Prepare to set 7 vectors
LEDF3:
                lda defaultVectorTable.fsVectors-1,x ; Set filing
                                                     ; system vectors
                                                     ; to point to
                                                     ; extended
                                                     ; vectors
                sta FILEV-1,x
                dex
                bne LEDF3
                jsr LF1EE                    ; Set extended vectors
                stz $C2                      ; Set Progress=idle
                ldx #romServiceCallVectorsClaimed ; Send service call &0F - vectors changed

;-------------------------------------------------------------------------
;
; OSBYTE 143 (&8F) Issue paged ROM service request [MasRef D.2-44]
;
osbyte8F: .proc                    ;ee03
                phy
                phx                          ; Send service call
                jsr makeROMServiceCall
                plx
                cpx #romServiceCallVectorsClaimed ; If VectorsClaimed,
                                                  ; hook FileSwitch
                                                  ; back in
                beq handleVectorsClaimed
                inc a       ; If claimed, check for
                            ; InitialiseFilingSystem or
                            ; UnrecognisedCommand
                dec a       ;Z=1 if claimed
                beq wasClaimed  ;branch taken if claimed
done:
                plx             ; Return with result in X, EQ=Claimed
                tax
                rts

wasClaimed:
                cpx #romServiceCallInitialiseFilingSystem
                beq +
                cpx #romServiceCallUnrecognisedCommand
                bne done
+

; handle InitialiseFilingSystem ($12) or UnrecognisedCommand ($04)

                ply                     ;Y=service call arg
                pha                     ;save A (though actually it's
                                        ;always $00...)
                lda ACCCON
                pha                     ;save ACCCON
                jsr selectHAZEL
                sec
                ror hazel.currentFS ;set currentFS bit 7
LEE29:
                phy             ;save ROM service call argument
                lda #$00
                tay
                jsr callARGSV   ;A=0, Y=0 - get active FS number
                sta hazel.activeFS ;save active FS number
                bit hazel.currentFS
                bpl LEE3B
                jsr osbyte6D
LEE3B:
                ply
                pla
                jsr selectMOSOrHAZEL
                pla
                tax
                rts

handleVectorsClaimed:
                ply
                pha
                lda ACCCON
                pha
                jsr selectHAZEL
                lda FSCV+0
                sta hazel.activeFSCV+0
                lda FSCV+1
                sta hazel.activeFSCV+1
                lda #<fileswitchFSCEntryPoint
                sta FSCV+0
                lda #>fileswitchFSCEntryPoint
                sta FSCV+1
                bra LEE29
                .pend

;-------------------------------------------------------------------------

LEE64:
                lda #$A1
                sta $E3
                lda #$19
                sta $03D1
                lda #$04
                tsb $E2
                rts

;-------------------------------------------------------------------------
;
; Pass service call around sideways ROMs
;
; Entry:
; X=service call number
; Y=any parameters
;
; Exit:
; X=0 or preserved
; Y=any returned parameters
; EQ=call claimed if called directly
;
makeROMServiceCall: .proc                    ;ee72
                lda $F4         ; Save current ROM
                pha
                lda ACCCON      ; Save current paging state
                pha
                jsr selectHAZEL ; Page in Hazel
                txa             ; Pass service call number to A
                ldx #$0F     ; Start at ROM 15, and always call ROM 15
                bra callServiceEntry
callServiceEntriesLoop:
                bit romInformationTable,x ;check if ROM X has a service entry
                bpl nextROM       ;branch taken if no service entry
callServiceEntry:
                jsr selectROMX  ; Page in ROM X
                jsr $8003       ; Call ROM service entry point
                tax             ; X = service call result
                beq done       ;branch taken if service call claimed
                ldx $F4         ; Get ROM number
nextROM:
                dex       ; Step down to next ROM, loop until all done
                bpl callServiceEntriesLoop

done:
                pla                          ; Restore paging state
                jsr selectMOSOrHAZEL
                pla                          ; Restore current ROM
                jsr selectROMA
                txa                          ; Pass claim/noclaim to A
                rts
                .pend

;-------------------------------------------------------------------------

; OSBYTE &6B (107) - Select memory for direct access
; ==============================================
osbyte6B:                       ;ee9e
                ldy #$20                     ; Y=&20 to change 1MHz bit
                bra LEEA4

;-------------------------------------------------------------------------

; OSBYTE &6C (108) - Select memory for direct access
; ==============================================
osbyte6C:
                ldy #ACCCON.X                ; Y=&04 to change RAM bit
LEEA4:
                tya                          ; Clear RAM or 1MHz bit
                trb ACCCON
                txa                          ; If X=0, exit with normal RAM/1MHz selected
                beq LEEB0
                .if correctOSBYTE6B6C
                tya
                .else
                lda #ACCCON.X                ; BUG! This should be TYA
                .endif
                tsb ACCCON                   ; Page in shadow RAM
LEEB0:
                rts                          ; X preserved, Y=&04 or &20

;-------------------------------------------------------------------------

osword06Macro: .macro
                jsr getAddressFromOSWORDParameterBlock
                lda (originalX),y
                sta (SEIWKA)
ret:
                lda #$00
                rts
                .endmacro

LEF1BMacro: .macro
                lda $EB
                bmi osword06.ret
                lda spoolFileHandle
                bne osword06.ret
                lda #$08
                and $E2
                bne LEF2E
                lda #$88
                and $BB
LEF2E:
                rts
                .endmacro

;-------------------------------------------------------------------------

                .if version>=350
osword06: .osword06Macro
LEF1B: .LEF1BMacro
                .endif

;-------------------------------------------------------------------------

                .if version>=500
oswordEntryPoint:
                pha
                php
                sei
                sta originalA
                stx originalX
                sty originalY
                ldx #romServiceCallUnrecognisedOSWORD
                cmp #$e0
                bcs osbyteOrUSERV
                cmp #$10
                bcc osword00To0F
                cmp #$44
                bcs osword44ToFF
                cmp #$42
                bcs osword42To43
                sec
osword44ToFF:
                jmp handleUnrecognisedOSBYTEOrOSWORD

osword42To43:
                .cerror (osword42AndAboveRoutineTable-oswordRoutineTable)%2!=0
                sbc #$42-((osword42AndAboveRoutineTable-oswordRoutineTable)/2-1)

osword00To0F:
                .cerror (oswordRoutineTable-osbyteAndOSWORDRoutineTable)%2!=0
                adc #(oswordRoutineTable-osbyteAndOSWORDRoutineTable)/2
                asl a
                bra callOSBYTEOrOSWORDFromTable
                .endif

;-------------------------------------------------------------------------

                .if version>=350
selectTerminalROMAndOSWORD0E:
                cmp #3
                bcs handleUnrecognisedOSWORD
                jsr withTerminalROM
                jmp osword0E
                .endif

;-------------------------------------------------------------------------

                .if version>=500||version==350
LEF85:
                plp
                pla
                bit valueFF
                rts
                .endif

;-------------------------------------------------------------------------


; OSBYTE
; ======
osbyteEntryPoint:
                pha
                php
                sei
                sta originalA
                stx originalX
                sty originalY
                ldx #romServiceCallUnrecognisedOSBYTE
                cmp #$6B
                bcc osbyte00To6A
                cmp #$A6
                bcc osbyte6BToA5
                cmp #$A6
                bcc handleUnrecognisedOSBYTEOrOSWORD       ;??? - wait... didn't we just do this?

osbyteA6ToFF:
                clc
osbyteOrUSERV:      ;call OSBYTE A6+ routine if C=0; call USERV if C=1
                lda #$A6
                adc #$00
                .if version<350
osbyte6BToA5:
                sbc #$50        ;map $6b-$a5 to $1a-$54
                .elsif version>=350
osbyte6BToA5:
                ; map $6b-$a5 to $46-$80
                sbc #$24
osbyte44To45:
                ; map $44-$80 $1a-$56
                sbc #$2A
                .endif
osbyteUseTable:
                asl a           ;table is of words
                sec
callOSBYTEOrOSWORDFromTable:
                sty originalY
                tay             ;get table offset in Y
                bit econetInterceptionStatus
                bpl LEEE0             ;taken if no Econet interception
                txa
                .cerror (netOSBYTEAttempted!=romServiceCallUnrecognisedOSBYTE),"net/rom reason codes mismatch"
                .cerror (netOSWORDAttempted!=romServiceCallUnrecognisedOSWORD),"net/rom reason codes mismatch"
                clv
                jsr callNETV
                bvs LEEFA
LEEE0:
                .if version>=500
                lda $f4
                pha
                jsr selectTerminalROM
                .elsif version==350
                ldx $f4
                jsr selectTerminalROM
                .endif
                .if version==350
                lda osbyteAndOSWORDRoutineTable,y
                sta SEIWKA
                lda osbyteAndOSWORDRoutineTable+1,y
                sta SEIWKB
                .else
                lda osbyteAndOSWORDRoutineTable+1,y
                sta SEIWKB
                lda osbyteAndOSWORDRoutineTable,y
                sta SEIWKA
                .endif
                .if version>=500
                plx
                jsr selectROMX
                .elsif version==350
                jsr selectROMX
                and #$40
                tax
                .endif
                lda originalA
                ldy originalY
                bcs +
                ldy #$00            ;??? - is this actually desirable?
                lda ($F0)           ;fetch 0th byte of parameter block
+
                sec
                .if version==350
                jsr LF198
                .else
                ldx originalX

; on entry to the OSBYTE handlers, C=1, N/Z set as per X.

                jsr callSEIWKA
                .endif
LEEFA:
                ror a
                plp
                rol a
                pla
                clv
                rts

osbyte00To6A:
                ldy #$00        ;Y=0 on entry for this lot
                cmp #$1A        ;OSBYTE <=$19 is table-driven
                bcc osbyteUseTable ;taken if OSBYTE $00-$19
                .if version>=350
                cmp #$44
                beq osbyte44To45
                cmp #$45
                beq osbyte44To45
                .endif
                bra handleUnrecognisedOSBYTEOrOSWORD

handleUnrecognisedOSWORD:
                ldx #romServiceCallUnrecognisedOSWORD
                pla
                pla
handleUnrecognisedOSBYTEOrOSWORD:
                jsr makeROMServiceCall
                .if version<500&&version!=350
                bne LEF15
                .else
                bne LEF85
                .endif
                ldx originalX
                bra LEEFA
                .if version<500&&version!=350
LEF15:
                plp
                pla
                bit valueFF
                rts
                .endif

;-------------------------------------------------------------------------

                .if version<350
LEF1B: .LEF1BMacro
                .endif

;-------------------------------------------------------------------------
;
; OSWORD 14 (&0E) Read CMOS clock [MasRef D.3-22]
;
                .if version<350
selectTerminalROMAndOSWORD0E:
                cmp #$03                   ;only codes 0/1/2 are valid
                bcs handleUnrecognisedOSWORD
                jsr withTerminalROM
                jmp osword0E
                .endif

;-------------------------------------------------------------------------
;
; Entry point for OSWORD.
;
; D.3-3
;
                .if version<500
oswordEntryPoint:
                pha             ;save OSWORD request
                php
                sei
                sta originalA
                stx originalX
                sty originalY
                ldx #romServiceCallUnrecognisedOSWORD
                cmp #$E0
                bcs osbyteOrUSERV ;taken if OSWORD $E0 or higher -
                                  ;these go via USERV

                .if version==320
                cmp #$10
                bcs handleUnrecognisedOSBYTEOrOSWORD ;taken if unknown OSWORD

; adjust request number so it's a suitable index into the
; OSBYTE/OSWORD routine table.

                adc #(oswordRoutineTable-osbyteAndOSWORDRoutineTable)/2
                asl a
                bra callOSBYTEOrOSWORDFromTable

                .else

                cmp #$10
                bcc osword00To0F
                cmp #$44
                bcs handleUnrecognisedOSBYTEOrOSWORD
                cmp #$42
                bcs osword42To43
                sec
                bra handleUnrecognisedOSBYTEOrOSWORD

osword42To43:
                .cerror (osword42AndAboveRoutineTable-oswordRoutineTable)%2!=0
                sbc #$42-((osword42AndAboveRoutineTable-oswordRoutineTable)/2-1)
osword00To0F:
                .cerror (oswordRoutineTable-osbyteAndOSWORDRoutineTable)%2!=0
                adc #(oswordRoutineTable-osbyteAndOSWORDRoutineTable)/2
                asl a
                bra callOSBYTEOrOSWORDFromTable
                .endif
                .endif

;-------------------------------------------------------------------------
;
; OSWORD 5 (&05) Read byte from I/O processor memory [MasRef D.3-9]
;
osword05:
                jsr getAddressFromOSWORDParameterBlock
                lda (SEIWKA)                 ;read byte from the address
                sta (originalX),y                  ;update parameter block
                rts

;-------------------------------------------------------------------------
;
; OSWORD 6 (&06) Write byte to I/O processor memory [MasRef D.3-9]
;

                .if version<350
osword06: .osword06Macro
                .endif

;-------------------------------------------------------------------------
;
; Get address from OSWORD parameter block.
;
; entry:
;
; A = 0th byte of parameter block
;
; Y = 0
;
; (originalX) = parameter block
;
; exit:
;
; (SEIWKA) = address, first two bytes from parameter block
;
; Y = 4 (this is just convenient for both callers)
;
getAddressFromOSWORDParameterBlock:
                sta SEIWKA
                iny
                lda (originalX),y
                sta SEIWKA+1
                ldy #$04
ldxim03_rts:
                .if version<400
                ldx #$03
                .elsif version<500
                ldx #$04
                .else
                ldx #$05
                .endif
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 0 (&00) Display MOS version
;
; OSBYTE 0 has the effect of performing a BRK instruction and
; displaying the MOS version number.
;
; Entry parameters :
;
; X=0 executes a BRK and displays the OS version
;
; X=1 executes an RTS and returns the Operating system version
;
; On exit : X=<OS version>
;
; D.2-18
;
osbyte00:                       ;ef6f
                bne ldxim03_rts ;branch taken if X<>0 - return with
                                 ;X=3

; do a BRK and print MOS version number.

                brk
                .text $f7,versionString,0

;-------------------------------------------------------------------------
;
; OSWORD 7 (&07) Generate a sound [MasRef D.3-10]
;
osword07:
                iny
                lda ($F0),y
                cmp #$20
                bcs handleUnrecognisedOSWORD
                dey
                jsr LEFF6
                ora #$04
                tax
                bcc LEF90
                jsr LE95A
                ldy #$01
LEF90:
                jsr LEFF6
                sta $FA
                php
                ldy #$06
                lda ($F0),y
                pha
                ldy #$04
                lda ($F0),y
                pha
                ldy #$02
                lda ($F0),y
                rol a
                dec a
                dec a
                asl a
                asl a
                ora $FA
                jsr LE9A3
                bcc LEFCE
                pla
                pla
                plp

                ; WTF... fall through to OSBYTE $75!

;-------------------------------------------------------------------------
;
; OSBYTE 117 (&75) Read VDU status [MasRef D.2-32]
;
osbyte75:
                ldx STATE
                rts

;-------------------------------------------------------------------------
;
; VDU 7 (&07) Produce BELL sound [MasRef E.3-4]
;
vdu7EntryPoint:
                php
                sei
                lda bellChannel
                and #$07
                ora #$04
                tax
                lda bellSound
                jsr callINSV
                lda bellDuration
                pha
                lda bellFrequency
                pha
LEFCE:
                sec
                ror $0800,x
                pla
                jsr callINSV
                pla
                jsr callINSV
                plp
                rts

;-------------------------------------------------------------------------
;
; OSWORD 8 (&08) Define a sound envelope [MasRef D.3-14]
;
osword08:
                dec a                   ;get index of 1-based envelope
                asl a
                asl a
                asl a
                asl a                        ;index*16
                ora #$0F                     ;index*16+15
                tax                          ;
                lda #$00                     ;
                ldy #16             ;16 bytes of envelope data get set
-
                cpy #$0E                     ;
                bcs + ;taken if last 2 bytes of data - they get initialized to $00
                lda (originalX),y        ;fetch byte from OSWORD block
+
                sta envelope1Data,x          ;set envelope data bytes
                dex
                dey
                bne -
                rts

;-------------------------------------------------------------------------

LEFF6:
                lda ($F0),y
                cmp #$10
                and #$03
                iny
                rts

;-------------------------------------------------------------------------
;
; OSWORD 3 (&03) Read interval timer [MasRef D.3-8]
;
osword03:
                ldx #$0F
                bra LF005

;-------------------------------------------------------------------------
;
; OSWORD 1 (&01) Read system clock [MasRef D.3-7]
;
osword01:
                ldx timerSwitchState
LF005:
                ldy #$04
-
                lda timer0-initialTimerSwitchState,x
                sta (originalX),y
                inx
                dey
                bpl -
rtsF010:
                rts

;-------------------------------------------------------------------------
;
; OSWORD 4 (&04) Write interval timer [MasRef D.3-9]
;
osword04:
                lda #intervalTimer-(timer0-initialTimerSwitchState)
                bra copyTIMEValue

;-------------------------------------------------------------------------
;
; OSWORD 2 (&02) Write system clock [MasRef D.3-8]
;
osword02:
                lda timerSwitchState
                eor #$0F       ;select the timer that isn't being used
                clc
copyTIMEValue:
                pha
                tax
                ldy #$04
-
                lda (originalX),y
                sta timer0-initialTimerSwitchState,x
                inx
                dey
                bpl -
                pla
                bcs rtsF010
                sta timerSwitchState
                rts

;-------------------------------------------------------------------------
;
; OSWORD 0 (&00) Read line from input stream to memory [MasRef D.3-6]
;
osword00:
                ldy #$04
LF031:
                lda (originalX),y
                .cerror osword0MaxLineLength+1!=osword0MinASCIICharacter
                .cerror osword0MinASCIICharacter+1!=osword0MaxASCIICharacter
                sta osword0MaxLineLength-2,y
                dey
                cpy #$02
                bcs LF031
                lda ($F0),y
                sta $E9
                dey
                stz pagedModeCounter
                lda ($F0)
                sta $E8
                cli
                bra LF051

LF04A:
                lda #$07
LF04C:
                dey
LF04D:
                iny
LF04E:
                jsr OSWRCH
LF051:
                jsr OSRDCH
                bcs LF09F
                tax
                lda characterDestinationStatus
                ror a
                ror a
                txa
                bcs LF064
                ldx vduQueueNegativeLength
                bne LF04E
LF064:
                cmp #$7F
                bne LF06F
                cpy #$00
                beq LF051
                dey
                bra LF04E

LF06F:
                cmp #$15
                bne LF080
                tya
                beq LF051
                lda #$7F
LF078:
                jsr OSWRCH
                dey
                bne LF078
                bra LF051

LF080:
                sta ($E8),y
                cmp #$0D
                beq LF099
                cpy osword0MaxLineLength
                bcs LF04A
                cmp osword0MinASCIICharacter
                bcc LF04C
                cmp osword0MaxASCIICharacter
                beq LF04D
                bcc LF04D
                bra LF04C

LF099:
                jsr OSNEWL
                jsr callNETV
LF09F:
                lda $FF
                rol a
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 3 (&03) Specify output stream [MasRef D.2-19]
;
osbyte03:
                phx
                ldx characterDestinationStatus
                lda #printerDriverFX3
                jsr callPrinterDriver
                plx
                lda #$03
                ldy #$00
                bra osbyte04

;-------------------------------------------------------------------------
;
; OSBYTE 6 (&06) Write printer ignore character [MasRef D.2-21]
;
osbyte06:                       ;f0b3
                lsr noignoreState
                bra osbyte01

;-------------------------------------------------------------------------
;
; OSBYTE 114 (&72) Write usage of shadow memory [MasRef D.2-32]
;
osbyte72:                       ;f0b8
                lda #$1F
                bra LF0CC

;-------------------------------------------------------------------------
;
; OSBYTE 5 (&05) Write printer driver type [MasRef D.2-20]
;
osbyte05:
waitForPrinterDriverDormant:
                cli
                sei
                bit $FF                      ;test for ESCAPE
                bmi rtsF0EB                  ;taken if ESCAPE pressed
                bit bufferEmptyFlags+bufferPrinter
                bpl waitForPrinterDriverDormant ;taken if printer driver active
                jsr callPrinterDriver    ;call with A=printerDriverFX5
                ldy #$00
LF0CC:
                stz $F1

                ; fall through to standard MOS variable handling,
                ; affecting printerDriverType

;-------------------------------------------------------------------------
;
; OSBYTE 1 (&01) Write user flag [MasRef D.2-18]
;
osbyte01:
                eor #firstMOSVariableOSBYTE+(userFlag-mosVariables)-1 ;-1 because OSBYTE 1
                bra osbyteA6X  ;jump to standard MOS variable handling

;-------------------------------------------------------------------------
;
; OSBYTE 12 (&0C) Write keyboard auto-repeat rate [MasRef D.2-23]
;
osbyte0C:
                beq resetKeyRepeat    ;taken if X=0

;-------------------------------------------------------------------------
;
; OSBYTE 11 (&0B) Write keyboard auto-repeat delay [MasRef D.2-22]
;
osbyte0B:
                ; TODO - turn this constant into an expression
                adc #$CF

                ;if osbyte0C, A=$db
                ;if osbyteOD, A=$dc

;-------------------------------------------------------------------------
;
; OSBYTE 4 (&04) Enable/disable cursor editing [MasRef D.2-19]
;
osbyte04:
                clc
                adc #firstMOSVariableOSBYTE+(editKeysMode-mosVariables)-4 ;-4 because OSBYTE 4

                ;if originally OSBYTE 4 (&04) Enable/disable cursor
                ;editing [MasRef D.2-19], it's now OSBYTE 237 (&ED)
                ;Read/write cursor editing status [MasRef D.2-77].
                ;
                ;if originally OSBYTE 12 (&0C) Write keyboard
                ;auto-repeat rate [MasRef D.2-23], it's now OSBYTE 197
                ;(&C5) Read/write keyboard auto-repeat rate [MasRef
                ;D.2-60].
                ;
                ;if originally OSBYTE 11 (&0B) Write keyboard
                ;auto-repeat delay [MasRef D.2-22], it's now OSBYTE
                ;196 (&C4) Read/write keyboard auto-repeat delay
                ;[MasRef D.2-60].

osbyteA6X:
                stx originalX

;-------------------------------------------------------------------------
;
; OSBYTE 166 (&A6) Read start address of MOS variables [MasRef D.2-50]
;
osbyteA6:
                tay             ;
                lda mosVariables-firstMOSVariableOSBYTE,y;
                tax             ;save old value
                and originalY   ;AND old value with Y
                eor originalX   ;EOR old value with X
                sta mosVariables-firstMOSVariableOSBYTE,y     ;set new variable value
                lda mosVariables-firstMOSVariableOSBYTE+1,y
                tay             ;Y=contents of next location
rtsF0EB:
                rts

;-------------------------------------------------------------------------
;
; This table is used to set the serial baud rate.
;
;   - bit 7 is not used (always clear)
;   - bit 6 is not used (always set)
;   - bits 3,4,5 indicate the serial receive baud rate
;   - bits 0,1,2 indicate the serial transmit baud rate
;
;       111 =    75 baud
;       011 =   150 baud
;       101 =   300 baud
;       001 =  1200 baud
;       110 =  2400 baud
;       010 =  4800 baud
;       100 =  9600 baud
;       000 = 19200 baud
;
                .if version!=400
serialBaudRatesTable:
                .byte %01100100;$64
                .byte %01111111;$7f
                .byte %01011011;$5b
                .byte %01101101;$6d
                .byte %01001001;$49
                .byte %01110110;$76
                .byte %01010010;$52
                .byte %01100100;$64
                .byte %01000000;$40
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 19 (&13) Wait for vertical sync [MasRef D.2-26]
;
osbyte13:
                lda cfsTimeoutCounter
-
                cli
                sei
                cmp cfsTimeoutCounter
                beq -

                ; fall through to OSBYTE $a0 (!!)

;-------------------------------------------------------------------------
;
; OSBYTE 160 (&A0) Read VDU variable value [MasRef D.2-49]
;
osbyteA0:
                ldy vduv+1,x
                lda vduv+0,x
                tax
                rts

;-------------------------------------------------------------------------
;
; Reset key auto repeat settings to the defaults set in CMOS.
;
                .if version==350
clearTSTAndResetKeyRepeat:
                jsr withTSTClear
                .endif
resetKeyRepeat:
                jsr withTerminalROM
                .if useTableDrivenConfigure
                ldx #CMOSBytes.keyboardAutoRepeatDelay+cmosBytesOffset
                jsr readRTCByte
                sta keyboardAutoRepeatDelay
                ldx #CMOSBytes.keyboardAutoRepeatRate+cmosBytesOffset
                jsr readRTCByte
                tay
                .else
                jsr getDefaultKeyboardAutoRepeatDelay
                sty keyboardAutoRepeatDelay
                jsr getDefaultKeyboardAutoRepeatRate
                .endif
                ldx keyboardAutoRepeatRate
                sty keyboardAutoRepeatRate
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 18 (&12) Reset soft keys [MasRef D.2-26]
;
; MasRef says X undefined on exit; in fact, X=0, and scanROMs
; relies on this.
;
osbyte12:
                sec
                ror softKeyConsistencyFlag   ;mark soft keys inconsistent
                lda $F4
                pha                          ;push selected paged ROM
                jsr selectTerminalROMAndANDY

                ; point each soft key at the 0th byte of the strings -
                ; they all then have length 0.
                ldx #softKeyCount
-
                lda #<andy.softKeys.strings
                sta andy.softKeys.stringLSBs,x
                lda #>andy.softKeys.strings
                sta andy.softKeys.stringMSBs,x
                dex
                bpl -

                pla                 ;pop previously selected paged ROM
                jsr selectROMA

                stz softKeyStringLength
                stz softKeyConsistencyFlag   ;mark soft keys consistent
                inx
                rts

;-------------------------------------------------------------------------
;
; OSWORD 11 (&0B) Read the palette [MasRef D.3-20]
;
osword0B:
                and vduv.numberOfLogicalColoursMinusOne
                tax
                lda vduv.currentPalette,x
LF146:
                iny
LF147:
                sta (originalX),y
                lda #$00                     ;fill last 3 bytes with 0
                cpy #$04
                bne LF146
                rts

;-------------------------------------------------------------------------
;
; OSWORD 9 (&09) Read pixel logical colour [MasRef D.3-19]
;
osword09:                                    ;f150
                jsr withMOSROM               ; sF150= 20 AB F3     +s
                ldy #$03
-
                lda (originalX),y
                sta vduv.workspace._28,y
                lda $0310,y
                pha
                dey
                bpl -
                lda #VDUVariables.workspace._28
                jsr readPixelColour
                tax
                ldy #$00
LF169:
                pla
                sta $0310,y
                iny
                cpy #$04
                bne LF169
                txa
                bra LF147

osword0A:                                    ;f175
                jsr getSoftCharacterDefinitionAddress
                ldy #$00
                lda $F4
                pha
                jsr selectTerminalROMAndANDY
LF180:
                lda ($DE),y
                iny
                sta ($F0),y
                cpy #$08
                bne LF180
                plx
                jmp selectROMX

osword0C:                                    ;f18d
                jsr withMOSROM
                php
                and $0360
                tax
                iny
                lda ($F0),y
                jmp LC639

osword0D:                                    ;f19b
                jsr withMOSROM
                lda #$03
                jsr LF1A5
                lda #$07
LF1A5:
                pha
                jsr LE2B6
                jsr LC4DF
                ldx #$03
                pla
                tay
LF1B0:
                lda $0310,x
                sta ($F0),y
                dey
                dex
                bpl LF1B0
                rts

; Read address of bottom of screen/top of user memory
; ===================================================
osbyte84:                     ;f1ba
                lda STATE     ; Get VDU status
                bit #STATE.isShadowMode ; If shadow screen, jump to return &8000
                bne LF1D8
LF1C0:
                lda $0355                    ; Get current screen MODE

; Return start of screen for non-shadow MODE in X
; -----------------------------------------------
LF1C3:
                and #$07
                tay
                ldx screenMODEGroupForMODE,y ; Get screen map for supplied MODE
                lda startScreenAddressHighByteForScreenMODEGroup,x ; Get address top byte for this screen map
LF1CC:
                ldx #$00                     ; Address=&xx00
                tay
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 133 (&85) Read top of user RAM for given mode [MasRef D.2-41]
;
osbyte85:
                txa                          ; If MODE &80+n, return &8000
                bmi LF1D8
                ldx shadowRAMState ; If *SHADOW<>0, jump to return non-shadow address
                bne LF1C3
LF1D8:
                lda #$80                     ; Return &8000
                bra LF1CC

;-------------------------------------------------------------------------
;
; OSBYTE 135 (&87) Read screen mode and character at text cursor
; position [MasRef D.2-42]
;
osbyte87: ;F1DC:
                jsr withMOSROM
                jmp readCharacterAtTextCursor

;-------------------------------------------------------------------------
;
; OSBYTE 139 (&8B) Write Filing System options [MasRef D.2-43]
;
osbyte8B:
                asl a

;-------------------------------------------------------------------------
;
; OSBYTE 127 (&7F) Check for end of file on an opened file [MasRef D.2-37]
;
osbyte7F:
                and #$01

;-------------------------------------------------------------------------
;
; Call OSFSC. There's no entry point for this.
;
callFSCV:
                jmp (FSCV)

;-------------------------------------------------------------------------
;
; OSWORD 15 (&0F) Write CMOS clock [MasRef D.3-24]
;
                .if version!=350
selectTerminalROMAndOSWORD0F:
                jsr withTerminalROM       ; Page in ROM 15
                jmp osword0F
                .endif

;-------------------------------------------------------------------------

; Set TAPE/ROM extended vectors
; =============================
LF1EE:
                ldx #$15
LF1F0:
                lda LF1FA-1,x
                sta ExtendedVectorAddress(FILEV)-1,x
                dex
                bne LF1F0
LF1F9:
                rts

; TAPE/ROM extended vector values
; -------------------------------
LF1FA:
                .word osfileTapeOrROM ; FILEV
                .byte terminalROM
                .word osargsTapeOrROM ; ARGSV
                .byte terminalROM
                .word bputTapeOrROM ; BPUTV
                .byte terminalROM
                .if version==400
                .word badCommandError
                .else
                .word bgetTapeOrROM ; BGETV
                .endif
                .byte terminalROM
                .word osgbpbTapeOrROM ; GBPBV
                .byte terminalROM
                .word osfindTapeOrROM ; FINDV
                .byte terminalROM
                .word fscTapeOrROM  ; FSCV
                .byte terminalROM

;-------------------------------------------------------------------------
;
; OSBYTE 109 (&6D) Make temporary Filing System permanent
;
; MasRef D.2-30
;
osbyte6D:;f20f
                ldx hazel.activeFS; Copy active FS to current FS
                stx hazel.currentFS
                lda ExtendedVectorAddress(FILEV)+2 ; Copy XFILEV ROM to current FS ROM number
                sta hazel.currentFSROM
rtsF180:
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 20 (&14) Restore default font definitions
;
; MasRef D.2-24
;
                .if version!=350
osbyte14:                       ;f21c
                jsr withTerminalROM
                jmp restoreFont32To126
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 25 (&19) Restore a group of font definitions
;
; MasRef D.2-28
;
selectTerminalROMAndOSBYTE19:                ;f222
                .if version>=511||version==350
                ldx #romServiceCallUnrecognisedOSBYTE
                jsr makeROMServiceCall
                .if version==350
                beq rtsF180
                .else
                beq LF2EB
                .endif
                ldx originalX
                .endif
                jsr withTerminalROM
                jmp osbyte19

;-------------------------------------------------------------------------

; OSBYTE &16 - Increment ROM polling semaphore
; ========================================
osbyte16:                       ;f228
                inc romPollingSemaphore
LF2EB:
                rts

;-------------------------------------------------------------------------

; OSBYTE &17 - Decrement ROM polling semaphore
osbyte17:                       ;f22c
; ========================================
                dec romPollingSemaphore
                rts

;-------------------------------------------------------------------------

                .if version==350
LF198:
                dex
                bpl LF19E
                jsr withTerminalROM
LF19E:
                ldx originalX
                jmp (SEIWKA)
                .endif

;-------------------------------------------------------------------------

; OSBYTE &76 - Set LEDs to keyboard state
; =======================================
osbyte76:
                php                          ; Disable IRQs
                sei
                lda #$40                     ; Turn on LEDs
                jsr LF241
                bmi LF23E                    ; Exit if Escape pending
                clc                          ; Call KEYV to read SHIFT and CTRL
                clv
                jsr callKEYV
; Returns A.b7=CTRL, A.b6=SHIFT, MI=CTRL, VS=SHIFT
LF23E:
                plp                          ; Restore IRQs
                rol a                        ; Set Carry from A bit 7 and return
                rts
; Returns A.b7=SHIFT, CS=CTRL

; Set keyboard LEDs
; -----------------
LF241:
                bcc LF24C                    ; Skip if not called from OSBYTE
                ldy #$07                     ; Turn ShiftLock LED on
                sty systemVIA.orb
                dey                          ; Turn CapsLock LED on
                sty systemVIA.orb
LF24C:
                bit $FF                      ; Test Escape and return
                rts

;-------------------------------------------------------------------------

osbyte9A:
                txa
setVCONTROL:
                php
                sei
                sta vcontrolRegister
                sta VCONTROL
                lda secondFlashColourDuration
                sta flashCounter
                plp
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 155 (&9B) Write to video ULA palette register and copy
;
osbyte9B:
                txa
writeVPALETTE:
                eor #$07
                php
                sei
                sta vpaletteRegister
                sta VPALETTE
                plp
                rts

;-------------------------------------------------------------------------

gsinitForFilenameParsing:
                clc


;-------------------------------------------------------------------------
;
; GSINIT
;
; MasRef D.10-1
;
gsinitEntryPoint:
                ror stringInputOptions    ;put C into bit 7
                jsr skipSpacesAndCheckForCRInStringInput
                iny
                cmp #'"'
                beq +                       ; C=1 if double quotes
                dey
                clc                         ; clear double quotes flag
+
                ror stringInputOptions ; set doubleQuotes; move bit 7 into spaceNotATerminator
                cmp #$0D                     ; set Z if initial CR
                rts

;-------------------------------------------------------------------------
;
; GSREAD
;
; MasRef D.10-2
; MasRef C.5-8 has the | syntax
;
gsreadEntryPoint:
                lda #stringInputOptions.goodString
                tsb stringInputOptions
                jsr LF29C
                php                          ; save flags
                lsr stringInputOptions       ; move goodString into C
                bcc badStringError           ; branch taken if bad string
                rol stringInputOptions       ; reinstate goodString
                plp                          ; restore flags
                rts                          ;

badStringError:
                brk                          ;
                .text $fd,"Bad string",0
LF29C:
                clc                          ; last char not !
LF29D:
                ; C=1 at this point if |! was the last sequence seen.
                stz stringInputPlingFlag
                ror stringInputPlingFlag     ; set ! flag as required
                lda (stringInputBufferAddress),y
                cmp #13                      ;EOL?
                bne notRETURN                ;taken if not EOL
                bit stringInputOptions
                bpl finishedString           ;taken if !doubleQuotes
badString:
                lda #stringInputOptions.goodString
                trb stringInputOptions
                rts

notRETURN:
                cmp #' '
                bcc badString ;taken if unprintable control char
                bne notSPACE
                bit stringInputOptions ;N=doubleQuotes, V=spaceNotATerminator
                bmi finishUpReadClearV ;taken if quoted
                bvc finishedString ;taken if space is a terminator
notSPACE:
                cmp #'"'
                bne notDOUBLEQUOTE         ;taken if not quotes
                bit stringInputOptions ;N=doubleQuotes, V=spaceNotATerminator
                bpl finishUpReadClearV ;taken if not double quotes
                iny
                lda (stringInputBufferAddress),y
                cmp #'"'
                beq finishUpReadClearV       ;taken if quotes
finishedString:
                jsr skipSpacesAndCheckForCRInStringInput
                sec
                rts

notDOUBLEQUOTE:
                cmp #'|'
                bne finishUpReadClearV       ;taken if not |
                iny                          ;skip |
                lda (stringInputBufferAddress),y
                cmp #'|'
                beq finishUpReadClearV ;branch taken if "||" - literal |
                cmp #'"'
                beq finishUpReadClearV ;branch taken if "|\"" - literal "
                cmp #'!'
                bne LF2E6                    ;taken if not "|!"

                ; Handle |! - ASCII 128-255
                iny                          ;skip !
                bra LF29D

LF2E6:
                cmp #' '
                bcc badString ;taken if | followed by a non-printable char
                cmp #'?'
                beq ascii127                 ;taken if "|?" - CHR$127
                jsr implementCTRLCodes
                bit valueFF
                bra LF2F9

ascii127:
                lda #$7F
finishUpReadClearV:
                clv
LF2F9:
                iny
                ora stringInputPlingFlag ;if it was a |! char, set bit 7
                clc
                rts

;-------------------------------------------------------------------------

incAndSkipSpaces:
                iny
skipSpacesAndCheckForCRInStringInput:
                lda (stringInputBufferAddress),y
                cmp #' '
                beq incAndSkipSpaces
checkForCR:
                cmp #13
                rts

;-------------------------------------------------------------------------

LF308:
                bcc skipSpacesAndCheckForCRInStringInput
LF30A:
                jsr skipSpacesAndCheckForCRInStringInput
                cmp #','
                bne checkForCR
                iny
                rts

;-------------------------------------------------------------------------

                .if version==510&&olivetti

LF3C6o:
                ldx #0
LF3C8o:
                pha
                lda LF3F0o,x
                tay
                pla
                cpy #32
                beq LF3EAo
                inx
                cpy countryFlag
                bne LF3C8o

LF3D8o:
                pha
                lda LF3F0o,x
                tay
                pla
                cpy #33
                bcc LF3EAo
                cmp LF3F0o,x
                beq LF3EBo
                inx
                bra LF3D8o

LF3EAo:
                rts

LF3EBo:
                clv
                lda LF3F0o+1,x
                rts

LF3F0o:
                .byte $20
LF3F1o:
                ldx #$00
LF3F3o:
                pha
                lda LF41Bo,x
                tay
                pla
                cpy #32
                beq LF415o
                inx
                cpy countryFlag
                bne LF3F3o

LF403o:
                pha
                lda LF41Bo,x
                tay
                pla
                cpy #33
                bcc LF415o
                cmp LF41Bo,x
                beq LF416o
                inx
                bra LF403o

LF415o:
                rts

LF416o:
                clv
                lda LF424o,x
                rts

LF41Bo:
                .byte $04
                .byte $7b
                .byte $5b
                .byte $5e
                .byte $3b
                .byte $3a
                .byte $5d
                .byte $7d
                .byte $20
LF424o:
                .byte $04
                .byte $94
                .byte $8d
                .byte $97
                .byte $99
                .byte $8c
                .byte $9b
                .byte $9f
                .endif

;-------------------------------------------------------------------------
;
; Modify character in A as if the SHIFT key is being pressed.
;

implementShift:
                .if version<500&&version!=350

                cmp #'0'
                beq gotShiftedChar           ;taken if SHIFT+0 - no change
                cmp #$40
                beq gotShiftedChar           ;taken if SHIFT+@ - no change
                bcc shiftMaybeNumber ;taken if probably a "number" (ASCII 33-63)
                cmp #$7F
                beq gotShiftedChar  ;taken if SHIFT+DELETE - no change
                bcs shiftNumber     ;taken if SHIFT+CHR$>=127 - ???
flipBitsForShift:
                eor #$30                     ;
                cmp #$6F                     ;
                beq +                        ;taken if originally _
                cmp #$50                     ;
                bne shiftMaybeNumber         ;taken if not originally GBP
+
                eor #$1F                     ;extra step for GBP/_ toggle
shiftMaybeNumber:
                cmp #' '+1
                bcc gotShiftedChar         ;taken if non-printing char
shiftNumber:
                eor #$10                     ;
gotShiftedChar:
                rts

                .else

                ldx #2
                bvc LF3C5
LF3C5:
                cmp LF3E7-1,x
                beq LF3E2
                dex
                bne LF3C5
                bvc LF3E1
                cmp #'!'
                bcc LF3E1
                cmp #'@'
                .if version==350
                beq LF3E1
                .endif
                bcc LF3DF
                cmp #$7f
                beq LF3E1
                bcs LF3DF

LF3DD:
                eor #$30
LF3DF:
                eor #$10
LF3E1:
                rts

LF3E2:
                clv
                lda LF3E9-1,x
                rts

LF3E7:
                .byte '_'
                .byte '0'
LF3E9:
                .byte '`'
                .if version==350
                .byte '0'
                .else
                .byte '@'
                .endif

                .endif

;-------------------------------------------------------------------------
;
; See MasRef C.5-8
;
;
implementCTRLCodes:
                .if version<500&&version!=350

                cmp #$7F
                beq gotCtrlChar
                bcs flipBitsForShift         ;taken if CHR$>=128
                cmp #$60
                bne +                        ;taken if not GBP
                lda #'_'                     ;GBP and _ are equivalent
+
                cmp #$40                     ;
                bcc gotCtrlChar              ;taken if CHR$<64
                and #$1F                     ;|@=0, |A=1, |a=1, etc.
gotCtrlChar:
                rts

                .else

                phx
                ldx #2
LF3EE:
                cmp LF40A-1,x
                beq LF404
                dex
                bne LF3EE
                plx
                cmp #'?'
                bcc LF403
                cmp #$7f
                beq LF403
                bcs LF3DD
                and #$1f
LF403:
                rts

LF404:
                clv
                lda LF40C-1,x
                plx
                rts

LF40A:
                .text '0','@'
LF40C:
                .text 0,0

                .endif

;-------------------------------------------------------------------------

                .if version==350
clearTSTAndOSBYTE247EntryPoint:
                jsr withTSTClear
                .endif
osbyte247EntryPoint:
                lda breakVectorByte0
                eor #$4C                     ; JMP abs
                bne rtsF363
                .if version==350
                jsr breakVectorByte0
                jmp selectTerminalROM
                .elsif version<500
                jmp breakVectorByte0
                .else
                lda $f4
                pha
                jsr breakVectorByte0
                pla
                sta $f4
                rts
                .endif

;-------------------------------------------------------------------------
;
; OSBYTE 144 (&90)
; Set vertical screen shift and interlace
;
; MasRef D.2-44
;
osbyte90:
                lda tvOffset
                stx tvOffset
                tax
                tya
                and #$01
                ldy tvInterlace
                sta tvInterlace
rtsF363:
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 149 (&95) - write to JIM
;
; MasRef D.2-45
;
osbyte95:
                tya
                sta $FD00,x
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 151 (&97) - write to SHEILA
;
; MasRef D.2-45
;
osbyte97:
                tya
                sta $FE00,x
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 147 (&93) - write to FRED
;
; MasRef D.2-45
;
osbyte93:
                tya
                sta $FC00,x
                rts

;-------------------------------------------------------------------------
;
; *SHUT [MasRef G.5-10]
;
starSHUT:
                ldx #romServiceCallCloseAllOpenFiles
                jmp makeROMServiceCall

;-------------------------------------------------------------------------
;
; Return thunk used by withTerminalROM.
;
; On entry here, the old value of $f4 is at the top of the stack.
;
withTerminalROMReturnThunk:
                php                          ; S=[p; old ROMSEL]
                pha                          ; S=[a; p; old ROMSEL]
                phx                          ; S=[x; a; p; old ROMSEL]
                tsx
                lda $0104,x                  ; get old ROMSEL
                jsr selectROMA               ; re-select old ROM
                bra returnThunkSuffix

;-------------------------------------------------------------------------
;
; Select the Terminal ROM. Rearrange the stack so that the original
; ROM is re-selected when withTerminalROM's caller itself returns.
;
withTerminalROM:
                .if version==350
                jsr initWithRoutineStack
                lda $f4
                sta $109,x
                lda #>(withTerminalROMReturnThunk-1)
                sta $108,x
                lda #<(withTerminalROMReturnThunk-1)
                sta $107,x
                .else
                pha                          ; S=[A]
                pha                          ; S=[A; A]
                pha                          ; S=[A; A; A]
                php                          ; S=[P; A; A; A]
                pha                          ; S=[A; P; A; A; A]
                phx                          ; S=[X; A; P; A; A; A]
                tsx                          ; S=[X; A; P; A; A; A; RL; RH]
                lda $0107,x                  ; get RL
                sta $0104,x                  ; overwrite placeholder A
                lda $0108,x                  ; get RH
                sta $0105,x                  ; overwrite placeholder A
                lda $F4                      ; get ROMSEL
                sta $0108,x                  ; overwrite RH

                ; put return thunk in the right spot
                lda #>withTerminalROMReturnThunk-1
                sta $0107,x
                lda #<withTerminalROMReturnThunk-1
                sta $0106,x
                .endif
                jsr selectTerminalROM
                bra plx_pla_plp_rts

;-------------------------------------------------------------------------
;
; Select the MOS ROM (i.e., no HAZEL). Rearrange the stack so that the
; original HAZEL state is restored when withMOSROM's caller itself
; returns.
;
withMOSROM:
                .if version==350
                jsr initWithRoutineStack
                lda #>(withMOSROMReturnThunk-1)
                sta $108,x
                lda #<(withMOSROMReturnThunk-1)
                sta $107,x
                lda ACCCON
                sta $109,x
                jsr selectMOS
                .else
                pha                          ; S=[A]
                pha                          ; S=[A; A]
                pha                          ; S=[A; A; A]
                php                          ; S=[P; A; A; A]
                pha                          ; S=[A; P; A; A; A]
                phx                          ; S=[X; A; P; A; A; A]
                tsx                          ; S=[X; A; P; A; A; A; RL; RH]
                lda $0108,x                  ; get RH
                sta $0105,x                  ; overwrite placeholder A
                lda $0107,x                  ; get RL
                sta $0104,x                  ; overwrite placeholder A

                ; put return thunk in the right spot
                lda #>withMOSROMReturnThunk-1
                sta $0107,x
                lda #<withMOSROMReturnThunk-1
                sta $0106,x

                lda ACCCON                   ; get ACCCON
                sta $0108,x                  ; overwrite RH
                lda #ACCCON.Y
                trb ACCCON
                ; HAZEL off
                .endif
plx_pla_plp_rts:
                ; S=[X; A; P; RL; RH; thunkRL; thunkRH; old ACCCON/ROMSEL]
                plx
                pla
                plp
                rts

withMOSROMReturnThunk:
                php                          ; S=[P]
                pha                          ; S=[A; P]
                phx                          ; S=[X; A; P]
                tsx                          ; S=[X; A; P; old ACCCON]
                lda $0104,x                  ; get old ACCCON
                jsr selectMOSOrHAZEL         ; re-select old HAZEL state
returnThunkSuffix:
                ; double up P, as that's the easiest way of ending up
                ; discarding the TOS without affecting the flags.
                lda $0103,x
                sta $0104,x
                plx
                pla
                plp
                plp
                rts

;-------------------------------------------------------------------------
;
; Clear ACCCON TST bit (paging in I/O for reads, rather than ROM, at
; $fc00...$feff), and restore it on exit from the current routine.
; 
                .if version==350
                ; Should be called something more like runWithTST
withTSTClear:
                jsr initWithRoutineStack
                lda TEMPA
                and #(~ACCCON.TST)&$ff       ; clear TST
                sta ACCCON
                lda #<(withTSTClearReturnThunk-1)
                sta $107,x
                lda #>(withTSTClearReturnThunk-1)
                sta $108,x
                bra plx_pla_plp_rts

withTSTClearReturnThunk:
                php
                pha
                phx
                tsx
                sei
                lda ACCCON
                ora #ACCCON.TST
                jsr staTEMPAAndACCCON
                bra returnThunkSuffix
                .endif

;-------------------------------------------------------------------------
;
; Sort out stack for one of the withXXX routines, that set up some
; state and then automatically restore the original state on exit from
; the calling routine.
; 
                .if version==350
initWithRoutineStack:
                pha                          ; A RL RH R^L R^H
                php                          ; P A RL RH R^L R^H
                pha                          ; A P A RL RH R^L R^H
                phx                          ; X A P A RL RH R^L R^H
                tsx                          ; | X A P A RL RH R^L R^H
                lda $106,x                   ; get RH
                pha                          ; RH | X A P A RL RH R^L R^H
                lda $105,x                   ; get RL
                pha                          ; RL RH | X A P A RL RH R^L R^H
                jsr LF392
                dex
LF392:
                lda $108,x                   ; get R^L or R^H
                sta $105,x                   ; replace RL or RH
                rts
                .endif

;-------------------------------------------------------------------------

vduChrEntryPoint:
                jsr withMOSROM
                ldx $F4
                phx
                jsr selectTerminalROMAndANDY
                jsr outputToVDU
                plx
                jmp selectROMX

;-------------------------------------------------------------------------
;
; OSRDSC [MasRef D.6-1]
;
osrdscEntryPoint:
                jsr withMOSROM
                jmp LC018

;-------------------------------------------------------------------------
;
; OSWRSC [MasRef D.8-1]
;
oswrscEntryPoint:
                jsr withMOSROM
                jmp oswrscCode

;-------------------------------------------------------------------------

starRunBOOT:
                .text "/!BOOT",13

;-------------------------------------------------------------------------

                .if version<500&&version!=350&&!soundStuffInExtROM
                .include "sound_stuff.s65"
                .endif

;-------------------------------------------------------------------------

                .if version>=500

LF416:
                lda $f4
                pha
                jsr selectTerminalROM
                jsr LF416Internal
                plx
                jmp selectROMX

clearSoundChannelBuffer:
                phx
                lda $f4
                pha
                jsr selectTerminalROM
                jsr clearSoundChannelBufferInternal
                plx
                jsr selectROMX
                plx
                rts

                .endif

;-------------------------------------------------------------------------

                .if soundStuffInExtROM
clearSoundChannelBuffer:
                jsr selectExtROM
                phy
                jsr clearSoundChannelBufferInternal
                bra selectOldROM
                .endif

;-------------------------------------------------------------------------

                .if soundStuffInExtROM
LF3C5_350:
                jsr selectExtROM
                phy
                jsr LF416
selectOldROM:
                pla
                jmp selectROMA
                .endif

;-------------------------------------------------------------------------

                .if soundStuffInExtROM
selectExtROM:
                ldy $f4
                lda #extROM
                jmp selectROMA
                .endif

;-------------------------------------------------------------------------

LF6FC:
                lda #$FF
                sta $F5
                rts

LF701:
                inc $F5
                ldy $F5
                ldx #romServiceCallROMFilingSystemInitialize
LF707:
                php
                jsr makeROMServiceCall
                plp
                cmp #$01
                tya
                rts

LF710:
                ldx #$0E
                ldy #$FF
                jmp LF707

LF717:
                lda $03CB
                sta $F6
                lda $03CC
                sta $F7
                lda $F5
                rts

tidyUpAfterKeyboardProcessing:
                ldx #$FF
                lda lastKeyPressedInternal
                ora firstKeyPressedInternal
                bne +                    ;taken if any keys pressed
                lda #$81
                sta systemVIA.ier            ;re-enable keyboard IRQ
                inx                          ;X=0
+
                stx keyboardSemaphore
updateKeyboardLEDs:
                php
                lda keyboardStatusByte
                lsr a

                ; bit 3 = caps lock off
                ; bit 4 = shift lock off
                and #(keyboardStatusByte.capsLockDisengaged|keyboardStatusByte.shiftLockDisengaged)>>1
                ora #$06                     ;latch B6 - caps lock
                sta systemVIA.orb            ;update caps lock LED
                lsr a                        ;bit 3 = shift lock off
                ora #$07                     ;latch B7 - shift lock
                sta systemVIA.orb            ;update shift lock LED
                jsr enableKeyboardScanning
                pla
                rts

; KEYV handler
; ============
keyEntryPoint:
                bvc keyVClear
                lda #$01
                sta systemVIA.ier
                bcs keyboardTimerInterrupt
                jmp keyPressedInterrupt

keyVClear:
                bcc keyTestSHIFTAndCTRLOrTimerInterrupt
                jmp scanKeyboard

keyboardTimerInterrupt:
                inc keyboardSemaphore

;-------------------------------------------------------------------------
;
; Test Shift & Ctrl keys, or deal with timer interrupt.
;
; Entry: C=0 if KEYV V=0 C=0 - test SHIFT+CTRL keys
;        C=1 if KEYV V=1 C=1 - keyboard timer interrupt
;
keyTestSHIFTAndCTRLOrTimerInterrupt:
                lda keyboardStatusByte
                and #~(keyboardStatusByte.shiftPressed|keyboardStatusByte.ctrlPressed)
                ldx #key_shift
                jsr interrogateKeyboard      ;X=$80 if SHIFT pressed
                bcc +                        ;taken if testing
                                             ;SHIFT+CTRL only
                stx SEIWKA                   ;b7 set if SHIFT pressed
+
                clv                        ;V=0
                bpl testCTRL               ;taken if SHIFT not pressed
                bit valueFF                ;V=1 N=1
                ora #keyboardStatusByte.shiftPressed
testCTRL:
                inx                          ;X=1 - key_ctrl
                jsr interrogateKeyboard
                bcc updateKeyboardLEDs ;taken if testing SHIFT+CTRL only
                bpl updateKeyboardStatusByte ;taken if CTRL not pressed
                ora #keyboardStatusByte.ctrlPressed
updateKeyboardStatusByte:
                sta keyboardStatusByte
                ldx lastKeyPressedInternal
                beq braRolloverChecks        ;taken if no key pressed
                jsr interrogateKeyboard      ;still pressed?
                bmi checkForKeyAutoRepeat    ;taken if still pressed
                cpx lastKeyPressedInternal   ;X=0 at this point
storeLastKeyPressed:
                stx lastKeyPressedInternal   ;update last key pressed
                bne braRolloverChecks  ;taken if still nothing pressed
                stz lastKeyPressedInternal   ;reset last key pressed
resetAutoRepeatAndContinue:
                jsr resetAutoRepeatCounters
                bra braRolloverChecks

checkForKeyAutoRepeat:
                cpx lastKeyPressedInternal
                bne storeLastKeyPressed      ;taken if new key pressed
                lda autoRepeatCountdownTimer
                beq braRolloverChecks      ;taken if countdown timer 0
                dec autoRepeatCountdownTimer ;timer--
                bne braRolloverChecks        ;taken if timer newly 0
                lda keyboardFirstAutoRepeatCount
                sta autoRepeatCountdownTimer
                lda keyboardAutoRepeatRate
                sta keyboardFirstAutoRepeatCount
                lda keyboardStatusByte
                ldx lastKeyPressedInternal
                cpx #$80|key_shift_lock
                beq shiftLockPressed
                cpx #$80|key_caps_lock
                .if version>=511||version==350
                bne LF5E5_511
                .else
                bne getASCIICode
                .endif
capsLockPressed:
                ora #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
                bit SEIWKA                   ;test SHIFT status
                bpl +                        ;taken if SHIFT not pressed
                ; Do the SHIFT+CAPS LOCK thing
                ora #keyboardStatusByte.capsLockDisengaged
                eor #keyboardStatusByte.shiftEnabled
+
                eor #keyboardStatusByte.shiftEnabled|keyboardStatusByte.capsLockDisengaged
                bra resetKeyboardStatusAndTimer

shiftLockPressed:
                ora #keyboardStatusByte.shiftEnabled|keyboardStatusByte.capsLockDisengaged
                eor #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
resetKeyboardStatusAndTimer:
                sta keyboardStatusByte
                stz autoRepeatCountdownTimer
braRolloverChecks:
                .if version<500&&version!=350
                bra keyboardRolloverChecks
                .else
                jmp keyboardRolloverChecks
                .endif

;-------------------------------------------------------------------------

                .if version>=511||version==350
LF5E5_511:
                bit keyboardTranslationTableAddress+1
                bmi getASCIICode
                phx
                phx
                ply
                ldx #romServiceCall30
                jsr makeROMServiceCall
                bne LF607
                plx
                tya
                ror a
                ror a
                bcc LF5FC
                stz autoRepeatCountdownTimer
LF5FC:
                bmi braRolloverChecks
                lda keyboardTranslationTableAddress+0
                bit keyboardTranslationTableAddress+1
                .if version==350
                jmp LF839
                .else
                jmp LF6A8
                .endif

LF607:
                plx
                .endif
;-------------------------------------------------------------------------
;
; Convert internal key number (with bit 7 set) to ASCII code, taking
; into account state of CTRL, SHIFT, CAPS LOCK and SHIFT LOCK.
;
getASCIICode:
                ; -$80 to adjust for bit 7 set; -16 because
                ; interesting keys start at 16
                lda keyTranslationTable-$80-16,x
                .if version>=500
                ldx editKeysMode
                cpx #3
                bne LF5E5
                cmp #$8b
                bcc LF5E5
                cmp #$90
                bcc braRolloverChecks
LF5E5:
                pha
                cmp #27
                bne LF5EF
                lda #7
                trb keyboardStatusByte
LF5EF:
                pla
                .endif
                beq handleTAB                ;taken if TAB
                cmp #$9D                     ;was it key_numpad_return?
                .if version<500&&version!=350
                bne handleKey                ;taken if not
                .else
                bne LF5FD
                .endif

                ;Transform $9d into $8d, aka 13|$80. ($8d is already
                ; used in the table for right arrow.)
                eor #$10
                bra getNumpadASCIICode

handleTAB:
                lda tabKeyCode
                .if version>=500
LF5FD:
                cmp #1
                bne LF61F
                lda keyboardStatusByte
                and #$f8
                sta keyboardStatusByte
                ldx #1
                bit #keyboardStatusByte.shiftPressed
                beq LF610
                inx
LF610:
                bit #keyboardStatusByte.ctrlPressed
                beq LF616
                inx
                inx
LF616:
                txa
                ora keyboardStatusByte
                sta keyboardStatusByte
                bra braRolloverChecks

LF61F:
                bit valueFF
                cmp #$90
                bcc handleKey
                clv
                .elsif version==350
LF5FD:
                bit valueFF
                cmp #$90
                bcc handleKey
                clv
                .endif
handleKey:
                cmp #$A0                     ;numpad key?
                bcc processModifiers         ;taken if not
getNumpadASCIICode:
                .if version>=500||version==350
                php
                .endif
                ; C=1 at this point
                sbc #'0'+1      ;+1 to compensate for C=1 in the next
                                ;addition
                adc numericKeypadInterpretation ;form actual ASCII value
                .if version>=500||version==350
                plp
                .endif
                eor #$80                     ;clear bit 7
                ldx numericKeypadShiftEffect ;does SHIFT affect the
                                             ;keypad?
                bne LF839                    ;taken if no
processModifiers:
                ldx keyboardStatusByte
                stx SEIWKA
                rol SEIWKA                  ;b7 = ctrlPressed
                bpl testShiftLock           ;taken if ctrl not pressed
                ldx firstKeyPressedInternal
localResetAutoRepeatAndContinue:
                .if version<500&&version!=350
                bne resetAutoRepeatAndContinue
                jsr implementCTRLCodes
                .else
                beq +
                jmp resetAutoRepeatAndContinue
+
                jsr implementCTRLCodes
                .endif
testShiftLock:
                rol SEIWKA                   ;b7 = shiftLockDisengaged
                bmi testCapsLock             ;taken if shift lock off
                jsr implementShift           ;shift lock on - apply shift
                rol SEIWKA                   ;b7 = capsLockDisengaged
                bra testShiftEnabled

testCapsLock:
                rol SEIWKA                   ;b7 = capsLockDisengaged
                bmi testShift                ;taken if caps lock off
                jsr isLetter
                bcs testShift                ;taken if not a letter
                jsr implementShift ;letter + caps lock - make upper case
testShiftEnabled:
                ldx keyboardStatusByte       ;b7 = shiftEnabled
                bpl testEscape               ;taken if not shiftEnabled
testShift:
                rol SEIWKA                   ;b7 = shiftPressed
                bpl testEscape               ;taken if not shiftPressed
                ldx firstKeyPressedInternal
                bne localResetAutoRepeatAndContinue
                jsr implementShift
testEscape:
                cmp escapeCharacter
                bne LF839
                ldx escapeKeyStatus
                bne LF839
                stz autoRepeatCountdownTimer

LF839:

                .if version==350

                tay
                bvc LF54A
                bne LF555
LF54A:
                tya
                beq LF54F
                bpl LF555
LF54F:
                jsr insertCharacterIntoKeyboardBufferIfPossible
                bcc LF55D_350
                tay
LF555:
                lda keyboardStatus
                bne LF55D_350
                jsr insertCharacterIntoKeyboardBuffer
LF55D_350:
                jsr enableKeyboardScanningFlippingInterrupts

                .elsif version<500

                tay
                jsr enableKeyboardScanningFlippingInterrupts
                lda keyboardStatus
                bne keyboardRolloverChecks
                jsr insertCharacterIntoKeyboardBuffer

                .elsif version>=500

                pha
                lda keyboardStatusByte
                and #7
                tax
                .if version<511
                lda #7
                .endif
                trb keyboardStatusByte
                pla
                pha
                dex
                .if version<511
                bne LF693
                pla
                .if olivetti
                bra LF718o
                .else
                bra LF6A8
                .endif
                .endif

LF693:
                dex
                .if version<511
                bne LF699
                pla
                .if olivetti
                bra LF718o
                .else
                bra LF6A8
                .endif
                .endif

LF699:
                dex
                .if version<511
                bne LF69F
                pla
                .if olivetti
                bra LF718o
                .else
                bra LF6A8
                .endif
                .endif

LF69F:
                dex
                .if olivetti
                bne LF712o
                .else
                bne LF6A7
                .endif
                pla
                ora #$80
                bra LF6AD

                .if olivetti
LF712o:
                pla
                jsr LF3C6o
                bra LF6A7

LF718o:
                jsr LF3F1o
                .endif

LF6A7:
                .if !olivetti
                pla
LF6A8:
                .endif
                tay
                bvc LF6AD
                bne LF6B3
LF6AD:
                jsr insertCharacterIntoKeyboardBufferIfPossible
                bcc LF6BB
                tay

LF6B3:
                lda keyboardStatus
                bne LF6BB
                jsr insertCharacterIntoKeyboardBuffer
LF6BB:
                jsr enableKeyboardScanningFlippingInterrupts

                .endif

keyboardRolloverChecks:
                ldx firstKeyPressedInternal
                beq LF852                    ;taken if 1 key down
                jsr interrogateKeyboard      ;test first key pressed
                stx firstKeyPressedInternal  ;save it
                bmi LF868                    ;taken if still pressed
                stz firstKeyPressedInternal  ;reset first key
LF852:
                ldy #lastKeyPressedInternal
                jsr scanKeyboardWithExclusion
                bmi LF862
                lda lastKeyPressedInternal
                sta firstKeyPressedInternal
updateLastKeyPressedInternal:
                stx lastKeyPressedInternal
                jsr resetAutoRepeatCounters
LF862:
                jmp tidyUpAfterKeyboardProcessing

keyPressedInterrupt:
                jsr interrogateKeyboard
LF868:
                lda lastKeyPressedInternal
                bne LF862
                ldy #firstKeyPressedInternal
                jsr scanKeyboardWithExclusion
                bmi LF862
                bra updateLastKeyPressedInternal

resetAutoRepeatCounters:
                ldx #$01
                stx autoRepeatCountdownTimer
                ldx keyboardAutoRepeatDelay
                stx keyboardFirstAutoRepeatCount
                rts

;-------------------------------------------------------------------------
;
; Read a single key's state from the keyboard
;
; Entry:
;
; X = key to test
;
; Exit:
;
; X=$80, N=1 if key pressed; X=$00, N=0 if key not pressed
;
; Preserves: A/C
;
                .if version==350
clearTSTAndInterrogateKeyboard:
                jsr withTSTClear
                .endif
interrogateKeyboard:
                ldy #$03                     ;write to keyboard
                sty systemVIA.orb
                ldy #$7F
                sty systemVIA.ddra           ;bit 7=input, bits 6-0=output
                stx systemVIA.oraNoHandshake ;store key value
                nop
                ldx systemVIA.iraNoHandshake ;read key state
                rts

; Default keyboard table
; ======================

keyTranslationTable:
                .text "q"                    ;10 q
                .byte "3"                    ;11 3
                .byte "4"                    ;12 4
                .byte "5"                    ;13 5
                .byte $84                    ;14 f4
                .text "8"                    ;15 8
                .byte $87                    ;16 f7
                .text "-"                    ;17 minus
                .text "^"                    ;18 caret
                .byte $8C                    ;19 left
                .byte "6"|$80                ;1a numpad_6
                .byte "7"|$80                ;1b numpad_7
osbyte92:
                ldy $FC00,x                  ;1c 1d 1e
                rts                          ;1f

                .cerror *-keyTranslationTable!=16,'oops'
                .byte $80                    ;20 f0
                .text "w"                    ;21 w
                .text "e"                    ;22 e
                .text "t"                    ;23 t
                .text "7"                    ;24 7
                .text "i"                    ;25 i
                .text "9"                    ;26 9
                .text "0"                    ;27 0
                .text "_"                    ;28 underline
                .byte $8E                    ;29 down
                .byte "8"|$80                ;2a numpad_8
                .byte "9"|$80                ;2b numpad_9
osbyte94:
                ldy $FD00,x                  ;2c 2d 2e
                rts                          ;2f

                .cerror *-keyTranslationTable!=32,'oops'
                .text "1"                    ;30 1
                .text "2"                    ;31 2
                .text "d"                    ;32 d
                .text "r"                    ;33 r
                .text "6"                    ;34 6
                .text "u"                    ;35 u
                .text "o"                    ;36 o
                .text "p"                    ;37 p
                .text "["                    ;38 left_square_bracket
                .byte $8F                    ;39 up
                .byte "+"|$80                ;3a numpad_plus
                .byte "-"|$80                ;3b numpad_minus
                .byte $9D                    ;3c numpad_return
LF8BF:
                jmp (EVENTV)                 ;3d 3e 3f
                .cerror *-keyTranslationTable!=48,'oops'
                .byte 1                      ;40 caps_lock
                .text "a"                    ;41 a
                .text "x"                    ;42 x
                .text "f"                    ;43 f
                .text "y"                    ;44 y
                .text "j"                    ;45 j
                .text "k"                    ;46 k
                .if version<500
                .text "@"                    ;47 at
                .elsif version>=500
                .byte 1                      ;47 special
                .endif
                .text ":"                    ;48 colon
                .byte $0D                    ;49 return
                .byte "/"|$80                ;4a numpad_divide
                .byte 127|$80                ;4b numpad_delete
                .byte "."|$80                ;4c numpad_stop
call1MHzBusHook:
                jmp ($FDFE)                  ;4d 4e 4f

                .cerror *-keyTranslationTable!=64,'oops'
                .byte 2                      ;50 shift_lock
                .text "s"                    ;51 s
                .text "c"                    ;52 c
                .text "g"                    ;53 g
                .text "h"                    ;54 h
                .text "n"                    ;55 n
                .text "l"                    ;56 l
                .text ";"                    ;57 semicolon
                .text "]"                    ;58 right_square_bracket
                .byte $7F                    ;59 delete
                .byte "#"|$80                ;5a numpad_hash
                .byte "*"|$80                ;5b numpad_multiply
                .byte ","|$80                ;5c numpad_comma
callSEIWKA:
                jmp (SEIWKA)                 ;5d 5e 5f
                .cerror *-keyTranslationTable!=80,'oops'
                .byte 0                      ;60 tab
                .text "z"                    ;61 z
                .text " "                    ;62 space
                .text "v"                    ;63 v
                .text "b"                    ;64 b
                .text "m"                    ;65 m
                .text ","                    ;66 comma
                .text "."                    ;67 stop
                .text "/"                    ;68 divide
                .byte $8B                    ;69 copy
                .byte "0"|$80                ;6a numpad_0
                .byte "1"|$80                ;6b numpad_1
                .byte "3"|$80                ;6c numpad_3
                .byte 0                      ;6d
                .byte 0                      ;6e
                .byte 0                      ;6f
                .cerror *-keyTranslationTable!=96,'oops'
                .byte 27                     ;70 escape
                .byte $81                    ;71 f1
                .byte $82                    ;72 f2
                .byte $83                    ;73 f3
                .byte $85                    ;74 f5
                .byte $86                    ;75 f6
                .byte $88                    ;76 f8
                .byte $89                    ;77 f9
                .byte $5C                    ;78 backslash
                .byte $8D                    ;79 right
                .byte "4"|$80                ;7a numpad_4
                .byte "5"|$80                ;7b numpad_5
                .byte "2"|$80                ;7c numpad_2
LF8FF:
                bit valueFF                  ; Set V
callKEYV:
                jmp (KEYV)                   ; Jump to KEYV

;-------------------------------------------------------------------------
;
; OSBYTE 131 (&83) - Read Operating System High Water Mark (OSHWM)
;
; MasRef D.2-40
;
osbyte83:
                ldy oshwm
                ldx #$00
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 120 ($78) - Write keys pressed information
;
; MasRef D.2-33
;
osbyte78:                          ;f90b
                sty lastKeyPressedInternal
                stx firstKeyPressedInternal
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 122 (&7A) Keyboard scan from 16 decimal
;
; MasRef D.2-36
;
                .if version==350
clearTSTAndOSBYTE7A:
                jsr withTSTClear
                .endif
osbyte7A:
                ldx #$10
                clv
                sec
                bra callKEYV

;-------------------------------------------------------------------------

scanKeyboard:
                txa
                bpl LF923
                jsr interrogateKeyboard
enableKeyboardScanning:
                lda #8|3                     ;set latch B3 - auto scan mode
                sta systemVIA.orb            ;set auto scan mode
                txa
                rts

LF923:
                stx previousKeyPressedWhenReadingLastKey
                lda #$FF
                sta previousKeyPressedWhenReadingFirstKey
                ldx #$0C
                lda #$7F
                sta systemVIA.ddra
                lda #0|3            ;reset latch B3 - manual scan mode
                sta systemVIA.orb
loopKeyboardColumns:
                lda #$0F
                sta systemVIA.oraNoHandshake ;select a non-existent column
                lda #$01
                sta systemVIA.ifr            ;cancel keyboard interrupts
                stx systemVIA.oraNoHandshake ;select column
                bit systemVIA.ifr            ;any key in this column
                                             ;pressed?
                beq tryNextKeyboardColumn    ;taken if no key
                txa                          ;A = first key in column
loopKeyboardRows:
                clc
                adc #$10                     ;next row
                bmi tryNextKeyboardColumn    ;taken if done
                sta systemVIA.oraNoHandshake ;store key
                bit systemVIA.iraNoHandshake ;pressed?
                bpl loopKeyboardRows         ;taken if not
                cmp previousKeyPressedWhenReadingLastKey
                bcc loopKeyboardRows
                cmp previousKeyPressedWhenReadingFirstKey
                bcs loopKeyboardRows
                sta previousKeyPressedWhenReadingFirstKey
tryNextKeyboardColumn:
                dex
                bpl loopKeyboardColumns
                ldx previousKeyPressedWhenReadingFirstKey
                bra enableKeyboardScanning

scanKeyboardWithExclusion:
                ldx #$0c
LF96E:
                jsr enableKeyboardScanningFlippingInterrupts
                lda #$7F
                sta systemVIA.ddra
                lda #0|3
                sta systemVIA.orb
                lda #$0F
                sta systemVIA.oraNoHandshake ;select non-existent column
                lda #$01
                sta systemVIA.ifr            ;cancel keyboard interrupts
                stx systemVIA.oraNoHandshake
                bit systemVIA.ifr
                beq LF9AD
                txa
LF98E:
                clc
                adc #$10
                bmi LF9AD                    ;taken if done
                sta systemVIA.oraNoHandshake ;test key
                bit systemVIA.iraNoHandshake ;pressed?
                bpl LF98E                    ;taken if not
                pha                          ;save key number
LF99C:
                eor $0000,y                  ;compare to value
                asl a                        ;discard irrelevant bit 7
                cmp #$01                     ;C set if different
                pla                          ;restore key number
                bcc LF98E                    ;same key found - keep going
                tax
enableKeyboardScanningFlippingInterrupts:
                jsr enableKeyboardScanning
                cli
                sei
                txa
                rts

LF9AD:
                dex
                bpl LF96E
                bra enableKeyboardScanningFlippingInterrupts

;-------------------------------------------------------------------------

                .if version==400
                .include "sram_access_helpers_tube.s65"
                .endif

;-------------------------------------------------------------------------

                .if version>=500
                .include "insertCharacterIntoKeyboardBufferIfPossible.s65"
                .endif

;-------------------------------------------------------------------------

                ; Ugly condition...
                .if version>=500||(version==350&&!includeTubeSupport)
transferBetweenSidewaysRAMAndRAM: .block
                jsr selectROMA
transferBetweenSidewaysRAMAndRAMLoop:
                lda (sramTransferPointers.src),y
                sta (sramTransferPointers.dest),y
                iny
                bne LF85D
                inc sramTransferPointers.src+1
                inc sramTransferPointers.dest+1
                jsr selectTerminalROM
                jsr L8D0F
                jsr selectROMA
LF85D:
                cpy sramWorkspace.length+0
                bne transferBetweenSidewaysRAMAndRAMLoop
                lda 1,x
                cmp sramWorkspace.length+1
                bne transferBetweenSidewaysRAMAndRAMLoop
                jmp selectTerminalROM
                .endblock
                .endif

;-------------------------------------------------------------------------

                .if version>=400
                .include "sram_access_helpers_2.s65"
                .endif

;-------------------------------------------------------------------------

                .if version>=400
LF8B4:
                jsr selectROMX
                .if version==400
                lda #$80
                sta 1
                stz 0
                lda #0
                .else
                ldy #$80
                sty 1
                stz 0
                .endif
                tay
LF8BE:
                sta (0),y
                iny
                bne LF8BE
                inc 1
                bit 1
                bvc LF8BE
                dex
                cpx #4
                bcs LF8B4
                jmp selectTerminalROM
                .endif

;-------------------------------------------------------------------------

                .if version>=500
                .include "sram_access_helpers_3.s65"
                .endif

;-------------------------------------------------------------------------

                .if version>=400
selectTerminalROMAndOSBYTE44:
                jsr withTerminalROM
                jmp osbyte44
                .endif

;-------------------------------------------------------------------------

                .if version>=400
selectTerminalROMAndOSBYTE45:
                jsr withTerminalROM
                jmp osbyte45
                .endif

;-------------------------------------------------------------------------

                .if version>=400
selectTerminalROMAndOSWORD42:
                jsr withTerminalROM
                jmp osword42
                .endif

;-------------------------------------------------------------------------

                .if version>=400
selectTerminalROMAndOSWORD43:
                jsr withTerminalROM
                jmp osword43
                .endif

;-------------------------------------------------------------------------

                .if version==350
                .include "insertCharacterIntoKeyboardBufferIfPossible.s65"
                .endif

;-------------------------------------------------------------------------
;
; OSBPUT [AUG p339]
;
osbputEntryPoint:
                jsr selectFSForHandle
                jmp (BPUTV)

;-------------------------------------------------------------------------
;
; OSBGET [AUG p338]
;
osbgetEntryPoint:
                jsr selectFSForHandle
                jmp (BGETV)

;-------------------------------------------------------------------------
;
; OSGBPB [AUG p339]
;
osgbpbEntryPoint: .proc
                cmp #gbpbGetMediaMetadata
                bcs nonFileOperation
                cmp #$00
                beq nonFileOperation

                ; Handle OSGBPB call that's an operation on a file
                ; handle. Select the appropriate FS, given the file
                ; handle, and pass the request along.
                phy                          ;save OSGBPB Y
                pha                          ;save OSGBPB A
                stx osgbpbWorkspace.ptr+0
                sty osgbpbWorkspace.ptr+1
                lda (osgbpbWorkspace.ptr)    ;get file handle
                tay
                pla                          ;restore OSGBPB A
                jsr selectFSForHandle
passToCurrentFS:
                ply                          ;restore OSGBPB Y
                jmp (GBPBV)

;-------------------------------------------------------------------------
;
; Handle OSGBPB call that isn't an operation on a file handle. Select
; current FS and pass the request along.
;
nonFileOperation:
                phy
                phx
                pha
                jsr selectHAZEL
                lda hazel.currentFS
                jsr selectFS
                pla
                plx
                bra passToCurrentFS
                .endproc

;-------------------------------------------------------------------------
;
; OSARGS [AUG p337[
;
;
osargsEntryPoint: .proc
                cpy #$00
                bne fileOperation            ;taken if file operation
                cmp #$04
                bcs fileOperation ;taken if Y=0, A>=4 - honorary file operation
                pha
                jsr selectHAZEL
                pla
                bne notGetFS
getFS:
                ; OSARGS Y=0 A=0 - read current FS number
                lda hazel.currentFS
                rts

notGetFS:
                dec a
                bne notGetCommandLine
getCommandLine:
                ; OSARGS Y=0 A=1 - read command line tail address
                dec a                        ;A=$ff
                sta 2,x                    ;store full 32-bit address
                sta 3,x                    ;store full 32-bit address
                lda hazel.commandLinePointer+0
                sta 0,x                    ;
                lda hazel.commandLinePointer+1
                sta 1,x
                rts

notGetCommandLine:
                cmp #argsCheckANFS-1    ;-1 due to the dec a above
                beq rtsFA14            ; OSARGS Y=0 A=2 - Read OldNFS flag
getLibFS:
                lda hazel.libFS      ;OSARGS Y=0 A=3 - Read libfs filing system number
rtsFA14:
                rts

fileOperation:
                ; Operating on a file. Select appropriate FS first.
                jsr selectFSForHandle
                .endproc


;-------------------------------------------------------------------------
;
; Call current FS's OSARGS routine, bypassing the FileSwitch stuff.
;
callARGSV:                      ;fa18
                jmp (ARGSV)

;-------------------------------------------------------------------------
;
; OSFIND [AUG p342]
;
osfindEntryPoint: .proc
                ora #$00        ;A=$00 if a file is to be closed
                beq close       ;branch taken if closing a file
                jsr parseFileNameAndSelectFS       ;handle something other than a file close
                bra callFINDV

close:
                jsr selectFSForHandle
callFINDV:
                jmp (FINDV)
                .pend

;-------------------------------------------------------------------------
;
; OSFILE [AUG p335]
;
osfileEntryPoint:               ;fa2a
                phx
                phy
                pha
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                ldy #size(OSFILEParameterBlock)-1
-
                lda (stringInputBufferAddress),y
                sta osfileParameterBlock,y
                dey
                bpl -
                ldx osfileParameterBlock+OSFILEParameterBlock.fileName+0
                ldy osfileParameterBlock+OSFILEParameterBlock.fileName+1
                jsr parseFileNameAndSelectFS
                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
                pla
                ldx #<osfileParameterBlock
                ldy #>osfileParameterBlock
                jsr callFILEV
                ply
                sty stringInputBufferAddress+1
                plx
                stx stringInputBufferAddress+0
                pha
                ldy #size(OSFILEParameterBlock)-1
-
                lda osfileParameterBlock,y
                sta (stringInputBufferAddress),y
                dey
                cpy #$02                     ;don't overwrite file name
                bcs -
                pla
                ldx stringInputBufferAddress+0
                ldy stringInputBufferAddress+1
                rts

callFILEV:
                jmp (FILEV)

;-------------------------------------------------------------------------
;
; Parse file name. Handle (and skip) any -FS- tempfs syntax, selecting
; the FS specified if required.
;
; entry:
;
; Y (MSB)/X (LSB) = address of file name string
;
; exit:
;
; Y (MSB)/X (LSB) = address of file name part
;
; - New FS may have been selected
;
parseFileNameAndSelectFS:
                pha
                lda stringInputBufferAddress+0
                pha
                lda stringInputBufferAddress+1
                pha
                jsr selectHAZEL
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                ldy #$00
                jsr parseFileNameFS      ;find -FS- prefix, if any
                phy                      ;save offset
                jsr selectFS                 ;select desired FS
                pla
                clc
                adc stringInputBufferAddress+0
                tax                          ;save string address LSB
                ldy stringInputBufferAddress+1
                bcc +
                iny
+
                pla
                sta stringInputBufferAddress+1
                pla
                sta stringInputBufferAddress+0
                pla
                rts

;-------------------------------------------------------------------------
;
; Select appropriate FS for the given file handle.
;
; entry:
;
; Y = file handle
;
; exit:
;
; - appropriate FS selected
;
; preserves: Y/X/A

selectFSForHandle:
                phx
                pha
                jsr selectHAZEL
                jsr findFSForHandle
                txa
                jsr selectFS
                pla
                plx
                rts

;-------------------------------------------------------------------------
;
; Parse the FS part of a file name, if any, and return the filing
; system to use.
;
; Entry:
;
; (stringInputBufferAddress),y = the string
;
; Exit:
;
; A = FS number to use
;
; (stringInputBufferAddress),y = next char after any tempfs prefix has
; been consumed
parseFileNameFS: .proc

                lsr hazel.tempFSFlag
                jsr skipSpacesAndCheckForCRInStringInput
                lda (stringInputBufferAddress),y
                cmp #'-'
                beq parseFSNamePrefix ; branch taken if tempfs syntax
                bit hazel.tempFSFlag
                lda hazel.currentFS
                bvc +
                lda hazel.activeFS
+
                rts

parseFSNamePrefix:
                iny
                ldx #$00
LFAC1:
                lda hazel.fsInfoBlocks,x ;get FS name char
                beq badFilingSystemName
                txa                      ;A=offset in info blocks
                clc
                adc #size(fsInfoBlock.name)
                sta parseFileNameFSWorkspace.fsInfoOffset
                phy
compareFSNameLoop:
                lda (stringInputBufferAddress),y

; validate FS name char. Must be letter or digit.

                jsr isLetter
                bcc validFSNameChar           ;branch taken if letter
                cmp #'0'
                bcc notValidFSNameChar       ;branch taken if not digit
                cmp #'9'+1
                bcs notValidFSNameChar       ;branch taken if not digit
validFSNameChar:
                cpx parseFileNameFSWorkspace.fsInfoOffset
                bcs nextFSInfoBlock ;branch taken if end of FS
                                         ;info block name was reached
                eor hazel.fsInfoBlocks,x
                and #$DF                 ;Z=1 if char matches FS name
                bne nextFSInfoBlock      ;branch taken if not a match
                inx                      ;next fs info block byte
                iny                      ;next input string byte
                bra compareFSNameLoop

nextFSInfoBlock:
                ply
                ldx parseFileNameFSWorkspace.fsInfoOffset ;offset of end of name
                inx
                inx
                inx             ;advance to next entry
                bra LFAC1

notValidFSNameChar:

; Matching FS name must be terminated with -. Otherwise, it's bad
; syntax, or perhaps an overly long name.

                cmp #'-'
                bne badFilingSystemName
                iny                       ;consume input '-'
                cpx parseFileNameFSWorkspace.fsInfoOffset
                beq foundFSInfoBlock     ;branch taken if a match due
                                         ;to being right at end of the
                                         ;FS info block name
                lda hazel.fsInfoBlocks,x ;
                cmp #' '
                bne nextFSInfoBlock      ;branch taken if not a match
                                         ;as tthe supplied name was a
                                         ;prefix of this FS's name
foundFSInfoBlock:
                pla
                ldx parseFileNameFSWorkspace.fsInfoOffset
                lda hazel.fsInfoBlocks+(fsInfoBlock.fsNumber-(fsInfoBlock.name+size(fsInfoBlock.name))),x
                rts

badFilingSystemName:
                brk
                .text $f8,'Bad filing system name',0
                .pend

;-------------------------------------------------------------------------
;
; Find FS for the given handle
;
; entry:
;
; Y = file handle
;
; exit:
;
; X = FS number - will just use current FS if none suitable found
;
findFSForHandle: .proc
                pha                          ;
                phy                          ;
                tya                          ;A = handle to search for
                ldy #$00                     ;
loop:
                ldx hazel.fsInfoBlocks.name+0,y
                beq notFound                  ;taken if terminating entry
                cmp hazel.fsInfoBlocks.minHandle,y
                bcc next                     ;taken if not this FS
                cmp hazel.fsInfoBlocks.maxHandle,y
                bcc found                    ;taken if this FS
                beq found                    ;taken if this FS

next:
                pha
                tya
                clc
                adc #size(fsInfoBlock)
                tay
                pla
                bra loop

notFound:
                ldx hazel.currentFS
                bra done

found:
                ldx hazel.fsInfoBlocks.fsNumber,y
done:
                ply
                pla
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Select filing system in A.
;
; Entry:
;
; A = FS number
;
selectFS:                               ;fb4d
                cmp hazel.activeFS      ; Check active fs
                beq rtsFB68               ; Already active fs, return
                phy
                phx
                tay
                dec a
                bne LFB5F       ;taken if not FS 1 (tape)

; ??? - only if trying to select tape FS

                lda #$04
                bit $E2
                bne LFB5F
                iny
LFB5F:
                phy
                ldx #romServiceCallInitialiseFilingSystem
                jsr makeROMServiceCall
                pla
                plx
                ply
rtsFB68:
                rts

;-------------------------------------------------------------------------
;
; FileSwitch FSC
; ==============
;
fileswitchFSCEntryPoint:
                pha                          ;save request type
                jsr selectHAZEL
                lsr hazel.tempFSFlag
                pla                          ;restore request type
                pha                          ;save request type
                phx                          ;save request X
                asl a
                tax
                cmp #11*2+1
                bcs fileswitchPassFSCToCurrentFS ;taken if out of range
                jmp (fileswitchFSCRoutinesTable,x)

;-------------------------------------------------------------------------
;
; Pass to filing system's FSC
;
; There's 2 entry points - fileswitchPassFSCToCurrentFS, for
; when X and A are both on the stack, and
; fileswitchPassFSCToCurrentFS_X, for when only A is on the
; stack.
;
fileswitchPassFSCToCurrentFS:
fileswitchFSCNewFS:
fileswitchFSCFileHandleRange:
fileswitchFSCStarCommand:
                plx                          ;restore request X
fileswitchPassFSCToCurrentFS_X:
                pla                          ;restore request type
                jmp (hazel.activeFSCV) ;call active FS's real FSCV entry point

;-------------------------------------------------------------------------
;
; FileSwitch FSC table
;
fileswitchFSCRoutinesTable:
                .word fileswitchFSCOPT
                .word fileswitchFSCCheckEOF
                .word fileswitchFSCStarSlash
                .word fileswitchFSCUnknownCommand
                .word fileswitchFSCStarRUN
                .word fileswitchFSCStarCAT
                .word fileswitchFSCNewFS
                .word fileswitchFSCFileHandleRange
                .word fileswitchFSCStarCommand
                .word fileswitchFSCStarEX
                .word fileswitchFSCStarINFO
                .word fileswitchFSCRUNLibrary

;-------------------------------------------------------------------------
;
; FSC 3 - *command [AUG p344]
;
fileswitchFSCUnknownCommand:
                plx
                jsr getCommandLinePointer
                bra fileswitchPassFSCToCurrentFS_X

;-------------------------------------------------------------------------
;
; FSC 1 - check EOF [AUG p343]
;
fileswitchFSCCheckEOF:
                ply                         ;Y = file handle
                phy                         ;restore stack arrangement
                jsr selectFSForHandle
                bra fileswitchPassFSCToCurrentFS

;-------------------------------------------------------------------------
;
; FSC 0 - *OPT [AUG p343]
;
fileswitchFSCOPT:
                bit hazel.tempFSFlag   ; Check temporary fs flag
                bvs fileswitchPassFSCToCurrentFS
                lda hazel.currentFS ; Get current filing system number

;-------------------------------------------------------------------------
;
; Pass FSCV request through to a particular FS.
;
; entry:
;
; A = FS to select
;
; Y = FSCV Y
;
; S = [FSCV X; FSCV A]
;
fileswitchPassFSCToSpecificFS:
                jsr selectFS        ; Select filing system
                bra fileswitchPassFSCToCurrentFS

;-------------------------------------------------------------------------
;
; FSC 2 - */filename [AUG p343]
; FSC 4 - *RUN filename [AUG p344]
;
fileswitchFSCStarSlash:
fileswitchFSCStarRUN:
                plx
                jsr getCommandLinePointer ; Skip '*'s and spaces, set command line address
                phx             ; Continue on to pass to filing system


;-------------------------------------------------------------------------
;
; FSC 5 - *CAT [AUG p344]
; FSC 9 - *EX [NAUG p257]
; FSC, 10 - *INFO [NAUG p257]
;
fileswitchFSCStarCAT:
fileswitchFSCStarEX:
fileswitchFSCStarINFO:
                plx
                asl hazel.tempFSFlag
                jsr parseFileNameAndSelectFS
                bra fileswitchPassFSCToCurrentFS_X

;-------------------------------------------------------------------------
;
; Get command line pointer.
;
; Entry:
;
; X/Y - pointer to CR-terminated command line string
;
; Exit:
;
; X/Y, (hazel.commandLinePointer) - pointer to first non-space char in
; command line string
getCommandLinePointer: .proc ;fbc1
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1

; skip spaces. Stop if terminating CR encountered.

                ldy #$FF
-
                iny
                lda (stringInputBufferAddress),y
                cmp #$0D
                beq +
                cmp #' '
                bne -

+

; Hmm. Didn't we just do this bit already?

                jsr skipSpacesAndCheckForCRInStringInput

; Store address of first non-space char in the HAZEL command line
; pointer.

                tya
                clc
                adc stringInputBufferAddress+0
                sta hazel.commandLinePointer+0
                lda stringInputBufferAddress+1
                adc #$00
                sta hazel.commandLinePointer+1
                ldy stringInputBufferAddress+1
                ldx stringInputBufferAddress+0
                rts
                .pend

;-------------------------------------------------------------------------
;
; FSC 11 - RUN from libfs [NAUG p257]
;
fileswitchFSCRUNLibrary:
                lda hazel.libFS      ; Is a libfs set?
                bpl fileswitchPassFSCToSpecificFS
badCommandError:
                brk
                .byte 254
                .text "Bad command"
                brk

;-------------------------------------------------------------------------

                .if version==350
                .if includeTubeSupport
                .include "sram_access_helpers_tube.s65"
                .endif
                .include "sram_access_helpers_2.s65"
                .include "sram_access_helpers_3.s65"
                .endif

;-------------------------------------------------------------------------
;
; Tube 6502 language ROM relocation
;

                .if version==350&&includeTubeSupport

relocateNextLanguageROMPage: .block
                
                .if fasterTubeRelocation

                stz tubeLanguageHostAddr+0
                
                ldx tubeRelocationPageOffset
                beq transferVerbatim

transferRelocated:

                lda tubeRelocationBitmapByte

                jsr tubeHost.zeroPageCode.transferRelocatedPageLoop

                sta tubeRelocationBitmapByte

pageTransferred:
                inc tubeLanguageHostAddr+1
                rts

transferVerbatim:
                ldy #0
transferVerbatimLoop:
                lda (tubeLanguageHostAddr),y ; +5 = 10
                nop                          ; +2 = 12
                nop                          ; +2 = 14
                nop                          ; +2 = 16
                sta tube.data3               ; +4 = 20
                iny                          ; +2 = 2
                bne transferVerbatimLoop     ; +3 = 5
                bra pageTransferred

                .else
                
                ldy #0
                sty tubeLanguageHostAddr+0
loop:
                lda (tubeLanguageHostAddr),y ; fetch byte from language ROM
                ldx tubeRelocationPageOffset
                beq gotByte                  ; taken if not relocating
                .if finmos329
                cmp #$80
                .else
                ; Presumably somebody found at least one ROMs that
                ; does lda $7fff,X (or similar), and so references to
                ; page $7f also need accounting for.
                cmp #$7F
                .endif
                bcc gotByte ; taken if not potentially-relocatable byte
                cmp #$C0
                bcs gotByte ; taken if not potentially-relocatable byte

                pha
                jsr fetchTubeRelocationBitmapBit
                pla
                bcc gotByte ; taken if byte isn't actually to be relocated
                clc
                adc tubeRelocationPageOffset
                
gotByte:
                sta tubeRelocationBuffer,y
                iny
                bne loop
                .forcew inc,tubeLanguageHostAddr+1
                rts

                .endif
                
                .endblock

;-------------------------------------------------------------------------

checkForTubeRelocationBitmap:
                .forcew sta,tubeLanguageParasiteAddr+3 ; parasite address bits 24-31
                .forcew sty,tubeLanguageParasiteAddr+2 ; parasite address bits 16-23
                bit $f4
                bvs setTubeLanguageParasiteAddr00008000 ; taken if don't-relocate bit set
                lda sidewaysROMType
                and #~%0010&$0f              ; Z=1 if 6502 code
                bne noTubeRelocationBitmap                    ; taken if not 6502 code
                .forcew lda,tubeLanguageParasiteAddr+3 ; parasite address bits 24-31
                .forcew sta,tubeRelocationBitmapPtr+1
                .forcew ora,tubeLanguageParasiteAddr+2 ; parasite address bits 16-31
                beq noTubeRelocationBitmap     ; taken if parasite address is $0000xxxx
                .forcew lda,tubeLanguageParasiteAddr+2
                .forcew sta,tubeRelocationBitmapPtr+0
                ; (2) is address of bitmap descriptor table
                ldy #2
                lda (tubeRelocationBitmapPtr),y ; get bitmap ROM number
                tax                          ; X = bitmap ROM number
                dey                          
                lda (tubeRelocationBitmapPtr),y ; get pointer to byte after bitmap, MSB
                tay            ; Y = pointer to byte after bitmap, MSB
                lda (tubeRelocationBitmapPtr) ; get pointer to byte after bitmap, LSB
                ; (tubeRelocationBitmapPtr) = pointer to byte after bitmap
                .forcew sta,tubeRelocationBitmapPtr+0
                .forcew sty,tubeRelocationBitmapPtr+1
                .forcew lda,tubeLanguageParasiteAddr+1
                sec
                sbc #$80 ; $80 is of course the base page for a language ROM
                sta tubeRelocationPageOffset
                .forcew stz,tubeLanguageParasiteAddr+3
                .forcew stz,tubeLanguageParasiteAddr+2
                txa                     ; A = bitmap ROM number
                bpl gotRelocationBitmapROMBank ; taken if absolute ROM number
                clc
                adc $f4     ; form ROM number from relative ROM number
gotRelocationBitmapROMBank:
                and #$F                      ; ROM numbers are 4 bits
                sta tubeRelocationBitmapROMBank ; store ROM number containing relocation bitmap
                ldx $f4
                phx
                jsr selectROMA          ; select ROM containing bitmap
                jsr fetchTubeRelocationBitmapByte ; fetch hopefully $DE
                eor #$DE                  ; check for $CODE identifier
                bne invalidTubeRelocationBitmap                 ; taken if $CODE not found
                jsr fetchTubeRelocationBitmapByte ;fetch hopefully $C0
                eor #$C0                  ; check for $CODE identifier
                bne invalidTubeRelocationBitmap ; taken if $CODE not found
                sta tubeRelocationBitmapByte    ; A=0
                jsr fetchTubeRelocationBitmapByte ; fetch bitmap size MSB
                sta tubeRelocationBitmapSizeBytes+1
                jsr fetchTubeRelocationBitmapByte ; fetch bitmap size LSB
                sta tubeRelocationBitmapSizeBytes+0
                pla
                jsr selectROMA
                rts

;-------------------------------------------------------------------------

invalidTubeRelocationBitmap:
                pla
                jsr selectROMA
                .if correctlyHandleMissingTubeRelocationBitmap
                .cerror *!=setTubeLanguageParasiteAddr00008000
                .else
                bra noTubeRelocationBitmap
                .endif

;-------------------------------------------------------------------------

setTubeLanguageParasiteAddr00008000:
                lda #$80
                .forcew sta,tubeLanguageParasiteAddr+1
                .forcew stz,tubeLanguageParasiteAddr+0
                .forcew stz,tubeLanguageParasiteAddr+2
                .forcew stz,tubeLanguageParasiteAddr+3
noTubeRelocationBitmap:
                stz tubeRelocationPageOffset
                rts

;-------------------------------------------------------------------------

fetchTubeRelocationBitmapByte: .block
                .if fasterTubeRelocation
                sec
                lda tubeRelocationBitmapPtr+0
                sbc #1
                sta tubeRelocationBitmapPtr+0
                bcs +
                dec tubeRelocationBitmapPtr+1
                .else
                ; decrement (2)
                .forcew lda,tubeRelocationBitmapPtr+0
                php
                .forcew dec,tubeRelocationBitmapPtr+0
                plp
                bne +
                .forcew dec,tubeRelocationBitmapPtr+1
                .endif
+
                
                .if fasterTubeRelocation
                ldx $f4
                lda tubeRelocationBitmapROMBank
                sta $f4
                sta ROMSEL
                lda (tubeRelocationBitmapPtr)
                stx $f4
                stx ROMSEL
                .else
                lda $f4
                pha
                lda tubeRelocationBitmapROMBank ; get ROM number containing relocation bitmap
                jsr selectROMA ; select ROM containing relocation bitmap
                lda (tubeRelocationBitmapPtr)        ; get bitmap byte
                tax            ; X = bitmap byte
                pla            ; 
                jsr selectROMA ; restore old ROM
                txa            ; A = bitmap byte
                .endif
                rts
                .endblock

;-------------------------------------------------------------------------

                .if !fasterTubeRelocation
fetchTubeRelocationBitmapBit: .block
                asl tubeRelocationBitmapByte ; put next bit in carry, possibly the terminator
                bne +                        ; taken if bit was valid
                ; the bit shifted out was the terminator, so fetch
                ; next one.
                jsr fetchTubeRelocationBitmapByte2 ; fetch next byte
                clc                         ; report bit clear
                beq +                       ; taken if end of table??
                ; fetch next bit into carry, and set shifted-in bit 0
                ; by way of terminator.
                sec
                rol tubeRelocationBitmapByte
+
                rts
                .endblock
                .endif

;-------------------------------------------------------------------------
;
; Terrible naming...
;
                .if !fasterTubeRelocation
fetchTubeRelocationBitmapByte2: .block
                jsr fetchTubeRelocationBitmapByte ; fetch next byte from bitmap
                sta tubeRelocationBitmapByte      ; store it

                ; decrement (tubeRelocationBitmapSizeBytes)
                lda tubeRelocationBitmapSizeBytes+0
                php
                dec tubeRelocationBitmapSizeBytes+0
                plp
                bne +
                dec tubeRelocationBitmapSizeBytes+1
+
                ; Set Z if the remaining size went negative.
                
                lda tubeRelocationBitmapSizeBytes+1 ; N=1 if run out
                eor #$80                            ; N=0 if run out
                and #$80                            ; Z=1 if run out
                rts
                .endblock
                .endif

;-------------------------------------------------------------------------

osbyte8EWithoutRelocation:
                txa
                ora #$40                  ; set the don't-relocate bit
                tax
                lda #$8E                     ; enter language ROM
                jmp OSBYTE

;-------------------------------------------------------------------------

getLanguageParasiteAddrAndAssumeRelocatable:
                jsr tubeHost.getLanguageParasiteAddr
                lda #$40
                trb $f4                 ; clear the don't-relocate bit
                rts

;-------------------------------------------------------------------------

                .endif
                
                .if version==350&&!finmos329

LFB0A:       .block
                php
                sei
                lda econetInterceptionStatus
                pha
                lda #$80        ; ''
                trb econetInterceptionStatus
                lda #$87        ; ''
                jsr OSBYTE
                pla
                sta econetInterceptionStatus
                plp
                txa
                rts
                .endblock

;-------------------------------------------------------------------------

                .if CFA3000
LFB2F:
                ldx #size(RTC.ram)-1
LFB31:
                phx
                ldy #0
                cpx #size(CMOSBytes)
                bcs LFB3B
                ldy reset.LFEA2-1,x
LFB3B:
                jsr writeCMOSByte
                plx
                dex
                bne LFB31
                rts
                .endif

                .endif

;-------------------------------------------------------------------------

mosUnusedBegin:
                .fill $fc00-*,$ff
mosUnusedSize=*-mosUnusedBegin

                .if version==350

;-------------------------------------------------------------------------
;
; Some init code - normally hidden by the I/O region

reset: .block
                .include "reset.s65"
foundTube:
continueSoftReset:
                jmp softResetPart2
                .endblock

;-------------------------------------------------------------------------

clearAllSoundChannelBuffers: .block
                ldx #8
loop:
                dex
                jsr clearSoundChannelBuffer
                cpx #4
                bne loop
                rts
                .endblock

                .fill $ff00-*

;-------------------------------------------------------------------------

                .else

;-------------------------------------------------------------------------
;
; Credits - normally hidden by the I/O region.
;

                .if version<500
                .text "(C) 1984 Acorn Computers Ltd."
                .text "Thanks are due to the following contributors to the BBC Computer (among others too numerous to mention):- "
                .elsif version>=500
                .if olivetti
                .text "(C) 1986 Olivetti."
                .else
                .text "(C) 1986 Acorn Computers Ltd."
                .endif
                .text "Thanks are due to the following contributors to this Computer (among many others):- "
                .endif
                .text "David Allen,"
                .if version<500
                .text "Clive Angel,"
                .endif
                .text "David Bell,"
                .text "Paul Bond,"
                .if version<500
                .text "Allen Boothroyd,"
                .endif
                .text "Julian Brown,"
                .text "Tudor Brown,"
                .if version>=500
                .text "Tim Caspell,"
                .endif
                .text "Brian Cockburn,"
                .if version>=500
                .text "Barbara Cole,"
                .endif
                .if version<500
                .text "Pete Cockerell,"
                .endif
                .text "Mark Colton,"
                .text "Chris Curry,"
                .if version>=500
                .text "Jim Day,"
                .text "Tim Dobson,"
                .endif
                .text "Joe Dunn,"
                .if version==400
                .text "Wendy Frazer,"
                .endif
                .if version<500
                .text "Paul Freakley,"
                .endif
                .if version>=500
                .text "Paul Fellows,"
                .text "Alan Fournier,"
                .endif
                .text "Steve Furber,"
                .text "Martyn Gilbert,"
                .text "John Harrison,"
                .text "Hermann Hauser,"
                .if version!=400
                .text "Mike Hill,"
                .endif
                .if version>=500
                .text "Paul Holding,"
                .endif
                .text "John Horton,"
                .if version==400
                .text "Richard Hughes,"
                .endif
                .if version>=500
                .text "Dave Ireland,"
                .endif
                .if version<500
                .text "Neil Johnson,"
                .endif
                .text "Richard King,"
                .text "David Kitson,"
                .if version>=500
                .text "Andy Knight,"
                .endif
                .text "Julian Lomberg,"
                .text "Rob Macmillan,"
                .if version>=500
                .text "Tom McNamara,"
                .endif
                .text "Richard Manby,"
                .if version<500
                .text "Peter McKenna,"
                .text "Andrew McKernan,"
                .if version==400
                .text "Mick Neal,"
                .else
                .text "Mick Neil,"
                .endif
                .text "Ian Niblock,"
                .endif
                .if version>=500
                .text "David Morgan,"
                .text "Richard Murphy,"
                .endif
                .text "Glen Nicholls,"
                .text "Robert Nokes,"
                .if version>=500
                .text "Jean Nunn,"
                .endif
                .text "Richard Page,"
                .if version<400
                .text "Steve Parsons,"
                .endif
                .if version<=400
                .text "Ed Phipps,"
                .endif
                .text "John Radcliffe,"
                .text "Rick Rand,"
                .if version>=400
                .text "Nick Reeves,"
                .endif
                .text "Brian Robertson,"
                .if version>=500
                .text "Paul Rose,"
                .endif
                .text "Richard Russell,"
                .if version<500
                .text "Gordon Sage,"
                .text "Terry Scotcher,"
                .endif
                .if version>=500
                .text "Robert Sack,"
                .text "Roger Sale,"
                .endif
                .text "David Seal,"
                .if version>=500
                .text "Phil Smith,"
                .text "Tony Sumner,"
                .endif
                .if version!=400
                .text "Paul Swindell,"
                .endif
                .text "Jon Thackray,"
                .if version>=500
                .text "Tony Thompson,"
                .endif
                .text "Hugo Tyson,"
                .if version<500
                .text "Adrian Warner,"
                .if version==400
                .text "Jes Wills,"
                .else
                .text "Jess Wills,"
                .endif
                .endif
                .if version<500
                .text "Roger Wilson,"
                .text "Graham Winterflood."
                ;.text "   "
                .endif
                .if version>=500
                .text "Roger Wilson."
                .endif
                .if version!=400
                .if olivetti
                .align 256,$ff
                .else
                .align 256,' '
                .endif
                .else
                .align 256
                .endif

;-------------------------------------------------------------------------

                .endif

;-------------------------------------------------------------------------

E_USERV: ; ff00
                jsr extendedVectorEntryPoint
E_BRKV: ; ff03
                jsr extendedVectorEntryPoint
E_IRQ1V: ; ff06
                jsr extendedVectorEntryPoint
E_IRQ2V: ; ff09
                jsr extendedVectorEntryPoint
E_CLIV: ; ff0c
                jsr extendedVectorEntryPoint
E_BYTEV: ; ff0f
                jsr extendedVectorEntryPoint
E_WORDV: ; ff12
                jsr extendedVectorEntryPoint
E_WRCHV: ; ff15
                jsr extendedVectorEntryPoint
E_RDCHV: ; ff18
                jsr extendedVectorEntryPoint
E_FILEV: ; ff1b
                jsr extendedVectorEntryPoint
E_ARGSV: ; ff1e
                jsr extendedVectorEntryPoint
E_BGETV: ; ff21
                jsr extendedVectorEntryPoint
E_BPUTV: ; ff24
                jsr extendedVectorEntryPoint
E_GBPBV: ; ff27
                jsr extendedVectorEntryPoint
E_FINDV: ; ff2a
                jsr extendedVectorEntryPoint
E_FSCV: ; ff2d
                jsr extendedVectorEntryPoint
E_EVENTV: ; ff30
                jsr extendedVectorEntryPoint
E_UPTV: ; ff33
                jsr extendedVectorEntryPoint
E_NETV: ; ff36
                jsr extendedVectorEntryPoint
E_VDUV: ; ff39
                jsr extendedVectorEntryPoint
E_KEYV: ; ff3c
                jsr extendedVectorEntryPoint
E_INSV: ; ff3f
                jsr extendedVectorEntryPoint
E_REMV: ; ff42
                jsr extendedVectorEntryPoint
E_CNPV: ; ff45
                jsr extendedVectorEntryPoint
E_IND1V: ; ff48
                jsr extendedVectorEntryPoint
E_IND2V: ; ff4b
                jsr extendedVectorEntryPoint
E_IND3V: ; ff4e
                jsr extendedVectorEntryPoint

;-------------------------------------------------------------------------

extendedVectorEntryPoint:
                ; .if CFA3000
                ; ;...
                ; .else
                ; $10b,x = rL
                pha                 ; $10a,x  (old ROMSEL)
                pha                 ; $109,x  (old ACCCON)
                pha                 ; $108,x  (thunk rH)
                pha                 ; $107,x  (thunk rL)
                pha                 ; $106,x  (jump dest MSB)
                pha                 ; $105,x  (jump dest LSB)
                php                 ; $104,x  (P for RTI)
                pha                 ; $103,x  (old A)
                phx                 ; $102,x  (old X)
                phy                 ; $101,x  (old Y)
                tsx
                lda #>extendedVectorReturnThunk-1
                sta $0108,x
                lda #<extendedVectorReturnThunk-1
                sta $0107,x

                ; this routine is only ever called from $ff00, $ff03,
                ; $ff06, etc. - so rL holds vectorIndex*3+2, suitable
                ; for indexing into the extended vector space.
                ldy $010B,x                  ;Y=vectorIndex*3+2
                lda extendedVectorSpace-2,y  ;get vector LSB
                sta $0105,x                  ;
                lda extendedVectorSpace-1,y  ;get vector MSB
                sta $0106,x
                lda $F4
                sta $010A,x
                lda ACCCON
                sta $0109,x

                ; New stack layout:
                ;
                ; $10a,x - old ROMSEL
                ; $109,x - old ACCCON
                ; $108,x - thunk rH
                ; $107,x - thunk rL
                ; $106,x - jump dest MSB
                ; $105,x - jump dest LSB
                ; $104,x - P (for RTI)
                ; $103,x - old A
                ; $102,x - old X
                ; $101,x - old Y

                jsr selectHAZEL
                lda extendedVectorSpace,y    ;get vector ROM number
                jsr selectROMA
                ply
                plx
                pla
                rti
;                .endif

;-------------------------------------------------------------------------

extendedVectorReturnThunk:
                php
                pha
                phx
                tsx
                lda $0102,x
                sta $0106,x
                lda $0103,x
                sta $0107,x
                plx
                pla
                pla
                pla
                jsr selectMOSOrHAZEL
                pla
                jsr selectROMA
                pla
                plp
rtsFFAA:
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 150 (&96) Read from SHEILA (&FE00 - &FEFF) [MasRef D.2-45]
;
osbyte96:
                ldy $fe00,x
                rts

;-------------------------------------------------------------------------
;
; OSBYTE 157 (&9D) Write byte across Tube [MasRef D.2-48]
;
osbyte9D:
                txa
                bra OSBPUT

                brk

;-------------------------------------------------------------------------
OSWRSC:
                jmp oswrscEntryPoint ; FFB3
                .byte defaultVectorTable.end-defaultVectorTable ;
                .word defaultVectorTable ;
OSRDSC:
                jmp osrdscEntryPoint ; FFB9
VDUCHR:
                jmp vduChrEntryPoint ; FFBC
OSEVEN:
                jmp eventEntryPoint ; FFBF
GSINIT:
                jmp gsinitEntryPoint ; FFC2
GSREAD:
                jmp gsreadEntryPoint ; FFC5
NVRDCH:
                jmp osrdchEntryPoint                    ; FFC8
NVWRCH:
                jmp oswrchEntryPoint                    ; FFCB
OSFIND:
                jmp osfindEntryPoint                    ; FFCE
OSGBPB:
                jmp osgbpbEntryPoint                    ; FFD1
OSBPUT:
                jmp osbputEntryPoint                    ; FFD4
OSBGET:
                jmp osbgetEntryPoint                    ; FFD7
OSARGS:
                jmp osargsEntryPoint ; FFDA
OSFILE:
                jmp osfileEntryPoint ; FFDD
OSRDCH:
                jmp (RDCHV)                  ; FFE0
OSASCI:
                cmp #$0D                     ; FFE3
                bne OSWRCH                   ; FFE5
OSNEWL:
                lda #$0A                     ; FFE7
                jsr OSWRCH                   ; FFE9
                lda #$0D                     ; FFEC
OSWRCH:
                jmp (WRCHV)                  ; FFEE
OSWORD:
                jmp (WORDV)                  ; FFF1
OSBYTE:
                jmp (BYTEV)                  ; FFF4
OSCLI:
                jmp (CLIV)                  ; FFF7

LFFFA:                                       ; FFFA NMIV
                .word nmiEntryPoint
LFFFC:                                       ; FFFB RESETV
                .word resetEntryPoint
LFFFE:                                       ; FFFE IRQV
                .word irqEntryPoint
                