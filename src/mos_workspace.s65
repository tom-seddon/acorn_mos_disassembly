
;-------------------------------------------------------------------------
;
; Disorganized jumble of constants. They'll get tidied up at some
; point... promise...
; 
;-------------------------------------------------------------------------

; These variant flags are applicable to the stated versions only, and
; may or may not be separable from the various .if/.endif constructs
; for that version. If they're changed from these defaults for any
; other version, the output may not make sense.

                .weak
                ; Set if building Olivetti MOS, a variant of 5.10.
olivetti=false

                ; Set if building CFA3000 MOS, a variant of 3.50.
CFA3000=false

                ; Set if building Autocue 1500 MOS, a variant of 5.11.
autocue=false

                ; Set if building MOS 3.29 (Acorn FinMOS), a variant
                ; of 3.50.
finmos329=false

                ; Clear if stripping out the terminal ROM. Applicable
                ; to 3.20 or 3.50.
includeTerminalROM=true
                .endweak
                
;-------------------------------------------------------------------------


tubeHostAddr=$400

                .if version==350
                ; MOS 3.50 parasite language relocation workspace?
tubeRelocationBitmapPtr=2
tubeRelocationBitmapSizeBytes=$4f5
tubeRelocationBitmapByte=$4f7
tubeRelocationBitmapROMBank=$04f8
tubeRelocationPageOffset=$04f9

                ; 256-byte region where 1 relocated page of language
                ; ROM is held ready for host->parasite pagewise
                ; transfer.
tubeRelocationBuffer=$700
                .endif
                
;-------------------------------------------------------------------------

osargsBuffer=$a8                ;4-byte ZP buffer for use with OSARGS
printMessageAddress=$b8

                .virtual $bb
tapeCurrentOptionsByte: .block
                .endblock
                .endvirtual

                .virtual $f2
fsStatusByte: .block
inputFileOpen=$01
outputFileOpen=$02
catStatus=$08
eofReached=$40
eofWarningGiven=$80
                .endblock
                .endvirtual
                
                .virtual $e4
stringInputOptions: .block
doubleQuotes=$80
spaceNotATerminator=$40
goodString=$01
                .endblock
                .endvirtual
stringInputPlingFlag=$e5        ;bit 7 set if last char was '!'
readCharacterTimedFlag=$e6
autoRepeatCountdownTimer=$e7
tapeCritical=$eb
lastKeyPressedInternal=$ec
firstKeyPressedInternal=$ed
stringInputBufferAddress=$f2    ;word
                
;-------------------------------------------------------------------------

romServiceCallAbsoluteWorkspaceClaim=$01 ; memory used only when ROM is paged in
romServiceCallPrivateWorkspaceClaim=$02 ; memory used even when ROM is not paged in
romServiceCallAutoBoot=$03              ;
romServiceCallUnrecognisedCommand=$04   ; star command not recognised
romServiceCallUnrecognisedInterrupt=$05 ;
romServiceCallBreakInstruction=$06      ;
romServiceCallUnrecognisedOSBYTE=$07    ;
romServiceCallUnrecognisedOSWORD=$08    ;
romServiceCallHelp=$09                  ;
romServiceCallClaimStaticWorkspace=$0A ; (Issued by paged ROMs, not the OS)
romServiceCallNMIRelease=$0B    ; (Issued by paged ROMs, not the OS)
romServiceCallNMIClaim=$0C      ; (Issued by paged ROMs, not the OS)
romServiceCallROMFilingSystemInitialize=$0D    ;
romServiceCallROMFilingSystemByteGet=$0E    ;
romServiceCallVectorsClaimed=$0F    ; Used when a filing system starts
romServiceCallSpoolExecClosureWarning=$10    ;
;romServiceCallFontImplosionExplosionWarning=$11    ;
romServiceCallInitialiseFilingSystem=$12    ; (Issued from paged ROMs, not the OS)
romServiceCallPollingInterrupt=$15
romServiceCallReserved=$18
romServiceCallAbsoluteHAZELWorkspaceClaim=$21
romServiceCallPrivateHAZELWorkspaceClam=$22
romServiceCallTopOfHAZELWorkspace=$23
romServiceCallCountDynamicHAZELWorkspace=$24
romServiceCallRequestFSInfo=$25
romServiceCallCloseAllOpenFiles=$26
romServiceCallInformReset=$27
romServiceCallUnknownCONFIG=$28
romServiceCallUnknownSTATUS=$29
romServiceCallLanguageChange=$2a
romServiceCall30=$30
romServiceCallTubeSystemPostInitialisation=$FE    ;
romServiceCallTubeMainInitialisation=$FF    ;

;-------------------------------------------------------------------------

; [MasRef D.2-24]
                
eventOutputBufferEmpty=0
eventInputBufferFull=1
eventCharacterEnteringBuffer=2
eventADCConversionComplete=3
eventStartOfVerticalSync=4
eventIntervalTimerCrossingZero=5
eventESCAPEPressed=6
eventRS423Error=7
eventNetworkError=8
eventUser=9
eventMax=9

;-------------------------------------------------------------------------

; [MasRef D.2-27]

; Input buffers
bufferKeyboard=0
bufferRS423Input=1

; Output buffers                
bufferFirstOutput=2
bufferRS423Output=2
bufferPrinter=3
bufferSoundChannel0=4
bufferSoundChannel1=5
bufferSoundChannel2=6
bufferSoundChannel3=7
; What's buffer 8? Previously speech on OS 1.20. There's indices
; allocated for it...
bufferMax=8

                
bufferKeyboardAddress=$03e0
bufferKeyboardSize=32
bufferRS423InputAddress=$0a00
bufferRS423InputSize=256
bufferRS423OutputAddress=$0900
bufferRS423OutputSize=192
bufferPrinterAddress=$0880
bufferPrinterSize=64
bufferSoundChannel0Address=$0840
bufferSoundChannel0Size=16
bufferSoundChannel1Address=$0850
bufferSoundChannel1Size=16
bufferSoundChannel2Address=$0860
bufferSoundChannel2Size=16
bufferSoundChannel3Address=$0870
bufferSoundChannel3Size=16
buffer8Address=$09c0
buffer8Size=64


                
; BufferInfo: .function bufferAddress,bufferSizeByte
;                 .endfunction (bufferAddress,256-bufferSizeByte)
                
; ; buffer info is (base address,size)
;  _:=[]
; _..=[BufferInfo($0300,32)];bufferKeyboard=0
; _..=[BufferInfo($0a00,256)];bufferRS423Input=1
; _..=[BufferInfo($08c0,192)];bufferRS423Output=2
; _..=[BufferInfo($07c0,64)];bufferPrinter=3
; _..=[BufferInfo($0750,16)];bufferSoundChannel0=4
; _..=[BufferInfo($0760,16)];bufferSoundChannel1=5
; _..=[BufferInfo($0770,16)];bufferSoundChannel2=6
; _..=[BufferInfo($0780,16)];bufferSoundChannel3=7
; _..=[BufferInfo($0900,64)];What's buffer 8?
                
;-------------------------------------------------------------------------

; [MasRef C.5-5]

printerDriverTypeSink=0
printerDriverTypeParallel=1
printerDriverTypeSerial=2
printerDriverTypeUser=3
printerDriverTypeNetwork=4

; AUG p259

printerDriverPoll=0
printerDriverActivate=1
printerDriverVDU2=2
printerDriverVDU3=3
printerDriverFX5=5

printerDriverFX3=10             ;undocumented???
                
;-------------------------------------------------------------------------

; AUG p261

netPrinterRequest0=0
netPrinterRequest1=1
netPrinterRequest2=2
netPrinterRequest3=3
netWriteCharacterAttempted=4
netPrinterRequest5=5
netReadCharacterAttempted=6
netOSBYTEAttempted=7
netOSWORDAttempted=8
netOSWORD0Complete=13
                
;-------------------------------------------------------------------------

fscOPT=0
fscCheckEOF=1
fscStarSlash=2
fscUnknownCommand=3
fscStarRUN=4
fscStarCAT=5
fscNewFS=6
fscFileHandleRange=7
fscStarCommand=8
fscStarEX=9
fscStarINFO=10
fscRUNLibrary=11

; NAUG mentions this. But it doesn't appear to
; actually exist in the code.
;
; Maybe it's present in MOS 3.50 or later?
fscRENAME=12

gbpbPutBytesNewPTR=1            ;[AUG p340]
gbppPutBytesCurrentPTR=2        ;[AUG p340]
gbpbGetBytesNewPTR=3            ;[AUG p341]
gbpbGetBytesCurrentPTR=4        ;[AUG p341]
gbpbGetMediaMetadata=5          ;[AUG p341]
gbpbGetCurrentDevice=6          ;[AUG p341]
gbpbGetLibraryDevice=7          ;[AUG p341]
gbpbReadFileNames=8             ;[AUG p341]

OSGBPBParameterBlock: .struct
handle:
                .fill 1
address:
                .fill 4
count:
                .fill 4
ptr:
                .fill 4
                .endstruct                
                
argsGetFS=0                     ;[AUG p337]
argsGetCommandLine=1            ;[AUG p338]
argsCheckANFS=2                 ;https://beebwiki.mdfs.net/OSARGS
argsGetLibFS=3                  ;
argsFlushBuffers=$ff            ;[AUG p338]

argsFileGetPTR=0
argsFileSetPTR=1
argsFileGetEXT=2
argsFileFlush=$ff

fileSave=0                      ;[AUG p336]
fileWriteMetadata=1             ;[AUG p336]
fileWriteLoadAddress=2          ;[AUG p336]
fileWriteExecAddress=3          ;[AUG p336]
fileWritettributes=4            ;[AUG p336]
fileReadMetadata=5              ;[AUG p336]
fileDelete=6                    ;[AUG p336]
fileLoad=$ff                    ;[AUG p336]

OSFILEParameterBlock: .struct
fileName:
                .fill 2
addresses:
load:
                .fill 4
exec:
                .fill 4
length:
saveStart:
                .fill 4
attributes:
saveEnd:
                .fill 4
                .endstruct

;-------------------------------------------------------------------------

bufferNumberKeyboard=0          ;
bufferNumberRS423Input=1        ;
bufferNumberRS423Output=2       ;
bufferNumberPrinter=3           ;
bufferNumberSound0=4            ; Noise channel
bufferNumberSound1=5            ;
bufferNumberSound2=6            ;
bufferNumberSound3=7            ;
; bufferNumberSpeech=8            ;
bufferNumberHighest=8           ;

;-------------------------------------------------------------------------

; uservIndex=0
; brkvIndex=1
; irq1vIndex=2
; irq2vIndex=3
; clivIndex=4
; bytevIndex=5
; wordvIndex=6
; wrchvIndex=7
; rdchvIndex=8
; filevIndex=9
; argsvIndex=10
; bgetvIndex=11
; bputvIndex=12
; gbpbvIndex=13
; findvIndex=14
; fscvIndex=15
; eventvIndex=16
; uptvIndex=17
; netvIndex=18
; vduvIndex=19
; keyvIndex=20
; insvIndex=21
; remvIndex=22
; cnpvIndex=23
; ind1vIndex=24
; ind2vIndex=25
; ind3vIndex=26

              
                .virtual $200
vectors:
USERV:
                .fill 2
BRKV:
                .fill 2
IRQ1V:
                .fill 2
IRQ2V:
                .fill 2
CLIV:
                .fill 2
BYTEV:
                .fill 2
WORDV:
                .fill 2
WRCHV:
                .fill 2
RDCHV:
                .fill 2
FILEV:
                .fill 2
ARGSV:
                .fill 2
BGETV:
                .fill 2
BPUTV:
                .fill 2
GBPBV:
                .fill 2
FINDV:
                .fill 2
FSCV:
                .fill 2
EVENTV:
                .fill 2
UPTV:
                .fill 2
NETV:
                .fill 2
VDUV:
                .fill 2
KEYV:
                .fill 2
INSV:
                .fill 2
REMV:
                .fill 2
CNPV:
                .fill 2
IND1V:
                .fill 2
IND2V:
                .fill 2
IND3V:
                .fill 2
mosVariables:

; OSBYTE 166 (&A6) Read start address of MOS variables [MasRef D.2-50]
; OSBYTE 167 (&A7) Read start address of MOS variablespointer table  [MasRef D.2-50]
mosVariablesAddress: .fill 2

; OSBYTE 168 (&A8) Read address of ROM pointer table [MasRef D.2-51]
; OSBYTE 169 (&A9) Read address of ROM pointer table [MasRef D.2-51]
extendedVectorSpaceAddress: .fill 2

; OSBYTE 170 (&AA) Read address of ROM information table [MasRef D.2-51]
; OSBYTE 171 (&AB) Read address of ROM information table [MasRef D.2-51]
romInformationTableAddress: .fill 2

; OSBYTE 172 (&AC) Read address of keyboard translation table [MasRef D.2-52]
; OSBYTE 173 (&AD) Read address of keyboard translation table [MasRef D.2-52]
keyboardTranslationTableAddress: .fill 2

; OSBYTE 174 (&AE) Read address of VDU variables origin [MasRef D.2-52]
; OSBYTE 175 (&AF) Read address of VDU variables origin [MasRef D.2-52]
vduVariablesAddress: .fill 2

; OSBYTE 176 (&B0) Read/Write CFS timeout counter [MasRef D.2-52]
cfsTimeoutCounter: .fill 1

; OSBYTE 177 (&B1) Read/write input source [MasRef D.2-53]
inputSource: .fill 1

; OSBYTE 178 (&B2) Read/write keyboard semaphore [MasRef D.2-53]
keyboardSemaphore: .fill 1

; OSBYTE 179 (&B3) Read/write ROM polling semaphore [MasRef D.2-54]
romPollingSemaphore: .fill 1

; OSBYTE 180 (&B4) Read/write Operating System High [MasRef D.2-54]
oshwm: .fill 1

; OSBYTE 181 (&B5) Read/write RS243 input interpretation [MasRef D.2-54]
rs423InputInterpretationStatus: .fill 1

; OSBYTE 182 (&B6) Read NOIGNORE state [MasRef D.2-55]
;
; TODO - not a great name, no matter how official - should probably be usePrinterIgnoreChar or something
noignoreState: .fill 1

; OSBYTE 183 (&B7) Read/write cassette/ROM filing system [MasRef D.2-55]
cfsRFSFSSwitch: .fill 1

; OSBYTE 184 (&B8) Read OS copy of video ULA control [MasRef D.2-56]
vcontrolRegister: .fill 1

; OSBYTE 185 (&B9) Read OS copy of video ULA palette [MasRef D.2-56]
vpaletteRegister: .fill 1

; OSBYTE 186 (&BA) Read ROM number active at last BRK [MasRef D.2-56]
romActiveAtLastBRK: .fill 1

; OSBYTE 187 (&BB) Read ROM number of socket [MasRef D.2-57]
basicROMNumber: .fill 1

; OSBYTE 188 (&BC) Read current ADC channel number [MasRef D.2-57]
currentADCChannel: .fill 1

; OSBYTE 189 (&BD) Read maximum ADC channel number [MasRef D.2-57]
maximumADCChannel: .fill 1

; OSBYTE 190 (&BE) Read/write ADC conversion type [MasRef D.2-58]
adcConversionType: .fill 1

; OSBYTE 191 (&BF) Read/write RS423 busy flag [MasRef D.2-58]
rs423Busy: .fill 1

; OSBYTE 192 (&C0) Read serial ACIA control register [MasRef D.2-58]
aciaControlRegister: .fill 1

; OSBYTE 193 (&C1) Read/write flash counter [MasRef D.2-59]
flashCounter: .fill 1

; OSBYTE 194 (&C2) Read/write duration of first colour [MasRef D.2-59]
firstFlashColourDuration: .fill 1

; OSBYTE 195 (&C3) Read/write duration of second colour [MasRef D.2-60]
secondFlashColourDuration: .fill 1

; OSBYTE 196 (&C4) Read/write keyboard auto-repeat delay [MasRef D.2-60]
keyboardAutoRepeatDelay: .fill 1

; OSBYTE 197 (&C5) Read/write keyboard auto-repeat rate [MasRef D.2-60]
keyboardAutoRepeatRate: .fill 1

; OSBYTE 198 (&C6) Read/write *EXEC file handle [MasRef D.2-61]
execFileHandle: .fill 1

; OSBYTE 199 (&C7) Read/write *SPOOL file handle [MasRef D.2-62]
spoolFileHandle: .fill 1

; OSBYTE 200 (&C8) Read/write BREAK and ESCAPE effect [MasRef D.2-62]
breakAndESCAPEEffect: .fill 1

; OSBYTE 201 (&C9) Read/write keyboard status [MasRef D.2-63]
keyboardStatus: .fill 1

; OSBYTE 202 (&CA) Read/write keyboard status byte [MasRef D.2-63]
keyboardStatusByte: .block
shiftPressed=%1<<3
capsLockDisengaged=%1<<4
shiftLockDisengaged=%1<<5
ctrlPressed=%1<<6
shiftEnabled=%1<<7
                .fill 1
                .endblock

; OSBYTE 203 (&CB) Read/write RS423 input buffer [MasRef D.2-64]
rs423InputBufferMinimumSpace: .fill 1

; OSBYTE 204 (&CC) Read/write RS423 ignore flag [MasRef D.2-65]
rs423Ignore: .fill 1

; OSBYTE 205 (&CD) Read/write RS423 destination [MasRef D.2-65]
rs423Destination: .fill 1

; OSBYTE 206 (&CE) Read/write Econet OS call interception [MasRef D.2-66]
econetInterceptionStatus: .fill 1

; OSBYTE 207 (&CF) Read/write Econet input interpretation [MasRef D.2-66]
econetInputInterpretationStatus: .fill 1

; OSBYTE 208 (&D0) Read write Econet output [MasRef D.2-67]
econetOutputInterpretationStatus: .fill 1

; OSBYTE 209 (&D1) is reserved for the speech system [MasRef D.2-67]
speechSystemByte1:  .fill 1

; OSBYTE 210 (&D2) Read/write sound suppression status [MasRef D.2-67]
soundSuppressionStatus: .fill 1

; OSBYTE 211 (&D3) Read/write BELL channel [MasRef D.2-67]
bellChannel: .fill 1

; OSBYTE 212 (&D4) Read/write BELL sound information [MasRef D.2-68]
bellSound: .fill 1

; OSBYTE 213 (&D5) Read/write BELL frequency [MasRef D.2-69]
bellFrequency: .fill 1

; OSBYTE 214 (&D6) Read/write BELL duration [MasRef D.2-69]
bellDuration: .fill 1

; OSBYTE 215 (&D7) Read/write startup message [MasRef D.2-69]
startupMessageSuppressionStatus: .fill 1

; OSBYTE 216 (&D8) Read/write length of soft key string [MasRef D.2-70]
softKeyStringLength: .fill 1

; OSBYTE 217 (&D9) Read/write paged mode line count [MasRef D.2-71]
pagedModeCounter: .fill 1

; OSBYTE 218 (&DA) Read/write bytes in VDU queue [MasRef D.2-71]
vduQueueNegativeLength: .fill 1

; OSBYTE 219 (&DB) Read/write TAB key code [MasRef D.2-72]
tabKeyCode: .fill 1

; OSBYTE 220 (&DC) Read/write ESCAPE character [MasRef D.2-72]
escapeCharacter: .fill 1

; OSBYTE 221 (&DD) Read/write interpretation of input values 192-207 [MasRef D.2-73]
input192To207Interpretation: .fill 1

; OSBYTE 222 (&DE) Read/write interpretation of input values 208-223 [MasRef D.2-73]
input208To223Interpretation: .fill 1

; OSBYTE 223 (&DF) Read/write interpretation of input values 224-239 [MasRef D.2-73]
input224To239Interpretation: .fill 1

; OSBYTE 224 (&E0) Read/write interpretation of input values 240-255 [MasRef D.2-73]
input240To255Interpretation: .fill 1

; OSBYTE 225 (&E1) Read/write soft key interpretation [MasRef D.2-74]
softKeyInterpretation: .fill 1

; OSBYTE 226 (&E2) Read/write SHIFT+soft key interpretation [MasRef D.2-74]
shiftSoftKeyInterpretation: .fill 1

; OSBYTE 227 (&E3) Read/write CTRL+soft key interpretation [MasRef D.2-74]
ctrlSoftKeyInterpretation: .fill 1

; OSBYTE 228 (&E4) Read/write SHIFT+CTRL+soft key interpretation [MasRef D.2-74]
shiftCtrlSoftKeyInterpretation: .fill 1

; OSBYTE 229 (&E5) Read/write ESCAPE key status [MasRef D.2-75]
escapeKeyStatus: .fill 1

; OSBYTE 230 (&E6) Read/write ESCAPE effects [MasRef D.2-75]
escapeEffects: .fill 1

; OSBYTE 231 (&E7) Read/write IRQ bit mask for user 6522 [MasRef D.2-76]
userVIAInterruptMask: .fill 1

; OSBYTE 232 (&E8) Read/write IRQ bit mask for 6850 [MasRef D.2-76]
rs423InterruptMask: .fill 1

; OSBYTE 233 (&E9) Read write IRQ bit mask for system [MasRef D.2-76]
systemVIAInterruptMask: .fill 1

; OSBYTE 234 (&EA) Read flag indicating Tube presence [MasRef D.2-76]
tubePresence: .fill 1

; OSBYTE 235 (&EB) is reserved for the speech system. [MasRef D.2-77]
speechSystemByte2: .fill 1

; OSBYTE 236 (&EC) Read/write character destination status [MasRef D.2-77]
characterDestinationStatus: .block
                .fill 1
rs423_enable=1
vdu_disable=2
printer_disable=4               ;printer always off
printer_enable=8                ;printer always on
spool_disable=16
printer_maybe=64                ;printer on when VDU 1 only
                .endblock

; OSBYTE 237 (&ED) Read/write cursor editing status [MasRef D.2-77]
editKeysMode: .block
editKeys=0                      ;edit keys do editing
asciiKeys=1                     ;edit keys are ASCII 135-139
functionKeys=2                  ;edit keys are F keys 11-15
                .fill 1
                .endblock

; OSBYTE 238 (&EE) Read/write numeric keypad [MasRef D.2-78]
numericKeypadInterpretation: .fill 1

; OSBYTE 239 (&EF) Read/write *SHADOW state [MasRef D.2-78]
shadowRAMState: .fill 1

; OSBYTE 240 (&F0) Read country flag [MasRef D.2-79]
countryFlag: .fill 1

; OSBYTE 241 (&F1) Read/write user flag [MasRef D.2-79]
userFlag: .fill 1

; OSBYTE 242 (&F2) Read copy of serial processor ULA [MasRef D.2-80]
serialULARegister: .fill 1

; OSBYTE 243 (&F3) Read timer switch state [MasRef D.2-80]
;
; The location holds either 5 (initialTimerSwitchState) or 10
; (initialTimerSwitchState^15) - i.e., the offset of the byte after
; the last of the timer.
;
; Various offsets are applied to the timer addresses to make this
; work.
timerSwitchState: .fill 1

; OSBYTE 244 (&F4) Read/write soft key consistency flag [MasRef D.2-81]
softKeyConsistencyFlag: .fill 1

; OSBYTE 245 (&F5) Read printer driver type [MasRef D.2-81[
printerDriverType: .fill 1

; OSBYTE 246 (&F6) Read/write printer ignore character [MasRef D.2-81]
printerIgnoreChar: .fill 1

; OSBYTE 247 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
breakVectorByte0: .fill 1

; OSBYTE 248 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
breakVectorByte1: .fill 1

; OSBYTE 249 (&F7) Read/write BREAK intercept vector [MasRef D.2-82]
breakVectorByte2: .fill 1

; OSBYTE 250 (&FA) Read memory written by VDU driver [MasRef D.2-82]
vduDriverMemory: .fill 1

; OSBYTE 251 (&FB) Read memory displayed [MasRef D.2-83]
displayMemory: .fill 1

; OSBYTE 252 (&FC) Read/write current language ROM number [MasRef D.2-83]
currentLanguageROM: .fill 1
                
; OSBYTE 253 (&FD) Read last BREAK type [MasRef D.2-83]
lastBREAKType: .block
                .fill 1
softBREAK=0
powerOn=1
hardBREAK=2
                .endblock
; OSBYTE 254 (&FE) Set effect of SHIFT on numeric keypad [MasRef D.2-84]
numericKeypadShiftEffect: .fill 1
; OSBYTE 255 (&FF) Read/write startup options [MasRef D.2-84]
startupOptions: .fill 1
modeMask=7
                
                .endvirtual

firstMOSVariableOSBYTE=166
                
initialTimerSwitchState=5
tvOffset=$290
tvInterlace=$291
timer0=$292
timer1=$297
intervalTimer=$29c
romInformationTable=$2a1
inkeyTimeoutCounter=$2b1
osword0MaxLineLength=$2b3
osword0MinASCIICharacter=$2b4
osword0MaxASCIICharacter=$2b5
adcResultLSBs=$2b6
adcResultMSBs=$2ba
adcLastChannelRead=$2be         ;Two names for the same thing!
adcLastConvertedChannel=$2be    ;Two names for the same thing!
eventEnabledFlags=$2bf
currentSoftKey=$02c9
keyboardFirstAutoRepeatCount=$02ca
previousKeyPressedWhenReadingLastKey=$2cb
previousKeyPressedWhenReadingFirstKey=$2cc
previousKeyPressedWhenReadingOSBYTE=$2cd
; soundIsUpdatingFlag=$2ce
bufferEmptyFlags=$2ce
bufferStartIndices=$2d7
bufferEndIndices=$2e0

tapeInputCurrentBlockSize=$2e9
blockFlagOfCurrentlyResidentBlock=$2eb
lastCharacterOfCurrentlyResidentBlock=$2ec

; Probably needs a better name :(
;
; Used by various file routines to store OSGBPB and OSFILE parameter
; blocks.
;
; Used by the clock routines to hold a (possibly partial) mirror of
; the RTC time/date registers.
;
; Used when parsing hex addresses from the command line - obviously
; designed primarily for convenient use when building up the OSFILE
; parameter block for use with *LOAD and *SAVE.
osfileParameterBlock=$2ed
                
; rtcTempData=$2ee

ExtendedVectorAddress: .function vectorAddress
                .cerror !(vectorAddress>=USERV && vectorAddress<=IND3V && vectorAddress%2==0),"invalid vector"
                .endfunction extendedVectorSpace+(vectorAddress-vectors)/2*3
                
;-------------------------------------------------------------------------

extendedVectorSpace=$d9f

key_space=$62
key_comma=$66
key_minus=$17
key_stop=$67
key_slash=$68
key_0=$27
key_1=$30
key_2=$31
key_3=$11
key_4=$12
key_5=$13
key_6=$34
key_7=$24
key_8=$15
key_9=$26
key_colon=$48
key_semicolon=$57
key_at=$47
key_a=$41
key_b=$64
key_c=$52
key_d=$32
key_e=$22
key_f=$43
key_g=$53
key_h=$54
key_i=$25
key_j=$45
key_k=$46
key_l=$56
key_m=$65
key_n=$55
key_o=$36
key_p=$37
key_q=$10
key_r=$33
key_s=$51
key_t=$23
key_u=$35
key_v=$63
key_w=$21
key_x=$42
key_y=$44
key_z=$61
key_left_square_bracket=$38
key_backslash=$78
key_right_square_bracket=$58
key_caret=$18
key_underline=$28
key_escape=$70
key_tab=$60
key_caps_lock=$40
key_ctrl=$1
key_shift_lock=$50
key_shift=$0
key_delete=$59
key_copy=$69
key_return=$49
key_up=$39
key_down=$29
key_left=$19
key_right=$79
key_f0=$20
key_f1=$71
key_f2=$72
key_f3=$73
key_f4=$14
key_f5=$74
key_f6=$75
key_f7=$16
key_f8=$76
key_f9=$77
key_numpad_0=$6a
key_numpad_1=$6b
key_numpad_2=$7c
key_numpad_3=$6c
key_numpad_4=$7a
key_numpad_5=$7b
key_numpad_6=$1a
key_numpad_7=$1b
key_numpad_8=$2a
key_numpad_9=$2b
key_numpad_plus=$3a
key_numpad_minus=$3b
key_numpad_divide=$4a
key_numpad_hash=$5a
key_numpad_multiply=$5b
key_numpad_comma=$5c
key_numpad_return=$3c
key_numpad_delete=$4b
key_numpad_stop=$4c

fsInfoBlock: .struct
name: .fill 8
minHandle: .fill 1
maxHandle: .fill 1
fsNumber: .fill 1
                .ends

osgbpbBlock: .struct
handle: .fill 1
addr: .fill 4
numBytes: .fill 4
ptr: .fill 4
                .ends

                ; NAUG p260
                .virtual $dc00
hazel: .block
commandLine:                    ;dc00
                .fill 256
ddxx:                           ;dd00
                .fill 256
dexx:
                .fill 256
currentFS:                      ;df00
                .fill 1
activeFS:                       ;df01
                .fill 1
libFS:                          ;df02
                .fill 1
currentFSROM:                   ;df03
                .fill 1
commandLinePointer:             ;df04
                .fill 2

                ; 17 info blocks in total, but everything is relative
                ; to the 0th, so there's only a need to instantiate a
                ; struct for that one. Don't think 64tass handles
                ; arrays of structs anyway.
fsInfoBlocks:   .dstruct fsInfoBlock ;df06
                .fill 16*size(fsInfoBlock)
fsInfoBlocksTerminator:         ;dfc1
                ; space reserved for the 0 terminator when the full
                ; set of info blocks are filled.
                .fill 1
fsFlags: .block                 ;dfc2
                .fill 1
useASCII=$80
isAPPEND=$80
noLineNumbers=$40
                .bend
lineNumberBCD:                  ;dfc3
                .fill 2
lastCharPrinted:                ;dfc5
                .fill 1
tempFSFlag:                     ;dfc6
                .fill 1
moveOSGBPB: .dstruct osgbpbBlock ;dfc7
moveSrcHandle:                  ;dfd4
                .fill 1
moveDestHandle:                 ;dfd5
                .fill 1
moveBufferMSB:                  ;dfd6
                .fill 1
moveNumPages:                   ;dfd7
                .fill 1
moveDestName:                   ;dfd8
                .fill 2
activeFSCV:                     ;dfda
                .fill 2
oldACCCON:                      ;dfdc
                .fill 1
hasACCCONChanged:                ;dfdd
                .fill 1
dfde:
                .fill 1
                .bend
                .endv

;-------------------------------------------------------------------------
;
; VDU variables
; 
; MasRef E.4-1
;
VDUVariables: .struct
graphicsWindow:
;graphicsWindowLeftBottom:
; &00 2 Graphics window left column. (p)
graphicsWindowPixelsLeft: .fill 2
; &02 2 Graphics window bottom row. (p)
graphicsWindowPixelsBottom: .fill 2
;graphicsWindowRightTop:
; &04 2 Graphics window right column. (p)
graphicsWindowPixelsRight: .fill 2
; &06 2 Graphics window top row. (p)
graphicsWindowPixelsTop: .fill 2
textWindow:
; &08 1 Text window left column.
textWindowLeft: .fill 1
; &09 1 Text window bottom row.
textWindowBottom: .fill 1
; &0A 1 Text window right column.
textWindowRight: .fill 1
; &0B 1 Text window top row.
textWindowTop: .fill 1
; &0C 2 Graphics origin X coordinate. (e)
graphicsWindowOriginX: .fill 2
; &0E 2 Graphics origin Y coordinate. (e)
graphicsWindowOriginY: .fill 2
; &10 2 Graphics cursor X coordinate. (e)
graphicsCursorPositionX: .fill 2
; &12 2 Graphics cursor Y coordinate. (e)
graphicsCursorPositionY: .fill 2
; &14 2 Previous graphics cursor X coordinate. (p)
oldGraphicsCursorPixels:
oldGraphicsCursorPixelsX: .fill 2
; &16 2 Previous graphics cursor Y coordinate. (p)
oldGraphicsCursorPixelsY: .fill 2
; &18 1 Text cursor X coordinate (from left of screen) when not cursor editing. When cursor editing, normally the input cursor X coordinate, but the output cursor X coordinate within an “unknown PLOT codes” routine.
textCursorXPosition: .fill 1
; &19 1 Text cursor Y coordinate (from top of screen) when not cursor editing. When cursor editing, normally t.lsthe input cursor Y coordinate, but the output cursor Y coordinate within an “unknown PLOT codes” routine.
textCursorYPosition: .fill 1
; &1A 1 Y produced by GADDR (see next section) so that (ZMEMG),Y addresses the correct byte.
graphicsAddressOffset: .fill 1
; &1B–&23 VDU queue: &23 contains last byte of queue, other bytes immediately precede it.
queueSize=9
queueBegin: .fill queueSize
queueEnd:
graphicsCursorPixels:
; &24 2 Graphics cursor X coordinate. (p)
graphicsCursorPixelsX: .fill 2
; &26 2 Graphics cursor Y coordinate. (p)
graphicsCursorPixelsY: .fill 2
; &28–&49 Workspace. But variable &38 must not be used in a Teletext mode (mode 7 or 135).
                .union
ew: .dstruct EllipseWorkspaceVDUVariables
hlfw: .dstruct HorizontalLineFillWorkspaceVDUVariables
mocr: .dstruct MoveOrCopyRectangleWorkspaceVDUVariables
workspace: .dstruct GenericWorkspaceVDUVariables
                .endunion
; &4A 2 Address at which the 6845 is to display the text cursor.
textCursorCRTCAddress: .fill 2
; &4C 2 Number of bytes in a character row of the text window.
textWindowWidthInBytes: .fill 2
; &4E 1 Most significant byte of address of first byte of screen memory.
startScreenAddressHighByte: .fill 1
; &4F 1 Number of bytes in a character.
bytesPerCharacter: .fill 1
; &50 2 Address of byte in top left corner of screen display.
screenTopLeftAddress: .fill 2
; &52 2 Number of bytes in a character row of the whole screen.
bytesPerCharacterRow: .fill 2
; &54 1 Most significant byte of number of bytes of screen memory.
screenSizeHighByte: .fill 1
; &55 1 Current screen mode (in range 0–7, i.e. without regard to ‘shadowing’).
currentScreenMODE: .fill 1
; &56 1 Memory mode: 0 for 20K modes, 1 for 16K modes, 2 for 10K modes, 3 for 8K modes, 4 for 1K modes.
currentScreenMODEGroup: .fill 1
; &57 1 Foreground text colour mask.
foregroundTextColour: .fill 1
; &58 1 Background text colour mask.
backgroundTextColour: .fill 1
; &59 1 0 if plotting graphics foreground, 8 if plotting graphics background.
graphicsPlotState: .fill 1
; &5A 1 Current graphics plot mode (usually set to one of following two reduced mod 16).
graphicsPlotMode: .fill 1
; &5B 1 Current graphics foreground plot mode (as set by VDU 18).
foregroundGCOLMode: .fill 1
; &5C 1 Current graphics background plot mode (as set by VDU 18).
backgroundGCOLMode: .fill 1
; &5D 2 Address of routine to process current VDU sequence.
jumpVector: .fill 2
; &5F 1 Value for 6845 register 10 to revert to on leaving cursor editing.
lastCursorStartRegisterValue: .fill 1
; &60 1 (Number of logical colours)−1 (0 if Teletext).
numberOfLogicalColoursMinusOne: .fill 1
; &61 1 (Number of pixels/byte)−1 (0 if not graphics).
pixelsPerByteMinusOne: .fill 1
; &62 1 Mask for leftmost pixel in a byte.
colourMaskLeft: .fill 1
; &63 1 Mask for rightmost pixel in a byte.
colourMaskRight: .fill 1
; &64 1 Output cursor X coordinate when cursor editing, but input cursor X coordinate when cursor editing and inside an ‘unknown PLOT codes’ routine.
editCursorXPosition: .fill 1
; &65 1 Output cursor Y coordinate when cursor editing, but input cursor Y coordinate when cursor editing and inside an ‘unknown PLOT codes’ routine.
editCursorYPosition: .fill 1
; &66 1 Cursor control flags (as set by VDU 23 16).
cursorFlags: .block
                .fill 1
; MasRef E.3-18
noSpecialVDU5Actions=$40
noMoveCursorAfterPrint=$20
noVerticalScroll=$10
swapAxes=$08                    ;if set, X=vert; if clear, X=horiz
invertVertical=$04              ;if set, vert=up; if clear, vert=down
invertHorizontal=$02            ;if set, horiz=left; if clear, horiz=right
scrollProtect=$01
                .endblock
; &67 1 Dot pattern (as set by VDU 23 6).
dotPattern: .fill 1
; &68 1 Current state of dot pattern.
dotPatternState: .fill 1
; &69 1 0 if colour being plotted is solid, non-zero if colour is an ECF
isColourECF: .fill 1
; &6A 1 0 if graphics foreground colour is solid, non-zero if foreground colour is an ECF
isForegroundECF: .fill 1
; &6B 1 0 if graphics background colour is solid, non-zero if background colour is an ECF
isBackgroundECF: .fill 1
; &6C 1 Top bit set when cursor is in "column 81".
column81: .fill 1
; &6D 1 Current graphics foreground colour (as set by VDU 18).
foregroundGraphicsColour: .fill 1
; &6E 1 Current graphics background colour (as set by VDU 18)
backgroundGraphicsColour: .fill 1
; &6F–&7E Software copy of the current palette.
currentPalette: .fill 16
; &7F 1 Reserved.
reserved: .fill 1
                .endstruct

                .virtual $300
vduv: .dstruct VDUVariables
                .endvirtual

; vduQueueItemAddr: .function index
;                 .cerror index<0||index>=vdu.queueSize,"bad VDU queue index"
;                 .endfunction vdu.queue+vdu.queueSize-1-index
                
; Presumed addresses in ANDY that don't happen to coincide with other
; labels.
; 
; MasRef E.4-5, MasRef F.6-10
;
; &8000-83FF  RAM  Soft key expansions buffer
; &8400–87FF  RAM  VDU workspace.
; &8800–07    RAM  ECF pattern 1 definition.
; &8808–0F    RAM  ECF pattern 2 definition.
; &8810–17    RAM  ECF pattern 3 definition.
; &8818–1F    RAM  ECF pattern 4 definition.
; &8820–27    RAM  Current foreground ECF pattern or solid colour.
; &8828–2F    RAM  Current background ECF pattern or solid colour.
; &8830–BF    RAM  VDU workspace.
; &88C0–FF    RAM  Reserved for future expansion.
; &8900–FF    RAM  Current definitions of characters &20–3F.
; &8A00–FF    RAM  Current definitions of characters &40–5F.
; &8B00–FF    RAM  Current definitions of characters &60–7F.
; &8C00–FF    RAM  Current definitions of characters &80–9F.
; &8D00–FF    RAM  Current definitions of characters &A0–BF.
; &8E00–FF    RAM  Current definitions of characters &C0–DF.
; &8F00–FF    RAM  Current definitions of characters &E0–FF.

VDUCoordinate: .struct
x: .fill 2
y: .fill 2
                .endstruct

VDUAABB: .struct
min: .dstruct VDUCoordinate
max: .dstruct VDUCoordinate
                .endstruct
                
GenericWorkspaceVDUVariables: .struct
_28:
                .fill 1
_29:
                .fill 1
_2A:
                .fill 1
_2B:
                .fill 1
_2C:
                .fill 1
_2D:
                .fill 1
_2E:
                .fill 1
_2F:
                .fill 1
_30:
                .fill 1
_31:
                .fill 1
_32:
                .fill 1
_33:
                .fill 1
_34:
                .fill 1
_35:
                .fill 1
_36:
                .fill 1
_37:
                .fill 1
_38:
                .fill 1
_39:
                .fill 1
_3A:
                .fill 1
_3B:
                .fill 1
_3C:
                .fill 1
_3D:
                .fill 1
_3E:
                .fill 1
_3F:
                .fill 1
_40:
                .fill 1
_41:
                .fill 1
_42:
                .fill 1
_43:
                .fill 1
_44:
                .fill 1
_45:
                .fill 1
_46:
                .fill 1
_47:
                .fill 1
_48:
                .fill 1
_49:
                .fill 1
                .endstruct

EllipseWorkspaceVDUVariables: .struct
                ; https://tobylobster.github.io/GXR-pages/gxr/S-s3.html#SP4
aspectRatio:
                .fill 3
shear:
                .fill 3
halfHeightCounter:
                .fill 2
halfHeightSquared:
                .fill 4
pointC:
                .fill 2
pointD:
                .fill 2
leftPoint:
                .fill 2
rightPoint:
                .fill 2
pointA:
                .fill 2
pointB:
                .fill 2
pointE:
                .fill 2
currentOffsetX:
                .fill 2
plotPointX:
pointF:
                .fill 2
plotPointY:
                .fill 2
                .endstruct
                
HorizontalLineFillWorkspaceZP: .struct
notByteMatch: .fill 1
a: .fill 1
b: .fill 2
;c: .fill 2
pixelsX: .fill 2
d: .fill 1
resultEOR: .fill 1
                .endstruct

MoveOrCopyRectangleWorkspaceVDUVariables: .struct
src: .dstruct VDUAABB
                .fill 4
dest: .dstruct VDUAABB
                .fill 9
copy:
                .fill 1         ;0=move, 2=copy
                .endstruct
                
HorizontalLineFillWorkspaceVDUVariables: .struct
                .fill 6
pixelsX:                        ;2e
                .fill 2
pixelsY:                        ;30
                .fill 2
pixelsRightEndX:
                .fill 2         ;32
pixelsLimitX:                   ;34
                .fill 2
                .endstruct
                
HorizontalLineFillWorkspaceANDY: .struct
ecfPattern: .fill 8
                .endstruct

softKeyCount=16
softKeyDataTotalSize=$400
                
                .virtual $8000
andy: .block
softKeys: .block
stringLSBs: .fill softKeyCount
endLSB: .fill 1
stringMSBs: .fill softKeyCount
endMSB: .fill 1
strings:
                .fill softKeys+$400-*
end:
                .endblock
                .fill $8800-*;(softKeyCount*2+1)
ecfPatterns:
ecfPattern1: .fill 8
ecfPattern2: .fill 8
ecfPattern3: .fill 8
ecfPattern4: .fill 8
currentECFPatterns:
fgECFPattern: .fill 8
bgECFPattern: .fill 8
workspace:
                .union
hlfw: .dstruct HorizontalLineFillWorkspaceANDY
                .fill 208
                .endunion
softCharacterDefinitions:
                .fill (256-32)*8
                .cerror (<andy.softCharacterDefinitions)!=0,"Soft character definitions must be page aligned"
                .cerror *!=$9000,"ANDY is the wrong size"
                .endblock
                .endvirtual
                
                
L8000=$8000
L8001=$8001
L8002=$8002
L8004=$8004
L8010=$8010
L8011=$8011
L8012=$8012
                ;l8011=$8011
                ;l8012=$8012
L8021=$8021

; see $d40d, $d4ae
;
; (suspect these are actually references to $8840-$104 and $8848-$104)
L873C=$873c
L8744=$8744
                
L8400=$8400
L8500=$8500
L8600=$8600
L8700=$8700
L87F8=$87f8
L87FF=$87FF
L8800=$8800
L8803=$8803
L8804=$8804
L881E=$881E
L8820=$8820
L8830=$8830
L8831=$8831
L8832=$8832
L8833=$8833
L8834=$8834
L8835=$8835
L8836=$8836
L8837=$8837
L8838=$8838
L8839=$8839
L883A=$883a
L883B=$883b
L883C=$883C
L883D=$883D
L883E=$883e
L883F=$883f
L8840=$8840
L8841=$8841
L8842=$8842
L8843=$8843
L8844=$8844
L8845=$8845
L8846=$8846
L8847=$8847
L8848=$8848
L8849=$8849
L884A=$884a
L884B=$884b
L884C=$884c
ellipseCountHeight=$884d

                ; written to during startup
LFE8E=$fe8e

;-------------------------------------------------------------------------

                .virtual $00
                .union
tubeOSFILEParameterBlock: .dstruct OSFILEParameterBlock
tubeOSGBPBParameterBlock: .dstruct OSGBPBParameterBlock
tubeLanguageHostAddr: .fill 2
                .endunion
tubeTransferAddr: .fill 2
tubeNotClaimed: .fill 1            ;bit 7 clear if tube claimed
tubeClaimantID: .fill 1
tubeBrkHandlerAddr:
                ; Tube BRK handler sits here.
                .endv

tubeStringBuffer=$700
tubeOSWORDBuffer=$0128
                
;-------------------------------------------------------------------------

                .virtual $53
tubeLanguageParasiteAddr: .fill 4
                .endv

; MasRef E.4-4
                .virtual $d0
STATE: .block
                .fill 1
                ; D.2-32
isPrinterEnabled=$01
isScrollingDisabled=$02
isPagedScrolling=$04
isTextWindow=$08
isShadowMode=$10
isVDU5=$20
isCursorEditing=$40
isVDU21=$80
                .bend

ZMASK: .fill 1                       ;Pixel mask
ZORA: .fill 1                        ;Text OR mask
ZEOR: .fill 1                        ;Text EOR mask
ZGORA: .fill 1                       ;Graphics OR mask
ZGEOR: .fill 1                       ;Graphics EOR mask
ZMEMG: .fill 2                       ;Graphics pointer
ZMEMT: .fill 2                       ;Text pointer
ZTEMP: .fill 2                       ;Temporary space
ZTEMPB: .fill 2                      ;Temporary space
ZTEMPC: .fill 2                      ;Temporary space
ZTEMPD: .fill 2                      ;Temporary space
                .endv

                .virtual ZTEMP
zhlfw: .dstruct HorizontalLineFillWorkspaceZP
                .endv

                
softKeyExpansionPtr=$f8       ;pointer to current char when expanding soft key.
SEIWKA=$fa
SEIWKB=$fb

vduWriteCursor=$d8     

nmiEntryPoint=$d00

gcolModeOverwrite=0
gcolModeOR=1
gcolModeAND=2
gcolModeEOR=3
gcolModeInvert=4
gcolModeLeave=5

;-------------------------------------------------------------------------

StarKEYWorkspace: .struct
newStringLength: .fill 1
destPtr: .fill 2
srcPtr: .fill 2
counter: .fill 2
                .endstruct

OSGBPBWorkspace: .struct
ptr: .fill 2
                .endstruct

ParseFileNameFSWorkspace: .struct
fsInfoOffset: .fill 1
                .endstruct

OSCLIWorkspace: .struct
tablePtr: .fill 2
                .endstruct

                ; TODO - could do being renamed, as it's used (in the
                ; same way) by *UNPLUG and *INSERT.
StarROMSWorkspace: .struct
insertedFlagMask: .fill 1
                .endstruct

TerminalHELPWorkspace: .struct
tablePtr: .fill 2
                .endstruct

                ; TODO - tediously verbose names. Acronyms work well
                ; enough for the VDU variables. Do the same thing
                ; here.
                .virtual $b0
                .union
starKEYWorkspace: .dstruct StarKEYWorkspace
osgbpbWorkspace: .dstruct OSGBPBWorkspace
parseFileNameFSWorkspace: .dstruct ParseFileNameFSWorkspace
oscliWorkspace: .dstruct OSCLIWorkspace
starROMSWorkspace: .dstruct StarROMSWorkspace
terminalHELPWorkspace: .dstruct TerminalHELPWorkspace
                .endunion
                .endvirtual

;-------------------------------------------------------------------------

; ROM number containing Terminal
terminalROM=15

; ROM number containing the extXXXX entry points
                .if !includeTerminalROM
                ; If no terminal ROM, the ext part is automatically in
                ; the utils bank. (Yes, the naming here is bad.
                ; Sorry.)
extROM=terminalROM
                .elsif version==320
extROM=14
                .elsif version==350
extROM=9
                .elsif version>=400
extROM=15
                .endif

; Base page for VDU routines
vduRoutinesPage=$c0

                .if version<500
cmosBytesOffset=RTC.ram
                .elsif version>=500
cmosBytesOffset=0
                .endif
                
CMOSBytes: .struct
econetStationNumber: .fill 1
fileServerStationNumber: .fill 1
fileServerNetworkNumber: .fill 1
printerServerStationNumber: .fill 1
printerServerNetworkNumber: .fill 1
defaultROMs: .block
                .fill 1
fsShift=0
languageShift=4
                .endblock
                
insertedROMs: .fill 2
                
editROMByte: .fill 1
telecommsByte: .fill 1

                ; TODO - don't need to say "default" so much...
defaults0: .block
                .fill 1
defaultMODEMask=7
defaultSHADOWMask=8
defaultInterlaceMask=16
defaultTVMask=7
defaultTVShift=5
                .endblock

defaults1: .block
                .fill 1
defaultFDRIVEMask=7
defaultShiftLockMask=8
defaultNoLockMask=16
defaultCapsLockMask=32
defaultADFSLoadDirMask=64
defaultFloppyDrive=128
                .endblock

keyboardAutoRepeatDelay: .fill 1
keyboardAutoRepeatRate: .fill 1
printerIgnoreChar: .fill 1
                
defaults2: .block
                .fill 1
tubeOnMask=1
usePrinterIgnoreCharMask=2
serialBaudRateIndexMask=7
serialBaudRateIndexShift=2
fx5SettingMask=7
fx5SettingShift=5
                .endblock

defaults3: .block
                .fill 1
loudMask=2
extTubeMask=4
protectedScrollingMask=8
autoBootMask=16
defaultSerialDataFormatMask=7
defaultSerialDataFormatShift=5
                .endblock

                .if version>=500
                ; Purpose currently unknown. Is it even used?
unknown11:
                .fill 1

joystick: .block
stickMask=$f
isSwitchedMask=32
                .fill 1
                .endblock

                .if version>=511||olivetti
                ; 5.11 doesn't appear to use this byte, but it does
                ; get cleared as part of the CMOS reset loop. So
                ; presumably there was space booked for it somewhere
                ; in the original code.
country:
                .fill 1
                .endif
                .endif
                
                .endstruct

originalA=$ef
originalX=$f0
originalY=$f1
irqTempA=$fc
errPtr=$fd                      ;REPTR in OS 1.20
escapeFlag=$ff
                
envelope1Data=$8c0

sidewaysROMLanguageEntry=$8000
sidewaysROMServiceEntry=$8003
                .virtual $8006
sidewaysROMType: .block
hasRelocationAddress=32
hasLanguageEntry=64
hasServiceEntry=128
                .endblock
                .endvirtual
sidewaysROMCopyrightOffset=$8007
sidewaysROMVersion=$8008
sidewaysROMName=$8009

;-------------------------------------------------------------------------

                ; [MasRef D.3-22]
ClockStringFormat: .struct
ddd:
                .fill 3
                .fill 1                      ;','
nn:
                .fill 2
                .fill 1                      ;' '
mmm:
                .fill 3
                .fill 1                      ;' '
yyyy:
                .fill 4
                .fill 1                      ;'.'
hh:
                .fill 2
                .fill 1                      ;':'
mm:
                .fill 2
                .fill 1                      ;':'
ss:
                .fill 2
cr:
                .fill 1                      ;'\n'
                .endstruct

;-------------------------------------------------------------------------
