;-------------------------------------------------------------------------

osword42SetupTable:
                .if version>=500||version==350
                .byte 1
                .endif
                .byte 9
                .byte 10
                .byte 11
                .byte 12
                .byte 2
                .byte 3
                .byte 4
                .byte 5
                .byte 6

;-------------------------------------------------------------------------
;
; OSWORD $42 - Sideways RAM Block Transfor (G.7-7)
;
; Entry: parameter block like this:
;
;    block?0 - bit 7 clear=read, set=write
;              bit 6 clear=absolute, set=pseudo
;    block!1 - data address
;    (block+5); - block length
;    block?7 - ROM ID 0-$0f, or $10-$13 for W/X/Y/Z
;    (block+8); - sideways RAM address
; 
osword42: .proc
                .if version==400
                lda (originalX)
                and #$c0
                sta osfileParameterBlock+1
                .endif
                ldy #9

copyFromParameterBlockLoop:
                lda (originalX),y
                .if version==400
                ldx osword42SetupTable-1,y
                .else
                ldx osword42SetupTable,y
                .endif
                sta osfileParameterBlock,x
                dey
                .if version==400
                bne copyFromParameterBlockLoop
                .else
                bpl copyFromParameterBlockLoop
                iny             ; Y=0
                .endif

saveTransferPointersLoop:
                lda sramTransferPointers,y
                pha
                iny
                cpy #size(sramTransferPointers)
                bcc saveTransferPointersLoop

                jsr doSidewaysRAMBlockTransfer

                ldy #size(sramTransferPointers)-1
restoreTransferPointersLoop:
                pla
                sta sramTransferPointers,y
                dey
                bpl restoreTransferPointersLoop
                rts
                .endproc

;-------------------------------------------------------------------------

convertSidewaysRAMPseudoAddress:
                bit osfileParameterBlock+1
                bvc checkROMID ;taken if absolute addressing - nothing to do

                ; Sort out pseudo address - see MasRef G.7-5
                ldy #4          ; 4=first SRAM bank
                lda osfileParameterBlock+5 ; SRAM pseudo address LSB
                ldx osfileParameterBlock+6 ; SRAM pseudo address MSB
findStartBankLoop:
                cpx #>dataBankSize
                bcc foundStartBank ; taken if MSB $00-$3e
                bne nextBank       ; taken if MSB >=$40

                ; Address is 16 KB-the dummy header size
                cmp #<dataBankSize
                bcc foundStartBank ; taken if address<$3ff0

nextBank:
                sbc #<dataBankSize
                pha
                txa
                sbc #>dataBankSize
                tax
                pla
                iny
                cpy #8          ; 8=last SRAM bank
                bcc findStartBankLoop ; taken if more banks to go
                jmp badAddressError ; taken if pseudo address out of range

foundStartBank:
                ; form actual address in osfileParameterBlock!5
                adc #<dataBankStart
                sta osfileParameterBlock+5
                txa
                adc #>dataBankStart
                sta osfileParameterBlock+6
                sty osfileParameterBlock+4 ; save ROM number
                .cerror *!=checkROMID ; fall through to checkROMID

;-------------------------------------------------------------------------
;
; Check ROM ID (as read by readROMID) is valid.
;
; Entry:
;
; osfileParameterBlock?4 = ROM ID
;
; Exit:
;
; 
;
; May also generate a "Bad id" error.

checkROMID: .proc
                lda osfileParameterBlock+4 ; get ROM number
                cmp #$10                   
                bcc gotValidROMID       ; if <16, use as-is

                ; convert W/X/Y/Z to 4-7
                cmp #$14
                bcs badIdError  ; bad id if >=$14
                eor #$14        ; $10->$04, $11->$05, $12->$06, $13->$07
                sta osfileParameterBlock+4

gotValidROMID:
                tax
                jsr isBankROM
                bcs L8C68       ; taken if ROM
                bit osfileParameterBlock+1
                bpl badIdError
                bvs badIdError

L8C68:
                jsr sramGetBankMode        ; A=$40 if pseudo
                ldx osfileParameterBlock+4 ; get ROM ID
                eor osfileParameterBlock+1
                and #$40

                ; for *SRDATA: A=$00 if pseudo bank, $40 if absolute
                ; 
                ; for *SRROM: A=$40 if pseudo bank, $00 if absolute
                
                rts
                .endproc
                
;-------------------------------------------------------------------------

badIdError:
                jsr doFollowingError
                .byte $80
                .text "Bad id"
                .byte 0

;-------------------------------------------------------------------------
;
; Read ROM ID from command line.
;
; Entry:
;
; ($f2),y = command line input pointer
;
; Exit:
;
; V=1 if invalid
;
; V=0 if valid
;    osfileParameterBlock?1 bit 6 cleared
;    osfileParameterBlock?4 is ROM ID
;
; May also generate a "Bad id" error.
; 
readROMID: .proc
                jsr readHexDigit ; get char, possibly hex
                bit valueFF      ; V=1
                bcs L8C94        ; taken if hex digit encountered
                and #$DF         ; redundantly convert to upper case
                cmp #'Z'+1
                bcs done        ; taken if >'Z' - not valid
                cmp #'W'
                bcc done        ; taken if <'W' - not valid
                sbc #'W'-4      ; adjust: W=4, X=5, Y=6, Z=7
                iny             ; consume command line char

L8C94:
                ; Handle decimal numbers: if the bank was 1, it might
                ; be "1" or the first char of "10", "11", etc. Handle
                ; accordingly.
                ;
                ; (If using the W/X/Y/Z syntax, the banks are 4-7.)
                cmp #1
                bne gotROMID
                dey             ; go back to the got char
                jsr parseNumberFromString ; read as number
                txa                       ; A = result
                cmp #$10
                bcs badIdError  ; bad id if >15

gotROMID:
                ; +4 = romid
                sta osfileParameterBlock+4

                ; clear +1 bit 6 - indicate valid rom id?
                lda #$40
                trb osfileParameterBlock+1
                clv             ; V=0

done:
                jmp skipSpacesAndCheckForCRInStringInput
                .endproc

;-------------------------------------------------------------------------

starSRDATAOrStarSRROM:
                pha
                jsr readROMID
                bvs jmpBadCommandError8CD6 ; taken if invalid ROM ID
                bne jmpBadCommandError8CD6 ; taken if bad command line
                                           ; contents
                pla

                ; $80 if *SRDATA; $00 if *SRROM
                .if version==400
                jsr L8A88
                .else
                asl a
                sta osfileParameterBlock+1
                .endif
                jsr checkROMID
                bcs badIdError  ; taken if bank could never be used
                                ; with pseudo addressing
                bne toggleModeAndInitBank ; taken if switching to other bank mode

                ; If bank mode didn't change, but there's nothing in
                ; the bank already, set up the dummy ROM header for
                ; it. 
                ora romInformationTable,x
                beq initBank
                rts

toggleModeAndInitBank:
                lda hazel.sramBankModes
                eor sramBank4567ModeMasks-4,x
                sta hazel.sramBankModes

initBank:
                jsr setROMXType6502
                jmp initDummyROMHeader

;-------------------------------------------------------------------------

jmpBadCommandError8CD6:
                jmp badCommandError

;-------------------------------------------------------------------------

L8CD9:       
                jsr L8CEA
                bcs locret_8CE9
                jsr LF846
                sty osfileParameterBlock+5
                lda 1,x
                sta osfileParameterBlock+6

locret_8CE9:
                rts
                

;-------------------------------------------------------------------------

L8CEA:
                ; get sideways RAM pointer address in X - src if
                ; reading from sideways RAM, dest if writing to
                ; sideways RAM
                ldx #sramTransferPointers.src
                bit osfileParameterBlock+1
                bpl +           ; taken if reading from sideways RAM
                ldx #sramTransferPointers.dest
+
                stz 0,x
                ldy osfileParameterBlock+5 ; sram address LSB
                tya                        ; Y=sram address LSB
                clc
                adc osfileParameterBlock+2 ; form end address LSB
                sta osfileParameterBlock+2
                lda osfileParameterBlock+6 ; sram address MSB
                sta 1,x                    ; 
                adc osfileParameterBlock+3 ; form end address MSB
                sta osfileParameterBlock+3
                sec
                jsr L8F62
L8D0F:
                cpy osfileParameterBlock+2
                bne L8D1C
                lda 1,x
                cmp osfileParameterBlock+3
                bne L8D1C
                rts
L8D1C:
                bit osfileParameterBlock+1
                bvc L8D53       ; taken if absolute addressing
                lda 1,x         ; get sideways RAM pointer
                cmp #>(dataBankStart+dataBankSize) ; gone past end of bank?
                bcc L8D53       ; taken if not past end of bank
                lda #>dataBankStart
                sta 1,x                    ; reset pointer MSB
                inc osfileParameterBlock+4 ; move to next bank
                lda osfileParameterBlock+4
                cmp #8
                bcs jmpBadAddressError ; bad address error if definitely past end of pseudo-addressable area
                phx
                jsr checkROMID  ; perform other ROM ID checks
                bne jmpBadAddressError ; bad address error if bad
                plx
                ldy #<dataBankStart

                ; Subtract dataBankSize from count of bytes remaining
                lda osfileParameterBlock+2
                sec
                sbc #<dataBankSize
                sta osfileParameterBlock+2
                lda osfileParameterBlock+3
                sbc #>dataBankSize
                sta osfileParameterBlock+3
                clc
                jsr L8F62

L8D53:
                lda osfileParameterBlock+4
                clc

locret_8D57:
                rts

;-------------------------------------------------------------------------

parse16BitHexAddressFromCommandLine:
                jsr parseHexAddressFromCommandLine
checkParameterBlockAddressIs16Bit:
                lda osfileParameterBlock+2,x
                ora osfileParameterBlock+3,x
                beq locret_8D57

jmpBadAddressError:
                jmp badAddressError

;-------------------------------------------------------------------------
;
; Read I from command line. From Master Compact app note: ``A facility
; to load an SRAM image and update the MOS ROM type table has been
; added. An "I" should be added to the *SRLOAD command.''
; 
                .if version==350||version>=500
readImmediateFlag:
                jsr skipSpacesAndCheckForCRInStringInput
                and #$DF
                cmp #'I'
                bne L8D7C
                iny
                lda osfileParameterBlock+1
                cmp #$80
                bne jmpBadCommandError8DB4 ; "Bad command" if not *SRLOAD
                ora #$20                   ; set bit 5 to indicate I
                sta osfileParameterBlock+1

L8D7C:
                jmp skipSpacesAndCheckForCRInStringInput
                .endif

;-------------------------------------------------------------------------
;
; C=0 for *SRREAD
; 
starSRREADOrStarSRWRITE:
                .if version==400
                jsr L8A88
                .else
                asl a
                sta osfileParameterBlock+1
                .endif
                
                ; osfileParameterBlock?1 = 64 if SRREAD or SRSAVE
                ;                          192 if SRWRITE
                ;                          128 if SRLOAD
                ;                          bit 6 clear if valid rom id
                ;                          bit 5 set if I flag (3.50/5.xx)
                ; (osfileParameterBlock+2); = data length
                ; osfileParameterBlock?4 = rom bank/rom id
                ; osfileParameterBlock!5 = sram address
                ; osfileParameterBlock!9 = data address
                
                ldx #9          ; store at osfileParameterBlock+9
                jsr parseHexAddressFromCommandLine
                jsr checkForPlusInCommandLine
                ldx #2          ; store at osfileParameterBlock+2
                jsr parseHexAddressFromCommandLine
                bvs L8DA2 ; taken if + encountered, so +2 is already the length

                ; Form length of data in +2
                ldx #$FC

L8D94:
                lda osfileParameterBlock+2-$FC,x
                sbc osfileParameterBlock+9-$FC,x
                sta osfileParameterBlock+2-$FC,x
                inx
                bne L8D94
                bcc jmpBadAddressError ; taken if end<start

L8DA2:
                ; Check length is a 16 bit quantity
                ldx #2
                jsr checkParameterBlockAddressIs16Bit

                ; Parse SRAM address
                ldx #5
                jsr parse16BitHexAddressFromCommandLine

                ; Read ROM ID
                jsr readROMID

                .if version>=500||version==350
                jsr readImmediateFlag
                .endif
                beq doSidewaysRAMBlockTransfer

jmpBadCommandError8DB4:
                jmp badCommandError

doSidewaysRAMBlockTransfer:
                php
                jsr convertSidewaysRAMPseudoAddress
                beq L8DC0
                jsr badIdError  ; should be a jmp; will never return
L8DC0:
                jsr L8F40
                .if includeTubeSupport
                lda osfileParameterBlock+11
                and osfileParameterBlock+12
                inc a
                and tubePresence
                bne L8952
                .endif
                jsr L8CD9
                plp
                .if version==400
                rts
                .else
                jmp LF8D1
                .endif

;-------------------------------------------------------------------------

                .if includeTubeSupport
L8952:
                lda #$c8    ; 8 = claimant code for sideways RAM utils
                jsr $0406   ; claim Tube
                bcc L8952       ; if it failed, try again
                lda #0          ; multi byte parasite->host
                bit osfileParameterBlock+1
                bmi +           ; taken if writing to sideways RAM
                inc a           ; multi byte host->parasite
+
                ldx #<(osfileParameterBlock+9)
                ldy #>(osfileParameterBlock+9)
                jsr $0406       ; begin transfer to/from data address
                jsr L8CEA
                bcs L8970
                jsr transferSidewaysRAMOverTube
L8970:
                lda #$88
                jsr $0406
                plp
                rts
                .endif

;-------------------------------------------------------------------------

starSRLOADOrStarSRSAVE:
                .if version==400
                jsr L8A88
                .else
                asl a
                sta osfileParameterBlock+1
                .endif
                lsr hazel.tempFSFlag
                stx stringInputBufferAddress
                sty stringInputBufferAddress+1
                stx osfileParameterBlock+2
                sty osfileParameterBlock+3
                ldy #0
                jsr gsinitForFilenameParsing

L8DE0:
                jsr gsreadEntryPoint
                bcc L8DE0
                ldx #5
                jsr parse16BitHexAddressFromCommandLine
                bit osfileParameterBlock+1
                bmi L8E0D
                jsr checkForPlusInCommandLine
                ldx #7
                jsr parse16BitHexAddressFromCommandLine
                bvs L8E0D
                sec
                ldx #$FE

L8DFC:
                lda osfileParameterBlock+7-$FE,x
                sbc osfileParameterBlock+5-$FE,x
                sta osfileParameterBlock+7-$FE,x
                inx
                bne L8DFC
                bcs L8E0D
                jmp jmpBadAddressError

;-------------------------------------------------------------------------

L8E0D:
                jsr readROMID
                stz osfileParameterBlock+$B
                .if version==350
                ldx #$ff
                .else
                ldx #0
                .endif
                .if version>=500||version==350
                jsr readImmediateFlag
                .endif
                and #$DF
                .if version==350
                iny
                .endif
                cmp #'Q'
                .if version==350
                beq L8E20
                .else
                bne L8E20
                .endif
                .if version==350
                dey
                .endif
                .if version==350
                stz osfileParameterBlock+9
                ldx #>hazel.commandLine
                stx osfileParameterBlock+10
                ldx #$03
                .else
                dex
                iny
                .endif

L8E20:
                stx osfileParameterBlock+12
                ldx ACCCON
                .if version==400
                jsr skipSpacesAndCheckForCRInStringInput
                .else
                jsr readImmediateFlag
                .endif
                beq L8E41
                jmp jmpBadCommandError8DB4

;-------------------------------------------------------------------------

osword43:
                ldx ACCCON
                jsr selectHAZEL
                stz hazel.tempFSFlag
                ldy #$B

L8E39:
                lda (originalX),y
                sta osfileParameterBlock+1,y
                dey
                bpl L8E39
                .if version==400
                lda #$3f
                trb osfileParameterBlock+1
                .endif

L8E41:
                php
                phx
                jsr convertSidewaysRAMPseudoAddress
                beq L8E4B
                jmp badIdError
L8E4B:
                lda osfileParameterBlock+12
                bmi L8E5B
                ora osfileParameterBlock+11
                bne L8E72
                lda #2
                ldy #>hazel.ddxx
                bra L8E66

;-------------------------------------------------------------------------

L8E5B:
                jsr osbyte84
                tya
                sec
                sbc oshwm
                ldy oshwm

L8E66:
                stz osfileParameterBlock+9
                sty osfileParameterBlock+10
                stz osfileParameterBlock+11
                sta osfileParameterBlock+12

L8E72:
                bit osfileParameterBlock+1
                bpl L8EAF
                lda #findOpenForRead
                jsr sramOpenFile

L8E7C:
                sec
                jsr L8EED
                lda #gbpbGetBytesCurrentPTR
                jsr sramOSGBPB
                php
                bcc L8E96
                ldx #$FE

L8E8A:
                lda osfileParameterBlock+2-$FE,x

L8E8D:
                sbc hazel.moveOSGBPB+OSGBPBParameterBlock.count+0-$fe,x
                sta osfileParameterBlock+2-$FE,x
                inx
                bne L8E8A

L8E96:
                jsr L8CD9
                plp
                bcc L8E7C

L8E9C:
                ldy hazel.moveSrcHandle
                stz hazel.moveSrcHandle
                lda #0
                jsr OSFIND
                pla
                sta ACCCON
                plp
                .if version==400
                rts
                .else
                jmp LF8D1
                .endif

;-------------------------------------------------------------------------

L8EAF:
                lda #findOpenForWrite
                jsr sramOpenFile

L8EB4:
                sec
                ldx #$FE

L8EB7:
                lda osfileParameterBlock+7-$FE,x
                sta @w sramTransferPointers-$fe,x
                sbc osfileParameterBlock+11-$FE,x
                sta osfileParameterBlock+7-$FE,x
                inx
                bne L8EB7
                ora osfileParameterBlock+7
                php
                jsr L8EED
                jsr L8CD9
                lda #gbpbPutBytesCurrentPTR
                jsr sramOSGBPB
                plp
                bcc L8E9C
                beq L8E9C
                bra L8EB4

;-------------------------------------------------------------------------

                .if version==400
L8A88:
                asl a
                sta osfileParameterBlock+1
                rts
                .endif
                
;-------------------------------------------------------------------------
;
; OSBYTE 68 (&44) - Test RAM presence [MasRef D.2-28]
; 
osbyte44:
                lda #0
                ldx #7
osbyte44Loop:
                pha
                jsr isBankROM
                pla
                rol a
                dex
                cpx #4
                bcs osbyte44Loop
                tax
                rts

;-------------------------------------------------------------------------

L8EED:
                lda hazel.moveSrcHandle
                sta hazel.moveOSGBPB.handle
                ldx #1

L8EF5:
                lda osfileParameterBlock+9,x
                sta hazel.moveOSGBPB.addr,x
                lda osfileParameterBlock+$B,x
                bcs L8F02
                lda sramTransferPointers.src,x

L8F02:
                sta hazel.moveOSGBPB.numBytes,x
                sta osfileParameterBlock+2,x
                lda #$FF
                sta hazel.moveOSGBPB.addr+2,x ; address is in I/O processor
                stz hazel.moveOSGBPB.numBytes+2,x ; size is 16-bit quantity
                dex
                bpl L8EF5
                rts
                

;-------------------------------------------------------------------------

sramOSGBPB:
                ldx #<hazel.moveOSGBPB
                ldy #>hazel.moveOSGBPB
                jmp OSGBPB
                

;-------------------------------------------------------------------------

sramOpenFile:
                asl hazel.tempFSFlag
                ldx osfileParameterBlock+2
                ldy osfileParameterBlock+3
                jsr OSFIND
                tax
                bne sramFileFound
                jsr doFollowingError
                .byte $D6
                .text "File not found"
                .byte 0

sramFileFound:
                sta hazel.moveSrcHandle
L8F40:
                ldx osfileParameterBlock+4 ; ROM number of interest
                bit osfileParameterBlock+1
                bpl rts8F4F ; taken if reading
                bvs rts8F4F ; taken if pseudo addressing

                ; writing, absolute addressing
setROMXType6502:
                lda #romType6502
                sta romInformationTable,x

rts8F4F:
                rts
                

;-------------------------------------------------------------------------

sramBank4567ModeMasks:
                .byte 1         ; bank 4
                .byte 2         ; bank 5
                .byte 4         ; bank 6
                .byte 8         ; bank 7

;-------------------------------------------------------------------------
;
; Check to see if next char on command line is +.
;
; Entry:
;
; (stringInputBufferAddress),y = next char on command line
;
; Exit:
;
; V=0 if not +
; 
; V=1 if +. (stringInputBufferAddress),y = next non-space after the +

checkForPlusInCommandLine:       
                clv
                lda (stringInputBufferAddress),y
                cmp #'+'
                bne locret_8F61
                bit valueFF
                jsr incAndSkipSpaces

locret_8F61:
                rts
                

;-------------------------------------------------------------------------

L8F62:       
                phx
                ; select the non-sram data pointer
                txa
                eor #sramTransferPointers.src^sramTransferPointers.dest
                tax
                bcc L8F73

                ; store data address in the non-sram pointer
                lda osfileParameterBlock+9 ; data address LSB
                sta 0,x
                lda osfileParameterBlock+10 ; data address MSB
                sta 1,x

L8F73:
                sty osfileParameterBlock+0 ; sram address LSB
                lda 0,x
                sec
                sbc osfileParameterBlock+0
                sta 0,x
                bcs L8F82
                dec 1,x

L8F82:
                plx
                rts
                

;-------------------------------------------------------------------------
;
; Get bank mode: pseudo, or absolute.
;
; (Only banks 4-7 can be used with pseudo addressing, but you can test
; any.)
;
; Entry:
;
; X = bank of interest
;
; Exit:
;
; A=$00 if absolute (C=1 as well, if bank could only ever be absolute)
;
; A=$40 if pseudo

sramGetBankMode:
                cpx #4
                bcc bankModeIsInherentlyAbsolute ; taken if <4
                cpx #8
                bcs bankModeIsInherentlyAbsolute ; taken if >=8

osbyte45:
                ; When entered as OSBYTE $45, the X register is bogus,
                ; so the table lookup could read junk and the AND
                ; could end up meaningless. But that doesn't matter:
                ; it's only the value in X on exit that's important.
                ldy ACCCON
                jsr selectHAZEL ; engage HAZEL
                lda sramBank4567ModeMasks-4,x ; acquire mask: 1/2/4/8 for banks
                                 ; 4/5/6/7 respectively
                ldx hazel.sramBankModes ; load current settings into X, in case this is OSBYTE $45
                and hazel.sramBankModes
                beq +           ; taken with A=$00 if bank of interest
                                ; is absolute
                lda #$40        ; indicate pseudo
+
                sty ACCCON
                clc
                rts

bankModeIsInherentlyAbsolute:
                sec
                lda #0
                rts
