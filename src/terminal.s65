; -*- comment-column:45; -*-

utilsROMHeader: .block
                .if (version==320||version==350)&&includeTerminalROM
                jmp terminalLanguageEntryPoint ; Language entry point
                jmp utilsServiceEntryPoint  ; Service entry point
                .byte $C2                    ; ROM type=SERV+LANG+6502
                .byte copyrightText-1-utilsROMHeader ; (C) offset
                .byte $01
                .text "TERMINAL"
                .byte 0
copyrightText:
                .if version==350
                .text "(C)1986 Acorn"
                .else
                .text "(C)1984 Acorn"
                .endif
                .byte 0

                .elsif version==400||!includeTerminalROM

                brk
                brk
                brk
                jmp utilsServiceEntryPoint
                .byte $82
                .byte copyrightText-1-utilsROMHeader
                .byte $00
                .text "MOS"
                .byte 0
copyrightText:
                .text "(C)1984 Acorn"
                .byte 0

                .elsif version>=500

                ; Language entry point
                brk                          
                brk
                brk

                ; Service entry point
                jmp utilsServiceEntryPoint

                .byte $82
                .byte copyright-1-utilsROMHeader
                .if version==500
                .byte 0
                .elsif version==510
                .if olivetti
                .byte $10
                .else
                .byte 1
                .endif
                .elsif version==511
                .byte $10
                .endif
                .text "UTILS",0
copyright:
                .if olivetti
                .text "(C)1986 Olivetti",0
                .else
                .text "(C)1986 Acorn",0
                .endif
                .endif
                .endblock

;-------------------------------------------------------------------------

                .if version==350
trbACCCON:
                jsr withTST
                trb ACCCON
                rts
                .endif

;-------------------------------------------------------------------------

                .if version==350
tsbACCCON:
                jsr withTST
                tsb ACCCON
                rts
                .endif

;-------------------------------------------------------------------------

                .if version==350
ldaSystemVIAIER:
                jsr withTST
                lda systemVIA.ier
                rts
                .endif

;-------------------------------------------------------------------------

                .if version==350
printCMOSRamResetMessage:
                jsr withTST
                jsr alwaysPrintFollowingMessage
                .text 13,10
                .text "CMOS RAM reset",13,10
                .text "Press break to continue",13,10
                .text 0
                rts
                .endif

;-------------------------------------------------------------------------

                .if version==350
                .include "isSecondProcessorPresent.s65"
                .endif

;-------------------------------------------------------------------------

                .if version==350
resetCRTC:
                ldx #$1e
L8081:
                stx $fe00
                stz $fe01
                inx
                cpx #$21
                bcc L8081
                rts
                .endif

;-------------------------------------------------------------------------

; STARTUP
; =======

; This code is officially more than a bit gnarly, as it gets stitched
; together in several different ways.

                .if version==350             ;stripped_out_reset
softResetPart2:
                jsr withTST
                pla
                pla
                pla
                .else                        ;stripped_out_reset
reset:                          ;8020
                .include "reset.s65"
                .endif

                .if version<500
                bcc handleROMWorkspace        ;taken if Tube not found
                .if version!=350
foundTube:
                .endif
                ldx #romServiceCallTubeMainInitialisation
                jsr makeROMServiceCall   ;
                bne handleROMWorkspace        ; Not claimed, step past
                dec tubePresence ; Tube PreInit claimed, set TubeFlag to &FF, Tube present
                .endif
                .if version!=350
continueSoftReset:
                .endif
handleROMWorkspace:
                lda lastBREAKType ; Soft Break, don't ask about workspace
                beq L82FC
                ldy #$DC                     ; Start high workspace at &DC00 and work downwards
                ldx #romServiceCallCountDynamicHAZELWorkspace ; Ask ROMs how much private high workspace required
                jsr makeROMServiceCall   ;
                ldx #romServiceCallAbsoluteHAZELWorkspaceClaim ; Ask ROMs for maximum shared high workspace required
                jsr makeROMServiceCall   ;
                phy                          ; Save top of shared workspace
                ldx #romServiceCallPrivateHAZELWorkspaceClam ; Ask ROMs for private high workspace required
                jsr makeROMServiceCall   ;
                ldy #$0E                     ; Start low workspace at &0E00
                ldx #romServiceCallAbsoluteWorkspaceClaim ; Ask ROMs for maximum shared workspace
                jsr makeROMServiceCall   ;
                ldx #romServiceCallPrivateWorkspaceClaim ; Ask ROMs for private workspace
                jsr makeROMServiceCall   ;
                sty oshwm                    ; Set OSHWM - default PAGE
                ply                          ; Get top of shared high workspace
                ldx #romServiceCallTopOfHAZELWorkspace ; Tell ROMs top of shared high workspace
                jsr makeROMServiceCall   ;
L82FC:
                ldx #size(defaultFsInfoBlocks)
L82FE:
                lda defaultFsInfoBlocks-1,x                ; Copy initial FS info blocks for CFS, TAPE, ROM
                sta hazel.fsInfoBlocks-1,x
                dex
                bne L82FE
                stz $F2                      ; &F2/3=>FS Info Blocks
                lda #>hazel.fsInfoBlocks
                sta $F3
                ; Y=>end of FS Info Blocks
                ldy #<hazel.fsInfoBlocks+size(defaultFsInfoBlocks)
                ldx #$25                     ; Ask ROMs for FS Info Blocks
                jsr makeROMServiceCall   ;
                lda #$00                     ; Terminate FS Info blocks
                sta ($F2),y

                lda spoolFileHandle ; Save Spool handle and disable Spooling
                pha
                stz spoolFileHandle
                ldx #romServiceCallTubeSystemPostInitialisation
                ldy tubePresence
                jsr makeROMServiceCall   ; Tube PostInit
                and startupMessageSuppressionStatus
                bpl L8340

                ; use +$ff rather than -1 to avoid 64tass warning.
                ; Only the LSB is used.
                ldy #((startupMessages.acornMOS-(startupMessages&$ff00))+$ff)&$ff
                jsr printStartupMessage
                lda lastBREAKType            ; Skip past if Soft Break
                beq L833B
                ldy #((startupMessages.beep-(startupMessages&$ff00))-1)&$ff
                jsr printStartupMessage
L833B:
                ldy #((startupMessages.twoNewlines-(startupMessages&$ff00))-1)&$ff
                jsr printStartupMessage
L8340:
                pla                          ; Restore Spool handle
                sta spoolFileHandle
                jmp LE40E                ;

;-------------------------------------------------------------------------

                .if version>=500
L8363:
                lda #$0f
L8365:
                dec a
                sta $fe40
                cmp #9
                bcs L8365
                .endif
                .if version>=400
clearAllSoundChannelBuffers:
                ldx #8
L836F:
                dex
                jsr clearSoundChannelBuffer
                cpx #4
                bne L836F
                rts
                .endif

;-------------------------------------------------------------------------

; Default FS Info Blocks
; ======================
defaultFsInfoBlocks: .block
                .if version<500
                .text "CFS     "
                .byte $01
                .byte $02
                .byte $01
                .text "TAPE    "
                .byte $01
                .byte $02
                .byte $01
                .endif
                .text "ROM     "
                .byte $03
                .byte $03
                .byte $03
                .endblock

;-------------------------------------------------------------------------
; 
; MOS command table

mos_command .macro name,routine,byte1,byte2
                ; Name of command, compared case-insensitively.
                .text \name

                ; Address of command routine, big-endian so that the
                ; first byte always has bit 7 set.
                .beword \routine

                ; If bit 7 set, reset the tempFS flag before
                ; starting.
                .byte \byte1

                ; If bit 7 set, update string input buffer address
                ; before starting.
                ;
                ; A is set to this value on entry to the routine.
                .byte \byte2
                .endm
                
mosCommandTable:
                .mos_command "CAT",callFSCV,$80,$05 ; XY=>parameters, FSC &05
                .if version!=400
                .mos_command "ADFS",passStarCommandThrough,$00,$00   ;
                .endif
                .mos_command "APPEND",starAPPEND,$80,$00 ; XY=>parameters
                .mos_command "BASIC",starBASIC,$00,$00  ;
                .mos_command "BUILD",starBUILD,$80,$00  ; XY=>parameters
                .mos_command "CLOSE",starCLOSE,$00,$FF  ;
                .if version<500&&version!=350
                .mos_command "CONFIGURE",starCONFIGURE,$00,$FF ;
                .else
                .mos_command "CONFIGURE",starCONFIGUREOrStarSTATUS,$00,$80 ;
                .endif
                .mos_command "CODE",starCommandThroughOSBYTE,$00,$88 ; X,y=parameters, OSBYTE &88
                .mos_command "CREATE",starCommandThroughOSFILE,$80,$07 ; XY=>parameters, OSFILE &07
                .mos_command "DUMP",starDUMP,$80,$00   ; XY=>parameters
                .mos_command "DELETE",starDELETE,$80,$00 ; XY=>parameters
                .mos_command "EXEC",starEXEC,$80,$00   ; XY=>parameters
                .mos_command "EX",callFSCV,$80,$09 ; XY=>parameters, FSC &09
                .mos_command "FX",starFX,$00,$FF ;
                .mos_command "GOIO",starGOIO,$00,$FF ;
                .mos_command "GO",starGO,$00,$FF   ;
                .mos_command "HELP",starHELP,$00,$FF ;
                .mos_command "INFO",callFSCV,$80,$0A ; XY=>parameters, FSC &0A
                .mos_command "IGNORE",starIGNORE,$00,$FF ;
                .mos_command "INSERT",starINSERT,$00,$FF ;
                .mos_command "KEY",starKEY,$00,$FF    ;
                .mos_command "LOAD",starLOAD,$80,$00   ; XY=>parameters
                .mos_command "LIST",starLIST,$80,$00   ; XY=>parameters
                .mos_command "LINE",callUSERV,$00,$01 ;
                .mos_command "LIBFS",starLIBFS,$00,$00    ;
                .if version<500
                .mos_command motorCommandString,starCommandThroughOSBYTE,$00,$89 ; X,y=parameters, OSBYTE &89
                .else
                .mos_command motorCommandString,rtsFFAA,$00,$89 ; X,y=
                .endif
                .mos_command "MOVE",starMOVE,$80,$00  ; XY=>parameters
                .mos_command "OPT",starCommandThroughOSBYTE,$80,$8B ; X,y=parameters, OSBYTE &8B
                .mos_command "PRINT",starPRINT,$80,$00 ; XY=>parameters
                .mos_command "RUN",callFSCV,$80,$04 ; XY=>parameters, FSC &04
                .mos_command "REMOVE",starREMOVE,$80,$00 ; XY=>parameters
                .mos_command "ROM",starCommandThroughOSBYTE,$00,$8D ; X,y=parameters, OSBYTE &8D
                .mos_command "ROMS",starROMS,$00,$FF ;
                .mos_command "SAVE",starCommandThroughOSFILE,$80,$00 ; XY=>parameters, OSFILE &00
                .mos_command "SHADOW",starSHADOW,$00,$FF  ;
                .mos_command "SHOW",starSHOW,$00,$FF    ;
                .mos_command "SHUT",starSHUT,$00,$00 ;
                .mos_command "SPOOL",starSPOOL,$80,$00   ; XY=>parameters
                .mos_command "SPOOLON",starSPOOLON,$80,$00 ; XY=>parameters
                .if version>=350
                .mos_command "SRDATA",starSRDATAOrStarSRROM,$00,$a0
                .mos_command "SRLOAD",starSRLOADOrStarSRSAVE,$80,$60
                .mos_command "SRREAD",starSRREADOrStarSRWRITE,$00,$a0
                .mos_command "SRROM",starSRDATAOrStarSRROM,$00,$80
                .mos_command "SRSAVE",starSRLOADOrStarSRSAVE,$80,$20
                .mos_command "SRWRITE",starSRREADOrStarSRWRITE,$00,$e0
                .endif
                .if version<500&&version!=350
                .mos_command "STATUS",starSTATUS,$00,$FF  ;
                .else
                .mos_command "STATUS",starCONFIGUREOrStarSTATUS,$00,$c0
                .endif
                .if version<500
                .mos_command tapeCommandString,starCommandThroughOSBYTE,$00,$8C ; X,y=parameters, OSBYTE &8C
                .else
                .mos_command tapeCommandString,rtsFFAA,$00,$8C ; X,y=parameters, OSBYTE &8C
                .endif
                .mos_command "TV",starCommandThroughOSBYTE,$00,$90 ; X,y=parameters, OSBYTE &90
                .mos_command "TIME",starTIME,$00,$00   ;
                .mos_command "TYPE",starTYPE,$80,$00   ; XY=>parameters
                .mos_command "UNPLUG",starUNPLUG,$00,$FF ;
                .if includeStarX
                .mos_command "X",starX,$00,$00  ;
                .endif
                .mos_command "",callFSCV,$00,$03 ; FSC &03
                .byte $00

;-------------------------------------------------------------------------
;
; Get string input buffer address tail according to table byte.
;
; Entry:
;
; oscliWorkspace.tablePtr; = pointer to table byte
; (stringInputBufferAddress),y = pointer to input
;
; Exit:
;
; A = table byte
;
; if table byte bit 7 set: Y/X points to command line tail
maybeGetStringInputBufferAddress:
                lda (oscliWorkspace.tablePtr)
                bmi rts84FE
getStringInputBufferAddressWithYOffset:
                tya
getStringInputBufferAddressWithAOffset:
                clc
                adc stringInputBufferAddress+0
                tax
                ldy stringInputBufferAddress+1
                bcc +
                iny
+
                lda (oscliWorkspace.tablePtr)
rts84FE:
                rts        

; Prepare OSCLI command line
; ==========================
oscli:
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                lda hazel.currentFS
                jsr selectFS
                lda #fscStarCommand
                jsr callFSCV
                ldy #$FF
L8510:
                jsr incAndSkipSpaces
                beq rts84FE
                cmp #'*'
                beq L8510
                jsr skipSpacesAndCheckForCRInStringInput
                beq rts84FE
                cmp #'|'
                beq rts84FE
                stz hazel.tempFSFlag
                cmp #'-'
                bne L8535
                jsr parseFileNameFS
                jsr selectFS
                sec
                ror hazel.tempFSFlag
                lda (stringInputBufferAddress),y
L8535:
                cmp #'/'
                bne L8542
                iny
                jsr getStringInputBufferAddressWithYOffset
                lda #fscStarSlash
                jmp callFSCV

L8542:
                .if version<500&&version!=350
                sty $E6
                .endif
                lda #<mosCommandTable
                sta oscliWorkspace.tablePtr+0
                lda #>mosCommandTable
                sta oscliWorkspace.tablePtr+1
                .if version<500&&version!=350
                bra L8558
                .else
                clv
                jsr findCommand
                bcc passStarCommandThrough
                .endif

                .if version<500&&version!=350
L854E:
                eor (oscliWorkspace.tablePtr)
                and #$DF
                bne L8569
                jsr fetchCommandTableByte
                iny
L8558:
                lda (stringInputBufferAddress),y
                jsr isLetter
                bcc L854E                    ;taken if letter
                lda (oscliWorkspace.tablePtr)
                bmi L8582                ;taken if end of command name
                lda (stringInputBufferAddress),y
                cmp #'.'
                beq L856D                    ;taken if input abbreviated
L8569:
                clc
                ldy $E6
                dey
L856D:
                iny
L856E:
                jsr fetchCommandTableByte ; Get byte from table, update pointer
                beq passStarCommandThrough   ; Zero byte
                bpl L856E                    ; Loop until b7 set
                bcs L8585
                jsr fetchCommandTableByte
                jsr fetchCommandTableByte
                jsr fetchCommandTableByte
                bra L8558
                
L8582:
                jsr fetchCommandTableByte
                .endif
L8585:
                pha
                jsr fetchCommandTableByte
                pha
                jsr fetchCommandTableByte
                bmi L8592
                stz hazel.tempFSFlag
L8592:
                jsr skipSpacesAndCheckForCRInStringInput
                clc                          
                php                          
                jsr maybeGetStringInputBufferAddress
                rti                          

                .if version<500&&version!=350
fetchCommandTableByte:
                lda (oscliWorkspace.tablePtr)
                pha                          
                inc oscliWorkspace.tablePtr+0
                bne +
                inc oscliWorkspace.tablePtr+1
+
                pla                          
rts85A5:
                rts
                .endif

;-------------------------------------------------------------------------

; *BASIC
; ======
starBASIC:
                ldx basicROMNumber           ; Get BASIC ROM number
                bmi passStarCommandThrough ; If no BASIC ROM, jump to pass to ROMs and filing system
                .if version==350
                jmp osbyte8EWithoutRelocation
                .elsif version<500
                sec                          ;
                jmp osbyte8E             ; Enter ROM as a language
                .else
                lda #$8e
                jmp OSBYTE
                .endif

;-------------------------------------------------------------------------

; *ADFS - pass straight to ROMs/Filing System
; ===========================================
passStarCommandThrough:
                bit hazel.tempFSFlag      ; Check filing system flag
                bmi L85C0                    ; If ... skip ROM service call
                stz hazel.tempFSFlag      ; Clear filing system flag
                ldy $E6
                ldx #romServiceCallUnrecognisedCommand
                jsr osbyte8F    ; Service call 4 - Unknown command
                .if version<500&&version!=350
                beq rts85A5                    ; Claimed, return
                .else
                beq parseDone
                .endif
L85C0:
                lda $E6
                jsr getStringInputBufferAddressWithAOffset
                lda #$03
                jmp callFSCV ; Pass to FSCV,3 - Unknown command

starHELP:
                ldx #romServiceCallHelp      ;
                lda STATE                    ;
                pha                          ;save STATE
                lda #14
                jsr OSWRCH                   ; paged mode ON
                jsr makeROMServiceCall   ; 
                ldx #romServiceCallReserved  ;???
                jsr makeROMServiceCall
                pla                          ;restore STATE
                bit #STATE.isPagedScrolling  ;was paged mode on originally?
                bne parseDone   ;taken if paged mode was originally on
                                ;(branch target is an arbitrary nearby
                                ;RTS)
                lda #15         ;restore non-paged mode
                jmp OSWRCH

;-------------------------------------------------------------------------
;
; Read a byte value (0-255) from a string. If the number has a '&'
; prefix, interpret it as hex.
;
; entry:
;
; (stringInputBufferAddress),y - string
;
; exit:
;
; X = result
; ?$e6 = result
; C=0 if error
; Z=1 if CR encountered
; 
parseNumberFromString:
                jsr skipSpacesAndCheckForCRInStringInput
                cmp #'&'                     ; hex value incoming?
                bne parseDecimal             ; taken if not hex value
parseHex:
                iny                          ; skip '&'
                jsr readHexDigit             ; read first hex digit
                bcc errorReadingString
                sta $E6                      ; save first hex digit
                jsr readHexDigit             ; read second hex digih
                bcc parsedValue         ; taken if not hex digit
                ; The first digit read was actually the high nybble,
                ; and the current digit read is therefore the low
                ; nybble.
                ;
                ; Shift saved digit 4 bits left.
                ldx #$04                     
-
                asl $E6                      
                dex                          
                bne -
                tsb $E6                      ; insert low nybble
                jsr readHexDigit             ; read third hex digit
                bcs errorReadingString2 ; 3+-digit hex values are not valid
parsedValue:
                ldx $E6
                cmp #$0D
                sec
parseDone:
                rts

parseDecimal:
                jsr readDigitFromString
                bcc errorReadingString      ;branch taken if not digit
parseDecimalDigit:
                sta $E6                     ;save current value
                jsr readNextDigitFromString
                bcc parsedValue ;branch taken if not digit, meaning number
                                     ;parsed successfully
                tax                         ;X=digit

                ; calculate (value*4+value)*2 - i.e., value*10. Carry
                ; at any point indicates the value was greater than
                ; 255, and therefore an error.
                lda $E6                     ;value
                asl a                       ;value*2
                bcs errorReadingString      
                asl a                       ;value*4
                bcs errorReadingString      
                adc $E6                     ;value*5
                bcs errorReadingString      
                asl a                       ;value*10
                bcs errorReadingString
                sta $E6                      ;save value*10
                txa                          ;A=digit
                adc $E6                      ;value*10+digit
                bcc parseDecimalDigit
errorReadingString2:
                clc
                rts

readNextDigitFromString:
                iny

; check if current string input byte is a digit.
;
; exit: C=1 if digit; C=0 if not digit
readDigitFromString:
                lda (stringInputBufferAddress),y
                cmp #'9'+1
                bcs errorReadingString       ;taken if not ASCII decimal digit
                cmp #'0'
                bcc errorReadingString       ;taken if not ASCII decimal digit
                and #$0F         ;convert ASCII decimaldigit to number
                rts

L8641:
                jsr skipSpacesAndCheckForCRInStringInput
                .if version!=350
                cmp #$0D
                .endif
errorReadingString:
                clc
                rts

;-------------------------------------------------------------------------
;
; Read a hex digit from a string
;
; entry:
;
; (stringInputBufferAddress),y = next byte to read
;
; exit:
;
; C=1 if ok: A = digit read
;
; C=0 if error: Z=1 if CR encountered
; 
readHexDigit:
                jsr readDigitFromString
                bcs +                        ; branch taken if digit
                and #$DF                     ; convert to upper case
                cmp #'F'+1
                bcs L8641    ; branch taken if not ASCII A-F hex digit
                cmp #'A'
                bcc L8641     ;branch taken if not ASCII A-F hex digit
                ; convert ASCII A-F hex digit to number.
                eor #$48
                inc a
+
                iny
                rts

;-------------------------------------------------------------------------
; 
; OSWORD 0 control block for *commands
; ====================================
commandLineUIOSWORD0Parameters:
                .word hazel.commandLine      ; address
                .byte $F0			; max # chars
                .byte $20			; min ASCII char
                .byte $7E			; max ASCII char

;-------------------------------------------------------------------------

commandLineUI:
                lda #<commandLineUIBRKHandler
                sta BRKV+0
                lda #>commandLineUIBRKHandler
                sta BRKV+1
                lda #$10|terminalROM         ;????
                sta currentLanguageROM
commandLineUILoop:
                ldx #$FF                     
                txs                          
                cli                          
                jsr selectHAZEL          
                lda #'*'                     
                jsr OSWRCH                   
                jsr readCommandLine          
                bcc +                     ;taken if ESCAPE not pressed
                jmp escapeError
+
                ldx #<hazel.commandLine     
                ldy #>hazel.commandLine     
                jsr OSCLI
                bra commandLineUILoop

commandLineUIBRKHandler:
                jsr OSNEWL                  
                ldy #$00                    
                jsr printBRKMessage
                jsr OSNEWL                  
                bra commandLineUI           

badCommandError869A:
                jmp badCommandError

readCommandLine:
                lda #$00                     
                ldx #<commandLineUIOSWORD0Parameters
                ldy #>commandLineUIOSWORD0Parameters
                jmp OSWORD                   

;-------------------------------------------------------------------------
;
; *ROMS [MasRef C.5-10]
; 
starROMS:
                jsr skipSpacesAndCheckForCRInStringInput
                bne badCommandError869A
                ldy #$0F
printROMsLoop:
                .if version<400&&version!=350
                iny                          ;ensure Y!=0
                jsr printFollowingMessage
                .text "ROM ",0
                tya                          ;A = ROM number+1
                dec a                        ;A = ROM number
                pha                          ;save ROM number
                .else
                tya
                tax
                phy
                jsr LF89A
                bcs L86D2
                jsr alwaysPrintFollowingMessage
                .text "ROM ",0
                bra L86DA
L86D2:
                jsr alwaysPrintFollowingMessage
                .text "RAM ",0
L86DA:
                ply
                tya
                .endif
                jsr printHexDigit            ;print ROM slot
                jsr printSpace               
                lda #<sidewaysROMName
                sta $F6
                lda #>sidewaysROMName
                sta $F7
                .if version<400&&version!=350
                plx                          ;restore ROM number
                .endif
                jsr isROMValidThenSelectTerminalROM
                .if version<400&&version!=350
                dey
                .endif
                bcc invalidROM
                .if version>=500||version==350
                lda romInformationTable,y
                dec a
                beq invalidROM
                .endif
printROMNameLoop:
                jsr osrdscEntryPoint     ;read name byte
                cmp #' '
                bcc printROMVersion ;taken if non-printable char, including the terminating 0
                cmp #127
                bcs invalidROM  ;taken if bad (bit 7 set) char in name
                jsr OSWRCH
                inc $F6
                bit $F6
                bvc printROMNameLoop         ;taken if address<$8040
                bra invalidROM               ;taken if name too long

printROMVersion:
                tax               ;Z=1 if final char was the expected 0
                bne invalidROM    ;taken if bad (control) char in name
                lda #<sidewaysROMVersion
                sta $F6
                lda #>sidewaysROMVersion
                sta $F7
                jsr osrdscEntryPoint
                jsr printSpaceThenPrintHexByte
printInsertionStatus:
                phy
                .if version<500&&version!=350
                jsr getROMInsertedFlagRTCAddressAndMask
                sta starROMSWorkspace.insertedFlagMask
                jsr readRTCByte
                and starROMSWorkspace.insertedFlagMask
                .else
                jsr L873F
                .endif
                bne +
                jsr alwaysPrintFollowingMessage
                .text " unplugged",0
+
                ply              
                jsr OSNEWL       
                dey              
                bpl printROMsLoop
                rts              

invalidROM:
                lda #'?'                     
                jsr OSWRCH                   
                bra printInsertionStatus

;-------------------------------------------------------------------------

                .if version>=500||version==350
L873F:
                jsr getROMInsertedFlagRTCAddressAndMask
                sta $b0
                jsr readRTCByte
                and $b0
                rts
                .endif
                
;-------------------------------------------------------------------------
;
; *INSERT [MasRef C.5-8]
; 
starINSERT:
                sec              
                bra starINSERTOrStarUNPLUG

;-------------------------------------------------------------------------
;
; *UNPLUG [MasRef C.5-13]
; 
starUNPLUG:
                clc
starINSERTOrStarUNPLUG:
                php
                jsr skipSpacesAndCheckForCRInStringInput
                .if version<500&&version!=350
                jsr parseSingle4BitNumberFromCommandLine
                .else
                jsr L8953
                .endif
                tay                          ;Y=ROM number
                jsr getROMInsertedFlagRTCAddressAndMask
                pha
                jsr readRTCByte                    
                sty starROMSWorkspace.insertedFlagMask
                pla
                plp
                bcc unplug                   ;taken if it's *UNPLUG

                ; it's *INSERT
                ora starROMSWorkspace.insertedFlagMask
                bra +
unplug:
                eor #$FF
                and starROMSWorkspace.insertedFlagMask
+
                tay
                jmp writeRTCByte

;-------------------------------------------------------------------------
;
; *TIME [MasRef C.5-12]
; 
starTIME:
                stz hazel.commandLine        
                ldx #<hazel.commandLine      
                ldy #>hazel.commandLine      
                lda #$0E                     
                jsr OSWORD                   
                ldx #256-size(ClockStringFormat)
L8752:
                lda hazel.commandLine-(256-size(ClockStringFormat)),x
                jsr OSASCI                   
                inx                          
                bne L8752                    
                rts                          

;-------------------------------------------------------------------------

                .if version==350
                .include "configure500.s65"
                .include "sram_utils.s65"
                .include "osbyte_osword_table.s65"
                .elsif version<400
                .include "configure320.s65"
                .elsif version<500
                .include "sram_utils.s65"
                .include "configure320.s65"
                .elsif version>=500
                .include "configure500.s65"
                .include "sram_utils.s65"
                .include "osbyte_osword_table.s65"
                .endif

;-------------------------------------------------------------------------

                .if version>=500
i2cTestReadEEPROMByte:
                phx
                phy
                jsr i2cReadEEPROMByte
                ply
                plx
                rts
                .endif

;-------------------------------------------------------------------------

                .if version<500&&version!=350
;-------------------------------------------------------------------------
;
; Read default *TV settings.
;
; exit:
;
; X = interlace flag (0=off, 1=on)
;
; Y = *TV offset
readDefaultTVSettings:
                ldx #CMOSBytes.defaults0+cmosBytesOffset
                jsr readRTCByte
                phy
                and #%11100000
                asl a
                rol a
                rol a
                rol a                        ;move into bottom 3 bits
                bit #$04                     ;sign bit?
                beq +                        ;taken if positive
                ora #%11111100               ;sign extent from bit 2
+
                tay
                pla
                ldx #$00                     ;X=0 - interlace off
                bit #CMOSBytes.defaults0.interlaceMask
                beq +
                inx                          ;X=1 - interlace on
+
                rts

;-------------------------------------------------------------------------
; 
; Read configured MODE
; --------------------
readDefaultMODE:
                ldx #CMOSBytes.defaults0+cmosBytesOffset
                jsr readRTCByte
                and #CMOSBytes.defaults0.modeMask|CMOSBytes.defaults0.shadowMask
                bit #CMOSBytes.defaults0.shadowMask
                beq +
                eor #$80|CMOSBytes.defaults0.shadowMask ;reset defaultSHADOWMask bit, set bit 7
+
                rts

;-------------------------------------------------------------------------
;
;
                .if version!=400
readDefaultSerialBaudRateIndex:
                jsr readDefaults2
                and #CMOSBytes.defaults2.serialBaudRateIndexMask<<CMOSBytes.defaults2.serialBaudRateIndexShift
                lsr a
                lsr a
                inc a
                rts
                .endif

;-------------------------------------------------------------------------

readDefaultFX5Settings:
                jsr readDefaults2
getTop3Bits:
                and #%11100000               ;? %abc00000
                asl a                        ;a %bc000000
                rol a                        ;b %c000000a
                rol a                        ;c %000000ab
                rol a                        ;0 %00000abc
                rts                          

;-------------------------------------------------------------------------
;
;
                .if version!=400
readDefaultSerialDataFormat:
                jsr readDefaults3
                bra getTop3Bits
                .endif

;-------------------------------------------------------------------------

readDefaultLanguageROM:
                jsr readDefaultROMs
                lsr a
                lsr a
                lsr a
                lsr a
                rts

;-------------------------------------------------------------------------
;
; 
readDefaultROMs:
                ldx #CMOSBytes.defaultROMs+cmosBytesOffset;
                bra jmpReadRTCByte

;-------------------------------------------------------------------------

readDefaultPrinterIgnoreChar:
                ldx #CMOSBytes.printerIgnoreChar+cmosBytesOffset
jmpReadRTCByte:
                jmp readRTCByte

;-------------------------------------------------------------------------

readDefaults1:
                ldx #CMOSBytes.defaults1+cmosBytesOffset
                bra jmpReadRTCByte

;-------------------------------------------------------------------------

printNo_:
                jsr alwaysPrintFollowingMessage
                .text "No ",0
                rts

;-------------------------------------------------------------------------
                .endif

;-------------------------------------------------------------------------
;
; [MasRef G.5-8]
;
starPRINT:
                lda #$C0
                sta hazel.fsFlags
                bra L8ED2

;-------------------------------------------------------------------------

starLIST:
                lsr hazel.fsFlags
                stz hazel.lineNumberBCD+0
                stz hazel.lineNumberBCD+1
                bra L8ECF

;-------------------------------------------------------------------------

starTYPE:
                sec
                ror hazel.fsFlags
L8ECF:
                lsr hazel.fsFlags
L8ED2:
                stz hazel.lastCharPrinted
                jsr openFileForReading
L8ED8:
                bit $FF
                bmi handleESCAPEWithFileOpen
                jsr OSBGET
                bcs closeFile
                bit hazel.fsFlags
                bvs L8EEB
                pha
                jsr printLineNumber
                pla
L8EEB:
                bit hazel.fsFlags
                bmi L8F04
                cmp #$0D
                beq L8F14
                cmp #$0A
                beq L8F14
                sta hazel.lastCharPrinted
                cmp #'"'
                beq L8F04
                jsr printGSREADChar
                bra L8F07

L8F04:
                jsr OSWRCH
L8F07:
                jsr bgetAndCheckForESCAPE
                bcc L8EEB
printNewLineThenCloseFile:
                jsr OSNEWL
closeFile:
                lda #$00
                jmp OSFIND

L8F14:
                cmp hazel.lastCharPrinted
                beq L8F29
                pha
                lda hazel.lastCharPrinted
                cmp #$0D
                beq L8F34
                cmp #$0A
                beq L8F34
                pla
                sta hazel.lastCharPrinted
L8F29:
                jsr OSNEWL
                bra L8ED8

;-------------------------------------------------------------------------
;
; Tidily handle ESCAPE when a file is open during *DUMP or whatever.
; Prints a new line, closes the file, then does an Escape error.
;
; entry:
;
; Y = file handle
; 
handleESCAPEWithFileOpen:
                jsr printNewLineThenCloseFile
                jmp escapeError

;-------------------------------------------------------------------------

L8F34:
                pla
                stz hazel.lastCharPrinted
                bra L8F07

;-------------------------------------------------------------------------
;
; Does an OSBGET and handles ESCAPE.
;
; entry:
;
; Y = file handle
;
; exit:
;
; A = byte read
; C=1 if EOF
; (as per OSBGET)
;
bgetAndCheckForESCAPE:
                jsr OSBGET
                bit $FF
                bmi handleESCAPEWithFileOpen
                rts

;-------------------------------------------------------------------------
;
; *DUMP [MasRef G.5-4]
; 
starDUMP:
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                ldx #$00
                jsr clearOSFILEParameterBlockDWORD
                ldx #$04
                jsr clearOSFILEParameterBlockDWORD
                ldy #$00
                lsr hazel.tempFSFlag
                jsr gsinitForFilenameParsing
L8F58:
                jsr gsreadEntryPoint
                bcc L8F58
                beq L8F79
                ldx #$00
                jsr parseHexAddressFromCommandLine

                ldx #$03
-
                lda osfileParameterBlock+0,x
                sta osfileParameterBlock+4,x
                dex
                bpl -
                
                jsr skipSpacesAndCheckForCRInStringInput
                beq L8F79
                ldx #$04
                jsr parseHexAddressFromCommandLine
L8F79:
                ldy stringInputBufferAddress+1
                ldx stringInputBufferAddress+0
                asl hazel.tempFSFlag
                jsr openFileForReading
                
                lda #argsFileGetEXT
                jsr callOSARGSWithBuffer
                
                ldx #$03
L8F8A:
                lda osargsBuffer,x
                cmp osfileParameterBlock+0,x
                bcc L8FFB
                bne L8F96
                dex
                bpl L8F8A
L8F96:
                ldx #$03
-
                lda osfileParameterBlock+0,x
                sta osargsBuffer,x
                dex
                bpl -
                jsr setFilePointerFromOSARGSBuffer
L8FA3:
                ldx #$00
                jsr OSBGET
                bcs L8FF0
                jsr L9239
                pha
                lda osfileParameterBlock+4
                and #$07
                beq L8FCA
                phy
                tay
L8FB7:
                phy
                jsr alwaysPrintFollowingMessage
                .text "   ",0
                ply
                lda #$20
                sta osfileParameterBlock+8,x
                inx
                dey
                bne L8FB7
                ply
L8FCA:
                pla
L8FCB:
                pha
                cmp #32
                bcc nonPrintable
                cmp #127
                bcc L8FD6                    ;taken if printable
nonPrintable:
                lda #'.'          ;placeholder for non-printable chars
L8FD6:
                sta osfileParameterBlock+8,x
                pla
                jsr printSpaceThenPrintHexByte
                inx
                jsr L9248
                lda osfileParameterBlock+4
                and #$07
                beq L8FF3
                jsr bgetAndCheckForESCAPE
                bcc L8FCB
                jsr L9257
L8FF0:
                jmp closeFile

L8FF3:
                jsr L9257
                bra L8FA3

L8FF8:
                jmp notFoundError

L8FFB:
                jsr closeFile
                jsr doFollowingError
                .text $b7,"Outside file",0

;-------------------------------------------------------------------------
;
; *BUILD
; 
starBUILD:
                lsr hazel.fsFlags            ;clear bit 7 of fsFlags
                bra starBUILDOrAPPEND

;-------------------------------------------------------------------------
;
; *APPEND
; 
starAPPEND:
                sec
                ror hazel.fsFlags            ;set bit 7 of fsFlags
starBUILDOrAPPEND:
                ; bit 7 of fsFlags indicates *BUILD (clear) or *APPEND
                ; (set).
                stz hazel.lineNumberBCD+0    ;reset line number
                stz hazel.lineNumberBCD+1    ;reset line number
                lda #$80                     ;open for output. Assume *BUILD
                bit hazel.fsFlags            ;test *BUILD/*APPEND
                bpl +                        ;branch taken if *BUILD
                lda #$C0                     ;*APPEND, so open for update
+
                jsr OSFIND                   ;open the file
                tay                          ;Y=file handle
                beq L8FF8                    ;branch taken if open failed
                sty osfileParameterBlock+0   ;save file handle
                jsr setPTRToEOF ;move to EOF (effective no-op when *BUILD)
L9033:
                jsr printLineNumber
L9036:
                .if version<500&&version!=350
                jsr readCommandLine
                .else
                lda #0
                ldx #<starBuildOrAPPENDOSWORD0Parameters
                ldy #>starBuildOrAPPENDOSWORD0Parameters
                jsr OSWORD
                .endif
                php
                bcc L904B
                ; Handle ESCAPE
                jsr OSNEWL
                lda #$0D
                sta hazel.commandLine,y      ;terminate current line
L9044:
                phy                          ;save line length
                lda #$7E
                jsr OSBYTE                   ;acknowledge ESCAPE
                ply                          ;restore line length
L904B:
                tya                          ;A=line length
                beq L909E                    ;taken if line empty
                jsr setStringInputBufferToCommandLine
                ldy #$00                     
                ldx #$00                     
L9055:
                jsr LF29C
                sta hazel.commandLine,x
                lda #stringInputOptions.goodString
                bit stringInputOptions
                bne L906C
                lda #7
                jsr OSWRCH                   ;beep
                jsr L91F5
                plp
                bra L9036

L906C:
                inx
                bcc L9055
                plp
                bcc L9073
                dex
L9073:
                php
                phx
                ldx #size(OSGBPBParameterBlock)-2
L9077:
                stz osfileParameterBlock+1,x
                dex
                bpl L9077
                plx
                stx osfileParameterBlock+OSGBPBParameterBlock.count+0
                .cerror (<hazel.commandLine)!=0,"hazel.commandLine must be page aligned"
                lda #>hazel.commandLine
                sta osfileParameterBlock+OSGBPBParameterBlock.address+1
                dec osfileParameterBlock+OSGBPBParameterBlock.address+2
                dec osfileParameterBlock+OSGBPBParameterBlock.address+3
                lda #gbppPutBytesCurrentPTR
                ldx #<osfileParameterBlock
                ldy #>osfileParameterBlock
                jsr OSGBPB
                plp
                bcc L9033
L9098:
                ldy osfileParameterBlock+0
                jmp closeFile

L909E:
                plp
                bcs L9098
                lda #13
                ldy osfileParameterBlock
                jsr OSBPUT
                bra L9033

setStringInputBufferToCommandLine:
                lda #$41
                sta $E4
                .cerror (<hazel.commandLine)!=0,"hazel.commandLine must be page aligned"
                stz stringInputBufferAddress+0
                lda #>hazel.commandLine
                sta stringInputBufferAddress+1
                rts

;-------------------------------------------------------------------------

                .if version>=500||version==350
starBuildOrAPPENDOSWORD0Parameters:
                .word hazel.commandLine      ;address
                .byte $f0                    ;max # chars
                .byte 0                      ;min char
                .byte 255                    ;max char
                .endif
                
;-------------------------------------------------------------------------
; 
; *MOVE
; 
starMOVE:
                lda ACCCON                    ; Save ACCCON
                sta hazel.oldACCCON
                pha                          ; Save ACCCON and command line pointer
                phx
                phy
                ldy #$80                     ; Top of available shadow memory at &8000
                lda STATE                      ; Get VDU status
                bit #$10                     ; Jump if not shadow screen, spare up to &8000
                beq L90CE
; Shadow screen selected
                jsr LF1C0                ; Get screen bottom to XY
                cpy #$30                     ; Screen at &3000, no spare memory, jump to use Hazel
                beq L90E2

; Non-shadow or small shadow screen selected
; Y=top of available memory in shadow memory
L90CE:
                lda #$30                     ; &3000=start of shadow memory
                sta hazel.moveBufferMSB
                lda #ACCCON.X
                tsb ACCCON
                sta hazel.hasACCCONChanged      ; set 'ACCCON changed'
                tya                          ; A=length of space in shadow memory
                sec
                sbc hazel.moveBufferMSB
                bra L90E9

; No shadow memory available, use Hazel
L90E2:
                lda #$DD                     ; Buffer at &DD00
                sta hazel.moveBufferMSB
                lda #$02                     ; Buffer length=&200

; &DFD6=high byte of buffer address
; A=high byte of buffer length
L90E9:
                sta hazel.moveNumPages      ; Store buffer length
                ply                          ; Get command line pointer
                plx
                phx
                phy
                lda #$40                     ; Open source file
                jsr OSFIND
                tay                          ; Store source handle, jump if not found
                sty hazel.moveSrcHandle
                beq L9134
                ply                          ; Get command line back again
                plx
                stx $F2
                sty $F3
                phx                          ; And save it again
                phy
                ldy #$00                     ; Step past first parameter
                jsr gsinitForFilenameParsing
L9108:
                jsr gsreadEntryPoint     ;
                bcc L9108
                tya                          ; Save address of dest filename
                clc
                adc $F2
                sta hazel.moveDestName+0
                tax
                lda $F3
                adc #$00
                sta hazel.moveDestName+1
                tay                          ; Temporary filing system flag
                asl hazel.tempFSFlag
                lda #$80                     ; Open destination file
                jsr OSFIND
                tay                          ; Store dest handle, jump if opened
                sty hazel.moveDestHandle
                bne L9137

; Couldn't open destination
                ldy hazel.moveSrcHandle      ; Get source handle and clear it
                stz hazel.moveSrcHandle
                jsr OSFIND                   ; Close source file
L9134:
                jmp notFoundError                    ; Jump to 'Not found' error

; Source and dest opened
; ----------------------
; Build OSGBPB source file control block at &02ED
; and destination control block at &DFC7
L9137:
                ldx #$07
L9139:
                stz @w osfileParameterBlock+OSGBPBParameterBlock.address,x ; Addr=0, Num=0
                stz hazel.moveOSGBPB+1,x
                dex
                bpl L9139
                lda hazel.moveSrcHandle      ; Source handle
                sta osfileParameterBlock+OSGBPBParameterBlock.handle
                lda hazel.moveBufferMSB      ; Buffer address
                sta osfileParameterBlock+OSGBPBParameterBlock.address+1
                sta hazel.moveOSGBPB.addr+1
                lda hazel.moveNumPages
                sta osfileParameterBlock+OSGBPBParameterBlock.count+1
                sta hazel.moveOSGBPB.numBytes+1
                dec osfileParameterBlock+OSGBPBParameterBlock.address+2 ; Source addr=&FFFFxxxx
                dec osfileParameterBlock+OSGBPBParameterBlock.address+3
                dec hazel.moveOSGBPB.addr+2
                dec hazel.moveOSGBPB.addr+3

; Should use &FFFExxxx and let filing system select correct memory
; Unfortunately, CFS/RFS and DFS do not recognise &FFFExxxx, so
; *MOVE has to do it itself, causing problems for filing systems
; that /do/ recognise &FFFExxxx where they have to remember to
; *do* *nothing* for &FFFFxxxx instead of select main memory as
; &FFFFxxxx implies.

                ldx #<osfileParameterBlock                     ; XY=>source OSGBPB block
                ldy #>osfileParameterBlock
                lda #$04                     ; Read data from source
                jsr OSGBPB
                php                          ; Jump if not at end of file
                bcc L9183
; End of file, adjust destination buffer length for final part
                lda #$00
                sbc osfileParameterBlock+OSGBPBParameterBlock.count+0
                sta hazel.moveOSGBPB.numBytes+0
                lda hazel.moveOSGBPB.numBytes+1
                sbc osfileParameterBlock+OSGBPBParameterBlock.count+1
                sta hazel.moveOSGBPB.numBytes+1
L9183:
                lda hazel.moveDestHandle      ; Destination handle
                sta hazel.moveOSGBPB.handle
                lda #$02                     ; XY=>control block, A=write
                ldx #<hazel.moveOSGBPB
                ldy #>hazel.moveOSGBPB
                jsr OSGBPB
                plp                          ; Loop until end of file
                bcc L9137
                lda #$00
                ldy hazel.moveSrcHandle      ; Get and clear source handle
                stz hazel.moveSrcHandle
                phy                          ; Close source file
                jsr OSFIND
                lda #$00                     ; Get dest handle
                ldy hazel.moveDestHandle
                phy                          ; Clear dest handle and close file
                stz hazel.moveDestHandle
                jsr OSFIND
                ply                          ; Dest not CFS/RFS, jump to...
                cpy #$04
                bcs L91BD
                ply                          ; Pop source handle
L91B3:
                ply                          ; Restore XY
                plx
L91B5:
                pla                          ; Clear 'ACCCON changed', restore ACCCON
                stz hazel.hasACCCONChanged
                sta ACCCON
                rts

L91BD:
                ply                          ; Source was CFS/RFS, jump to exit
                cpy #$04
                bcc L91B3
                ply                          ; Point to first parameter
                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
                plx
                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
                ldx #<osfileParameterBlock
                ldy #>osfileParameterBlock
                lda #$05                     ; Read info on source file
                jsr OSFILE
                lda hazel.moveDestName+0      ; Get address of dest filename
                sta osfileParameterBlock+OSFILEParameterBlock.fileName+0
                lda hazel.moveDestName+1      ;  and put in control block
                sta osfileParameterBlock+OSFILEParameterBlock.fileName+1
                lda #$F0                     ; Mask out 'public' access bits
                trb osfileParameterBlock+OSFILEParameterBlock.attributes+0
                lda #$01                     ; Write info on dest file
                jsr OSFILE
                bra L91B5                    ; Jump to restore ACCCON and exit

printLineNumber:
                ldx #$00
                sec
                jsr adcLineNumberBCDX        ;increment line number LSB
                inx                          
                jsr adcLineNumberBCDX        ;carry into line number MSB
L91F5:
                sec                          ;printing leading 0s
                lda hazel.lineNumberBCD+1    ;get line number MSB
                jsr printPossiblyLeading0s
                lda hazel.lineNumberBCD+0    ;get line number LSB
                pha                          ;save line number LSB
                php                          ;save C
                .if version==350
                jsr LE520
                .else
                lsr a
                lsr a
                lsr a
                lsr a
                .endif
                plp                          ;restore  C
                jsr printPossiblyLeading0    ;print line number 3rd digit
                pla                          ;restore line number LSB
                clc                ;always print line number 4th digit
                jsr printPossiblyLeading0    ;
                jmp printSpace                    ;

printPossiblyLeading0s:
                pha                          ;save value
                php                          ;save C
                .if version==350
                jsr LE520
                .else
                lsr a
                lsr a
                lsr a
                lsr a
                .endif
                plp                          ;restore C
                jsr printPossiblyLeading0    ;print 1st digit
                pla                          ;restore value
printPossiblyLeading0:
                and #$0F                     ;get digit to print
                bne printNonLeading0         ;always print if non-0
                bcc printNonLeading0 ;branch taken if not leading 0
                lda #$20             ;print space instead of leading 0
                jsr OSWRCH
                sec                ;indicate still in leading 0s state
                rts

printNonLeading0:
                jsr printHexDigit            ;print digit
                clc                          ;no longer in leading 0s state
                rts                          ;

adcLineNumberBCDX:
                lda #$00
                sed
                adc hazel.lineNumberBCD,x
                sta hazel.lineNumberBCD,x
                cld
rts9238:
                rts

;-------------------------------------------------------------------------

L9239:
                phx
                pha
                ldx #$02
L923D:
                lda osfileParameterBlock+4,x
                jsr printHexByte
                dex
                bpl L923D
                bra L9254

;-------------------------------------------------------------------------

L9248:
                phx
                pha
                ldx #256-4
L924C:
                inc osfileParameterBlock+4-(256-4),x
                bne L9254
                inx
                bne L924C
L9254:
                pla
                plx
                rts

L9257:
                phy
                phx
L9259:
                cpx #$08
                beq L9267
                jsr alwaysPrintFollowingMessage
                .text "   ",0
                inx
                bra L9259

L9267:
                plx
                jsr printSpace
                ldy #$00
L926D:
                lda osfileParameterBlock+8,y
                jsr OSWRCH
                iny
                dex
                bne L926D
                ply
                jmp OSNEWL

;-------------------------------------------------------------------------

                .if version!=350
                .include "restore_font.s65"
                .endif
                
;-------------------------------------------------------------------------
;
; Clear 4 bytes in the OSFILE parameter block.
;
; entry:
;
; X = offset of the 4 bytes to clear
; 
clearOSFILEParameterBlockDWORD:
                stz osfileParameterBlock+0,x
                stz osfileParameterBlock+1,x
                stz osfileParameterBlock+2,x
                stz osfileParameterBlock+3,x
rts94A4:
                rts

;-------------------------------------------------------------------------
;
; Read a 32-bit hex value from a string.
;
; entry:
;
; X = offset into osfileParameterBlock to store the value
;
; exit:
;
; C=0 if error

parseHexAddressFromString:
                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
                jsr readHexDigit
                bcc rts92F4
                jsr clearOSFILEParameterBlockDWORD
readDigitsLoop:
                phy
                rol a
                rol a
                rol a
                rol a                        ;put digit in top 4 bits
                ldy #$04
shiftIn1DigitLoop:
                rol a
                rol osfileParameterBlock+0,x
                rol osfileParameterBlock+1,x
                rol osfileParameterBlock+2,x
                rol osfileParameterBlock+3,x
                bcs badAddressError ;carry out of bit 31 implies too many digits
                dey
                bne shiftIn1DigitLoop
                ply
                jsr readHexDigit
                bcs readDigitsLoop   ;keep going until hex digits stop
                sec       ;got at least 1 hex digit, so result is good
rts92F4:
                rts

;-------------------------------------------------------------------------
; 
; *GO (<addr>) [MasRef C.5-6]
;
starGO:
                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
                bne starGOIO             ; Jump to read parameters
                jmp commandLineUI        ; No parameters, enter CLICOM

;-------------------------------------------------------------------------
; 
; *GOIO <addr> [MasRef C.5-7]
; 
starGOIO:
                ldx #$00
                jsr parseHexAddressFromCommandLine ; Read hex address
                jsr skipSpacesAndCheckForCRInStringInput ; Skip spaces
                php  ; Update &F2/3 to point to any further parameters
                tya
                clc
                adc stringInputBufferAddress+0
                sta stringInputBufferAddress+0
                bcc +
                inc stringInputBufferAddress+1
+
                ldy #$00    ; (&F2),y=>parameters, EQ if no parameters
                plp
                jmp (osfileParameterBlock+0) ; Jump to address

;-------------------------------------------------------------------------

starLOAD:
                lda #fileLoad
starCommandThroughOSFILE:
                lsr hazel.tempFSFlag
L931B:
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
                pha                          ;save OSFILE reason
                ldx #OSFILEParameterBlock.load
                jsr clearOSFILEParameterBlockDWORD
                ldx #OSFILEParameterBlock.length
                jsr clearOSFILEParameterBlockDWORD
                ldy #$FF
                sty osfileParameterBlock+OSFILEParameterBlock.exec+0 ;by default, load to file's load address
                iny                                                  ;Y=0
                jsr gsinitForFilenameParsing
L9339:
                jsr gsreadEntryPoint
                bcc L9339
                pla                          ;restore OSFILE reason
                pha                          ;save OSFILE reason
                bpl finishStarSAVE                    ;taken if *SAVE
                ldx #OSFILEParameterBlock.load
                jsr parseHexAddressFromString ;parse *LOAD address
                bcs doStarLOADWithExplicitAddress ;taken if good address
                beq L9366        ;taken if CR encountered (this is ok)
badAddressError:
                jsr doFollowingError
                .text $fc,"Bad address",0

;-------------------------------------------------------------------------
;
; Parse hex address from command line.
;
parseHexAddressFromCommandLine:
                jsr parseHexAddressFromString ; Read hex address
                bcc badAddressError           ; Jump with bad address
                rts

;-------------------------------------------------------------------------

doStarLOADWithExplicitAddress:
                bne badCommandError93E2
                inc osfileParameterBlock+OSFILEParameterBlock.exec+0 ;load to parameter block load address
L9366:
                asl hazel.tempFSFlag
callOSFILEWithOSFILEParameterBlock:
                ldx #<osfileParameterBlock
                ldy #>osfileParameterBlock
                pla
                jmp OSFILE

;-------------------------------------------------------------------------
;
; *REMOVE [MasRef G.5-9]
; 
starREMOVE:
                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
                .if version>=510||version==350
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                ldy #$ff
L9596:
                iny
                lda (stringInputBufferAddress),y
                cmp #'!'
                bcs L9596
                jsr skipSpacesAndCheckForCRInStringInput
                bne badCommandError93E2
                .endif
                lda #fileDelete
                pha
                bra callOSFILEWithOSFILEParameterBlock

;-------------------------------------------------------------------------
                .if version<510&&version!=350
;
; *CLOSE [MasRef G.5-3]
; 
starCLOSE:
                jsr skipSpacesAndCheckForCRInStringInput
                bne badCommandError93E2
                lda #$00                     
                tay                          
                jmp (FINDV)                  ;OSFIND A=0 Y=0
                .endif
;-------------------------------------------------------------------------
                .if version<510&&version!=350
;
; *IGNORE [MasRef C.5-7]
; 
starIGNORE:
                bne L938E
                sec
                ror noignoreState
                rts
                
L938E:
                lda #$06
                bra starCommandThroughOSBYTE
                .endif
;-------------------------------------------------------------------------

finishStarSAVE:
                bne L939B
                ldx #OSFILEParameterBlock.saveStart
                jsr parseHexAddressFromString
                bcc badCommandError93E2
L939B:
                clv
                lda (stringInputBufferAddress),y
                cmp #'+'
                bne L93A6                    ;taken if "*SAVE START END..."
                bit valueFF              ;V=1
                iny
L93A6:
                ldx #OSFILEParameterBlock.saveEnd
                jsr parseHexAddressFromString
                bcc badCommandError93E2
                php
                bvc L93BF                    ;taken if "*SAVE START END"

                ; Get the save end address.
                ldx #256-4
                clc
-
                ; TODO - not sure why the @w notation is required here?
                lda@w osfileParameterBlock+OSFILEParameterBlock.saveStart-(256-4),x
                adc@w osfileParameterBlock+OSFILEParameterBlock.saveEnd-(256-4),x
                sta@w osfileParameterBlock+OSFILEParameterBlock.saveEnd-(256-4),x
                inx
                bne -
L93BF:

                ; Initialize load and exec addresses to save start
                ; address.
                ldx #$03
-
                lda@w osfileParameterBlock+OSFILEParameterBlock.saveStart,x
                sta@w osfileParameterBlock+OSFILEParameterBlock.exec,x
                sta@w osfileParameterBlock+OSFILEParameterBlock.load,x
                dex
                bpl -
                
                plp
                beq L9366
                
                ldx #OSFILEParameterBlock.exec
                jsr parseHexAddressFromString
                bcc badCommandError93E2
                beq L9366
                
                ldx #OSFILEParameterBlock.load
                jsr parseHexAddressFromString
                bcc badCommandError93E2
                beq L9366
                
badCommandError93E2:
                jmp badCommandError

;-------------------------------------------------------------------------

starFX:
                jsr parseNumberFromString
                bcc badCommandError93E2
                txa
starCommandThroughOSBYTE:
                php
                lsr hazel.tempFSFlag
                plp
                pha
                stz $E5
                stz $E4
                jsr LF308
                beq L9412
                jsr parseNumberFromString
                bcc badCommandError93E2
                stx $E5
                jsr LF30A
                beq L9412
                jsr parseNumberFromString
                bcc badCommandError93E2
                stx $E4
                jsr skipSpacesAndCheckForCRInStringInput
L9625:
                bne badCommandError93E2
L9412:
                ldy $E4
                ldx $E5
                pla
                asl hazel.tempFSFlag
                jsr OSBYTE
                bvs badCommandError93E2
L941F:
                rts

;-------------------------------------------------------------------------

starSPOOLON:
                sec
                bra starSPOOL

;-------------------------------------------------------------------------

                .if version>=510||version==350
starSHADOW:
                lda #$72
L963A:
                bra starCommandThroughOSBYTE
                .endif
                
;-------------------------------------------------------------------------

L9423:
                ldx #romServiceCallSpoolExecClosureWarning
                jsr makeROMServiceCall
                beq L941F
                jsr LA58B
                lda spoolFileHandle
                jsr LA56B
starSPOOL:
                php
                phy
                ldy spoolFileHandle
                sta spoolFileHandle
                beq L9440
                jsr OSFIND
L9440:
                lsr hazel.tempFSFlag
                ply
                plp
                beq L941F
                lda #$80
                bcc L944D
                lda #$C0
L944D:
                asl hazel.tempFSFlag
                jsr OSFIND
                tay
                beq badCommandError93E2
                sta spoolFileHandle
                tay
setPTRToEOF:
                lda #argsFileGetEXT
                jsr callOSARGSWithBuffer
setFilePointerFromOSARGSBuffer:
                lda #argsFileSetPTR
callOSARGSWithBuffer:
                ldx #osargsBuffer
                jmp OSARGS

;-------------------------------------------------------------------------

                .if version<510&&version!=350
starSHADOW:
                lda #$72
                bra starCommandThroughOSBYTE
                .endif

;-------------------------------------------------------------------------

                .if version>=510||version==350
starCLOSE:
                jsr skipSpacesAndCheckForCRInStringInput
                bne L9625
                lda #$00                     
                tay                          
                jmp (FINDV)                  ;OSFIND A=0 Y=0
                .endif

;-------------------------------------------------------------------------

                .if version>=510||version==350
starIGNORE:
                bne L938E
                sec
                ror noignoreState
                rts
                
L938E:
                lda #$06
                bra L963A
                .endif
                
;-------------------------------------------------------------------------
; 
starDELETE:
                jsr starREMOVE
                tay
                bne L941F
                jmp notFoundError

;-------------------------------------------------------------------------

                .if version==350
                .include "rtc.s65"
                .include "restore_font.s65"
                .endif

;-------------------------------------------------------------------------

                .if version==350
parseSoftKeyNumberFromCommandLine:
                jsr parseNumberFromString
                bcc badKeyError
                cpx #softKeyCount
                .if version==350
                bcc rts9922
                .else
                bcc L96BE
                .endif
badKeyError:
                jsr doFollowingError
                .byte $FB
                .text "Bad key"
                .byte 0
                .endif
                
;-------------------------------------------------------------------------

                .if version>=510||version==350
starSHOW:
                lda (stringInputBufferAddress),y
                eor #13
                bne L96BF
                tax
L96A5:
                jsr alwaysPrintFollowingMessage
                .text "Key ",0

                phx
                txa
                jsr printHexDigit
                jsr printSpace
                jsr printKeyDefinition
                plx
                inx
                cpx #$10
                bcc L96A5
L96BE:
                rts

L96BF:
                jsr parseSoftKeyNumberFromCommandLine
                jsr skipSpacesAndCheckForCRInStringInput
L96C5:
                bne badKeyError
                .endif

;-------------------------------------------------------------------------

                .if version<510&&version!=350
parseSoftKeyNumberFromCommandLine:
                jsr parseNumberFromString
                bcc badKeyError
                cpx #softKeyCount
                bcc L941F
badKeyError:
                jsr doFollowingError
                .byte $FB
                .text "Bad key"
                .byte 0
                .endif

;-------------------------------------------------------------------------
;
; [MasRef C.5-11]
;

                .if version<510&&version!=350
starSHOW:
                jsr parseSoftKeyNumberFromCommandLine
                jsr skipSpacesAndCheckForCRInStringInput
                bne badKeyError
                .else
printKeyDefinition:
                .endif
                lda #'"'
                jsr OSWRCH
                lda $F4
                pha
                jsr selectTerminalROMAndANDY2
                lda andy.softKeys.stringLSBs,x
                sta stringInputBufferAddress+0
                lda andy.softKeys.stringMSBs,x
                sta stringInputBufferAddress+1
                .if version<510&&version!=350
                ldy $E6
                .else
                txa
                tay
                .endif
                jsr getSoftKeyStringLength
                tay                          ;Y = string length
                beq starSHOWDone                    ;done if length=0
-
                lda (stringInputBufferAddress)
                jsr printGSREADChar
                inc stringInputBufferAddress+0
                bne +
                inc stringInputBufferAddress+1
+
                dey
                bne -
starSHOWDone:
                pla     
                jsr selectROMA
                lda #'"'
                jsr OSWRCH        
                jmp OSNEWL        

;-------------------------------------------------------------------------

                .if version>=510
parseSoftKeyNumberFromCommandLine:
                jsr parseNumberFromString
                bcc badKeyError
                cpx #softKeyCount
                bcc L96BE
badKeyError:
                jsr doFollowingError
                .byte $FB
                .text "Bad key"
                .byte 0
                .endif
                
;-------------------------------------------------------------------------
;
; [MasRef C.5-8]
; 
starKEY: .proc
                jsr parseSoftKeyNumberFromCommandLine
                lda $F4                      
                pha                          
                jsr selectTerminalROMAndANDY 
                jsr skipSpacesAndCheckForCRInStringInput
                stz starKEYWorkspace.newStringLength
                beq commandLineTailEmpty
                ldx #$00
                sec
                jsr gsinitEntryPoint
-
                jsr gsreadEntryPoint
                bcs bneBadKeyError
                sta hazel.commandLine,x
                inx
                bra -

bneBadKeyError:
                .if version==350
                bne L96C5
                .else
                bne badKeyError
                .endif
                stx starKEYWorkspace.newStringLength
commandLineTailEmpty:
                ldy $E6                        ;Y = soft key number
                jsr getSoftKeyStringLength                
                sta starKEYWorkspace.counter+0
                sec                          
                sbc starKEYWorkspace.newStringLength ;A=existing len-new len
                bcs newStringWillFit            ;taken if new string shorter, meaning it'll definitely fit

                eor #$FF                     
                adc #$01                     ;A=new len-existing len
                adc andy.softKeys.endLSB
                tax
                lda andy.softKeys.endMSB
                adc #$00
                cmp #>(andy.softKeys.end)
                bcc newStringWillFit

                ; Produce slightly cryptic "Bad key" if string won't
                ; fit.
                bne bneBadKeyError
                txa
                bne bneBadKeyError
newStringWillFit:
                lda softKeyStringLength
                beq storeNewString          ;taken if new string empty
                lda currentSoftKey
                cmp $E6
                bcc storeNewString ;taken if current soft key<key - expansion will not need to relocate
                bne relocateCurrentSoftKeyExpansion ;taken if current soft key>key - expansion must relocate
                jsr doFollowingError
                .text $fa,"Key in use",0
relocateCurrentSoftKeyExpansion:
                stz starKEYWorkspace.destPtr+1
                sec
                lda starKEYWorkspace.newStringLength
                sbc starKEYWorkspace.counter+0
                sta starKEYWorkspace.destPtr+0
                bcs +
                dec starKEYWorkspace.destPtr+1
+
                clc
                lda softKeyExpansionPtr+0
                adc starKEYWorkspace.destPtr+0
                sta softKeyExpansionPtr+0
                lda softKeyExpansionPtr+1
                adc starKEYWorkspace.destPtr+1
                sta softKeyExpansionPtr+1
storeNewString:
                dec softKeyConsistencyFlag   ;mark soft keys inconsistent
                ldx $E6                      ;X=key number
                lda starKEYWorkspace.counter+0
                beq makeSpaceForNewString ;taken if no existing string for this soft key

                ; delete existing string
                lda andy.softKeys.stringLSBs,x
                sta starKEYWorkspace.destPtr+0
                lda andy.softKeys.stringMSBs,x
                sta starKEYWorkspace.destPtr+1
                lda andy.softKeys.stringLSBs+1,x
                sta starKEYWorkspace.srcPtr+0
                lda andy.softKeys.stringMSBs+1,x
                sta starKEYWorkspace.srcPtr+1
deleteExistingStringLoop:
                ; copy byte (with postincrement)
                lda (starKEYWorkspace.srcPtr)
                sta (starKEYWorkspace.destPtr)

                ; increment destPtr
                inc starKEYWorkspace.destPtr+0
                bne +
                inc starKEYWorkspace.destPtr+1
+

                ; increment srcPtr
                inc starKEYWorkspace.srcPtr+0
                bne +
                inc starKEYWorkspace.srcPtr+1
+

                ; keep copying until end of buffer reached.
                lda starKEYWorkspace.srcPtr+0
                cmp andy.softKeys.endLSB
                lda starKEYWorkspace.srcPtr+1
                sbc andy.softKeys.endMSB
                bcc deleteExistingStringLoop

                ; update following strings' start addresses, which all
                ; move down by the old string's length.
updateAddressesLoop:
                inx
                cpx #softKeyCount+1
                bcs makeSpaceForNewString
                sec
                lda andy.softKeys.stringLSBs,x
                sbc starKEYWorkspace.counter+0
                sta andy.softKeys.stringLSBs,x
                bcs updateAddressesLoop
                dec andy.softKeys.stringMSBs,x
                bra updateAddressesLoop

makeSpaceForNewString:
                ldx $E6
                lda starKEYWorkspace.newStringLength
                beq done
                lda andy.softKeys.endLSB
                sta starKEYWorkspace.srcPtr+0
                clc
                adc starKEYWorkspace.newStringLength
                sta starKEYWorkspace.destPtr+0 ;new end ptr LSB
                lda andy.softKeys.endMSB
                sta starKEYWorkspace.srcPtr+1
                adc #$00
                sta starKEYWorkspace.destPtr+1 ;new end ptr MSB
                lda starKEYWorkspace.srcPtr+0
                sec
                sbc andy.softKeys.stringLSBs,x
                sta starKEYWorkspace.counter+0
                lda starKEYWorkspace.srcPtr+1
                sbc andy.softKeys.stringMSBs,x
                sta starKEYWorkspace.counter+1
makeSpaceForNewStringLoop:
                ; loop while counter>0
                lda starKEYWorkspace.counter+0
                ora starKEYWorkspace.counter+1
                beq updateAddressesLoop2

                ; decrement destPtr
                lda starKEYWorkspace.destPtr+0
                bne +
                dec starKEYWorkspace.destPtr+1  
+
                dec starKEYWorkspace.destPtr+0

                ; decrement srcPtr
                lda starKEYWorkspace.srcPtr+0  
                bne +
                dec starKEYWorkspace.srcPtr+1  
+
                dec starKEYWorkspace.srcPtr+0

                ; copy byte (with predecrement)
                lda (starKEYWorkspace.srcPtr)
                sta (starKEYWorkspace.destPtr)

                ; decrement counter
                lda starKEYWorkspace.counter+0
                bne +
                dec starKEYWorkspace.counter+1  
+
                dec starKEYWorkspace.counter+0
                
                bra makeSpaceForNewStringLoop

                ; update following strings' start addresses, which all
                ; move up by the new string's length.
updateAddressesLoop2:
                inx      
                cpx #softKeyCount+1
                bcs copyNewString
                lda andy.softKeys.stringLSBs,x
                adc starKEYWorkspace.newStringLength  
                sta andy.softKeys.stringLSBs,x
                bcc updateAddressesLoop2
                inc andy.softKeys.stringMSBs,x
                bra updateAddressesLoop2

copyNewString:
                ldy #$00
copyNewStringLoop:
                lda hazel.commandLine,y
                sta (starKEYWorkspace.srcPtr),y
                iny
                dec starKEYWorkspace.newStringLength
                bne copyNewStringLoop
done:
                inc softKeyConsistencyFlag   ;mark soft keys consistent
                pla                          
                jmp selectROMA
                .endproc       

;-------------------------------------------------------------------------
;
; Print char, printing control codes using the string reader escape
; syntax. [MasRef C.5-8]
;
printGSREADChar: .proc
                tax                          ;X=char
                bmi printHighBitChar
                cmp #$20
                bcc printControlChar
                inx
                bmi vdu127
                dex                          ;restore old char
                cmp #'"'
                beq printEscapedX
                cmp #'|'
                bne printA
                ; print "||"
                jsr OSWRCH
printA:
                jmp OSWRCH

vdu127:
                ; print "|?"
                jsr printEscapeChar
                lda #'?'
                bra printA

printEscapedX:
                jsr printEscapeChar
                txa
                bra printA

printControlChar:
                ora #$40
                tax
                bra printEscapedX

printHighBitChar:
                pha
                ldx #'!'
                jsr printEscapedX
                pla
                and #$7F
                bra printGSREADChar

printEscapeChar:
                lda #'|'
                bra printA
                .endproc

;-------------------------------------------------------------------------

                .if version!=350
                .include "rtc.s65"
                .endif
                
;-------------------------------------------------------------------------

L9923:
                lda #$03
                jsr LD298
                bcc L993C
                jsr L9930
                jsr LD8A9
L9930:
                ldx #$20
                jmp LE2B8

L9935:
                lda #$02
                jsr LD298
                bcs L99A0
L993C:
                jsr LD3D2
                jsr L9ABF
                bra L994C

L9944:
                jsr LD41A
                beq L99A0
                jsr LD3D2
L994C:
                lda $E1
                bit #$20
                beq L9957
                pha
                jsr LD6A3
                pla
L9957:
                bit #$10
                beq L995E
                jsr LD698
L995E:
                jsr L99FC
                php
                jsr L9A5A
                ldx #$42
                ldy #$46
                lda #$20
                bit L8849
                beq L998C
                bmi L998A
                lda $032C
                cmp $0337
                bne L9982
                lda $032D
                cmp $0338
                beq L9992
L9982:
                ldx #$37
                jsr LD24D
                ldx #$42
                clv
L998A:
                ldy #$2C
L998C:
                bmi L9995
                bvc L9992
                ldx #$37
L9992:
                jsr LD24D
L9995:
                plp
                bcc L994C
                rts

L9999:
                lda #$01
                jsr LD298
                bcc L99A9
L99A0:
                ldx #$24
                bra L99DB

L99A4:
                jsr LD41A
                beq L99A0
L99A9:
                jsr LD3D2
                jsr L99C9
L99AF:
                jsr LD5E6
                jsr L99C9
                lda L8830
                ora L8831
                beq L99FB
                bit L8848
                bvs L99AF
                ldx #$42
                jsr L99D6
                bra L99AF

L99C9:
                jsr LD334
                jsr L99DE
                bit L8848
                bmi L99FB
                ldx #$46
L99D6:
                phx
                jsr LD280
                plx
L99DB:
                jmp plotPointInternal

L99DE:
                ldx #$03
L99E0:
                lda L8830,x
                sta $0342,x
                sta $0346,x
                dex
                bpl L99E0
L99EC:
                ldy $0342
                lda $0343
                jsr negateAY
                sty $0342
                sta $0343
L99FB:
                rts

L99FC:
                lda $E1
                sta L8849
                jsr L99DE
                ldx #$01
L9A06:
                stz $0342,x
                stz $0346,x
                dex
                bpl L9A06
L9A0F:
                jsr L9A2E
                lda L8830
                ora L8831
                bne L9A20
                sec
                lda L8847
                bne L99EC
L9A20:
                jsr LD5E6
                lda L8832
                cmp $0344
                beq L9A0F
                clc
                bra L99EC

L9A2E:
                jsr LD334
                bit L8848
                bmi L9A3D
                php
                ldx #$46
                jsr L9A41
                plp
L9A3D:
                bvs L9A59
                ldx #$42
L9A41:
                lda L8830
                tay
                cmp $0300,x
                lda L8831
                pha
                sbc $0301,x
                pla
                bcc L9A59
                sta $0301,x
                tya
                sta $0300,x
L9A59:
                rts

L9A5A:
                lda $0344
                ora $0345
                bne L9ABE
                lda $E1
                inc a
                and #$03
                bne L9ABE
                lda #$20
                bit L8849
                bpl L9A79
                beq L9A79
                ldx #$2C
                ldy #$46
                jsr copyFourBytesWithinVDUVariables
L9A79:
                lda #$10
                bit L8849
                bvc L9A89
                beq L9A89
                ldx #$37
                ldy #$42
                jsr copyFourBytesWithinVDUVariables
L9A89:
                jsr L9ABF
                lda $E1
                eor #$3C
                rol a
                jsr fixUpVPALETTEFor4Colours
                ror a
                sta $E1
                bit #$20
                beq L9AAB
                pha
                ldx #$2C
                ldy #$46
                jsr sortVDUVariableWords
                tya
                tax
                ldy #$46
                jsr copyFourBytesWithinVDUVariables
                pla
L9AAB:
                bit #$10
                beq L9ABB
                ldx #$37
                ldy #$42
                jsr sortVDUVariableWords
                ldy #$42
                jsr copyFourBytesWithinVDUVariables
L9ABB:
                stz L8849
L9ABE:
                rts

L9ABF:
                ldx #$03
L9AC1:
                stz $033B,x
                dex
                bpl L9AC1
                ldy #$28
                ldx #$1B
                lda #$2C
                jsr L9ADF
                jsr LD6A8
                ldy #$1B
                ldx #$28
                lda #$37
                jsr L9ADF
                jmp LD69D

L9ADF:
                pha
                lda $E1
                lsr a
                bcc L9AF0
                lda L8847
                bne L9AEE
                ldx #$3B
                bra L9AF0

L9AEE:
                ldy #$3B
L9AF0:
                txa
                plx
                phx
                pha
                phy
                tay
                lda #$03
                sta $DA
L9AFA:
                lda $0300,y
                sta L881E,x
                iny
                inx
                dec $DA
                bpl L9AFA
                ply
                pla
                plx
L9B09:
                pha
                phy
                jsr L9B61
                dex
                ply
                pla
                phx
                iny
                iny
                inc a
                inc a
                inx
                inx
                jsr L9B61
                plx
                jsr L9B90
                php
                pha
                lda $0305,x
                asl a
                ror $030A,x
                bpl L9B2D
                jsr L9B7F
L9B2D:
                pla
                asl a
                ror $030A,x
                bpl L9B3B
                inx
                inx
                jsr L9B7F
                dex
                dex
L9B3B:
                jsr L9B90
                bpl L9B46
                lda $0305,x
                ldy $0304,x
L9B46:
                plp
                bmi L9B4F
                cpy #$00
                bne L9B4E
                dec a
L9B4E:
                dey
L9B4F:
                lsr a
                pha
                tya
                ror a
                sec
                dex
                jsr L9B5A
                inx
                pla
L9B5A:
                sbc $0307,x
                sta $0309,x
                rts

L9B61:
                pha
                lda $0300,y
                sta $0300,x
                lda $0301,y
                sta $0301,x
                ply
                sec
                jsr L9B75
                inx
                iny
L9B75:
                lda $0300,y
                sbc $0300,x
                sta $0304,x
                rts

L9B7F:
                lda $0305,x
                ldy $0304,x
                jsr negateAY
                sta $0305,x
                tya
                sta $0304,x
                rts

L9B90:
                lda $0306,x
                tay
                cmp $0304,x
                lda $0307,x
                sbc $0305,x
                php
                lda $0307,x
                plp
                rts

;-------------------------------------------------------------------------
;
; 112–119 = Plot parallelogram [MasRef E.3-27]
;
plotParallelogram:
                ldx #$28
                stx $DA
                ldx #$14
                ldy #$20
                lda #$24
                jsr addRegionDimensionsToVDUVariableCoordinates
                ldy #$14
                ldx #$24
                jsr sortVDUVariableCoordinates
                stx L8830
                ldx #$20
                jsr sortVDUVariableCoordinates
                stx L8831
                ldx #$28
                jsr sortVDUVariableCoordinates
                sty L8833
                ldy L8831
                jsr sortVDUVariableCoordinates
                sty L8832
                ldy L8830
                jsr L9C0F
                lda L8833
                sta $E0
                ldx #$2C
                jsr L9B09
                ldy $E1
                jsr L9C56
                ldy L8832
                lda L8833
                sta $E1
                ldx #$37
                jsr L9C51
                bra L9C0C

L9BF7;
                ldy #$14
                ldx #$24
                jsr sortVDUVariableCoordinates
                sty L8832
                ldy #$20
                jsr L9C0F
                lda L8832
                jsr L9C4D
L9C0C:
                jmp LDAE4

L9C0F:
                jsr sortVDUVariableCoordinates
                stx L8830
                ldx L8832
                jsr sortVDUVariableCoordinates
                sty L8832
                stx L8831
                ldy L8830
                ldx #$FC
L9C26:
                lda $0300,y
                sta vduv.workspace._42-$fc,x
                sta vduv.workspace._46-$fc,x
                iny
                inx
                bne L9C26
                ldy L8830
                lda L8832
                sta $E1
                ldx #$37
                jsr L9B09
                ldy L8830
                lda L8831
                jsr L9C4D
                ldy L8831
                rts

L9C4D:
                sta $E0
                ldx #$2C
L9C51:
                jsr L9B09
                ldy $E0
L9C56:
                phy
                lda $0302,y
                cmp $0344
                bne L9C67
                lda $0303,y
                cmp $0345
                beq L9CA0
L9C67:
                ldx #$2C
                jsr L9CC0
                ldx #$37
                jsr L9CC0
                jsr LDAE4
                ldx #$37
                jsr LD726
                ldx #$2C
                jsr LD726
                ldy #$37
                jsr sortVDUVariableWords
                phx
                ldx #$FC
L9C86:
                lda $0300,y
                sta vduv.workspace._46-$fc,x
                iny
                inx
                bne L9C86
                plx
                ldy #$FC
L9C93:
                lda $0300,x
                sta vduv.workspace._42-$fc,y
                inx
                iny
                bne L9C93
                ply
                bra L9C56

L9CA0:
                lda #$2C
                ldx $E0
                jsr L9CAC
                ply
                lda #$37
                ldx $E1
L9CAC:
                sta $DE
                lda vduv.graphicsWindowPixelsBottom+0,x
                cmp vduv.graphicsWindowPixelsBottom+0,y
                bne L9CBE
                lda vduv.graphicsWindowPixelsBottom+1,x
                cmp vduv.graphicsWindowPixelsBottom+1,y
                beq L9CC3
L9CBE:
                ldx $DE
L9CC0:
                jsr LD71D
L9CC3:
                lda $0300,x
                cmp $0342
                lda $0301,x
                sbc $0343
                bpl L9CDE
                lda $0300,x
                sta $0342
                lda $0301,x
                sta $0343
                rts

L9CDE:
                lda $0346
                cmp $0300,x
                lda $0347
                sbc $0301,x
                bpl L9CF8
                lda $0300,x
                sta $0346
                lda $0301,x
                sta $0347
L9CF8:
                rts

L9CF9:
                jsr LDDA1
                stz $0336
                stz $0337
                jsr LDCB0
                bne L9D56
                jsr LDC1C
L9D0A:
                bit $FF
                bmi L9D56
                lda $0336
                cmp $0337
                beq L9D56
                inc a
                sta $0336
                tax
                lda L8400,x
                sta $0328
                lda L8500,x
                sta $032C
                lda L8600,x
                pha
                lsr a
                lsr a
                sta $0329
                pla
                and #$03
                sta $032D
                lda L8700,x
                stz $032B
                cmp $0306
                beq L9D4B
                sta $E0
                inc a
                jsr LDC48
                bcs L9D56
                lda $E0
L9D4B:
                cmp $0302
                beq L9D0A
                dec a
                jsr LDC48
                bcc L9D0A
L9D56:
                rts

L9D57:
                lda $0332
                tay
                cmp $032C
                lda $0333
                tax
                sbc $032D
                bcs L9D71
                iny
                bne L9D6B
                inx
L9D6B:
                sty $032E
                stx $032F
L9D71:
                rts

;-------------------------------------------------------------------------

                .if version>=500
readDefaults2:
                ldx #CMOSBytes.defaults2
                bra readRTCByte
                .endif

;-------------------------------------------------------------------------

                .if version>=500
readDefaults3:
                ldx #CMOSBytes.defaults3
                bra readRTCByte
                .endif

;-------------------------------------------------------------------------
;
; Read byte from EEPROM by 0-based CMOS RAM offset (readCMOSByte) or
; RTC register index (readRTCByte).
;
; (The number of RTC registers on the Compact is 0, so readRTCByte and
; readCMOSByte use the same indexes. Nevertheless, the two routines
; behave differently... presumably I still haven't quite got this bit
; right.)
;
; entry:
;
; X = address to read from
;
; exit:
;
; Y = byte read

                .if version>=500
readCMOSByte:
                cpx #$ff
                bne readRTCByte              ; taken if address not $ff
                jsr i2cTestReadEEPROMByte    ; do an experimental read
                ldy #0                       ; failure result is 0
                bcs rts9DE0                  ; taken if read failed
                ldx #$7f                          
                jsr i2cReadEEPROMByte        ; read the byte at $7f
                phy                          ; save the byte read
                ldx #$ff                     
                jsr i2cReadEEPROMByte        ; read the byte at $ff
                tya                          ; A = byte from $ff
                tsx
                eor $101,x          ; difference between the two reads
                ora #$7f            ; ?????
                tay                 ; and... that is the result?????
                bra plx_rts9DDF
                .endif

                .if version>=500
readRTCByte: .block
                phx
                jsr i2cTestReadEEPROMByte
                bcc addressIsValid           ; taken if read succeeded
readDefaultByte:
                ldy #0                 ; default failure result is 0
                cpx #size(CMOSBytes)   ; trying to read a known value?
                bcs gotResult   ; taken if failed to read an unknown value
                ldy L9DE4,x      ; use a default value for failed read
                bra gotResult

addressIsValid:
                jsr i2cReadEEPROMByte
gotResult:
                tya
                .cerror *!=plx_rts9DDF
                .endblock
plx_rts9DDF:
                plx
rts9DE0:
                rts

readDefaultCMOSByte:
                phx
                bra readRTCByte.readDefaultByte

L9DE4:
                ; Default EEPROM contents? For use if the EEPROM runs
                ; out of write cycles?
                .byte 0                      ; econetStationNumber
                .byte 254                    ; fileServerStationNumber
                .byte 0                      ; fileServerNetworkNumber
                .byte $EB                    ; printerServerStationNumber
                .byte 0                      ; printerServerNetworkNumber
                .byte 14<<CMOSBytes.defaultROMs.languageShift|13<<CMOSBytes.defaultROMs.fsShift
                .byte $FF                    ; insertedROMS 8-15
                .byte $FF                    ; insertedROMS 0-7
                .byte 0                      ; editROMBytes
                .byte 0                      ; telecommsByte
                .cerror !(defaultMODE>=0&&defaultMODE<=7||defaultMODE>=128&&defaultMODE<=135)
                .byte (defaultMODE&7)<<CMOSBytes.defaults0.modeShift|((defaultMODE&$80)!=0?CMOSBytes.defaults0.shadowMask:0)|CMOSBytes.defaults0.interlaceMask|7<<CMOSBytes.defaults0.tvShift ; defaults0
                .byte 3<<CMOSBytes.defaults1.fdriveShift|CMOSBytes.defaults1.capsLockMask|CMOSBytes.defaults1.adfsLoadDirMask|CMOSBytes.defaults1.floppyDrive ; defaults1
                .byte 32                     ; keyboardAutoRepeatDelay
                .byte 8                      ; keyboardAutoRepeatRate
                .byte $A                     ; printerIgnoreChar
                .byte 1<<CMOSBytes.defaults2.fx5SettingShift|3<<CMOSBytes.defaults2.serialBaudRateIndexShift ; defaults2
                .byte 4<<CMOSBytes.defaults3.serialDataFormatShift ; defaults3
                .byte 0                      ; unknown11
                .byte 3                      ; joystick
                .if version>=511||olivetti
                .byte 4                      ; country
                .endif
                .cerror *-L9DE4!=size(CMOSBytes)
                .endif

;-------------------------------------------------------------------------

                .if version>=500
rts9DF7:
                rts
writeCMOSByte:
                txa
                and #$7f
                beq rts9DF7              ; taken if address $00 or $80
                ora #$80
                inc a                    
                beq rts9DF7              ; taken if address $7f or $ff
writeRTCByte:
                phx
                phy
                jsr L9E99
                ply
                plx
                rts
                .endif

;-------------------------------------------------------------------------
;
; Transmit 1 bit over the I2C bus.
;
; preserves: P
; 
                .if version>=500
i2cTransmitBit:
                php
                sei
                jsr i2cSetClockLow
                jsr i2cSetData
                jsr i2cSetClockHigh
                jsr i2cSetClockLow
                plp
                rts
                .endif

;-------------------------------------------------------------------------
;
; Set the I2C clock line high.
;
; preserves: A/C
; 
                .if version>=500
i2cSetClockHigh:
                pha
                lda systemVIA.irb
                and #~i2cClock               ; seems needless?
                ora #i2cClock
                sta systemVIA.orb
                pla
                rts
                .endif

;-------------------------------------------------------------------------
;
; Set the I2C clock line low.
;
; preserves: A/C
; 
                .if version>=500
i2cSetClockLow:
                pha
                lda systemVIA.irb
                and #~i2cClock
                sta systemVIA.orb
                pla
                rts
                .endif

;-------------------------------------------------------------------------
;
; "A change in the state of the data line, from HIGH to LOW, while the
; clock is HIGH, defines the START condition."
;
; preserves: P
                .if version>=500
i2cStartDataTransfer:
                php
                sei
                lda systemVIA.ddrb
                ora #i2cClock|i2cData        ; I2C lines are outputs
                sta systemVIA.ddrb
                jsr i2cSetClockLow
                jsr i2cSetDataHigh
                jsr i2cSetClockHigh
                jsr i2cSetDataLow
                jsr i2cSetClockLow
                plp
                rts
                .endif

;-------------------------------------------------------------------------
;
; Set the I2C data line low.
;
; preserves: A/C
; 
                .if version>=500
i2cSetDataLow:
                pha
                lda systemVIA.irb
                and #~i2cData
                sta systemVIA.orb
                pla
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9E58:
                jsr i2cStartDataTransfer
                lda #0                       ; What is this value?
                jsr i2cTransmitByteAndReceiveBit
                lda #6                       ; What is this value?
                jsr i2cTransmitByteAndReceiveBit
                .cerror *!=i2cStopDataTransfer

;-------------------------------------------------------------------------
;
; "A change in the state of the data line, from LOW to HIGH, while the
; clock is HIGH, defines the STOP condition."
; 
i2cStopDataTransfer:
                php
                sei
                jsr i2cSetClockLow
                jsr i2cSetDataLow
                jsr i2cSetClockHigh
                jsr i2cSetDataHigh
                jsr i2cSetClockLow
                lda systemVIA.ddrb
                and #~(i2cData|i2cClock)     ; I2C lines are inputs
                sta systemVIA.ddrb
                plp
                rts
                .endif

;-------------------------------------------------------------------------
;
; Set the I2C data line to a particular value.
;
; entry:
;
; C = state of signal: 1 = high, 0 = low
;
; preserves: C

                .if version>=500
i2cSetData:
                bcc i2cSetDataLow
                .cerror *!=i2cSetDataHigh
                .endif

;-------------------------------------------------------------------------
;
; Set the I2C data line high.
;
; preserves: A/C
; 
                .if version>=500
i2cSetDataHigh:
                pha
                lda systemVIA.irb
                ora #i2cData
                sta systemVIA.orb
                pla
                rts
                .endif

;-------------------------------------------------------------------------
;
; Transmits 1 byte/8 bits over the I2C bus.
;
; entry: A = byte to transmit

                .if version>=500
i2cTransmitByte: .block
                php
                sei
                sec
                rol a
loop:
                jsr i2cTransmitBit
                asl a
                bne loop
                plp
                rts
                .endblock
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9E99: .block
                phx                          ; X
                phy                          ; Y X
                jsr i2cReadEEPROMByte
                bcs writeIfCarry ; taken if read failed. Attempt write anyawy
                
                ; Compare new value to old value, and write only if
                ; different. Don't use up the EEPROM write cycles
                ; unnecessarily.
                tya
                tsx                          ; | Y X
                eor $101,x                   ; Y^(old Y)
                cmp #1  ; C set if new value is different, so attempt write
writeIfCarry:
                ply
                plx
                bcs write
                rts

write:
                jsr i2cStartDataTransfer
                lda #eepromWrite
                jsr i2cTransmitByteAndReceiveBit ; initiate write mode
                txa
                jsr i2cTransmitByteAndReceiveBit ; send address
                tya
                jsr i2cTransmitByteAndReceiveBit ; send value
                jsr i2cStopDataTransfer

                ; After writing 1 or 2 bytes and entering the STOP
                ; state, the write process begins, Delay ~100 ms to
                ; wait for it. (The data sheet implies 20 ms/byte is
                ; sufficient, but surely no harm in waiting longer.)
                ldy #$a0
                ldx #0
delayLoop:
                dex
                bne delayLoop
                dey
                bne delayLoop
                rts
                .endblock

;-------------------------------------------------------------------------
;
; Read 1 byte from EEPROM
;
; entry:
;
; X = address to read from
;
; exit:
;
; C=0 = success
;       Y = byte read
; C=1 = failure
; 
i2cReadEEPROMByte:
                jsr i2cStartDataTransfer

                ; Send %1010, I2C address, and not-write flag
                lda #eepromWrite
                jsr i2cTransmitByteAndReceiveBit

                ; Send word address
                txa
                jsr i2cTransmitByteAndReceiveBit
                bcs L9F0E_500              ; taken if not acknowledged

                ; And again, this time in read mode
                jsr i2cStartDataTransfer
                lda #eepromRead
                jsr i2cTransmitByteAndReceiveBit
                bcs L9F0E_500                ; taken if not acknowledged
                
                jsr i2cSetClockLow
                lda systemVIA.ddrb
                pha                          ; save old DDRB
                and #~i2cData
                sta systemVIA.ddrb           ; set I2C data line as input
                lda #1                 ; add terminating bit to result
L9EF0:
                pha                          ; save current result
                jsr i2cSetClockHigh
                nop                          ; wait +1 microsecond
                nop                          ; wait +1 microsecond
                lda systemVIA.irb
                and #i2cData
                cmp #1                       ; C=1 if data received
                jsr i2cSetClockLow          
                pla                          ; restore current result
                rol a                        ; shift new bit in
                bcc L9EF0                    ; keep going until 8 bits
                                             ; shifted in
                tay
                pla                          ; restore old DDRB
                sta systemVIA.ddrb
                sec 
                jsr i2cTransmitBit           ; transmit acknowledge bit
                clc                          ; success - clear carry
L9F0E_500:
                jmp i2cStopDataTransfer
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9F11:
                jsr i2cStartDataTransfer
                lda #eepromWrite
                jsr i2cTransmitByteAndReceiveBit
                txa
                jsr i2cTransmitByteAndReceiveBit
                php
                jsr i2cStopDataTransfer
                plp
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
i2cTransmitByteAndReceiveBit: .block
                php
                sei
                jsr i2cTransmitByte
                jsr i2cSetClockLow
                lda systemVIA.ddrb
                pha
                and #~i2cData
                sta systemVIA.ddrb           ; set data line as input
                jsr i2cSetClockHigh
                nop
                nop
                lda systemVIA.irb
                and #i2cData
                cmp #1                       ; C=bit read
                jsr i2cSetClockLow
                pla
                sta systemVIA.ddrb
                bcs returnWithCarrySet
                plp
                clc
                rts

returnWithCarrySet:
                plp
                sec
                rts
                .endblock
                .endif

;-------------------------------------------------------------------------

                .if version>=500
                .include "sound_stuff.s65"
                .endif

;-------------------------------------------------------------------------

                .if version==400
                .include "ext.s65"
                .endif

;-------------------------------------------------------------------------
;
; Utils/Terminal ROM service entry point.
;
utilsServiceEntryPoint:
                .if version==400
                ; this is the same as the MOS 5.00 code, but I didn't
                ; get the if arrangement right. This needs improving.
                cpx #terminalROM
                beq utilsInCorrectBank
                rts
utilsInCorrectBank:
                .endif
                .if version<500
                cmp #romServiceCallTubeSystemPostInitialisation
                bcc handleNonTube
                bne handleTubeMainInitialisation
handleTubeSystemPostInitialisation:
                cpy #$00           
                beq handleNonTube

                ; [Tube p28] - write out the startup message that the
                ; second processor has been stuck trying to write out.
writeSecondProcessorStartupMessageLoop:
                bit tube.status1
                bpl writeSecondProcessorStartupMessageLoop
                lda tube.data1  
                beq L9DCA       
                jsr OSWRCH      
                jmp writeSecondProcessorStartupMessageLoop

handleTubeMainInitialisation:
                lda #<tubeHost.eventHandler
                sta EVENTV+0
                lda #>tubeHost.eventHandler
                sta EVENTV+1
                lda #<tubeBrkHandlerAddr
                sta BRKV+0
                lda #>tubeBrkHandlerAddr
                sta BRKV+1
                lda #tube.status1.S|tube.status1.M|tube.status1.J|tube.status1.I;
                sta tube.status1

                ; Copy Tube host code into main RAM.
                ldy #$00
-
                lda tubeHost.codePage0,y
                sta tubeHostAddr+0*256,y
                lda tubeHost.codePages12,y
                sta tubeHostAddr+1*256,y
                lda tubeHost.codePages12+256,y
                sta tubeHostAddr+2*256,y
                dey                   
                bne -
                
                jsr tubeHost.resetTubeClaim

                ; Copy BRK handler into zero page.
                ldx #size(tubeHost.brkHandler)
-
                lda tubeHost.brkHandler,x
                sta @w tubeBrkHandlerAddr,x
                dex
                bpl -

L9DCA:
                lda #$00                     ; Claim call and return

handleNonTube:
                .elsif version>=500
                cpx #terminalROM
                beq utilsInCorrectBank
                rts
utilsInCorrectBank:
                bra handleInitialiseFilingSystem
L9DCA:
                lda #$00
handleInitialiseFilingSystem:
                .endif
                cmp #romServiceCallInitialiseFilingSystem
                bne handleBreakInstruction
                .if version==400
                cpy #fsROM
                bne L9E16
                .else
                cpy #fsTapeOrROMMax+1
                bcs L9E16                    ; taken if not tape/rom
                cpy #fsNone
                beq L9E16                    ; taken if no FS
                ldx #3                       ; assume tape, 300 baud tape
                tya                          ; Y = FS number
                cmp #fs300BaudTape
                bcs L9DE3              ; taken if 300 baud tape or ROM
                ldx #$00               ; X=0 for 1200 baud
                adc #$02            ; adjust so that the result of the
                                    ; following adc will be $8c
L9DE3:
                adc #$89                     ; Convert to TAPE/ROM select value
                .endif
                jsr selectROMOrTAPEByOSBYTE
                bra L9DCA                    ; Jump to claim and return

handleBreakInstruction:
                cmp #romServiceCallBreakInstruction
                bne handleCloseAllOpenFiles
                lda hazel.hasACCCONChanged ; Skip if ACCCON not changed
                beq closeMoveSrcHandle
                stz hazel.hasACCCONChanged ; Clear ACCCON changed flag
                lda hazel.oldACCCON        ; Restore ACCCON
                sta ACCCON
closeMoveSrcHandle:
                phy
                ldy hazel.moveSrcHandle
                beq closeMoveDestHandle
                stz hazel.moveSrcHandle
                jsr closeFile
closeMoveDestHandle:
                ldy hazel.moveDestHandle
                beq L9E13
                stz hazel.moveDestHandle
                jsr closeFile
L9E13:
                ply
                lda #romServiceCallBreakInstruction ; restore A
L9E16:
                rts
handleCloseAllOpenFiles:
                cmp #romServiceCallCloseAllOpenFiles
                bne handleHelp
                .if version!=400
                lda #$8D
                jsr L9E2C
                ldx #$03
                lda #$04
                bit $C6
                beq L9E2A
                ldx #$00
L9E2A:
                lda #$8C
L9E2C:
                .endif
                jsr selectROMOrTAPEByOSBYTE
                lda #$00
                tay
                jsr osfindTapeOrROM
                lda #$26
                rts

handleHelp
                cmp #romServiceCallHelp
                .if version<400&&includeTerminalROM
                bne handleTerminal
                .else
                bne LA304
                .endif
                phy
                lda ($F2),y
                cmp #$0D
                bne L9E61
                jsr L9EFC
                jsr alwaysPrintFollowingMessage
                .text "  MOS",13
                .if version<400&&includeTerminalROM
                .text 13,"TERMINAL 1.20",13
                .elsif version==500
                .text 13,"UTILS 1.00",13
                .elsif version==510
                .if olivetti
                .text 13,"UTILS 1.10C",13
                .else
                .text 13,"UTILS 1.10",13
                .endif
                .elsif version==511
                .text 13,"UTILS 1.10C",13
                .endif
                .text 0
                bra L9E8B
L9E61:
                ldx #size(mosHelpSubject)-1
L9E63:
                lda (stringInputBufferAddress),y
                cmp #'.'
                beq L9E95
                and #$DF
                cmp mosHelpSubject,x
                bne L9E7B
                iny
                dex
                bpl L9E63
                lda (stringInputBufferAddress),y
                jsr isLetter
                bcs L9E95
L9E7B:
                lda (stringInputBufferAddress),y
                cmp #13
                beq L9E8B
                iny
                cmp #' '
                bne L9E7B
                jsr skipSpacesAndCheckForCRInStringInput
                bne L9E61
L9E8B:
                ply
                lda #romServiceCallHelp
LA304:
                rts

                .if version<400&&includeTerminalROM
handleTerminal:
                jmp terminalServiceEntryPoint
                .endif

mosHelpSubject: .text "SOM"

L9E95:
                jsr L9EFC
                lda #<mosCommandTable
                sta terminalHELPWorkspace.tablePtr+0
                lda #>mosCommandTable
                sta terminalHELPWorkspace.tablePtr+1
L9EA0:
                lda (terminalHELPWorkspace.tablePtr)
                bmi L9EF4
                .if version==400
                cmp #'a'
                bcs LA711
                .endif
                jsr printSpace
                jsr printSpace
                lda (terminalHELPWorkspace.tablePtr)
L9EAC:
                .if version==400
                cmp #'a'
                bcs LA711
                .endif
                jsr L9F0E
LA711:
                inc terminalHELPWorkspace.tablePtr+0
                bne L9EB5
                inc terminalHELPWorkspace.tablePtr+1
L9EB5:
                lda (terminalHELPWorkspace.tablePtr)
                bpl L9EAC

                ; add 4 to tablePtr
                lda #$04
                clc
                adc terminalHELPWorkspace.tablePtr+0
                sta terminalHELPWorkspace.tablePtr+0
                bcc +
                inc terminalHELPWorkspace.tablePtr+1
+
                jsr LE25C
                cpx #19
                beq L9EEF
L9ECB:
                jsr getTextCursorPositionWithColumn81
                txa
                beq L9EA0
                cpx #20
                beq L9EA0
                bcc L9EE4
                cpx #40
                beq L9EA0
                bcs L9EE9
                jsr LE25C
                cpx #39
                beq L9EEF
L9EE4:
                jsr printSpace
                bra L9ECB

L9EE9:
                cpx #60
                bcc L9EE4
                beq L9EA0
L9EEF:
                jsr printNewLine
                bra L9EA0

L9EF4:
                jsr getTextCursorPositionWithColumn81
                txa      
                beq L9E8B
                bra L9EEF

L9EFC:
                phy
                jsr alwaysPrintFollowingMessage
                .text 13,versionString,13,0
                ply
                rts

;-------------------------------------------------------------------------
;
printSpace:
                lda #$20          
L9F0E:
                phx               
                ldx $B0           
                phx               
                ldx $B1           
                jsr OSWRCH        
restoreB1AndB0:
                stx $B1           
                plx               
                stx $B0           
                plx               
                rts               

;-------------------------------------------------------------------------

printNewLine:
                phx               
                ldx $B0           
                phx               
                ldx $B1           
                jsr OSNEWL        
                bra restoreB1AndB0

;-------------------------------------------------------------------------

; TAPE/ROM OSARGS handler
; =======================
osargsTapeOrROM:
                cpy #$00       ; Handle<>0 - read/write open file info
                bne L9F3B
                ora #$00 ; A<>0 - read/write filing system info - exit
                bne L9F3A

; A=0, Y=0 - read current filing system
; -------------------------------------
                lda #$03                     ; Prepare A=ROMFS
                .if version!=400
                bit cfsRFSFSSwitch           ; If TAPE/ROM switch
                bne L9F3A
                and $C6           ; Mask with speed to give A=2 or A=1
                .endif

; TAPE/ROM FSC 6 - shut down FS
; TAPE/ROM FSC 8 - OS command
; TAPE/ROM FSC 10 - *INFO
; -----------------------------
L9F3A:
                rts

; OSARGS handle<>0 - red/write open file info
; -------------------------------------------
L9F3B:
                cmp #$00                     ; Not =PTR, exit unsupported
                bne L9F3A
                cpy #$02                     ; =PTR#2 - read PTR on output handle
                beq L9F60

; Read PTR on CFS/RFS input file
; ------------------------------
                lda #$01                     ; Check if this is input channel and is open
                jsr LAA68
                lda $039E
                sta $00,x
                phy
                lda $03DE
                ldy $03DD
                bne L9F57
                dec a
L9F57:
                dey
                sty $01,x
                ply
L9F5B:
                sta $02,x
                stz $03,x
                rts

; Read PTR on TAPE output file
; ----------------------------
L9F60:
                lda #$02                     ; Check if this is output channel and is open
                jsr LAA68
                lda $039D                    ; Copy PTR to control block
                sta $00,x
                lda $0394
                sta $01,x
                lda $0395
                bra L9F5B

;-------------------------------------------------------------------------

; TAPE/ROM FSC dispatch table
; ---------------------------
                
tapeAndROMFSCRoutine: .macro addr,shift
                .byte ((\addr)-1)>>(\shift)&$ff
                .endmacro
                
tapeAndROMFSCRoutinesTable: .macro shift
                .tapeAndROMFSCRoutine LA422,\shift ;0 - *OPT
                .tapeAndROMFSCRoutine LA4F1,\shift ;1 - EOF
                .tapeAndROMFSCRoutine LA110,\shift ;2 - */
                .tapeAndROMFSCRoutine LA129,\shift ;3 - unknown * command
                .tapeAndROMFSCRoutine LA110,\shift ;4 - *RUN
                .tapeAndROMFSCRoutine LA168,\shift ;5 - *CAT
                .tapeAndROMFSCRoutine L9F3A,\shift ;6 - shut down FS
                .tapeAndROMFSCRoutine L9F9E,\shift ;7 - obtain file handle range
                .tapeAndROMFSCRoutine L9F3A,\shift ;8 - OS command
                .tapeAndROMFSCRoutine LA155,\shift ;9 - *EX
                .tapeAndROMFSCRoutine L9F3A,\shift ;10 - *INFO
                .tapeAndROMFSCRoutine LA113,\shift ;11 - *RUN command for library
                .endmacro
                
L9F74:
                .tapeAndROMFSCRoutinesTable 0
L9F80:
                .tapeAndROMFSCRoutinesTable 8

;-------------------------------------------------------------------------

; TAPE/ROM FSC
; ============
fscTapeOrROM:
                cmp #$0C                     ; function<12 - exit unchanged
                bcs L9F3A
                stx $BC                      ; Index into dispatch table
                tax
                lda L9F80,x
                pha
                lda L9F74,x
                pha
                ldx $BC
                rts

; TAPE/ROM FSC 7 - obtain file handle range
; -----------------------------------------
L9F9E:
                ldx #$03
                ldy #$03
                .if version!=400
                lda cfsRFSFSSwitch
                bne L9F3A
                dey
                ldx #$01
                .endif
                rts

L9FAB:
                pla
                plp
                sec
                rts

L9FAF:
                php
                pha
                jsr LA9F3
                lda $03C2
                pha
                jsr LA502
                pla
                bcs L9FAB
                beq L9FD9
                ldx #$03
                lda #$FF
L9FC4:
                pha
                lda $03BE,x
                sta $B0,x
                pla
                and $B0,x
                dex
                bpl L9FC4
                inc a
                bne L9FD9
                jsr LA9B1
                jmp badAddressError

L9FD9:
                lda $03CA
                lsr a
                pla
                pha
                beq L9FF1
                bcc L9FF8
L9FE3:
                jsr LA9BB
                jsr doFollowingError
                .text $d5,"Locked",0
L9FF1:
                bcc L9FF8
                lda #$03
                sta breakAndESCAPEEffect
L9FF8:
                lda #$30
                and $BB
                beq LA002
                lda $C1
LA000:
                bne LA00A
LA002:
                .if version<500
                phy
                jsr LAAA4
                ply
                .endif
                jsr LA6D2
LA00A:
                jsr LA8A1
                bne LA066
                jsr LAA35
                bit $03CA
                bmi LA01F
                jsr LA85B
                jsr LA678
                bra L9FF8

LA01F:
                pla                          ; RUN, no control block to update
                beq LA055
                ldy #$02
LA024:
                lda $03BC,y                  ; Copy load/exec to control block
                sta ($C8),y
                iny
                cpy #$0A
                bne LA024
                lda $03C8                    ; Length b0-b7=Block Length b0-b7
                sta ($C8),y
                iny
                lda $03C9
                clc
                adc $03C6                    ; Length b8-b15=Block Number+Block Length b8-b15
                sta ($C8),y
                iny
                lda #$00
                adc $03C7                    ; Length b16-b23=overflow
                sta ($C8),y
                iny                          ; Length b24-b31=&00
                lda #$00
                sta ($C8),y
                iny
LA04B:
                lda $03BD,y                  ; Attrs=&00000000
                sta ($C8),y
                iny
                cpy #$12
                bne LA04B
LA055:
                plp
LA056:
                jsr LA9B1
LA059:
                bit $BA                      ; If flag set, skip printing newline
                bmi LA064
LA05D:
                php                          ; Print inline text
                jsr LA923
                .byte 13                     ; Could just do JSR OSNEWL
                .byte 0
                plp
LA064:
                clc
                rts

LA066:
                jsr LA506
                bne L9FF8
LA06B:
                stx $F2
                sty $F3
                ldy #$00
                jsr gsinitForFilenameParsing
                ldx #$00
LA076:
                jsr gsreadEntryPoint
                bcs LA088
                beq LA085
                sta $03D2,x
                inx
                cpx #$0B
                bne LA076
LA085:
                jmp badStringError

LA088:
                stz $03D2,x
                rts

; CFS/RFS OSFILE
; ==============
osfileTapeOrROM:
                pha
                stx $C8                      ; C8/9=>control block
                sty $C9
                lda ($C8)                    ; Get XY=>filename
                tax
                ldy #$01
                lda ($C8),y
                tay
                jsr LA06B                    ; Parse filename
                ldy #$02
LA09E:
                lda ($C8),y
                sta $03BC,y
                sta $00AE,y
                iny
                cpy #$0A
                bne LA09E
                pla
                beq LA0B5
                cmp #$FF
                bne LA064
                jmp L9FAF

LA0B5:
                .if version==400
                jmp badCommandError
                .else
                sta $03C6
                sta $03C7
LA0BB:
                lda ($C8),y
                sta $00A6,y
                iny
                cpy #$12
                bne LA0BB
                txa
                beq LA085
                jsr LA9F3
                jsr LA822
                .if version<500
                lda #$00
                jsr LAAA6
                .endif
LA0D3:
                sec
                ldx #$fd                     ;-3
LA0D6:
                lda ($b4-$fd)&$ffff,x
                sbc ($b0-$fd)&$ffff,x
                sta $3c8-$fd,x
                inx
                bne LA0D6
                tay
                bne LA0F3
                cpx $03C8
                lda #$01
                sbc $03C9
                bcc LA0F3
                ldx #$80
                bra LA0FB

LA0F3:
                lda #$01
                sta $03C9
                stx $03C8
LA0FB:
                stx $03CA
                jsr LA6E9
                bmi LA17B
                jsr LA85B
                inc $03C6
                bne LA0D3
                inc $03C7
                bra LA0D3
                .endif
                
; TAPE/ROM FSC 2 - */
; TAPE/ROM FSC 4 - *RUN
; ---------------------
LA110:
                sec
                ror $CE
; TAPE/ROM FSC 11 - *RUN command for library
; ------------------------------------------
LA113:
                phx
                phy
                jsr LA06B
                lda #$00
                ldx #$FF
                stx $03C2
                jsr L9FAF
                ply
                plx
                bcc LA12E
                .if version!=400
                jsr LA9CA
                .endif

; TAPE/ROM FSC 3 - unknown * command
; ----------------------------------
LA129:
                lda #$0B
                jmp (FSCV)

LA12E:
                .if version<500
                bit tubePresence
                bpl LA13C
                lda $03C4
                and $03C5
                inc a
                bne LA14C
LA13C:
                .endif
                
                ldx $03C2
                ldy $03C3
                lda #$A4
                jsr OSBYTE
                lda #$01
                jmp ($03C2)

                .if version<500
LA14C:
                ldx #$C2
                ldy #$03
                lda #$04
                jmp LAAB0
                .endif

; TAPE/ROM FSC 9 - *EX
; --------------------
LA155:
                lda #$08
                tsb $E2
                lda $E3
                pha
                ora #$CC
                sta $E3
                jsr LA9F3
                pla
                sta $E3
                bra LA16F

; TAPE/ROM FSC 5 - *CAT
; ---------------------
LA168:
                lda #$08
                tsb $E2
                jsr LA9F3
LA16F:
                lda #$00
                jsr LA17C
                .if version!=400
                jsr LA9CA
                .endif
LA177:
                lda #$08
                trb $E2
LA17B:
                rts

LA17C:
                pha
                .if version!=400
                lda cfsRFSFSSwitch
                beq LA18B
                .endif
                jsr LF6FC
                jsr LF701
                clv
                bcs LA1DB
LA18B:
                jsr LA678
                lda $03C6
                sta $B4
                lda $03C7
                sta $B5
                ldx #$FF
                stx $03DF
                stz $BA
                bra LA1B7

LA1A1:
                .if version!=400
                lda cfsRFSFSSwitch
                beq LA1DD
                .endif
LA1A6:
                jsr LF717
LA1A9:
                lda #$FF
                sta $03C6
                sta $03C7
LA1B1:
                jsr LAA35
                jsr LA678
LA1B7:
                .if version!=400
                lda cfsRFSFSSwitch
                beq LA1BE
                .endif
                bvc LA1DB
LA1BE:
                pla
                pha
                beq LA1DD
                jsr LA95C
                bne LA1A1
                lda #$30
                and $BB
                beq LA1DB
                lda $03C6
                cmp $B6
                bne LA1A1
                lda $03C7
                cmp $B7
                bne LA1A1
LA1DB:
                pla
                rts

LA1DD:
                bvc LA1E4
                lda #$FF
                jsr LA6D4
LA1E4:
                ldx #$00
                jsr LA8C4
                .if version!=400
                lda cfsRFSFSSwitch
                beq LA1F2
                .endif
                bit $BB
                bvc LA1A6
LA1F2:
                bit $03CA
                bmi LA1A9
                bra LA1B1

; CFS/RFS OSFIND HANDLER
; ======================
osfindTapeOrROM:
                sta $BC
                phx
                phy
                ora #$00
                bne LA220
                tya
                bne LA212
                .if version!=400
                lda cfsRFSFSSwitch
                bne LA20C
                jsr LA29C
                .endif
LA20C:
                lda #$01
                trb $E2
                .if version==400
                bra LA297
                .else
                bra LA21E
                .endif
LA212:
                lsr a
                bcs LA20C
                .if version!=400
                lsr a
                bcs LA21B
                .endif
                jmp LAA81

                .if version!=400
LA21B:
                jsr LA29C
LA21E:
                bra LA297
                .endif

LA220:
                jsr LA06B
                bit $BC
                bvc LA260
                stz $039E
                stz $03DD
                stz $03DE
                lda #$C1
                trb $E2
                jsr LA9E6
                php
                jsr LA502
                jsr LA5B7
                plp
                ldx #$FF
LA241:
                inx
                lda $03B2,x
                sta $03A7,x
                bne LA241
                inc a
                tsb $E2
                lda tapeInputCurrentBlockSize+0
                ora tapeInputCurrentBlockSize+1
                bne LA259
                lda #$40
                tsb $E2
LA259:
                .if version==400
                lda #3
                bne LA295
LA260:
                jmp badCommandError
                .else
                lda #$01
                ora cfsRFSFSSwitch
                bne LA295
LA260:
                txa
                bne LA266
                jmp badStringError

LA266:
                ldx #$FF
LA268:
                inx
                lda $03D2,x
                sta $0380,x
                bne LA268
                dec a
                ldx #$08
LA274:
                sta $038B,x
                dex
                bne LA274
                txa
                ldx #$14
LA27D:
                sta $0380,x
                inx
                cpx #$1E
                bne LA27D
                rol $0397
                jsr LA9F3
                jsr LA822
                jsr LA9BB
                lda #$02
                tsb $E2
                .endif
LA295:
                sta $BC
LA297:
                ply
                plx
                lda $BC
LA29B:
                rts

                .if version!=400
LA29C:
                lda #$02
                and $E2
                beq LA29B
                stz $0397
                lda #$80
                ldx $039D
                stx $0396
                sta $0398
                jsr LA2B8
                lda #$02
                trb $E2
                rts

LA2B8:
                jsr LA9E6
                ldx #$11
LA2BD:
                lda $038C,x
                sta $03BE,x
                dex
                bpl LA2BD
                stx $B2
                stx $B3
                stz $B0
                lda #$09
                sta $B1
                ldx #$7F
                jsr LAA4D
                sta $03DF
                jsr LAA5A
                jsr LAAA0
                jsr LA6E9
                inc $0394
                bne LA2E9
                inc $0395
LA2E9:
                rts
                .endif

bputTapeOrROM:
                phx
                phy
                lda #$01
LA2EE:
                jsr LAA68
                lda $E2
                asl a
                bcs LA343
                asl a
                bcc LA301
                lda #$80
                tsb $E2
                lda #$FE
                bcs LA33B
LA301:
                ldx $039E
                inx
                cpx tapeInputCurrentBlockSize+0
                bne LA336
                bit blockFlagOfCurrentlyResidentBlock
                bmi LA332
                lda lastCharacterOfCurrentlyResidentBlock
                pha
                jsr LA9E6
                php
                jsr LA5AF
                plp
                pla
                sta $BC
                clc
                bit blockFlagOfCurrentlyResidentBlock
                bpl LA33D
                lda tapeInputCurrentBlockSize+0
                ora tapeInputCurrentBlockSize+1
                bne LA33D
                lda #$40
                tsb $E2
                bra LA33D

LA332:
                lda #$40
                tsb $E2
LA336:
                dex
                clc
                lda $0A00,x
LA33B:
                sta $BC
LA33D:
                inc $039E
                jmp LA297

LA343:
                jsr doFollowingError
                .text $df,"EOF",0

                .if version==400
osgbpbTapeOrROM:
bgetTapeOrROM:
LAA9A:
                cmp #4
                beq LA378
                sec
                rts
                .endif

                .if version!=400
bgetTapeOrROM:
                sta $C4
                phx
                phy
                lda #$02
                jsr LAA68
                ldx $039D
                lda $C4
                sta $0900,x
                inx
                bne LA365
                jsr LA2B8
                jsr LA9BB
LA365:
                inc $039D
                lda $C4
                jmp LA295
                .endif

                .if version!=400
; TAPE/ROM OSGBPB handler
; =======================
osgbpbTapeOrROM:
                lsr a                        ; Odd numbered calls - change PTR - exit with A=changed, SEC
                bcs LA376
                beq LA376                    ; OSGBPB 0 - exit with A=unchanged, SEC
                cmp #$03                     ; function/2<3 - function<6 - function 2 and 4 - jump to do
                bcc LA378
LA376:
                sec
                rts
                .endif
                
; Call Return
;  0    A=0   SEC                        - unsupported
;  1    A=0   SEC  Write using new PTR   - unsupported
;  2    A=         Write with current PTR
;  3    A=1   SEC  Read with new PTR     - unsupported
;  4    A=         Read with current PTR
;  5+   A=A/2 SEC                        - unsupported

; TAPE/ROM OSGBPB 2 and 4 - read/write with current PTR
; -----------------------------------------------------
LA378:
                .if version!=400
                lsr a
                .endif
                stx $CC
                sty $CD
                ldy #$01
                lda ($CC),y
                sta $C8
                iny
                lda ($CC),y
                sta $C9
                .if version<500
                iny
                lda ($CC),y
                iny
                and ($CC),y
                inc a
                and tubePresence
                pha
                .if version!=400
                php
                .endif
                beq LA3A7
                ldx $CC
                ldy $CD
                inx
                bne LA39E
                iny
LA39E:
                .if version==400
                lda #1
                .elsif version==350
                lda #1
                sbc #0
                .else
                lda #$00
                plp
                php
                adc #$00
                .endif
                jsr LAAB0
LA3A7:
                .endif
                lda ($CC)
                tay
                lda #$01
                .if version!=400
                .if version<500
                plp
                .endif
                php
                adc #$00
                .endif
                jsr LAA8D
                bcs LA3C1
                .if version!=400
                plp
                .endif
                .if version<500
                pla
                beq LA3BE
                lda #$80
                jsr tubeHost.entryPoint
LA3BE:
                .endif
                jmp LAA81

LA3C1:
                .if version!=400
                plp
                bcs LA401
                .endif
                bit $E2
                bpl LA3D3
                .if version<500
                pla
                beq LA3D0
                lda #$80
                jsr tubeHost.entryPoint
LA3D0:
                .endif
                jmp LA343

LA3D3:
                jsr LAAE0
                beq LA3F6
                lda ($CC)
                tay
                jsr bputTapeOrROM
                bcs LA3F6
                .if version<500
                plx
                phx
                beq LA3E9
                sta tube.data3
                bra LA3F1

LA3E9:
                .endif
                sta ($C8)
                inc $C8
                bne LA3F1
                inc $C9
LA3F1:
                jsr LAACA
                bra LA3D3

LA3F6:
                .if version<500
                pla
                php
                beq LA3FF
                lda #$80
                jsr tubeHost.entryPoint
LA3FF:
                plp
                .endif
                rts

                .if version!=400
LA401:
                jsr LAAE0
                beq LA3F6
                lda ($CC)
                tay
                .if version<500
                pla
                pha
                beq LA412
                lda tube.data3
                bra LA41A
LA412:
                .endif
                
                lda ($C8)
                inc $C8
                bne LA41A
                inc $C9
LA41A:
                jsr bgetTapeOrROM
                jsr LAACA
                bra LA401
                .endif
                
; TAPE/ROM FSC 0 - *OPT
; ---------------------
LA422:
                txa                          ; *OPT 0
                beq LA453
                cpx #$03                     ; *OPT 3
                beq LA448
                cpy #$03                     ; *OPT n,3+ - error Bad command (*BUG* should be Bad option)
                bcs LA433
                dex                          ; *OPT 1
                beq LA436
                dex                          ; *OPT 2
                beq LA43D
LA433:
                jmp badCommandError ; *OPT 4+ - error Bad command (*BUG* should be Bad option)

; *OPT 1 - set message level
; --------------------------
LA436:
                lda #$33
                iny
                iny
                iny
                bra LA43F

; *OPT 2 - set error response level
; ---------------------------------
LA43D:
                lda #$CC
LA43F:
                iny
                and $E3
LA442:
                ora LA456,y
                sta $E3
                rts

; *OPT 3 - set interblock gap
; ---------------------------
LA448:
                tya                          ; *OPT 3,128+ - set to default
                bmi LA44D    ;
                bne LA44F                    ; *OPT 3,<>0 - use setting
LA44D:
                lda #$19                     ; *OPT 3,0 or *OPT 3,128+ - use default of 2.5 sec
LA44F:
                sta $03D1                    ; Set inter-block gap
                rts

LA453:
                tay
                bra LA442

LA456:
                ; LDA ($00,x)
                ; EQUB $22
                ; ORA ($00),y
                ; DEY
                ; CPY LC0C6
                .byte $A1
                .byte $00
                .byte $22
                .byte $11
                .byte $00
                .byte $88
                .byte $CC
                
                .if version!=400
LA45D:
                dec $C0
                lda cfsRFSFSSwitch
                beq LA46B
                jsr LF710
                tay
                clc
                bra LA485

LA46B:
                lda ACIA+0
                pha
                and #$02
                beq LA47E
                ldy $CA
                beq LA47E
                pla
                lda $BD
                sta ACIA+1
                rts

LA47E:
                ldy ACIA+1
                pla
                lsr a
                lsr a
                lsr a
LA485:
                ldx $C2
                beq LA4F0
                dex
                bne LA492
                bcc LA4F0
                ldy #$02
                bra LA4EE
                .endif
                
LA492:
                .if version==400
                jsr $f4ff
                tay
                clc
                ldx $c2
                dex
                beq LA4F0
                dex
                bne LA4A8
                .else
                dex
                bne LA4A8
                bcs LA4F0
                .endif
                tya
                jsr LAA44
                ldy #$03
                cmp #$2A
                beq LA4EE
                jsr LAA1C
                ldy #$01
                bra LA4EE

LA4A8:
                dex
                bne LA4B5
                .if version!=400
                bcs LA4B0
                .endif
                sty $BD
                rts

                .if version!=400
LA4B0:
                lda #$80
                sta $C0
                rts
                .endif

LA4B5:
                dex
                bne LA4E1
                .if version!=400
                bcs LA4E9
                .endif
                tya
                jsr LA6A9
                ldy $BC
                inc $BC
                bit $BD
                bmi LA4D3
                .if version<500
                jsr LAABC
                beq LA4D0
                stx tube.data3
                bra LA4D3

LA4D0:
                txa
                .endif
                sta ($B0),y
LA4D3:
                iny
                cpy $03C8
                bne LA4F0
                lda #$01
                sta $BC
                ldy #$05
                bra LA4EE

LA4E1:
                tya
                jsr LA6A9
                dec $BC
                bpl LA4F0
                .if version!=400
LA4E9:
                jsr resetACIA
                .endif
                ldy #$00
LA4EE:
                sty $C2
LA4F0:
                rts

; TAPE/ROM FSC 1 - =EOF
; ---------------------
LA4F1:
                pha
                phy
                txa
                tay
                lda #$03                     ; Check if this channel is open for anything
                jsr LAA68
                lda $E2                      ; Get EOF flag
                and #$40
                tax                          ; Return in X
                ply
                pla
                rts

LA502:
                stz $B4
                stz $B5
LA506:
                lsr $CE
                lda $B4
                pha
                sta $B6
                lda $B5
                pha
                sta $B7
                jsr LA923
                .text "Searching",13,0
                lda #$ff
                jsr LA17C
                pla
                sta $B5
                pla
                sta $B4
                lda $B6
                ora $B7
                bne LA564
                stz $B4
                stz $B5
                .if version!=400
                lda cfsRFSFSSwitch
                beq LA55B
                .endif
                bvs LA55B
                .if version!=400
                jsr LA9CA
                .endif
                bit $CE
                bvc notFoundError
                sec
rtsA544:
                rts

;-------------------------------------------------------------------------

openFileForReading:
                lda #$40                     ;open for reading
                jsr OSFIND
                tay
                bne rtsA544
notFoundError:
                jsr doFollowingError
                .text $d6,"Not found",0

;-------------------------------------------------------------------------

LA55B:
                lda $C1
                bne LA564
                ldx #$B1
                jsr LAA4D
LA564:
                ldy #$FF
                sty $03DF
                clc
                rts

LA56B:
                beq LA584
                pha
                lda #fscFileHandleRange
                jsr callFSCV
                pla
                clc
                php
                sei
                sta $FA
                cpy $FA
                bcc LA583
                cpx $FA
                bcc LA587
                beq LA587
LA583:
                plp
LA584:
                pla
                pla
                rts

LA587:
                plp
                lda #$00
                rts

LA58B:
                lda execFileHandle
                jsr LA56B
starEXEC:
                php
                phy
                ldy execFileHandle
                sta execFileHandle
                beq LA59E
                jsr OSFIND
LA59E:
                lsr hazel.tempFSFlag
                ply
                plp
                beq LA5AE
                asl hazel.tempFSFlag
                jsr openFileForReading
                sta execFileHandle
LA5AE:
                rts

LA5AF:
                ldx #$A6
                jsr LAA4D
                jsr LA678
LA5B7:
                lda $03CA
                lsr a
                bcc LA5C0
                jmp L9FE3

LA5C0:
                lda $03DD
                sta $B4
                lda $03DE
                sta $B5
                stz $B0
                lda #$0A
                sta $B1
                lda #$FF
                sta $B2
                sta $B3
                jsr LA6D2
                jsr LA8A1
                bne LA603
                lda $0AFF
                sta lastCharacterOfCurrentlyResidentBlock
                jsr LAA35
                stx $03DD
                sty $03DE
                ldx #$02
LA5EF:
                lda $03C8,x
                sta tapeInputCurrentBlockSize+0,x
                dex
                bpl LA5EF
                bit blockFlagOfCurrentlyResidentBlock
                bpl LA600
                jsr LA059
LA600:
                jmp LA9C5

LA603:
                jsr LA506
                bra LA5B7

LA608:
                cmp #'*'
                beq LA643
                cmp #'#'
                bne LA61F
                inc $03C6
                bne LA618
                inc $03C7
LA618:
                ldx #$FF
                bit valueFF
                bra LA670

LA61F:
                jsr LA177
                jsr doFollowingError
                .byte $D7
                .text "Bad ROM"
                .byte 0

LA62E:
                .if version!=400
                ldy #$FF
                jsr LAA5C
                lda #$01
                sta $C2
                jsr LAA1C
LA63A:
                jsr LA880
                lda #$03
                cmp $C2
                bne LA63A
                .endif
LA643:
                jsr LAA46
LA646:
                jsr LA694
                bvc LA665
                sta $03B2,y
                beq LA656
                iny
                cpy #$0B
                bne LA646
                dey
LA656:
                ldx #$0C
LA658:
                jsr LA694
                bvc LA665
                sta $03B2,x
                inx
                cpx #$1F
                bne LA658
LA665:
                tya
                tax
                stz $03B2,x
                lda $BE
                ora $BF
                sta $C1
LA670:
                jsr LAA44
                sty $C2
                txa
                .if version<500
                bne LA6CC
                .elsif version>=500
                bne rtsAAC1
                .endif
LA678:
                .if version!=400
                lda cfsRFSFSSwitch
                beq LA62E
                .endif
LA67D:
                jsr LF710
                cmp #$2B
                bne LA608
                lda #$08
                and $E2
                beq LA68D
                jsr LA05D
LA68D:
                jsr LF701
                bcc LA67D
                clv
                rts

LA694:
                .if version!=400
                lda cfsRFSFSSwitch
                beq LA6A6
                .endif
                phx
                phy
                jsr LF710
                sta $BD
                lda #$FF
                sta $C0
                ply
                plx
LA6A6:
                jsr LA778
LA6A9:
                .if version<500
                php
                pha
                sec
                ror $CB
                eor $BF
                sta $BF
LA6B2:
                lda $BF
                clc
                bpl LA6C2
                eor #$08
                sta $BF
                lda $BE
                eor #$10
                sta $BE
                sec
LA6C2:
                rol $BE
                rol $BF
                lsr $CB
                bne LA6B2
                pla
                plp
                .endif
LA6CC:
                rts

                .if version!=400
LA6CD:                                       ;AAA6 in MOS 5.00
                jsr LA776
                bra LA6A9
                .endif

LA6D2:                                       ;AAAB in MOS 5.00
                lda #$00
LA6D4:
                sta $BD
                ldx #$00
                stz $BC
                bvc LA6E6
                lda $03C8
                ora $03C9
                beq LA6E6
                ldx #$04
LA6E6:
                stx $C2
rtsAAC1:
                rts

                .if version!=400
LA6E9:                                       ;AAC2 in MOS 5.00
                php
                ldx #$03
LA6EC:
                stz $03CB,x
                dex
                bpl LA6EC
                lda $03C6
                ora $03C7
                bne LA6FF
                jsr LA784
                bra LA702

LA6FF:
                jsr LA788
LA702:
                lda #$2A
                sta $BD
                jsr LAA44
                jsr LAA16
                jsr LA778
                dey
LA710:
                iny
                lda $03D2,y
                sta $03B2,y
                jsr LA6CD
                bne LA710
                ldx #$0C
LA71E:
                lda $03B2,x
                jsr LA6CD
                inx
                cpx #$1D
                bne LA71E
                jsr LA76F
                lda $03C8
                ora $03C9
                beq LA74F
                jsr LAA46
LA737:
                .if version<500
                jsr LAABC
                beq LA741
                lda tube.data3
                bra LA743
LA741:
                .endif
                lda ($B0),y
LA743:
                jsr LA6CD
                iny
                cpy $03C8
                bne LA737
                jsr LA76F
LA74F:
                jsr LA778
                jsr LA778
                jsr resetACIA
                lda #$01
                jsr LA78A
                plp
                jsr LA7AB
                bit $03CA
                bpl LA76E
                php
                jsr LA784
                jsr LA056
                plp
LA76E:
                rts

LA76F:
                .if version<500
                lda $BF
                .elsif version>=500
                lda #0
                .endif
                jsr LA776
                .if version<500
                lda $BE
                .elsif version>=500
                lda #0
                .endif
LA776:
                sta $BD
                .endif
                
LA778:
                jsr LA880
                bit $C0
                bpl LA778
                stz $C0
                lda $BD
                rts

                .if version!=400
LA784:
                lda #$32
                bra LA78A

LA788:
                lda $C7
LA78A:
                ldx #$05
LA78C:
                sta cfsTimeoutCounter
LA78F:
                jsr LA880
                bit cfsTimeoutCounter
                bpl LA78F
                dex
                bne LA78C
                rts
                .endif
                
LA79B:
                lda $03C6
                ora $03C7
                beq LA7A8
                bit $03DF
                bpl LA7AB
LA7A8:
                jsr LA059
LA7AB:
                ldy #$00
                stz $BA
                lda $03CA
                sta $03DF
                jsr LEF1B
                beq LA821
                lda #$0D
                jsr OSWRCH
LA7BF:
                lda $03B2,y
                beq LA7D4
                cmp #$20
                bcc LA7CC
                cmp #$7F
                bcc LA7CE
LA7CC:
                lda #$3F
LA7CE:
                jsr OSWRCH
                iny
                bne LA7BF
                
LA7D4:
                .if version!=400
                lda cfsRFSFSSwitch
                beq LA7DD
                .endif
                bit $BB
                bvc LA821
LA7DD:
                jsr printSpace
                iny
                cpy #$0B
                bcc LA7D4
                lda $03C6
                tax
                jsr printHexByte
                bit $03CA
                bpl LA821
                txa
                clc
                adc $03C9
                jsr printSpaceThenPrintHexByte
LA7F9:
                lda $03C8
                jsr printHexByte
                bit $BB
                bvc LA821
                ldx #$04
LA805:
                jsr printSpace
                dex
                bne LA805
                ldx #$0F
                jsr LA815
                jsr printSpace
                ldx #$13
LA815:
                ldy #$04
LA817:
                lda $03B2,x
                jsr printHexByte
                dex
                dey
                bne LA817
LA821:
                rts

                .if version!=400
LA822:
                lda cfsRFSFSSwitch
                beq LA82D
                jsr LA9CA
                jmp badCommandError

LA82D:
                jsr LAA5A
                jsr LAAA0
                jsr LEF1B
                beq LA821
                jsr LA923
                .text "RECORD then RETURN"
                .byte $00

LA84E:
                jsr LA880
                jsr OSRDCH
                cmp #$0D
                bne LA84E
                jmp OSNEWL
                .endif

;-------------------------------------------------------------------------

                .if version==350
                .include "cfs_errors.s65"
                .endif
                
;-------------------------------------------------------------------------


LA85B:
                ldx #$FD
LA85D:
                inc $B4,x
                bne LA864
                inx
                bne LA85D
LA864:
                rts

;-------------------------------------------------------------------------

printSpaceThenPrintHexByte:
                pha
                jsr printSpace
                pla
printHexByte:
                pha
                .if version==350
                jsr LE520
                .else
                lsr a
                lsr a
                lsr a
                lsr a
                .endif
                jsr printHexDigit
                pla
printHexDigit:
                and #$0F
                ora #'0'                     ;+'0'
                cmp #'9'+1
                bcc LA87D                    ;taken if <='9'
                adc #'A'-('9'+1)-1           ;adjust - -1 because C set
LA87D:
                jmp OSWRCH

;-------------------------------------------------------------------------

LA880:
                php
                bit $EB
                bmi LA889
                bit $FF
                bmi LA88B
LA889:
                plp
                rts

LA88B:
                jsr LA177
                jsr LA9BB
escapeError:
                lda #$7E
                jsr OSBYTE
                jsr doFollowingError
                .byte $11
                .text "Escape"
                .byte $00

;-------------------------------------------------------------------------

LA8A1:
                tya
                beq LA8B1
                jsr LA923
                .byte $0D
                .text "Loading"
                .byte $0D
                .byte $00
LA8B1:
                stz $BA                      ; :
                ldx #$FF
                lda $C1
                bne LA8C4
                jsr LA95C
                php
                ldx #$FF
                ldy #<fileError
                .cwarn (>fileError)!=(>dataError),"must be on same page"
                plp
                bne LA8DA
LA8C4:
                ldy #<dataError
                lda $C1
                bne LA8DA
                lda $03C6
                cmp $B4
                bne LA8D8
                lda $03C7
                cmp $B5
                beq LA8E3
LA8D8:
                ldy #<blockError
                .cwarn (>blockError)!=(>dataError),"must be on same page"
LA8DA:
                phy
                phx
                jsr LA7A8
                plx
                ply
                bra LA8F3

LA8E3:
                phx
                jsr LA79B
                jsr LA9A0
                plx
                lda $BE
                ora $BF
                beq LA96A
                ldy #<dataError
LA8F3:
                lda #>dataError
                dec $BA
                pha
                bit $EB
                bmi LA909
                txa
                .if version!=400
                and cfsRFSFSSwitch
LA900:
                .endif
                bne LA909
                txa
                and #$11
                and $BB
                beq LA918
LA909:
                pla
                sta $B9
                sty $B8
                jsr LA58B
                lsr $EB
                jsr LA9B1
                bra LA955

LA918:
                tya
                clc
                adc #$03
                tay
                bcc LA922
                pla
                inc a
                pha
LA922:
                phy
LA923:
                jsr LEF1B
                tay

;-------------------------------------------------------------------------
;
; Print 0-terminated message using address from stack.
;
; entry:
;
; S=[StrL; StrH] - where Str = (address of string)-1
; Y = 0 to print message; otherwise, don't print message
; 
printFollowingMessage:                       ;
                pla
                sta printMessageAddress+0
                pla
                sta printMessageAddress+1
                phy                          ;save initial Y
                tya                          ;Z=1 if Y=0
                php                          ;save Y=0 state
fetchNextChar:
                inc printMessageAddress+0
                bne +
                inc printMessageAddress+1
+
                lda (printMessageAddress)   ;fetch next char to print
                beq printingFinished        ;branch taken if last char
                plp                         ;restore Y=0 state
                php                         ;save Y=0 state
                beq fetchNextChar ;branch taken if Y=0 - i.e., skip the
                                  ;printing

                ; printMessageAddress is in the $b0-$bf area, so it
                ; needs saving in case there's a *SPOOL going on.
                ldy printMessageAddress+0
                phy                          
                ldy printMessageAddress+1
                jsr OSASCI                   
                sty printMessageAddress+1
                ply                          
                sty printMessageAddress+0
                
                bra fetchNextChar

printingFinished:
                plp                          ;discard Y=0 state
                inc printMessageAddress+0
                bne +
                inc printMessageAddress+1
+
                ply                          ;restore initial Y
LA955:
                jmp (printMessageAddress)

alwaysPrintFollowingMessage:
                ldy #$01
                bra printFollowingMessage

;-------------------------------------------------------------------------

LA95C:
                ldx #$FF
LA95E:
                inx
                lda $03D2,x
                bne LA96B
                txa
                beq LA96A
                lda $03B2,x
LA96A:
                rts

LA96B:
                jsr isLetter
                eor $03B2,x
                bcs LA975
                and #$DF
LA975:
                beq LA95E
LA977:
                rts

LA978:
                lda $BA
                beq LA99D
                txa
                beq LA99D
                lda #$22
                bit $BB
                beq LA99D
                .if version!=400
                jsr resetACIA
                .endif
                tay
                jsr printFollowingMessage
                .byte $0D
                .byte $07
                .text "Rewind tape"
                .byte $0D
                .byte $0D
                .byte $00
                rts

LA99D:
                jsr LA05D
LA9A0:
                lda $C2
                beq LA977
                jsr LA880
                .if version!=400
                lda cfsRFSFSSwitch
                beq LA9A0
                .endif
                .if version==400
                jsr LA492
                .else
                jsr LA45D
                .endif
                bra LA9A0

LA9B1:
                jsr LEF1B
                beq LA9BB
LA9B6:
                lda #$07
                jsr OSWRCH
LA9BB:
                .if version<500
                lda tubePresence
                beq LA9C5
                lda #$80
                jsr tubeHost.entryPoint
                .endif
LA9C5:
                .if version!=400
                ldx #$00
                jsr LAA61
LA9CA:
                php
                sei
                lda serialULARegister
                sta SERPROC+0
                stz $EA
                bra LA9D7

;-------------------------------------------------------------------------

resetACIAThenRewriteControlRegister:
                php
LA9D7:
                jsr resetACIA
                lda aciaControlRegister
                jmp writeACIAControlRegisterAndCopy
                
;-------------------------------------------------------------------------

LA9E0:
                plp
                bit $FF
                bpl LA9FD
                .endif
                rts

LA9E6:
                lda $E3
                asl a
                asl a
                asl a
                asl a
                sta $BB
                .if version==400
                rts
                .else
                lda $03D1
                bra LA9FB
                .endif

LA9F3:
                lda $E3
                and #$F0
                sta $BB
                .if version!=400
                lda #$06
LA9FB:
                sta $C7
LA9FD:
                cli
LA9FE:
                php
                sei
LAA00:
                bit rs423Busy
                bpl LA9E0
                lda $EA
                bmi LA9E0
                lda #$01
                sta $EA
                jsr resetACIA
                plp
                .endif
                rts

;-------------------------------------------------------------------------

                .if version!=400
resetACIA:
                lda #ACIA.control.reset
                bra writeACIAControlRegister
                .endif
                
;-------------------------------------------------------------------------

LAA16:
                .if version!=400
                lda #$30
                sta $CA
                bra LAA2F
                .endif
LAA1C:
                .if version!=400
                lda #$05
                sta SERPROC+0
                ldx #$FF
LAA23:
                dex
                bne LAA23
                .endif
                stz $CA
                .if version!=400
                lda #$D0
LAA2A:
                ldy #$85
                sty SERPROC+0
LAA2F:
                ora $C6
writeACIAControlRegister:
                sta ACIA+0
                .endif
                rts

;-------------------------------------------------------------------------

LAA35:
                ldx $03C6
                ldy $03C7
                inx
                stx $B4
                bne LAA41
                iny
LAA41:
                sty $B5
                rts

LAA44:
                stz $C0
LAA46:
                ldy #$00
                stz $BE
                stz $BF
                rts

LAA4D:
                ldy #$FF
LAA4F:
                iny
                inx
                lda $0300,x
                sta $03D2,y
                bne LAA4F
                rts

                .if version!=400
LAA5A:
                ldy #$00
LAA5C:
                cli
                ldx #$01
                sty $C3
LAA61:
                lda #$89
                ldy $C3
                jmp OSBYTE
                .endif

; Check if TAPE/ROM channel is open
; ---------------------------------
; Y=handle to check, A=status mask to use
LAA68:
                phy
                jsr LAA8D
                ply
                .if version<500
                bcs LAAC9                    ; Channel open, exit
                .elsif version>=500
                bcs LAA9F
                .endif
                cpy spoolFileHandle                    ; Not SPOOL handle
                bne LAA79
                stz spoolFileHandle                    ; Clear the SPOOL handle
                bra LAA81
LAA79:
                cpy execFileHandle                    ; Not EXEC handle
                bne LAA81
                stz execFileHandle                    ; Clear the EXEC handle
LAA81:
                jsr doFollowingError                    ; Generate error
                .byte $DE
                .text "Channel"
                brk

LAA8D:
                pha                          ; Toggle channel with CFS/RFS switch
                tya
                .if version==400
                eor #2
                .else
                eor cfsRFSFSSwitch
                .endif
                tay                          ; If CFS=unchanged, if RFS 1/2/3->3/0/1
                pla
                and $E2                      ; Mask with open channels bitmask
                lsr a                        ; Move 'input open if tested' into Carry
                dey                          ; Exit if testing CFS#1 or RFS#3
                beq LAA9F
                lsr a                        ; Move 'output open if tested' into Carry
                dey                          ; Exit if testing CFS#2
                beq LAA9F
                clc                          ; Otherwise, Carry=Not Open
LAA9F:
                rts

                .if version!=400
LAAA0:
                lda #$10
                bra LAA2A
                .endif

                .if version<500
LAAA4:
                lda #$01
LAAA6:
                jsr LAABC
                beq LAAC9
                txa
                ldx #$B0
                ldy #$00
LAAB0:
                pha
                lda #$C0
LAAB3:
                jsr tubeHost.entryPoint
                bcc LAAB3
                pla
                jmp tubeHost.entryPoint

LAABC:
                tax
                lda $B2
                and $B3
                inc a
                beq LAAC9
                lda tubePresence
                and #$80
LAAC9:
                rts
                .endif
                
LAACA:
                ldy #$05
LAACC:
                lda ($CC),y
                bne LAAD7
                iny
                cpy #$08
                bcc LAACC
LAAD5:
                lda ($CC),y
LAAD7:
                dec a
                sta ($CC),y
                dey
                cpy #$05
                bcs LAAD5
                rts

LAAE0:
                ldy #$08
                lda #$00
LAAE4:
                ora ($CC),y
                dey
                cpy #$05
                bcs LAAE4
                tax
                rts

doFollowingError:
                sei
                pla
                sta SEIWKA+0
                pla
                sta SEIWKA+1
                stz $0100
                ldy #$00
-
                iny
                lda (SEIWKA),y
                sta $0100,y
                bne -
                jmp $0100


                .if version!=350
                .include "cfs_errors.s65"
                .endif

                .if version<500
;-------------------------------------------------------------------------
;
; Tube host code
;
; See http://mdfs.net/Software/Tube/M128/Host320.lst
;
; I mostly just copied JGH's comments here.

tubeHost: .block          ;tube code
                
brkHandler: .block
                .logical tubeBrkHandlerAddr
                lda #$FF
                jsr sendR4       ;send $ff via R4 to interrupt copro
                lda tube.data2   ;get ACK byte from copro
                lda #$00
                jsr sendR2A       ;send $00 via R2 to specify ERROR
                tay               ;Y=0
                lda ($FD),y       ;get error number
                jsr sendR2A       ;send error number via R2
-
                iny             ;next char
                lda ($FD),y     ;fetch error string char
                jsr sendR2A     ;send via R2
                tax             ;set N/Z as per error string char
                bne -           ;repeat until terminating $00 sent
idleStartup:
                ldx #$FF
                txs             ;clear stack
                cli
idleLoop:
                bit tube.status1 ;is there a char in R1?
                bpl LAB58        ;branch taken if no char in R1
handleOSWRCH:
                lda tube.data1  ;get char from R1
                jsr OSWRCH      ;pass to OSWRCH
LAB58:
                bit tube.status2 ;is there a command in R2?
                bpl idleLoop     ;branch taken if no command in R2
                bit tube.status1 ;is there a char in R1?
                bmi handleOSWRCH ;branch taken if char in R1
                ldx tube.data2   ;get command from R2
                stx callCommandRoutine+1 ;use as index into command
                                         ;table
callCommandRoutine:
                ; not sure why this can't be jmp
                ; (tubeHost.commandRoutines,x)? - and then the table
                ; wouldn't have to be page-aligned.
                jmp (tubeHost.commandRoutines)

                ; ???
                .dword $8000
                .here
                .endblock

; Slightly ugly aliases for inner symbol :(
idleStartup=brkHandler.idleStartup
idleLoop=brkHandler.idleLoop

codePage0:
                .logical tubeHostAddr
copyLanguage:
                jmp LAC30

copyEscapeStatus:
                jmp LADDA

; Tube transfer/claim/release
entryPoint:
                cmp #$80
                bcc dataTransfer
                cmp #$C0
                bcs claim
                ora #$40
                cmp $15
                bne done
release:
                php
                sei
                lda #$05
                jsr sendR4
                jsr sendR4TubeClaimantID
                plp
resetTubeClaim:
                lda #$80
                sta tubeClaimantID
                sta tubeNotClaimed
                rts

claim:
                asl tubeNotClaimed    ;test if Tube free
                bcs claim2         ;taken if Tube free - with C=1 and
                                   ;tube marked as claimed
                cmp tubeClaimantID
                beq done       ;taken with C=1 if already claimed
                clc            ;signal claim failure
                rts

claim2:
                sta tubeClaimantID ; store claimant ID
done:
                rts

dataTransfer:
                php
                sei
                sty tubeTransferAddr+1
                stx tubeTransferAddr+0
                jsr sendR4      ;send reason code to interrupt copro
                tax             ;save reason code
                ldy #$03        ;will send 4 bytes
                jsr sendR4TubeClaimantID ;send Tube claimant ID
-
                lda (tubeTransferAddr),y
                jsr sendR4
                dey
                bpl -

                ; disable R3 FIFO, disable R3 NMI
                ldy #tube.status1.V|tube.status1.M
                sty tube.status1

                ; disable/enable other per-transfer type flags as
                ; appropriate.
                lda dataTransferFlags,x
                sta tube.status1 ;STPVMJIQ

                lsr a           ;0STPVMJI Q
                lsr a           ;00STPVMJ I
                bcc +           ;branch taken if CoPro->I/O transfer

                ; Read R3 twice to delay and empty FIFO
                bit tube.data3
                bit tube.data3
+
                jsr sendR4      ;send value to synchronize
-
                bit tube.status4
                bvc -
                bcs LABE4       ;branch taken if I/O->CoPro transfer
                cpx #$04        ;$04 = execute in CoPro
                bne LABEC       ;taken if not execute in CoPro
LABDB:
                jsr release
                jsr sendR2A
                jmp idleStartup

LABE4:
                lsr a            ;000STPVM J
                bcc LABEC        ;branch taken if J=0
                ldy #tube.status1.S|tube.status1.M
                sty tube.status1
LABEC:
                plp
                rts

LABEE:
                ldx lastBREAKType            ;get last BREAK type
                beq LABDB   ;if soft break, release Tube, send $80 via
                            ;R2, and enter idle loop.

; The current language is not copied across the Tube on soft Break,
; only on Power-On Break and Hard Break, or when entered explicitly
; with OSBYTE 142.
                
enterNewLanguage: .proc
                lda #$FF
                jsr tubeHost.entryPoint ;claim with ID=$3f
                bcc enterNewLanguage    ;repeat until claimed
                jsr getLanguageParasiteAddr ;sort out addresses
                
transferPage:
                .if version==350
                jsr relocateNextLanguageROMPage
                .endif
                php
                sei

                ; initiate I/O->CoPro 256 bytes, then transfer the
                ; next 256 bytes of the language ROM.
                lda #$07
                jsr doTube
                
                ldy #$00
                .if version==350
transferPageLoop:
                lda tubeRelocationBuffer,y
                sta tube.data3
                pha
                pla
                .else
                stz tubeLanguageHostAddr+0
transferPageLoop:
                lda (tubeLanguageHostAddr),y
                sta tube.data3
                nop
                nop
                nop
                .endif
                iny
                bne transferPageLoop
                plp

                ; advance to next dest page.
                inc tubeLanguageParasiteAddr+1
                bne +
                inc tubeLanguageParasiteAddr+2
                bne +
                inc tubeLanguageParasiteAddr+3
+

                .if version!=350
                inc tubeLanguageHostAddr+1 ;next source page
                .endif
                bit tubeLanguageHostAddr+1
                bvc transferPage ;branch taken if source page $c0 not
                                 ;reached yet

                ; copy done - execute language in parasite
                .if version==350
                jsr getLanguageParasiteAddrAndAssumeRelocatable
                .else
                jsr getLanguageParasiteAddr
                .endif
                lda #$04        ;execute in copro

                ; call Tube entry point with whatever reason code,
                ; supplying language parasite address as the parasite
                ; address.
doTube:
                ldy #>tubeLanguageParasiteAddr
                ldx #<tubeLanguageParasiteAddr
                jmp tubeHost.entryPoint
                .pend
                
LAC30:
                cli
                bcs enterNewLanguage
                bne LABEE
                bra LAC8F

getLanguageParasiteAddr: .proc
                lda #$80
                sta tubeLanguageParasiteAddr+1 ;$xxxx80xx
                sta tubeLanguageHostAddr+1     ;$80xx
                lda #$20
                and $8006  ;test parasite address flag
                tay        ;Y=0 if $8000, Y=$20 if parasite address
                .if version==350
                sty @w tubeLanguageParasiteAddr+0
                .else
                sty tubeLanguageParasiteAddr+0
                .endif
                beq LAC60       ;branch taken if good to go with A=0
                                ;and Y=0

                ldx $8007       ;get copyright offset
                ; skip copyright message
-
                inx
                lda $8000,x
                bne -
                
                lda $8000+1,x
                sta tubeLanguageParasiteAddr+0
                lda $8000+2,x
                sta tubeLanguageParasiteAddr+1
                ldy $8000+3,x                  
                lda $8000+4,x
LAC60:
                ; Y = parasite address bits 16-23
                ; A = parasite address bits 24-31
                .if version==350
                jmp checkForTubeRelocationBitmap
                .else
                sta tubeLanguageParasiteAddr+3
                sty tubeLanguageParasiteAddr+2
                rts

                .endif
                .pend
                .here

codePages12:
                .logical tubeHostAddr+256

; names of the indexes here come from app note 004
commandRoutines:
                .cerror (*&$ff)!=0,"commandRoutines must be paged aligned"
                .word doRDCH    ;RDCHNO = $00
                .word doCLI     ;CLINO = $02
                .word doSBYT    ;SBYTNO = $04
                .word doBYTE    ;BYTENO = $06
                .word doWORD    ;WORDNO = $08
                .word doRDLN    ;RDLNNO = $0a
                .word doARGS     ;ARGSNO = $0c
                .word doBGET     ;BGETNO = $0e
                .word doBPUT     ;BPUTNO = $10
                .word doFIND     ;FINDNO = $12
                .word doFILE    ;FILENO = $14
                .word doGBPB     ;GBPBNO = $16

                ; Tube data transfer flags
dataTransferFlags:
                ; 0 - CoPro->I/O bytes
                ;
                ; Enable: PIRQ from R3, PIRQ from R1
                .byte tube.status1.S|tube.status1.J|tube.status1.I

                ; 1 - I/O->CoPro bytes
                ;
                ; Enable: PNMI from R3
                .byte tube.status1.S|tube.status1.M

                ; 2 - CoPro->I/O words
                ;
                ; Enable: 2-byte R3, PIRQ from R2, PIRQ from R1
                .byte tube.status1.S|tube.status1.V|tube.status1.J|tube.status1.I

                ; 3 - I/O->CoPro words
                ;
                ; Enable: 2-byte R3, PNMI from R3
                .byte tube.status1.S|tube.status1.V|tube.status1.M

                ; 4 - Execute in CoPro
                ;
                ; Disable: 2-byte R3, PNMI from R3
                .byte tube.status1.V|tube.status1.M

                ; 5 - Reserved
                ;
                ; Disable: 2-byte R3, PNMI from R3
                .byte tube.status1.V|tube.status1.M

                ; 6 - CoPro->I/O 256 bytes
                ;
                ; Enable: PIRQ from R1
                .byte tube.status1.S|tube.status1.I

                ; 7 - I/O->CoPro 256 bytes
                ;
                ; Disable: 2-byte R3, PNMI from R3
                .byte tube.status1.V|tube.status1.M

doBPUT:
                jsr recvR2      ;Receive file handle
                tay             ;Y = file handle
                jsr recvR2      ;Receive byte
                jsr OSBPUT      ;Do OSBPUT
LAC8F:
                bra sendR27FThenGoIdle

doBGET:
                jsr recvR2      ;Receive file handle
                tay             ;Y = file handle
                jsr OSBGET      ;Do OSBGET
LAC98:
                bra sendR2CAThenGoIdle

doRDCH:
                jsr OSRDCH      ;Do OSRDCH
sendR2CAThenGoIdle:
                ror a           ;set A bit 7 as per carry
                jsr sendR2A     ;send via R2
                rol a           ;restore A
                bra sendR2AThenGoIdle

doFIND: .proc
                jsr recvR2            ;Receive reason code
                beq close             ;taken if A=$00 - CLOSE#
                pha                   ;save reason code
                jsr recvR2String      ;receive file name
                pla                   ;restore reason code
                jsr OSFIND            ;call OSFIND
                bra sendR2AThenGoIdle

close:
                jsr recvR2      ;Receive file handle
                tay             ;Y = file handle
                lda #$00        ;A = $00 - CLOSE#
                jsr OSFIND      ;call OSFIND
                bra sendR27FThenGoIdle
                .pend

;-------------------------------------------------------------------------
;
; Handle a Tube OSARGS request.
;
; [Tube p24]
; 
doARGS:
                jsr recvR2                   ;receive file handle
                tay                          ;Y = file handle
                ldx #$04
                jsr recvR2N ;receive 4 bytes OSARGS data, + operation code
                jsr OSARGS  ;call OSARGS
                jsr sendR2A ;send OSARGS result

                ; send 4 bytes OSARGS data
                ldx #$03
-
                .if version==350
                lda @w $00,x
                .else
                lda $00,x
                .endif
                jsr sendR2A
                dex
                bpl -
                
                bra goIdle_0

;-------------------------------------------------------------------------
;
; Receive a CR-terminated string over the Tube via R2.
;
; exit:
; YX = pointer to received string (here, always $0700)
;
recvR2String: .proc
                ldx #$00
                ldy #$00        ;index
-
                jsr recvR2      ;get next string char
                sta tubeStringBuffer,y     ;store in string buffer
                iny
                beq +           ;taken if too many bytes received
                cmp #$0D
                bne -           ;taken if end of string data not reached
+
                ldy #>tubeStringBuffer
                .cerror (<tubeStringBuffer)!=0,"tubeStringBuffer must be page-aligned"
                rts                          
                .pend

;-------------------------------------------------------------------------
;
; Handle a Tube OSCLI request.
;
; [Tube p22]
;
doCLI:
                jsr recvR2String
                jsr OSCLI
sendR27FThenGoIdle:
                lda #$7F
sendR2AThenGoIdle:
-
                bit tube.status2
                bvc -
                sta tube.data2
goIdle_0:
                bra goIdle_1

;-------------------------------------------------------------------------
;
; Handle a Tube OSGBPB request.
;
; [Tube p25]
; 
doGBPB:
                ldx #size(OSGBPBParameterBlock)
                .cerror tubeOSGBPBParameterBlock!=0,"Tube OSGBPB parameter block must be at $0000"
                jsr recvR2N     ;receive parameter block + reason code
                ldy #>tubeOSGBPBParameterBlock
                jsr OSGBPB      ;call OSGBPB
                pha             ;save OSGBPB A result

                ; Send updated OSGBPB parameter block.
                ldx #size(OSGBPBParameterBlock)-1
-
                .if version==350
                lda @w tubeOSGBPBParameterBlock,x
                .else
                lda tubeOSGBPBParameterBlock,x
                .endif
                jsr sendR2A
                dex
                bpl -
                pla                          ;restore OSGBPB A result
                bra sendR2CAThenGoIdle       ;send OSGBPB full result

;-------------------------------------------------------------------------
;
; Handle a Tube OSFILE request.
;
; [Tube p24]
; 
doFILE: .proc
                ; receive non-name part of OSFILE parameter block
                ldx #size(OSFILEParameterBlock)-2
-
                jsr recvR2
                .if version==350
                sta @w tubeOSFILEParameterBlock.addresses-1,x
                .else
                sta tubeOSFILEParameterBlock.addresses-1,x
                .endif
                dex
                bne -
                jsr recvR2String
                .if version==350
                stx @w tubeOSFILEParameterBlock+0
                sty @w tubeOSFILEParameterBlock+1
                .else
                stx tubeOSFILEParameterBlock+0
                sty tubeOSFILEParameterBlock+1
                .endif
                ldy #>tubeOSFILEParameterBlock
                .cerror (<tubeOSFILEParameterBlock)!=0,"Tube OSFILE parameter block must be at $0000"
                jsr recvR2                   ;receive OSFILE reason code
                jsr OSFILE                   ;call OSFILE
                jsr sendR2A                  ;send OSFILE result

                ; send non-name part of updated OSFILE parameter block
                ldx #size(OSFILEParameterBlock)-2
-
                .if version==350
                lda @w tubeOSFILEParameterBlock.addresses-1,x
                .else
                lda tubeOSFILEParameterBlock.addresses-1,x
                .endif
                jsr sendR2A
                dex
                bne -
                bra goIdle_1
                .pend

;-------------------------------------------------------------------------
;
; Handle a Tube small (A<$80) OSBYTE.
;
; [Tube p22]
;
doSBYT:
                jsr recvR2XA    ;receive X and A arguments
                jsr OSBYTE
sendR2X:
                bit tube.status2
                bvc sendR2X
                stx tube.data2
goIdle_1:
                jmp idleLoop

;-------------------------------------------------------------------------
;
; Handle a Tube non-small OSBYTE.
;
; [Tube p22]
doBYTE:
                jsr recvR2XA                ;receive X and Y arguments
                tay                         ;Y = Y argument
                jsr recvR2                  ;receive A argument
                jsr OSBYTE                  ;call OSBYTE
                eor #$9D                    ;was it Fast Tube BPUT?
                beq goIdle_1      ;if it was, done.
                ror a             
                jsr sendR2A       ;send carry result
-
                bit tube.status2
                bvc -
                sty tube.data2               ;send Y result
                bra sendR2X                  ;send X result

;-------------------------------------------------------------------------
;
; Handle a Tube OSWORD request.
;
; [Tube p22]
; 
doWORD:
                jsr recvR2
                tay
                jsr LAE0F
                bmi LAD7F
LAD75:
                jsr recvR2
                sta tubeOSWORDBuffer,x
                dex
                bpl LAD75
                tya
LAD7F:
                ldx #<tubeOSWORDBuffer
                ldy #>tubeOSWORDBuffer
                jsr OSWORD
                jsr LAE0F
                bmi goIdle_1
LAD8B:
                ldy tubeOSWORDBuffer,x
LAD8E:
                bit tube.status2
                bvc LAD8E
                sty tube.data2
                dex
                bpl LAD8B
LAD99:
                bra goIdle_1

;-------------------------------------------------------------------------

doRDLN:
                ldx #$04
LAD9D:
                jsr recvR2
                .if version==350
                sta @w $00,x
                .else
                sta $00,x
                .endif
                dex
                bpl LAD9D
                inx
                txa
                tay
                jsr OSWORD
                bcc LADB2
                lda #$FF
                jmp sendR2AThenGoIdle

LADB2:
                ldx #$00
                lda #$7F
                jsr sendR2A
LADB9:
                lda $0700,x
                jsr sendR2A
                inx
                cmp #$0D
                bne LADB9
                bra LAD99

sendR2A:                          ;adc6/0661
                bit tube.status2
                bvc sendR2A
                sta tube.data2
                rts

sendR4TubeClaimantID:              ;adcf
                lda tubeClaimantID ;get Tube ID
sendR4:                          ;add1/066c
                bit tube.status4 ;check R4 status
                bvc sendR4       ;branch taken if FIFO full
                sta tube.data4   ;put byte in FIFO
                rts

LADDA:
                lda $FF
                sec
                ror a
                bra LADEF

eventHandler:
                pha
                lda #$00
                jsr LADEF
                tya
                jsr LADEF
                txa
                jsr LADEF
                pla
LADEF:
                bit tube.status1
                bvc LADEF
                sta tube.data1
                rts

;-------------------------------------------------------------------------
;
; Receive multiple bytes via R2: some kind of parameter block,
; followed by the reason code. Store the first N-1 received in zero
; page, starting at $00.
;
; entry:
;
; X = number of bytes to receive, minus 1
;
; exit:
;
; ?$00, ?$01... = first N-1 bytes received
;
; A = final byte received
;
; X = 0
;
recvR2N:
                jsr recvR2
                sta $ff,x
                dex
                bne recvR2N
                bra recvR2

;-------------------------------------------------------------------------
;
; Receive 2 bytes via R2.
;
; exit:
;
; X = first byte received
;
; A = second byte received
; 
recvR2XA:
                jsr recvR2
                tax

;-------------------------------------------------------------------------
;
; Receive 1 byte via R2.
;
; exit:
;
; A = byte received
; 
recvR2:
                bit tube.status2
                bpl recvR2
                lda tube.data2
                rts

;-------------------------------------------------------------------------

LAE0F:
                bit tube.status2
                bpl LAE0F
                ldx tube.data2
                dex
                rts
                .here
                .bend

;-------------------------------------------------------------------------
                .endif

                .if version<400&&includeTerminalROM
                .include "terminal_code.s65"
                .endif

                .if version==350&&!includeTerminalROM
                .include "sound_stuff.s65"
                .endif

                .if version>=500||!includeTerminalROM
                .include "ext.s65"
                .endif

;-------------------------------------------------------------------------

; Unused space
; ============
                .fill $b900-*,$ff

; Default font
; ============
LB900:
                .cerror (<LB900)!=0,"font data must be page aligned"
                ; CHR$32 -  
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$33 - !
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00000000

                ; CHR$34 - "
                .byte %01101100
                .byte %01101100
                .byte %01101100
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$35 - #
                .byte %00110110
                .byte %00110110
                .byte %01111111
                .byte %00110110
                .byte %01111111
                .byte %00110110
                .byte %00110110
                .byte %00000000

                ; CHR$36 - $
                .byte %00001100
                .byte %00111111
                .byte %01101000
                .byte %00111110
                .byte %00001011
                .byte %01111110
                .byte %00011000
                .byte %00000000

                ; CHR$37 - %
                .byte %01100000
                .byte %01100110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100110
                .byte %00000110
                .byte %00000000

                ; CHR$38 - &
                .byte %00111000
                .byte %01101100
                .byte %01101100
                .byte %00111000
                .byte %01101101
                .byte %01100110
                .byte %00111011
                .byte %00000000

                ; CHR$39 - '
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$40 - (
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %00110000
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00000000

                ; CHR$41 - )
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00001100
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %00000000

                ; CHR$42 - *
                .byte %00000000
                .byte %00011000
                .byte %01111110
                .byte %00111100
                .byte %01111110
                .byte %00011000
                .byte %00000000
                .byte %00000000

                ; CHR$43 - +
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00000000

                ; CHR$44 - ,
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00110000

                ; CHR$45 - -
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$46 - .
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$47 - /
                .byte %00000000
                .byte %00000110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100000
                .byte %00000000
                .byte %00000000

                ; CHR$48 - 0
                .byte %00111100
                .byte %01100110
                .byte %01101110
                .byte %01111110
                .byte %01110110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$49 - 1
                .byte %00011000
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00000000

                ; CHR$50 - 2
                .byte %00111100
                .byte %01100110
                .byte %00000110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01111110
                .byte %00000000

                ; CHR$51 - 3
                .byte %00111100
                .byte %01100110
                .byte %00000110
                .byte %00011100
                .byte %00000110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$52 - 4
                .byte %00001100
                .byte %00011100
                .byte %00111100
                .byte %01101100
                .byte %01111110
                .byte %00001100
                .byte %00001100
                .byte %00000000

                ; CHR$53 - 5
                .byte %01111110
                .byte %01100000
                .byte %01111100
                .byte %00000110
                .byte %00000110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$54 - 6
                .byte %00011100
                .byte %00110000
                .byte %01100000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$55 - 7
                .byte %01111110
                .byte %00000110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %00110000
                .byte %00110000
                .byte %00000000

                ; CHR$56 - 8
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$57 - 9
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000110
                .byte %00001100
                .byte %00111000
                .byte %00000000

                ; CHR$58 - :
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$59 - ;
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00110000

                ; CHR$60 - <
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100000
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00000000

                ; CHR$61 - =
                .byte %00000000
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$62 - >
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00000110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %00000000

                ; CHR$63 - ?
                .byte %00111100
                .byte %01100110
                .byte %00001100
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00000000

                ; CHR$64 - @
                .byte %00111100
                .byte %01100110
                .byte %01101110
                .byte %01101010
                .byte %01101110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$65 - A
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$66 - B
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %00000000

                ; CHR$67 - C
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$68 - D
                .byte %01111000
                .byte %01101100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01101100
                .byte %01111000
                .byte %00000000

                ; CHR$69 - E
                .byte %01111110
                .byte %01100000
                .byte %01100000
                .byte %01111100
                .byte %01100000
                .byte %01100000
                .byte %01111110
                .byte %00000000

                ; CHR$70 - F
                .byte %01111110
                .byte %01100000
                .byte %01100000
                .byte %01111100
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %00000000

                ; CHR$71 - G
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %01101110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$72 - H
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$73 - I
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00000000

                ; CHR$74 - J
                .byte %00111110
                .byte %00001100
                .byte %00001100
                .byte %00001100
                .byte %00001100
                .byte %01101100
                .byte %00111000
                .byte %00000000

                ; CHR$75 - K
                .byte %01100110
                .byte %01101100
                .byte %01111000
                .byte %01110000
                .byte %01111000
                .byte %01101100
                .byte %01100110
                .byte %00000000

                ; CHR$76 - L
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01111110
                .byte %00000000

                ; CHR$77 - M
                .byte %01100011
                .byte %01110111
                .byte %01111111
                .byte %01101011
                .byte %01101011
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$78 - N
                .byte %01100110
                .byte %01100110
                .byte %01110110
                .byte %01111110
                .byte %01101110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$79 - O
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$80 - P
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %00000000

                ; CHR$81 - Q
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01101010
                .byte %01101100
                .byte %00110110
                .byte %00000000

                ; CHR$82 - R
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %01101100
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$83 - S
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %00111100
                .byte %00000110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$84 - T
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$85 - U
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$86 - V
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00000000

                ; CHR$87 - W
                .byte %01100011
                .byte %01100011
                .byte %01101011
                .byte %01101011
                .byte %01111111
                .byte %01110111
                .byte %01100011
                .byte %00000000

                ; CHR$88 - X
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$89 - Y
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$90 - Z
                .byte %01111110
                .byte %00000110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100000
                .byte %01111110
                .byte %00000000

                ; CHR$91 - [
                .byte %01111100
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01111100
                .byte %00000000

                ; CHR$92 - \
                .byte %00000000
                .byte %01100000
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00000110
                .byte %00000000
                .byte %00000000

                ; CHR$93 - ]
                .byte %00111110
                .byte %00000110
                .byte %00000110
                .byte %00000110
                .byte %00000110
                .byte %00000110
                .byte %00111110
                .byte %00000000

                ; CHR$94 - ^
                .byte %00011000
                .byte %00111100
                .byte %01100110
                .byte %01000010
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$95 - _
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11111111

                ; CHR$96
                .byte %00011100
                .byte %00110110
                .byte %00110000
                .byte %01111100
                .byte %00110000
                .byte %00110000
                .byte %01111110
                .byte %00000000

                ; CHR$97 - a
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$98 - b
                .byte %01100000
                .byte %01100000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %00000000

                ; CHR$99 - c
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$100 - d
                .byte %00000110
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$101 - e
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$102 - f
                .byte %00011100
                .byte %00110000
                .byte %00110000
                .byte %01111100
                .byte %00110000
                .byte %00110000
                .byte %00110000
                .byte %00000000

                ; CHR$103 - g
                .byte %00000000
                .byte %00000000
                .byte %00111110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000110
                .byte %00111100

                ; CHR$104 - h
                .byte %01100000
                .byte %01100000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$105 - i
                .byte %00011000
                .byte %00000000
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$106 - j
                .byte %00011000
                .byte %00000000
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %01110000

                ; CHR$107 - k
                .byte %01100000
                .byte %01100000
                .byte %01100110
                .byte %01101100
                .byte %01111000
                .byte %01101100
                .byte %01100110
                .byte %00000000

                ; CHR$108 - l
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$109 - m
                .byte %00000000
                .byte %00000000
                .byte %00110110
                .byte %01111111
                .byte %01101011
                .byte %01101011
                .byte %01100011
                .byte %00000000

                ; CHR$110 - n
                .byte %00000000
                .byte %00000000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$111 - o
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$112 - p
                .byte %00000000
                .byte %00000000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %01100000
                .byte %01100000

                ; CHR$113 - q
                .byte %00000000
                .byte %00000000
                .byte %00111110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000110
                .byte %00000111

                ; CHR$114 - r
                .byte %00000000
                .byte %00000000
                .byte %01101100
                .byte %01110110
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %00000000

                ; CHR$115 - s
                .byte %00000000
                .byte %00000000
                .byte %00111110
                .byte %01100000
                .byte %00111100
                .byte %00000110
                .byte %01111100
                .byte %00000000

                ; CHR$116 - t
                .byte %00110000
                .byte %00110000
                .byte %01111100
                .byte %00110000
                .byte %00110000
                .byte %00110000
                .byte %00011100
                .byte %00000000

                ; CHR$117 - u
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$118 - v
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00000000

                ; CHR$119 - w
                .byte %00000000
                .byte %00000000
                .byte %01100011
                .byte %01101011
                .byte %01101011
                .byte %01111111
                .byte %00110110
                .byte %00000000

                ; CHR$120 - x
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00111100
                .byte %01100110
                .byte %00000000

                ; CHR$121 - y
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000110
                .byte %00111100

                ; CHR$122 - z
                .byte %00000000
                .byte %00000000
                .byte %01111110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01111110
                .byte %00000000

                ; CHR$123 - {
                .byte %00001100
                .byte %00011000
                .byte %00011000
                .byte %01110000
                .byte %00011000
                .byte %00011000
                .byte %00001100
                .byte %00000000

                ; CHR$124 - |
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$125 - }
                .byte %00110000
                .byte %00011000
                .byte %00011000
                .byte %00001110
                .byte %00011000
                .byte %00011000
                .byte %00110000
                .byte %00000000

                ; CHR$126 - ~
                .byte %00110001
                .byte %01101011
                .byte %01000110
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$127
chr127:
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                
                ; CHR$128
                .if version==350
                .byte %01100110
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %00000000
                .else
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %01100110
                .byte %00000000
                .endif
                
                ; CHR$129
                .if version==350
                .byte %00111100
                .byte %01100110
                .byte %00111100
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %00000000
                .else
                .byte %00111100
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %01100110
                .byte %00000000
                .endif

                ; CHR$130
                .byte %00111111
                .byte %01100110
                .byte %01100110
                .byte %01111111
                .byte %01100110
                .byte %01100110
                .byte %01100111
                .byte %00000000
                
                ; CHR$131
                .if version==350
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %01100000
                .byte %01100110
                .byte %00111100
                .byte %00110000
                .byte %01100000
                .else
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100110
                .byte %00111100
                .byte %01100000
                .endif
                
                ; CHR$132
                .byte %00001100
                .byte %00011000
                .byte %01111110
                .byte %01100000
                .byte %01111100
                .byte %01100000
                .byte %01111110
                .byte %00000000

                ; CHR$133
                .if version==350
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000
                .else
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000
                .endif
                
                ; CHR$134
                .byte %01100110
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$135
                .if version==350
                .byte %00111100
                .byte %01000010
                .byte %10011001
                .byte %10100001
                .byte %10100001
                .byte %10011001
                .byte %01000010
                .byte %00111100
                .else
                .byte %01111110
                .byte %11000011
                .byte %10011101
                .byte %10110001
                .byte %10011101
                .byte %11000011
                .byte %01111110
                .byte %00000000
                .endif

                ; CHR$136
                .byte %00000000
                .byte %00011000
                .byte %00111000
                .byte %01111111
                .byte %00111000
                .byte %00011000
                .byte %00000000
                .byte %00000000

                ; CHR$137
                .byte %00000000
                .byte %00011000
                .byte %00011100
                .byte %11111110
                .byte %00011100
                .byte %00011000
                .byte %00000000
                .byte %00000000

                ; CHR$138
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00111100
                .byte %00011000
                .byte %00000000

                ; CHR$139
                .byte %00000000
                .byte %00011000
                .byte %00111100
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$140
                .byte %00110000
                .byte %00011000
                .byte %00111100
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$141
                .byte %00110000
                .byte %00011000
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$142
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$143
                .byte %00111100
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$144
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$145
                .byte %00111100
                .byte %01100110
                .byte %00111100
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$146
                .byte %00000000
                .byte %00000000
                .byte %00111111
                .byte %00001101
                .byte %00111111
                .byte %01101100
                .byte %00111111
                .byte %00000000

                ; CHR$147
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %01100110
                .byte %00111100
                .byte %01100000

                ; CHR$148
                .byte %00001100
                .byte %00011000
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$149
                .if version==350
                .byte %01100110
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000
                .else
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000
                .endif
                
                ; CHR$150
                .if version==350
                .byte %01100110
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000000
                .else
                .byte %01100110
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000000
                .endif
                
                ; CHR$151
                .byte %00110000
                .byte %00011000
                .byte %00000000
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$152
                .byte %00111100
                .byte %01100110
                .byte %00000000
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$153
                .byte %00110000
                .byte %00011000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$154
                .byte %00111100
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$155
                .byte %00110000
                .byte %00011000
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$156
                .byte %00111100
                .byte %01100110
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$157
                .byte %01100110
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000110
                .byte %00111100

                ; CHR$158
                .byte %00000000
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %00000000

                ; CHR$159
                .byte %00111100
                .byte %01100000
                .byte %00111100
                .byte %01100110
                .byte %00111100
                .byte %00000110
                .byte %00111100
                .byte %00000000

                ; CHR$160
                .byte %00111100
                .byte %01100110
                .byte %00111100
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$161
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$162
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011111
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$163
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011111
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$164
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11111000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$165
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$166
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11111111
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$167
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11111111
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$168
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$169
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$170
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011111
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$171
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011111
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$172
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %11111000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$173
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %11111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$174
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %11111111
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$175
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %11111111
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$176
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000111
                .byte %00001100
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$177
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11100000
                .byte %00110000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$178
                .byte %00011000
                .byte %00011000
                .byte %00001100
                .byte %00000111
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$179
                .byte %00011000
                .byte %00011000
                .byte %00110000
                .byte %11100000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$180
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00110000
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$181
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$182
                .byte %00110110
                .byte %01101100
                .byte %00000000
                .byte %01100110
                .byte %01110110
                .byte %01101110
                .byte %01100110
                .byte %00000000

                ; CHR$183
                .byte %00110110
                .byte %01101100
                .byte %00000000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$184
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$185
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00000000

                ; CHR$186
                .if version==350
                .byte %00011000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .else
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .endif
                
                ; CHR$187
                .if version==350
                .byte %00110000
                .byte %00011000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .else
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .endif
                
                ; CHR$188
                .if version==350
                .byte %00000011
                .byte %00111110
                .byte %01110110
                .byte %01110110
                .byte %00110110
                .byte %00110110
                .byte %00111110
                .byte %00000000
                .else
                .byte %00111111
                .byte %01111011
                .byte %01111011
                .byte %00111011
                .byte %00011011
                .byte %00011011
                .byte %00011111
                .byte %00000000
                .endif
                
                ; CHR$189
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$190
                .byte %00000011
                .byte %00000011
                .byte %00000110
                .byte %00000110
                .byte %01110110
                .byte %00011100
                .byte %00001100
                .byte %00000000

                ; CHR$191
                .byte %10101010
                .byte %01010101
                .byte %10101010
                .byte %01010101
                .byte %10101010
                .byte %01010101
                .byte %10101010
                .byte %01010101

                ; CHR$192
                .byte %00111110
                .byte %01100011
                .byte %01100111
                .byte %01101011
                .byte %01110011
                .byte %01100011
                .byte %00111110
                .byte %00000000

                ; CHR$193
                .byte %00011100
                .byte %00110110
                .byte %01100011
                .byte %01100011
                .byte %01111111
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$194
                .byte %01111110
                .byte %00110011
                .byte %00110011
                .byte %00111110
                .byte %00110011
                .byte %00110011
                .byte %01111110
                .byte %00000000

                ; CHR$195
                .byte %01111111
                .byte %01100011
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %00000000

                ; CHR$196
                .byte %00011100
                .byte %00011100
                .byte %00110110
                .byte %00110110
                .byte %01100011
                .byte %01100011
                .byte %01111111
                .byte %00000000

                ; CHR$197
                .byte %01111111
                .byte %00110011
                .byte %00110000
                .byte %00111110
                .byte %00110000
                .byte %00110011
                .byte %01111111
                .byte %00000000

                ; CHR$198
                .byte %01111110
                .byte %01100110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100110
                .byte %01111110
                .byte %00000000

                ; CHR$199
                .byte %01110111
                .byte %00110011
                .byte %00110011
                .byte %00111111
                .byte %00110011
                .byte %00110011
                .byte %01110111
                .byte %00000000

                ; CHR$200
                .byte %00111110
                .byte %01100011
                .byte %01100011
                .byte %01111111
                .byte %01100011
                .byte %01100011
                .byte %00111110
                .byte %00000000

                ; CHR$201
                .byte %00111100
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$202
                .byte %01100011
                .byte %01100110
                .byte %01101100
                .byte %01111000
                .byte %01101100
                .byte %01100110
                .byte %01100011
                .byte %00000000

                ; CHR$203
                .byte %00011100
                .byte %00011100
                .byte %00110110
                .byte %00110110
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$204
                .byte %01100011
                .byte %01110111
                .byte %01111111
                .byte %01101011
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$205
                .byte %01100011
                .byte %01110011
                .byte %01111011
                .byte %01101111
                .byte %01100111
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$206
                .byte %01111110
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %00000000
                .byte %00000000
                .byte %01111110
                .byte %00000000

                ; CHR$207
                .byte %00111110
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %00111110
                .byte %00000000

                ; CHR$208
                .byte %01111111
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00000000

                ; CHR$209
                .byte %01111110
                .byte %00110011
                .byte %00110011
                .byte %00111110
                .byte %00110000
                .byte %00110000
                .byte %01111000
                .byte %00000000

                ; CHR$210
                .byte %01111111
                .byte %01100011
                .byte %00110000
                .byte %00011000
                .byte %00110000
                .byte %01100011
                .byte %01111111
                .byte %00000000

                ; CHR$211
                .byte %01111110
                .byte %01011010
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$212
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$213
                .byte %00111110
                .byte %00001000
                .byte %00111110
                .byte %01101011
                .byte %00111110
                .byte %00001000
                .byte %00111110
                .byte %00000000

                ; CHR$214
                .byte %01100011
                .byte %01100011
                .byte %00110110
                .byte %00011100
                .byte %00110110
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$215
                .byte %00111110
                .byte %00001000
                .byte %01101011
                .byte %01101011
                .byte %00111110
                .byte %00001000
                .byte %00111110
                .byte %00000000

                ; CHR$216
                .byte %00111110
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %00110110
                .byte %00110110
                .byte %01100011
                .byte %00000000

                ; CHR$217
                .byte %01111111
                .byte %01100011
                .byte %01100011
                .byte %00110110
                .byte %00110110
                .byte %00011100
                .byte %00011100
                .byte %00000000

                ; CHR$218
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %01111110
                .byte %00000000

                ; CHR$219
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00011000

                ; CHR$220
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$221
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00000000

                ; CHR$222
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$223
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$224
                .if version==350
                .byte %00000000
                .byte %00000010
                .byte %00111100
                .byte %01101110
                .byte %01110110
                .byte %01100110
                .byte %10111100
                .byte %00000000
                .else
                .byte %00000000
                .byte %00000011
                .byte %00111110
                .byte %01100111
                .byte %01101011
                .byte %01110011
                .byte %00111110
                .byte %01100000
                .endif
                
                ; CHR$225
                .byte %00000000
                .byte %00000000
                .byte %00111011
                .byte %01101110
                .byte %01100110
                .byte %01101110
                .byte %00111011
                .byte %00000000

                ; CHR$226
                .byte %00011110
                .byte %00110011
                .byte %00110011
                .byte %00111110
                .byte %00110011
                .byte %00110011
                .byte %00111110
                .byte %01100000

                ; CHR$227
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %00110110
                .byte %00011100
                .byte %00011000
                .byte %00110000
                .byte %00110000

                ; CHR$228
                .byte %00111100
                .byte %01100000
                .byte %00110000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$229
                .byte %00000000
                .byte %00000000
                .byte %00011110
                .byte %00110000
                .byte %00011100
                .byte %00110000
                .byte %00011110
                .byte %00000000

                ; CHR$230
                .byte %00111110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100000
                .byte %01100000
                .byte %00111110
                .byte %00000110

                ; CHR$231
                .byte %00000000
                .byte %00000000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000110
                .byte %00000110

                ; CHR$232
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$233
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00001100
                .byte %00000000

                ; CHR$234
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %01101100
                .byte %01111000
                .byte %01101100
                .byte %01100110
                .byte %00000000

                ; CHR$235
                .byte %01100000
                .byte %00110000
                .byte %00011000
                .byte %00011100
                .byte %00110110
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$236
                .byte %00000000
                .byte %00000000
                .byte %00110011
                .byte %00110011
                .byte %00110011
                .byte %00110011
                .byte %00111110
                .byte %01100000

                ; CHR$237
                .byte %00000000
                .byte %00000000
                .byte %01100011
                .byte %00110011
                .byte %00011011
                .byte %00011110
                .byte %00011100
                .byte %00000000

                ; CHR$238
                .if version==350
                .byte %00001100
                .byte %00111110
                .byte %01100000
                .byte %00111100
                .byte %01100000
                .byte %00111110
                .byte %00000110
                .byte %00001100
                .else
                .byte %00111100
                .byte %01100000
                .byte %01100000
                .byte %00111100
                .byte %01100000
                .byte %01100000
                .byte %00111110
                .byte %00000110
                .endif
                
                ; CHR$239
                .byte %00000000
                .byte %00000000
                .byte %00111110
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %00111110
                .byte %00000000

                ; CHR$240
                .byte %00000000
                .byte %00000000
                .byte %01111111
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00000000

                ; CHR$241
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %01100000
                .byte %01100000

                ; CHR$242
                .byte %00000000
                .byte %00000000
                .byte %00111111
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$243
                .byte %00000000
                .byte %00000000
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00001100
                .byte %00000000

                ; CHR$244
                .byte %00000000
                .byte %00000000
                .byte %01110011
                .byte %00110011
                .byte %00110011
                .byte %00110011
                .byte %00011110
                .byte %00000000

                ; CHR$245
                .byte %00000000
                .byte %00000000
                .byte %00111110
                .byte %01101011
                .byte %01101011
                .byte %00111110
                .byte %00011000
                .byte %00011000

                ; CHR$246
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %00110110
                .byte %00011100
                .byte %00011100
                .byte %00110110
                .byte %00110011

                ; CHR$247
                .byte %00000000
                .byte %00000000
                .byte %01100011
                .byte %01101011
                .byte %01101011
                .byte %00111110
                .byte %00011000
                .byte %00011000

                ; CHR$248
                .if version==350
                .byte %00000000
                .byte %00000000
                .byte %01100011
                .byte %01100011
                .byte %01101011
                .byte %01111111
                .byte %00110110
                .byte %00000000
                .else
                .byte %00000000
                .byte %00000000
                .byte %00110110
                .byte %01100011
                .byte %01101011
                .byte %01111111
                .byte %00110110
                .byte %00000000
                .endif
                
                ; CHR$249
                .byte %00111000
                .byte %00001100
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$250
                .byte %00000000
                .byte %00110001
                .byte %01101011
                .byte %01000110
                .byte %00000000
                .byte %01111111
                .byte %00000000
                .byte %00000000

                ; CHR$251
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %00000000

                ; CHR$252
                .byte %00000111
                .byte %00011100
                .byte %01110000
                .byte %00011100
                .byte %00000111
                .byte %00000000
                .byte %01111111
                .byte %00000000

                ; CHR$253
                .byte %00000110
                .byte %00001100
                .byte %01111110
                .byte %00011000
                .byte %01111110
                .byte %00110000
                .byte %01100000
                .byte %00000000

                ; CHR$254
                .byte %01110000
                .byte %00011100
                .byte %00000111
                .byte %00011100
                .byte %01110000
                .byte %00000000
                .byte %01111111
                .byte %00000000

                ; CHR$255
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
