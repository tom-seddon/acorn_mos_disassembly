; -*- comment-column:45; -*-

terminal: .block

                .if version==320
                
                jmp terminalLanguageEntryPoint ; Language entry point
                jmp terminalServiceEntryPoint  ; Service entry point
                .byte $C2                    ; ROM type=SERV+LANG+6502
                .byte copyrightText-1-terminal ; (C) offset
                .byte $01
                .text "TERMINAL"
                .byte 0
copyrightText:
                .text "(C)1984 Acorn"
                .byte 0

                .elsif version>=500

                ; Language entry point
                brk                          
                brk
                brk

                ; Service entry point
                brk
                brk
                brk

                .byte $82
                .byte copyright-1-terminal
                .byte 0
                .text "UTILS",0
copyright:
                .text "(C)1986 Acorn",0

                .endif
                
; STARTUP
; =======
reset:                          ;8020
                lda #~ACCCON.D  ;display main RAM
                trb ACCCON
                .if version==320
                stz hazel.hasACCCONChanged
                .endif
                trb $0366
                cld
                ldx #$FF
                txs              ;reset stack
                stx userVIA.ddra ;port A all outputs
                lda #%11001111
                sta systemVIA.ddrb ;
                .if version==320
                ldy #RTC.a.dv32768Hz
                ldx #RTC.a
                jsr writeRTCByte
                jsr finishRTCUpdate
                .endif
                lda #ACCCON.Y|ACCCON.X       ; page in HAZEL+shadow
                tsb ACCCON
                .if version>=500
                stz hazel.hasACCCONChanged
                jsr L8363
                .endif
                lda systemVIA.ier
                asl a
                pha
                .if version==320
                beq startClearRAM       ; branch taken if power on
                lda breakAndESCAPEEffect                    ; read BREAK action flags
                                             ; (set by *FX200)
                lsr a                        ; divide by 2 to get the
                                             ; break action
                dec a                        ; Z=1 if it was 1
                bne L8073                    ; branch taken if break
                                             ; action says don't clear
                                             ; RAM
                .elsif version>=500
                bne L8073
                ldx #7
                jsr mos.LF8B4
                tya
                .endif                                             
startClearRAM
                tay             ;Y=0
clearRAM:
                tya             ;A=0
                stz $01
                stz $00         ;start at $0000
-
                sta ($00),y     ;clear RAM
                iny
                bne -
                inc $01
                ldx #$40          ;$40=RTI
                stx nmiEntryPoint ;restore the RTI previously written,
                                  ;as each iteration will potentially
                                  ;overwrite it
                ldx $01
                cpx #$E0        ;hit the end of RAM?
                bcc -           ;branch taken if still more to go
                lda #ACCCON.X   ;page out shadow RAM
                trb ACCCON
                bne clearRAM    ;branch taken if shadow RAM bit
                             ;previously set - i.e., that was the
                             ;first iteration, and we need to go back
                             ;to do main RAM
                .if version>=500
                lda $fe28
                lda $fe2b
                .endif
L8073:
                .if version>=500
                lda breakAndESCAPEEffect
                lsr a
                dec a
                beq startClearRAM
                .endif
                lda #<mos.emptyCommandLine
                sta hazel.commandLinePointer+0
                lda #>mos.emptyCommandLine
                sta hazel.commandLinePointer+1
                lda #ACCCON.Y|ACCCON.X ; page in MOS ROM, page in main
                                       ; RAM
                trb ACCCON
                lda #$0F                     ; 8084= 8D 8E 02    ...
                sta numericKeypadShiftEffect
                .if version==320
-
                dec a                        ; 8088= 8D 40 FE    .@~
                sta systemVIA.orb
                cmp #$09                     ; 808D= B0 F8       0x
                bcs -
                .endif
                ldx #key_ctrl
                jsr mos.interrogateKeyboard
                cpx #$80        ;Z=0 C=1 if CTRL+BREAK
                jsr mos.updateKeyboardLEDs
                stz lastBREAKType            ;softBREAK
                ror a
                ldx #<intervalTimer ; TODO - $9C - is this right?
                ldy #$8D
                pla
                beq L80AD
                ldy #$7E
                bcc L80DF
                ldy #$87
                inc lastBREAKType
L80AD:
                inc lastBREAKType
                phy
                .if version==320
                jsr readDefaultMODE          ; Read configured MODE
                .elsif version>=500
                jsr utils_9E58
                ldx #$4d
                jsr utils_8A64
                .endif
L80B4:
                ora #$08    ; Store in OSBYTE 255 with boot off (b3=1)
                sta startupOptions
L80B9:
                jsr readDefaults3            ; Read configured BOOT
                and #CMOSBytes.defaults3.autoBootMask
                lsr a         ; Reset OSBYTE 255 boot bit (b3) if BOOT
                trb startupOptions
                jsr readDefaultTVSettings
                sty tvOffset
                stx tvInterlace
L80CB:
                jsr readDefaults3
                and #CMOSBytes.defaults3.protectedScrollingMask
                beq L80D4
                lda #VDUVariables.cursorFlags.scrollProtect
L80D4:
                sta vduv.cursorFlags
                jsr restoreFont32To255
                ply
                ldx #<timer0 ; $92
                bra initializePage2Loop

L80DF:
                .if version>=500
                jsr utils_9E58
                .endif
                lda #$87             ; Clear MODE bits from OSBYTE 255
                trb startupOptions
                lda vduv.currentScreenMODE ; Get current screen MODE b0-b2
                and #$07
                tsb startupOptions           ; Copy to OSBYTE 255
                lda #STATE.isShadowMode ; Test shadow screen bit in VDU flags
                bit STATE                      ; Not shadow screen
                beq initializePage2Loop
                lda #$80                     ; Set shadow screen bit in OSBYTE 255
                tsb startupOptions
initializePage2Loop:
                lda lastBREAKType
                bne clearPage2Byte           ;taken unless soft BREAK

                ; leave the ROM information table alone on a soft
                ; BREAK.
                cpx #<romInformationTable+16
                bcs clearPage2Byte
                cpx #<romInformationTable
                bcs nextPage2Byte
clearPage2Byte:
                stz $0200,x
                cpx #$CD
                bcc nextPage2Byte
                dec $0200,x                  ;initialize later values to $ff
nextPage2Byte:
                inx
                bne initializePage2Loop

                ldx #$CF                     
initializeZeroPageLoop:
                stz $00,x                    
                inx                          
                bne initializeZeroPageLoop
                lda lastBREAKType
                bne L813D                    ;taken if not soft BREAK

                lda noignoreState
                pha
                lda basicROMNumber
                pha
                lda oshwm
                pha
                lda spoolFileHandle
                pha
                ldx execFileHandle
                
L8130:
                lda mos.defaultVectorTable-1,y
                sta vectors-1,y       
                dey                   
                cpy #EVENTV+1-vectors 
                bcs L8130             
                ldy #FILEV-vectors
                
L813D:
                lda mos.defaultVectorTable-1,y ; 813D= B9 D6 E2    9Vb
                sta vectors-1,y   ; 8140= 99 FF 01    ...
                dey                          ; 8143= 88          .
                bne L813D                    ; 8144= D0 F7       Pw
                lda lastBREAKType
                bne L8164                    ; 8149= D0 19       P.
                stx execFileHandle
                pla                          ;restore *SPOOL file handle
                cmp #$04                     ;is it a TAPE or ROM handle?
                bcs +                    ;taken if no - keep it
                lda #$00          ;auto-close it if TAPE or ROM handle
+
                sta spoolFileHandle
                pla
                sta oshwm
                pla               
                sta basicROMNumber
                pla               
                sta noignoreState
L8164:
                .if version==320
                jsr readDefaults1
                .elsif version>=500
                ldx #$0b
                jsr utils_9DCA
                .endif
                ldx #keyboardStatusByte.shiftLockDisengaged
                asl a                        
                asl a                        ;N=defaultCapsLockMask
                bmi gotKeyboardStatusByte                    ;taken if defaultCapsLock
                ldx #keyboardStatusByte.shiftLockDisengaged|keyboardStatusByte.capsLockDisengaged
                asl a                        ;N=defaultNoLockMask
                bmi gotKeyboardStatusByte
                ldx #keyboardStatusByte.shiftEnabled|keyboardStatusByte.shiftLockDisengaged
gotKeyboardStatusByte:
                stx keyboardStatusByte
                jsr mos.selectTerminalROM
                jsr mos.resetKeyRepeat
                lda lastBREAKType
                beq L8196
                .if version==320
                jsr readDefaultPrinterIgnoreChar
                .elsif version>=500
                ldx #$0e
                jsr utils_9DCA
                .endif
                sta printerIgnoreChar
                .if version==320
                jsr readDefaults2
                lsr a                        ;C=tubeOn
                lsr a                        ;C=usePrinterIgnoreChar
                .elsif version==500
                jsr readUsePrinterIgnoreChar
                .endif
                ror noignoreState
                .if version==320
                jsr readDefaultFX5Settings
                .elsif version>=500
                ldx #$75
                jsr utils_8A64
                .endif
                sta printerDriverType
L8196:
                .if version==320
                jsr readDefaultSerialDataFormat
                .elsif version>=500
                ldx #$19
                jsr utils_8A64
                .endif
                asl a                        ;
                asl a       ;shift into the control registerword field
                ora #ACIA.control.rtsHighTXInterruptDisabled|ACIA.control.counterDivide64
                sta aciaControlRegister

                .if version==320
                jsr resetACIAThenRewriteControlRegister
                ldx #$01
                .elsif version>=500
                ldx #$12
                jsr utils_9DCA
                sta adcConversionType
                ldx #$ff
L81B2:
                jsr utils_ADD7
                lda $fe08
                bne L81C8
                lda #$20
                sta $fe08
                lda $fe08
                and #$f7
                cmp #$82
                beq L81CF
L81C8:
                cmp #8
                beq L81CF
                stz rs423InterruptMask
L81CF:
                dex
                bne L81B2
                jsr utils_AD9B
                inx
                .endif
                
                lda #$7F
initializeVIAInterruptsLoop:
                sta systemVIA.ifr,x          
                sta userVIA.ifr,x            
                dex                          
                bpl initializeVIAInterruptsLoop

                ; Let through 1 IRQ.
                cli                          
                sei

                ; $FC was cleared above, so if bit 6 is set, there
                ; must have been an IRQ (as A=$7f). 
                bit $FC
                bvc +
                jsr mos.call1MHzBusHook
+
                ldx #$80|VIA.irq.t1|VIA.irq.cb1|VIA.irq.ca1
                stx systemVIA.ier
                .if version>=500
                ldx #$80|VIA.irq.cb1|VIA.irq.cb2
                stx userVIA.ier
                .endif
                ldx #VIA.pcr.cb2InputNegativeActiveEdge|VIA.pcr.cb1NegativeActiveEdge|VIA.pcr.ca2InputPositiveEdge|VIA.pcr.ca1NegativeActiveEdge
                stx systemVIA.pcr
                lda #VIA.acr.t1Continuous|VIA.acr.t2Timer|VIA.acr.srDisabled|VIA.acr.pbLatchDisabled|VIA.acr.paLatchDisabled
                sta systemVIA.acr
                lda #$0E
                sta systemVIA.t1lL
                sta userVIA.pcr              ;VIA.pcr.cb2InputNegativeActiveEdge|VIA.pcr.cb1NegativeActiveEdge|VIA.pcr.ca2HighOutput|VIA.pcr.ca1NegativeActiveEdge
                .if version==320
                sta HADC.latch               ;looks benign
                .endif
                lda #$27
                sta systemVIA.t1lH
                sta systemVIA.t1cH
                .if version==320
                ldx #$08
L81DD:
                dex
                jsr mos.LF55D
                cpx #$04
                bne L81DD
                .elsif version>=500
                jsr utils_836D
                .endif
                jsr mos.osbyte7A             
                stx firstKeyPressedInternal
                ldx #$00
                .if version>=500
                stx userVIA.ddrb
                .endif
                jsr mos.purgeBuffer
                lda serialULARegister
                and #$7F
                jsr mos.LEC89
                .if version==320
                jsr readDefaultSerialBaudRateIndex
                .elsif version>=500
                ldx #$7
                jsr utils_8A64
                .endif
                pha
                tax
                jsr mos.osbyte08
                plx
                lda #$07
                jsr mos.osbyte07
                jsr readDefaults3
                bit #$02
                bne L8211
                lda #$F0
                sta bellSound
L8211:
                jsr mos.selectTerminalROM
                ldx softKeyConsistencyFlag
                beq scanROMs
                jsr mos.osbyte12             ;
scanROMs:
                lda lastBREAKType
                beq romsScanned                    ;taken if soft BREAK
                jmp mos.scanROMs
romsScanned:
                lda startupOptions
                jsr mos.setStartupMODE
                lda lastBREAKType
                dec a
                bne L8284                    ;taken if not power-on reset
                .if version>=500
                ldx #$ff
                jsr utils_9ECA
                bcs checkForResetKey
                tya
                and #$7f
                cmp #$30
                beq checkForResetKey
                ldx #0
                ldy #0
                jsr utils_9E99
                bra resetCMOSRAM
                .endif
checkForResetKey:
                lda firstKeyPressedInternal
                cmp #key_r
                bne L8284                    ;taken if R not pressed

                ; Reset CMOS RAM
resetCMOSRAM
                .if version==320
                ldx #size(RTC.ram)-1
resetCMOSRAMLoop:
                phx                          
                ldy #$00                     
                jsr writeCMOSByte            
                plx                          
                dex                          
                bpl resetCMOSRAMLoop

                ; Initialize ROM insertion flags.                
                ldy #$FF
                ldx #CMOSBytes.insertedROMs+0
                jsr writeCMOSByte
                ldx #CMOSBytes.insertedROMs+1
                jsr writeCMOSByte
                .elsif version>=500
L827E:
                ldx #$13
L8280:
                phx
                dex
                jsr utils_9DE1
                jsr utils_9DF8
                plx
                dex
                bne L8280
                ldx #$7f
                jsr utils_9ECA
                tya
                and #$80
                eor #$b0
                tay
                ldx #$ff
                jsr utils_9E99
                .endif
                
                jsr alwaysPrintFollowingMessage
                .if version>=500
                .byte 22,7
                .endif
                .text 13,10
                .if version==320
                .text "CMOS RAM reset"
                .elsif version>=500
                .text "Options reset"
                .endif
                .text 13,10,"Press break to continue"
                .text 13,10,0
                
                lda #$03
                sta breakAndESCAPEEffect
hang:
                bra hang

;-------------------------------------------------------------------------

L8284:
                jsr mos.selectHAZEL
                stz hazel.moveSrcHandle
                stz hazel.moveDestHandle
                ldy #$CA
                jsr mos.insertCharacterIntoKeyboardBuffer
                jsr mos.osbyte247EntryPoint
                lda lastBREAKType
                beq L829D
                jsr mos.LEDD0
L829D:
                .if version==320
                jsr readDefaults2
                lsr a
                bcc L82D0
                jsr readDefaults3
                bit #$04
                php
                lda #ACCCON.ITU
                trb ACCCON
                plp
                bne L82B4
                tsb ACCCON
L82B4:
                jsr mos.LE375 ; If Tube hardware present, jump to Tube PreInit
                bcs L82C6
                lda ACCCON                    ; Toggle Internal/External Tube
                eor #ACCCON.ITU
                sta ACCCON
                jsr mos.LE375        ; No Tube, skip past Tube PreInit
                bcc L82D0
L82C6:
                ldx #romServiceCallTubeMainInitialisation
                jsr mos.makeROMServiceCall   ;
                bne L82D0                    ; Not claimed, step past
                dec tubePresence ; Tube PreInit claimed, set TubeFlag to &FF, Tube present
L82D0:
                .endif
                lda lastBREAKType ; Soft Break, don't ask about workspace
                beq L82FC
                ldy #$DC                     ; Start high workspace at &DC00 and work downwards
                ldx #romServiceCallCountDynamicHAZELWorkspace ; Ask ROMs how much private high workspace required
                jsr mos.makeROMServiceCall   ;
                ldx #romServiceCallAbsoluteHAZELWorkspaceClaim ; Ask ROMs for maximum shared high workspace required
                jsr mos.makeROMServiceCall   ;
                phy                          ; Save top of shared workspace
                ldx #romServiceCallPrivateHAZELWorkspaceClam ; Ask ROMs for private high workspace required
                jsr mos.makeROMServiceCall   ;
                ldy #$0E                     ; Start low workspace at &0E00
                ldx #romServiceCallAbsoluteWorkspaceClaim ; Ask ROMs for maximum shared workspace
                jsr mos.makeROMServiceCall   ;
                ldx #romServiceCallPrivateWorkspaceClaim ; Ask ROMs for private workspace
                jsr mos.makeROMServiceCall   ;
                sty oshwm                    ; Set OSHWM - default PAGE
                ply                          ; Get top of shared high workspace
                ldx #romServiceCallTopOfHAZELWorkspace ; Tell ROMs top of shared high workspace
                jsr mos.makeROMServiceCall   ;
L82FC:
                ldx #size(defaultFsInfoBlocks)
L82FE:
                lda defaultFsInfoBlocks-1,x                ; Copy initial FS info blocks for CFS, TAPE, ROM
                sta hazel.fsInfoBlocks-1,x
                dex
                bne L82FE
                stz $F2                      ; &F2/3=>FS Info Blocks
                lda #>hazel.fsInfoBlocks
                sta $F3
                ldy #<hazel.fsInfoBlocks+3*size(fsInfoBlock) ; Y=>end
                                                             ; of FS
                                                             ; Info
                                                             ; Blocks
                ldx #$25                     ; Ask ROMs for FS Info Blocks
                jsr mos.makeROMServiceCall   ;
                lda #$00                     ; Terminate FS Info blocks
                sta ($F2),y

                lda spoolFileHandle ; Save Spool handle and disable Spooling
                pha
                stz spoolFileHandle
                ldx #romServiceCallTubeSystemPostInitialisation
                ldy tubePresence
                jsr mos.makeROMServiceCall   ; Tube PostInit
                and startupMessageSuppressionStatus
                bpl L8340
                ldy #((mos.startupMessages.acornMOS-mos.startupMessages)-1)&$ff
                jsr mos.printStartupMessage
                lda lastBREAKType            ; Skip past if Soft Break
                beq L833B
                ldy #((mos.startupMessages.beep-mos.startupMessages)-1)&$ff
                jsr mos.printStartupMessage
L833B:
                ldy #((mos.startupMessages.twoNewlines-mos.startupMessages)-1)&$ff
                jsr mos.printStartupMessage
L8340:
                pla                          ; Restore Spool handle
                sta spoolFileHandle
                jmp mos.LE40E                ;

;-------------------------------------------------------------------------

                .if version>=500
L8363:
                lda #$0f
L8365:
                dec a
                sta $fe40
                cmp #9
                bcs L8365
L836D:
                ldx #8
L836F:
                dex
                jsr mos.LF55D
                cpx #4
                bne L836F
                rts
                .endif

;-------------------------------------------------------------------------

; Default FS Info Blocks
; ======================
defaultFsInfoBlocks: .block
                .if version==320
                .text "CFS     "
                .byte $01
                .byte $02
                .byte $01
                .text "TAPE    "
                .byte $01
                .byte $02
                .byte $01
                .endif
                .text "ROM     "
                .byte $03
                .byte $03
                .byte $03
                .endblock

;-------------------------------------------------------------------------
; 
; MOS command table

mos_command .macro name,routine,byte1,byte2
                .text \name
                .beword \routine
                .byte \byte1
                .byte \byte2
                .endm
                
mosCommandTable:
                .mos_command "CAT",mos.callFSCV,$80,$05 ; XY=>parameters, FSC &05
                .mos_command "ADFS",passStarCommandThrough,$00,$00   ;
                .mos_command "APPEND",starAPPEND,$80,$00 ; XY=>parameters
                .mos_command "BASIC",starBASIC,$00,$00  ;
                .mos_command "BUILD",starBUILD,$80,$00  ; XY=>parameters
                .mos_command "CLOSE",starCLOSE,$00,$FF  ;
                .mos_command "CONFIGURE",starCONFIGURE,$00,$FF ;
                .mos_command "CODE",starCommandThroughOSBYTE,$00,$88 ; X,y=parameters, OSBYTE &88
                .mos_command "CREATE",starCommandThroughOSFILE,$80,$07 ; XY=>parameters, OSFILE &07
                .mos_command "DUMP",starDUMP,$80,$00   ; XY=>parameters
                .mos_command "DELETE",starDELETE,$80,$00 ; XY=>parameters
                .mos_command "EXEC",starEXEC,$80,$00   ; XY=>parameters
                .mos_command "EX",mos.callFSCV,$80,$09 ; XY=>parameters, FSC &09
                .mos_command "FX",starFX,$00,$FF ;
                .mos_command "GOIO",starGOIO,$00,$FF ;
                .mos_command "GO",starGO,$00,$FF   ;
                .mos_command "HELP",starHELP,$00,$FF ;
                .mos_command "INFO",mos.callFSCV,$80,$0A ; XY=>parameters, FSC &0A
                .mos_command "IGNORE",starIGNORE,$00,$FF ;
                .mos_command "INSERT",starINSERT,$00,$FF ;
                .mos_command "KEY",starKEY,$00,$FF    ;
                .mos_command "LOAD",starLOAD,$80,$00   ; XY=>parameters
                .mos_command "LIST",starLIST,$80,$00   ; XY=>parameters
                .mos_command "LINE",mos.callUSERV,$00,$01 ;
                .mos_command "LIBFS",mos.starLIBFS,$00,$00    ;
                .mos_command "MOTOR",starCommandThroughOSBYTE,$00,$89 ; X,y=parameters, OSBYTE &89
                .mos_command "MOVE",starMOVE,$80,$00  ; XY=>parameters
                .mos_command "OPT",starCommandThroughOSBYTE,$80,$8B ; X,y=parameters, OSBYTE &8B
                .mos_command "PRINT",starPRINT,$80,$00 ; XY=>parameters
                .mos_command "RUN",mos.callFSCV,$80,$04 ; XY=>parameters, FSC &04
                .mos_command "REMOVE",starREMOVE,$80,$00 ; XY=>parameters
                .mos_command "ROM",starCommandThroughOSBYTE,$00,$8D ; X,y=parameters, OSBYTE &8D
                .mos_command "ROMS",starROMS,$00,$FF ;
                .mos_command "SAVE",starCommandThroughOSFILE,$80,$00 ; XY=>parameters, OSFILE &00
                .mos_command "SHADOW",starSHADOW,$00,$FF  ;
                .mos_command "SHOW",starSHOW,$00,$FF    ;
                .mos_command "SHUT",mos.starSHUT,$00,$00 ;
                .mos_command "SPOOL",starSPOOL,$80,$00   ; XY=>parameters
                .mos_command "SPOOLON",starSPOOLON,$80,$00 ; XY=>parameters
                .if version>=500
                .mos_command "SRDATA",starSRDATAOrStarSRROM,$00,$a0
                .mos_command "SRLOAD",starSRLOADOrStarSRSAVE,$80,$60
                .mos_command "SRREAD",starSRREADOrStarSRWRITE,$00,$a0
                .mos_command "SRROM",starSRDATAOrStarSRROM,$00,$80
                .mos_command "SRSAVE",starSRLOADOrStarSRSAVE,$80,$20
                .mos_command "SRWRITE",starSRREADOrStarSRWRITE,$00,$e0
                .endif
                .mos_command "STATUS",starSTATUS,$00,$FF  ;
                .mos_command "TAPE",starCommandThroughOSBYTE,$00,$8C ; X,y=parameters, OSBYTE &8C
                .mos_command "TV",starCommandThroughOSBYTE,$00,$90 ; X,y=parameters, OSBYTE &90
                .mos_command "TIME",starTIME,$00,$00   ;
                .mos_command "TYPE",starTYPE,$80,$00   ; XY=>parameters
                .mos_command "UNPLUG",starUNPLUG,$00,$FF ;
                .if version==320
                .mos_command "X",mos.starX,$00,$00  ;
                .endif
                .mos_command "",mos.callFSCV,$00,$03 ; FSC &03
                .byte $00

;-------------------------------------------------------------------------

L84EE:
                lda (oscliWorkspace.tablePtr)
                bmi rts84FE
getStringInputBufferAddressWithYOffset:
                tya
getStringInputBufferAddressWithAOffset:
                clc
                adc stringInputBufferAddress+0
                tax
                ldy stringInputBufferAddress+1
                bcc +
                iny
+
                lda (oscliWorkspace.tablePtr)
rts84FE:
                rts        

; Prepare OSCLI command line
; ==========================
oscli:
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                lda hazel.currentFS
                jsr mos.selectFS
                lda #fscStarCommand
                jsr mos.callFSCV
                ldy #$FF
L8510:
                jsr mos.incAndSkipSpaces
                beq rts84FE
                cmp #'*'
                beq L8510
                jsr mos.skipSpacesAndCheckForCRInStringInput
                beq rts84FE
                cmp #'|'
                beq rts84FE
                stz hazel.tempFSFlag
                cmp #'-'
                bne L8535
                jsr mos.parseFileNameFS
                jsr mos.selectFS
                sec
                ror hazel.tempFSFlag
                lda (stringInputBufferAddress),y
L8535:
                cmp #'/'
                bne L8542
                iny
                jsr getStringInputBufferAddressWithYOffset
                lda #fscStarSlash
                jmp mos.callFSCV

L8542:
                .if version==320
                sty $E6
                .endif
                lda #<mosCommandTable
                sta oscliWorkspace.tablePtr+0
                lda #>mosCommandTable
                sta oscliWorkspace.tablePtr+1
                .if version==320
                bra L8558
                .elsif version>=500
                clv
                jsr utils_8A8F
                bcc passStarCommandThrough
                .endif

                .if version==320
L854E:
                eor (oscliWorkspace.tablePtr)
                and #$DF
                bne L8569
                jsr fetchCommandTableByte
                iny                          ; 8557= C8          H
L8558:
                lda (stringInputBufferAddress),y
                jsr mos.isLetter
                bcc L854E                    ;taken if letter
                lda (oscliWorkspace.tablePtr)
                bmi L8582                ;taken if end of command name
                lda (stringInputBufferAddress),y
                cmp #'.'                     
                beq L856D                    ;taken if input abbreviated
L8569:
                clc                          ; 8569= 18          .
                ldy $E6                      ; 856A= A4 E6       $f
                dey                          ; 856C= 88          .
L856D:
                iny                          ; 856D= C8          H
L856E:
                jsr fetchCommandTableByte ; Get byte from table, update pointer
                beq passStarCommandThrough   ; Zero byte
                bpl L856E                    ; Loop until b7 set
                bcs L8585                    ; 8575= B0 0E       0.
                jsr fetchCommandTableByte    
                jsr fetchCommandTableByte    
                jsr fetchCommandTableByte    
                bra L8558                    
                
L8582:
                jsr fetchCommandTableByte
                .endif
L8585:
                pha
                jsr fetchCommandTableByte
                pha
                jsr fetchCommandTableByte
                bmi L8592
                stz hazel.tempFSFlag
L8592:
                jsr mos.skipSpacesAndCheckForCRInStringInput
                clc                          
                php                          
                jsr L84EE                    
                rti                          

                .if version==320
fetchCommandTableByte:
                lda (oscliWorkspace.tablePtr)
                pha                          
                inc oscliWorkspace.tablePtr+0
                bne +
                inc oscliWorkspace.tablePtr+1
+
                pla                          
rts85A5:
                rts
                .endif

;-------------------------------------------------------------------------

; *BASIC
; ======
starBASIC:
                ldx basicROMNumber           ; Get BASIC ROM number
                bmi passStarCommandThrough ; If no BASIC ROM, jump to pass to ROMs and filing system
                .if version==320
                sec                          ;
                jmp mos.osbyte8E             ; Enter ROM as a language
                .elsif version>=500
                lda #$8e
                jmp OSBYTE
                .endif

;-------------------------------------------------------------------------

; *ADFS - pass straight to ROMs/Filing System
; ===========================================
passStarCommandThrough:
                bit hazel.tempFSFlag      ; Check filing system flag
                bmi L85C0                    ; If ... skip ROM service call
                stz hazel.tempFSFlag      ; Clear filing system flag
                ldy $E6
                ldx #romServiceCallUnrecognisedCommand
                jsr mos.osbyte8F    ; Service call 4 - Unknown command
                .if version==320
                beq rts85A5                    ; Claimed, return
                .elsif version>=500
                beq parseDone
                .endif
L85C0:
                lda $E6
                jsr getStringInputBufferAddressWithAOffset
                lda #$03
                jmp mos.callFSCV ; mos.Pass to FSCV,3 - Unknown command

starHELP:
                ldx #romServiceCallHelp      ;
                lda STATE                    ;
                pha                          ;save STATE
                lda #14
                jsr OSWRCH                   ; paged mode ON
                jsr mos.makeROMServiceCall   ; 
                ldx #romServiceCallReserved  ;???
                jsr mos.makeROMServiceCall
                pla                          ;restore STATE
                bit #STATE.isPagedScrolling  ;was paged mode on originally?
                bne parseDone   ;taken if paged mode was originally on
                                ;(branch target is an arbitrary nearby
                                ;RTS)
                lda #15         ;restore non-paged mode
                jmp OSWRCH

;-------------------------------------------------------------------------
;
; Read a byte value (0-255) from a string. If the number has a '&'
; prefix, interpret it as hex.
;
; entry:
;
; (stringInputBufferAddress),y - string
;
; exit:
;
; X = result
; ?$e6 = result
; C=0 if error
; Z=1 if CR encountered
; 
parseNumberFromString:
                jsr mos.skipSpacesAndCheckForCRInStringInput ; 85E6= 20 FF F2     .r
                cmp #'&'                     ; hex value incoming?
                bne parseDecimal             ; taken if not hex value
parseHex:
                iny                          ; skip '&'
                jsr readHexDigit             ; read first hex digit
                bcc errorReadingString
                sta $E6                      ; save first hex digit
                jsr readHexDigit             ; read second hex digih
                bcc parsedValue         ; taken if not hex digit
                ; The first digit read was actually the high nybble,
                ; and the current digit read is therefore the low
                ; nybble.
                ;
                ; Shift saved digit 4 bits left.
                ldx #$04                     
-
                asl $E6                      
                dex                          
                bne -
                tsb $E6                      ; insert low nybble
                jsr readHexDigit             ; read third hex digit
                bcs errorReadingString2 ; 3+-digit hex values are not valid
parsedValue:
                ldx $E6                      ; 8608= A6 E6       &f
                cmp #$0D                     ; 860A= C9 0D       I.
                sec                          ; 860C= 38          8
parseDone:
                rts                          ; 860D= 60          `

parseDecimal:
                jsr readDigitFromString
                bcc errorReadingString      ;branch taken if not digit
parseDecimalDigit:
                sta $E6                     ;save current value
                jsr readNextDigitFromString
                bcc parsedValue ;branch taken if not digit, meaning number
                                     ;parsed successfully
                tax                         ;X=digit

                ; calculate (value*4+value)*2 - i.e., value*10. Carry
                ; at any point indicates the value was greater than
                ; 255, and therefore an error.
                lda $E6                     ;value
                asl a                       ;value*2
                bcs errorReadingString      
                asl a                       ;value*4
                bcs errorReadingString      
                adc $E6                     ;value*5
                bcs errorReadingString      
                asl a                       ;value*10
                bcs errorReadingString
                sta $E6                      ;save value*10
                txa                          ;A=digit
                adc $E6                      ;value*10+digit
                bcc parseDecimalDigit
errorReadingString2:
                clc                          ; 8631= 18          .
                rts                          ; 8632= 60          `

readNextDigitFromString:
                iny                          ; 8633= C8          H

; check if current string input byte is a digit.
;
; exit: C=1 if digit; C=0 if not digit
readDigitFromString:
                lda (stringInputBufferAddress),y
                cmp #'9'+1
                bcs errorReadingString       ;taken if not ASCII decimal digit
                cmp #'0'
                bcc errorReadingString       ;taken if not ASCII decimal digit
                and #$0F         ;convert ASCII decimaldigit to number
                rts

L8641:
                jsr mos.skipSpacesAndCheckForCRInStringInput
                cmp #$0D
errorReadingString:
                clc
                rts

;-------------------------------------------------------------------------
;
; Read a hex digit from a string
;
; entry:
;
; (stringInputBufferAddress),y = next byte to read
;
; exit:
;
; C=1 if ok: A = digit read
;
; C=0 if error: Z=1 if CR encountered
; 
readHexDigit:
                jsr readDigitFromString
                bcs +                        ; branch taken if digit
                and #$DF                     ; convert to upper case
                cmp #'F'+1
                bcs L8641    ; branch taken if not ASCII A-F hex digit
                cmp #'A'
                bcc L8641     ;branch taken if not ASCII A-F hex digit
                ; convert ASCII A-F hex digit to number.
                eor #$48
                inc a
+
                iny
                rts

;-------------------------------------------------------------------------
; 
; OSWORD 0 control block for *commands
; ====================================
commandLineUIOSWORD0Parameters:
                .word hazel.commandLine      ; address
                .byte $F0			; max # chars
                .byte $20			; min ASCII char
                .byte $7E			; max ASCII char

;-------------------------------------------------------------------------

commandLineUI:
                lda #<commandLineUIBRKHandler
                sta BRKV+0
                lda #>commandLineUIBRKHandler
                sta BRKV+1
                lda #$10|terminalROM         ;????
                sta currentLanguageROM
commandLineUILoop:
                ldx #$FF                     
                txs                          
                cli                          
                jsr mos.selectHAZEL          
                lda #'*'                     
                jsr OSWRCH                   
                jsr readCommandLine          
                bcc +                     ;taken if ESCAPE not pressed
                jmp escapeError
+
                ldx #<hazel.commandLine     
                ldy #>hazel.commandLine     
                jsr OSCLI
                bra commandLineUILoop

commandLineUIBRKHandler:
                jsr OSNEWL                  
                ldy #$00                    
                jsr mos.printBRKMessage
                jsr OSNEWL                  
                bra commandLineUI           

badCommandError869A:
                jmp mos.badCommandError

readCommandLine:
                lda #$00                     
                ldx #<commandLineUIOSWORD0Parameters
                ldy #>commandLineUIOSWORD0Parameters
                jmp OSWORD                   

;-------------------------------------------------------------------------
;
; *ROMS [MasRef C.5-10]
; 
starROMS:
                jsr mos.skipSpacesAndCheckForCRInStringInput
                bne badCommandError869A
                ldy #$0F
printROMsLoop:
                .if version==320
                iny                          ;ensure Y!=0
                jsr printFollowingMessage
                .text "ROM ",0
                tya                          ;A = ROM number+1
                dec a                        ;A = ROM number
                pha                          ;save ROM number
                .elsif version>=500
                tya
                tax
                phy
                jsr mos.LF89A
                bcs L86D2
                jsr printFollowingMessage
                .text "ROM ",0
                bra L86DA
L86D2:
                jsr printFollowingMessage
                .text "RAM ",0
L86DA:
                ply
                tya
                .endif
                jsr printHexDigit            ;print ROM slot
                jsr printSpace               
                lda #<sidewaysROMName
                sta $F6
                lda #>sidewaysROMName
                sta $F7
                .if version==320
                plx                          ;restore ROM number
                .endif
                jsr mos.isROMValidThenSelectTerminalROM
                .if version==320
                dey
                .endif
                bcc invalidROM
                .if version>=500
                lda romInformationTable,y
                dec a
                beq invalidROM
                .endif
printROMNameLoop:
                jsr mos.osrdscEntryPoint     ;read name byte
                cmp #' '
                bcc printROMVersion ;taken if non-printable char, including the terminating 0
                cmp #127
                bcs invalidROM  ;taken if bad (bit 7 set) char in name
                jsr OSWRCH
                inc $F6
                bit $F6
                bvc printROMNameLoop         ;taken if address<$8040
                bra invalidROM               ;taken if name too long

printROMVersion:
                tax               ;Z=1 if final char was the expected 0
                bne invalidROM    ;taken if bad (control) char in name
                lda #<sidewaysROMVersion
                sta $F6
                lda #>sidewaysROMVersion
                sta $F7
                jsr mos.osrdscEntryPoint
                jsr printSpaceThenPrintHexByte
printInsertionStatus:
                phy                          ; 86F5= 5A          Z
                .if version==320
                jsr mos.getROMInsertedFlagRTCAddressAndMask
                sta starROMSWorkspace.insertedFlagMask
                jsr readRTCByte
                and starROMSWorkspace.insertedFlagMask
                .elsif version>=500
                jsr L873F
                .endif
                bne +
                jsr alwaysPrintFollowingMessage
                .text " unplugged",0
+
                ply              
                jsr OSNEWL       
                dey              
                bpl printROMsLoop
                rts              

invalidROM:
                lda #'?'                     
                jsr OSWRCH                   
                bra printInsertionStatus

;-------------------------------------------------------------------------

                .if version>=500
L873F:
                jsr mos.getROMInsertedFlagRTCAddressAndMask
                sta $b0
                jsr readRTCByte
                and $b0
                rts
                .endif
                
;-------------------------------------------------------------------------
;
; *INSERT [MasRef C.5-8]
; 
starINSERT:
                sec              
                bra starINSERTOrStarUNPLUG

;-------------------------------------------------------------------------
;
; *UNPLUG [MasRef C.5-13]
; 
starUNPLUG:
                clc
starINSERTOrStarUNPLUG:
                php
                jsr mos.skipSpacesAndCheckForCRInStringInput
                jsr parseSingle4BitNumberFromCommandLine
                tay                          ;Y=ROM number
                jsr mos.getROMInsertedFlagRTCAddressAndMask
                pha
                jsr readRTCByte                    
                sty starROMSWorkspace.insertedFlagMask
                pla
                plp
                bcc unplug                   ;taken if it's *UNPLUG

                ; it's *INSERT
                ora starROMSWorkspace.insertedFlagMask
                bra +
unplug:
                eor #$FF
                and starROMSWorkspace.insertedFlagMask
+
                tay
                jmp writeRTCByte

;-------------------------------------------------------------------------
;
; *TIME [MasRef C.5-12]
; 
starTIME:
                stz hazel.commandLine        
                ldx #<hazel.commandLine      
                ldy #>hazel.commandLine      
                lda #$0E                     
                jsr OSWORD                   
                ldx #256-size(ClockStringFormat)
L8752:
                lda hazel.commandLine-(256-size(ClockStringFormat)),x
                jsr OSASCI                   
                inx                          
                bne L8752                    
                rts                          

;-------------------------------------------------------------------------

                .if version==320
                .include "configure320.s65"
                .elif version>=500
                .include "configure500.s65"
                .include "osbyte_osword_table.s65"
parseSingle4BitNumberFromCommandLine:
readDefaultTVSettings:
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L907E:
                phx
                phy
                jsr utils_9ECA
                ply
                plx
                rts
                .endif

;-------------------------------------------------------------------------

                .if version==320
;-------------------------------------------------------------------------
;
; Read default *TV settings.
;
; exit:
;
; X = interlace flag (0=off, 1=on)
;
; Y = *TV offset
readDefaultTVSettings:
                ldx #CMOSBytes.defaults0+cmosBytesOffset
                jsr readRTCByte
                phy
                and #%11100000
                asl a
                rol a
                rol a
                rol a                        ;move into bottom 3 bits
                bit #$04                     ;sign bit?
                beq +                        ;taken if positive
                ora #%11111100               ;sign extent from bit 2
+
                tay
                pla
                ldx #$00                     ;X=0 - interlace off
                bit #CMOSBytes.defaults0.defaultInterlaceMask
                beq +
                inx                          ;X=1 - interlace on
+
                rts

;-------------------------------------------------------------------------
; 
; Read configured MODE
; --------------------
readDefaultMODE:
                ldx #CMOSBytes.defaults0+cmosBytesOffset
                jsr readRTCByte
                and #CMOSBytes.defaults0.defaultMODEMask|CMOSBytes.defaults0.defaultSHADOWMask
                bit #CMOSBytes.defaults0.defaultSHADOWMask
                beq +
                eor #$80|CMOSBytes.defaults0.defaultSHADOWMask ;reset defaultSHADOWMask bit, set bit 7
+
                rts

;-------------------------------------------------------------------------
;
;
readDefaultSerialBaudRateIndex:
                jsr readDefaults2
                and #CMOSBytes.defaults2.serialBaudRateIndexMask<<CMOSBytes.defaults2.serialBaudRateIndexShift
                lsr a
                lsr a
                inc a
                rts

;-------------------------------------------------------------------------

readDefaultFX5Settings:
                jsr readDefaults2
getTop3Bits:
                and #%11100000               ;? %abc00000
                asl a                        ;a %bc000000
                rol a                        ;b %c000000a
                rol a                        ;c %000000ab
                rol a                        ;0 %00000abc
                rts                          

;-------------------------------------------------------------------------
;
; 
readDefaultSerialDataFormat:
                jsr readDefaults3
                bra getTop3Bits

;-------------------------------------------------------------------------

readDefaultLanguageROM:
                jsr readDefaultROMs
                lsr a
                lsr a
                lsr a
                lsr a
                rts

;-------------------------------------------------------------------------
;
; 
readDefaultROMs:
                ldx #CMOSBytes.defaultROMs+cmosBytesOffset;
                bra jmpReadRTCByte

;-------------------------------------------------------------------------

readDefaultPrinterIgnoreChar:
                ldx #CMOSBytes.printerIgnoreChar+cmosBytesOffset
jmpReadRTCByte:
                jmp readRTCByte

;-------------------------------------------------------------------------

readDefaults1:
                ldx #CMOSBytes.defaults1+cmosBytesOffset
                bra jmpReadRTCByte

;-------------------------------------------------------------------------

printNo_:
                jsr alwaysPrintFollowingMessage
                .text "No ",0
                rts                          ; 8EB8= 60          `

;-------------------------------------------------------------------------
                .endif
                
;-------------------------------------------------------------------------
;
; [MasRef G.5-8]
; 
starPRINT:
                lda #$C0                     ; 8EB9= A9 C0       )@
                sta hazel.fsFlags      ; 8EBB= 8D C2 DF    .B_
                bra L8ED2                    ; 8EBE= 80 12       ..

;-------------------------------------------------------------------------

starLIST:
                lsr hazel.fsFlags      ; 8EC0= 4E C2 DF    NB_
                stz hazel.lineNumberBCD+0      ; 8EC3= 9C C3 DF    .C_
                stz hazel.lineNumberBCD+1      ; 8EC6= 9C C4 DF    .D_
                bra L8ECF                    ; 8EC9= 80 04       ..

;-------------------------------------------------------------------------

starTYPE:
                sec                          ; 8ECB= 38          8
                ror hazel.fsFlags      ; 8ECC= 6E C2 DF    nB_
L8ECF:
                lsr hazel.fsFlags      ; 8ECF= 4E C2 DF    NB_
L8ED2:
                stz hazel.lastCharPrinted      ; 8ED2= 9C C5 DF    .E_
                jsr openFileForReading                    ; 8ED5= 20 45 A5     E%
L8ED8:
                bit $FF                      ; 8ED8= 24 FF       $.
                bmi handleESCAPEWithFileOpen                    ; 8EDA= 30 52       0R
                jsr OSBGET                   ; 8EDC= 20 D7 FF     W.
                bcs closeFile                    ; 8EDF= B0 2E       0.
                bit hazel.fsFlags      ; 8EE1= 2C C2 DF    ,B_
                bvs L8EEB                    ; 8EE4= 70 05       p.
                pha                          ; 8EE6= 48          H
                jsr printLineNumber          ; 8EE7= 20 EB 91     k.
                pla                          ; 8EEA= 68          h
L8EEB:
                bit hazel.fsFlags      ; 8EEB= 2C C2 DF    ,B_
                bmi L8F04                    ; 8EEE= 30 14       0.
                cmp #$0D                     ; 8EF0= C9 0D       I.
                beq L8F14                    ; 8EF2= F0 20       p
                cmp #$0A                     ; 8EF4= C9 0A       I.
                beq L8F14                    ; 8EF6= F0 1C       p.
                sta hazel.lastCharPrinted      ; 8EF8= 8D C5 DF    .E_
                cmp #'"'                     ; 8EFB= C9 22       I"
                beq L8F04                    ; 8EFD= F0 05       p.
                jsr printGSREADChar                    ; 8EFF= 20 06 96     ..
                bra L8F07                    ; 8F02= 80 03       ..

L8F04:
                jsr OSWRCH                   ; 8F04= 20 EE FF     n.
L8F07:
                jsr bgetAndCheckForESCAPE                    ; 8F07= 20 3A 8F     :.
                bcc L8EEB                    ; 8F0A= 90 DF       ._
printNewLineThenCloseFile:
                jsr OSNEWL                   ; 8F0C= 20 E7 FF     g.
closeFile:
                lda #$00                     ; 8F0F= A9 00       ).
                jmp OSFIND                   ; 8F11= 4C CE FF    LN.

L8F14:
                cmp hazel.lastCharPrinted      ; 8F14= CD C5 DF    ME_
                beq L8F29                    ; 8F17= F0 10       p.
                pha                          ; 8F19= 48          H
                lda hazel.lastCharPrinted      ; 8F1A= AD C5 DF    -E_
                cmp #$0D                     ; 8F1D= C9 0D       I.
                beq L8F34                    ; 8F1F= F0 13       p.
                cmp #$0A                     ; 8F21= C9 0A       I.
                beq L8F34                    ; 8F23= F0 0F       p.
                pla                          ; 8F25= 68          h
                sta hazel.lastCharPrinted      ; 8F26= 8D C5 DF    .E_
L8F29:
                jsr OSNEWL                   ; 8F29= 20 E7 FF     g.
                bra L8ED8                    ; 8F2C= 80 AA       .*

;-------------------------------------------------------------------------
;
; Tidily handle ESCAPE when a file is open during *DUMP or whatever.
; Prints a new line, closes the file, then does an Escape error.
;
; entry:
;
; Y = file handle
; 
handleESCAPEWithFileOpen:
                jsr printNewLineThenCloseFile
                jmp escapeError

;-------------------------------------------------------------------------

L8F34:
                pla
                stz hazel.lastCharPrinted
                bra L8F07

;-------------------------------------------------------------------------
;
; Does an OSBGET and handles ESCAPE.
;
; entry:
;
; Y = file handle
;
; exit:
;
; A = byte read
; C=1 if EOF
; (as per OSBGET)
;
bgetAndCheckForESCAPE:
                jsr OSBGET
                bit $FF
                bmi handleESCAPEWithFileOpen
                rts

;-------------------------------------------------------------------------
;
; *DUMP [MasRef G.5-4]
; 
starDUMP:
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                ldx #$00
                jsr clearOSFILEParameterBlockDWORD
                ldx #$04
                jsr clearOSFILEParameterBlockDWORD
                ldy #$00
                lsr hazel.tempFSFlag
                jsr mos.gsinitForFilenameParsing
L8F58:
                jsr mos.gsreadEntryPoint
                bcc L8F58
                beq L8F79
                ldx #$00
                jsr parseHexAddressFromCommandLine

                ldx #$03
-
                lda osfileParameterBlock+0,x
                sta osfileParameterBlock+4,x
                dex
                bpl -
                
                jsr mos.skipSpacesAndCheckForCRInStringInput
                beq L8F79
                ldx #$04
                jsr parseHexAddressFromCommandLine
L8F79:
                ldy stringInputBufferAddress+1
                ldx stringInputBufferAddress+0
                asl hazel.tempFSFlag
                jsr openFileForReading
                
                lda #argsFileGetEXT
                jsr callOSARGSWithBuffer
                
                ldx #$03
L8F8A:
                lda osargsBuffer,x
                cmp osfileParameterBlock+0,x
                bcc L8FFB
                bne L8F96
                dex
                bpl L8F8A
L8F96:
                ldx #$03
-
                lda osfileParameterBlock+0,x
                sta osargsBuffer,x
                dex
                bpl -
                jsr setFilePointerFromOSARGSBuffer
L8FA3:
                ldx #$00
                jsr OSBGET
                bcs L8FF0
                jsr L9239
                pha
                lda osfileParameterBlock+4
                and #$07
                beq L8FCA
                phy
                tay
L8FB7:
                phy
                jsr alwaysPrintFollowingMessage
                .text "   ",0
                ply
                lda #$20
                sta osfileParameterBlock+8,x
                inx
                dey
                bne L8FB7
                ply
L8FCA:
                pla
L8FCB:
                pha
                cmp #32
                bcc nonPrintable
                cmp #127
                bcc L8FD6                    ;taken if printable
nonPrintable:
                lda #'.'          ;placeholder for non-printable chars
L8FD6:
                sta osfileParameterBlock+8,x
                pla
                jsr printSpaceThenPrintHexByte
                inx
                jsr L9248
                lda osfileParameterBlock+4
                and #$07
                beq L8FF3
                jsr bgetAndCheckForESCAPE
                bcc L8FCB
                jsr L9257
L8FF0:
                jmp closeFile

L8FF3:
                jsr L9257
                bra L8FA3

L8FF8:
                jmp notFoundError

L8FFB:
                jsr closeFile
                jsr doFollowingError
                .text $b7,"Outside file",0

;-------------------------------------------------------------------------
;
; *BUILD
; 
starBUILD:
                lsr hazel.fsFlags            ;clear bit 7 of fsFlags
                bra starBUILDOrAPPEND

;-------------------------------------------------------------------------
;
; *APPEND
; 
starAPPEND:
                sec
                ror hazel.fsFlags            ;set bit 7 of fsFlags
starBUILDOrAPPEND:
                ; bit 7 of fsFlags indicates *BUILD (clear) or *APPEND
                ; (set).
                stz hazel.lineNumberBCD+0    ;reset line number
                stz hazel.lineNumberBCD+1    ;reset line number
                lda #$80                     ;open for output. Assume *BUILD
                bit hazel.fsFlags            ;test *BUILD/*APPEND
                bpl +                        ;branch taken if *BUILD
                lda #$C0                     ;*APPEND, so open for update
+
                jsr OSFIND                   ;open the file
                tay                          ;Y=file handle
                beq L8FF8                    ;branch taken if open failed
                sty osfileParameterBlock+0   ;save file handle
                jsr setPTRToEOF ;move to EOF (effective no-op when *BUILD)
L9033:
                jsr printLineNumber
L9036:
                .if version==320
                jsr readCommandLine
                .elsif version>=500
                lda #0
                ldx #<starBuildOrAPPENDOSWORD0Parameters
                ldy #>starBuildOrAPPENDOSWORD0Parameters
                jsr OSWORD
                .endif
                php
                bcc L904B
                ; Handle ESCAPE
                jsr OSNEWL
                lda #$0D
                sta hazel.commandLine,y      ;terminate current line
L9044:
                phy                          ;save line length
                lda #$7E
                jsr OSBYTE                   ;acknowledge ESCAPE
                ply                          ;restore line length
L904B:
                tya                          ;A=line length
                beq L909E                    ;taken if line empty
                jsr setStringInputBufferToCommandLine
                ldy #$00                     
                ldx #$00                     
L9055:
                jsr mos.LF29C
                sta hazel.commandLine,x
                lda #stringInputOptions.goodString
                bit stringInputOptions
                bne L906C
                lda #7
                jsr OSWRCH                   ;beep
                jsr L91F5
                plp
                bra L9036

L906C:
                inx
                bcc L9055
                plp
                bcc L9073
                dex
L9073:
                php
                phx
                ldx #size(OSGBPBParameterBlock)-2
L9077:
                stz osfileParameterBlock+1,x
                dex
                bpl L9077
                plx
                stx osfileParameterBlock+OSGBPBParameterBlock.count+0
                .cerror (<hazel.commandLine)!=0,"hazel.commandLine must be page aligned"
                lda #>hazel.commandLine
                sta osfileParameterBlock+OSGBPBParameterBlock.address+1
                dec osfileParameterBlock+OSGBPBParameterBlock.address+2
                dec osfileParameterBlock+OSGBPBParameterBlock.address+3
                lda #gbppPutBytesCurrentPTR
                ldx #<osfileParameterBlock
                ldy #>osfileParameterBlock
                jsr OSGBPB
                plp
                bcc L9033
L9098:
                ldy osfileParameterBlock+0
                jmp closeFile

L909E:
                plp
                bcs L9098
                lda #13
                ldy osfileParameterBlock
                jsr OSBPUT
                bra L9033

setStringInputBufferToCommandLine:
                lda #$41
                sta $E4
                .cerror (<hazel.commandLine)!=0,"hazel.commandLine must be page aligned"
                stz stringInputBufferAddress+0
                lda #>hazel.commandLine
                sta stringInputBufferAddress+1
                rts

;-------------------------------------------------------------------------

                .if version==500
starBuildOrAPPENDOSWORD0Parameters:
                .word hazel.commandLine      ;address
                .byte $f0                    ;max # chars
                .byte 0                      ;min char
                .byte 255                    ;max char
                .endif
                
;-------------------------------------------------------------------------
; 
; *MOVE
; 
starMOVE:
                lda ACCCON                    ; Save ACCCON
                sta hazel.oldACCCON
                pha                          ; Save ACCCON and command line pointer
                phx
                phy
                ldy #$80                     ; Top of available shadow memory at &8000
                lda STATE                      ; Get VDU status
                bit #$10                     ; Jump if not shadow screen, spare up to &8000
                beq L90CE
; Shadow screen selected
                jsr mos.LF1C0                ; Get screen bottom to XY
                cpy #$30                     ; Screen at &3000, no spare memory, jump to use Hazel
                beq L90E2

; Non-shadow or small shadow screen selected
; Y=top of available memory in shadow memory
L90CE:
                lda #$30                     ; &3000=start of shadow memory
                sta hazel.moveBufferMSB
                lda #ACCCON.X
                tsb ACCCON
                sta hazel.hasACCCONChanged      ; set 'ACCCON changed'
                tya                          ; A=length of space in shadow memory
                sec
                sbc hazel.moveBufferMSB
                bra L90E9

; No shadow memory available, use Hazel
L90E2:
                lda #$DD                     ; Buffer at &DD00
                sta hazel.moveBufferMSB
                lda #$02                     ; Buffer length=&200

; &DFD6=high byte of buffer address
; A=high byte of buffer length
L90E9:
                sta hazel.moveNumPages      ; Store buffer length
                ply                          ; Get command line pointer
                plx
                phx
                phy
                lda #$40                     ; Open source file
                jsr OSFIND
                tay                          ; Store source handle, jump if not found
                sty hazel.moveSrcHandle
                beq L9134
                ply                          ; Get command line back again
                plx
                stx $F2
                sty $F3
                phx                          ; And save it again
                phy
                ldy #$00                     ; Step past first parameter
                jsr mos.gsinitForFilenameParsing
L9108:
                jsr mos.gsreadEntryPoint     ;
                bcc L9108
                tya                          ; Save address of dest filename
                clc
                adc $F2
                sta hazel.moveDestName+0
                tax
                lda $F3
                adc #$00
                sta hazel.moveDestName+1
                tay                          ; Temporary filing system flag
                asl hazel.tempFSFlag
                lda #$80                     ; Open destination file
                jsr OSFIND
                tay                          ; Store dest handle, jump if opened
                sty hazel.moveDestHandle
                bne L9137

; Couldn't open destination
                ldy hazel.moveSrcHandle      ; Get source handle and clear it
                stz hazel.moveSrcHandle
                jsr OSFIND                   ; Close source file
L9134:
                jmp notFoundError                    ; Jump to 'Not found' error

; Source and dest opened
; ----------------------
; Build OSGBPB source file control block at &02ED
; and destination control block at &DFC7
L9137:
                ldx #$07
L9139:
                stz osfileParameterBlock+OSGBPBParameterBlock.address,x ; Addr=0, Num=0
                stz hazel.moveOSGBPB+1,x
                dex
                bpl L9139
                lda hazel.moveSrcHandle      ; Source handle
                sta osfileParameterBlock+OSGBPBParameterBlock.handle
                lda hazel.moveBufferMSB      ; Buffer address
                sta osfileParameterBlock+OSGBPBParameterBlock.address+1
                sta hazel.moveOSGBPB.addr+1
                lda hazel.moveNumPages
                sta osfileParameterBlock+OSGBPBParameterBlock.count+1
                sta hazel.moveOSGBPB.numBytes+1
                dec osfileParameterBlock+OSGBPBParameterBlock.address+2 ; Source addr=&FFFFxxxx
                dec osfileParameterBlock+OSGBPBParameterBlock.address+3
                dec hazel.moveOSGBPB.addr+2
                dec hazel.moveOSGBPB.addr+3

; Should use &FFFExxxx and let filing system select correct memory
; Unfortunately, CFS/RFS and DFS do not recognise &FFFExxxx, so
; *MOVE has to do it itself, causing problems for filing systems
; that /do/ recognise &FFFExxxx where they have to remember to
; *do* *nothing* for &FFFFxxxx instead of select main memory as
; &FFFFxxxx implies.

                ldx #<osfileParameterBlock                     ; XY=>source OSGBPB block
                ldy #>osfileParameterBlock
                lda #$04                     ; Read data from source
                jsr OSGBPB
                php                          ; Jump if not at end of file
                bcc L9183
; End of file, adjust destination buffer length for final part
                lda #$00
                sbc osfileParameterBlock+OSGBPBParameterBlock.count+0
                sta hazel.moveOSGBPB.numBytes+0
                lda hazel.moveOSGBPB.numBytes+1
                sbc osfileParameterBlock+OSGBPBParameterBlock.count+1
                sta hazel.moveOSGBPB.numBytes+1
L9183:
                lda hazel.moveDestHandle      ; Destination handle
                sta hazel.moveOSGBPB.handle
                lda #$02                     ; XY=>control block, A=write
                ldx #<hazel.moveOSGBPB
                ldy #>hazel.moveOSGBPB
                jsr OSGBPB
                plp                          ; Loop until end of file
                bcc L9137
                lda #$00
                ldy hazel.moveSrcHandle      ; Get and clear source handle
                stz hazel.moveSrcHandle
                phy                          ; Close source file
                jsr OSFIND
                lda #$00                     ; Get dest handle
                ldy hazel.moveDestHandle
                phy                          ; Clear dest handle and close file
                stz hazel.moveDestHandle
                jsr OSFIND
                ply                          ; Dest not CFS/RFS, jump to...
                cpy #$04
                bcs L91BD
                ply                          ; Pop source handle
L91B3:
                ply                          ; Restore XY
                plx
L91B5:
                pla                          ; Clear 'ACCCON changed', restore ACCCON
                stz hazel.hasACCCONChanged
                sta ACCCON
                rts

L91BD:
                ply                          ; Source was CFS/RFS, jump to exit
                cpy #$04
                bcc L91B3
                ply                          ; Point to first parameter
                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
                plx
                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
                ldx #<osfileParameterBlock
                ldy #>osfileParameterBlock
                lda #$05                     ; Read info on source file
                jsr OSFILE
                lda hazel.moveDestName+0      ; Get address of dest filename
                sta osfileParameterBlock+OSFILEParameterBlock.fileName+0
                lda hazel.moveDestName+1      ;  and put in control block
                sta osfileParameterBlock+OSFILEParameterBlock.fileName+1
                lda #$F0                     ; Mask out 'public' access bits
                trb osfileParameterBlock+OSFILEParameterBlock.attributes+0
                lda #$01                     ; Write info on dest file
                jsr OSFILE
                bra L91B5                    ; Jump to restore ACCCON and exit

printLineNumber:
                ldx #$00
                sec
                jsr adcLineNumberBCDX        ;increment line number LSB
                inx                          
                jsr adcLineNumberBCDX        ;carry into line number MSB
L91F5:
                sec                          ;printing leading 0s
                lda hazel.lineNumberBCD+1    ;get line number MSB
                jsr printPossiblyLeading0s
                lda hazel.lineNumberBCD+0    ;get line number LSB
                pha                          ;save line number LSB
                php                          ;save C
                lsr a
                lsr a
                lsr a
                lsr a
                plp                          ;restore  C
                jsr printPossiblyLeading0    ;print line number 3rd digit
                pla                          ;restore line number LSB
                clc                ;always print line number 4th digit
                jsr printPossiblyLeading0    ;
                jmp printSpace                    ;

printPossiblyLeading0s:
                pha                          ;save value
                php                          ;save C
                lsr a
                lsr a
                lsr a
                lsr a
                plp                          ;restore C
                jsr printPossiblyLeading0    ;print 1st digit
                pla                          ;restore value
printPossiblyLeading0:
                and #$0F                     ;get digit to print
                bne printNonLeading0         ;always print if non-0
                bcc printNonLeading0 ;branch taken if not leading 0
                lda #$20             ;print space instead of leading 0
                jsr OSWRCH
                sec                ;indicate still in leading 0s state
                rts

printNonLeading0:
                jsr printHexDigit            ;print digit
                clc                          ;no longer in leading 0s state
                rts                          ;

adcLineNumberBCDX:
                lda #$00
                sed
                adc hazel.lineNumberBCD,x
                sta hazel.lineNumberBCD,x
                cld
rts9238:
                rts

;-------------------------------------------------------------------------

L9239:
                phx
                pha
                ldx #$02
L923D:
                lda osfileParameterBlock+4,x
                jsr printHexByte
                dex
                bpl L923D
                bra L9254

;-------------------------------------------------------------------------

L9248:
                phx
                pha
                ldx #256-4
L924C:
                inc osfileParameterBlock+4-(256-4),x
                bne L9254
                inx
                bne L924C
L9254:
                pla
                plx
                rts

L9257:
                phy
                phx
L9259:
                cpx #$08
                beq L9267
                jsr alwaysPrintFollowingMessage
                .text "   ",0
                inx
                bra L9259

L9267:
                plx
                jsr printSpace
                ldy #$00
L926D:
                lda osfileParameterBlock+8,y
                jsr OSWRCH
                iny
                dex
                bne L926D
                ply
                jmp OSNEWL

;-------------------------------------------------------------------------
;
; Restore entire font.
;
restoreFont32To255:
                ldx #$07                     ;224 chars - 32-255
                
                ; fall through to restoreFont32ToN

;-------------------------------------------------------------------------
;
; Restore part of the font, starting from char 32.
;
; entry:
;
; X = number of pages of font data to restore - X*32 chars will be
; restored
; 
restoreFont32ToN:
                php
                sei
                lda #>LB900                ;start at beginning of font
                sta $F1
                lda #>andy.softCharacterDefinitions ;write to beginning of soft character definitions
                
                ; fall through to restoreFontPart

;-------------------------------------------------------------------------
;
; Restore part of the font.
;
; entry:
;
; ?$f1 = MSB of font data
;
; A = MSB of dest page in ANDY - should be part of the soft character
; definitions!
;
; X = number of pages of font data to restore - X*32 chars will be
; restored
;
; preserves: Y

restoreFontPart:
                sta $FB                      ;save MSB of dest
                jsr mos.selectTerminalROMAndANDY2
                phy                          ;
                ldy #$00                     ;
                stz $FA                      ;initialize LSB of src
                stz $F0                      ;initialize LSB of dest
-
                lda ($F0),y                  
                sta ($FA),y                  
                iny                          
                bne -
                inc $F1                      ; 9298= E6 F1       fq
                inc $FB                      ; 929A= E6 FB       f{
                dex                          ; 929C= CA          J
                bne -
                ply                          ; 929F= 7A          z
                plp                          ; 92A0= 28          (
                jmp mos.selectTerminalROM    ; 92A1= 4C 90 E5    L.e

restoreFont32To126:
                ldx #$03                     ;96 chars - 32-126
                bra restoreFont32ToN         ; 92A6= 80 D5       .U

;-------------------------------------------------------------------------
;
; OSBYTE 25 (&19) Restore a group of font definitions
;
; MasRef D.2-28
; 
osbyte19:
                txa                          ;A=group identifier
                beq restoreFont32To255   ;taken if group 0 - all chars
                .if version==320
                cmp #$08
                bcs rts9238         ;taken if group >= 8 (not invalid)
                .elsif version>=500
                cmp #$10
                bcs rts9238
                and #7
                beq restoreFont32To255
                .endif
                php
                sei
                adc #(>LB900)-1 ;form address of ROM font data for group
                sta $F1
                txa
                ldx #$01                   ;copy 1 page, 32 chars
                adc #(>andy.softCharacterDefinitions)-1 ;get page in ANDY for group
                bra restoreFontPart

;-------------------------------------------------------------------------
;
; Clear 4 bytes in the OSFILE parameter block.
;
; entry:
;
; X = offset of the 4 bytes to clear
; 
clearOSFILEParameterBlockDWORD:
                stz osfileParameterBlock+0,x
                stz osfileParameterBlock+1,x
                stz osfileParameterBlock+2,x
                stz osfileParameterBlock+3,x
                rts

;-------------------------------------------------------------------------
;
; Read a 32-bit hex value from a string.
;
; entry:
;
; X = offset into osfileParameterBlock to store the value
;
; exit:
;
; C=0 if error

parseHexAddressFromString:
                jsr mos.skipSpacesAndCheckForCRInStringInput ; Skip spaces
                jsr readHexDigit
                bcc rts92F4
                jsr clearOSFILEParameterBlockDWORD
readDigitsLoop:
                phy
                rol a
                rol a
                rol a
                rol a                        ;put digit in top 4 bits
                ldy #$04
shiftIn1DigitLoop:
                rol a
                rol osfileParameterBlock+0,x
                rol osfileParameterBlock+1,x
                rol osfileParameterBlock+2,x
                rol osfileParameterBlock+3,x
                bcs badAddressError ;carry out of bit 31 implies too many digits
                dey
                bne shiftIn1DigitLoop
                ply
                jsr readHexDigit
                bcs readDigitsLoop   ;keep going until hex digits stop
                sec       ;got at least 1 hex digit, so result is good
rts92F4:
                rts

;-------------------------------------------------------------------------
; 
; *GO (<addr>) [MasRef C.5-6]
;
starGO:
                jsr mos.skipSpacesAndCheckForCRInStringInput ; Skip spaces
                bne starGOIO             ; Jump to read parameters
                jmp commandLineUI        ; No parameters, enter CLICOM

;-------------------------------------------------------------------------
; 
; *GOIO <addr> [MasRef C.5-7]
; 
starGOIO:
                ldx #$00
                jsr parseHexAddressFromCommandLine ; Read hex address
                jsr mos.skipSpacesAndCheckForCRInStringInput ; Skip spaces
                php  ; Update &F2/3 to point to any further parameters
                tya
                clc
                adc stringInputBufferAddress+0
                sta stringInputBufferAddress+0
                bcc +
                inc stringInputBufferAddress+1
+
                ldy #$00    ; (&F2),y=>parameters, EQ if no parameters
                plp
                jmp (osfileParameterBlock+0) ; Jump to address

;-------------------------------------------------------------------------

starLOAD:
                lda #fileLoad
starCommandThroughOSFILE:
                lsr hazel.tempFSFlag
L931B:
                stx stringInputBufferAddress+0
                sty stringInputBufferAddress+1
                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
                pha                          ;save OSFILE reason
                ldx #OSFILEParameterBlock.load
                jsr clearOSFILEParameterBlockDWORD
                ldx #OSFILEParameterBlock.length
                jsr clearOSFILEParameterBlockDWORD
                ldy #$FF
                sty osfileParameterBlock+OSFILEParameterBlock.exec+0 ;by default, load to file's load address
                iny                                                  ;Y=0
                jsr mos.gsinitForFilenameParsing
L9339:
                jsr mos.gsreadEntryPoint
                bcc L9339
                pla                          ;restore OSFILE reason
                pha                          ;save OSFILE reason
                bpl finishStarSAVE                    ;taken if *SAVE
                ldx #OSFILEParameterBlock.load
                jsr parseHexAddressFromString ;parse *LOAD address
                bcs doStarLOADWithExplicitAddress ;taken if good address
                beq L9366        ;taken if CR encountered (this is ok)
badAddressError:
                jsr doFollowingError
                .text $fc,"Bad address",0

;-------------------------------------------------------------------------
;
; Parse hex address from command line.
;
parseHexAddressFromCommandLine:
                jsr parseHexAddressFromString ; Read hex address
                bcc badAddressError           ; Jump with bad address
                rts

;-------------------------------------------------------------------------

doStarLOADWithExplicitAddress:
                bne badCommandError93E2
                inc osfileParameterBlock+OSFILEParameterBlock.exec+0 ;load to parameter block load address
L9366:
                asl hazel.tempFSFlag
callOSFILEWithOSFILEParameterBlock:
                ldx #<osfileParameterBlock
                ldy #>osfileParameterBlock
                pla
                jmp OSFILE

;-------------------------------------------------------------------------
;
; *REMOVE [MasRef G.5-9]
; 
starREMOVE:
                stx osfileParameterBlock+OSFILEParameterBlock.fileName+0
                sty osfileParameterBlock+OSFILEParameterBlock.fileName+1
                lda #fileDelete
                pha
                bra callOSFILEWithOSFILEParameterBlock

;-------------------------------------------------------------------------
;
; *CLOSE [MasRef G.5-3]
; 
starCLOSE:
                jsr mos.skipSpacesAndCheckForCRInStringInput
                bne badCommandError93E2
                lda #$00                     
                tay                          
                jmp (FINDV)                  ;OSFIND A=0 Y=0

;-------------------------------------------------------------------------
;
; *IGNORE [MasRef C.5-7]
; 
starIGNORE:
                bne L938E
                sec
                ror noignoreState
                rts

;-------------------------------------------------------------------------

L938E:
                lda #$06                     ; 938E= A9 06       ).
                bra starCommandThroughOSBYTE                    ; 9390= 80 59       .Y

;-------------------------------------------------------------------------

finishStarSAVE:
                bne L939B
                ldx #OSFILEParameterBlock.saveStart
                jsr parseHexAddressFromString
                bcc badCommandError93E2
L939B:
                clv
                lda (stringInputBufferAddress),y
                cmp #'+'
                bne L93A6                    ;taken if "*SAVE START END..."
                bit mos.valueFF              ;V=1
                iny
L93A6:
                ldx #OSFILEParameterBlock.saveEnd
                jsr parseHexAddressFromString
                bcc badCommandError93E2
                php
                bvc L93BF                    ;taken if "*SAVE START END"

                ; Get the save end address.
                ldx #256-4
                clc
-
                ; TODO - not sure why the @w notation is required here?
                lda@w osfileParameterBlock+OSFILEParameterBlock.saveStart-(256-4),x
                adc@w osfileParameterBlock+OSFILEParameterBlock.saveEnd-(256-4),x
                sta@w osfileParameterBlock+OSFILEParameterBlock.saveEnd-(256-4),x
                inx
                bne -
L93BF:

                ; Initialize load and exec addresses to save start
                ; address.
                ldx #$03
-
                lda@w osfileParameterBlock+OSFILEParameterBlock.saveStart,x
                sta@w osfileParameterBlock+OSFILEParameterBlock.exec,x
                sta@w osfileParameterBlock+OSFILEParameterBlock.load,x
                dex
                bpl -
                
                plp
                beq L9366
                
                ldx #OSFILEParameterBlock.exec
                jsr parseHexAddressFromString
                bcc badCommandError93E2
                beq L9366
                
                ldx #OSFILEParameterBlock.load
                jsr parseHexAddressFromString
                bcc badCommandError93E2
                beq L9366
                
badCommandError93E2:
                jmp mos.badCommandError

;-------------------------------------------------------------------------

starFX:
                jsr parseNumberFromString
                bcc badCommandError93E2
                txa
starCommandThroughOSBYTE:
                php
                lsr hazel.tempFSFlag
                plp
                pha
                stz $E5
                stz $E4
                jsr mos.LF308
                beq L9412
                jsr parseNumberFromString
                bcc badCommandError93E2
                stx $E5
                jsr mos.LF30A
                beq L9412
                jsr parseNumberFromString
                bcc badCommandError93E2
                stx $E4
                jsr mos.skipSpacesAndCheckForCRInStringInput
                bne badCommandError93E2
L9412:
                ldy $E4
                ldx $E5
                pla
                asl hazel.tempFSFlag
                jsr OSBYTE
                bvs badCommandError93E2
L941F:
                rts

;-------------------------------------------------------------------------

starSPOOLON:
                sec
                bra starSPOOL

L9423:
                ldx #romServiceCallSpoolExecClosureWarning
                jsr mos.makeROMServiceCall
                beq L941F
                jsr LA58B
                lda spoolFileHandle
                jsr LA56B
starSPOOL:
                php
                phy
                ldy spoolFileHandle
                sta spoolFileHandle
                beq L9440
                jsr OSFIND
L9440:
                lsr hazel.tempFSFlag
                ply
                plp
                beq L941F
                lda #$80
                bcc L944D
                lda #$C0
L944D:
                asl hazel.tempFSFlag
                jsr OSFIND
                tay
                beq badCommandError93E2
                sta spoolFileHandle
                tay
setPTRToEOF:
                lda #argsFileGetEXT
                jsr callOSARGSWithBuffer
setFilePointerFromOSARGSBuffer:
                lda #argsFileSetPTR
callOSARGSWithBuffer:
                ldx #osargsBuffer
                jmp OSARGS

starSHADOW:
                lda #$72
                bra starCommandThroughOSBYTE

;-------------------------------------------------------------------------
; 
starDELETE:
                jsr starREMOVE                    ; 946A= 20 71 93     q.
                tay                          ; 946D= A8          (
                bne L941F                    ; 946E= D0 AF       P/
                jmp notFoundError                    ; 9470= 4C 4D A5    LM%

;-------------------------------------------------------------------------

parseSoftKeyNumberFromCommandLine:
                jsr parseNumberFromString
                bcc badKeyError
                cpx #softKeyCount
                bcc L941F
badKeyError:
                jsr doFollowingError
                .byte $FB
                .text "Bad key"
                .byte 0

;-------------------------------------------------------------------------
;
; [MasRef C.5-11]
; 
starSHOW: .proc
                jsr parseSoftKeyNumberFromCommandLine
                jsr mos.skipSpacesAndCheckForCRInStringInput
                bne badKeyError
                lda #'"'
                jsr OSWRCH
                lda $F4
                pha
                jsr mos.selectTerminalROMAndANDY2
                lda andy.softKeys.stringLSBs,x
                sta stringInputBufferAddress+0
                lda andy.softKeys.stringMSBs,x
                sta stringInputBufferAddress+1
                ldy $E6
                jsr mos.getSoftKeyStringLength
                tay                          ;Y = string length
                beq done                    ;done if length=0
-
                lda (stringInputBufferAddress)
                jsr printGSREADChar
                inc stringInputBufferAddress+0
                bne +
                inc stringInputBufferAddress+1
+
                dey
                bne -
done
                pla     
                jsr mos.selectROMA
                lda #'"'
                jsr OSWRCH        
                jmp OSNEWL        
                .endproc

;-------------------------------------------------------------------------
;
; [MasRef C.5-8]
; 
starKEY: .proc
                jsr parseSoftKeyNumberFromCommandLine
                lda $F4                      
                pha                          
                jsr mos.selectTerminalROMAndANDY 
                jsr mos.skipSpacesAndCheckForCRInStringInput
                stz starKEYWorkspace.newStringLength
                beq commandLineTailEmpty
                ldx #$00
                sec
                jsr mos.gsinitEntryPoint
-
                jsr mos.gsreadEntryPoint
                bcs bneBadKeyError
                sta hazel.commandLine,x
                inx
                bra -

bneBadKeyError:
                bne badKeyError
                stx starKEYWorkspace.newStringLength
commandLineTailEmpty:
                ldy $E6                        ;Y = soft key number
                jsr mos.getSoftKeyStringLength                
                sta starKEYWorkspace.counter+0
                sec                          
                sbc starKEYWorkspace.newStringLength ;A=existing len-new len
                bcs newStringWillFit            ;taken if new string shorter, meaning it'll definitely fit

                eor #$FF                     
                adc #$01                     ;A=new len-existing len
                adc andy.softKeys.endLSB
                tax
                lda andy.softKeys.endMSB
                adc #$00
                cmp #>(andy.softKeys.end)
                bcc newStringWillFit

                ; Produce slightly cryptic "Bad key" if string won't
                ; fit.
                bne bneBadKeyError
                txa
                bne bneBadKeyError
newStringWillFit:
                lda softKeyStringLength
                beq storeNewString          ;taken if new string empty
                lda currentSoftKey
                cmp $E6                      ; 9516= C5 E6       Ef
                bcc storeNewString ;taken if current soft key<key - expansion will not need to relocate
                bne relocateCurrentSoftKeyExpansion ;taken if current soft key>key - expansion must relocate
                jsr doFollowingError                    ; 951C= 20 ED AA     m*
                .text $fa,"Key in use",0
relocateCurrentSoftKeyExpansion:
                stz starKEYWorkspace.destPtr+1
                sec
                lda starKEYWorkspace.newStringLength
                sbc starKEYWorkspace.counter+0
                sta starKEYWorkspace.destPtr+0
                bcs +
                dec starKEYWorkspace.destPtr+1
+
                clc
                lda softKeyExpansionPtr+0
                adc starKEYWorkspace.destPtr+0
                sta softKeyExpansionPtr+0
                lda softKeyExpansionPtr+1
                adc starKEYWorkspace.destPtr+1
                sta softKeyExpansionPtr+1
storeNewString:
                dec softKeyConsistencyFlag   ;mark soft keys inconsistent
                ldx $E6                      ;X=key number
                lda starKEYWorkspace.counter+0
                beq makeSpaceForNewString ;taken if no existing string for this soft key

                ; delete existing string
                lda andy.softKeys.stringLSBs,x
                sta starKEYWorkspace.destPtr+0
                lda andy.softKeys.stringMSBs,x
                sta starKEYWorkspace.destPtr+1
                lda andy.softKeys.stringLSBs+1,x
                sta starKEYWorkspace.srcPtr+0
                lda andy.softKeys.stringMSBs+1,x
                sta starKEYWorkspace.srcPtr+1
deleteExistingStringLoop:
                ; copy byte (with postincrement)
                lda (starKEYWorkspace.srcPtr)
                sta (starKEYWorkspace.destPtr)

                ; increment destPtr
                inc starKEYWorkspace.destPtr+0
                bne +
                inc starKEYWorkspace.destPtr+1
+

                ; increment srcPtr
                inc starKEYWorkspace.srcPtr+0
                bne +
                inc starKEYWorkspace.srcPtr+1
+

                ; keep copying until end of buffer reached.
                lda starKEYWorkspace.srcPtr+0
                cmp andy.softKeys.endLSB
                lda starKEYWorkspace.srcPtr+1
                sbc andy.softKeys.endMSB
                bcc deleteExistingStringLoop

                ; update following strings' start addresses, which all
                ; move down by the old string's length.
updateAddressesLoop:
                inx
                cpx #softKeyCount+1
                bcs makeSpaceForNewString
                sec
                lda andy.softKeys.stringLSBs,x
                sbc starKEYWorkspace.counter+0
                sta andy.softKeys.stringLSBs,x
                bcs updateAddressesLoop
                dec andy.softKeys.stringMSBs,x
                bra updateAddressesLoop

makeSpaceForNewString:
                ldx $E6
                lda starKEYWorkspace.newStringLength
                beq done
                lda andy.softKeys.endLSB
                sta starKEYWorkspace.srcPtr+0
                clc
                adc starKEYWorkspace.newStringLength
                sta starKEYWorkspace.destPtr+0 ;new end ptr LSB
                lda andy.softKeys.endMSB
                sta starKEYWorkspace.srcPtr+1
                adc #$00
                sta starKEYWorkspace.destPtr+1 ;new end ptr MSB
                lda starKEYWorkspace.srcPtr+0
                sec
                sbc andy.softKeys.stringLSBs,x
                sta starKEYWorkspace.counter+0
                lda starKEYWorkspace.srcPtr+1
                sbc andy.softKeys.stringMSBs,x
                sta starKEYWorkspace.counter+1
makeSpaceForNewStringLoop:
                ; loop while counter>0
                lda starKEYWorkspace.counter+0
                ora starKEYWorkspace.counter+1
                beq updateAddressesLoop2

                ; decrement destPtr
                lda starKEYWorkspace.destPtr+0
                bne +
                dec starKEYWorkspace.destPtr+1  
+
                dec starKEYWorkspace.destPtr+0

                ; decrement srcPtr
                lda starKEYWorkspace.srcPtr+0  
                bne +
                dec starKEYWorkspace.srcPtr+1  
+
                dec starKEYWorkspace.srcPtr+0

                ; copy byte (with predecrement)
                lda (starKEYWorkspace.srcPtr)
                sta (starKEYWorkspace.destPtr)

                ; decrement counter
                lda starKEYWorkspace.counter+0
                bne +
                dec starKEYWorkspace.counter+1  
+
                dec starKEYWorkspace.counter+0
                
                bra makeSpaceForNewStringLoop

                ; update following strings' start addresses, which all
                ; move up by the new string's length.
updateAddressesLoop2:
                inx      
                cpx #softKeyCount+1
                bcs copyNewString
                lda andy.softKeys.stringLSBs,x
                adc starKEYWorkspace.newStringLength  
                sta andy.softKeys.stringLSBs,x
                bcc updateAddressesLoop2
                inc andy.softKeys.stringMSBs,x
                bra updateAddressesLoop2

copyNewString:
                ldy #$00
copyNewStringLoop:
                lda hazel.commandLine,y
                sta (starKEYWorkspace.srcPtr),y
                iny
                dec starKEYWorkspace.newStringLength
                bne copyNewStringLoop
done:
                inc softKeyConsistencyFlag   ;mark soft keys consistent
                pla                          
                jmp mos.selectROMA
                .endproc       

;-------------------------------------------------------------------------
;
; Print char, printing control codes using the string reader escape
; syntax. [MasRef C.5-8]
; 
printGSREADChar: .proc
                tax                          ;X=char
                bmi printHighBitChar
                cmp #$20
                bcc printControlChar
                inx
                bmi vdu127
                dex                          ;restore old char
                cmp #'"'
                beq printEscapedX
                cmp #'|'
                bne printA
                ; print "||"
                jsr OSWRCH
printA:
                jmp OSWRCH                   ; 961C= 4C EE FF    Ln.

vdu127:
                ; print "|?"
                jsr printEscapeChar
                lda #'?'
                bra printA

printEscapedX:
                jsr printEscapeChar
                txa                          ; 9629= 8A          .
                bra printA

printControlChar:
                ora #$40                     ; 962C= 09 40       .@
                tax                          ; 962E= AA          *
                bra printEscapedX

printHighBitChar:
                pha                          ; 9631= 48          H
                ldx #'!'
                jsr printEscapedX
                pla                          ; 9637= 68          h
                and #$7F                     ; 9638= 29 7F       ).
                bra printGSREADChar                    ; 963A= 80 CA       .J

printEscapeChar:
                lda #'|'
                bra printA
                .endproc

;-------------------------------------------------------------------------

                .if version==320
; Day string not matched
; ----------------------
nextDayString:
                pla                          ; Drop number of characters matched
                pla                          ; Get offset to string table
                ply                          ; Get start of supplied string
                clc                          ; Step to next string table entry
                adc #$04
                cmp #size(dayOfWeekStrings) ; If not checked 28/4=7 entries, keep looking
                bcc checkDayString
                rts                          ; Otherwise exit silently

; Month string not matched
; ------------------------
nextMonthString:
                pla                          ; Drop number of characters matched
                pla                          ; Get offset to string table
                ply                          ; Get start of supplied string
                clc                          ; Step to next string table entry
                adc #$04
                cmp #size(monthStrings) ; If not checked 48/4=12 entries, keep looking
                bcc checkMonthString
rts9655:
                rts                          ; Otherwise exit silently

;-------------------------------------------------------------------------
;
; OSWORD 15 (&0F) Write CMOS clock [MasRef D.3-24]
; 
osword0F:
                stz osfileParameterBlock     ;got no time, got no date
                eor #15                     ; len=15, set date
                beq setDate
                eor #15^8
                beq setTime
                eor #(15^8)^23
                bne rts9655

; Set date and set date+time
; --------------------------
; (&F0),1=>"Day,00 Mon 0000"
; (&F0),1=>"Day,00 Mon 0000.00:00:00"
; A=0, Y=0
setDate:
                iny                          ; Point to supplied data
; Translate day string into day number
checkDayString:
                phy                          ; Push pointer to data string
                pha                          ; Push offset to match strings
                tax                          ; X=>match strings
                lda #$03                     ; A=3 characters to match
checkDayStringLoop:
                pha                          ; Save number of characters to match
                lda (originalX),y      ; Get character from string
                eor dayOfWeekStrings,x ; Compare with day string table
                and #$DF                     ; Force to upper case
                bne nextDayString  ; No match step to check next entry
                inx                          ; Step to next character to match
                iny                          ; Step to next data character
                pla                          ; Get character count back
                dec a                        ; Decrement and loop until 3 characters matched
                bne checkDayStringLoop
                lda dayOfWeekStrings,x ; Get translation byte from string table
                sta osfileParameterBlock+1+RTC.dayOfWeek ; Store it in workspace
; Translates Sun,Mon,Tue,etc to &01,&02,&03,etc
                plx                          ; Drop char count and table offset
                plx
                lda ($F0),y                  ; Get next character
                cmp #','                     ; Not followed by a comma, so exit silently
                bne rts9655
                ldx #$07                     ; Get day of month
                jsr readDecimalBCDByte
                bcc rts9655                    ; Bad number, exit silently
                iny                          ; Get next character
                lda ($F0),y
                eor #' '                     ; Not space, exit silently
                bne rts9655
                iny                          ; Step to first character of month
; Translate month string into month number
; This could use the same code as the Day translation
checkMonthString:
                phy                          ; Push pointer to data string
                pha                          ; Push offset to match strings
                tax                          ; X=>match strings
                lda #$03                     ; A=3 characters to match
checkMonthStringLoop:
                pha
                lda (originalX),y
                eor monthStrings,x
                and #$DF
                bne nextMonthString
                inx
                iny
                pla
                dec a
                bne checkMonthStringLoop
                lda monthStrings,x
                sta osfileParameterBlock+1+RTC.month
; Translates Jan,Feb,Mar,etc to &01,&02,&03,etc..&09,&10,&11,&12
                plx                          ; Drop char count and table offset
                plx
                lda ($F0),y                  ; Get next character
                cmp #' '                     ; Not followed by space, exit silently
                bne rts9655
                ldx #RTC.year
                jsr readDecimalBCDByte
                bcc rts9655                    ; Bad number, exit silently
                jsr readDecimalBCDByte                    ; Get year number
                bcc rts9655                    ; Bad number, exit silently
                ror osfileParameterBlock+0     ;got date
                lda (originalX)        ; Get data length
                cmp #$0F                     ; len=15, jump to just set date
                beq setRTCDate
; Must be len=24 to set date+time
                iny                          ; Get next character
                lda (originalX),y
                cmp #'.'                     ; If not full stop, exit silently
                bne rts9753

setTime:
                ldx #RTC.hours
                jsr readDecimalBCDByte
                bcc rts9753
                iny        
                lda (originalX),y
                cmp #':'
                bne rts9753
                ldx #RTC.minutes
                jsr readDecimalBCDByte
                bcc rts9753           
                iny                   
                lda (originalX),y     
                cmp #':'
                bne rts9753
                ldx #RTC.seconds
                jsr readDecimalBCDByte
                bcc rts9753
                lda #$40
                tsb osfileParameterBlock+0   ;got time
setRTCDate:
                cli
                sei
                ldy #RTC.b.set|RTC.b._24h|RTC.b.dse
                ldx #RTC.b
                jsr writeRTCByte
                bit osfileParameterBlock+0 ;N=1 if got date; V=1 if got time
                bpl setRTCTime ;taken if not got date - must then have time
                ldx #$06
-
                ldy osfileParameterBlock+1,x
                jsr writeRTCByte
                inx
                cpx #RTC.a
                bcc -
                bvc finishRTCUpdate                    ;taken if not got date
setRTCTime:
                ldx #RTC.seconds
-
                ldy osfileParameterBlock+1,x
                jsr writeRTCByte
                inx
                cpx #RTC.dayOfWeek
                bcc -
finishRTCUpdate:
                ldx #RTC.b
                ldy #RTC.b._24h
                jmp writeRTCByte

readDecimalBCDByte:
                jsr readDecimalDigit
                eor #$20         ;check for ' '
                beq +        ;taken if leading space - that's fine
                eor #$20         ;reinstate old value
                bcc rts9753      ;taken if non-space non-digits
+
                sta osfileParameterBlock+1,x
                jsr readDecimalDigit
                bcc rts9753                  ;taken if invalid digit

                ; rotate new digit into place
                phy
                ldy #$04
                asl a
                asl a
                asl a
                asl a
-
                asl a
                rol osfileParameterBlock+1,x
                dey
                bne -
                ply
                sec
rts9753:
                rts

readDecimalDigit:
                iny
                lda (originalX),y
                cmp #'9'+1
                bcs notDecimalDigit
                cmp #'0'
                bcc notDecimalDigit
                and #$0F
                rts     

notDecimalDigit:
                clc
                rts
                .endif
                
;-------------------------------------------------------------------------

; TODO - is this necessary?
;
; There's a reference to dayOfWeekStrings-4, but that seems to be
; because days are 1-based. The data here is presumably never
; accesssed.
                .text "   ",0

;-------------------------------------------------------------------------

dayOfWeekStrings: .block
                .text "Sun",$01
                .text "Mon",$02
                .text "Tue",$03
                .text "Wed",$04
                .text "Thu",$05
                .text "Fri",$06
                .text "Sat",$07
                .endblock
                
;-------------------------------------------------------------------------

monthStrings: .block
                .text "Jan",$01
                .text "Feb",$02
                .text "Mar",$03
                .text "Apr",$04
                .text "May",$05
                .text "Jun",$06
                .text "Jul",$07
                .text "Aug",$08
                .text "Sep",$09
                .text "Oct",$10
                .text "Nov",$11
                .text "Dec",$12
                .endblock

;-------------------------------------------------------------------------

                .if version>=500
L986B:
                .byte $12
                .byte $99
                .byte $31
                .byte $06
                .byte $23
                .byte $59
                .byte $59
                .endif

;-------------------------------------------------------------------------

                .if version>=500
osword0F:
                ldx #romServiceCallUnrecognisedOSWORD
                jmp mos.makeROMServiceCall
                .endif
                
;-------------------------------------------------------------------------
;
; OSWORD 14 (&0E) Read CMOS clock [MasRef D.3-22]
; 

osword0E:
                .if version==320
                pha                          ;save reason code
                eor #$02                     ;
                bne readClock
                .else
                cmp #2
                beq L98A8
                pha
                lda originalX
                pha
                lda originalY
                pha
                ldx #romServiceCallUnrecognisedOSWORD
                jsr mos.makeROMServiceCall
                cmp #1
                pla
                sta originalY
                pla
                sta originalX
                bcc L98B0
                ldy #7
                pla
                pha
                beq L9899
                dey
L9899:
                ldx #7
L989B:
                lda L986B,x
                sta (originalX),y
                dey
                dex
                bne L989B
                pla
                dec a
                beq L98AF
L98A8:
                ldx #romServiceCallUnrecognisedOSWORD
                jsr mos.makeROMServiceCall
                bne L98B2
L98AF:
                pha
L98B0:
                pla
                rts

L98B2:
                .endif
                
                ; Convert given time to string. Fill out the RTC temp
                ; data with the info from the parameter block, then
                ; pass on to the common code.
                ldy #$07

                ; Copy hours, mins, secs.
                ldx #$00
-
                lda ($F0),y
                sta osfileParameterBlock+1,x
                dey
                inx
                inx
                cpx #$06
                bcc -

                ; Copy day of week, day of month, month, year.
-
                lda (originalX),y
                sta osfileParameterBlock+1,x
                inx
                dey
                bne -

                .if version==320
                bra maybeConvertToString ; (called from here, there's no maybe about it)

readClock:
                lda originalX
                pha
                lda originalY
                pha
readRTCClock:
                ldx #RTC.c
                jsr readRTCByte ;clear the various IRQ flags with a read of register C
                ldx #RTC.year
-
                jsr readRTCByte
                sta osfileParameterBlock+1,x
                dex
                bpl -
                ldx #RTC.a
                jsr readRTCByte
                bpl L97F5 ;taken if update not in progress - result is good
retryReadRTCClock:
                cli
                sei
                bra readRTCClock

L97F5:
                ldx #RTC.c
                jsr readRTCByte
                and #RTC.c.uf
                bne retryReadRTCClock
                pla         
                sta originalY
                pla         
                sta originalX
maybeConvertToString:
                pla                          ;get reason code
                dec a                        
                bne convertTimeToString                    ;taken if 0 or 2
                
                ; Copy year, month, day of month, day of week.
                ldy #$00                     ; 9808= A0 00        .
                ldx #RTC.year
-
                lda osfileParameterBlock+1,x
                sta (originalX),y
                iny
                dex
                cpx #RTC.dayOfWeek
                bcs -

                ; Copy hours, minutes, seconds.
-
                lda osfileParameterBlock,x          
                sta (originalX),y            
                iny                          
                dex                          
                dex                          
                bpl -
                rts                          

                .endif

convertTimeToString:
                ; Store terminating CR.
                ldy #ClockStringFormat.cr
                lda #13
                sta (originalX),y
                ldx #$00
                dey                          ; 982A= 88          .
                jsr storeRTCDataByteString
                lda #':'
                sta (originalX),y
                ldy #ClockStringFormat.hh+2
                sta (originalX),y
                ldx #RTC.minutes
                ldy #ClockStringFormat.mm+1
                jsr storeRTCDataByteString
                ldx #RTC.hours
                ldy #ClockStringFormat.hh+1
                jsr storeRTCDataByteString
                lda #'.'
                sta (originalX),y
                lda osfileParameterBlock+1+RTC.dayOfWeek;
                asl a           
                asl a           
                ldy #$00        
                tax             
-
                lda dayOfWeekStrings-4,x     ;-4 as 1=Sunday
                sta (originalX),y
                inx
                iny
                cpy #$03
                bcc -
                lda #','
                sta (originalX),y
                lda osfileParameterBlock+1+RTC.month
                cmp #$10
                bcc +
                sbc #$06            ;convert $10, $11 and $12 from BCD
+
                dec a                        ;make month 0-based
                asl a
                asl a
                tax
                ldy #ClockStringFormat.mmm
-
                lda monthStrings,x
                sta ($F0),y                  ; 9871= 91 F0       .p
                inx                          ; 9873= E8          h
                iny                          ; 9874= C8          H
                cpy #ClockStringFormat.mmm+3
                bcc -
                ldx #RTC.year
                ldy #ClockStringFormat.yyyy+3
                jsr storeRTCDataByteString
                lda #$19                     ;it's always 19xx... right?
                jsr storeBCDByteString
                lda #$20                     
                sta ($F0),y                  
                ldy #ClockStringFormat.nn+2
                sta ($F0),y                  
                dey                          
                ldx #RTC.dayOfMonth
storeRTCDataByteString:
                lda osfileParameterBlock+1,x
storeBCDByteString:
                pha
                jsr storeNybbleString
                pla
                lsr a
                lsr a
                lsr a
                lsr a
storeNybbleString:
                and #$0F
                ora #'0'
                cmp #'9'+1
                bcc +
                adc #('A'-'9'-1)-1           ;(-1 because C set)
+
                sta (originalX),y
                dey
                rts

;-------------------------------------------------------------------------

                .if version==320
readDefaults2:
                ldx #CMOSBytes.defaults2+cmosBytesOffset
                bra readRTCByte
                .endif

;-------------------------------------------------------------------------

                .if version==320
readDefaults3:
                ldx #CMOSBytes.defaults3+cmosBytesOffset
                bra readRTCByte
                .endif

;-------------------------------------------------------------------------
;
; Read byte from RTC, either by 0-based CMOS RAM offset (readCMOSByte)
; or by RTC register index (readRTCByte).
;
; entry:
;
; X = address to read from
;
; exit:
;
; A = byte read
;
; N,Z = set as per byte read
;
                .if version==320
readCMOSByte:
                jsr getRTCAddressForCMOSByte
                bcs rts98DB                  ;taken if invalid address
readRTCByte:
                php
                sei
                jsr setRTCAddress
                lda #$49
                sta systemVIA.orb
                stz systemVIA.ddra
                lda #$4A
                sta systemVIA.orb
                ldy systemVIA.iraNoHandshake ;read value
deselectRTC:
                lda #$42
                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=0
                lda #$02
                sta systemVIA.orb            ;RTC AS=0 CS=0 DS=0 R=0
                stz systemVIA.ddra           ;all bits inputs
                plp
                tya
rts98DB:
                rts
                .elsif version>=500
readCMOSByte=$9daa
                .endif
                
;-------------------------------------------------------------------------
;
; Write byte to RTC, either by 0-based CMOS RAM offset (writeCMOSByte)
; or by RTC register index (writeRTCByte).
;
; (For some reason, writeCMOSByte can't be used to write to CMOS RAM
; offset 0.)
;
; entry:
;
; X = address to write to
;
; Y = value to write
;
                .if version==320
writeCMOSByte:
                txa                          ; 98DC= 8A          .
                beq rts98DB                    ; 98DD= F0 FC       p|
                jsr getRTCAddressForCMOSByte
                bcs rts98DB                    ; 98E2= B0 F7       0w
writeRTCByte:
                php
                sei
                jsr setRTCAddress            ;X=address
                lda #$41
                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=0
                lda #$FF
                sta systemVIA.ddra           ;all bits outputs
                lda #$4A
                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=1
                sty systemVIA.oraNoHandshake ;store value
                bra deselectRTC
                .elsif version>=500
writeCMOSByte=$9fd8
                .endif
                
;-------------------------------------------------------------------------
;
; Convert CMOS byte offset to actual RTC address.
;
; entry:
;
; X = CMOS byte offset - 0-49
;
; exit:
;
; C=1 = invalid address
;
; C=0 = valid address: X = register index
;
                .if version==320
getRTCAddressForCMOSByte:
                cpx #size(RTC.ram)
                bcs rts9905
                txa        
                adc #RTC.ram
                tax        
rts9905:
                rts        
                .endif
                
;-------------------------------------------------------------------------
;
; set RTC address for future read/write operation.
;
; entry:
;
; X = address to set
;
; preserves: Y
;
                .if version==320
setRTCAddress:
                lda #$02
                sta systemVIA.orb            ;RTC AS=0 CS=0 DS=0 R=0
                lda #$82
                sta systemVIA.orb            ;RTC AS=1 CS=0 DS=0 R=0
                lda #$FF
                sta systemVIA.ddra           ;all bits outputs
                stx systemVIA.oraNoHandshake ;write RTC address
                lda #$c2
                sta systemVIA.orb            ;RTC AS=1 CS=1 DS=0 R=0
                lda #$42
                sta systemVIA.orb            ;RTC AS=0 CS=1 DS=0 R=0
                rts                          ; 9922= 60          `
                .endif
                
;-------------------------------------------------------------------------

L9923:
                lda #$03
                jsr mos.LD298
                bcc L993C
                jsr L9930
                jsr mos.LD8A9
L9930:
                ldx #$20
                jmp mos.LE2B8

L9935:
                lda #$02
                jsr mos.LD298
                bcs L99A0
L993C:
                jsr mos.LD3D2
                jsr L9ABF
                bra L994C

L9944:
                jsr mos.LD41A
                beq L99A0
                jsr mos.LD3D2
L994C:
                lda $E1
                bit #$20
                beq L9957
                pha
                jsr mos.LD6A3
                pla
L9957:
                bit #$10
                beq L995E
                jsr mos.LD698
L995E:
                jsr L99FC
                php
                jsr L9A5A
                ldx #$42
                ldy #$46
                lda #$20
                bit L8849
                beq L998C
                bmi L998A
                lda $032C
                cmp $0337
                bne L9982
                lda $032D
                cmp $0338
                beq L9992
L9982:
                ldx #$37
                jsr mos.LD24D
                ldx #$42
                clv
L998A:
                ldy #$2C
L998C:
                bmi L9995
                bvc L9992
                ldx #$37
L9992:
                jsr mos.LD24D
L9995:
                plp
                bcc L994C
                rts

L9999:
                lda #$01
                jsr mos.LD298
                bcc L99A9
L99A0:
                ldx #$24
                bra L99DB

L99A4:
                jsr mos.LD41A
                beq L99A0
L99A9:
                jsr mos.LD3D2
                jsr L99C9
L99AF:
                jsr mos.LD5E6
                jsr L99C9
                lda L8830
                ora L8831
                beq L99FB
                bit L8848
                bvs L99AF
                ldx #$42
                jsr L99D6
                bra L99AF

L99C9:
                jsr mos.LD334
                jsr L99DE
                bit L8848
                bmi L99FB
                ldx #$46
L99D6:
                phx
                jsr mos.LD280
                plx
L99DB:
                jmp mos.LDB4C

L99DE:
                ldx #$03
L99E0:
                lda L8830,x
                sta $0342,x
                sta $0346,x
                dex
                bpl L99E0
L99EC:
                ldy $0342
                lda $0343
                jsr mos.negateAY
                sty $0342
                sta $0343
L99FB:
                rts

L99FC:
                lda $E1
                sta L8849
                jsr L99DE
                ldx #$01
L9A06:
                stz $0342,x
                stz $0346,x
                dex
                bpl L9A06
L9A0F:
                jsr L9A2E
                lda L8830
                ora L8831
                bne L9A20
                sec
                lda L8847
                bne L99EC
L9A20:
                jsr mos.LD5E6
                lda L8832
                cmp $0344
                beq L9A0F
                clc
                bra L99EC

L9A2E:
                jsr mos.LD334
                bit L8848
                bmi L9A3D
                php
                ldx #$46
                jsr L9A41
                plp
L9A3D:
                bvs L9A59
                ldx #$42
L9A41:
                lda L8830
                tay
                cmp $0300,x
                lda L8831
                pha
                sbc $0301,x
                pla
                bcc L9A59
                sta $0301,x
                tya
                sta $0300,x
L9A59:
                rts

L9A5A:
                lda $0344
                ora $0345
                bne L9ABE
                lda $E1
                inc a
                and #$03
                bne L9ABE
                lda #$20
                bit L8849
                bpl L9A79
                beq L9A79
                ldx #$2C
                ldy #$46
                jsr mos.copyFourBytesWithinVDUVariables
L9A79:
                lda #$10
                bit L8849
                bvc L9A89
                beq L9A89
                ldx #$37
                ldy #$42
                jsr mos.copyFourBytesWithinVDUVariables
L9A89:
                jsr L9ABF
                lda $E1
                eor #$3C
                rol a
                jsr mos.fixUpVPALETTEFor4Colours
                ror a
                sta $E1
                bit #$20
                beq L9AAB
                pha
                ldx #$2C
                ldy #$46
                jsr mos.sortVDUVariableWords
                tya
                tax
                ldy #$46
                jsr mos.copyFourBytesWithinVDUVariables
                pla
L9AAB:
                bit #$10
                beq L9ABB
                ldx #$37
                ldy #$42
                jsr mos.sortVDUVariableWords
                ldy #$42
                jsr mos.copyFourBytesWithinVDUVariables
L9ABB:
                stz L8849
L9ABE:
                rts

L9ABF:
                ldx #$03
L9AC1:
                stz $033B,x
                dex
                bpl L9AC1
                ldy #$28
                ldx #$1B
                lda #$2C
                jsr L9ADF
                jsr mos.LD6A8
                ldy #$1B
                ldx #$28
                lda #$37
                jsr L9ADF
                jmp mos.LD69D

L9ADF:
                pha
                lda $E1
                lsr a
                bcc L9AF0
                lda L8847
                bne L9AEE
                ldx #$3B
                bra L9AF0

L9AEE:
                ldy #$3B
L9AF0:
                txa
                plx
                phx
                pha
                phy
                tay
                lda #$03
                sta $DA
L9AFA:
                lda $0300,y
                sta L881E,x
                iny
                inx
                dec $DA
                bpl L9AFA
                ply
                pla
                plx
L9B09:
                pha
                phy
                jsr L9B61
                dex
                ply
                pla
                phx
                iny
                iny
                inc a
                inc a
                inx
                inx
                jsr L9B61
                plx
                jsr L9B90
                php
                pha
                lda $0305,x
                asl a
                ror $030A,x
                bpl L9B2D
                jsr L9B7F
L9B2D:
                pla
                asl a
                ror $030A,x
                bpl L9B3B
                inx
                inx
                jsr L9B7F
                dex
                dex
L9B3B:
                jsr L9B90
                bpl L9B46
                lda $0305,x
                ldy $0304,x
L9B46:
                plp
                bmi L9B4F
                cpy #$00
                bne L9B4E
                dec a
L9B4E:
                dey
L9B4F:
                lsr a
                pha
                tya
                ror a
                sec
                dex
                jsr L9B5A
                inx
                pla
L9B5A:
                sbc $0307,x
                sta $0309,x
                rts

L9B61:
                pha
                lda $0300,y
                sta $0300,x
                lda $0301,y
                sta $0301,x
                ply
                sec
                jsr L9B75
                inx
                iny
L9B75:
                lda $0300,y
                sbc $0300,x
                sta $0304,x
                rts

L9B7F:
                lda $0305,x
                ldy $0304,x
                jsr mos.negateAY
                sta $0305,x
                tya
                sta $0304,x
                rts

L9B90:
                lda $0306,x
                tay
                cmp $0304,x
                lda $0307,x
                sbc $0305,x
                php
                lda $0307,x
                plp
                rts

;-------------------------------------------------------------------------
;
; 112119 = Plot parallelogram [MasRef E.3-27]
;
plotParallelogram:
                ldx #$28
                stx $DA
                ldx #$14
                ldy #$20                     ; 9BA9= A0 20
                lda #$24
                jsr mos.addRegionDimensionsToVDUVariableCoordinates
                ldy #$14
                ldx #$24
                jsr mos.sortVDUVariableCoordinates
                stx L8830
                ldx #$20
                jsr mos.sortVDUVariableCoordinates
                stx L8831
                ldx #$28
                jsr mos.sortVDUVariableCoordinates
                sty L8833
                ldy L8831
                jsr mos.sortVDUVariableCoordinates
                sty L8832
                ldy L8830
                jsr L9C0F
                lda L8833
                sta $E0
                ldx #$2C
                jsr L9B09
                ldy $E1
                jsr L9C56
                ldy L8832
                lda L8833
                sta $E1
                ldx #$37
                jsr L9C51
                bra L9C0C

L9BF7;
                ldy #$14
                ldx #$24
                jsr mos.sortVDUVariableCoordinates
                sty L8832
                ldy #$20                     ; 9C01= A0 20
                jsr L9C0F
                lda L8832
                jsr L9C4D
L9C0C:
                jmp mos.LDAE4

L9C0F:
                jsr mos.sortVDUVariableCoordinates
                stx L8830
                ldx L8832
                jsr mos.sortVDUVariableCoordinates
                sty L8832
                stx L8831
                ldy L8830
                ldx #$FC
L9C26:
                lda $0300,y
                sta vduv.workspace._42-$fc,x
                sta vduv.workspace._46-$fc,x
                iny
                inx
                bne L9C26
                ldy L8830
                lda L8832
                sta $E1
                ldx #$37
                jsr L9B09
                ldy L8830
                lda L8831
                jsr L9C4D
                ldy L8831
                rts

L9C4D:
                sta $E0
                ldx #$2C
L9C51:
                jsr L9B09
                ldy $E0
L9C56:
                phy
                lda $0302,y
                cmp $0344
                bne L9C67
                lda $0303,y
                cmp $0345
                beq L9CA0
L9C67:
                ldx #$2C
                jsr L9CC0
                ldx #$37
                jsr L9CC0
                jsr mos.LDAE4
                ldx #$37
                jsr mos.LD726
                ldx #$2C
                jsr mos.LD726
                ldy #$37
                jsr mos.sortVDUVariableWords
                phx
                ldx #$FC
L9C86:
                lda $0300,y
                sta vduv.workspace._46-$fc,x
                iny
                inx
                bne L9C86
                plx
                ldy #$FC
L9C93:
                lda $0300,x
                sta vduv.workspace._42-$fc,y
                inx
                iny
                bne L9C93
                ply
                bra L9C56

L9CA0:
                lda #$2C
                ldx $E0
                jsr L9CAC
                ply
                lda #$37
                ldx $E1
L9CAC:
                sta $DE
                lda vduv.graphicsWindowPixelsBottom+0,x
                cmp vduv.graphicsWindowPixelsBottom+0,y
                bne L9CBE
                lda vduv.graphicsWindowPixelsBottom+1,x
                cmp vduv.graphicsWindowPixelsBottom+1,y
                beq L9CC3
L9CBE:
                ldx $DE
L9CC0:
                jsr mos.LD71D
L9CC3:
                lda $0300,x
                cmp $0342
                lda $0301,x
                sbc $0343
                bpl L9CDE
                lda $0300,x
                sta $0342
                lda $0301,x
                sta $0343
                rts

L9CDE:
                lda $0346
                cmp $0300,x
                lda $0347
                sbc $0301,x
                bpl L9CF8
                lda $0300,x
                sta $0346
                lda $0301,x
                sta $0347
L9CF8:
                rts

L9CF9:
                jsr mos.LDDA1
                stz $0336
                stz $0337
                jsr mos.LDCB0
                bne L9D56
                jsr mos.LDC1C
L9D0A:
                bit $FF
                bmi L9D56
                lda $0336
                cmp $0337
                beq L9D56
                inc a
                sta $0336
                tax
                lda L8400,x
                sta $0328
                lda L8500,x
                sta $032C
                lda L8600,x
                pha
                lsr a
                lsr a
                sta $0329
                pla
                and #$03
                sta $032D
                lda L8700,x
                stz $032B
                cmp $0306
                beq L9D4B
                sta $E0
                inc a
                jsr mos.LDC48
                bcs L9D56
                lda $E0
L9D4B:
                cmp $0302
                beq L9D0A
                dec a
                jsr mos.LDC48
                bcc L9D0A
L9D56:
                rts

L9D57:
                lda $0332
                tay
                cmp $032C
                lda $0333
                tax
                sbc $032D
                bcs L9D71
                iny
                bne L9D6B
                inx
L9D6B:
                sty $032E
                stx $032F
L9D71:
                rts

;-------------------------------------------------------------------------

                .if version>=500
readDefaults2:
                ldx #$0f
                bra readRTCByte
                .endif

;-------------------------------------------------------------------------

                .if version>=500
readDefaults3:
                ldx #$10
                bra readRTCByte
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9DAA:
                cpx #$ff
                bne readRTCByte
                jsr L907E
                ldy #0
                bcs L9DE0
                ldx #$7f
                jsr utils_9ECA
                phy
                ldx #$ff
                jsr utils_9ECA
                tya
                tsx
                eor $101,x
                ora #$7f
                tay
                bra L9DDF
                .endif

                .if version>=500
readRTCByte:
                phx
                jsr L907E
                bcc L9DDB
L9DD0:
                ldy #0
                cpx #$13
                bcs L9DDE
                ldy L9DE4,x
                bra L9DDE

L9DDB:
                jsr utils_9ECA
L9DDE:
                tya
L9DDF:
                plx
L9DE0:
                rts

L9DE1:
                phx
                bra L9DD0

L9DE4:
                .byte 0  
                .byte $FE
                .byte 0
                .byte $EB
                .byte 0
                .byte $ED
                .byte $FF
                .byte $FF
                .byte 0
                .byte 0
                .byte $F7
                .byte $E3
                .byte $20
                .byte 8
                .byte $A
                .byte $2C
                .byte $80
                .byte 0
                .byte 3
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9DF7:
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9DF8:
                txa
                and #$7f
                beq L9DF7
                ora #$80
                inc a
                beq L9DF7
writeRTCByte:
                phx
                phy
                jsr utils_9E99
                ply
                plx
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9E0A:
                php
                sei
                jsr L9E27
                jsr L9E80
                jsr L9E1A
                jsr L9E27
                plp
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9E1A:
                pha
                lda systemVIA.irb
                and #$df
                ora #$20
                sta systemVIA.orb
                pla
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9E27:
                pha
                lda systemVIA.irb
                and #$df
                sta systemVIA.orb
                pla
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9E32:
                php
                sei
                lda systemVIA.ddrb
                ora #$30
                sta systemVIA.ddrb
                jsr L9E27
                jsr L9E82
                jsr L9E1A
                jsr L9E4D
                jsr L9E27
                plp
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9E4D:
                pha
                lda systemVIA.irb
                and #$ef
                sta systemVIA.orb
                pla
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9E58:
                jsr L9E32
                lda #0
                jsr L9F23
                lda #6
                jsr L9F23
L9E65:
                php
                sei
                jsr L9E27
                jsr L9E4D
                jsr L9E1A
                jsr L9E82
                jsr L9E27
                lda systemVIA.ddrb
                and #$cf
                sta systemVIA.ddrb
                plp
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9E80:
                bcc L9E4D
L9E82:
                pha
                lda systemVIA.irb
                ora #$10
                sta systemVIA.orb
                pla
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9E8D:
                php
                sei
                sec
                rol a
L9E91:
                jsr L9E0A
                asl a
                bne L9E91
                plp
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9E99:
                phx
                phy
                jsr L9ECA
                bcs L9EA7
                tya
                tsx
                eor $101,x
                cmp #1
L9EA7:
                ply
                plx
                bcs L9EAC_500
                rts

L9EAC_500:
                jsr L9E32
                lda #$a0
                jsr L9F23
                txa
                jsr L9F23
                tya
                jsr L9F23
                jsr L9E65
                ldy #$a0
                ldx #0
L9EC3:
                dex
                bne L9EC3
                dey
                bne L9EC3
                rts

L9ECA:
                jsr L9E32
                lda #$0a
                jsr L9F23
                txa
                jsr L9F23
                bcs L9F0E_500
                jsr L9E32
                lda #$a1
                jsr L9F23
                bcs L9F0E_500
                jsr L9E27
                lda systemVIA.ddrb
                pha
                and #$ef
                sta systemVIA.ddrb
                lda #1
L9EF0:
                pha
                jsr L9E1A
                nop
                nop
                lda systemVIA.irb
                and #$10
                cmp #1
                jsr L9E27
                pla
                rol a
                bcc L9EF0
                tay
                pla
                sta systemVIA.ddrb
                sec
                jsr L9E0A
                clc
L9F0E_500:
                jmp L9E65
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9F11:
                jsr L9E32
                lda #$a0
                jsr L9F23
                txa
                jsr L9F23
                php
                jsr L9E65
                plp
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
L9F23:
                php
                sei
                jsr L9E8D
                jsr L9E27
                lda systemVIA.ddrb
                pha
                and #$ef
                sta systemVIA.ddrb
                jsr L9E1A
                nop
                nop
                lda systemVIA.irb
                and #$10
                cmp #1
                jsr L9E27
                pla
                sta systemVIA.ddrb
                bcs L9F4C
                plp
                clc
L9F4B:
                rts

L9F4C:
                plp
                sec
                rts
                .endif

;-------------------------------------------------------------------------

                .if version>=500
                .include "sound_stuff.s65"
                .endif

;-------------------------------------------------------------------------

                .if version>=500
                .endif

;-------------------------------------------------------------------------
;
; Terminal ROM service entry point.
;
terminalServiceEntryPoint:
                .if version==320
                cmp #romServiceCallTubeSystemPostInitialisation
                bcc L9DCC        ;taken if definitely not Tube-related
                bne handleTubeMainInitialisation
handleTubeSystemPostInitialisation:
                cpy #$00           
                beq L9DCC

                ; [Tube p28] - write out the startup message that the
                ; second processor has been stuck trying to write out.
writeSecondProcessorStartupMessageLoop:
                bit tube.status1
                bpl writeSecondProcessorStartupMessageLoop
                lda tube.data1  
                beq L9DCA       
                jsr OSWRCH      
                jmp writeSecondProcessorStartupMessageLoop

handleTubeMainInitialisation:
                lda #<tubeHost.eventHandler
                sta EVENTV+0
                lda #>tubeHost.eventHandler
                sta EVENTV+1
                lda #<tubeBrkHandlerAddr
                sta BRKV+0
                lda #>tubeBrkHandlerAddr
                sta BRKV+1
                lda #tube.status1.S|tube.status1.M|tube.status1.J|tube.status1.I;
                sta tube.status1

                ; Copy Tube host code into main RAM.
                ldy #$00
-
                lda tubeHost.codePage0,y
                sta tubeHostAddr+0*256,y
                lda tubeHost.codePages12,y
                sta tubeHostAddr+1*256,y
                lda tubeHost.codePages12+256,y
                sta tubeHostAddr+2*256,y
                dey                   
                bne -
                
                jsr tubeHost.resetTubeClaim

                ; Copy BRK handler into zero page.
                ldx #size(tubeHost.brkHandler)
-
                lda tubeHost.brkHandler,x
                sta @w tubeBrkHandlerAddr,x
                dex
                bpl -

L9DCA:
                lda #$00                     ; Claim call and return

L9DCC:
                .elsif version>=500
                cpx #15
                beq utilsInCorrectBank
                rts
utilsInCorrectBank:
                bra L9E17
L9DCA:
                lda #$00                
                .endif
                cmp #romServiceCallInitialiseFilingSystem
                bne L9DEA
                cpy #$04                     ; Exit if not TAPE/ROM
                bcs L9E16
                cpy #$00                     ; Exit if Y=0, no FS
                beq L9E16
                ldx #$03                     ; X=ROMFS, A=FS number
                tya
                cmp #$02                     ; If A=2, ROMFS, jump to select it
                bcs L9DE3
                ldx #$00                     ; X=TAPE, A=speed+2
                adc #$02
L9DE3:
                adc #$89                     ; Convert to TAPE/ROM select value
                jsr mos.selectROMOrTAPEByOSBYTE
                bra L9DCA                    ; Jump to claim and return

L9DEA:
                cmp #romServiceCallBreakInstruction
                bne L9E17
                lda hazel.hasACCCONChanged ; Skip if ACCCON not changed
                beq L9DFC
                stz hazel.hasACCCONChanged ; Clear ACCCON changed flag
                lda hazel.oldACCCON        ; Restore ACCCON
                sta ACCCON
L9DFC:
                phy                          ; 9DFC= 5A          Z
                ldy hazel.moveSrcHandle
                beq L9E08                    ; 9E00= F0 06       p.
                stz hazel.moveSrcHandle
                jsr closeFile                    ; 9E05= 20 0F 8F     ..
L9E08:
                ldy hazel.moveDestHandle
                beq L9E13                    ; 9E0B= F0 06       p.
                stz hazel.moveDestHandle
                jsr closeFile                    ; 9E10= 20 0F 8F     ..
L9E13:
                ply                          ; 9E13= 7A          z
                lda #$06                     ; 9E14= A9 06       ).
L9E16:
                rts                          ; 9E16= 60          `
L9E17:
                cmp #romServiceCallCloseAllOpenFiles
                bne L9E38                    ; 9E19= D0 1D       P.
                lda #$8D                     ; 9E1B= A9 8D       ).
                jsr L9E2C                    ; 9E1D= 20 2C 9E     ,.
                ldx #$03                     ; 9E20= A2 03       ".
                lda #$04                     ; 9E22= A9 04       ).
                bit $C6                      ; 9E24= 24 C6       $F
                beq L9E2A                    ; 9E26= F0 02       p.
                ldx #$00                     ; 9E28= A2 00       ".
L9E2A:
                lda #$8C                     ; 9E2A= A9 8C       ).
L9E2C:
                jsr mos.selectROMOrTAPEByOSBYTE
                lda #$00                     ; 9E2F= A9 00       ).
                tay                          ; 9E31= A8          (
                jsr osfindTapeOrROM
                lda #$26                     ; 9E35= A9 26       )&
                rts                          ; 9E37= 60          `

L9E38:
                cmp #romServiceCallHelp
                .if version==320
                bne L9E8F                    ; 9E3A= D0 53       PS
                .elsif version>=500
                bne LA304
                .endif
                phy                          ; 9E3C= 5A          Z
                lda ($F2),y                  ; 9E3D= B1 F2       1r
                cmp #$0D                     ; 9E3F= C9 0D       I.
                bne L9E61                    ; 9E41= D0 1E       P.
                jsr L9EFC                    ; 9E43= 20 FC 9E     |.
                jsr alwaysPrintFollowingMessage                    ; 9E46= 20 58 A9     X)
                .text "  MOS",13
                .text 13
                .if version==320
                .text "TERMINAL 1.20"
                .elsif version>=500
                .text "UTILS 1.00"
                .endif
                .byte 13
                .text 0
                bra L9E8B
L9E61:
                ldx #size(mosHelpSubject)-1
L9E63:
                lda (stringInputBufferAddress),y
                cmp #'.'
                beq L9E95                    ; 9E67= F0 2C       p,
                and #$DF                     ; 9E69= 29 DF       )_
                cmp mosHelpSubject,x
                bne L9E7B                    ; 9E6E= D0 0B       P.
                iny                          ; 9E70= C8          H
                dex                          ; 9E71= CA          J
                bpl L9E63                    ; 9E72= 10 EF       .o
                lda (stringInputBufferAddress),y
                jsr mos.isLetter
                bcs L9E95       
L9E7B:
                lda (stringInputBufferAddress),y
                cmp #13
                beq L9E8B
                iny
                cmp #' '
                bne L9E7B
                jsr mos.skipSpacesAndCheckForCRInStringInput
                bne L9E61
L9E8B:
                ply
                lda #romServiceCallHelp
LA304:
                rts

                .if version==320
L9E8F:
                jmp LAE19                    ; 9E8F= 4C 19 AE    L..
                .endif

mosHelpSubject: .text "SOM"

L9E95:
                jsr L9EFC                    ; 9E95= 20 FC 9E
                lda #<mosCommandTable
                sta terminalHELPWorkspace.tablePtr+0
                lda #>mosCommandTable
                sta terminalHELPWorkspace.tablePtr+1
L9EA0:
                lda (terminalHELPWorkspace.tablePtr)
                bmi L9EF4                    ; 9EA2= 30 50       0P
                jsr printSpace                    ; 9EA4= 20 0C 9F     ..
                jsr printSpace                    ; 9EA7= 20 0C 9F     ..
                lda (terminalHELPWorkspace.tablePtr)
L9EAC:
                jsr L9F0E
                inc terminalHELPWorkspace.tablePtr+0
                bne L9EB5
                inc terminalHELPWorkspace.tablePtr+1  
L9EB5:
                lda (terminalHELPWorkspace.tablePtr)
                bpl L9EAC

                ; add 4 to tablePtr
                lda #$04                     
                clc                          
                adc terminalHELPWorkspace.tablePtr+0
                sta terminalHELPWorkspace.tablePtr+0
                bcc +          
                inc terminalHELPWorkspace.tablePtr+1
+
                jsr mos.LE25C
                cpx #19
                beq L9EEF
L9ECB:
                jsr mos.getTextCursorPositionWithColumn81
                txa                          ; 9ECE= 8A          .
                beq L9EA0                    ; 9ECF= F0 CF       pO
                cpx #20
                beq L9EA0
                bcc L9EE4
                cpx #40
                beq L9EA0
                bcs L9EE9
                jsr mos.LE25C                ; 9EDD= 20 5C E2     \b
                cpx #39
                beq L9EEF                    ; 9EE2= F0 0B       p.
L9EE4:
                jsr printSpace                    ; 9EE4= 20 0C 9F     ..
                bra L9ECB                    ; 9EE7= 80 E2       .b

L9EE9:
                cpx #60
                bcc L9EE4
                beq L9EA0
L9EEF:
                jsr printNewLine
                bra L9EA0

L9EF4:
                jsr mos.getTextCursorPositionWithColumn81
                txa      
                beq L9E8B
                bra L9EEF

L9EFC:
                phy
                jsr alwaysPrintFollowingMessage
                .text 13
                .if version==320
                .text "OS 3.20"
                .elsif version>=500
                .text "MOS 5.00"
                .endif
                .text 13,0
                ply
                rts

;-------------------------------------------------------------------------
;
printSpace:
                lda #$20          
L9F0E:
                phx               
                ldx $B0           
                phx               
                ldx $B1           
                jsr OSWRCH        
restoreB1AndB0:
                stx $B1           
                plx               
                stx $B0           
                plx               
                rts               

;-------------------------------------------------------------------------

printNewLine:
                phx               
                ldx $B0           
                phx               
                ldx $B1           
                jsr OSNEWL        
                bra restoreB1AndB0

;-------------------------------------------------------------------------

; TAPE/ROM OSARGS handler
; =======================
osargsTapeOrROM:
                cpy #$00                     ; Handle<>0 - read/write open file info
                bne L9F3B
                ora #$00                     ; A<>0 - read/write filing system info - exit
                bne L9F3A

; A=0, Y=0 - read current filing system
; -------------------------------------
                lda #$03                     ; Prepare A=ROMFS
                bit cfsRFSFSSwitch                    ; If TAPE/ROM switch
                bne L9F3A
                and $C6                      ; Mask with speed to give A=2 or A=1

; TAPE/ROM FSC 6 - shut down FS
; TAPE/ROM FSC 8 - OS command
; TAPE/ROM FSC 10 - *INFO
; -----------------------------
L9F3A:
                rts

; OSARGS handle<>0 - red/write open file info
; -------------------------------------------
L9F3B:
                cmp #$00                     ; Not =PTR, exit unsupported
                bne L9F3A
                cpy #$02                     ; =PTR#2 - read PTR on output handle
                beq L9F60

; Read PTR on CFS/RFS input file
; ------------------------------
                lda #$01                     ; Check if this is input channel and is open
                jsr LAA68
                lda $039E
                sta $00,x
                phy                          ; 9F4D= 5A          Z
                lda $03DE                    ; 9F4E= AD DE 03    -^.
                ldy $03DD                    ; 9F51= AC DD 03    ,].
                bne L9F57                    ; 9F54= D0 01       P.
                dec a                        ; 9F56= 3A          :
L9F57:
                dey                          ; 9F57= 88          .
                sty $01,x                    ; 9F58= 94 01       ..
                ply                          ; 9F5A= 7A          z
L9F5B:
                sta $02,x                    ; 9F5B= 95 02       ..
                stz $03,x                    ; 9F5D= 74 03       t.
                rts                          ; 9F5F= 60          `

; Read PTR on TAPE output file
; ----------------------------
L9F60:
                lda #$02                     ; Check if this is output channel and is open
                jsr LAA68
                lda $039D                    ; Copy PTR to control block
                sta $00,x
                lda $0394
                sta $01,x
                lda $0395
                bra L9F5B

; TAPE/ROM FSC dispatch table
; ---------------------------

_:=[]
_..=[LA422]          ;0 - *OPT
_..=[LA4F1]          ;1 - EOF
_..=[LA110]          ;2 - */
_..=[LA129]          ;3 - unknown * command
_..=[LA110]          ;4 - *RUN
_..=[LA168]          ;5 - *CAT
_..=[L9F3A]          ;6 - shut down FS
_..=[L9F9E]          ;7 - obtain file handle range
_..=[L9F3A]          ;8 - OS command
_..=[LA155]          ;9 - *EX
_..=[L9F3A]          ;10 - *INFO
_..=[LA113]          ;11 - *RUN command for library
tape_and_rom_dispatch_fsc_routines=_
                
L9F74:
                .byte <tape_and_rom_dispatch_fsc_routines-1
L9F80:
                .byte >tape_and_rom_dispatch_fsc_routines-1

; TAPE/ROM FSC
; ============
fscTapeOrROM:
                cmp #$0C                     ; function<12 - exit unchanged
                bcs L9F3A
                stx $BC                      ; Index into dispatch table
                tax
                lda L9F80,x
                pha
                lda L9F74,x
                pha
                ldx $BC
                rts

; TAPE/ROM FSC 7 - obtain file handle range
; -----------------------------------------
L9F9E:
                ldx #$03                     ; 9F9E= A2 03       ".
                ldy #$03                     ; 9FA0= A0 03        .
                lda cfsRFSFSSwitch                    ; 9FA2= AD 47 02    -G.
                bne L9F3A                    ; 9FA5= D0 93       P.
                dey                          ; 9FA7= 88          .
                ldx #$01                     ; 9FA8= A2 01       ".
                rts                          ; 9FAA= 60          `

L9FAB:
                pla                          ; 9FAB= 68          h
                plp                          ; 9FAC= 28          (
                sec                          ; 9FAD= 38          8
                rts                          ; 9FAE= 60          `

L9FAF:
                php                          ; 9FAF= 08          .
                pha                          ; 9FB0= 48          H
                jsr LA9F3                    ; 9FB1= 20 F3 A9     s)
                lda $03C2                    ; 9FB4= AD C2 03    -B.
                pha                          ; 9FB7= 48          H
                jsr LA502                    ; 9FB8= 20 02 A5     .%
                pla                          ; 9FBB= 68          h
                bcs L9FAB                    ; 9FBC= B0 ED       0m
                beq L9FD9                    ; 9FBE= F0 19       p.
                ldx #$03                     ; 9FC0= A2 03       ".
                lda #$FF                     ; 9FC2= A9 FF       ).
L9FC4:
                pha                          ; 9FC4= 48          H
                lda $03BE,x                  ; 9FC5= BD BE 03    =>.
                sta $B0,x                    ; 9FC8= 95 B0       .0
                pla                          ; 9FCA= 68          h
                and $B0,x                    ; 9FCB= 35 B0       50
                dex                          ; 9FCD= CA          J
                bpl L9FC4                    ; 9FCE= 10 F4       .t
                inc a                        ; 9FD0= 1A          .
                bne L9FD9                    ; 9FD1= D0 06       P.
                jsr LA9B1                    ; 9FD3= 20 B1 A9     1)
                jmp badAddressError                    ; 9FD6= 4C 4B 93    LK.

L9FD9:
                lda $03CA                    ; 9FD9= AD CA 03    -J.
                lsr a                        ; 9FDC= 4A          J
                pla                          ; 9FDD= 68          h
                pha                          ; 9FDE= 48          H
                beq L9FF1                    ; 9FDF= F0 10       p.
                bcc L9FF8                    ; 9FE1= 90 15       ..
L9FE3:
                jsr LA9BB                    ; 9FE3= 20 BB A9     ;)
                jsr doFollowingError                    ; 9FE6= 20 ED AA     m*
                .text $d5,"Locked",0
L9FF1:
                bcc L9FF8                    ; 9FF1= 90 05       ..
                lda #$03                     ; 9FF3= A9 03       ).
                sta breakAndESCAPEEffect                    ; 9FF5= 8D 58 02    .X.
L9FF8:
                lda #$30                     ; 9FF8= A9 30       )0
                and $BB                      ; 9FFA= 25 BB       %;
                beq LA002                    ; 9FFC= F0 04       p.
                lda $C1                      ; 9FFE= A5 C1       %A
LA000:
                bne LA00A                    ; A000= D0 08       P.
LA002:
                .if version==320
                phy                          ; A002= 5A          Z
                jsr LAAA4                    ; A003= 20 A4 AA     $*
                ply                          ; A006= 7A          z
                .endif
                jsr LA6D2                    ; A007= 20 D2 A6     R&
LA00A:
                jsr LA8A1                    ; A00A= 20 A1 A8     !(
                bne LA066                    ; A00D= D0 57       PW
                jsr LAA35                    ; A00F= 20 35 AA     5*
                bit $03CA                    ; A012= 2C CA 03    ,J.
                bmi LA01F                    ; A015= 30 08       0.
                jsr LA85B                    ; A017= 20 5B A8     [(
                jsr LA678                    ; A01A= 20 78 A6     x&
                bra L9FF8                    ; A01D= 80 D9       .Y

LA01F:
                pla                          ; RUN, no control block to update
                beq LA055
                ldy #$02
LA024:
                lda $03BC,y                  ; Copy load/exec to control block
                sta ($C8),y
                iny
                cpy #$0A
                bne LA024
                lda $03C8                    ; Length b0-b7=Block Length b0-b7
                sta ($C8),y
                iny
                lda $03C9
                clc
                adc $03C6                    ; Length b8-b15=Block Number+Block Length b8-b15
                sta ($C8),y
                iny
                lda #$00
                adc $03C7                    ; Length b16-b23=overflow
                sta ($C8),y
                iny                          ; Length b24-b31=&00
                lda #$00
                sta ($C8),y
                iny
LA04B:
                lda $03BD,y                  ; Attrs=&00000000
                sta ($C8),y
                iny
                cpy #$12
                bne LA04B
LA055:
                plp
LA056:
                jsr LA9B1
LA059:
                bit $BA                      ; If flag set, skip printing newline
                bmi LA064
LA05D:
                php                          ; Print inline text
                jsr LA923
                .byte 13                     ; Could just do JSR OSNEWL
                .byte 0
                plp
LA064:
                clc
                rts

LA066:
                jsr LA506                    ; A066= 20 06 A5     .%
                bne L9FF8                    ; A069= D0 8D       P.
LA06B:
                stx $F2                      ; A06B= 86 F2       .r
                sty $F3                      ; A06D= 84 F3       .s
                ldy #$00                     ; A06F= A0 00        .
                jsr mos.gsinitForFilenameParsing
                ldx #$00                     ; A074= A2 00       ".
LA076:
                jsr mos.gsreadEntryPoint     ; A076= 20 7F F2     .r
                bcs LA088                    ; A079= B0 0D       0.
                beq LA085                    ; A07B= F0 08       p.
                sta $03D2,x                  ; A07D= 9D D2 03    .R.
                inx                          ; A080= E8          h
                cpx #$0B                     ; A081= E0 0B       `.
                bne LA076                    ; A083= D0 F1       Pq
LA085:
                jmp mos.badStringError       ; A085= 4C 8F F2    L.r

LA088:
                stz $03D2,x                  ; A088= 9E D2 03    .R.
                rts                          ; A08B= 60          `

; CFS/RFS OSFILE
; ==============
osfileTapeOrROM:
                pha
                stx $C8                      ; C8/9=>control block
                sty $C9
                lda ($C8)                    ; Get XY=>filename
                tax
                ldy #$01
                lda ($C8),y
                tay
                jsr LA06B                    ; Parse filename
                ldy #$02
LA09E:
                lda ($C8),y
                sta $03BC,y
                sta $00AE,y
                iny
                cpy #$0A
                bne LA09E
                pla
                beq LA0B5
                cmp #$FF
                bne LA064
                jmp L9FAF

LA0B5:
                sta $03C6
                sta $03C7
LA0BB:
                lda ($C8),y
                sta $00A6,y
                iny
                cpy #$12
                bne LA0BB
                txa
                beq LA085
                jsr LA9F3
                jsr LA822
                .if version==320
                lda #$00
                jsr LAAA6
                .endif
LA0D3:
                sec
                ldx #$fd                     ;-3
LA0D6:
                lda ($b4-$fd)&$ffff,x
                sbc ($b0-$fd)&$ffff,x
                sta $3c8-$fd,x
                inx
                bne LA0D6
                tay
                bne LA0F3
                cpx $03C8
                lda #$01
                sbc $03C9
                bcc LA0F3
                ldx #$80
                bra LA0FB

LA0F3:
                lda #$01
                sta $03C9
                stx $03C8
LA0FB:
                stx $03CA
                jsr LA6E9
                bmi LA17B
                jsr LA85B
                inc $03C6
                bne LA0D3
                inc $03C7
                bra LA0D3

; TAPE/ROM FSC 2 - */
; TAPE/ROM FSC 4 - *RUN
; ---------------------
LA110:
                sec
                ror $CE
; TAPE/ROM FSC 11 - *RUN command for library
; ------------------------------------------
LA113:
                phx
                phy
                jsr LA06B
                lda #$00
                ldx #$FF
                stx $03C2
                jsr L9FAF
                ply
                plx
                bcc LA12E
                jsr LA9CA

; TAPE/ROM FSC 3 - unknown * command
; ----------------------------------
LA129:
                lda #$0B
                jmp (FSCV)

LA12E:
                .if version==320
                bit tubePresence
                bpl LA13C
                lda $03C4
                and $03C5
                inc a
                bne LA14C
LA13C:
                .endif
                
                ldx $03C2
                ldy $03C3
                lda #$A4
                jsr OSBYTE
                lda #$01
                jmp ($03C2)

                .if version==320
LA14C:
                ldx #$C2
                ldy #$03
                lda #$04
                jmp LAAB0
                .endif

; TAPE/ROM FSC 9 - *EX
; --------------------
LA155:
                lda #$08
                tsb $E2
                lda $E3
                pha
                ora #$CC
                sta $E3
                jsr LA9F3
                pla
                sta $E3
                bra LA16F

; TAPE/ROM FSC 5 - *CAT
; ---------------------
LA168:
                lda #$08
                tsb $E2
                jsr LA9F3
LA16F:
                lda #$00
                jsr LA17C
                jsr LA9CA
LA177:
                lda #$08
                trb $E2
LA17B:
                rts

LA17C:
                pha
                lda cfsRFSFSSwitch
                beq LA18B
                jsr mos.LF6FC
                jsr mos.LF701
                clv
                bcs LA1DB
LA18B:
                jsr LA678
                lda $03C6
                sta $B4
                lda $03C7
                sta $B5
                ldx #$FF
                stx $03DF
                stz $BA
                bra LA1B7

LA1A1:
                lda cfsRFSFSSwitch
                beq LA1DD
LA1A6:
                jsr mos.LF717
LA1A9:
                lda #$FF
                sta $03C6
                sta $03C7
LA1B1:
                jsr LAA35
                jsr LA678
LA1B7:
                lda cfsRFSFSSwitch
                beq LA1BE
                bvc LA1DB
LA1BE:
                pla
                pha
                beq LA1DD
                jsr LA95C
                bne LA1A1
                lda #$30
                and $BB
                beq LA1DB
                lda $03C6
                cmp $B6
                bne LA1A1
                lda $03C7
                cmp $B7
                bne LA1A1
LA1DB:
                pla
                rts

LA1DD:
                bvc LA1E4
                lda #$FF
                jsr LA6D4
LA1E4:
                ldx #$00
                jsr LA8C4
                lda cfsRFSFSSwitch
                beq LA1F2
                bit $BB
                bvc LA1A6
LA1F2:
                bit $03CA
                bmi LA1A9
                bra LA1B1

; CFS/RFS OSFIND HANDLER
; ======================
osfindTapeOrROM:
                sta $BC
                phx
                phy
                ora #$00
                bne LA220
                tya
                bne LA212
                lda cfsRFSFSSwitch
                bne LA20C
                jsr LA29C
LA20C:
                lda #$01
                trb $E2
                bra LA21E

LA212:
                lsr a
                bcs LA20C
                lsr a
                bcs LA21B
                jmp LAA81

LA21B:
                jsr LA29C
LA21E:
                bra LA297

LA220:
                jsr LA06B
                bit $BC
                bvc LA260
                stz $039E
                stz $03DD
                stz $03DE
                lda #$C1
                trb $E2
                jsr LA9E6
                php
                jsr LA502
                jsr LA5B7
                plp
                ldx #$FF
LA241:
                inx
                lda $03B2,x
                sta $03A7,x
                bne LA241
                inc a
                tsb $E2
                lda tapeInputCurrentBlockSize+0
                ora tapeInputCurrentBlockSize+1
                bne LA259
                lda #$40
                tsb $E2
LA259:
                lda #$01
                ora cfsRFSFSSwitch
                bne LA295
LA260:
                txa
                bne LA266
                jmp mos.badStringError

LA266:
                ldx #$FF
LA268:
                inx
                lda $03D2,x
                sta $0380,x
                bne LA268
                dec a
                ldx #$08
LA274:
                sta $038B,x
                dex
                bne LA274
                txa
                ldx #$14
LA27D:
                sta $0380,x
                inx
                cpx #$1E
                bne LA27D
                rol $0397
                jsr LA9F3
                jsr LA822
                jsr LA9BB
                lda #$02
                tsb $E2
LA295:
                sta $BC
LA297:
                ply
                plx
                lda $BC
LA29B:
                rts

LA29C:
                lda #$02
                and $E2
                beq LA29B
                stz $0397
                lda #$80
                ldx $039D
                stx $0396
                sta $0398
                jsr LA2B8
                lda #$02
                trb $E2
                rts

LA2B8:
                jsr LA9E6
                ldx #$11
LA2BD:
                lda $038C,x
                sta $03BE,x
                dex
                bpl LA2BD
                stx $B2
                stx $B3
                stz $B0
                lda #$09
                sta $B1
                ldx #$7F
                jsr LAA4D
                sta $03DF
                jsr LAA5A
                jsr LAAA0
                jsr LA6E9
                inc $0394
                bne LA2E9
                inc $0395
LA2E9:
                rts

bputTapeOrROM:
                phx
                phy
                lda #$01
LA2EE:
                jsr LAA68
                lda $E2
                asl a
                bcs LA343
                asl a
                bcc LA301
                lda #$80
                tsb $E2
                lda #$FE
                bcs LA33B
LA301:
                ldx $039E
                inx
                cpx tapeInputCurrentBlockSize+0
                bne LA336
                bit blockFlagOfCurrentlyResidentBlock
                bmi LA332
                lda lastCharacterOfCurrentlyResidentBlock
                pha
                jsr LA9E6
                php
                jsr LA5AF
                plp
                pla
                sta $BC
                clc
                bit blockFlagOfCurrentlyResidentBlock
                bpl LA33D
                lda tapeInputCurrentBlockSize+0
                ora tapeInputCurrentBlockSize+1
                bne LA33D
                lda #$40
                tsb $E2
                bra LA33D

LA332:
                lda #$40
                tsb $E2
LA336:
                dex
                clc
                lda $0A00,x
LA33B:
                sta $BC
LA33D:
                inc $039E
                jmp LA297

LA343:
                jsr doFollowingError
                .text $df,"EOF",0
bgetTapeOrROM:
                sta $C4
                phx
                phy
                lda #$02
                jsr LAA68
                ldx $039D
                lda $C4
                sta $0900,x
                inx
                bne LA365
                jsr LA2B8
                jsr LA9BB
LA365:
                inc $039D
                lda $C4
                jmp LA295

; TAPE/ROM OSGBPB handler
; =======================
osgbpbTapeOrROM:
                lsr a                        ; Odd numbered calls - change PTR - exit with A=changed, SEC
                bcs LA376
                beq LA376                    ; OSGBPB 0 - exit with A=unchanged, SEC
                cmp #$03                     ; function/2<3 - function<6 - function 2 and 4 - jump to do
                bcc LA378
LA376:
                sec
                rts
; Call Return
;  0    A=0   SEC                        - unsupported
;  1    A=0   SEC  Write using new PTR   - unsupported
;  2    A=         Write with current PTR
;  3    A=1   SEC  Read with new PTR     - unsupported
;  4    A=         Read with current PTR
;  5+   A=A/2 SEC                        - unsupported

; TAPE/ROM OSGBPB 2 and 4 - read/write with current PTR
; -----------------------------------------------------
LA378:
                lsr a
                stx $CC
                sty $CD
                ldy #$01
                lda ($CC),y
                sta $C8
                iny
                lda ($CC),y
                sta $C9
                .if version==320
                iny
                lda ($CC),y
                iny
                and ($CC),y
                inc a
                and tubePresence
                pha
                php
                beq LA3A7
                ldx $CC
                ldy $CD
                inx
                bne LA39E
                iny
LA39E:
                
                lda #$00
                plp
                php
                adc #$00
                jsr LAAB0
LA3A7:
                .endif
                lda ($CC)
                tay
                lda #$01
                plp
                .if version==320
                php
                .endif
                adc #$00
                jsr LAA8D
                bcs LA3C1
                plp
                .if version==320
                pla
                beq LA3BE
                lda #$80
                jsr tubeHost.entryPoint
LA3BE:
                .endif
                jmp LAA81

LA3C1:
                plp
                bcs LA401
                bit $E2
                bpl LA3D3
                .if version==320
                pla
                beq LA3D0
                lda #$80
                jsr tubeHost.entryPoint
LA3D0:
                .endif
                jmp LA343

LA3D3:
                jsr LAAE0
                beq LA3F6
                lda ($CC)
                tay
                jsr bputTapeOrROM
                bcs LA3F6
                .if version==320
                plx
                phx
                beq LA3E9
                sta tube.data3
                bra LA3F1

LA3E9:
                .endif
                sta ($C8)
                inc $C8
                bne LA3F1
                inc $C9
LA3F1:
                jsr LAACA
                bra LA3D3

LA3F6:
                .if version==320
                pla
                php
                beq LA3FF
                lda #$80
                jsr tubeHost.entryPoint
LA3FF:
                plp
                .endif
                rts

LA401:
                jsr LAAE0
                beq LA3F6
                lda ($CC)
                tay
                .if version==320
                pla
                pha
                beq LA412
                lda tube.data3
                bra LA41A
LA412:
                .endif
                
                lda ($C8)
                inc $C8
                bne LA41A
                inc $C9
LA41A:
                jsr bgetTapeOrROM
                jsr LAACA
                bra LA401

; TAPE/ROM FSC 0 - *OPT
; ---------------------
LA422:
                txa                          ; *OPT 0
                beq LA453
                cpx #$03                     ; *OPT 3
                beq LA448
                cpy #$03                     ; *OPT n,3+ - error Bad command (*BUG* should be Bad option)
                bcs LA433
                dex                          ; *OPT 1
                beq LA436
                dex                          ; *OPT 2
                beq LA43D
LA433:
                jmp mos.badCommandError ; *OPT 4+ - error Bad command (*BUG* should be Bad option)

; *OPT 1 - set message level
; --------------------------
LA436:
                lda #$33
                iny
                iny
                iny
                bra LA43F

; *OPT 2 - set error response level
; ---------------------------------
LA43D:
                lda #$CC
LA43F:
                iny
                and $E3
LA442:
                ora LA456,y
                sta $E3
                rts

; *OPT 3 - set interblock gap
; ---------------------------
LA448:
                tya                          ; *OPT 3,128+ - set to default
                bmi LA44D    ;
                bne LA44F                    ; *OPT 3,<>0 - use setting
LA44D:
                lda #$19                     ; *OPT 3,0 or *OPT 3,128+ - use default of 2.5 sec
LA44F:
                sta $03D1                    ; Set inter-block gap
                rts

LA453:
                tay
                bra LA442

LA456:
                ; LDA ($00,x)
                ; EQUB $22
                ; ORA ($00),y
                ; DEY
                ; CPY LC0C6
                .byte $A1
                .byte $00
                .byte $22
                .byte $11
                .byte $00
                .byte $88
                .byte $CC
LA45D:
                dec $C0
                lda cfsRFSFSSwitch
                beq LA46B
                jsr mos.LF710
                tay
                clc
                bra LA485

LA46B:
                lda ACIA+0
                pha
                and #$02
                beq LA47E
                ldy $CA
                beq LA47E
                pla
                lda $BD
                sta ACIA+1
                rts

LA47E:
                ldy ACIA+1
                pla
                lsr a
                lsr a
                lsr a
LA485:
                ldx $C2
                beq LA4F0
                dex
                bne LA492
                bcc LA4F0
                ldy #$02
                bra LA4EE

LA492:
                dex
                bne LA4A8
                bcs LA4F0
                tya
                jsr LAA44
                ldy #$03
                cmp #$2A
                beq LA4EE
                jsr LAA1C
                ldy #$01
                bra LA4EE

LA4A8:
                dex
                bne LA4B5
                bcs LA4B0
                sty $BD
                rts

LA4B0:
                lda #$80
                sta $C0
                rts

LA4B5:
                dex
                bne LA4E1
                bcs LA4E9
                tya
                jsr LA6A9
                ldy $BC
                inc $BC
                bit $BD
                bmi LA4D3
                .if version==320
                jsr LAABC
                beq LA4D0
                stx tube.data3
                bra LA4D3

LA4D0:
                txa
                .endif
                sta ($B0),y
LA4D3:
                iny
                cpy $03C8
                bne LA4F0
                lda #$01
                sta $BC
                ldy #$05
                bra LA4EE

LA4E1:
                tya
                jsr LA6A9
                dec $BC
                bpl LA4F0
LA4E9:
                jsr resetACIA
                ldy #$00
LA4EE:
                sty $C2
LA4F0:
                rts

; TAPE/ROM FSC 1 - =EOF
; ---------------------
LA4F1:
                pha
                phy
                txa
                tay
                lda #$03                     ; Check if this channel is open for anything
                jsr LAA68
                lda $E2                      ; Get EOF flag
                and #$40
                tax                          ; Return in X
                ply
                pla
                rts

LA502:
                stz $B4                      ; A502= 64 B4       d4
                stz $B5                      ; A504= 64 B5       d5
LA506:
                lsr $CE                      ; A506= 46 CE       FN
                lda $B4                      ; A508= A5 B4       %4
                pha                          ; A50A= 48          H
                sta $B6                      ; A50B= 85 B6       .6
                lda $B5                      ; A50D= A5 B5       %5
                pha                          ; A50F= 48          H
                sta $B7                      ; A510= 85 B7       .7
                jsr LA923                    ; A512= 20 23 A9     #)
                .text "Searching",13,0
                lda #$ff
                jsr LA17C                    ; A522= 20 7C A1     |!
                pla                          ; A525= 68          h
                sta $B5                      ; A526= 85 B5       .5
                pla                          ; A528= 68          h
                sta $B4                      ; A529= 85 B4       .4
                lda $B6                      ; A52B= A5 B6       %6
                ora $B7                      ; A52D= 05 B7       .7
                bne LA564                    ; A52F= D0 33       P3
                stz $B4                      ; A531= 64 B4       d4
                stz $B5                      ; A533= 64 B5       d5
                lda cfsRFSFSSwitch                    ; A535= AD 47 02    -G.
                beq LA55B                    ; A538= F0 21       p!
                bvs LA55B                    ; A53A= 70 1F       p.
                jsr LA9CA                    ; A53C= 20 CA A9     J)
                bit $CE                      ; A53F= 24 CE       $N
                bvc notFoundError                    ; A541= 50 0A       P.
                sec                          ; A543= 38          8
rtsA544:
                rts                          ; A544= 60          `

;-------------------------------------------------------------------------

openFileForReading:
                lda #$40                     ;open for reading
                jsr OSFIND
                tay
                bne rtsA544
notFoundError:
                jsr doFollowingError                    ; A54D= 20 ED AA     m*
                .text $d6,"Not found",0

;-------------------------------------------------------------------------

LA55B:
                lda $C1
                bne LA564
                ldx #$B1
                jsr LAA4D
LA564:
                ldy #$FF
                sty $03DF
                clc
                rts

LA56B:
                beq LA584
                pha
                lda #fscFileHandleRange
                jsr mos.callFSCV
                pla
                clc
                php
                sei
                sta $FA
                cpy $FA
                bcc LA583
                cpx $FA
                bcc LA587
                beq LA587
LA583:
                plp
LA584:
                pla
                pla
                rts

LA587:
                plp
                lda #$00
                rts

LA58B:
                lda execFileHandle
                jsr LA56B
starEXEC:
                php
                phy
                ldy execFileHandle
                sta execFileHandle
                beq LA59E
                jsr OSFIND
LA59E:
                lsr hazel.tempFSFlag
                ply
                plp
                beq LA5AE
                asl hazel.tempFSFlag
                jsr openFileForReading
                sta execFileHandle
LA5AE:
                rts

LA5AF:
                ldx #$A6
                jsr LAA4D
                jsr LA678
LA5B7:
                lda $03CA
                lsr a
                bcc LA5C0
                jmp L9FE3

LA5C0:
                lda $03DD
                sta $B4
                lda $03DE
                sta $B5
                stz $B0
                lda #$0A
                sta $B1
                lda #$FF
                sta $B2
                sta $B3
                jsr LA6D2
                jsr LA8A1
                bne LA603
                lda $0AFF
                sta lastCharacterOfCurrentlyResidentBlock
                jsr LAA35
                stx $03DD
                sty $03DE
                ldx #$02
LA5EF:
                lda $03C8,x
                sta tapeInputCurrentBlockSize+0,x
                dex
                bpl LA5EF
                bit blockFlagOfCurrentlyResidentBlock
                bpl LA600
                jsr LA059
LA600:
                jmp LA9C5

LA603:
                jsr LA506
                bra LA5B7

LA608:
                cmp #'*'
                beq LA643
                cmp #'#'
                bne LA61F
                inc $03C6
                bne LA618
                inc $03C7
LA618:
                ldx #$FF
                bit mos.valueFF
                bra LA670

LA61F:
                jsr LA177
                jsr doFollowingError
                .byte $D7
                .text "Bad ROM"
                .byte 0

LA62E:
                ldy #$FF
                jsr LAA5C
                lda #$01
                sta $C2
                jsr LAA1C
LA63A:
                jsr LA880
                lda #$03
                cmp $C2
                bne LA63A
LA643:
                jsr LAA46
LA646:
                jsr LA694
                bvc LA665
                sta $03B2,y
                beq LA656
                iny
                cpy #$0B
                bne LA646
                dey
LA656:
                ldx #$0C
LA658:
                jsr LA694
                bvc LA665
                sta $03B2,x
                inx
                cpx #$1F
                bne LA658
LA665:
                tya
                tax
                stz $03B2,x
                lda $BE
                ora $BF
                sta $C1
LA670:
                jsr LAA44
                sty $C2
                txa
                bne LA6CC
LA678:
                lda cfsRFSFSSwitch
                beq LA62E
LA67D:
                jsr mos.LF710
                cmp #$2B
                bne LA608
                lda #$08
                and $E2
                beq LA68D
                jsr LA05D
LA68D:
                jsr mos.LF701
                bcc LA67D
                clv
                rts

LA694:
                lda cfsRFSFSSwitch
                beq LA6A6
                phx
                phy
                jsr mos.LF710
                sta $BD
                lda #$FF
                sta $C0
                ply
                plx
LA6A6:
                jsr LA778
LA6A9:
                php
                pha
                sec
                ror $CB
                eor $BF
                sta $BF
LA6B2:
                lda $BF
                clc
                bpl LA6C2
                eor #$08
                sta $BF
                lda $BE
                eor #$10
                sta $BE
                sec
LA6C2:
                rol $BE
                rol $BF
                lsr $CB
                bne LA6B2
                pla
                plp
LA6CC:
                rts

LA6CD:
                jsr LA776
                bra LA6A9

LA6D2:
                lda #$00
LA6D4:
                sta $BD
                ldx #$00
                stz $BC
                bvc LA6E6
                lda $03C8
                ora $03C9
                beq LA6E6
                ldx #$04
LA6E6:
                stx $C2
                rts

LA6E9:
                php
                ldx #$03
LA6EC:
                stz $03CB,x
                dex
                bpl LA6EC
                lda $03C6
                ora $03C7
                bne LA6FF
                jsr LA784
                bra LA702

LA6FF:
                jsr LA788
LA702:
                lda #$2A
                sta $BD
                jsr LAA44
                jsr LAA16
                jsr LA778
                dey
LA710:
                iny
                lda $03D2,y
                sta $03B2,y
                jsr LA6CD
                bne LA710
                ldx #$0C
LA71E:
                lda $03B2,x
                jsr LA6CD
                inx
                cpx #$1D
                bne LA71E
                jsr LA76F
                lda $03C8
                ora $03C9
                beq LA74F
                jsr LAA46
LA737:
                .if version==320
                jsr LAABC
                beq LA741
                lda tube.data3
                bra LA743
LA741:
                .endif
                lda ($B0),y
LA743:
                jsr LA6CD
                iny
                cpy $03C8
                bne LA737
                jsr LA76F
LA74F:
                jsr LA778
                jsr LA778
                jsr resetACIA
                lda #$01
                jsr LA78A
                plp
                jsr LA7AB
                bit $03CA
                bpl LA76E
                php
                jsr LA784
                jsr LA056
                plp
LA76E:
                rts

LA76F:
                lda $BF
                jsr LA776
                lda $BE
LA776:
                sta $BD
LA778:
                jsr LA880
                bit $C0
                bpl LA778
                stz $C0
                lda $BD
                rts

LA784:
                lda #$32
                bra LA78A

LA788:
                lda $C7
LA78A:
                ldx #$05
LA78C:
                sta cfsTimeoutCounter
LA78F:
                jsr LA880
                bit cfsTimeoutCounter
                bpl LA78F
                dex
                bne LA78C
                rts

LA79B:
                lda $03C6
                ora $03C7
                beq LA7A8
                bit $03DF
                bpl LA7AB
LA7A8:
                jsr LA059
LA7AB:
                ldy #$00
                stz $BA
                lda $03CA
                sta $03DF
                jsr mos.LEF1B
                beq LA821
                lda #$0D
                jsr OSWRCH
LA7BF:
                lda $03B2,y
                beq LA7D4
                cmp #$20
                bcc LA7CC
                cmp #$7F
                bcc LA7CE
LA7CC:
                lda #$3F
LA7CE:
                jsr OSWRCH
                iny
                bne LA7BF
LA7D4:
                lda cfsRFSFSSwitch
                beq LA7DD
                bit $BB
                bvc LA821
LA7DD:
                jsr printSpace
                iny
                cpy #$0B
                bcc LA7D4
                lda $03C6
                tax
                jsr printHexByte
                bit $03CA
                bpl LA821
                txa
                clc
                adc $03C9
                jsr printSpaceThenPrintHexByte
LA7F9:
                lda $03C8
                jsr printHexByte
                bit $BB
                bvc LA821
                ldx #$04
LA805:
                jsr printSpace
                dex
                bne LA805
                ldx #$0F
                jsr LA815
                jsr printSpace
                ldx #$13
LA815:
                ldy #$04
LA817:
                lda $03B2,x
                jsr printHexByte
                dex
                dey
                bne LA817
LA821:
                rts

LA822:
                lda cfsRFSFSSwitch
                beq LA82D
                jsr LA9CA
                jmp mos.badCommandError

LA82D:
                jsr LAA5A
                jsr LAAA0
                jsr mos.LEF1B
                beq LA821
                jsr LA923
                .text "RECORD then RETURN"
                .byte $00

LA84E:
                jsr LA880
                jsr OSRDCH
                cmp #$0D
                bne LA84E
                jmp OSNEWL

LA85B:
                ldx #$FD
LA85D:
                inc $B4,x
                bne LA864
                inx
                bne LA85D
LA864:
                rts

;-------------------------------------------------------------------------

printSpaceThenPrintHexByte:
                pha
                jsr printSpace
                pla
printHexByte:
                pha
                lsr a
                lsr a
                lsr a
                lsr a
                jsr printHexDigit
                pla
printHexDigit:
                and #$0F
                ora #'0'                     ;+'0'
                cmp #'9'+1
                bcc LA87D                    ;taken if <='9'
                adc #'A'-('9'+1)-1           ;adjust - -1 because C set
LA87D:
                jmp OSWRCH

;-------------------------------------------------------------------------

LA880:
                php
                bit $EB
                bmi LA889
                bit $FF
                bmi LA88B
LA889:
                plp
                rts

LA88B:
                jsr LA177
                jsr LA9BB
escapeError:
                lda #$7E
                jsr OSBYTE
                jsr doFollowingError
                .byte $11
                .text "Escape"
                .byte $00

;-------------------------------------------------------------------------

LA8A1:
                tya
                beq LA8B1
                jsr LA923
                .byte $0D
                .text "Loading"
                .byte $0D
                .byte $00
LA8B1:
                stz $BA                      ; :
                ldx #$FF
                lda $C1
                bne LA8C4
                jsr LA95C
                php
                ldx #$FF
                ldy #<fileError
                .cwarn (>fileError)!=(>dataError),"must be on same page"
                plp
                bne LA8DA
LA8C4:
                ldy #$04
                lda $C1
                bne LA8DA
                lda $03C6
                cmp $B4
                bne LA8D8
                lda $03C7
                cmp $B5
                beq LA8E3
LA8D8:
                ldy #<blockError
                .cwarn (>blockError)!=(>dataError),"must be on same page"
LA8DA:
                phy
                phx
                jsr LA7A8
                plx
                ply
                bra LA8F3

LA8E3:
                phx
                jsr LA79B
                jsr LA9A0
                plx
                lda $BE
                ora $BF
                beq LA96A
                ldy #<dataError
LA8F3:
                lda #>dataError
                dec $BA
                pha
                bit $EB
                bmi LA909
                txa
                and cfsRFSFSSwitch
LA900:
                bne LA909
                txa
                and #$11
                and $BB
                beq LA918
LA909:
                pla
                sta $B9
                sty $B8
                jsr LA58B
                lsr $EB
                jsr LA9B1
                bra LA955

LA918:
                tya
                clc
                adc #$03
                tay
                bcc LA922
                pla
                inc a
                pha
LA922:
                phy
LA923:
                jsr mos.LEF1B
                tay

;-------------------------------------------------------------------------
;
; Print 0-terminated message using address from stack.
;
; entry:
;
; S=[StrL; StrH] - where Str = (address of string)-1
; Y = 0 to print message; otherwise, don't print message
; 
printFollowingMessage:                       ;
                pla
                sta printMessageAddress+0
                pla
                sta printMessageAddress+1
                phy                          ;save initial Y
                tya                          ;Z=1 if Y=0
                php                          ;save Y=0 state
fetchNextChar:
                inc printMessageAddress+0
                bne +
                inc printMessageAddress+1
+
                lda (printMessageAddress)   ;fetch next char to print
                beq printingFinished        ;branch taken if last char
                plp                         ;restore Y=0 state
                php                         ;save Y=0 state
                beq fetchNextChar ;branch taken if Y=0 - i.e., skip the
                                  ;printing

                ; save printMessageAddress while calling OSASCI - not
                ; obvious why? Does this routine have to be
                ; re-entrant?
                ldy printMessageAddress+0
                phy                          
                ldy printMessageAddress+1
                jsr OSASCI                   
                sty printMessageAddress+1
                ply                          
                sty printMessageAddress+0
                
                bra fetchNextChar

printingFinished:
                plp                          ;discard Y=0 state
                inc printMessageAddress+0
                bne +
                inc printMessageAddress+1
+
                ply                          ;restore initial Y
LA955:
                jmp (printMessageAddress)

alwaysPrintFollowingMessage:
                ldy #$01
                bra printFollowingMessage

;-------------------------------------------------------------------------

LA95C:
                ldx #$FF
LA95E:
                inx
                lda $03D2,x
                bne LA96B
                txa
                beq LA96A
                lda $03B2,x
LA96A:
                rts

LA96B:
                jsr mos.isLetter
                eor $03B2,x
                bcs LA975
                and #$DF
LA975:
                beq LA95E
LA977:
                rts

LA978:
                lda $BA
                beq LA99D
                txa
                beq LA99D
                lda #$22
                bit $BB
                beq LA99D
                jsr resetACIA
                tay
                jsr printFollowingMessage
                .byte $0D
                .byte $07
                .text "Rewind tape"
                .byte $0D
                .byte $0D
                .byte $00
                rts

LA99D:
                jsr LA05D
LA9A0:
                lda $C2
                beq LA977
                jsr LA880
                lda cfsRFSFSSwitch
                beq LA9A0
                jsr LA45D
                bra LA9A0

LA9B1:
                jsr mos.LEF1B
                beq LA9BB
LA9B6:
                lda #$07
                jsr OSWRCH
LA9BB:
                .if version==320
                lda tubePresence
                beq LA9C5
                lda #$80
                jsr tubeHost.entryPoint
                .endif
LA9C5:
                ldx #$00
                jsr LAA61
LA9CA:
                php
                sei
                lda serialULARegister
                sta SERPROC+0
                stz $EA
                bra LA9D7

;-------------------------------------------------------------------------

resetACIAThenRewriteControlRegister:
                php
LA9D7:
                jsr resetACIA
                lda aciaControlRegister
                jmp mos.writeACIAControlRegister

;-------------------------------------------------------------------------

LA9E0:
                plp
                bit $FF
                bpl LA9FD
                rts

LA9E6:
                lda $E3
                asl a
                asl a
                asl a
                asl a
                sta $BB
                lda $03D1
                bra LA9FB

LA9F3:
                lda $E3
                and #$F0
                sta $BB
                lda #$06
LA9FB:
                sta $C7
LA9FD:
                cli
LA9FE:
                php
                sei
LAA00:
                bit rs423Busy
                bpl LA9E0
                lda $EA
                bmi LA9E0
                lda #$01
                sta $EA
                jsr resetACIA
                plp
                rts

;-------------------------------------------------------------------------

resetACIA:
                lda #ACIA.control.reset
                bra writeACIAControlRegister

;-------------------------------------------------------------------------

LAA16:
                lda #$30
                sta $CA
                bra LAA2F

LAA1C:
                lda #$05
                sta SERPROC+0
                ldx #$FF
LAA23:
                dex
                bne LAA23
                stz $CA
                lda #$D0
LAA2A:
                ldy #$85
                sty SERPROC+0
LAA2F:
                ora $C6
writeACIAControlRegister:
                sta ACIA+0
                rts

;-------------------------------------------------------------------------

LAA35:
                ldx $03C6
                ldy $03C7
                inx
                stx $B4
                bne LAA41
                iny
LAA41:
                sty $B5
                rts

LAA44:
                stz $C0
LAA46:
                ldy #$00
                stz $BE
                stz $BF
                rts

LAA4D:
                ldy #$FF
LAA4F:
                iny
                inx
                lda $0300,x
                sta $03D2,y
                bne LAA4F
                rts

LAA5A:
                ldy #$00
LAA5C:
                cli
                ldx #$01
                sty $C3
LAA61:
                lda #$89
                ldy $C3
                jmp OSBYTE

; Check if TAPE/ROM channel is open
; ---------------------------------
; Y=handle to check, A=status mask to use
LAA68:
                phy
                jsr LAA8D
                ply
                .if version==320
                bcs LAAC9                    ; Channel open, exit
                .elsif version>=500
                bcs LAA9F
                .endif
                cpy spoolFileHandle                    ; Not SPOOL handle
                bne LAA79
                stz spoolFileHandle                    ; Clear the SPOOL handle
                bra LAA81
LAA79:
                cpy execFileHandle                    ; Not EXEC handle
                bne LAA81
                stz execFileHandle                    ; Clear the EXEC handle
LAA81:
                jsr doFollowingError                    ; Generate error
                .byte $DE
                .text "Channel"
                brk

LAA8D:
                pha                          ; Toggle channel with CFS/RFS switch
                tya
                eor cfsRFSFSSwitch
                tay                          ; If CFS=unchanged, if RFS 1/2/3->3/0/1
                pla
                and $E2                      ; Mask with open channels bitmask
                lsr a                        ; Move 'input open if tested' into Carry
                dey                          ; Exit if testing CFS#1 or RFS#3
                beq LAA9F
                lsr a                        ; Move 'output open if tested' into Carry
                dey                          ; Exit if testing CFS#2
                beq LAA9F
                clc                          ; Otherwise, Carry=Not Open
LAA9F:
                rts

LAAA0:
                lda #$10
                bra LAA2A

                .if version==320
LAAA4:
                lda #$01
LAAA6:
                jsr LAABC
                beq LAAC9
                txa
                ldx #$B0
                ldy #$00
LAAB0:
                pha
                lda #$C0
LAAB3:
                jsr tubeHost.entryPoint
                bcc LAAB3
                pla
                jmp tubeHost.entryPoint

LAABC:
                tax
                lda $B2
                and $B3
                inc a
                beq LAAC9
                lda tubePresence
                and #$80
LAAC9:
                rts
                .endif
                
LAACA:
                ldy #$05
LAACC:
                lda ($CC),y
                bne LAAD7
                iny
                cpy #$08
                bcc LAACC
LAAD5:
                lda ($CC),y
LAAD7:
                dec a
                sta ($CC),y
                dey
                cpy #$05
                bcs LAAD5
                rts

LAAE0:
                ldy #$08
                lda #$00
LAAE4:
                ora ($CC),y
                dey
                cpy #$05
                bcs LAAE4
                tax
                rts

doFollowingError:
                sei
                pla
                sta SEIWKA+0
                pla
                sta SEIWKA+1
                stz $0100
                ldy #$00
-
                iny
                lda (SEIWKA),y
                sta $0100,y
                bne -
                jmp $0100


dataError:
                jsr doFollowingError
                .text $d8,13,"Data?",0
                bra LAB2A

fileError:
                jsr doFollowingError
                .text $db,13,"File?",0
                bra LAB2A

blockError:
                jsr doFollowingError
                .text $da,13,"Block?",0
LAB2A:
                jmp LA978

                .if version==320
;-------------------------------------------------------------------------
;
; Tube host code
;
; See http://mdfs.net/Software/Tube/M128/Host320.lst
;
; I mostly just copied JGH's comments here.

tubeHost: .block          ;tube code
                
brkHandler: .block
                .logical tubeBrkHandlerAddr
                lda #$FF
                jsr sendR4       ;send $ff via R4 to interrupt copro
                lda tube.data2   ;get ACK byte from copro
                lda #$00
                jsr sendR2A       ;send $00 via R2 to specify ERROR
                tay               ;Y=0
                lda ($FD),y       ;get error number
                jsr sendR2A       ;send error number via R2
-
                iny             ;next char
                lda ($FD),y     ;fetch error string char
                jsr sendR2A     ;send via R2
                tax             ;set N/Z as per error string char
                bne -           ;repeat until terminating $00 sent
idleStartup:
                ldx #$FF
                txs             ;clear stack
                cli
idleLoop:
                bit tube.status1 ;is there a char in R1?
                bpl LAB58        ;branch taken if no char in R1
handleOSWRCH:
                lda tube.data1  ;get char from R1
                jsr OSWRCH      ;pass to OSWRCH
LAB58:
                bit tube.status2 ;is there a command in R2?
                bpl idleLoop     ;branch taken if no command in R2
                bit tube.status1 ;is there a char in R1?
                bmi handleOSWRCH ;branch taken if char in R1
                ldx tube.data2   ;get command from R2
                stx callCommandRoutine+1 ;use as index into command
                                         ;table
callCommandRoutine:
                ; not sure why this can't be jmp
                ; (tubeHost.commandRoutines,x)? - and then the table
                ; wouldn't have to be page-aligned.
                jmp (tubeHost.commandRoutines)

                ; ???
                .dword $8000
                .here
                .endblock

; Slightly ugly aliases for inner symbol :(
idleStartup=brkHandler.idleStartup
idleLoop=brkHandler.idleLoop

codePage0:
                .logical tubeHostAddr
copyLanguage:
                jmp LAC30

copyEscapeStatus:
                jmp LADDA

; Tube transfer/claim/release
entryPoint:
                cmp #$80
                bcc dataTransfer
                cmp #$C0
                bcs claim
                ora #$40
                cmp $15
                bne done
release:
                php                          ; AB82= 08          .
                sei                          ; AB83= 78          x
                lda #$05                     ; AB84= A9 05       ).
                jsr sendR4
                jsr sendR4TubeClaimantID
                plp                          ; AB8C= 28          (
resetTubeClaim:
                lda #$80
                sta tubeClaimantID
                sta tubeNotClaimed
                rts

claim:
                asl tubeNotClaimed    ;test if Tube free
                bcs claim2         ;taken if Tube free - with C=1 and
                                   ;tube marked as claimed
                cmp tubeClaimantID
                beq done       ;taken with C=1 if already claimed
                clc            ;signal claim failure
                rts

claim2:
                sta tubeClaimantID ; store claimant ID
done:
                rts

dataTransfer:
                php
                sei
                sty tubeTransferAddr+1
                stx tubeTransferAddr+0
                jsr sendR4      ;send reason code to interrupt copro
                tax             ;save reason code
                ldy #$03        ;will send 4 bytes
                jsr sendR4TubeClaimantID ;send Tube claimant ID
-
                lda (tubeTransferAddr),y
                jsr sendR4
                dey
                bpl -

                ; disable R3 FIFO, disable R3 NMI
                ldy #tube.status1.V|tube.status1.M
                sty tube.status1

                ; disable/enable other per-transfer type flags as
                ; appropriate.
                lda dataTransferFlags,x
                sta tube.status1 ;STPVMJIQ

                lsr a           ;0STPVMJI Q
                lsr a           ;00STPVMJ I
                bcc +           ;branch taken if CoPro->I/O transfer

                ; Read R3 twice to delay and empty FIFO
                bit tube.data3
                bit tube.data3
+
                jsr sendR4      ;send value to synchronize
-
                bit tube.status4
                bvc -
                bcs LABE4       ;branch taken if I/O->CoPro transfer
                cpx #$04        ;$04 = execute in CoPro
                bne LABEC       ;taken if not execute in CoPro
LABDB:
                jsr release                    ; ABDB= 20 14 04     ..
                jsr sendR2A                    ; ABDE= 20 61 06     a.
                jmp idleStartup                ; ABE1= 4C 32 00    L2.

LABE4:
                lsr a            ;000STPVM J
                bcc LABEC        ;branch taken if J=0
                ldy #tube.status1.S|tube.status1.M
                sty tube.status1
LABEC:
                plp                          ; ABEC= 28          (
                rts                          ; ABED= 60          `

LABEE:
                ldx lastBREAKType            ;get last BREAK type
                beq LABDB   ;if soft break, release Tube, send $80 via
                            ;R2, and enter idle loop.

; The current language is not copied across the Tube on soft Break,
; only on Power-On Break and Hard Break, or when entered explicitly
; with OSBYTE 142.
                
enterNewLanguage: .proc
                lda #$FF
                jsr tubeHost.entryPoint ;claim with ID=$3f
                bcc enterNewLanguage    ;repeat until claimed
                jsr getLanguageParasiteAddr ;sort out addresses
                
transferPage:
                php
                sei

                ; initiate I/O->CoPro 256 bytes, then transfer the
                ; next 256 bytes of the language ROM.
                lda #$07
                jsr doTube
                
                ldy #$00
                stz tubeLanguageHostAddr+0
-
                lda (tubeLanguageHostAddr),y
                sta tube.data3
                nop
                nop
                nop
                iny
                bne -
                plp

                ; advance to next dest page.
                inc tubeLanguageParasiteAddr+1
                bne +
                inc tubeLanguageParasiteAddr+2
                bne +
                inc tubeLanguageParasiteAddr+3
+
                
                inc tubeLanguageHostAddr+1 ;next source page
                bit tubeLanguageHostAddr+1
                bvc transferPage ;branch taken if source page $c0 not
                                 ;reached yet

                ; copy done - execute language in parasite
                jsr getLanguageParasiteAddr
                lda #$04        ;execute in copro

                ; call Tube entry point with whatever reason code,
                ; supplying language parasite address as the parasite
                ; address.
doTube:
                ldy #>tubeLanguageParasiteAddr
                ldx #<tubeLanguageParasiteAddr
                jmp tubeHost.entryPoint
                .pend
                
LAC30:
                cli                          ; AC30= 58          X
                bcs enterNewLanguage         ; AC31= B0 C0       0@
                bne LABEE                    ; AC33= D0 B9       P9
                bra LAC8F                    ; AC35= 80 61       .a

getLanguageParasiteAddr: .proc
                lda #$80                     ; AC37= A9 80       ).
                sta tubeLanguageParasiteAddr+1 ;$xxxx80xx
                sta tubeLanguageHostAddr+1     ;$80xx
                lda #$20
                and $8006  ;test parasite address flag
                tay        ;Y=0 if $8000, Y=$20 if parasite address
                sty tubeLanguageParasiteAddr+0
                beq LAC60       ;branch taken if good to go with A=0
                                ;and Y=0

                ldx $8007       ;get copyright offset
                ; skip copyright message
-
                inx
                lda $8000,x
                bne -
                
                lda $8000+1,x
                sta tubeLanguageParasiteAddr+0
                lda $8000+2,x
                sta tubeLanguageParasiteAddr+1
                ldy $8000+3,x                  
                lda $8000+4,x
LAC60:
                sta tubeLanguageParasiteAddr+3
                sty tubeLanguageParasiteAddr+2
                rts
                .pend
                .here

codePages12:
                .logical tubeHostAddr+256

; names of the indexes here come from app note 004
commandRoutines:
                .cerror (*&$ff)!=0,"commandRoutines must be paged aligned"
                .word doRDCH    ;RDCHNO = $00
                .word doCLI     ;CLINO = $02
                .word doSBYT    ;SBYTNO = $04
                .word doBYTE    ;BYTENO = $06
                .word doWORD    ;WORDNO = $08
                .word doRDLN    ;RDLNNO = $0a
                .word doARGS     ;ARGSNO = $0c
                .word doBGET     ;BGETNO = $0e
                .word doBPUT     ;BPUTNO = $10
                .word doFIND     ;FINDNO = $12
                .word doFILE    ;FILENO = $14
                .word doGBPB     ;GBPBNO = $16

                ; Tube data transfer flags
dataTransferFlags:
                ; 0 - CoPro->I/O bytes
                ;
                ; Enable: PIRQ from R3, PIRQ from R1
                .byte tube.status1.S|tube.status1.J|tube.status1.I

                ; 1 - I/O->CoPro bytes
                ;
                ; Enable: PNMI from R3
                .byte tube.status1.S|tube.status1.M

                ; 2 - CoPro->I/O words
                ;
                ; Enable: 2-byte R3, PIRQ from R2, PIRQ from R1
                .byte tube.status1.S|tube.status1.V|tube.status1.J|tube.status1.I

                ; 3 - I/O->CoPro words
                ;
                ; Enable: 2-byte R3, PNMI from R3
                .byte tube.status1.S|tube.status1.V|tube.status1.M

                ; 4 - Execute in CoPro
                ;
                ; Disable: 2-byte R3, PNMI from R3
                .byte tube.status1.V|tube.status1.M

                ; 5 - Reserved
                ;
                ; Disable: 2-byte R3, PNMI from R3
                .byte tube.status1.V|tube.status1.M

                ; 6 - CoPro->I/O 256 bytes
                ;
                ; Enable: PIRQ from R1
                .byte tube.status1.S|tube.status1.I

                ; 7 - I/O->CoPro 256 bytes
                ;
                ; Disable: 2-byte R3, PNMI from R3
                .byte tube.status1.V|tube.status1.M

doBPUT:
                jsr recvR2      ;Receive file handle
                tay             ;Y = file handle
                jsr recvR2      ;Receive byte
                jsr OSBPUT      ;Do OSBPUT
LAC8F:
                bra sendR27FThenGoIdle

doBGET:
                jsr recvR2      ;Receive file handle
                tay             ;Y = file handle
                jsr OSBGET      ;Do OSBGET
LAC98:
                bra sendR2CAThenGoIdle

doRDCH:
                jsr OSRDCH      ;Do OSRDCH
sendR2CAThenGoIdle:
                ror a           ;set A bit 7 as per carry
                jsr sendR2A     ;send via R2
                rol a           ;restore A
                bra sendR2AThenGoIdle

doFIND: .proc
                jsr recvR2            ;Receive reason code
                beq close             ;taken if A=$00 - CLOSE#
                pha                   ;save reason code
                jsr recvR2String      ;receive file name
                pla                   ;restore reason code
                jsr OSFIND            ;call OSFIND
                bra sendR2AThenGoIdle

close:
                jsr recvR2      ;Receive file handle
                tay             ;Y = file handle
                lda #$00        ;A = $00 - CLOSE#
                jsr OSFIND      ;call OSFIND
                bra sendR27FThenGoIdle
                .pend

;-------------------------------------------------------------------------
;
; Handle a Tube OSARGS request.
;
; [Tube p24]
; 
doARGS:
                jsr recvR2                   ;receive file handle
                tay                          ;Y = file handle
                ldx #$04
                jsr recvR2N ;receive 4 bytes OSARGS data, + operation code
                jsr OSARGS  ;call OSARGS
                jsr sendR2A ;send OSARGS result

                ; send 4 bytes OSARGS data
                ldx #$03
-
                lda $00,x
                jsr sendR2A
                dex
                bpl -
                
                bra goIdle_0

;-------------------------------------------------------------------------
;
; Receive a CR-terminated string over the Tube via R2.
;
; exit:
; YX = pointer to received string (here, always $0700)
;
recvR2String: .proc
                ldx #$00
                ldy #$00        ;index
-
                jsr recvR2      ;get next string char
                sta tubeStringBuffer,y     ;store in string buffer
                iny
                beq +           ;taken if too many bytes received
                cmp #$0D
                bne -           ;taken if end of string data not reached
+
                ldy #>tubeStringBuffer
                .cerror (<tubeStringBuffer)!=0,"tubeStringBuffer must be page-aligned"
                rts                          
                .pend

;-------------------------------------------------------------------------
;
; Handle a Tube OSCLI request.
;
; [Tube p22]
;
doCLI:
                jsr recvR2String
                jsr OSCLI
sendR27FThenGoIdle:
                lda #$7F                     ; ACF3= A9 7F       ).
sendR2AThenGoIdle:
-
                bit tube.status2
                bvc -
                sta tube.data2
goIdle_0:
                bra goIdle_1

;-------------------------------------------------------------------------
;
; Handle a Tube OSGBPB request.
;
; [Tube p25]
; 
doGBPB:
                ldx #size(OSGBPBParameterBlock)
                .cerror tubeOSGBPBParameterBlock!=0,"Tube OSGBPB parameter block must be at $0000"
                jsr recvR2N     ;receive parameter block + reason code
                ldy #>tubeOSGBPBParameterBlock
                jsr OSGBPB      ;call OSGBPB
                pha             ;save OSGBPB A result

                ; Send updated OSGBPB parameter block.
                ldx #size(OSGBPBParameterBlock)-1
-
                lda tubeOSGBPBParameterBlock,x
                jsr sendR2A
                dex
                bpl -
                pla                          ;restore OSGBPB A result
                bra sendR2CAThenGoIdle       ;send OSGBPB full result

;-------------------------------------------------------------------------
;
; Handle a Tube OSFILE request.
;
; [Tube p24]
; 
doFILE: .proc
                ; receive non-name part of OSFILE parameter block
                ldx #size(OSFILEParameterBlock)-2
-
                jsr recvR2
                sta tubeOSFILEParameterBlock.addresses-1,x
                dex
                bne -
                jsr recvR2String
                stx tubeOSFILEParameterBlock+0
                sty tubeOSFILEParameterBlock+1
                ldy #>tubeOSFILEParameterBlock
                .cerror (<tubeOSFILEParameterBlock)!=0,"Tube OSFILE parameter block must be at $0000"
                jsr recvR2                   ;receive OSFILE reason code
                jsr OSFILE                   ;call OSFILE
                jsr sendR2A                  ;send OSFILE result

                ; send non-name part of updated OSFILE parameter block
                ldx #size(OSFILEParameterBlock)-2
-
                lda tubeOSFILEParameterBlock.addresses-1,x
                jsr sendR2A
                dex
                bne -
                bra goIdle_1
                .pend

;-------------------------------------------------------------------------
;
; Handle a Tube small (A<$80) OSBYTE.
;
; [Tube p22]
;
doSBYT:
                jsr recvR2XA    ;receive X and A arguments
                jsr OSBYTE
sendR2X:
                bit tube.status2
                bvc sendR2X
                stx tube.data2
goIdle_1:
                jmp idleLoop

;-------------------------------------------------------------------------
;
; Handle a Tube non-small OSBYTE.
;
; [Tube p22]
doBYTE:
                jsr recvR2XA                ;receive X and Y arguments
                tay                         ;Y = Y argument
                jsr recvR2                  ;receive A argument
                jsr OSBYTE                  ;call OSBYTE
                eor #$9D                    ;was it Fast Tube BPUT?
                beq goIdle_1      ;if it was, done.
                ror a             
                jsr sendR2A       ;send carry result
-
                bit tube.status2
                bvc -
                sty tube.data2               ;send Y result
                bra sendR2X                  ;send X result

;-------------------------------------------------------------------------
;
; Handle a Tube OSWORD request.
;
; [Tube p22]
; 
doWORD:
                jsr recvR2
                tay
                jsr LAE0F
                bmi LAD7F
LAD75:
                jsr recvR2
                sta tubeOSWORDBuffer,x
                dex
                bpl LAD75
                tya
LAD7F:
                ldx #<tubeOSWORDBuffer
                ldy #>tubeOSWORDBuffer
                jsr OSWORD
                jsr LAE0F
                bmi goIdle_1
LAD8B:
                ldy tubeOSWORDBuffer,x
LAD8E:
                bit tube.status2
                bvc LAD8E
                sty tube.data2
                dex
                bpl LAD8B
LAD99:
                bra goIdle_1

;-------------------------------------------------------------------------

doRDLN:
                ldx #$04                     ; AD9B= A2 04       ".
LAD9D:
                jsr recvR2                    ; AD9D= 20 A1 06     !.
                sta $00,x                    ; ADA0= 95 00       ..
                dex                          ; ADA2= CA          J
                bpl LAD9D                    ; ADA3= 10 F8       .x
                inx                          ; ADA5= E8          h
                txa                          ; ADA6= 8A          .
                tay                          ; ADA7= A8          (
                jsr OSWORD                   ; ADA8= 20 F1 FF     q.
                bcc LADB2                    ; ADAB= 90 05       ..
                lda #$FF                     ; ADAD= A9 FF       ).
                jmp sendR2AThenGoIdle                    ; ADAF= 4C 90 05    L..

LADB2:
                ldx #$00                     ; ADB2= A2 00       ".
                lda #$7F                     ; ADB4= A9 7F       ).
                jsr sendR2A                    ; ADB6= 20 61 06     a.
LADB9:
                lda $0700,x                  ; ADB9= BD 00 07    =..
                jsr sendR2A                    ; ADBC= 20 61 06     a.
                inx                          ; ADBF= E8          h
                cmp #$0D                     ; ADC0= C9 0D       I.
                bne LADB9                    ; ADC2= D0 F5       Pu
                bra LAD99                    ; ADC4= 80 D3       .S

sendR2A:                          ;adc6/0661
                bit tube.status2                   ; ADC6= 2C E2 FE    ,b~
                bvc sendR2A                    ; ADC9= 50 FB       P{
                sta tube.data2                   ; ADCB= 8D E3 FE    .c~
                rts                          ; ADCE= 60          `
                
sendR4TubeClaimantID:              ;adcf
                lda tubeClaimantID ;get Tube ID
sendR4:                          ;add1/066c
                bit tube.status4 ;check R4 status
                bvc sendR4       ;branch taken if FIFO full
                sta tube.data4   ;put byte in FIFO
                rts

LADDA:
                lda $FF                      ; ADDA= A5 FF       %.
                sec                          ; ADDC= 38          8
                ror a                        ; ADDD= 6A          j
                bra LADEF                    ; ADDE= 80 0F       ..

eventHandler:
                pha                          ; ADE0= 48          H
                lda #$00                     ; ADE1= A9 00       ).
                jsr LADEF                    ; ADE3= 20 8A 06     ..
                tya                          ; ADE6= 98          .
                jsr LADEF                    ; ADE7= 20 8A 06     ..
                txa                          ; ADEA= 8A          .
                jsr LADEF                    ; ADEB= 20 8A 06     ..
                pla                          ; ADEE= 68          h
LADEF:
                bit tube.status1                   ; ADEF= 2C E0 FE    ,`~
                bvc LADEF                    ; ADF2= 50 FB       P{
                sta tube.data1                   ; ADF4= 8D E1 FE    .a~
                rts                          ; ADF7= 60          `

;-------------------------------------------------------------------------
;
; Receive multiple bytes via R2: some kind of parameter block,
; followed by the reason code. Store the first N-1 received in zero
; page, starting at $00.
;
; entry:
;
; X = number of bytes to receive, minus 1
;
; exit:
;
; ?$00, ?$01... = first N-1 bytes received
;
; A = final byte received
;
; X = 0
;
recvR2N:
                jsr recvR2
                sta $ff,x
                dex
                bne recvR2N
                bra recvR2

;-------------------------------------------------------------------------
;
; Receive 2 bytes via R2.
;
; exit:
;
; X = first byte received
;
; A = second byte received
; 
recvR2XA:
                jsr recvR2
                tax

;-------------------------------------------------------------------------
;
; Receive 1 byte via R2.
;
; exit:
;
; A = byte received
; 
recvR2:
                bit tube.status2
                bpl recvR2
                lda tube.data2
                rts

;-------------------------------------------------------------------------

LAE0F:
                bit tube.status2                   ; AE0F= 2C E2 FE    ,b~
                bpl LAE0F                    ; AE12= 10 FB       .{
                ldx tube.data2                   ; AE14= AE E3 FE    .c~
                dex                          ; AE17= CA          J
                rts                          ; AE18= 60          `
                .here
                .bend

;-------------------------------------------------------------------------
                .endif
;-------------------------------------------------------------------------

LAE19:
                php                          ; AE19= 08          .
                phy                          ; AE1A= 5A          Z
                phx                          ; AE1B= DA          Z
                pha                          ; AE1C= 48          H
                cmp #romServiceCallUnrecognisedCommand
                beq handleUnrecognisedCommand
                cmp #romServiceCallUnrecognisedOSBYTE
                beq handleUnrecognisedOSBYTE
                cmp #romServiceCallLanguageChange
                beq handleLanguageChange
LAE29:
                pla                          ; AE29= 68          h
                plx                          ; AE2A= FA          z
                ply                          ; AE2B= 7A          z
                plp                          ; AE2C= 28          (
                rts                          ; AE2D= 60          `

handleUnrecognisedCommand:
                jsr LB832                    ; AE2E= 20 32 B8     28
                cmp #$0B                     ; AE31= C9 0B       I.
                bne LAE29                    ; AE33= D0 F4       Pt
                pla                          ; AE35= 68          h
                plx                          ; AE36= FA          z
                lda #$8E                     ; AE37= A9 8E       ).
                jsr OSBYTE                   ; AE39= 20 F4 FF     t.
LAE3C:
                ldx #$04                     ; AE3C= A2 04       ".
LAE3E:
                lda INSV-1,x                  ; AE3E= BD 29 02    =).
                cmp LAE93-1,x                ; AE41= DD 92 AE    ]..
                bne LAE49                    ; AE44= D0 03       P.
                dex                          ; AE46= CA          J
                bne LAE3E                    ; AE47= D0 F5       Pu
LAE49:
                rts                          ; AE49= 60          `
                
handleUnrecognisedOSBYTE:
                phy                          ; AE4A= 5A          Z
                ply                          ; AE4B= 7A          z
                bne LAE29                    ; AE4C= D0 DB       P[
                lda $EF                      ; AE4E= A5 EF       %o
                cmp #$60                     ; AE50= C9 60       I`
                bne LAE29                    ; AE52= D0 D5       PU

                ; handle OSBYTE $60
osbyte60:
                pla                          ; AE54= 68          h
                phy                          ; AE55= 5A          Z
                sei                          ; AE56= 78          x
                lda $F0                      ; AE57= A5 F0       %p
                bmi LAE6C                    ; AE59= 30 11       0.
                lsr a                        ; AE5B= 4A          J
                bne LAE66                    ; AE5C= D0 08       P.
                lda #$11                     ; AE5E= A9 11       ).
                sta $76                      ; AE60= 85 76       .v
                ror $74                      ; AE62= 66 74       ft
                bra LAE29                    ; AE64= 80 C3       .C

LAE66:
                
                stz $78                      ; AE66= 64 78       dx
                ror $77                      ; AE68= 66 77       fw
                
LAE6A:
                bra LAE29                    ; AE6A= 80 BD       .=

LAE6C:
                lsr a                        ; AE6C= 4A          J
                bcc handleLanguageChange
                stz $75                      ; AE6F= 64 75       du
                jsr LAE3C                    ; AE71= 20 3C AE     <.
                beq LAE29                    ; AE74= F0 B3       p3
                ldx #$04                     ; AE76= A2 04       ".
LAE78:
                lda INSV-1,x                  ; AE78= BD 29 02    =).
                sta oldINSV-1,x                    ; AE7B= 95 6F       .o
                lda LAE93-1,x                ; AE7D= BD 92 AE    =..
                sta INSV-1,x                  ; AE80= 9D 29 02    .).
                dex                          ; AE83= CA          J
                bne LAE78                    ; AE84= D0 F2       Pr
                ldx #$06                     ; AE86= A2 06       ".
LAE88:
                lda LAE97-1,x                  ; AE88= BD 96 AE    =..
                sta ExtendedVectorAddress(INSV)-1,x
                dex                          ; AE8E= CA          J
                bne LAE88                    ; AE8F= D0 F7       Pw
                bra LAE6A                    ; AE91= 80 D7       .W

LAE93:
                .word mos.E_INSV
                .word mos.E_REMV
LAE97:
                .word LAED4
                .byte terminalROM
                .word LAF13
                .byte terminalROM
                
handleLanguageChange:
                sei                          ; AE9D= 78          x
                jsr LAE3C                    ; AE9E= 20 3C AE     <.
                bne LAE6A                    ; AEA1= D0 C7       PG
                ldx #$06                     ; AEA3= A2 06       ".
LAEA5:
                lda ExtendedVectorAddress(INSV)-1,x;extendedVectorSpace+insvIndex*3-1,x
                cmp LAE97-1,x                  ; AEA8= DD 96 AE    ]..
                bne LAE6A                    ; AEAB= D0 BD       P=
                dex                          ; AEAD= CA          J
                bne LAEA5                    ; AEAE= D0 F5       Pu
                ldx #$04                     ; AEB0= A2 04       ".
LAEB2:
                lda oldINSV-1,x                    ; AEB2= B5 6F       5o
                sta INSV-1,x                  ; AEB4= 9D 29 02    .).
                dex                          ; AEB7= CA          J
                bne LAEB2                    ; AEB8= D0 F8       Px
                lda #$E6                     ; AEBA= A9 E6       )f
                jsr osbyteX00Y00                    ; AEBC= 20 23 B8     #8
                lda #$CB                     ; AEBF= A9 CB       )K
                ldx #$09                     ; AEC1= A2 09       ".
                jsr osbyteY00                    ; AEC3= 20 25 B8     %8
                jsr LB11A                    ; AEC6= 20 1A B1     .1
                inc a                        ; AEC9= 1A          .
LAECA:
                jsr osbyteX00Y00                    ; AECA= 20 23 B8     #8
                dec a                        ; AECD= 3A          :
                cmp #$01                     ; AECE= C9 01       I.
                bne LAECA                    ; AED0= D0 F8       Px
                bra LAE6A                    ; AED2= 80 96       ..

LAED4:
                php                          ; AED4= 08          .
                sei                          ; AED5= 78          x
                cpx #$01                     ; AED6= E0 01       `.
                bne LAF0B                    ; AED8= D0 31       P1
                bit $77                      ; AEDA= 24 77       $w
                bpl LAEEC                    ; AEDC= 10 0E       ..
                cmp #$13                     ; AEDE= C9 13       I.
                beq LAEE7                    ; AEE0= F0 05       p.
                cmp #$11                     ; AEE2= C9 11       I.
                bne LAEEC                    ; AEE4= D0 06       P.
                clc                          ; AEE6= 18          .
LAEE7:
                ror $78                      ; AEE7= 66 78       fx
LAEE9:
                plp                          ; AEE9= 28          (
                clc                          ; AEEA= 18          .
                rts                          ; AEEB= 60          `

LAEEC:
                bit $74                      ; AEEC= 24 74       $t
                bpl LAF0B                    ; AEEE= 10 1B       ..
                pha                          ; AEF0= 48          H
                sec                          ; AEF1= 38          8
                jsr LAF0F                    ; AEF2= 20 0F AF     ./
                tya                          ; AEF5= 98          .
                bne LAF08                    ; AEF6= D0 10       P.
                cpx #$20                     ; AEF8= E0 20       `
                bcs LAF08                    ; AEFA= B0 0C       0.
                lda #$13                     ; AEFC= A9 13       ).
                cpx #$10                     ; AEFE= E0 10       `.
                bcc LAF06                    ; AF00= 90 04       ..
                cmp $76                      ; AF02= C5 76       Ev
                beq LAF08                    ; AF04= F0 02       p.
LAF06:
                sta $75                      ; AF06= 85 75       .u
LAF08:
                pla                          ; AF08= 68          h
                ldx #$01                     ; AF09= A2 01       ".
LAF0B:
                plp                          ; AF0B= 28          (
                jmp ($0070)                  ; AF0C= 6C 70 00    lp.

LAF0F:
                clv                          ; AF0F= B8          8
                jmp (CNPV)                  ; AF10= 6C 2E 02    l..

LAF13:
                php                          ; AF13= 08          .
                sei                          ; AF14= 78          x
                cpx #$01                     ; AF15= E0 01       `.
                bne LAF37                    ; AF17= D0 1E       P.
                bit $74                      ; AF19= 24 74       $t
                bpl LAF33                    ; AF1B= 10 16       ..
                clc                          ; AF1D= 18          .
                jsr LAF0F                    ; AF1E= 20 0F AF     ./
                cpy #$00                     ; AF21= C0 00       @.
                bne LAF31                    ; AF23= D0 0C       P.
                cpx #$20                     ; AF25= E0 20       `
                bcs LAF31                    ; AF27= B0 08       0.
                lda #$11                     ; AF29= A9 11       ).
                cmp $76                      ; AF2B= C5 76       Ev
                beq LAF31                    ; AF2D= F0 02       p.
                sta $75                      ; AF2F= 85 75       .u
LAF31:
                ldx #$01                     ; AF31= A2 01       ".
LAF33:
                plp                          ; AF33= 28          (
                jmp ($0072)                  ; AF34= 6C 72 00    lr.

LAF37:
                cpx #$02                     ; AF37= E0 02       `.
                bne LAF33                    ; AF39= D0 F8       Px
                lda $75                      ; AF3B= A5 75       %u
                tay                          ; AF3D= A8          (
                beq LAF48                    ; AF3E= F0 08       p.
                bvs LAEE9                    ; AF40= 70 A7       p'
                stz $75                      ; AF42= 64 75       du
                sta $76                      ; AF44= 85 76       .v
                bra LAEE9                    ; AF46= 80 A1       .!

LAF48:
                lda $78                      ; AF48= A5 78       %x
                bpl LAF33                    ; AF4A= 10 E7       .g
                plp                          ; AF4C= 28          (
                sec                          ; AF4D= 38          8
LAF4E:
                rts                          ; AF4E= 60          `

;-------------------------------------------------------------------------

terminalBRKHandler:
                lda #$DA                     
                jsr osbyteX00Y00             ;Set VDU queue length to 0
                jsr disableESCAPE
                ldy #$00
                lda (errPtr),y
                bne LAF63
                stz $20
                lda #$16
                sta $6F
LAF63:
                lda #13
-
                jsr OSASCI
                iny
                lda (errPtr),y
                bne -
                jsr OSNEWL
                sec
                ror $19
                lda $1A
                bne LAFF4
terminalLanguageEntryPoint:
                dec a
                bne LAF4E
                lda #$01
                sta $6F
LAF7E:
                sei
                ldx #$FE
                txs
                lda #<terminalBRKHandler
                sta BRKV+0
                lda #>terminalBRKHandler
                sta BRKV+1
                lda #<terminalINDnHandler
                sta IND1V+0
                lda #>terminalINDnHandler
                sta IND1V+1
                lda #<terminalINDnHandler
                sta IND2V+0
                lda #>terminalINDnHandler
                sta IND2V+1

                ; Clear zero page
                ldx #$6E
-
                stz $00,x
                dex
                bpl -
                
                dec $21                      ; AFA7= C6 21       F!
                dec $34                      ; AFA9= C6 34       F4
                dec $36                      ; AFAB= C6 36       F6
                cli                          ; AFAD= 58          X
                lda #$0B                     ; AFAE= A9 0B       ).
                jsr LB690                    ; AFB0= 20 90 B6     .6
                lda #$87
                jsr OSBYTE                   ;Read screen mode
                tya                          ;A = screen mode
                jsr reinitDisplayMode
                ldy #$FF
-
                iny
                lda initOSBYTEAs,y
                beq LAFF4
                ldx initOSBYTEXs,y
                phy
                jsr osbyteY00
                ply
                bra -

;-------------------------------------------------------------------------

initOSBYTEAs:
                .byte $CB ;OSBYTE 203 (&CB) Read/write RS423 input buffer [MasRef D.2-64]
                .byte $60 ;OSBYTE 96 (&60) ???
                .byte $60 ;OSBYTE 96 (&60) ???
                .byte $60 ;OSBYTE 96 (&60) ???
                .byte $0F ;OSBYTE 15 (&0F) Flush buffer [MasRef D.2-24]
                .byte $0F ;OSBYTE 15 (&0F) Flush buffer [MasRef D.2-24]
                .byte $dd ;OSBYTE 221 (&DD) Read/write interpretation of input values 192-207 [MasRef D.2-73]
                .byte $de ;OSBYTE 222 (&DE) Read/write interpretation of input values 208-223 [MasRef D.2-73]
                .byte $df ;OSBYTE 223 (&DF) Read/write interpretation of input values 224-239 [MasRef D.2-73]
                .byte $e0 ;OSBYTE 224 (&E0) Read/write interpretation of input values 240-255 [MasRef D.2-73]
                .byte $e1 ;OSBYTE 225 (&E1) Read/write soft key interpretation [MasRef D.2-74]
                .byte $E2 ;OSBYTE 226 (&E2) Read/write SHIFT+soft key interpretation [MasRef D.2-74]
                .byte $E3 ;OSBYTE 227 (&E3) Read/write CTRL+soft key interpretation [MasRef D.2-74]
                .byte $e4 ;OSBYTE 228 (&E4) Read/write SHIFT+CTRL+soft key interpretation [MasRef D.2-74]
                .byte $e5 ;OSBYTE 229 (&E5) Read/write ESCAPE key status [MasRef D.2-75]
                .byte $04 ;OSBYTE 4 (&04) Enable/disable cursor editing [MasRef D.2-19]
                .byte $7e ;OSBYTE 126 (&7E) Acknowledge escape condition [MasRef D.2-37]
                .byte $e6 ;OSBYTE 230 (&E6) Read/write ESCAPE effects [MasRef D.2-75]
                .byte $02 ;OSBYTE 2 (&02) Specify input stream [MasRef D.2-18]
                
initOSBYTEXs:
                .byte $00
                .byte $01
                .byte $03
                .byte $ff
                .byte $01
                .byte $02
                .byte $c0
                .byte $d0
                .byte $e0
                .byte $f0
                .byte $01
                .byte $90
                .byte $a0
                .byte $a0
                .byte $01
                .byte $00
                .byte $00
                .byte $01
                .byte $02

;-------------------------------------------------------------------------

LAFF4:
                ldx #$FE
                txs
                sec
                ror $1A
                stz $1D
                jsr LB004
                jsr LB004
                bra LB030

LB004:
                jsr LB041                    ; B004= 20 41 B0     A0
                ldy #$01                     ; B007= A0 01        .
                sta ($1B),y                  ; B009= 91 1B       ..
                iny                          ; B00B= C8          H
                txa                          ; B00C= 8A          .
                sta ($1B),y                  ; B00D= 91 1B       ..
                iny                          ; B00F= C8          H
                tya                          ; B010= 98          .
                sta ($1B),y                  ; B011= 91 1B       ..
                asl a                        ; B013= 0A          .
                sta ($1B)                    ; B014= 92 1B       ..
                rts                          ; B016= 60          `

LB017:
                php                          ; B017= 08          .
                pha                          ; B018= 48          H
                phx                          ; B019= DA          Z
                phy                          ; B01A= 5A          Z
                tsx                          ; B01B= BA          :
                inx                          ; B01C= E8          h
                txa                          ; B01D= 8A          .
                eor #$FF                     ; B01E= 49 FF       I.
                sta ($1B)                    ; B020= 92 1B       ..
                tay                          ; B022= A8          (
LB023:
                pla                          ; B023= 68          h
                sta ($1B),y                  ; B024= 91 1B       ..
                dey                          ; B026= 88          .
                bne LB023                    ; B027= D0 FA       Pz
                lda #$20                     ; B029= A9 20       )
                sta $1E                      ; B02B= 85 1E       ..
                jsr LB041                    ; B02D= 20 41 B0     A0
LB030:
                lda ($1B)                    ; B030= B2 1B       2.
                tax                          ; B032= AA          *
                ldy #$00                     ; B033= A0 00        .
LB035:
                iny                          ; B035= C8          H
                lda ($1B),y                  ; B036= B1 1B       1.
                pha                          ; B038= 48          H
                dex                          ; B039= CA          J
                bne LB035                    ; B03A= D0 F9       Py
                ply                          ; B03C= 7A          z
                plx                          ; B03D= FA          z
                pla                          ; B03E= 68          h
                plp                          ; B03F= 28          (
                rts                          ; B040= 60          `

LB041:
                ldy #$04                     ; B041= A0 04        .
                sty $1C                      ; B043= 84 1C       ..
                ldy #$20                     ; B045= A0 20
                ldx #$50                     ; B047= A2 50       "P
                lda #$B6                     ; B049= A9 B6       )6
                lsr $1D                      ; B04B= 46 1D       F.
                bcs LB05B                    ; B04D= B0 0C       0.
                inc $1D                      ; B04F= E6 1D       f.
                ldy #$04                     ; B051= A0 04        .
                sty $1C                      ; B053= 84 1C       ..
                ldy #$00                     ; B055= A0 00        .
                ldx #$5D                     ; B057= A2 5D       "]
                lda #$B0                     ; B059= A9 B0       )0
LB05B:
                sty $1B                      ; B05B= 84 1B       ..
                rts                          ; B05D= 60          `

LB05E:
                jsr LB063                    ; B05E= 20 63 B0     c0
                bra LB05E                    ; B061= 80 FB       .{

LB063:
                bit $20                      ; B063= 24 20       $
                bpl LB06C                    ; B065= 10 05       ..
                jsr LB096                    ; B067= 20 96 B0     .0
                bcc LB083                    ; B06A= 90 17       ..
LB06C:
                bra LB017                    ; B06C= 80 A9       .)

LB06E:
                cmp #$0A                     ; B06E= C9 0A       I.
                bcc LB081                    ; B070= 90 0F       ..
                ldx #$00                     ; B072= A2 00       ".
LB074:
                inx                          ; B074= E8          h
                sbc #$0A                     ; B075= E9 0A       i.
                cmp #$0A                     ; B077= C9 0A       I.
                bcs LB074                    ; B079= B0 F9       0y
                pha                          ; B07B= 48          H
                txa                          ; B07C= 8A          .
                jsr LB06E                    ; B07D= 20 6E B0     n0
                pla                          ; B080= 68          h
LB081:
                ora #$30                     ; B081= 09 30       .0
LB083:
                pha                          ; B083= 48          H
                phy                          ; B084= 5A          Z
                tay                          ; B085= A8          (
                lda #$8A                     ; B086= A9 8A       ).
                ldx #$02                     ; B088= A2 02       ".
                jsr OSBYTE                   ; B08A= 20 F4 FF     t.
                ply                          ; B08D= 7A          z
                pla                          ; B08E= 68          h
                bcc LB0B0                    ; B08F= 90 1F       ..
                jsr LB017                    ; B091= 20 17 B0     .0
                bra LB083                    ; B094= 80 ED       .m

LB096:
                ldy $6F                      ; B096= A4 6F       $o
                beq LB0B1                    ; B098= F0 17       p.
                inc $6F                      ; B09A= E6 6F       fo
                lda LB14C-1,y                ; B09C= B9 4B B1    9K1
                bpl LB0AE                    ; B09F= 10 0D       ..
                stz $6F                      ; B0A1= 64 6F       do
                pha                          ; B0A3= 48          H
                lda #$D9                     ; B0A4= A9 D9       )Y
                jsr osbyteX00Y00                    ; B0A6= 20 23 B8     #8
                pla                          ; B0A9= 68          h
                ldy #$18                     ; B0AA= A0 18        .
                sty $1F                      ; B0AC= 84 1F       ..
LB0AE:
                asl a                        ; B0AE= 0A          .
                lsr a                        ; B0AF= 4A          J
LB0B0:
                rts                          ; B0B0= 60          `

LB0B1:
                lda #$81                     ; B0B1= A9 81       ).
                jsr osbyteX00Y00                    ; B0B3= 20 23 B8     #8
                txa                          ; B0B6= 8A          .
                bcs LB0B0                    ; B0B7= B0 F7       0w
                bpl LB0B0                    ; B0B9= 10 F5       .u
                cmp #$E0                     ; B0BB= C9 E0       I`
                bcs LB0B0                    ; B0BD= B0 F1       0q
                jsr LB0C4                    ; B0BF= 20 C4 B0     D0
                sec                          ; B0C2= 38          8
LB0C3:
                rts                          ; B0C3= 60          `

LB0C4:
                cmp #$99                     ; B0C4= C9 99       I.
                beq LB12A                    ; B0C6= F0 62       pb
                and #$0F                     ; B0C8= 29 0F       ).
                beq LB0E9                    ; B0CA= F0 1D       p.
                cmp #$02                     ; B0CC= C9 02       I.
                bcc LB0EE                    ; B0CE= 90 1E       ..
                beq LB0C3                    ; B0D0= F0 F1       pq
                cmp #$04                     ; B0D2= C9 04       I.
                bcc LB116                    ; B0D4= 90 40       .@
                beq LB11A                    ; B0D6= F0 42       pB
                cmp #$06                     ; B0D8= C9 06       I.
                bcc LB10A                    ; B0DA= 90 2E       ..
                beq LB0F5                    ; B0DC= F0 17       p.
                cmp #$08                     ; B0DE= C9 08       I.
                bcc LB0C3                    ; B0E0= 90 E1       .a
                beq LB11E                    ; B0E2= F0 3A       p:
                cmp #$09                     ; B0E4= C9 09       I.
                beq LB12E                    ; B0E6= F0 46       pF
                rts                          ; B0E8= 60          `

LB0E9:
                lda #$0C                     ; B0E9= A9 0C       ).
LB0EB:
                jmp OSWRCH                   ; B0EB= 4C EE FF    Ln.

LB0EE:
                lda #$16                     ; B0EE= A9 16       ).
                sta $6F                      ; B0F0= 85 6F       .o
                stz $20                      ; B0F2= 64 20       d
                rts                          ; B0F4= 60          `

LB0F5:
                ldx #$10                     ; B0F5= A2 10       ".
                jsr LB101                    ; B0F7= 20 01 B1     .1
                and #$10                     ; B0FA= 29 10       ).
                bne LB113                    ; B0FC= D0 15       P.
LB0FE:
                jmp LB7B6                    ; B0FE= 4C B6 B7    L67

LB101:
                lda #$EC                     ; B101= A9 EC       )l
                ldy #$FF                     ; B103= A0 FF        .
                jsr OSBYTE                   ; B105= 20 F4 FF     t.
                txa                          ; B108= 8A          .
                rts                          ; B109= 60          `

LB10A:
                ldx #$40                     ; B10A= A2 40       "@
                jsr LB101                    ; B10C= 20 01 B1     .1
                and #$40                     ; B10F= 29 40       )@
                beq LB0FE                    ; B111= F0 EB       pk
LB113:
                jmp LB7E2                    ; B113= 4C E2 B7    Lb7

LB116:
                lda #$02                     ; B116= A9 02       ).
                bra LB0EB                    ; B118= 80 D1       .Q

LB11A:
                lda #$03                     ; B11A= A9 03       ).
                bra LB0EB                    ; B11C= 80 CD       .M

LB11E:
                lda #$FF                     ; B11E= A9 FF       ).
                eor $21                      ; B120= 45 21       E!
                sta $21                      ; B122= 85 21       .!
                sta $20                      ; B124= 85 20       .
                bne LB0FE                    ; B126= D0 D6       PV
                bra LB113                    ; B128= 80 E9       .i

LB12A:
                ldx #$0C                     ; B12A= A2 0C       ".
                bra LB130                    ; B12C= 80 02       ..

LB12E:
                ldx #$AF                     ; B12E= A2 AF       "/
LB130:
                phx                          ; B130= DA          Z
                ldx #$60                     ; B131= A2 60       "`
                jsr LB82A                    ; B133= 20 2A B8     *8
                plx                          ; B136= FA          z
LB137:
                phx                          ; B137= DA          Z
                lda #$13                     ; B138= A9 13       ).
                jsr OSBYTE                   ; B13A= 20 F4 FF     t.
                plx                          ; B13D= FA          z
                dex                          ; B13E= CA          J
                bne LB137                    ; B13F= D0 F6       Pv
                ldx #$00                     ; B141= A2 00       ".
                jsr LB82A                    ; B143= 20 2A B8     *8
LB146:
                jsr LB198                    ; B146= 20 98 B1     .1
                bcc LB146                    ; B149= 90 FB       .{
                rts                          ; B14B= 60          `

LB14C:
                .byte $1B                    ; B14C= 1B          .
                lsr $4B2A,x                  ; B14D= 5E 2A 4B    ^*K
                eor $59                      ; B150= 45 59       EY
                and $217C,y                  ; B152= 39 7C 21    9|!
                jmp ($1B59,x)                ; B155= 7C 59 1B    |Y.

                .byte $5C                    ; B158= 5C          \
                .byte $54                    ; B159= 54          T
                eor $52                      ; B15A= 45 52       ER
                eor $4E49                    ; B15C= 4D 49 4E    MIN
                eor ($4C,x)                  ; B15F= 41 4C       AL
                ora $3D0A                    ; B161= 0D 0A 3D    ..=
                .byte $1B                    ; B164= 1B          .
;BNE LB187        :\ B165= D0 20       P
;BVS LB11A        :\ B167= 70 B1       p1
                .byte $D0
LB166:
                jsr LB170
                bcs LB1C4                    ; B169= B0 59       0Y
                cmp #$1B                     ; B16B= C9 1B       I.
                bne LB166                    ; B16D= D0 F7       Pw
                rts                          ; B16F= 60          `

LB170:
                jsr LB17A                    ; B170= 20 7A B1     z1
                cmp #$7F                     ; B173= C9 7F       I.
                beq LB170                    ; B175= F0 F9       py
                cmp #$20                     ; B177= C9 20       I
                rts                          ; B179= 60          `

LB17A:
                phx                          ; B17A= DA          Z
                phy                          ; B17B= 5A          Z
LB17C:
                jsr LB189                    ; B17C= 20 89 B1     .1
                bcs LB184                    ; B17F= B0 03       0.
                ply                          ; B181= 7A          z
                plx                          ; B182= FA          z
                rts                          ; B183= 60          `

LB184:
                jsr LB017                    ; B184= 20 17 B0     .0
LB187:
                bra LB17C                    ; B187= 80 F3       .s

LB189:
                bit $20                      ; B189= 24 20       $
                bmi LB190                    ; B18B= 30 03       0.
                jmp LB096                    ; B18D= 4C 96 B0    L.0

LB190:
                bit $25                      ; B190= 24 25       $%
                bmi LB1E0                    ; B192= 30 4C       0L
                bit $23                      ; B194= 24 23       $#
                bmi LB1A3                    ; B196= 30 0B       0.
LB198:
                lda #$91                     ; B198= A9 91       ).
                ldx #$01                     ; B19A= A2 01       ".
                jsr OSBYTE                   ; B19C= 20 F4 FF     t.
                tya                          ; B19F= 98          .
                and $22                      ; B1A0= 25 22       %"
LB1A2:
                rts                          ; B1A2= 60          `

LB1A3:
                jsr LB198                    ; B1A3= 20 98 B1     .1
                bcs LB1A2                    ; B1A6= B0 FA       0z
                jsr LB1D0                    ; B1A8= 20 D0 B1     P1
                bcc LB201                    ; B1AB= 90 54       .T
                asl a                        ; B1AD= 0A          .
                asl a                        ; B1AE= 0A          .
                asl a                        ; B1AF= 0A          .
                asl a                        ; B1B0= 0A          .
                sta $24                      ; B1B1= 85 24       .$
LB1B3:
                jsr LB198                    ; B1B3= 20 98 B1     .1
                bcc LB1BD                    ; B1B6= 90 05       ..
                jsr LB017                    ; B1B8= 20 17 B0     .0
                bra LB1B3                    ; B1BB= 80 F6       .v

LB1BD:
                jsr LB1D0                    ; B1BD= 20 D0 B1     P1
                bcc LB1B3                    ; B1C0= 90 F1       .q
                ora $24                      ; B1C2= 05 24       .$
LB1C4:
                clc                          ; B1C4= 18          .
                rts                          ; B1C5= 60          `

LB1C6:
                jsr LB166                    ; B1C6= 20 66 B1     f1
                bcc LB1D0                    ; B1C9= 90 05       ..
                plx                          ; B1CB= FA          z
                plx                          ; B1CC= FA          z
                jmp LB389                    ; B1CD= 4C 89 B3    L.3

LB1D0:
                cmp #$3A                     ; B1D0= C9 3A       I:
                bcs LB1D7                    ; B1D2= B0 03       0.
                sbc #$2F                     ; B1D4= E9 2F       i/
                rts                          ; B1D6= 60          `

LB1D7:
                sbc #$37                     ; B1D7= E9 37       i7
                cmp #$10                     ; B1D9= C9 10       I.
                bcs LB1C4                    ; B1DB= B0 E7       0g
                cmp #$0A                     ; B1DD= C9 0A       I.
LB1DF:
                rts                          ; B1DF= 60          `

LB1E0:
                stz $26                      ; B1E0= 64 26       d&
                jsr LB198                    ; B1E2= 20 98 B1     .1
                bcs LB1DF                    ; B1E5= B0 F8       0x
                cmp #$7F                     ; B1E7= C9 7F       I.
                bcs LB1DF                    ; B1E9= B0 F4       0t
                cmp #$20                     ; B1EB= C9 20       I
                bcs LB203                    ; B1ED= B0 14       0.
                bit $27                      ; B1EF= 24 27       $'
                bmi LB201                    ; B1F1= 30 0E       0.
                cmp #$07                     ; B1F3= C9 07       I.
                bcc LB201                    ; B1F5= 90 0A       ..
                beq LB240                    ; B1F7= F0 47       pG
                cmp #$0B                     ; B1F9= C9 0B       I.
                bcc LB240                    ; B1FB= 90 43       .C
                cmp #$0D                     ; B1FD= C9 0D       I.
                beq LB240                    ; B1FF= F0 3F       p?
LB201:
                sec                          ; B201= 38          8
                rts                          ; B202= 60          `

LB203:
                stz $27                      ; B203= 64 27       d'
                cmp #$7C                     ; B205= C9 7C       I|
                bne LB23E                    ; B207= D0 35       P5
LB209:
                jsr LB198                    ; B209= 20 98 B1     .1
                bcc LB213                    ; B20C= 90 05       ..
                jsr LB017                    ; B20E= 20 17 B0     .0
                bra LB209                    ; B211= 80 F6       .v

LB213:
                cmp #$20                     ; B213= C9 20       I
                bcc LB242                    ; B215= 90 2B       .+
                cmp #$21                     ; B217= C9 21       I!
                bne LB22F                    ; B219= D0 14       P.
                lda #$80                     ; B21B= A9 80       ).
                sta $26                      ; B21D= 85 26       .&
LB21F:
                jsr LB198                    ; B21F= 20 98 B1     .1
                bcc LB229                    ; B222= 90 05       ..
                jsr LB017                    ; B224= 20 17 B0     .0
                bra LB21F                    ; B227= 80 F6       .v

LB229:
                cmp #$20                     ; B229= C9 20       I
                bcc LB21F                    ; B22B= 90 F2       .r
                bra LB203                    ; B22D= 80 D4       .T

LB22F:
                cmp #$3F                     ; B22F= C9 3F       I?
                bne LB236                    ; B231= D0 03       P.
                lda #$7F                     ; B233= A9 7F       ).
                clc                          ; B235= 18          .
LB236:
                bcc LB23E                    ; B236= 90 06       ..
                cmp #$7C                     ; B238= C9 7C       I|
                beq LB23E                    ; B23A= F0 02       p.
                and #$9F                     ; B23C= 29 9F       ).
LB23E:
                ora $26                      ; B23E= 05 26       .&
LB240:
                clc                          ; B240= 18          .
                rts                          ; B241= 60          `

LB242:
                sec                          ; B242= 38          8
                ror $27                      ; B243= 66 27       f'
                sec                          ; B245= 38          8
                rts                          ; B246= 60          `

LB247:
                lda #$00                     ; B247= A9 00       ).
                sta $F2                      ; B249= 85 F2       .r
                lda #$05                     ; B24B= A9 05       ).
                sta $F3                      ; B24D= 85 F3       .s
                ldy #$00                     ; B24F= A0 00        .
LB251:
                jsr LB17A                    ; B251= 20 7A B1     z1
                ldx $1F                      ; B254= A6 1F       &.
                beq LB296                    ; B256= F0 3E       p>
                stz $2B                      ; B258= 64 2B       d+
                cmp #$1B                     ; B25A= C9 1B       I.
                bne LB262                    ; B25C= D0 04       P.
                ldy #$00                     ; B25E= A0 00        .
                bra LB266                    ; B260= 80 04       ..

LB262:
                cmp #$0D                     ; B262= C9 0D       I.
                bne LB273                    ; B264= D0 0D       P.
LB266:
                lda #$0D                     ; B266= A9 0D       ).
                sta ($F2),y                  ; B268= 91 F2       .r
                bit $2B                      ; B26A= 24 2B       $+
                bmi LB271                    ; B26C= 30 03       0.
                jsr OSASCI                   ; B26E= 20 E3 FF     c.
LB271:
                clc                          ; B271= 18          .
                rts                          ; B272= 60          `

LB273:
                cmp #$7F                     ; B273= C9 7F       I.
                bne LB27E                    ; B275= D0 07       P.
                cpy #$00                     ; B277= C0 00       @.
                beq LB251                    ; B279= F0 D6       pV
                dey                          ; B27B= 88          .
                bra LB291                    ; B27C= 80 13       ..

LB27E:
                cmp #$7F                     ; B27E= C9 7F       I.
                bcs LB251                    ; B280= B0 CF       0O
                cmp #$20                     ; B282= C9 20       I
                bcc LB251                    ; B284= 90 CB       .K
                cpy #$FF                     ; B286= C0 FF       @.
                bcs LB251                    ; B288= B0 C7       0G
                sta ($F2),y                  ; B28A= 91 F2       .r
                iny                          ; B28C= C8          H
                bit $2B                      ; B28D= 24 2B       $+
                bmi LB251                    ; B28F= 30 C0       0@
LB291:
                jsr LB728                    ; B291= 20 28 B7     (7
                bra LB251                    ; B294= 80 BB       .;

LB296:
                cmp #$1B                     ; B296= C9 1B       I.
                bne LB27E                    ; B298= D0 E4       Pd
                jsr LB166                    ; B29A= 20 66 B1     f1
                cmp #$5C                     ; B29D= C9 5C       I\
                beq LB266                    ; B29F= F0 C5       pE
                sec                          ; B2A1= 38          8
                rts                          ; B2A2= 60          `

LB2A3:
                ldx #$19                     ; B2A3= A2 19       ".
LB2A5:
                dex                          ; B2A5= CA          J
                stz $00,x                    ; B2A6= 74 00       t.
                bne LB2A5                    ; B2A8= D0 FB       P{
LB2AA:
                stz $3A                      ; B2AA= 64 3A       d:
                stz $3B                      ; B2AC= 64 3B       d;
LB2AE:
                jsr LB166                    ; B2AE= 20 66 B1     f1
                bcs LB2E0                    ; B2B1= B0 2D       0-
                jsr LB8AD                    ; B2B3= 20 AD B8     -8
                bcc LB2E5                    ; B2B6= 90 2D       .-
                pha                          ; B2B8= 48          H
                lda $3A                      ; B2B9= A5 3A       %:
                sta $02,x                    ; B2BB= 95 02       ..
                lda $3B                      ; B2BD= A5 3B       %;
                sta $03,x                    ; B2BF= 95 03       ..
                pla                          ; B2C1= 68          h
                cmp #$40                     ; B2C2= C9 40       I@
                bcs LB2F5                    ; B2C4= B0 2F       0/
                cmp #$30                     ; B2C6= C9 30       I0
                bcc LB2D7                    ; B2C8= 90 0D       ..
                cmp #$3C                     ; B2CA= C9 3C       I<
                bcs LB2E3                    ; B2CC= B0 15       0.
                inc $00                      ; B2CE= E6 00       f.
                inx                          ; B2D0= E8          h
                inx                          ; B2D1= E8          h
                inx                          ; B2D2= E8          h
                cpx #$18                     ; B2D3= E0 18       `.
                bcc LB2AA                    ; B2D5= 90 D3       .S
LB2D7:
                cmp #$40                     ; B2D7= C9 40       I@
                bcs LB2F5                    ; B2D9= B0 1A       0.
                jsr LB166                    ; B2DB= 20 66 B1     f1
                bcc LB2D7                    ; B2DE= 90 F7       .w
LB2E0:
                jmp LB389                    ; B2E0= 4C 89 B3    L.3

LB2E3:
                sta $01,x                    ; B2E3= 95 01       ..
LB2E5:
                lda $00                      ; B2E5= A5 00       %.
                bne LB2AE                    ; B2E7= D0 C5       PE
                inc $00                      ; B2E9= E6 00       f.
                bra LB2AE                    ; B2EB= 80 C1       .A

LB2ED:
                lda #$01                     ; B2ED= A9 01       ).
                sta $02                      ; B2EF= 85 02       ..
                stz $01                      ; B2F1= 64 01       d.
                stz $03                      ; B2F3= 64 03       d.
LB2F5:
                rts                          ; B2F5= 60          `

LB2F6:
                lda #$03                     ; B2F6= A9 03       ).
                bra LB2FC                    ; B2F8= 80 02       ..

LB2FA:
                lda #$00                     ; B2FA= A9 00       ).
LB2FC:
                phx                          ; B2FC= DA          Z
                tax                          ; B2FD= AA          *
                lda $01,x                    ; B2FE= B5 01       5.
                cmp #$01                     ; B300= C9 01       I.
                lda $03,x                    ; B302= B5 03       5.
                beq LB307                    ; B304= F0 01       p.
                sec                          ; B306= 38          8
LB307:
                lda $02,x                    ; B307= B5 02       5.
                plx                          ; B309= FA          z
                and #$FF                     ; B30A= 29 FF       ).
                rts                          ; B30C= 60          `

LB30D:
                pla                          ; B30D= 68          h
                sta $28                      ; B30E= 85 28       .(
                pla                          ; B310= 68          h
                sta $29                      ; B311= 85 29       .)
                lda $01                      ; B313= A5 01       %.
                bne LB338                    ; B315= D0 21       P!
                lda $02                      ; B317= A5 02       %.
                ora $03                      ; B319= 05 03       ..
                bne LB31F                    ; B31B= D0 02       P.
                inc $02                      ; B31D= E6 02       f.
LB31F:
                lda $02                      ; B31F= A5 02       %.
                bne LB325                    ; B321= D0 02       P.
                dec $03                      ; B323= C6 03       F.
LB325:
                dec $02                      ; B325= C6 02       F.
                bne LB32D                    ; B327= D0 04       P.
                lda $03                      ; B329= A5 03       %.
                beq LB332                    ; B32B= F0 05       p.
LB32D:
                jsr LB332                    ; B32D= 20 32 B3     23
                bra LB31F                    ; B330= 80 ED       .m

LB332:
                lda $29                      ; B332= A5 29       %)
                pha                          ; B334= 48          H
                lda $28                      ; B335= A5 28       %(
                pha                          ; B337= 48          H
LB338:
                rts                          ; B338= 60          `

LB339:
                dec $1E                      ; B339= C6 1E       F.
                bne LB340                    ; B33B= D0 03       P.
                jsr LB017                    ; B33D= 20 17 B0     .0
LB340:
                lda $6F                      ; B340= A5 6F       %o
                bne LB348                    ; B342= D0 04       P.
                lda $21                      ; B344= A5 21       %!
                sta $20                      ; B346= 85 20       .
LB348:
                rts                          ; B348= 60          `

LB349:
                jsr LB34E                    ; B349= 20 4E B3     N3
                bra LB349                    ; B34C= 80 FB       .{

LB34E:
                jsr LB339                    ; B34E= 20 39 B3     93
                jsr LB170                    ; B351= 20 70 B1     p1
LB354:
                cmp #$20                     ; B354= C9 20       I
                bcc LB361                    ; B356= 90 09       ..
                jmp LB728                    ; B358= 4C 28 B7    L(7

LB35B:
                jmp LB46C                    ; B35B= 4C 6C B4    Ll4

LB35E:
                jmp LB493                    ; B35E= 4C 93 B4    L.4

LB361:
                pha                          ; B361= 48          H
                jsr LB2ED                    ; B362= 20 ED B2     m2
                pla                          ; B365= 68          h
                cmp #$07                     ; B366= C9 07       I.
                bcc LB3BB                    ; B368= 90 51       .Q
                beq LB3E9                    ; B36A= F0 7D       p}
                cmp #$09                     ; B36C= C9 09       I.
                bcc LB35B                    ; B36E= 90 EB       .k
                beq LB35E                    ; B370= F0 EC       pl
                cmp #$0B                     ; B372= C9 0B       I.
                bcc LB3EE                    ; B374= 90 78       .x
                cmp #$0D                     ; B376= C9 0D       I.
                beq LB3E9                    ; B378= F0 6F       po
                cmp #$1B                     ; B37A= C9 1B       I.
                bne LB3BB                    ; B37C= D0 3D       P=
LB37E:
                ldx $6F                      ; B37E= A6 6F       &o
                bne LB386                    ; B380= D0 04       P.
                bit $2D                      ; B382= 24 2D       $-
                bmi LB3BB                    ; B384= 30 35       05
LB386:
                jsr LB166                    ; B386= 20 66 B1     f1
LB389:
                cmp #$1B                     ; B389= C9 1B       I.
                beq LB37E                    ; B38B= F0 F1       pq
                cmp #$25                     ; B38D= C9 25       I%
                beq LB401                    ; B38F= F0 70       pp
                cmp #$28                     ; B391= C9 28       I(
                beq LB404                    ; B393= F0 6F       po
                cmp #$44                     ; B395= C9 44       ID
                beq LB3EE                    ; B397= F0 55       pU
                cmp #$45                     ; B399= C9 45       IE
                beq LB3EB                    ; B39B= F0 4E       pN
                cmp #$4D                     ; B39D= C9 4D       IM
                beq LB3E7                    ; B39F= F0 46       pF
                cmp #$50                     ; B3A1= C9 50       IP
                beq LB3C5                    ; B3A3= F0 20       p
                cmp #$5B                     ; B3A5= C9 5B       I[
                beq LB407                    ; B3A7= F0 5E       p^
                cmp #$5D                     ; B3A9= C9 5D       I]
                stz $2B                      ; B3AB= 64 2B       d+
                beq LB3F6                    ; B3AD= F0 47       pG
                cmp #$5E                     ; B3AF= C9 5E       I^
                beq LB3F3                    ; B3B1= F0 40       p@
                cmp #$5F                     ; B3B3= C9 5F       I_
                beq LB3BC                    ; B3B5= F0 05       p.
                cmp #$63                     ; B3B7= C9 63       Ic
                beq LB3FE                    ; B3B9= F0 43       pC
LB3BB:
                rts                          ; B3BB= 60          `

LB3BC:
                jsr LB247                    ; B3BC= 20 47 B2     G2
                bcs LB389                    ; B3BF= B0 C8       0H
LB3C1:
                sec                          ; B3C1= 38          8
                jmp (IND2V)                  ; B3C2= 6C 32 02    l2.

LB3C5:
                sec                          ; B3C5= 38          8
                ror $2B                      ; B3C6= 66 2B       f+
                jsr LB247                    ; B3C8= 20 47 B2     G2
                bcs LB389                    ; B3CB= B0 BC       0<
                ldx $1F                      ; B3CD= A6 1F       &.
                stz $1F                      ; B3CF= 64 1F       d.
                beq LB3E4                    ; B3D1= F0 11       p.
                ldy #$00                     ; B3D3= A0 00        .
                jsr LB89E                    ; B3D5= 20 9E B8     .8
                beq LB3BB                    ; B3D8= F0 E1       pa
                stx $6F                      ; B3DA= 86 6F       .o
                cmp #$2A                     ; B3DC= C9 2A       I*
                beq LB3FB                    ; B3DE= F0 1B       p.
                cmp #$21                     ; B3E0= C9 21       I!
                beq LB3C1                    ; B3E2= F0 DD       p]
LB3E4:
                jmp LB4F2                    ; B3E4= 4C F2 B4    Lr4

LB3E7:
                lda #$0B                     ; B3E7= A9 0B       ).
LB3E9:
                bra LB3F0                    ; B3E9= 80 05       ..

LB3EB:
                jmp OSNEWL                   ; B3EB= 4C E7 FF    Lg.

LB3EE:
                lda #$0A                     ; B3EE= A9 0A       ).
LB3F0:
                jmp OSWRCH                   ; B3F0= 4C EE FF    Ln.

LB3F3:
                sec                          ; B3F3= 38          8
                ror $2B                      ; B3F4= 66 2B       f+
LB3F6:
                jsr LB247                    ; B3F6= 20 47 B2     G2
                bcs LB389                    ; B3F9= B0 8E       0.
LB3FB:
                jmp LB61F                    ; B3FB= 4C 1F B6    L.6

LB3FE:
                jmp LAF7E                    ; B3FE= 4C 7E AF    L~/

LB401:
                jmp LB640                    ; B401= 4C 40 B6    L@6

LB404:
                jmp LB68B                    ; B404= 4C 8B B6    L.6

LB407:
                jsr LB2A3                    ; B407= 20 A3 B2     #2
                ldx #$0E                     ; B40A= A2 0E       ".
LB40C:
                cmp LB41E-1,x                ; B40C= DD 1D B4    ].4
                beq LB418                    ; B40F= F0 07       p.
                dex                          ; B411= CA          J
                bne LB40C                    ; B412= D0 F8       Px
                sec                          ; B414= 38          8
                jmp (IND1V)                  ; B415= 6C 30 02    l0.

LB418:
                txa                          ; B418= 8A          .
                asl a                        ; B419= 0A          .
                tax                          ; B41A= AA          *
                jmp (LB42C-2,x)                ; B41B= 7C 2A B4    |*4
LB41E:
                .byte $41,$42   ; B41E= 41 42       AB
                .byte $43       ; B420= 43          C
                .byte $44       ; B421= 44          D
                .byte $48       ; B422= 48          H
                .byte $4a       ; B423= 4A          J
                .byte $4B       ; B424= 4B          K
                .byte $53       ; B425= 53          S
                .byte $58       ; B426= 58          X
                .byte $68       ; B427= 68          h
                .byte $6C       ; B428= 6C
                .byte $6E       ; B429= 6E
                .byte $66
                .byte $63
LB42C:
                .word LB4C5
                .word LB485
                .word LB493
                .word LB46C
                .word LB4A7
                .word LB5FD
                .word LB60D
                .word LB720
                .word LB5E1
                .word LB6B1
                .word LB6AD
                .word LB5A9
                .word LB4A7
                .word LB4D1
LB448:
                jsr LB44D
                bra LB448
LB44D:
                jsr LB339                    ; B44D= 20 39 B3     93
                jsr LB17A                    ; B450= 20 7A B1     z1
                cmp #$1B                     ; B453= C9 1B       I.
                bne LB466                    ; B455= D0 0F       P.
                lda #$DA                     ; B457= A9 DA       )Z
                ldy #$FF                     ; B459= A0 FF        .
                ldx #$00                     ; B45B= A2 00       ".
                jsr OSBYTE                   ; B45D= 20 F4 FF     t.
                lda #$1B                     ; B460= A9 1B       ).
                cpx #$00                     ; B462= E0 00       `.
                beq LB469                    ; B464= F0 03       p.
LB466:
                jmp OSWRCH                   ; B466= 4C EE FF    Ln.

LB469:
                jmp LB37E                    ; B469= 4C 7E B3    L~3

LB46C:
                lda #$08                     ; B46C= A9 08       ).
                sta $2C                      ; B46E= 85 2C       .,
                jsr LB30D                    ; B470= 20 0D B3     .3
                jsr LB821                    ; B473= 20 21 B8     !8
                txa                          ; B476= 8A          .
                bne LB480                    ; B477= D0 07       P.
                bit $34                      ; B479= 24 34       $4
                bpl LB4E2                    ; B47B= 10 65       .e
LB47D:
                tya                          ; B47D= 98          .
LB47E:
                beq LB4E2                    ; B47E= F0 62       pb
LB480:
                lda $2C                      ; B480= A5 2C       %,
LB482:
                jmp OSWRCH                   ; B482= 4C EE FF    Ln.

LB485:
                lda #$0A                     ; B485= A9 0A       ).
                sta $2C                      ; B487= 85 2C       .,
                jsr LB30D                    ; B489= 20 0D B3     .3
                jsr LB821                    ; B48C= 20 21 B8     !8
LB48F:
                cpy zterm.numRowsMinusOne                      ; B48F= C4 39       D9
                bra LB47E                    ; B491= 80 EB       .k

LB493:
                lda #$09                     ; B493= A9 09       ).
                sta $2C                      ; B495= 85 2C       .,
                jsr LB30D                    ; B497= 20 0D B3     .3
                jsr LB821                    ; B49A= 20 21 B8     !8
                cpx zterm.numColumnsMinusOne
LB49F:
                bcc LB480                    ; B49F= 90 DF       ._
                lda $34                      ; B4A1= A5 34       %4
                beq LB4E2                    ; B4A3= F0 3D       p=
                bra LB48F                    ; B4A5= 80 E8       .h

LB4A7:
                jsr LB2FA                    ; B4A7= 20 FA B2     z2
                bcs LB4E2                    ; B4AA= B0 36       06
                tay                          ; B4AC= A8          (
                beq LB4B0                    ; B4AD= F0 01       p.
                dey                          ; B4AF= 88          .
LB4B0:
                jsr LB2F6                    ; B4B0= 20 F6 B2     v2
                bcs LB4E2                    ; B4B3= B0 2D       0-
                tax                          ; B4B5= AA          *
                beq LB4B9                    ; B4B6= F0 01       p.
                dex                          ; B4B8= CA          J
LB4B9:
                lda #$1F                     ; B4B9= A9 1F       ).
                jsr OSWRCH                   ; B4BB= 20 EE FF     n.
                txa                          ; B4BE= 8A          .
                jsr OSWRCH                   ; B4BF= 20 EE FF     n.
                tya                          ; B4C2= 98          .
                bra LB482                    ; B4C3= 80 BD       .=

LB4C5:
                lda #$0B                     ; B4C5= A9 0B       ).
                sta $2C                      ; B4C7= 85 2C       .,
                jsr LB30D                    ; B4C9= 20 0D B3     .3
                jsr LB821                    ; B4CC= 20 21 B8     !8
                bra LB47D                    ; B4CF= 80 AC       .,

LB4D1:
                jsr LB2FA                    ; B4D1= 20 FA B2     z2
                bne LB4E2                    ; B4D4= D0 0C       P.
                tay                          ; B4D6= A8          (
LB4D7:
                lda #$1B                     ; B4D7= A9 1B       ).
LB4D9:
                iny                          ; B4D9= C8          H
                jsr LB083                    ; B4DA= 20 83 B0     .0
                lda LB4E2,y                  ; B4DD= B9 E2 B4    9b4
                bne LB4D9                    ; B4E0= D0 F7       Pw
LB4E2:
                rts                          ; B4E2= 60          `

                .byte $5B                    ; B4E3= 5B          [
                .byte $3e,$35,$63            ; B4E4= 3E 35 63    >5c
                .byte $00                    ; B4E7= 00          .
                .byte $5B                    ; B4E8= 5B          [
                .byte $30,$6e                ; B4E9= 30 6E       0n
                .byte $00                    ; B4EB= 00          .
                .byte $5B                    ; B4EC= 5B          [
                .byte $33                    ; B4ED= 33          3
                .byte $6e,$00,$5b            ; B4EE= 6E 00 5B    n.[
                .byte $00                    ; B4F1= 00          .
LB4F2:
                jsr LB830                    ; B4F2= 20 30 B8     08
                bcs LB547                    ; B4F5= B0 50       0P
                cmp #$07                     ; B4F7= C9 07       I.
                bcs LB518                    ; B4F9= B0 1D       0.
                pha                          ; B4FB= 48          H
                jsr LB832                    ; B4FC= 20 32 B8     28
                stz $2E                      ; B4FF= 64 2E       d.
                cmp #$0A                     ; B501= C9 0A       I.
                beq LB50B                    ; B503= F0 06       p.
                dec $2E                      ; B505= C6 2E       F.
                cmp #$09                     ; B507= C9 09       I.
                bne LB546                    ; B509= D0 3B       P;
LB50B:
                ply                          ; B50B= 7A          z
                cpy #$06                     ; B50C= C0 06       @.
                bne LB515                    ; B50E= D0 05       P.
                lda $2E                      ; B510= A5 2E       %.
                sta $34                      ; B512= 85 34       .4
LB514:
                rts                          ; B514= 60          `

LB515:
                jmp LB6E0                    ; B515= 4C E0 B6    L`6

LB518:
                cmp #$08                     ; B518= C9 08       I.
                beq LB53A                    ; B51A= F0 1E       p.
                bcs LB54A                    ; B51C= B0 2C       0,
LB51E:
                jsr LB89E                    ; B51E= 20 9E B8     .8
                beq LB514                    ; B521= F0 F1       pq
                jsr LB565                    ; B523= 20 65 B5     e5
                jsr LB89E                    ; B526= 20 9E B8     .8
                beq LB535                    ; B529= F0 0A       p.
                cmp #$2C                     ; B52B= C9 2C       I,
                bne LB547                    ; B52D= D0 18       P.
                iny                          ; B52F= C8          H
                jsr LB535                    ; B530= 20 35 B5     55
                bra LB51E                    ; B533= 80 E9       .i

LB535:
                lda $3A                      ; B535= A5 3A       %:
                jmp OSWRCH                   ; B537= 4C EE FF    Ln.

LB53A:
                jsr LB89E                    ; B53A= 20 9E B8     .8
                jsr LB565                    ; B53D= 20 65 B5     e5
                bcs LB547                    ; B540= B0 05       0.
                lda $3A                      ; B542= A5 3A       %:
                bra reinitDisplayMode                    ; B544= 80 33       .3

LB546:
                pla                          ; B546= 68          h
LB547:
                jmp LB7B3                    ; B547= 4C B3 B7    L37

LB54A:
                ldy #$00                     ; B54A= A0 00        .
                cmp #$0B                     ; B54C= C9 0B       I.
                bcc LB547                    ; B54E= 90 F7       .w
                beq LB561                    ; B550= F0 0F       p.
                iny                          ; B552= C8          H
                cmp #$0E                     ; B553= C9 0E       I.
                beq LB561                    ; B555= F0 0A       p.
                bcs LB547                    ; B557= B0 EE       0n
                ldy #$04                     ; B559= A0 04        .
                cmp #$0C                     ; B55B= C9 0C       I.
                beq LB561                    ; B55D= F0 02       p.
                ldy #$05                     ; B55F= A0 05        .
LB561:
                tya                          ; B561= 98          .
                jmp LB64F                    ; B562= 4C 4F B6    LO6

LB565:
                jsr LB8A9                    ; B565= 20 A9 B8     )8
                bcs LB573                    ; B568= B0 09       0.
LB56A:
                iny                          ; B56A= C8          H
                lda ($F2),y                  ; B56B= B1 F2       1r
                jsr LB8AD                    ; B56D= 20 AD B8     -8
                bcc LB56A                    ; B570= 90 F8       .x
                clc                          ; B572= 18          .
LB573:
                rts                          ; B573= 60          `

                jsr LB2FA                    ; B574= 20 FA B2     z2
                bcs LB547                    ; B577= B0 CE       0N
reinitDisplayMode:
                tay              ;Y = screen mode
                and #$7F         ;mask off shadow bit (unnecessarily!)
                cmp #$08
                bcs LB547                    ;branch taken if mode>=8
                tax                          ;X = mode number
                lda screenDimensionsForMode,x                  ;
                lsr a       ;A = width -1; C = height flag (1=32 rows,
                            ;0=25 rows)
                ldx #$1F                     ;assume 32 rows
                bcs +                        ;taken if 32 rows
                ldx #$18                     ;25 rows
+
                stx zterm.numRowsMinusOne    ;store rows
                sta zterm.numColumnsMinusOne ;store columns
                inc a                        ;compute column count
                sta zterm.numColumns

                ; re-select mode
                lda #22
                jsr OSWRCH
                tya
                jsr OSWRCH
                
                asl a
                cmp #$0E                     ;C=1 if Mode 7
                ror $30                      ;?$30 bit 7 set if Mode 7
                rts

screenDimensionsForMode:
                .byte 79<<1|1 ;mode 0 - 80 columns, 32 rows
                .byte 39<<1|1 ;mode 1 - 40 columns, 32 rows
                .byte 19<<1|1 ;mode 2 - 20 columns, 32 rows
                .byte 79<<1|0 ;mode 3 - 80 columns, 25 rows
                .byte 39<<1|1 ;mode 4 - 40 columns, 32 rows
                .byte 19<<1|1 ;mode 5 - 20 columns, 32 rows
                .byte 39<<1|0 ;mode 6 - 40 columns, 25 rows
                .byte 39<<1|0 ;mode 7 - 40 columns, 25 rows

LB5A9:
                jsr LB2FA                    ; B5A9= 20 FA B2
                bcs LB606                    ; B5AC= B0 58
                cmp #$05                     ; B5AE= C9 05       I.
                beq LB5D4                    ; B5B0= F0 22       p"
                cmp #$06                     ; B5B2= C9 06       I.
LB5B4:
                bne LB606                    ; B5B4= D0 50       PP
                jsr LB821                    ; B5B6= 20 21 B8     !8
                inx                          ; B5B9= E8          h
                phx                          ; B5BA= DA          Z
                iny                          ; B5BB= C8          H
                phy                          ; B5BC= 5A          Z
                ldy #$0D                     ; B5BD= A0 0D        .
                jsr LB4D7                    ; B5BF= 20 D7 B4     W4
                pla                          ; B5C2= 68          h
                jsr LB06E                    ; B5C3= 20 6E B0     n0
                lda #$3B                     ; B5C6= A9 3B       );
                jsr LB083                    ; B5C8= 20 83 B0     .0
                pla                          ; B5CB= 68          h
                jsr LB06E                    ; B5CC= 20 6E B0     n0
                lda #$52                     ; B5CF= A9 52       )R
                jmp LB083                    ; B5D1= 4C 83 B0    L.0

LB5D4:
                ldy #$05                     ; B5D4= A0 05        .
                bit $19                      ; B5D6= 24 19       $.
                stz $19                      ; B5D8= 64 19       d.
                bpl LB5DE                    ; B5DA= 10 02       ..
                ldy #$09                     ; B5DC= A0 09        .
LB5DE:
                jmp LB4D7                    ; B5DE= 4C D7 B4    LW4

LB5E1:
                jsr LB821                    ; B5E1= 20 21 B8     !8
                phx                          ; B5E4= DA          Z
                phy                          ; B5E5= 5A          Z
                lda #$20                     ; B5E6= A9 20       )
                sta $2C                      ; B5E8= 85 2C       .,
                jsr LB5F2                    ; B5EA= 20 F2 B5     r5
                ply                          ; B5ED= 7A          z
                plx                          ; B5EE= FA          z
                jmp LB4B9                    ; B5EF= 4C B9 B4    L94

LB5F2:
                jsr LB30D                    ; B5F2= 20 0D B3     .3
                jsr LB821                    ; B5F5= 20 21 B8     !8
                cpx zterm.numColumns                      ; B5F8= E4 38       d8
                jmp LB49F                    ; B5FA= 4C 9F B4    L.4

LB5FD:
                jsr LB2FA                    ; B5FD= 20 FA B2     z2
                bcs LB606                    ; B600= B0 04       0.
                cmp #$03                     ; B602= C9 03       I.
                bcc LB618                    ; B604= 90 12       ..
LB606:
                rts                          ; B606= 60          `

LB607:
                .byte $0F                    ; B607= 0F          .
                .byte $13                    ; B608= 13          .
                inc a                        ; B609= 1A          .
                brk                          ; B60A= 00          .
                tsb $0B                      ; B60B= 04 0B       ..
LB60D:
                jsr LB2FA                    ; B60D= 20 FA B2     z2
                bcs LB606                    ; B610= B0 F4       0t
                cmp #$03                     ; B612= C9 03       I.
                bcs LB606                    ; B614= B0 F0       0p
                adc #$03                     ; B616= 69 03       i.
LB618:
                tax                          ; B618= AA          *
                lda LB607,x                  ; B619= BD 07 B6    =.6
                jmp LB7E6                    ; B61C= 4C E6 B7    Lf7

LB61F:
                lda $20                      ; B61F= A5 20       %
                and $36                      ; B621= 25 36       %6
                bpl LB628                    ; B623= 10 03       ..
                jmp LB7B3                    ; B625= 4C B3 B7    L37

LB628:
                lda #$E5                     ; B628= A9 E5       )e
                jsr osbyteX00Y00                    ; B62A= 20 23 B8     #8
                ldx #$00                     ; B62D= A2 00       ".
                ldy #$05                     ; B62F= A0 05        .
                jsr OSCLI                   ; B631= 20 F7 FF     w.
disableESCAPE:
                lda #$E5
                ldx #$01
                jsr osbyteY00                ;disable ESCAPE key
                lda #$7E
                jmp OSBYTE                   ;acknowledge ESCAPE

LB640:
                jsr LB1C6                    ; B640= 20 C6 B1     F1
                cmp #$07                     ; B643= C9 07       I.
                bcc LB64F                    ; B645= 90 08       ..
                bne LB606                    ; B647= D0 BD       P=
                jsr LB166                    ; B649= 20 66 B1     f1
                jmp LB354                    ; B64C= 4C 54 B3    LT3

LB64F:
                sta $2A                      ; B64F= 85 2A       .*
                stz $25                      ; B651= 64 25       d%
                stz $23                      ; B653= 64 23       d#
                ldx #$FE                     ; B655= A2 FE       "~
                txs                          ; B657= 9A          .
                inx                          ; B658= E8          h
                stx $22                      ; B659= 86 22       ."
                lda $2A                      ; B65B= A5 2A       %*
                cmp #$06                     ; B65D= C9 06       I.
                bcc LB665                    ; B65F= 90 04       ..
                ror $23                      ; B661= 66 23       f#
                bra LB66D                    ; B663= 80 08       ..

LB665:
                cmp #$04                     ; B665= C9 04       I.
                bcc LB67B                    ; B667= 90 12       ..
                beq LB671                    ; B669= F0 06       p.
                ror $25                      ; B66B= 66 25       f%
LB66D:
                stz $27                      ; B66D= 64 27       d'
                lsr $22                      ; B66F= 46 22       F"
LB671:
                ror $30                      ; B671= 66 30       f0
                lda #$21                     ; B673= A9 21       )!
                jsr LB7E6                    ; B675= 20 E6 B7     f7
                jmp LB448                    ; B678= 4C 48 B4    LH4

LB67B:
                stz $30                      ; B67B= 64 30       d0
                lsr a                        ; B67D= 4A          J
                ror $2D                      ; B67E= 66 2D       f-
                lsr a                        ; B680= 4A          J
                ror $22                      ; B681= 66 22       f"
                lda #$1E                     ; B683= A9 1E       ).
                jsr LB7E6                    ; B685= 20 E6 B7     f7
                jmp LB349                    ; B688= 4C 49 B3    LI3

LB68B:
                jsr LB1C6                    ; B68B= 20 C6 B1     F1
                bcc LB69B                    ; B68E= 90 0B       ..
LB690:
                lsr a                        ; B690= 4A          J
                and #$04                     ; B691= 29 04       ).
                bne LB69C                    ; B693= D0 07       P.
                ror a                        ; B695= 6A          j
                lsr a                        ; B696= 4A          J
                adc #$40                     ; B697= 69 40       i@
                sta $33                      ; B699= 85 33       .3
LB69B:
                rts                          ; B69B= 60          `

LB69C:
                stz $33                      ; B69C= 64 33       d3
                ldx #$60                     ; B69E= A2 60       "`
                ldy #$23                     ; B6A0= A0 23        #
                bcc LB6A8                    ; B6A2= 90 04       ..
                phx                          ; B6A4= DA          Z
                phy                          ; B6A5= 5A          Z
                plx                          ; B6A6= FA          z
                ply                          ; B6A7= 7A          z
LB6A8:
                stx $31                      ; B6A8= 86 31       .1
                sty $32                      ; B6AA= 84 32       .2
                rts                          ; B6AC= 60          `

LB6AD:
                lda #$00                     ; B6AD= A9 00       ).
                bra LB6B3                    ; B6AF= 80 02       ..
                
LB6B1:
                lda #$FF                     ; B6B1= A9 FF       ).
LB6B3:
                sta $2E                      ; B6B3= 85 2E       ..
                stz $2F                      ; B6B5= 64 2F       d/
LB6B7:
                ldx $2F                      ; B6B7= A6 2F       &/
                inx                          ; B6B9= E8          h
                inx                          ; B6BA= E8          h
                inx                          ; B6BB= E8          h
                cpx #$1B                     ; B6BC= E0 1B       `.
                beq LB6DF                    ; B6BE= F0 1F       p.
                stx $2F                      ; B6C0= 86 2F       ./
                jsr LB6C7                    ; B6C2= 20 C7 B6     G6
                bra LB6B7                    ; B6C5= 80 F0       .p

LB6C7:
                ldy $FFFF,x                  ; B6C7= BC FF FF    <..
                lda $00,x                    ; B6CA= B5 00       5.
                bne LB6DF                    ; B6CC= D0 11       P.
                lda LFFFE,x                  ; B6CE= BD FE FF    =~.
                cmp #$3E                     ; B6D1= C9 3E       I>
                bcc LB6DF                    ; B6D3= 90 0A       ..
                beq LB6E0                    ; B6D5= F0 09       p.
                lda $2E                      ; B6D7= A5 2E       %.
                cpy #$07                     ; B6D9= C0 07       @.
                bne LB6DF                    ; B6DB= D0 02       P.
                sta $34                      ; B6DD= 85 34       .4
LB6DF:
                rts                          ; B6DF= 60          `

LB6E0:
                lda $2E                      ; B6E0= A5 2E       %.
                cpy #$01                     ; B6E2= C0 01       @.
                bcs LB6ED                    ; B6E4= B0 07       0.
                inc a                        ; B6E6= 1A          .
                asl a                        ; B6E7= 0A          .
                tax                          ; B6E8= AA          *
                lda #$04                     ; B6E9= A9 04       ).
                bra LB6F6                    ; B6EB= 80 09       ..

LB6ED:
                bne LB6F9                    ; B6ED= D0 0A       P.
                tax                          ; B6EF= AA          *
                beq LB6F4                    ; B6F0= F0 02       p.
                ldx #$21                     ; B6F2= A2 21       "!
LB6F4:
                lda #$CB                     ; B6F4= A9 CB       )K
LB6F6:
                jmp osbyteY00                    ; B6F6= 4C 25 B8    L%8

LB6F9:
                cpy #$03                     ; B6F9= C0 03       @.
                bcs LB707                    ; B6FB= B0 0A       0.
                bit $20                      ; B6FD= 24 20       $
                bpl LB704                    ; B6FF= 10 03       ..
                tay                          ; B701= A8          (
                beq LB6DF                    ; B702= F0 DB       p[
LB704:
                sta $36                      ; B704= 85 36       .6
LB706:
                rts                          ; B706= 60          `

LB707:
                bne LB712                    ; B707= D0 09       P.
                rol a                        ; B709= 2A          *
                lda #$00                     ; B70A= A9 00       ).
LB70C:
                rol a                        ; B70C= 2A          *
                tax                          ; B70D= AA          *
                lda #$60                     ; B70E= A9 60       )`
                bra LB6F6                    ; B710= 80 E4       .d

LB712:
                cpy #$05                     ; B712= C0 05       @.
                bcs LB71B                    ; B714= B0 05       0.
                rol a                        ; B716= 2A          *
                lda #$01                     ; B717= A9 01       ).
                bra LB70C                    ; B719= 80 F1       .q

LB71B:
                bne LB706                    ; B71B= D0 E9       Pi
                sta $35                      ; B71D= 85 35       .5
                rts                          ; B71F= 60          `

LB720:
                jsr LB30D                    ; B720= 20 0D B3     .3
                lda #$23                     ; B723= A9 23       )#
                jmp LB7E6                    ; B725= 4C E6 B7    Lf7

LB728:
                phy                          ; B728= 5A          Z
                phx                          ; B729= DA          Z
                pha                          ; B72A= 48          H
                bit $30                      ; B72B= 24 30       $0
                bmi LB74C                    ; B72D= 30 1D       0.
                cmp #$40                     ; B72F= C9 40       I@
                bcc LB739                    ; B731= 90 06       ..
                tay                          ; B733= A8          (
                bmi LB739                    ; B734= 30 03       0.
                clc                          ; B736= 18          .
                adc $33                      ; B737= 65 33       e3
LB739:
                tay                          ; B739= A8          (
                cpy #$60                     ; B73A= C0 60       @`
                bne LB740                    ; B73C= D0 02       P.
                lda #$BB                     ; B73E= A9 BB       );
LB740:
                cpy #$BB                     ; B740= C0 BB       @;
                bne LB746                    ; B742= D0 02       P.
                lda $32                      ; B744= A5 32       %2
LB746:
                cpy #$23                     ; B746= C0 23       @#
                bne LB74C                    ; B748= D0 02       P.
                lda $31                      ; B74A= A5 31       %1
LB74C:
                pha                          ; B74C= 48          H
                jsr LB821                    ; B74D= 20 21 B8     !8
                cpx zterm.numColumns                      ; B750= E4 38       d8
                beq LB75E                    ; B752= F0 0A       p.
LB754:
                pla                          ; B754= 68          h
                jsr OSWRCH                   ; B755= 20 EE FF     n.
                pha                          ; B758= 48          H
LB759:
                pla                          ; B759= 68          h
                pla                          ; B75A= 68          h
                plx                          ; B75B= FA          z
                ply                          ; B75C= 7A          z
                rts                          ; B75D= 60          `

LB75E:
                bit $34                      ; B75E= 24 34       $4
                bpl LB759                    ; B760= 10 F7       .w
                bit $35                      ; B762= 24 35       $5
                bpl LB754                    ; B764= 10 EE       .n
                pla                          ; B766= 68          h
                pha                          ; B767= 48          H
                cmp #$20                     ; B768= C9 20       I
                bcc LB754                    ; B76A= 90 E8       .h
                bne LB773                    ; B76C= D0 05       P.
                jsr OSNEWL                   ; B76E= 20 E7 FF     g.
                bra LB759                    ; B771= 80 E6       .f

LB773:
                lda #$0D                     ; B773= A9 0D       ).
                jsr OSWRCH                   ; B775= 20 EE FF     n.
                jsr LB4B9                    ; B778= 20 B9 B4     94
                ldy #$00                     ; B77B= A0 00        .
LB77D:
                phy                          ; B77D= 5A          Z
                lda #$08                     ; B77E= A9 08       ).
                jsr OSWRCH                   ; B780= 20 EE FF     n.
                lda #$87                     ; B783= A9 87       ).
                jsr OSBYTE                   ; B785= 20 F4 FF     t.
                ply                          ; B788= 7A          z
                txa                          ; B789= 8A          .
                cmp #$20                     ; B78A= C9 20       I
                beq LB79B                    ; B78C= F0 0D       p.
                sta $0440,y                  ; B78E= 99 40 04    .@.
                iny                          ; B791= C8          H
                cpy zterm.numColumns                      ; B792= C4 38       D8
                bne LB77D                    ; B794= D0 E7       Pg
                jsr OSNEWL                   ; B796= 20 E7 FF     g.
                bra LB754                    ; B799= 80 B9       .9

LB79B:
                phy                          ; B79B= 5A          Z
                lda #$00                     ; B79C= A9 00       ).
                jsr LB7E6                    ; B79E= 20 E6 B7     f7
                jsr OSNEWL                   ; B7A1= 20 E7 FF     g.
                ply                          ; B7A4= 7A          z
                iny                          ; B7A5= C8          H
LB7A6:
                dey                          ; B7A6= 88          .
                beq LB754                    ; B7A7= F0 AB       p+
                lda $043F,y                  ; B7A9= B9 3F 04    9?.
                jsr OSWRCH                   ; B7AC= 20 EE FF     n.
                bra LB7A6                    ; B7AF= 80 F5       .u

terminalINDnHandler:
                bcc LB7F9                    ; B7B1= 90 46       .F
LB7B3:
                sec                          ; B7B3= 38          8
                ror $19                      ; B7B4= 66 19       f.
LB7B6:
                ldx #$32                     ; B7B6= A2 32       "2
LB7B8:
                lda #$D5                     ; B7B8= A9 D5       )U
                jsr osbyteY00                    ; B7BA= 20 25 B8     %8
                phx                          ; B7BD= DA          Z
                ldx #$01                     ; B7BE= A2 01       ".
                lda #$D6                     ; B7C0= A9 D6       )V
                jsr osbyteY00                    ; B7C2= 20 25 B8     %8
                phx                          ; B7C5= DA          Z
                lda #$EC                     ; B7C6= A9 EC       )l
                ldx #$14                     ; B7C8= A2 14       ".
                jsr osbyteY00                    ; B7CA= 20 25 B8     %8
                lda #$07                     ; B7CD= A9 07       ).
                jsr OSWRCH                   ; B7CF= 20 EE FF     n.
                lda #$EC                     ; B7D2= A9 EC       )l
                jsr osbyteY00                    ; B7D4= 20 25 B8     %8
                plx                          ; B7D7= FA          z
                lda #$D6                     ; B7D8= A9 D6       )V
                jsr osbyteY00                    ; B7DA= 20 25 B8     %8
                plx                          ; B7DD= FA          z
                lda #$D5                     ; B7DE= A9 D5       )U
                bra osbyteY00                    ; B7E0= 80 43       .C

LB7E2:
                ldx #$8C                     ; B7E2= A2 8C       ".
                bra LB7B8                    ; B7E4= 80 D2       .R

LB7E6:
                tay                          ; B7E6= A8          (
                ldx #$0A                     ; B7E7= A2 0A       ".
                lda #$97                     ; B7E9= A9 97       ).
LB7EB:
                asl a                        ; B7EB= 0A          .
                bcs LB7EF                    ; B7EC= B0 01       0.
                iny                          ; B7EE= C8          H
LB7EF:
                lsr a                        ; B7EF= 4A          J
                jsr OSWRCH                   ; B7F0= 20 EE FF     n.
                lda LB7FA,y                  ; B7F3= B9 FA B7    9z7
                dex                          ; B7F6= CA          J
                bne LB7EB                    ; B7F7= D0 F2       Pr
LB7F9:
                rts                          ; B7F9= 60          `

LB7FA:
                ; PHP                        ; B7FA= 08          .
                ; ORA $06                    ; B7FB= 05 06       ..
                ; BRA LB807                  ; B7FD= 80 08       ..

                ; TSB $05                    ; B7FF= 04 05       ..
                ; BRK                        ; B801= 00          .
                ; BRK                        ; B802= 00          .
                ; ORA ($80,x)                ; B803= 01 80       ..
                ; PHP                        ; B805= 08          .
                ; TSB $06                    ; B806= 04 06       ..
                ; BRA LB812                  ; B808= 80 08       ..

                ; ORA $0A                    ; B80A= 05 0A       ..
                ; BRA LB816                  ; B80C= 80 08       ..

                ; BRK                        ; B80E= 00          .
                ; ORA $00                    ; B80F= 05 00       ..
                ; BRK                        ; B811= 00          .
                .byte $08
                .byte $05
                .byte $06
                .byte $80
                .byte $08
                .byte $04
                .byte $05
                .byte $00
                .byte $00
                .byte $01
                .byte $80
                .byte $08
                .byte $04
                .byte $06
                .byte $80
                .byte $08
                .byte $05
                .byte $0A
                .byte $80
                .byte $08
                .byte $00
                .byte $05
                .byte $00
                .byte $00

LB812:
;ORA (&80,x)      :\ B812= 01 80       ..
                .byte $01
                .byte $80
;PHP              :\ B814= 08          .
                .byte $08
;BRK              :\ B815= 00          .
                .byte $00
;.LB816
;ASL A            :\ B816= 0A          .
                .byte $0A
;BRA LB829        :\ B817= 80 10       ..
                .byte $80
                .byte $10
;ORA (&80,x)      :\ B819= 01 80       ..
                .byte $01
                .byte $80
;BPL LB79D        :\ B81B= 10 80       ..
                .byte $10
                .byte $80
                .byte $07                    ; B81D= 07          .
                .byte $00                    ; B81E= 00          .
                .byte $03                    ; B81F= 03          .
;BRA LB7CB        :\ B820= 80 A9       .)
; LDA &A2          :\ B822= A5 A2       %"
; BRK              :\ B824= 00          .
                .byte $80
LB821:
                lda #$A5
osbyteX00Y00:
                ldx #$00
osbyteY00:
                ldy #$00                     ; B825= A0 00        .
-
                jmp OSBYTE                   ; B827= 4C F4 FF    Lt.

LB82A:
                lda #$9C                     ; B82A= A9 9C       ).
                ldy #$9F                     ; B82C= A0 9F        .
                bra -

LB830:
                ldy #$00                     ; B830= A0 00        .
LB832:
                ldx #$FF                     ; B832= A2 FF       ".
                phx                          ; B834= DA          Z
LB835:
                pla                          ; B835= 68          h
                inc a                        ; B836= 1A          .
                pha                          ; B837= 48          H
                phy                          ; B838= 5A          Z
                jsr LB89E                    ; B839= 20 9E B8     .8
LB83C:
                cmp #'.'                     ; B83C= C9 2E       I.
                beq LB858                    ; B83E= F0 18       p.
                cmp #'@'                     ; B840= C9 40       I@
                bcs LB846                    ; B842= B0 02       0.
                lda #$00                     ; B844= A9 00       ).
LB846:
                and #$5F                     ; B846= 29 5F       )_
                inx                          ; B848= E8          h
                eor LB86B,x                  ; B849= 5D 6B B8    ]k8
                beq LB853                    ; B84C= F0 05       p.
                asl a                        ; B84E= 0A          .
                beq LB858                    ; B84F= F0 07       p.
                bra LB85D                    ; B851= 80 0A       ..

LB853:
                iny                          ; B853= C8          H
                lda ($F2),y                  ; B854= B1 F2       1r
                bra LB83C                    ; B856= 80 E4       .d

LB858:
                iny                          ; B858= C8          H
                pla                          ; B859= 68          h
                pla                          ; B85A= 68          h
                clc                          ; B85B= 18          .
                rts                          ; B85C= 60          `

LB85D:
                ply                          ; B85D= 7A          z
LB85E:
                lda LB86B,x                  ; B85E= BD 6B B8    =k8
                bne LB866                    ; B861= D0 03       P.
                sec                          ; B863= 38          8
                pla                          ; B864= 68          h
                rts                          ; B865= 60          `

LB866:
                bmi LB835                    ; B866= 30 CD       0M
                inx                          ; B868= E8          h
                bra LB85E                    ; B869= 80 F3       .s

LB86B:
                .byte $43                    ; B86B= 43          C
                .byte $4B                    ; B86C= 4B          K
                .byte $cc,$4d,$43            ; B86D= CC 4D 43    LMC
                .byte $cc,$50,$52            ; B870= CC 50 52    LPR
                .byte $4F                    ; B873= 4F          O
                .byte $D4                    ; B874= D4          T
                .byte $52,$46                ; B875= 52 46       RF
                .byte $C3                    ; B877= C3          C
                .byte $54                    ; B878= 54          T
                .byte $46,$c3                ; B879= 46 C3       FC
                .byte $57                    ; B87B= 57          W
                .byte $57                    ; B87C= 57          W
                .byte $cd,$41,$57            ; B87D= CD 41 57    MAW
                .byte $cd,$56,$44            ; B880= CD 56 44    MVD
                .byte $d5,$4d                ; B883= D5 4D       UM
                .byte $4F                    ; B885= 4F          O
                .byte $44                    ; B886= 44          D
                .byte $c5,$4f                ; B887= C5 4F       EO
                .byte $ce,$4f,$46            ; B889= CE 4F 46    NOF
                .byte $c6,$54                ; B88C= C6 54       FT
                .byte $45,$52                ; B88E= 45 52       ER
                .byte $4d,$49,$4e            ; B890= 4D 49 4E    MIN
                .byte $41,$cc                ; B893= 41 CC       AL
                .byte $42                    ; B895= 42          B
                .byte $42                    ; B896= 42          B
                .byte $C3                    ; B897= C3          C
                .byte $47                    ; B898= 47          G
                .byte $D3                    ; B899= D3          S
                .byte $54                    ; B89A= 54          T
                .byte $54                    ; B89B= 54          T
                .byte $D9
                .byte $00
LB89E:
                dey
LB89F:
                iny                          ; B89F= C8          H
                lda ($F2),y                  ; B8A0= B1 F2       1r
                cmp #$20                     ; B8A2= C9 20       I
                beq LB89F                    ; B8A4= F0 F9       py
                cmp #$0D                     ; B8A6= C9 0D       I.
                rts                          ; B8A8= 60          `

LB8A9:
                stz $3A                      ; B8A9= 64 3A       d:
                stz $3B                      ; B8AB= 64 3B       d;
LB8AD:
                cmp #$30                     ; B8AD= C9 30       I0
                bcc LB8B5                    ; B8AF= 90 04       ..
                cmp #$3A                     ; B8B1= C9 3A       I:
                bcc LB8B7                    ; B8B3= 90 02       ..
LB8B5:
                sec                          ; B8B5= 38          8
                rts                          ; B8B6= 60          `

LB8B7:
                sbc #$2F                     ; B8B7= E9 2F       i/
                pha                          ; B8B9= 48          H
                lda $3B                      ; B8BA= A5 3B       %;
                pha                          ; B8BC= 48          H
                lda $3A                      ; B8BD= A5 3A       %:
                asl a                        ; B8BF= 0A          .
                rol $3B                      ; B8C0= 26 3B       &;
                asl a                        ; B8C2= 0A          .
                rol $3B                      ; B8C3= 26 3B       &;
                clc                          ; B8C5= 18          .
                adc $3A                      ; B8C6= 65 3A       e:
                sta $3A                      ; B8C8= 85 3A       .:
                pla                          ; B8CA= 68          h
                adc $3B                      ; B8CB= 65 3B       e;
                sta $3B                      ; B8CD= 85 3B       .;
                asl $3A                      ; B8CF= 06 3A       .:
                rol $3B                      ; B8D1= 26 3B       &;
                pla                          ; B8D3= 68          h
                clc                          ; B8D4= 18          .
                adc $3A                      ; B8D5= 65 3A       e:
                sta $3A                      ; B8D7= 85 3A       .:
                bcc LB8DE                    ; B8D9= 90 03       ..
                inc $3B                      ; B8DB= E6 3B       f;
                clc                          ; B8DD= 18          .
LB8DE:
                rts                          ; B8DE= 60          `

; Unused space
; ============
                .align 256,$ff
                ; .byte $FF                    ; B8DF= FF          .
                ; .byte $FF                    ; B8E0= FF          .
                ; .byte $FF                    ; B8E1= FF          .
                ; .byte $FF                    ; B8E2= FF          .
                ; .byte $FF                    ; B8E3= FF          .
                ; .byte $FF                    ; B8E4= FF          .
                ; .byte $FF                    ; B8E5= FF          .
                ; .byte $FF                    ; B8E6= FF          .
                ; .byte $FF                    ; B8E7= FF          .
                ; .byte $FF                    ; B8E8= FF          .
                ; .byte $FF                    ; B8E9= FF          .
                ; .byte $FF                    ; B8EA= FF          .
                ; .byte $FF                    ; B8EB= FF          .
                ; .byte $FF                    ; B8EC= FF          .
                ; .byte $FF                    ; B8ED= FF          .
                ; .byte $FF                    ; B8EE= FF          .
                ; .byte $FF                    ; B8EF= FF          .
                ; .byte $FF                    ; B8F0= FF          .
                ; .byte $FF                    ; B8F1= FF          .
                ; .byte $FF                    ; B8F2= FF          .
                ; .byte $FF                    ; B8F3= FF          .
                ; .byte $FF                    ; B8F4= FF          .
                ; .byte $FF                    ; B8F5= FF          .
                ; .byte $FF                    ; B8F6= FF          .
                ; .byte $FF                    ; B8F7= FF          .
                ; .byte $FF                    ; B8F8= FF          .
                ; .byte $FF                    ; B8F9= FF          .
                ; .byte $FF                    ; B8FA= FF          .
                ; .byte $FF                    ; B8FB= FF          .
                ; .byte $FF                    ; B8FC= FF          .
                ; .byte $FF                    ; B8FD= FF          .
                ; .byte $FF                    ; B8FE= FF          .
                ; .byte $FF                    ; B8FF= FF          .

; Default font
; ============
LB900:
                .cerror (<LB900)!=0,"font data must be page aligned"
                ; CHR$32 -  
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$33 - !
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00000000

                ; CHR$34 - "
                .byte %01101100
                .byte %01101100
                .byte %01101100
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$35 - #
                .byte %00110110
                .byte %00110110
                .byte %01111111
                .byte %00110110
                .byte %01111111
                .byte %00110110
                .byte %00110110
                .byte %00000000

                ; CHR$36 - $
                .byte %00001100
                .byte %00111111
                .byte %01101000
                .byte %00111110
                .byte %00001011
                .byte %01111110
                .byte %00011000
                .byte %00000000

                ; CHR$37 - %
                .byte %01100000
                .byte %01100110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100110
                .byte %00000110
                .byte %00000000

                ; CHR$38 - &
                .byte %00111000
                .byte %01101100
                .byte %01101100
                .byte %00111000
                .byte %01101101
                .byte %01100110
                .byte %00111011
                .byte %00000000

                ; CHR$39 - '
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$40 - (
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %00110000
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00000000

                ; CHR$41 - )
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00001100
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %00000000

                ; CHR$42 - *
                .byte %00000000
                .byte %00011000
                .byte %01111110
                .byte %00111100
                .byte %01111110
                .byte %00011000
                .byte %00000000
                .byte %00000000

                ; CHR$43 - +
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00000000

                ; CHR$44 - ,
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00110000

                ; CHR$45 - -
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$46 - .
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$47 - /
                .byte %00000000
                .byte %00000110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100000
                .byte %00000000
                .byte %00000000

                ; CHR$48 - 0
                .byte %00111100
                .byte %01100110
                .byte %01101110
                .byte %01111110
                .byte %01110110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$49 - 1
                .byte %00011000
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00000000

                ; CHR$50 - 2
                .byte %00111100
                .byte %01100110
                .byte %00000110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01111110
                .byte %00000000

                ; CHR$51 - 3
                .byte %00111100
                .byte %01100110
                .byte %00000110
                .byte %00011100
                .byte %00000110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$52 - 4
                .byte %00001100
                .byte %00011100
                .byte %00111100
                .byte %01101100
                .byte %01111110
                .byte %00001100
                .byte %00001100
                .byte %00000000

                ; CHR$53 - 5
                .byte %01111110
                .byte %01100000
                .byte %01111100
                .byte %00000110
                .byte %00000110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$54 - 6
                .byte %00011100
                .byte %00110000
                .byte %01100000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$55 - 7
                .byte %01111110
                .byte %00000110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %00110000
                .byte %00110000
                .byte %00000000

                ; CHR$56 - 8
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$57 - 9
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000110
                .byte %00001100
                .byte %00111000
                .byte %00000000

                ; CHR$58 - :
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$59 - ;
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00110000

                ; CHR$60 - <
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100000
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00000000

                ; CHR$61 - =
                .byte %00000000
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$62 - >
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00000110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %00000000

                ; CHR$63 - ?
                .byte %00111100
                .byte %01100110
                .byte %00001100
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00000000

                ; CHR$64 - @
                .byte %00111100
                .byte %01100110
                .byte %01101110
                .byte %01101010
                .byte %01101110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$65 - A
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$66 - B
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %00000000

                ; CHR$67 - C
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$68 - D
                .byte %01111000
                .byte %01101100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01101100
                .byte %01111000
                .byte %00000000

                ; CHR$69 - E
                .byte %01111110
                .byte %01100000
                .byte %01100000
                .byte %01111100
                .byte %01100000
                .byte %01100000
                .byte %01111110
                .byte %00000000

                ; CHR$70 - F
                .byte %01111110
                .byte %01100000
                .byte %01100000
                .byte %01111100
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %00000000

                ; CHR$71 - G
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %01101110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$72 - H
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$73 - I
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00000000

                ; CHR$74 - J
                .byte %00111110
                .byte %00001100
                .byte %00001100
                .byte %00001100
                .byte %00001100
                .byte %01101100
                .byte %00111000
                .byte %00000000

                ; CHR$75 - K
                .byte %01100110
                .byte %01101100
                .byte %01111000
                .byte %01110000
                .byte %01111000
                .byte %01101100
                .byte %01100110
                .byte %00000000

                ; CHR$76 - L
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01111110
                .byte %00000000

                ; CHR$77 - M
                .byte %01100011
                .byte %01110111
                .byte %01111111
                .byte %01101011
                .byte %01101011
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$78 - N
                .byte %01100110
                .byte %01100110
                .byte %01110110
                .byte %01111110
                .byte %01101110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$79 - O
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$80 - P
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %00000000

                ; CHR$81 - Q
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01101010
                .byte %01101100
                .byte %00110110
                .byte %00000000

                ; CHR$82 - R
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %01101100
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$83 - S
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %00111100
                .byte %00000110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$84 - T
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$85 - U
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$86 - V
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00000000

                ; CHR$87 - W
                .byte %01100011
                .byte %01100011
                .byte %01101011
                .byte %01101011
                .byte %01111111
                .byte %01110111
                .byte %01100011
                .byte %00000000

                ; CHR$88 - X
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$89 - Y
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$90 - Z
                .byte %01111110
                .byte %00000110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100000
                .byte %01111110
                .byte %00000000

                ; CHR$91 - [
                .byte %01111100
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01111100
                .byte %00000000

                ; CHR$92 - \
                .byte %00000000
                .byte %01100000
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00000110
                .byte %00000000
                .byte %00000000

                ; CHR$93 - ]
                .byte %00111110
                .byte %00000110
                .byte %00000110
                .byte %00000110
                .byte %00000110
                .byte %00000110
                .byte %00111110
                .byte %00000000

                ; CHR$94 - ^
                .byte %00011000
                .byte %00111100
                .byte %01100110
                .byte %01000010
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$95 - _
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11111111

                ; CHR$96
                .byte %00011100
                .byte %00110110
                .byte %00110000
                .byte %01111100
                .byte %00110000
                .byte %00110000
                .byte %01111110
                .byte %00000000

                ; CHR$97 - a
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$98 - b
                .byte %01100000
                .byte %01100000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %00000000

                ; CHR$99 - c
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$100 - d
                .byte %00000110
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$101 - e
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$102 - f
                .byte %00011100
                .byte %00110000
                .byte %00110000
                .byte %01111100
                .byte %00110000
                .byte %00110000
                .byte %00110000
                .byte %00000000

                ; CHR$103 - g
                .byte %00000000
                .byte %00000000
                .byte %00111110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000110
                .byte %00111100

                ; CHR$104 - h
                .byte %01100000
                .byte %01100000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$105 - i
                .byte %00011000
                .byte %00000000
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$106 - j
                .byte %00011000
                .byte %00000000
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %01110000

                ; CHR$107 - k
                .byte %01100000
                .byte %01100000
                .byte %01100110
                .byte %01101100
                .byte %01111000
                .byte %01101100
                .byte %01100110
                .byte %00000000

                ; CHR$108 - l
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$109 - m
                .byte %00000000
                .byte %00000000
                .byte %00110110
                .byte %01111111
                .byte %01101011
                .byte %01101011
                .byte %01100011
                .byte %00000000

                ; CHR$110 - n
                .byte %00000000
                .byte %00000000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$111 - o
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$112 - p
                .byte %00000000
                .byte %00000000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %01100000
                .byte %01100000

                ; CHR$113 - q
                .byte %00000000
                .byte %00000000
                .byte %00111110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000110
                .byte %00000111

                ; CHR$114 - r
                .byte %00000000
                .byte %00000000
                .byte %01101100
                .byte %01110110
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %00000000

                ; CHR$115 - s
                .byte %00000000
                .byte %00000000
                .byte %00111110
                .byte %01100000
                .byte %00111100
                .byte %00000110
                .byte %01111100
                .byte %00000000

                ; CHR$116 - t
                .byte %00110000
                .byte %00110000
                .byte %01111100
                .byte %00110000
                .byte %00110000
                .byte %00110000
                .byte %00011100
                .byte %00000000

                ; CHR$117 - u
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$118 - v
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00000000

                ; CHR$119 - w
                .byte %00000000
                .byte %00000000
                .byte %01100011
                .byte %01101011
                .byte %01101011
                .byte %01111111
                .byte %00110110
                .byte %00000000

                ; CHR$120 - x
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00111100
                .byte %01100110
                .byte %00000000

                ; CHR$121 - y
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000110
                .byte %00111100

                ; CHR$122 - z
                .byte %00000000
                .byte %00000000
                .byte %01111110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01111110
                .byte %00000000

                ; CHR$123 - {
                .byte %00001100
                .byte %00011000
                .byte %00011000
                .byte %01110000
                .byte %00011000
                .byte %00011000
                .byte %00001100
                .byte %00000000

                ; CHR$124 - |
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$125 - }
                .byte %00110000
                .byte %00011000
                .byte %00011000
                .byte %00001110
                .byte %00011000
                .byte %00011000
                .byte %00110000
                .byte %00000000

                ; CHR$126 - ~
                .byte %00110001
                .byte %01101011
                .byte %01000110
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$127
chr127:
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                
                .if version==320

                ; CHR$128
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$129
                .byte %00111100
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$130
                .byte %00111111
                .byte %01100110
                .byte %01100110
                .byte %01111111
                .byte %01100110
                .byte %01100110
                .byte %01100111
                .byte %00000000

                ; CHR$131
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100110
                .byte %00111100
                .byte %01100000

                ; CHR$132
                .byte %00001100
                .byte %00011000
                .byte %01111110
                .byte %01100000
                .byte %01111100
                .byte %01100000
                .byte %01111110
                .byte %00000000

                ; CHR$133
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$134
                .byte %01100110
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$135
                .byte %01111110
                .byte %11000011
                .byte %10011101
                .byte %10110001
                .byte %10011101
                .byte %11000011
                .byte %01111110
                .byte %00000000

                ; CHR$136
                .byte %00000000
                .byte %00011000
                .byte %00111000
                .byte %01111111
                .byte %00111000
                .byte %00011000
                .byte %00000000
                .byte %00000000

                ; CHR$137
                .byte %00000000
                .byte %00011000
                .byte %00011100
                .byte %11111110
                .byte %00011100
                .byte %00011000
                .byte %00000000
                .byte %00000000

                ; CHR$138
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00111100
                .byte %00011000
                .byte %00000000

                ; CHR$139
                .byte %00000000
                .byte %00011000
                .byte %00111100
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$140
                .byte %00110000
                .byte %00011000
                .byte %00111100
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$141
                .byte %00110000
                .byte %00011000
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$142
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$143
                .byte %00111100
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$144
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$145
                .byte %00111100
                .byte %01100110
                .byte %00111100
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$146
                .byte %00000000
                .byte %00000000
                .byte %00111111
                .byte %00001101
                .byte %00111111
                .byte %01101100
                .byte %00111111
                .byte %00000000

                ; CHR$147
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100000
                .byte %01100110
                .byte %00111100
                .byte %01100000

                ; CHR$148
                .byte %00001100
                .byte %00011000
                .byte %00111100
                .byte %01100110
                .byte %01111110
                .byte %01100000
                .byte %00111100
                .byte %00000000

                ; CHR$149
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$150
                .byte %01100110
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$151
                .byte %00110000
                .byte %00011000
                .byte %00000000
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$152
                .byte %00111100
                .byte %01100110
                .byte %00000000
                .byte %00111000
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$153
                .byte %00110000
                .byte %00011000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$154
                .byte %00111100
                .byte %01100110
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$155
                .byte %00110000
                .byte %00011000
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$156
                .byte %00111100
                .byte %01100110
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000000

                ; CHR$157
                .byte %01100110
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111110
                .byte %00000110
                .byte %00111100

                ; CHR$158
                .byte %00000000
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %01100110
                .byte %00000000

                ; CHR$159
                .byte %00111100
                .byte %01100000
                .byte %00111100
                .byte %01100110
                .byte %00111100
                .byte %00000110
                .byte %00111100
                .byte %00000000

                ; CHR$160
                .byte %00111100
                .byte %01100110
                .byte %00111100
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$161
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$162
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011111
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$163
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011111
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$164
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11111000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$165
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$166
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11111111
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$167
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11111111
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$168
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$169
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$170
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011111
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$171
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011111
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$172
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %11111000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$173
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %11111000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$174
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %11111111
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$175
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %11111111
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$176
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000111
                .byte %00001100
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$177
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %11100000
                .byte %00110000
                .byte %00011000
                .byte %00011000
                .byte %00011000

                ; CHR$178
                .byte %00011000
                .byte %00011000
                .byte %00001100
                .byte %00000111
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$179
                .byte %00011000
                .byte %00011000
                .byte %00110000
                .byte %11100000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$180
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00110000
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$181
                .byte %00011000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$182
                .byte %00110110
                .byte %01101100
                .byte %00000000
                .byte %01100110
                .byte %01110110
                .byte %01101110
                .byte %01100110
                .byte %00000000

                ; CHR$183
                .byte %00110110
                .byte %01101100
                .byte %00000000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$184
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$185
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00000000

                ; CHR$186
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$187
                .byte %00110000
                .byte %00011000
                .byte %00001100
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$188
                .byte %00111111
                .byte %01111011
                .byte %01111011
                .byte %00111011
                .byte %00011011
                .byte %00011011
                .byte %00011111
                .byte %00000000

                ; CHR$189
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %00000000
                .byte %00000000

                ; CHR$190
                .byte %00000011
                .byte %00000011
                .byte %00000110
                .byte %00000110
                .byte %01110110
                .byte %00011100
                .byte %00001100
                .byte %00000000

                ; CHR$191
                .byte %10101010
                .byte %01010101
                .byte %10101010
                .byte %01010101
                .byte %10101010
                .byte %01010101
                .byte %10101010
                .byte %01010101

                ; CHR$192
                .byte %00111110
                .byte %01100011
                .byte %01100111
                .byte %01101011
                .byte %01110011
                .byte %01100011
                .byte %00111110
                .byte %00000000

                ; CHR$193
                .byte %00011100
                .byte %00110110
                .byte %01100011
                .byte %01100011
                .byte %01111111
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$194
                .byte %01111110
                .byte %00110011
                .byte %00110011
                .byte %00111110
                .byte %00110011
                .byte %00110011
                .byte %01111110
                .byte %00000000

                ; CHR$195
                .byte %01111111
                .byte %01100011
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %01100000
                .byte %00000000

                ; CHR$196
                .byte %00011100
                .byte %00011100
                .byte %00110110
                .byte %00110110
                .byte %01100011
                .byte %01100011
                .byte %01111111
                .byte %00000000

                ; CHR$197
                .byte %01111111
                .byte %00110011
                .byte %00110000
                .byte %00111110
                .byte %00110000
                .byte %00110011
                .byte %01111111
                .byte %00000000

                ; CHR$198
                .byte %01111110
                .byte %01100110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100110
                .byte %01111110
                .byte %00000000

                ; CHR$199
                .byte %01110111
                .byte %00110011
                .byte %00110011
                .byte %00111111
                .byte %00110011
                .byte %00110011
                .byte %01110111
                .byte %00000000

                ; CHR$200
                .byte %00111110
                .byte %01100011
                .byte %01100011
                .byte %01111111
                .byte %01100011
                .byte %01100011
                .byte %00111110
                .byte %00000000

                ; CHR$201
                .byte %00111100
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$202
                .byte %01100011
                .byte %01100110
                .byte %01101100
                .byte %01111000
                .byte %01101100
                .byte %01100110
                .byte %01100011
                .byte %00000000

                ; CHR$203
                .byte %00011100
                .byte %00011100
                .byte %00110110
                .byte %00110110
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$204
                .byte %01100011
                .byte %01110111
                .byte %01111111
                .byte %01101011
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$205
                .byte %01100011
                .byte %01110011
                .byte %01111011
                .byte %01101111
                .byte %01100111
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$206
                .byte %01111110
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %00000000
                .byte %00000000
                .byte %01111110
                .byte %00000000

                ; CHR$207
                .byte %00111110
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %00111110
                .byte %00000000

                ; CHR$208
                .byte %01111111
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00000000

                ; CHR$209
                .byte %01111110
                .byte %00110011
                .byte %00110011
                .byte %00111110
                .byte %00110000
                .byte %00110000
                .byte %01111000
                .byte %00000000

                ; CHR$210
                .byte %01111111
                .byte %01100011
                .byte %00110000
                .byte %00011000
                .byte %00110000
                .byte %01100011
                .byte %01111111
                .byte %00000000

                ; CHR$211
                .byte %01111110
                .byte %01011010
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$212
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00011000
                .byte %00011000
                .byte %00111100
                .byte %00000000

                ; CHR$213
                .byte %00111110
                .byte %00001000
                .byte %00111110
                .byte %01101011
                .byte %00111110
                .byte %00001000
                .byte %00111110
                .byte %00000000

                ; CHR$214
                .byte %01100011
                .byte %01100011
                .byte %00110110
                .byte %00011100
                .byte %00110110
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$215
                .byte %00111110
                .byte %00001000
                .byte %01101011
                .byte %01101011
                .byte %00111110
                .byte %00001000
                .byte %00111110
                .byte %00000000

                ; CHR$216
                .byte %00111110
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %00110110
                .byte %00110110
                .byte %01100011
                .byte %00000000

                ; CHR$217
                .byte %01111111
                .byte %01100011
                .byte %01100011
                .byte %00110110
                .byte %00110110
                .byte %00011100
                .byte %00011100
                .byte %00000000

                ; CHR$218
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00000000
                .byte %01111110
                .byte %00000000

                ; CHR$219
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %01111110
                .byte %00011000
                .byte %00011000

                ; CHR$220
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00000000

                ; CHR$221
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00000000

                ; CHR$222
                .byte %00000000
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$223
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000000

                ; CHR$224
                .byte %00000000
                .byte %00000011
                .byte %00111110
                .byte %01100111
                .byte %01101011
                .byte %01110011
                .byte %00111110
                .byte %01100000

                ; CHR$225
                .byte %00000000
                .byte %00000000
                .byte %00111011
                .byte %01101110
                .byte %01100110
                .byte %01101110
                .byte %00111011
                .byte %00000000

                ; CHR$226
                .byte %00011110
                .byte %00110011
                .byte %00110011
                .byte %00111110
                .byte %00110011
                .byte %00110011
                .byte %00111110
                .byte %01100000

                ; CHR$227
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %00110110
                .byte %00011100
                .byte %00011000
                .byte %00110000
                .byte %00110000

                ; CHR$228
                .byte %00111100
                .byte %01100000
                .byte %00110000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$229
                .byte %00000000
                .byte %00000000
                .byte %00011110
                .byte %00110000
                .byte %00011100
                .byte %00110000
                .byte %00011110
                .byte %00000000

                ; CHR$230
                .byte %00111110
                .byte %00001100
                .byte %00011000
                .byte %00110000
                .byte %01100000
                .byte %01100000
                .byte %00111110
                .byte %00000110

                ; CHR$231
                .byte %00000000
                .byte %00000000
                .byte %01111100
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00000110
                .byte %00000110

                ; CHR$232
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01111110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$233
                .byte %00000000
                .byte %00000000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00001100
                .byte %00000000

                ; CHR$234
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %01101100
                .byte %01111000
                .byte %01101100
                .byte %01100110
                .byte %00000000

                ; CHR$235
                .byte %01100000
                .byte %00110000
                .byte %00011000
                .byte %00011100
                .byte %00110110
                .byte %01100011
                .byte %01100011
                .byte %00000000

                ; CHR$236
                .byte %00000000
                .byte %00000000
                .byte %00110011
                .byte %00110011
                .byte %00110011
                .byte %00110011
                .byte %00111110
                .byte %01100000

                ; CHR$237
                .byte %00000000
                .byte %00000000
                .byte %01100011
                .byte %00110011
                .byte %00011011
                .byte %00011110
                .byte %00011100
                .byte %00000000

                ; CHR$238
                .byte %00111100
                .byte %01100000
                .byte %01100000
                .byte %00111100
                .byte %01100000
                .byte %01100000
                .byte %00111110
                .byte %00000110

                ; CHR$239
                .byte %00000000
                .byte %00000000
                .byte %00111110
                .byte %01100011
                .byte %01100011
                .byte %01100011
                .byte %00111110
                .byte %00000000

                ; CHR$240
                .byte %00000000
                .byte %00000000
                .byte %01111111
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00110110
                .byte %00000000

                ; CHR$241
                .byte %00000000
                .byte %00000000
                .byte %00111100
                .byte %01100110
                .byte %01100110
                .byte %01111100
                .byte %01100000
                .byte %01100000

                ; CHR$242
                .byte %00000000
                .byte %00000000
                .byte %00111111
                .byte %01100110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$243
                .byte %00000000
                .byte %00000000
                .byte %01111110
                .byte %00011000
                .byte %00011000
                .byte %00011000
                .byte %00001100
                .byte %00000000

                ; CHR$244
                .byte %00000000
                .byte %00000000
                .byte %01110011
                .byte %00110011
                .byte %00110011
                .byte %00110011
                .byte %00011110
                .byte %00000000

                ; CHR$245
                .byte %00000000
                .byte %00000000
                .byte %00111110
                .byte %01101011
                .byte %01101011
                .byte %00111110
                .byte %00011000
                .byte %00011000

                ; CHR$246
                .byte %00000000
                .byte %00000000
                .byte %01100110
                .byte %00110110
                .byte %00011100
                .byte %00011100
                .byte %00110110
                .byte %00110011

                ; CHR$247
                .byte %00000000
                .byte %00000000
                .byte %01100011
                .byte %01101011
                .byte %01101011
                .byte %00111110
                .byte %00011000
                .byte %00011000

                ; CHR$248
                .byte %00000000
                .byte %00000000
                .byte %00110110
                .byte %01100011
                .byte %01101011
                .byte %01111111
                .byte %00110110
                .byte %00000000

                ; CHR$249
                .byte %00111000
                .byte %00001100
                .byte %00000110
                .byte %00111110
                .byte %01100110
                .byte %01100110
                .byte %00111100
                .byte %00000000

                ; CHR$250
                .byte %00000000
                .byte %00110001
                .byte %01101011
                .byte %01000110
                .byte %00000000
                .byte %01111111
                .byte %00000000
                .byte %00000000

                ; CHR$251
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %01111110
                .byte %00000000
                .byte %00000000

                ; CHR$252
                .byte %00000111
                .byte %00011100
                .byte %01110000
                .byte %00011100
                .byte %00000111
                .byte %00000000
                .byte %01111111
                .byte %00000000

                ; CHR$253
                .byte %00000110
                .byte %00001100
                .byte %01111110
                .byte %00011000
                .byte %01111110
                .byte %00110000
                .byte %01100000
                .byte %00000000

                ; CHR$254
                .byte %01110000
                .byte %00011100
                .byte %00000111
                .byte %00011100
                .byte %01110000
                .byte %00000000
                .byte %01111111
                .byte %00000000

                ; CHR$255
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .byte %11111111
                .endif
                .endblock
